["src/nvim/getchar.c", ["", "/*", " * getchar.c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * These buffers are used for storing:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "#define MINIMAL_SIZE 20                 /* minimal size for b_str */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "static int typeahead_char = 0;          /* typeahead char that's not flushed */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * when block_redo is TRUE redo buffer will not be changed"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * List used for abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static mapblock_T       *first_abbr = NULL; /* first entry in abbrlist */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "static int KeyNoremap = 0;                  /* remapping flags */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Variables used by vgetorpeek() and flush_buffers()"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "#define RM_YES          0       /* tb_noremap: remap */", "#define RM_NONE         1       /* tb_noremap: don't remap */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["#define RM_YES          0       /* tb_noremap: remap */", "#define RM_NONE         1       /* tb_noremap: don't remap */", "#define RM_SCRIPT       2       /* tb_noremap: remap local script mappings */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["#define RM_NONE         1       /* tb_noremap: don't remap */", "#define RM_SCRIPT       2       /* tb_noremap: remap local script mappings */", "#define RM_ABBR         4       /* tb_noremap: don't remap, do abbrev. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["#define RM_SCRIPT       2       /* tb_noremap: remap local script mappings */", "#define RM_ABBR         4       /* tb_noremap: don't remap, do abbrev. */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/* typebuf.tb_buf has three parts: room in front (for result of mappings), the", " * middle for typeahead and room for new characters (which needs to be 3 *"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["#define TYPELEN_INIT    (5 * (MAXMAPLEN + 3))", "static char_u typebuf_init[TYPELEN_INIT];       /* initial typebuf.tb_buf */", "static char_u noremapbuf_init[TYPELEN_INIT];    /* initial typebuf.tb_noremap */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["static char_u typebuf_init[TYPELEN_INIT];       /* initial typebuf.tb_buf */", "static char_u noremapbuf_init[TYPELEN_INIT];    /* initial typebuf.tb_noremap */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free and clear a buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of a buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the record buffer as a single string"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * Remove the characters that were added the last time, these must be the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * When stopping recording from Insert mode with CTRL-O q, also remove the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (len > 0 && restart_edit != 0 && p[len - 1] == Ctrl_O)", "    p[len - 1] = NUL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return the contents of the redo buffer as a single string."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Add number \"n\" to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Add character 'c' to buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = read_readbuf(&readbuf1, advance);", "  if (c == NUL)", "    c = read_readbuf(&readbuf2, advance);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Prepare the read buffers for reading (if they contain something)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the stuff buffer is empty."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if readbuf1 is empty.  There may still be redo characters in"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Set a typeahead character that won't be flushed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove the contents of the stuff buffer and the mapped characters in the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  start_stuff();", "  while (read_readbuffers(TRUE) != NUL) {", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * The previous contents of the redo buffer is kept in old_redobuffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Discard the contents of the redo buffer and restore the previous redo"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    start_stuff();", "    while (read_readbuffers(TRUE) != NUL) {", "    }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Append \"s\" to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_char_buff(&redobuff, c);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (!block_redo)", "    add_num_buff(&redobuff, n);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Append string \"s\" to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Stuff \"s\" into the stuff buffer, leaving special key codes unmodified and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a character to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    c = *p;", "    if (c == NUL)             /* cannot happen? */", "      break;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    c = *p;", "    if (c == NUL)             /* cannot happen? */", "      break;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* copy the buffer name, if present */", "  if (c == '\"') {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /* if a numbered buffer is used, increment the number */", "    if (c >= '1' && c < '9')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    /* if a numbered buffer is used, increment the number */", "    if (c >= '1' && c < '9')", "      ++c;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (c >= '1' && c < '9')", "      ++c;", "    add_char_buff(&readbuf2, c);"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (c == 'v') {   /* redo Visual */", "    VIsual = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* copy from the redo buffer into the stuff buffer */", "  add_char_buff(&readbuf2, c);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Initialize typebuf.tb_buf to point to typebuf_init."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * insert a string in position 'offset' in the typeahead buffer (for \"@r\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  init_typebuf();", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    newlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);", "    if (newlen < 0) {               /* string is getting too long */", "      EMSG(_(e_toocompl));          /* also calls flush_buffers */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (newlen < 0) {               /* string is getting too long */", "      EMSG(_(e_toocompl));          /* also calls flush_buffers */", "      setcursor();"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff, typebuf.tb_noremap + typebuf.tb_off,", "        (size_t)offset);", "    memmove(s2 + newoff + offset + addlen,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(s2 + newoff + offset + addlen,", "        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + typebuf.tb_off + offset,", "        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        (size_t)(typebuf.tb_len - offset));", "    if (typebuf.tb_noremap != noremapbuf_init)", "      xfree(typebuf.tb_noremap);"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* If noremap == REMAP_SCRIPT: do remap script-local mappings. */", "  if (noremap == REMAP_SCRIPT)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  /* If noremap == REMAP_SCRIPT: do remap script-local mappings. */", "  if (noremap == REMAP_SCRIPT)", "    val = RM_SCRIPT;"], "readability/braces"]
["src/nvim/getchar.c", ["    val = RM_SCRIPT;", "  else if (noremap == REMAP_SKIP)", "    val = RM_ABBR;"], "readability/braces"]
["src/nvim/getchar.c", ["    val = RM_ABBR;", "  else", "    val = RM_NONE;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /*", "   * Adjust typebuf.tb_noremap[] for the new characters:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (noremap == REMAP_SKIP)", "    nrm = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = 1;", "  else if (noremap < 0)", "    nrm = addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = addlen;", "  else", "    nrm = noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/braces"]
["src/nvim/getchar.c", ["    nrm = noremap;", "  for (i = 0; i < addlen; ++i)", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/increment"]
["src/nvim/getchar.c", ["", "  /* tb_maplen and tb_silent only remember the length of mapped and/or", "   * silent mappings at the start of the buffer, assuming that a mapped"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * sequence doesn't result in typed characters. */", "  if (nottyped || typebuf.tb_maplen > offset)", "    typebuf.tb_maplen += addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["  }", "  if (typebuf.tb_no_abbr_cnt && offset == 0)    /* and not used for abbrev.s */", "    typebuf.tb_no_abbr_cnt += addlen;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  }", "  if (typebuf.tb_no_abbr_cnt && offset == 0)    /* and not used for abbrev.s */", "    typebuf.tb_no_abbr_cnt += addlen;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Put character \"c\" back into the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the typeahead buffer was changed (while waiting for a"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "int ", "typebuf_changed ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["int ", "typebuf_changed (", "    int tb_change_cnt              /* old value of typebuf.tb_change_cnt */"], "whitespace/parens"]
["src/nvim/getchar.c", ["typebuf_changed (", "    int tb_change_cnt              /* old value of typebuf.tb_change_cnt */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                                || typebuf_was_filled", "                                );", "}"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if there are no characters in the typeahead buffer that have"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the number of characters that are mapped (or not typed)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  if (len == 0)", "    return;             /* nothing to do */"], "readability/braces"]
["src/nvim/getchar.c", ["  if (len == 0)", "    return;             /* nothing to do */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Easy case: Just increase typebuf.tb_off."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (offset == 0 && typebuf.tb_buflen - (typebuf.tb_off + len)", "      >= 3 * MAXMAPLEN + 3)"], "readability/braces"]
["src/nvim/getchar.c", ["    typebuf.tb_off += len;", "  /*", "   * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["    i = typebuf.tb_off + offset;", "    /*", "     * Leave some extra room at the end to avoid reallocation."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_buf + MAXMAPLEN,", "          typebuf.tb_buf + typebuf.tb_off, (size_t)offset);", "      memmove(typebuf.tb_noremap + MAXMAPLEN,"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      memmove(typebuf.tb_noremap + MAXMAPLEN,", "          typebuf.tb_noremap + typebuf.tb_off, (size_t)offset);", "      typebuf.tb_off = MAXMAPLEN;"], "whitespace/alignment"]
["src/nvim/getchar.c", ["    memmove(typebuf.tb_noremap + typebuf.tb_off + offset,", "        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));"], "whitespace/alignment"]
["src/nvim/getchar.c", ["        typebuf.tb_noremap + i + len,", "        (size_t)(typebuf.tb_len - offset));", "  }"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "  if (typebuf.tb_maplen > offset) {             /* adjust tb_maplen */", "    if (typebuf.tb_maplen < offset + len)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (typebuf.tb_maplen > offset) {             /* adjust tb_maplen */", "    if (typebuf.tb_maplen < offset + len)", "      typebuf.tb_maplen = offset;"], "readability/braces"]
["src/nvim/getchar.c", ["      typebuf.tb_maplen = offset;", "    else", "      typebuf.tb_maplen -= len;"], "readability/braces"]
["src/nvim/getchar.c", ["  }", "  if (typebuf.tb_silent > offset) {             /* adjust tb_silent */", "    if (typebuf.tb_silent < offset + len)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (typebuf.tb_silent > offset) {             /* adjust tb_silent */", "    if (typebuf.tb_silent < offset + len)", "      typebuf.tb_silent = offset;"], "readability/braces"]
["src/nvim/getchar.c", ["      typebuf.tb_silent = offset;", "    else", "      typebuf.tb_silent -= len;"], "readability/braces"]
["src/nvim/getchar.c", ["  }", "  if (typebuf.tb_no_abbr_cnt > offset) {        /* adjust tb_no_abbr_cnt */", "    if (typebuf.tb_no_abbr_cnt < offset + len)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (typebuf.tb_no_abbr_cnt > offset) {        /* adjust tb_no_abbr_cnt */", "    if (typebuf.tb_no_abbr_cnt < offset + len)", "      typebuf.tb_no_abbr_cnt = offset;"], "readability/braces"]
["src/nvim/getchar.c", ["      typebuf.tb_no_abbr_cnt = offset;", "    else", "      typebuf.tb_no_abbr_cnt -= len;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* Reset the flag that text received from a client or from feedkeys()", "   * was inserted in the typeahead buffer. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Write typed characters to script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* output \"debug mode\" message next time in debug mode */", "  debug_did_msg = FALSE;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  /* output \"debug mode\" message next time in debug mode */", "  debug_did_msg = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "  /* Since characters have been typed, consider the following to be in", "   * another mapping.  Search string will be kept in history. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * another mapping.  Search string will be kept in history. */", "  ++maptick;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Sync undo.  Called when typed characters are obtained from the typeahead"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if ((!(State & (INSERT + CMDLINE)) || arrow_used)", "      && scriptin[curscript] == NULL)"], "readability/braces"]
["src/nvim/getchar.c", ["      && scriptin[curscript] == NULL)", "    u_sync(FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Make \"typebuf\" empty and allocate new buffers."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  typebuf.tb_no_abbr_cnt = 0;", "  if (++typebuf.tb_change_cnt == 0)", "    typebuf.tb_change_cnt = 1;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Free the buffers of \"typebuf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * When doing \":so! file\", the current typeahead needs to be saved, and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Save all three kinds of typeahead, so that the user must type at a prompt."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Restore the typeahead to what it was before calling save_typeahead()."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Open a new script file for the \":source!\" command."], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "void ", "openscript ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "openscript (", "    char_u *name,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    char_u *name,", "    int directly                   /* when TRUE execute directly */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  if (scriptin[curscript] != NULL)      /* already reading script */", "    ++curscript;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  if (scriptin[curscript] != NULL)      /* already reading script */", "    ++curscript;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (scriptin[curscript] != NULL)      /* already reading script */", "    ++curscript;", "  /* use NameBuff for expanded name */"], "readability/increment"]
["src/nvim/getchar.c", ["    ++curscript;", "  /* use NameBuff for expanded name */", "  expand_env(name, NameBuff, MAXPATHL);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Execute the commands from the file right now when using \":source!\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    State = NORMAL;", "    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */", "    restart_edit = 0;           /* don't go to Insert mode */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    State = NORMAL;", "    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */", "    restart_edit = 0;           /* don't go to Insert mode */"], "readability/bool"]
["src/nvim/getchar.c", ["    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */", "    restart_edit = 0;           /* don't go to Insert mode */", "    p_im = FALSE;               /* don't use 'insertmode' */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    restart_edit = 0;           /* don't go to Insert mode */", "    p_im = FALSE;               /* don't use 'insertmode' */", "    clear_oparg(&oa);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    restart_edit = 0;           /* don't go to Insert mode */", "    p_im = FALSE;               /* don't use 'insertmode' */", "    clear_oparg(&oa);"], "readability/bool"]
["src/nvim/getchar.c", ["    clear_oparg(&oa);", "    finish_op = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Close the currently active input script."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  scriptin[curscript] = NULL;", "  if (curscript > 0)", "    --curscript;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (curscript > 0)", "    --curscript;", "}"], "readability/increment"]
["src/nvim/getchar.c", ["{", "  while (scriptin[0] != NULL)", "    closescript();"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE when reading keys from a script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Get the next input character."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * If a character was put back with vungetc, it was already processed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        c = TO_SPECIAL(c2, c);", "", "      }"], "whitespace/blank_line"]
["src/nvim/getchar.c", ["", "  /*", "   * In the main loop \"may_garbage_collect\" can be set to do garbage"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like vgetc(), but never return a NUL when called recursively, get a key"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like safe_vgetc(), but loop to handle K_IGNORE."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if a character is available, such that vgetc() will not block."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (old_char != -1)", "    return old_char;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check if any character is available, also half an escape sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  c = vpeekc();", "  if (c == NUL && typebuf.tb_len > 0)", "    c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Call vpeekc() without causing anything to be mapped."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "void ", "vungetc ( /* unget one character (can only be done once!) */"], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "vungetc ( /* unget one character (can only be done once!) */", "    int c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["void ", "vungetc ( /* unget one character (can only be done once!) */", "    int c"], "whitespace/parens"]
["src/nvim/getchar.c", ["  int mp_match_len = 0;", "  int timedout = FALSE;                     /* waited for more than 1 second", "                                                for mapping to complete */"], "readability/multiline_comment"]
["src/nvim/getchar.c", ["  int mp_match_len = 0;", "  int timedout = FALSE;                     /* waited for more than 1 second", "                                                for mapping to complete */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  int mp_match_len = 0;", "  int timedout = FALSE;                     /* waited for more than 1 second", "                                                for mapping to complete */"], "readability/bool"]
["src/nvim/getchar.c", ["                                                for mapping to complete */", "  int mapdepth = 0;                 /* check for recursive mapping */", "  int mode_deleted = FALSE;             /* set when mode has been deleted */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  int mapdepth = 0;                 /* check for recursive mapping */", "  int mode_deleted = FALSE;             /* set when mode has been deleted */", "  int local_State;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  int mapdepth = 0;                 /* check for recursive mapping */", "  int mode_deleted = FALSE;             /* set when mode has been deleted */", "  int local_State;"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * This function doesn't work very well when called recursively.  This may"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  if (vgetc_busy > 0", "      && ex_normal_busy == 0"], "readability/braces"]
["src/nvim/getchar.c", ["", "  ++vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (advance)", "    KeyStuffed = FALSE;"], "readability/braces"]
["src/nvim/getchar.c", ["  if (advance)", "    KeyStuffed = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["  do {", "    /*", "     * get a character: 1. from the stuffbuffer"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      c = typeahead_char;", "      if (advance)", "        typeahead_char = 0;"], "readability/braces"]
["src/nvim/getchar.c", ["      }", "      if (typebuf.tb_no_abbr_cnt == 0)", "        typebuf.tb_no_abbr_cnt = 1;             /* no abbreviations now */"], "readability/braces"]
["src/nvim/getchar.c", ["      if (typebuf.tb_no_abbr_cnt == 0)", "        typebuf.tb_no_abbr_cnt = 1;             /* no abbreviations now */", "    } else {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    } else {", "      /*", "       * Loop until we either find a matching mapped key, or we"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      for (;; ) {", "        /*", "         * os_breakcheck() is slow, don't use it too often when"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        if (typebuf.tb_maplen)", "          line_breakcheck();"], "readability/braces"]
["src/nvim/getchar.c", ["          line_breakcheck();", "        else", "          os_breakcheck();                      /* check for CTRL-C */"], "readability/braces"]
["src/nvim/getchar.c", ["        else", "          os_breakcheck();                      /* check for CTRL-C */", "        keylen = 0;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (advance) {", "            /* Also record this character, it might be needed to", "             * get out of Insert mode. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        } else if (typebuf.tb_len > 0) {", "          /*", "           * Check for a mappable key sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /* First try buffer-local mappings. */", "            mp = curbuf->b_maphash[MAP_HASH(local_State, c1)];"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            if (mp == NULL) {", "              /* There are no buffer-local mappings. */", "              mp = mp2;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /*", "             * Loop until a partly matching mapping is found or"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                 (mp = mp->m_next)) {", "              /*", "               * Only consider an entry if the first character"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                int c2;", "                /* find the match length of this mapping */", "                for (mlen = 1; mlen < typebuf.tb_len; ++mlen) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                /* find the match length of this mapping */", "                for (mlen = 1; mlen < typebuf.tb_len; ++mlen) {", "                  c2 = typebuf.tb_buf[typebuf.tb_off + mlen];"], "readability/increment"]
["src/nvim/getchar.c", ["                  c2 = typebuf.tb_buf[typebuf.tb_off + mlen];", "                  if (nomap > 0)", "                    --nomap;"], "readability/braces"]
["src/nvim/getchar.c", ["                  if (nomap > 0)", "                    --nomap;", "                  else if (c2 == K_SPECIAL)"], "readability/increment"]
["src/nvim/getchar.c", ["                    --nomap;", "                  else if (c2 == K_SPECIAL)", "                    nomap = 2;"], "readability/braces"]
["src/nvim/getchar.c", ["                    nomap = 2;", "                  else", "                    LANGMAP_ADJUST(c2, TRUE);"], "readability/braces"]
["src/nvim/getchar.c", ["                  else", "                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)"], "readability/bool"]
["src/nvim/getchar.c", ["                    LANGMAP_ADJUST(c2, TRUE);", "                  if (mp->m_keys[mlen] != c2)", "                    break;"], "readability/braces"]
["src/nvim/getchar.c", ["", "                /* Don't allow mapping the first byte(s) of a", "                 * multi-byte char.  Happens when mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                        && typebuf.tb_len < keylen)) {", "                  /*", "                   * If only script-local mappings are"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                  s = typebuf.tb_noremap + typebuf.tb_off;", "                  if (*s == RM_SCRIPT", "                      && (mp->m_keys[0] != K_SPECIAL"], "readability/braces"]
["src/nvim/getchar.c", ["                    continue;", "                  /*", "                   * If one of the typed keys cannot be"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                   */", "                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))"], "readability/braces"]
["src/nvim/getchar.c", ["                  for (n = mlen; --n >= 0; )", "                    if (*s++ & (RM_NONE|RM_ABBR))", "                      break;"], "readability/braces"]
["src/nvim/getchar.c", ["                      break;", "                  if (n >= 0)", "                    continue;"], "readability/braces"]
["src/nvim/getchar.c", ["                                       && mp_match->m_nowait)) {", "                      /* break at a partly match */", "                      keylen = KEYLEN_PART_MAP;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /* If no partly match found, use the longest full", "             * match. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /* Need more chars for partly match. */", "            if (mlen == typebuf.tb_len)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            /* Need more chars for partly match. */", "            if (mlen == typebuf.tb_len)", "              keylen = KEYLEN_PART_KEY;"], "readability/braces"]
["src/nvim/getchar.c", ["              keylen = KEYLEN_PART_KEY;", "            else if (max_mlen < mlen)", "              /* no match, may have to check for termcode at"], "readability/braces"]
["src/nvim/getchar.c", ["            else if (max_mlen < mlen)", "              /* no match, may have to check for termcode at", "               * next character */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "          /* complete match */", "          if (keylen >= 0 && keylen <= typebuf.tb_len) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            cmd_silent = (typebuf.tb_silent > 0);", "            del_typebuf(keylen, 0);             /* remove the mapped keys */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Put the replacement string in front of mapstr."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              EMSG(_(\"E223: recursive mapping\"));", "              if (State & CMDLINE)", "                redrawcmdline();"], "readability/braces"]
["src/nvim/getchar.c", ["                redrawcmdline();", "              else", "                setcursor();"], "readability/braces"]
["src/nvim/getchar.c", ["", "            /*", "             * In Select mode and a Visual mode mapping is used:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                && (mp->m_mode & VISUAL)) {", "              VIsual_select = FALSE;", "              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,"], "readability/bool"]
["src/nvim/getchar.c", ["              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,", "                  0, TRUE, FALSE);", "            }"], "whitespace/alignment"]
["src/nvim/getchar.c", ["              (void)ins_typebuf(K_SELECT_STRING, REMAP_NONE,", "                  0, TRUE, FALSE);", "            }"], "readability/bool"]
["src/nvim/getchar.c", ["", "            /* Copy the values from *mp that are used, because", "             * evaluating the expression may invoke a function"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            save_m_silent = mp->m_silent;", "            save_m_keys = NULL;              /* only saved when needed */", "            save_m_str = NULL;              /* only saved when needed */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            save_m_keys = NULL;              /* only saved when needed */", "            save_m_str = NULL;              /* only saved when needed */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Handle \":map <expr>\": evaluate the {rhs} as an"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "            /*", "             * Insert the 'to' part in the typebuf.tb_buf."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["             */", "            if (s == NULL)", "              i = FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = FAIL;", "            else {", "              int noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["", "              if (save_m_noremap != REMAP_YES)", "                noremap = save_m_noremap;"], "readability/braces"]
["src/nvim/getchar.c", ["                noremap = save_m_noremap;", "              else if (", "                STRNCMP(s, save_m_keys != NULL"], "readability/braces"]
["src/nvim/getchar.c", ["              else if (", "                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    (size_t)keylen)", "                != 0)", "                noremap = REMAP_YES;"], "whitespace/indent"]
["src/nvim/getchar.c", ["                STRNCMP(s, save_m_keys != NULL", "                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                    ? save_m_keys : mp->m_keys,", "                    (size_t)keylen)", "                != 0)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                noremap = REMAP_YES;", "              else", "                noremap = REMAP_SKIP;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "whitespace/alignment"]
["src/nvim/getchar.c", ["              i = ins_typebuf(s, noremap,", "                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)"], "readability/bool"]
["src/nvim/getchar.c", ["                  0, TRUE, cmd_silent || save_m_silent);", "              if (save_m_expr)", "                xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - handle <Esc> in Insert mode"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /*", "         * special case: if we get an <ESC> in insert mode and there"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (mode_displayed) {", "            unshowmode(TRUE);", "            mode_deleted = TRUE;"], "readability/bool"]
["src/nvim/getchar.c", ["            unshowmode(TRUE);", "            mode_deleted = TRUE;", "          }"], "readability/bool"]
["src/nvim/getchar.c", ["", "          /* move cursor left, if possible */", "          if (curwin->w_cursor.col != 0) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              if (did_ai) {", "                /*", "                 * We are expecting to truncate the trailing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                curwin->w_wcol += curwin_col_off();", "                col = 0;                        /* no correction needed */", "              } else {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              } else {", "                --curwin->w_wcol;", "                col = curwin->w_cursor.col - 1;"], "readability/increment"]
["src/nvim/getchar.c", ["        }", "        if (c < 0)", "          continue;             /* end of input script reached */"], "readability/braces"]
["src/nvim/getchar.c", ["        if (c < 0)", "          continue;             /* end of input script reached */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        /* buffer full, don't map */", "        if (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        if (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN) {", "          timedout = TRUE;", "          continue;"], "readability/bool"]
["src/nvim/getchar.c", ["", "          /* No typeahead left and inside \":normal\".  Must return", "           * something to avoid getting stuck.  When an incomplete"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (typebuf.tb_len > 0) {", "            timedout = TRUE;", "            continue;"], "readability/bool"]
["src/nvim/getchar.c", ["          }", "          /* When 'insertmode' is set, ESC just beeps in Insert", "           * mode.  Use CTRL-L to make edit() return."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["           * cmdline window. */", "          if (p_im && (State & INSERT))", "            c = Ctrl_L;"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_L;", "          else if ((State & CMDLINE)", "                   || (cmdwin_type > 0 && tc == ESC)"], "readability/braces"]
["src/nvim/getchar.c", ["            c = Ctrl_C;", "          else", "            c = ESC;"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - update display"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["         */", "        /* In insert mode a screen update is skipped when characters", "         * are still available.  But when those available characters"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          update_screen(0);", "          setcursor();           /* put cursor back where it belongs */", "        }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        /*", "         * If we have a partial match (and are going to wait for more"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["              && State != HITRETURN) {", "            /* this looks nice when typing a dead character map */", "            if (State & INSERT"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["                && ptr2cells(typebuf.tb_buf + typebuf.tb_off", "                    + typebuf.tb_len - 1) == 1) {", "              edit_putchar(typebuf.tb_buf[typebuf.tb_off"], "whitespace/alignment"]
["src/nvim/getchar.c", ["                && ptr2cells(typebuf.tb_buf + typebuf.tb_off", "                    + typebuf.tb_len - 1) == 1) {", "              edit_putchar(typebuf.tb_buf[typebuf.tb_off"], "whitespace/alignment"]
["src/nvim/getchar.c", ["              edit_putchar(typebuf.tb_buf[typebuf.tb_off", "                                          + typebuf.tb_len - 1], FALSE);", "              setcursor();               /* put cursor back where it belongs */"], "readability/bool"]
["src/nvim/getchar.c", ["                                          + typebuf.tb_len - 1], FALSE);", "              setcursor();               /* put cursor back where it belongs */", "              c1 = 1;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            }", "            /* need to use the col and row from above here */", "            old_wcol = curwin->w_wcol;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["            push_showcmd();", "            if (typebuf.tb_len > SHOWCMD_COLS)", "              i = typebuf.tb_len - SHOWCMD_COLS;"], "readability/braces"]
["src/nvim/getchar.c", ["              i = typebuf.tb_len - SHOWCMD_COLS;", "            while (i < typebuf.tb_len)", "              (void)add_to_showcmd(typebuf.tb_buf[typebuf.tb_off"], "readability/braces"]
["src/nvim/getchar.c", ["", "        /*", "         * get a character: 3. from the user - get it"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        if (i != 0)", "          pop_showcmd();"], "readability/braces"]
["src/nvim/getchar.c", ["        if (c1 == 1) {", "          if (State & INSERT)", "            edit_unputchar();"], "readability/braces"]
["src/nvim/getchar.c", ["            edit_unputchar();", "          if (State & CMDLINE)", "            unputcmdline();"], "readability/braces"]
["src/nvim/getchar.c", ["            unputcmdline();", "          else", "            setcursor();                /* put cursor back where it belongs */"], "readability/braces"]
["src/nvim/getchar.c", ["          else", "            setcursor();                /* put cursor back where it belongs */", "        }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "        if (c < 0)", "          continue;                     /* end of input script reached */"], "readability/braces"]
["src/nvim/getchar.c", ["        if (c < 0)", "          continue;                     /* end of input script reached */", "        if (c == NUL) {                 /* no character available */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          continue;                     /* end of input script reached */", "        if (c == NUL) {                 /* no character available */", "          if (!advance)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        if (c == NUL) {                 /* no character available */", "          if (!advance)", "            break;"], "readability/braces"]
["src/nvim/getchar.c", ["            break;", "          if (wait_tb_len > 0) {                /* timed out */", "            timedout = TRUE;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (wait_tb_len > 0) {                /* timed out */", "            timedout = TRUE;", "            continue;"], "readability/bool"]
["src/nvim/getchar.c", ["          }", "        } else {          /* allow mapping for just typed characters */", "          while (typebuf.tb_buf[typebuf.tb_off"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        } else {          /* allow mapping for just typed characters */", "          while (typebuf.tb_buf[typebuf.tb_off", "                                + typebuf.tb_len] != NUL)"], "readability/braces"]
["src/nvim/getchar.c", ["        }", "      }             /* for (;;) */", "    }           /* if (!character from stuffbuf) */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }             /* for (;;) */", "    }           /* if (!character from stuffbuf) */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * The \"INSERT\" message is taken care of here:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (c == ESC && !mode_deleted && !no_mapping && mode_displayed) {", "      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* delete mode later */"], "readability/braces"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* delete mode later */", "      else"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* delete mode later */", "      else"], "readability/bool"]
["src/nvim/getchar.c", ["        redraw_cmdline = TRUE;              /* delete mode later */", "      else", "        unshowmode(FALSE);"], "readability/braces"]
["src/nvim/getchar.c", ["      else", "        unshowmode(FALSE);", "    } else if (c != ESC && mode_deleted) {"], "readability/bool"]
["src/nvim/getchar.c", ["    } else if (c != ESC && mode_deleted) {", "      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* show mode later */"], "readability/braces"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* show mode later */", "      else"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (typebuf.tb_len && !KeyTyped)", "        redraw_cmdline = TRUE;              /* show mode later */", "      else"], "readability/bool"]
["src/nvim/getchar.c", ["        redraw_cmdline = TRUE;              /* show mode later */", "      else", "        showmode();"], "readability/braces"]
["src/nvim/getchar.c", ["", "  --vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * inchar() - get one character from"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Don't reset these when at the hit-return prompt, otherwise an endless"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (State != HITRETURN) {", "    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (State != HITRETURN) {", "    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */"], "readability/bool"]
["src/nvim/getchar.c", ["    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */", "  }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    did_outofmem_msg = FALSE;       /* display out of memory message (again) */", "    did_swapwrite_msg = FALSE;      /* display swap file write error again */", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["  // Two characters are special: NUL and K_SPECIAL.", "  // Replace\t     NUL by K_SPECIAL KS_ZERO\t KE_FILLER", "  // Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER"], "whitespace/tab"]
["src/nvim/getchar.c", ["", "/*", " * Delete one entry from the abbrlist or maphash[]."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Initialize maphash[] for first use."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Get the mapping mode from the command name."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  modec = *p++;", "  if (modec == 'i')", "    mode = INSERT;                              /* :imap */"], "readability/braces"]
["src/nvim/getchar.c", ["  if (modec == 'i')", "    mode = INSERT;                              /* :imap */", "  else if (modec == 'l')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = INSERT;                              /* :imap */", "  else if (modec == 'l')", "    mode = LANGMAP;                             /* :lmap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'l')", "    mode = LANGMAP;                             /* :lmap */", "  else if (modec == 'c')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = LANGMAP;                             /* :lmap */", "  else if (modec == 'c')", "    mode = CMDLINE;                             /* :cmap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'c')", "    mode = CMDLINE;                             /* :cmap */", "  else if (modec == 'n' && *p != 'o')               /* avoid :noremap */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = CMDLINE;                             /* :cmap */", "  else if (modec == 'n' && *p != 'o')               /* avoid :noremap */", "    mode = NORMAL;                              /* :nmap */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = CMDLINE;                             /* :cmap */", "  else if (modec == 'n' && *p != 'o')               /* avoid :noremap */", "    mode = NORMAL;                              /* :nmap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'n' && *p != 'o')               /* avoid :noremap */", "    mode = NORMAL;                              /* :nmap */", "  else if (modec == 'v')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = NORMAL;                              /* :nmap */", "  else if (modec == 'v')", "    mode = VISUAL + SELECTMODE;                 /* :vmap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'v')", "    mode = VISUAL + SELECTMODE;                 /* :vmap */", "  else if (modec == 'x')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = VISUAL + SELECTMODE;                 /* :vmap */", "  else if (modec == 'x')", "    mode = VISUAL;                              /* :xmap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'x')", "    mode = VISUAL;                              /* :xmap */", "  else if (modec == 's')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = VISUAL;                              /* :xmap */", "  else if (modec == 's')", "    mode = SELECTMODE;                          /* :smap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 's')", "    mode = SELECTMODE;                          /* :smap */", "  else if (modec == 'o')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = SELECTMODE;                          /* :smap */", "  else if (modec == 'o')", "    mode = OP_PENDING;                          /* :omap */"], "readability/braces"]
["src/nvim/getchar.c", ["  else if (modec == 'o')", "    mode = OP_PENDING;                          /* :omap */", "  else if (modec == 't')"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mode = OP_PENDING;                          /* :omap */", "  else if (modec == 't')", "    mode = TERM_FOCUS;                            // :tmap"], "readability/braces"]
["src/nvim/getchar.c", ["    mode = TERM_FOCUS;                            // :tmap", "  else {", "    --p;"], "readability/braces"]
["src/nvim/getchar.c", ["    mode = TERM_FOCUS;                            // :tmap", "  else {", "    --p;"], "readability/braces"]
["src/nvim/getchar.c", ["  else {", "    --p;", "    if (forceit)"], "readability/increment"]
["src/nvim/getchar.c", ["    --p;", "    if (forceit)", "      mode = INSERT + CMDLINE;                  /* :map ! */"], "readability/braces"]
["src/nvim/getchar.c", ["    if (forceit)", "      mode = INSERT + CMDLINE;                  /* :map ! */", "    else"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      mode = INSERT + CMDLINE;                  /* :map ! */", "    else", "      mode = VISUAL + SELECTMODE + NORMAL + OP_PENDING;      /* :map */"], "readability/braces"]
["src/nvim/getchar.c", ["    else", "      mode = VISUAL + SELECTMODE + NORMAL + OP_PENDING;      /* :map */", "  }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings or abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  map_clear_int(curbuf, mode,", "      local,", "      abbr);"], "whitespace/alignment"]
["src/nvim/getchar.c", ["      local,", "      abbr);", "}"], "whitespace/alignment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings in \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "void ", "map_clear_int ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["void ", "map_clear_int (", "    buf_T *buf,        /* buffer for local mappings */"], "whitespace/parens"]
["src/nvim/getchar.c", ["map_clear_int (", "    buf_T *buf,        /* buffer for local mappings */", "    int mode,                       /* mode in which to delete */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    buf_T *buf,        /* buffer for local mappings */", "    int mode,                       /* mode in which to delete */", "    int local,               /* TRUE for buffer-local mappings */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int mode,                       /* mode in which to delete */", "    int local,               /* TRUE for buffer-local mappings */", "    int abbr                       /* TRUE for abbreviations */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int local,               /* TRUE for buffer-local mappings */", "    int abbr                       /* TRUE for abbreviations */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (hash = 0; hash < 256; ++hash) {", "    if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["    if (abbr) {", "      if (hash > 0)             /* there is only one abbrlist */", "        break;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (abbr) {", "      if (hash > 0)             /* there is only one abbrlist */", "        break;"], "readability/braces"]
["src/nvim/getchar.c", ["        break;", "      if (local)", "        mpp = &buf->b_first_abbr;"], "readability/braces"]
["src/nvim/getchar.c", ["        mpp = &buf->b_first_abbr;", "      else", "        mpp = &first_abbr;"], "readability/braces"]
["src/nvim/getchar.c", ["    } else {", "      if (local)", "        mpp = &buf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mpp = &buf->b_maphash[hash];", "      else", "        mpp = &maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        }", "        /*", "         * May need to put this entry into another hash list."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          }", "          continue;                     /* continue with *mpp */", "        }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "static void ", "showmap ("], "whitespace/end_of_line"]
["src/nvim/getchar.c", ["static void ", "showmap (", "    mapblock_T *mp,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    mapblock_T *mp,", "    int local                  /* TRUE for buffer-local map */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    msg_putchar('\\n');", "    if (got_int)            /* 'q' typed at MORE prompt */", "      return;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    msg_putchar('\\n');", "    if (got_int)            /* 'q' typed at MORE prompt */", "      return;"], "readability/braces"]
["src/nvim/getchar.c", ["", "  while (++len <= 3)", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["  do {", "    msg_putchar(' ');                   /* padd with blanks */", "    ++len;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    msg_putchar(' ');                   /* padd with blanks */", "    ++len;", "  } while (len < 12);"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (local)", "    msg_putchar('@');"], "readability/braces"]
["src/nvim/getchar.c", ["    msg_putchar('@');", "  else", "    msg_putchar(' ');"], "readability/braces"]
["src/nvim/getchar.c", ["", "  /* Use FALSE below if we only want things like <Up> to show up as such on", "   * the rhs, and not M-x etc, TRUE gets both -- webb */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Used below when expanding mapping/abbreviation names."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["static int expand_isabbrev = 0;", "static int expand_buffer = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Work out what to complete when doing command line completion of mapping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["char_u *", "set_context_in_map_cmd (", "    expand_T *xp,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    char_u *arg,", "    int forceit,                    /* TRUE if '!' given */", "    int isabbrev,                   /* TRUE if abbreviation */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int forceit,                    /* TRUE if '!' given */", "    int isabbrev,                   /* TRUE if abbreviation */", "    int isunmap,                    /* TRUE if unmap/unabbrev command */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int isabbrev,                   /* TRUE if abbreviation */", "    int isunmap,                    /* TRUE if unmap/unabbrev command */", "    cmdidx_T cmdidx"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  if (forceit && cmdidx != CMD_map && cmdidx != CMD_unmap)", "    xp->xp_context = EXPAND_NOTHING;"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_NOTHING;", "  else {", "    if (isunmap)"], "readability/braces"]
["src/nvim/getchar.c", ["  else {", "    if (isunmap)", "      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = get_map_mode(&cmd, forceit || isabbrev);", "    else {", "      expand_mapmodes = INSERT + CMDLINE;"], "readability/braces"]
["src/nvim/getchar.c", ["      expand_mapmodes = INSERT + CMDLINE;", "      if (!isabbrev)", "        expand_mapmodes += VISUAL + SELECTMODE + NORMAL + OP_PENDING;"], "readability/braces"]
["src/nvim/getchar.c", ["    xp->xp_context = EXPAND_MAPPINGS;", "    expand_buffer = FALSE;", "    for (;; ) {"], "readability/bool"]
["src/nvim/getchar.c", ["      if (STRNCMP(arg, \"<buffer>\", 8) == 0) {", "        expand_buffer = TRUE;", "        arg = skipwhite(arg + 8);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  *num_file = 0;                    /* return values in case of FAIL */", "  *file = NULL;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    count = 0;"], "readability/increment"]
["src/nvim/getchar.c", ["      if (vim_regexec(regmatch, p, (colnr_T)0)) {", "        if (round == 1)", "          ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["        if (round == 1)", "          ++count;", "        else"], "readability/increment"]
["src/nvim/getchar.c", ["          ++count;", "        else", "          (*file)[count++] = vim_strsave(p);"], "readability/braces"]
["src/nvim/getchar.c", ["", "    for (hash = 0; hash < 256; ++hash) {", "      if (expand_isabbrev) {"], "readability/increment"]
["src/nvim/getchar.c", ["      if (expand_isabbrev) {", "        if (hash > 0)           /* only one abbrev list */", "          break;           /* for (hash) */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (expand_isabbrev) {", "        if (hash > 0)           /* only one abbrev list */", "          break;           /* for (hash) */"], "readability/braces"]
["src/nvim/getchar.c", ["        if (hash > 0)           /* only one abbrev list */", "          break;           /* for (hash) */", "        mp = first_abbr;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        mp = first_abbr;", "      } else if (expand_buffer)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mp = curbuf->b_maphash[hash];", "      else", "        mp = maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["          if (p != NULL && vim_regexec(regmatch, p, (colnr_T)0)) {", "            if (round == 1)", "              ++count;"], "readability/braces"]
["src/nvim/getchar.c", ["            if (round == 1)", "              ++count;", "            else {"], "readability/increment"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["              ++count;", "            else {", "              (*file)[count++] = p;"], "readability/braces"]
["src/nvim/getchar.c", ["        }", "      }       /* for (mp) */", "    }     /* for (hash) */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }       /* for (mp) */", "    }     /* for (hash) */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    if (count == 0)                     /* no match found */", "      break;       /* for (round) */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    if (count == 0)                     /* no match found */", "      break;       /* for (round) */"], "readability/braces"]
["src/nvim/getchar.c", ["    if (count == 0)                     /* no match found */", "      break;       /* for (round) */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    }", "  }   /* for (round) */", ""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /* Sort the matches */", "    sort_strings(*file, count);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /* Remove multiple entries */", "    ptr1 = *file;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    while (ptr2 < ptr3) {", "      if (STRCMP(*ptr1, *ptr2))", "        *++ptr1 = *ptr2++;"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["        *++ptr1 = *ptr2++;", "      else {", "        xfree(*ptr2++);"], "readability/braces"]
["src/nvim/getchar.c", ["  int len;", "  int scol;                     /* starting column of the abbr. */", "  int j;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      ++clen;", "    }"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (scol < mincol)", "    scol = mincol;"], "readability/braces"]
["src/nvim/getchar.c", ["    scol = mincol;", "  if (scol < col) {             /* there is a word in front of the cursor */", "    ptr += scol;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      /* find entries with right mode and keys */", "      match = (mp->m_mode & State)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (mp != NULL) {", "      /*", "       * Found a match:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (c != Ctrl_RSB) {", "        /* special key code, split up */", "        if (IS_SPECIAL(c) || c == K_SPECIAL) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        tb[j] = NUL;", "        /* insert the last typed char */", "        (void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        /* insert the last typed char */", "        (void)ins_typebuf(tb, 1, 0, TRUE, mp->m_silent);", "      }"], "readability/bool"]
["src/nvim/getchar.c", ["      }", "      if (mp->m_expr)", "        s = eval_map_expr(mp->m_str, c);"], "readability/braces"]
["src/nvim/getchar.c", ["        s = eval_map_expr(mp->m_str, c);", "      else", "        s = mp->m_str;"], "readability/braces"]
["src/nvim/getchar.c", ["      if (s != NULL) {", "        /* insert the to string */", "        (void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        /* insert the to string */", "        (void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);", "        /* no abbrev. for these chars */"], "readability/bool"]
["src/nvim/getchar.c", ["        (void)ins_typebuf(s, mp->m_noremap, 0, TRUE, mp->m_silent);", "        /* no abbrev. for these chars */", "        typebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["        typebuf.tb_no_abbr_cnt += (int)STRLEN(s) + j + 1;", "        if (mp->m_expr)", "          xfree(s);"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Evaluate the RHS of a mapping or abbreviations and take care of escaping"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["static char_u *", "eval_map_expr (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    char_u *str,", "    int c                      /* NUL or typed character for abbreviation */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Remove escaping of CSI, because \"str\" is in a format to be used as", "   * typeahead. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Forbid changing text or using \":normal\" to avoid most of the bad side", "   * effects.  Also restore the cursor position. */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   * effects.  Also restore the cursor position. */", "  ++textlock;", "  ++ex_normal_lock;"], "readability/increment"]
["src/nvim/getchar.c", ["  ++textlock;", "  ++ex_normal_lock;", "  set_vim_var_char(c);    /* set v:char to the typed character */"], "readability/increment"]
["src/nvim/getchar.c", ["  ++ex_normal_lock;", "  set_vim_var_char(c);    /* set v:char to the typed character */", "  save_cursor = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  save_msg_row = msg_row;", "  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;"], "readability/bool"]
["src/nvim/getchar.c", ["  p = eval_to_string(expr, NULL, FALSE);", "  --textlock;", "  --ex_normal_lock;"], "readability/increment"]
["src/nvim/getchar.c", ["  --textlock;", "  --ex_normal_lock;", "  curwin->w_cursor = save_cursor;"], "readability/increment"]
["src/nvim/getchar.c", ["", "  if (p == NULL)", "    return NULL;"], "readability/braces"]
["src/nvim/getchar.c", ["    return NULL;", "  /* Escape CSI in the result to be able to use the string as typeahead. */", "  res = vim_strsave_escape_csi(p);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Copy \"p\" to allocated memory, escaping K_SPECIAL and CSI so that the result"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (s[0] == K_SPECIAL && s[1] != NUL && s[2] != NUL) {", "      /* Copy special key unmodified. */", "      *d++ = *s++;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove escaping from CSI and K_SPECIAL characters.  Reverse of"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      s += 3;", "    } else", "      *d++ = *s++;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Write map commands for the current mappings to an .exrc file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (*str == NUL && what == 1) {", "    if (fprintf(fd, \"<Nop>\") < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    if (p != NULL) {", "      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)"], "readability/braces"]
["src/nvim/getchar.c", ["      while (*p != NUL)", "        if (fputc(*p++, fd) < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["          return FAIL;", "      --str;", "      continue;"], "readability/increment"]
["src/nvim/getchar.c", ["    c = *str;", "    /*", "     * Special key codes have to be translated to be able to make sense"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      if (IS_SPECIAL(c) || modifiers) {         /* special key */", "        if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (IS_SPECIAL(c) || modifiers) {         /* special key */", "        if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "    /*", "     * A '\\n' in a map command should be written as <NL>."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (what == 2) {", "        if (fprintf(fd, \"\\\\\\026\\n\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["      } else {", "        if (fprintf(fd, \"<NL>\") < 0)", "          return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "    /*", "     * Some characters have to be escaped with CTRL-V to"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    if (what == 2 && (ascii_iswhite(c) || c == '\"' || c == '\\\\')) {", "      if (putc('\\\\', fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["               || (what != 2 && c == '<')) {", "      if (putc(Ctrl_V, fd) < 0)", "        return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["    }", "    if (putc(c, fd) < 0)", "      return FAIL;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Check the string \"keys\" against the lhs of all mappings."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["char_u *", "check_map (", "    char_u *keys,"], "whitespace/parens"]
["src/nvim/getchar.c", ["    int mode,", "    int exact,                      /* require exact match */", "    int ign_mod,                    /* ignore preceding modifier */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int exact,                      /* require exact match */", "    int ign_mod,                    /* ignore preceding modifier */", "    int abbr,                       /* do abbreviations */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int ign_mod,                    /* ignore preceding modifier */", "    int abbr,                       /* do abbreviations */", "    mapblock_T **mp_ptr,           /* return: pointer to mapblock or NULL */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    int abbr,                       /* do abbreviations */", "    mapblock_T **mp_ptr,           /* return: pointer to mapblock or NULL */", "    int *local_ptr         /* return: buffer-local mapping or NULL */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    mapblock_T **mp_ptr,           /* return: pointer to mapblock or NULL */", "    int *local_ptr         /* return: buffer-local mapping or NULL */", ")"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  len = (int)STRLEN(keys);", "  for (local = 1; local >= 0; --local)", "    /* loop over all hash lists */"], "readability/braces"]
["src/nvim/getchar.c", ["  len = (int)STRLEN(keys);", "  for (local = 1; local >= 0; --local)", "    /* loop over all hash lists */"], "readability/increment"]
["src/nvim/getchar.c", ["  for (local = 1; local >= 0; --local)", "    /* loop over all hash lists */", "    for (hash = 0; hash < 256; ++hash) {"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    /* loop over all hash lists */", "    for (hash = 0; hash < 256; ++hash) {", "      if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["      if (abbr) {", "        if (hash > 0)                   /* there is only one list. */", "          break;"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      if (abbr) {", "        if (hash > 0)                   /* there is only one list. */", "          break;"], "readability/braces"]
["src/nvim/getchar.c", ["          break;", "        if (local)", "          mp = curbuf->b_first_abbr;"], "readability/braces"]
["src/nvim/getchar.c", ["          mp = curbuf->b_first_abbr;", "        else", "          mp = first_abbr;"], "readability/braces"]
["src/nvim/getchar.c", ["          mp = first_abbr;", "      } else if (local)", "        mp = curbuf->b_maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["        mp = curbuf->b_maphash[hash];", "      else", "        mp = maphash[hash];"], "readability/braces"]
["src/nvim/getchar.c", ["      for (; mp != NULL; mp = mp->m_next) {", "        /* skip entries with wrong mode, wrong length and not matching", "         * ones */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["          if (STRNCMP(s, keys, minlen) == 0) {", "            if (mp_ptr != NULL)", "              *mp_ptr = mp;"], "readability/braces"]
["src/nvim/getchar.c", ["              *mp_ptr = mp;", "            if (local_ptr != NULL)", "              *local_ptr = local;"], "readability/braces"]
["src/nvim/getchar.c", ["", "/*", " * Add a mapping \"map\" for mode \"mode\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p_cpo = (char_u *)\"\";         /* Allow <> notation */", "  s = vim_strsave(map);"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  s = vim_strsave(map);", "  (void)do_map(0, s, mode, FALSE);", "  xfree(s);"], "readability/bool"]
["src/nvim/getchar.c", ["// Returns NULL when there is a problem.", "static char_u * translate_mapping (", "    char_u *str,"], "whitespace/parens"]
["src/nvim/getchar.c", ["", "  for (; *str; ++str) {", "    int c = *str;"], "readability/increment"]
["src/nvim/getchar.c", ["        ga_concat(&ga, get_special_key_name(c, modifiers));", "        continue;         /* for (str) */", "      }"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  for (i = 0; i < typebuf.tb_len && str[i]; i++) {", "    if (str[i] != typebuf.tb_buf[typebuf.tb_off + i])", "      break;"], "readability/braces"]

["src/nvim/indent_c.c", ["#endif", "/*", " * Find the start of a comment, not knowing if we are in a comment right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static pos_T *ind_find_start_comment(void)", "{ /* XXX */", "  return find_start_comment(curbuf->b_ind_maxcomment);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["pos_T *", "find_start_comment (  /* XXX */", "    int ind_maxcomment"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["pos_T *", "find_start_comment (  /* XXX */", "    int ind_maxcomment"], "whitespace/parens"]
["src/nvim/indent_c.c", ["    pos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);", "    if (pos == NULL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Check if the comment start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(pos->lnum);", "    for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "      p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["      p = skip_string(p);", "    if ((colnr_T)(p - line) <= pos->col)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find the start of a raw string, not knowing if we are in one right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static pos_T *find_start_rawstring(int ind_maxcomment)", "{ /* XXX */", "    pos_T *pos;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    for (;;)", "    {"], "readability/braces"]
["src/nvim/indent_c.c", ["    for (;;)", "    {", "        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);"], "whitespace/braces"]
["src/nvim/indent_c.c", ["        pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);", "        if (pos == NULL)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /*", "         * Check if the raw string start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/braces"]
["src/nvim/indent_c.c", ["        line = ml_get(pos->lnum);", "        for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)", "            p = skip_string(p);"], "readability/increment"]
["src/nvim/indent_c.c", ["            p = skip_string(p);", "        if ((colnr_T)(p - line) <= pos->col)", "            break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;", "        if (cur_maxcomment <= 0)", "        {"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (cur_maxcomment <= 0)", "        {", "            pos = NULL;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Skip to the end of a \"string\" and a 'c' character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * We loop, because strings may be concatenated: \"date\"\"time\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  for (;; ++p) {", "    if (p[0] == '\\'') {                     /* 'c' or '\\n' or '\\000' */"], "readability/increment"]
["src/nvim/indent_c.c", ["  for (;; ++p) {", "    if (p[0] == '\\'') {                     /* 'c' or '\\n' or '\\000' */", "      if (!p[1])                            /* ' at end of line */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (p[0] == '\\'') {                     /* 'c' or '\\n' or '\\000' */", "      if (!p[1])                            /* ' at end of line */", "        break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (p[0] == '\\'') {                     /* 'c' or '\\n' or '\\000' */", "      if (!p[1])                            /* ' at end of line */", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      i = 2;", "      if (p[1] == '\\\\') {                   /* '\\n' or '\\000' */", "        ++i;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (p[1] == '\\\\') {                   /* '\\n' or '\\000' */", "        ++i;", "        while (ascii_isdigit(p[i - 1]))           /* '\\000' */"], "readability/increment"]
["src/nvim/indent_c.c", ["        ++i;", "        while (ascii_isdigit(p[i - 1]))           /* '\\000' */", "          ++i;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        ++i;", "        while (ascii_isdigit(p[i - 1]))           /* '\\000' */", "          ++i;"], "readability/braces"]
["src/nvim/indent_c.c", ["        while (ascii_isdigit(p[i - 1]))           /* '\\000' */", "          ++i;", "      }"], "readability/increment"]
["src/nvim/indent_c.c", ["      }", "      if (p[i] == '\\'') {                   /* check for trailing ' */", "        p += i;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "    } else if (p[0] == '\"') {             /* start of string */", "      for (++p; p[0]; ++p) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    } else if (p[0] == '\"') {             /* start of string */", "      for (++p; p[0]; ++p) {", "        if (p[0] == '\\\\' && p[1] != NUL)"], "readability/increment"]
["src/nvim/indent_c.c", ["      for (++p; p[0]; ++p) {", "        if (p[0] == '\\\\' && p[1] != NUL)", "          ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (p[0] == '\\\\' && p[1] != NUL)", "          ++p;", "        else if (p[0] == '\"')               /* end of string */"], "readability/increment"]
["src/nvim/indent_c.c", ["          ++p;", "        else if (p[0] == '\"')               /* end of string */", "          break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          ++p;", "        else if (p[0] == '\"')               /* end of string */", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      if (p[0] == '\"')", "          continue; /* continue for another string */"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (p[0] == '\"')", "          continue; /* continue for another string */", "    } else if (p[0] == 'R' && p[1] == '\"') {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    } else if (p[0] == 'R' && p[1] == '\"') {", "        /* Raw string: R\"[delim](...)[delim]\" */", "        char_u *delim = p + 2;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0"], "readability/increment"]
["src/nvim/indent_c.c", ["            for (p += 3; *p; ++p)", "                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')"], "readability/braces"]
["src/nvim/indent_c.c", ["                if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0", "                        && p[delim_len + 1] == '\"')", "                {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        && p[delim_len + 1] == '\"')", "                {", "                    p += delim_len + 1;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["                }", "            if (p[0] == '\"')", "                continue; /* continue for another string */"], "readability/braces"]
["src/nvim/indent_c.c", ["            if (p[0] == '\"')", "                continue; /* continue for another string */", "        }"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    break;                                  /* no string found */", "  }"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  if (!*p)", "    --p;                                    /* backup from NUL */"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (!*p)", "    --p;                                    /* backup from NUL */", "  return p;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (!*p)", "    --p;                                    /* backup from NUL */", "  return p;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Functions for C-indenting."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "/*", " * Below \"XXX\" means that this function may unlock the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return true if the string \"line\" starts with a word from 'cinwords'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip over white space and C comments within the line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* Perl/shell # comment comment continues until eol.  Require a space", "     * before # to avoid recognizing $#array. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != '/')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    ++s;", "    if (*s == '/') {            /* slash-slash comment continues till eol */"], "readability/increment"]
["src/nvim/indent_c.c", ["    ++s;", "    if (*s == '/') {            /* slash-slash comment continues till eol */", "      s += STRLEN(s);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != '*')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    for (++s; *s; ++s)          /* skip slash-star comment */", "      if (s[0] == '*' && s[1] == '/') {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      break;", "    for (++s; *s; ++s)          /* skip slash-star comment */", "      if (s[0] == '*' && s[1] == '/') {"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    for (++s; *s; ++s)          /* skip slash-star comment */", "      if (s[0] == '*' && s[1] == '/') {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if there is no code at *s.  White space and comments are"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check previous lines for a \"//\" line comment, skipping over blank lines."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static pos_T *find_line_comment(void)   /* XXX */", "{"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    quote = *s;", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/tab"]
["src/nvim/indent_c.c", ["  }", "  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;"], "whitespace/braces"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(*s))\t{   // need at least one ID character", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  while (vim_isIDc(*s)) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  if (*s && *s == quote) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["{", "  if (!vim_isIDc(**s))              /* need at least one ID character */", "    return FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (!vim_isIDc(**s))              /* need at least one ID character */", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (!vim_isIDc(**s))              /* need at least one ID character */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  while (vim_isIDc(**s))", "    (*s)++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* \"::\" is not a label, it's C++ */", "  return **s == ':' && *++*s != ':';"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a label: \"label:\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["int cin_islabel(void)", "{ /* XXX */", "  char_u *s = cin_skipcomment(get_cursor_line_ptr());"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Exclude \"default\" from labels, since it should be indented"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  if (cin_isdefault(s))", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_isdefault(s))", "    return FALSE;", "  if (cin_isscopedecl(s))"], "readability/bool"]
["src/nvim/indent_c.c", ["    return FALSE;", "  if (cin_isscopedecl(s))", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_isscopedecl(s))", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  if (!cin_islabel_skip(&s)) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /*", "   * Only accept a label if the previous line is terminated or is a case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If we're in a comment or raw string now, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = get_cursor_line_ptr();", "    if (cin_ispreproc(line))          /* ignore #defines, #if, etc. */", "      continue;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = get_cursor_line_ptr();", "    if (cin_ispreproc(line))          /* ignore #defines, #if, etc. */", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["      continue;", "    if (*(line = cin_skipcomment(line)) == NUL)", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/braces"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["        || cin_isscopedecl(line)", "        || cin_iscase(line, TRUE)", "        || (cin_islabel_skip(&line) && cin_nocode(line)))"], "readability/bool"]
["src/nvim/indent_c.c", ["        || (cin_islabel_skip(&line) && cin_nocode(line)))", "      return TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      return TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["  curwin->w_cursor = cursor_save;", "  return TRUE;                /* label at start of file??? */", "}"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  curwin->w_cursor = cursor_save;", "  return TRUE;                /* label at start of file??? */", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize structure initialization and enumerations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["  char_u      *s;", "  static char *skip[] = {\"static\", \"public\", \"protected\", \"private\"};", ""], "whitespace/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"typedef\"))", "    s = cin_skipcomment(s + 7);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    for (i = 0; i < (int)ARRAY_SIZE(skip); ++i) {", "      l = (int)strlen(skip[i]);"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l != 0)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (cin_starts_with(s, \"enum\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"enum\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_ends_in(s, (char_u *)\"=\", (char_u *)\"{\"))", "    return TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a switch label: \"case .*:\" or \"default:\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "int ", "cin_iscase ("], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["int ", "cin_iscase (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["    char_u *s,", "    int strict     /* Allow relaxed check of case statement for JS */", ")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"case\")) {", "    for (s += 4; *s; ++s) {", "      s = cin_skipcomment(s);"], "readability/increment"]
["src/nvim/indent_c.c", ["      if (*s == ':') {", "        if (s[1] == ':')                /* skip over \"::\" for C++ */", "          ++s;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (*s == ':') {", "        if (s[1] == ':')                /* skip over \"::\" for C++ */", "          ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (s[1] == ':')                /* skip over \"::\" for C++ */", "          ++s;", "        else"], "readability/increment"]
["src/nvim/indent_c.c", ["          ++s;", "        else", "          return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["        else", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["      }", "      if (*s == '\\'' && s[1] && s[2] == '\\'')", "        s += 2;                         /* skip over ':' */"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s == '\\'' && s[1] && s[2] == '\\'')", "        s += 2;                         /* skip over ':' */", "      else if (*s == '/' && (s[1] == '*' || s[1] == '/'))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        s += 2;                         /* skip over ':' */", "      else if (*s == '/' && (s[1] == '*' || s[1] == '/'))", "        return FALSE;                   /* stop at comment */"], "readability/braces"]
["src/nvim/indent_c.c", ["      else if (*s == '/' && (s[1] == '*' || s[1] == '/'))", "        return FALSE;                   /* stop at comment */", "      else if (*s == '\"') {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      else if (*s == '/' && (s[1] == '*' || s[1] == '/'))", "        return FALSE;                   /* stop at comment */", "      else if (*s == '\"') {"], "readability/bool"]
["src/nvim/indent_c.c", ["        return FALSE;                   /* stop at comment */", "      else if (*s == '\"') {", "        /* JS etc. */"], "readability/braces"]
["src/nvim/indent_c.c", ["      else if (*s == '\"') {", "        /* JS etc. */", "        if (strict)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        /* JS etc. */", "        if (strict)", "          return FALSE;                         /* stop at string */"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (strict)", "          return FALSE;                         /* stop at string */", "        else"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (strict)", "          return FALSE;                         /* stop at string */", "        else"], "readability/bool"]
["src/nvim/indent_c.c", ["          return FALSE;                         /* stop at string */", "        else", "          return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["        else", "          return TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (cin_isdefault(s))", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (cin_isdefault(s))", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"default\" switch label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"public/private/protected\" scope declaration label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  s = cin_skipcomment(s);", "  if (STRNCMP(s, \"public\", 6) == 0)", "    i = 6;"], "readability/braces"]
["src/nvim/indent_c.c", ["    i = 6;", "  else if (STRNCMP(s, \"protected\", 9) == 0)", "    i = 9;"], "readability/braces"]
["src/nvim/indent_c.c", ["    i = 9;", "  else if (STRNCMP(s, \"private\", 7) == 0)", "    i = 7;"], "readability/braces"]
["src/nvim/indent_c.c", ["    i = 7;", "  else", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  else", "    return FALSE;", "  return *(s = cin_skipcomment(s + i)) == ':' && s[1] != ':';"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/* Maximum number of lines to search back for a \"namespace\" line. */", "#define FIND_NAMESPACE_LIM 20"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return a pointer to the first non-empty non-comment character after a ':'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  for (; *l; ++l) {", "    if (*l == ':') {"], "readability/increment"]
["src/nvim/indent_c.c", ["    if (*l == ':') {", "      if (l[1] == ':')              /* skip over \"::\" for C++ */", "        ++l;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (*l == ':') {", "      if (l[1] == ':')              /* skip over \"::\" for C++ */", "        ++l;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (l[1] == ':')              /* skip over \"::\" for C++ */", "        ++l;", "      else if (!cin_iscase(l + 1, FALSE))"], "readability/increment"]
["src/nvim/indent_c.c", ["        ++l;", "      else if (!cin_iscase(l + 1, FALSE))", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        ++l;", "      else if (!cin_iscase(l + 1, FALSE))", "        break;"], "readability/bool"]
["src/nvim/indent_c.c", ["        break;", "    } else if (*l == '\\'' && l[1] && l[2] == '\\'')", "      l += 2;                       /* skip over 'x' */"], "readability/braces"]
["src/nvim/indent_c.c", ["    } else if (*l == '\\'' && l[1] && l[2] == '\\'')", "      l += 2;                       /* skip over 'x' */", "  }"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["  l = cin_skipcomment(l + 1);", "  if (*l == NUL)", "    return NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Get indent of line \"lnum\", skipping a label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static int ", "get_indent_nolabel (     /* XXX */"], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["static int ", "get_indent_nolabel (     /* XXX */", "    linenr_T lnum"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static int ", "get_indent_nolabel (     /* XXX */", "    linenr_T lnum"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  p = after_label(l);", "  if (p == NULL)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Find indent for line \"lnum\", ignoring any case or jump label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  l = get_cursor_line_ptr();", "  /* XXX */", "  if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel()) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  /* XXX */", "  if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel()) {", "    amount = get_indent_nolabel(lnum);"], "readability/bool"]
["src/nvim/indent_c.c", ["    l = after_label(get_cursor_line_ptr());", "    if (l == NULL)              /* just in case */", "      l = get_cursor_line_ptr();"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    l = after_label(get_cursor_line_ptr());", "    if (l == NULL)              /* just in case */", "      l = get_cursor_line_ptr();"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first variable name after a type in a declaration."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  if (len == 6 && STRNCMP(p, \"struct\", 6) == 0)", "    p = skipwhite(p + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 6);", "  else if (len == 4 && STRNCMP(p, \"enum\", 4) == 0)", "    p = skipwhite(p + 4);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = skipwhite(p + 4);", "  else if ((len == 8 && STRNCMP(p, \"unsigned\", 8) == 0)", "           || (len == 6 && STRNCMP(p, \"signed\", 6) == 0)) {"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = skipwhite(p + len);", "    if ((STRNCMP(s, \"int\", 3) == 0 && ascii_iswhite(s[3]))", "        || (STRNCMP(s, \"long\", 4) == 0 && ascii_iswhite(s[4]))"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;"], "readability/increment"]
["src/nvim/indent_c.c", ["  for (len = 0; vim_isIDc(p[len]); ++len)", "    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["    ;", "  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first non-blank after an equal sign."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    line = ml_get(lnum - 1);", "    if (*line != NUL && line[STRLEN(line) - 1] == '\\\\')", "      return -1;"], "readability/braces"]
["src/nvim/indent_c.c", ["  while (*s != NUL && vim_strchr((char_u *)\"=;{}\\\"'\", *s) == NULL) {", "    if (cin_iscomment(s))       /* ignore comments */", "      s = cin_skipcomment(s);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (*s != NUL && vim_strchr((char_u *)\"=;{}\\\"'\", *s) == NULL) {", "    if (cin_iscomment(s))       /* ignore comments */", "      s = cin_skipcomment(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "    else", "      ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["    else", "      ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  if (*s != '=')", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = skipwhite(s + 1);", "  if (cin_nocode(s))", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (*s == '\"')        /* nice alignment for continued strings */", "    ++s;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (*s == '\"')        /* nice alignment for continued strings */", "    ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*s == '\"')        /* nice alignment for continued strings */", "    ++s;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a preprocessor statement: Any line that starts with '#'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*skipwhite(s) == '#')", "    return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(s) == '#')", "    return TRUE;", "  return FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["    return TRUE;", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (lnum == 1)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["    line = ml_get(--lnum);", "    if (*line == NUL || line[STRLEN(line) - 1] != '\\\\')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a C or C++ comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a \"//\" comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static char_u", "cin_isterminated (", "    char_u *s,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["    char_u *s,", "    int incl_open,                  /* include '{' at the end as terminator */", "    int incl_comma                 /* recognize a trailing comma */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int incl_open,                  /* include '{' at the end as terminator */", "    int incl_comma                 /* recognize a trailing comma */", ")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (*s == '{' || (*s == '}' && !cin_iselse(s)))", "    found_start = *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  if (!found_start)", "    is_else = cin_iselse(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["  while (*s) {", "    /* skip over comments, \"\" strings and 'c'haracters */", "    s = skip_string(cin_skipcomment(s));"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    s = skip_string(cin_skipcomment(s));", "    if (*s == '}' && n_open > 0)", "      --n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == '}' && n_open > 0)", "      --n_open;", "    if ((!is_else || n_open == 0)"], "readability/increment"]
["src/nvim/indent_c.c", ["      --n_open;", "    if ((!is_else || n_open == 0)", "        && (*s == ';' || *s == '}' || (incl_comma && *s == ','))"], "readability/braces"]
["src/nvim/indent_c.c", ["      return *s;", "    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))"], "readability/braces"]
["src/nvim/indent_c.c", ["    else if (*s == '{') {", "      if (incl_open && cin_nocode(s + 1))", "        return *s;"], "readability/braces"]
["src/nvim/indent_c.c", ["        return *s;", "      else", "        ++n_open;"], "readability/braces"]
["src/nvim/indent_c.c", ["      else", "        ++n_open;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    if (*s)", "      s++;"], "readability/braces"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int just_started = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  if (sp == NULL)", "    s = ml_get(lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["    s = ml_get(lnum);", "  else", "    s = *sp;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*s == ')' && cin_nocode(s + 1)) {", "      /* ')' at the end: may have found a match", "       * Check for he previous line not to end in a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = ml_get(lnum);", "      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s == NUL || s[STRLEN(s) - 1] != '\\\\')", "        retval = TRUE;", "      goto done;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "      /* ',' at the end: continue looking in the next line.", "       * At the end: check for ',' in the next line, for this style:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      for (;; ) {", "        if (lnum >= curbuf->b_ml.ml_line_count)", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = ml_get(++lnum);", "        if (!cin_ispreproc(s))", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      if (lnum >= curbuf->b_ml.ml_line_count)", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      /* Require a comma at end of the line or a comma or ')' at the", "       * start of next line. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      s = skipwhite(s);", "      if (!just_started && (!comma && *s != ',' && *s != ')'))", "        break;"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      just_started = FALSE;", "    } else if (cin_iscomment(s))        /* ignore comments */"], "readability/bool"]
["src/nvim/indent_c.c", ["      just_started = FALSE;", "    } else if (cin_iscomment(s))        /* ignore comments */", "      s = cin_skipcomment(s);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      just_started = FALSE;", "    } else if (cin_iscomment(s))        /* ignore comments */", "      s = cin_skipcomment(s);"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "    else {", "      ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "    else {", "      ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["    else {", "      ++s;", "      just_started = FALSE;"], "readability/increment"]
["src/nvim/indent_c.c", ["      ++s;", "      just_started = FALSE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", ["done:", "  if (lnum != first_lnum && sp != NULL)", "    *sp = ml_get(first_lnum);"], "readability/braces"]
["src/nvim/indent_c.c", ["{", "  if (*p == '}')            /* accept \"} else\" */", "    p = cin_skipcomment(p + 1);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*p == '}')            /* accept \"} else\" */", "    p = cin_skipcomment(p + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Check if this is a \"while\" that should have a matching \"do\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static int ", "cin_iswhileofdo ( /* XXX */"], "whitespace/end_of_line"]
["src/nvim/indent_c.c", ["static int ", "cin_iswhileofdo ( /* XXX */", "    char_u *p,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["static int ", "cin_iswhileofdo ( /* XXX */", "    char_u *p,"], "whitespace/parens"]
["src/nvim/indent_c.c", ["  pos_T       *trypos;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["  p = cin_skipcomment(p);", "  if (*p == '}')                /* accept \"} while (cond);\" */", "    p = cin_skipcomment(p + 1);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  p = cin_skipcomment(p);", "  if (*p == '}')                /* accept \"} while (cond);\" */", "    p = cin_skipcomment(p + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["    p = get_cursor_line_ptr();", "    while (*p && *p != 'w') {   /* skip any '}', until the 'w' of the \"while\" */", "      ++p;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    while (*p && *p != 'w') {   /* skip any '}', until the 'w' of the \"while\" */", "      ++p;", "      ++curwin->w_cursor.col;"], "readability/increment"]
["src/nvim/indent_c.c", ["      ++p;", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL"], "readability/braces"]
["src/nvim/indent_c.c", ["    if ((trypos = findmatchlimit(NULL, 0, 0,", "             curbuf->b_ind_maxparen)) != NULL", "        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["        && *cin_skipcomment(ml_get_pos(trypos) + 1) == ';')", "      retval = TRUE;", "    curwin->w_cursor = cursor_save;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (offset-- < 2)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["    return 0;", "  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;"], "readability/braces"]
["src/nvim/indent_c.c", ["  while (offset > 2 && ascii_iswhite(line[offset]))", "    --offset;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["  offset -= 1;", "  if (!STRNCMP(line + offset, \"if\", 2))", "    goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["    offset -= 1;", "    if (!STRNCMP(line + offset, \"for\", 3))", "      goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["      offset -= 2;", "      if (!STRNCMP(line + offset, \"while\", 5))", "        goto probablyFound;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if we are at the end of a do-while."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (terminated != ';')        /* there must be a ';' at the end */", "    return FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (terminated != ';')        /* there must be a ';' at the end */", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (terminated != ';')        /* there must be a ';' at the end */", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (*s == ';' && cin_nocode(s + 1)) {", "        /* Found \");\" at end of the line, now check there is \"while\"", "         * before the matching '('.  XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          s = cin_skipcomment(ml_get(trypos->lnum));", "          if (*s == '}')                        /* accept \"} while (cond);\" */", "            s = cin_skipcomment(s + 1);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          s = cin_skipcomment(ml_get(trypos->lnum));", "          if (*s == '}')                        /* accept \"} while (cond);\" */", "            s = cin_skipcomment(s + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "        /* Searching may have made \"line\" invalid, get it again. */", "        line = get_cursor_line_ptr();"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Find the position of a C++ base-class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "static int cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached) {", "  lpos_T *pos = &cached->lpos;  // find position"], "readability/braces"]
["src/nvim/indent_c.c", ["  s = skipwhite(line);", "  if (*s == '#')                /* skip #define FOO x ? (x) : x */", "    return FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  s = skipwhite(line);", "  if (*s == '#')                /* skip #define FOO x ? (x) : x */", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*s == '#')                /* skip #define FOO x ? (x) : x */", "    return FALSE;", "  s = cin_skipcomment(s);"], "readability/bool"]
["src/nvim/indent_c.c", ["  s = cin_skipcomment(s);", "  if (*s == NUL)", "    return FALSE;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*s == NUL)", "    return FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /* Search for a line starting with '#', empty, ending in ';' or containing", "   * '{' or '}' and start below it.  This handles the following situations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    s = skipwhite(line);", "    if (*s == '#' || *s == NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(s);", "      if (*s == '{' || *s == '}'", "          || (*s == ';' && cin_nocode(s + 1)))"], "readability/braces"]
["src/nvim/indent_c.c", ["        break;", "      if (*s != NUL)", "        ++s;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*s != NUL)", "        ++s;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (*s != NUL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["      break;", "    --lnum;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["      s = cin_skipcomment(line);", "      if (*s == NUL)", "        continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    if (s[0] == '\"' || (s[0] == 'R' && s[1] == '\"'))", "      s = skip_string(s) + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      s = skip_string(s) + 1;", "    else if (s[0] == ':') {", "      if (s[1] == ':') {"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[1] == ':') {", "        /* skip double colon. It can't be a constructor", "         * initialization any more */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (lookfor_ctor_init || class_or_struct) {", "        /* we have something found, that looks like the start of", "         * cpp-base-class-declaration or constructor-initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 1);", "      } else", "        s = cin_skipcomment(s + 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      if (*s == 'c')", "        s = cin_skipcomment(s + 5);"], "readability/braces"]
["src/nvim/indent_c.c", ["        s = cin_skipcomment(s + 5);", "      else", "        s = cin_skipcomment(s + 6);"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == ')') {", "        /* Constructor-initialization is assumed if we come across", "         * something like \"):\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == '?') {", "        /* Avoid seeing '() :' after '?' as constructor init. */", "        return FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        /* Avoid seeing '() :' after '?' as constructor init. */", "        return FALSE;", "      } else if (!vim_isIDc(s[0])) {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (!vim_isIDc(s[0])) {", "        /* if it is not an identifier, we are wrong */", "        class_or_struct = false;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else if (pos->col == 0) {", "        /* it can't be a constructor-initialization any more */", "        lookfor_ctor_init = FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        /* it can't be a constructor-initialization any more */", "        lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "        /* the first statement starts here: lineup with this one... */", "        if (cpp_base_class) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /* When the line ends in a comma don't align with it. */", "      if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1)) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    amount = get_indent();", "    if (find_last_paren(get_cursor_line_ptr(), '(', ')')", "        && (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)"], "readability/braces"]
["src/nvim/indent_c.c", ["        && (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)", "      amount = get_indent_lnum(trypos->lnum);       /* XXX */", "    if (!cin_ends_in(get_cursor_line_ptr(), (char_u *)\",\", NULL))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      amount = get_indent_lnum(trypos->lnum);       /* XXX */", "    if (!cin_ends_in(get_cursor_line_ptr(), (char_u *)\",\", NULL))", "      amount += curbuf->b_ind_cpp_baseclass;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  if (amount < curbuf->b_ind_cpp_baseclass)", "    amount = curbuf->b_ind_cpp_baseclass;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      r = skipwhite(p + len);", "      if (ignore != NULL && STRNCMP(r, ignore, STRLEN(ignore)) == 0)", "        r = skipwhite(r + STRLEN(ignore));"], "readability/braces"]
["src/nvim/indent_c.c", ["        r = skipwhite(r + STRLEN(ignore));", "      if (cin_nocode(r))", "        return TRUE;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (cin_nocode(r))", "        return TRUE;", "    }"], "readability/bool"]
["src/nvim/indent_c.c", ["    }", "    if (*p != NUL)", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p != NUL)", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE when \"s\" starts with \"word\" and then a non-ID character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip strings, chars and comments until at or past \"trypos\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the '{' at the start of the block we are in."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" * work. */", "/* foo()    */", "/* {\t    */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["/* foo()    */", "/* {\t    */", "/* }\t    */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["/* foo()    */", "/* {\t    */", "/* }\t    */"], "whitespace/tab"]
["src/nvim/indent_c.c", ["/* {\t    */", "/* }\t    */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["/* {\t    */", "/* }\t    */", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["static pos_T *find_start_brace(void)", "{ /* XXX */", "  pos_T cursor_save;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL) {", "    pos_copy = *trypos;         /* copy pos_T, next findmatch will change it */", "    trypos = &pos_copy;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    pos = NULL;", "    /* ignore the { if it's in a // or / *  * / comment */", "    if ((colnr_T)cin_skip2pos(trypos) == trypos->col"], "readability/multiline_comment"]
["src/nvim/indent_c.c", ["    pos = NULL;", "    /* ignore the { if it's in a // or / *  * / comment */", "    if ((colnr_T)cin_skip2pos(trypos) == trypos->col"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    pos = NULL;", "    /* ignore the { if it's in a // or / *  * / comment */", "    if ((colnr_T)cin_skip2pos(trypos) == trypos->col"], "whitespace/comments"]
["src/nvim/indent_c.c", ["", "      pos_copy = *trypos;           /* copy trypos, findmatch will change it */", "      trypos = &pos_copy;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum", "            - trypos_wk->lnum);", "        if (ind_maxp_wk > 0) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "/*", " * Return ind_maxparen corrected for the difference in line number between the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  if (n > 0 && n < curbuf->b_ind_maxparen / 2)", "    return curbuf->b_ind_maxparen - (int)n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "/*", " * Set w_cursor.col to the column number of the last unmatched ')' or '{' in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "  curwin->w_cursor.col = 0;                 /* default is start of line */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  for (i = 0; l[i] != NUL; i++) {", "    i = (int)(cin_skipcomment(l + i) - l);     /* ignore parens in comments */", "    i = (int)(skip_string(l + i) - l);        /* ignore parens in quotes */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    i = (int)(cin_skipcomment(l + i) - l);     /* ignore parens in comments */", "    i = (int)(skip_string(l + i) - l);        /* ignore parens in quotes */", "    if (l[i] == start)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    i = (int)(skip_string(l + i) - l);        /* ignore parens in quotes */", "    if (l[i] == start)", "      ++open_count;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (l[i] == start)", "      ++open_count;", "    else if (l[i] == end) {"], "readability/increment"]
["src/nvim/indent_c.c", ["      ++open_count;", "    else if (l[i] == end) {", "      if (open_count > 0)"], "readability/braces"]
["src/nvim/indent_c.c", ["    else if (l[i] == end) {", "      if (open_count > 0)", "        --open_count;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (open_count > 0)", "        --open_count;", "      else {"], "readability/increment"]
["src/nvim/indent_c.c", ["        --open_count;", "      else {", "        curwin->w_cursor.col = i;"], "readability/braces"]
["src/nvim/indent_c.c", ["        --open_count;", "      else {", "        curwin->w_cursor.col = i;"], "readability/braces"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Parse 'cinoptions' and set the values in \"curbuf\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Set the default values."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  /* Spaces from a block's opening brace the prevailing indent for that", "   * block should be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace that's at the end of a", "   * line is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent for a line that is not preceded by", "   * an opening brace. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Column where the first { of a function should be located }. */", "  buf->b_ind_first_open = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent a leftmost open brace should be", "   * located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the matching open brace (real location for one at the left", "   * edge; imaginary location from one that ends a line) the matching close"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace sitting in the leftmost", "   * column is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces jump labels should be shifted to the left if N is non-negative,", "   * otherwise the jump label will be put to column 1. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the switch() indent a \"case xx\" label should be located. */", "  buf->b_ind_case = sw;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the \"case xx:\" code after a switch() should be located. */", "  buf->b_ind_case_code = sw;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Lineup break at end of case in switch() with case label. */", "  buf->b_ind_case_break = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the class declaration indent a scope declaration label", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the scope declaration label code should be located. */", "  buf->b_ind_scopedecl_code = sw;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount K&R-style parameters should be indented. */", "  buf->b_ind_param = sw;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a function type spec should be indented. */", "  buf->b_ind_func_type = sw;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a cpp base class declaration or constructor initialization", "   * should be indented. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* additional spaces beyond the prevailing indent a continuation line", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses. */", "  buf->b_ind_unclosed = sw * 2;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses, which", "   * itself is also unclosed. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring spaces from the indent of a line starting with an", "   * unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* If the opening paren is the last nonwhite character on the line, and", "   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring white space when lining up with the character after", "   * an unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Indent a closing parentheses under the line start of the matching", "   * opening parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Indent a closing parentheses under the previous line. */", "  buf->b_ind_paren_prev = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Extra indent for comments. */", "  buf->b_ind_comment = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the comment opener when there is nothing after it. */", "  buf->b_ind_in_comment = 3;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Boolean: if non-zero, use b_ind_in_comment even if there is something", "   * after the comment opener. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Max lines to search for an open paren. */", "  buf->b_ind_maxparen = 20;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Max lines to search for an open comment. */", "  buf->b_ind_maxcomment = 70;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle braces for java code. */", "  buf->b_ind_java = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Not to confuse JS object properties with labels. */", "  buf->b_ind_js = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle blocked cases correctly. */", "  buf->b_ind_keep_case_label = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle C++ namespace. */", "  buf->b_ind_cpp_namespace = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle continuation lines containing conditions of if(), for() and", "   * while(). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        n *= sw;", "        if (divider)", "          n += (sw * fraction + divider / 2) / divider;"], "readability/braces"]
["src/nvim/indent_c.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["    }", "    if (l[1] == '-')", "      n = -n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /* When adding an entry here, also update the default 'cinoptions' in", "     * doc/indent.txt, and add explanation for it! */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    }", "    if (*p == ',')", "      ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (*p == ',')", "      ++p;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the desired indent for C code."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int start_brace;", "#define BRACE_IN_COL0           1           /* '{' is in column 0 */", "#define BRACE_AT_START          2           /* '{' is at start of line */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["#define BRACE_IN_COL0           1           /* '{' is in column 0 */", "#define BRACE_AT_START          2           /* '{' is at start of line */", "#define BRACE_AT_END            3           /* '{' is at end of line */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["#define BRACE_AT_START          2           /* '{' is at start of line */", "#define BRACE_AT_END            3           /* '{' is at end of line */", "  linenr_T ourscope;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int lookfor_break;", "  int lookfor_cpp_namespace = FALSE;", "  int cont_amount = 0;              /* amount for continuation line */"], "readability/bool"]
["src/nvim/indent_c.c", ["  int lookfor_cpp_namespace = FALSE;", "  int cont_amount = 0;              /* amount for continuation line */", "  int original_line_islabel;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* make a copy, value is changed below */", "  int ind_continuation = curbuf->b_ind_continuation;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* remember where the cursor was when we started */", "  cur_curpos = curwin->w_cursor;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* if we are at line 1 zero indent is fine, right? */", "  if (cur_curpos.lnum == 1)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  /* if we are at line 1 zero indent is fine, right? */", "  if (cur_curpos.lnum == 1)", "    return 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* Get a copy of the current contents of the line.", "   * This is required, because only the most recent line obtained with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * In insert mode and the cursor is on a ')' truncate the line at the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  if ((State & INSERT)", "      && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* move the cursor to the start of the line */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  original_line_islabel = cin_islabel();    /* XXX */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * If we are inside a raw string don't change the indent."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (comment_pos != NULL) {", "    /* findmatchlimit() static pos is overwritten, make a copy */", "    tryposCopy = *comment_pos;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Is it a non-case label?\tThen that goes at the left margin too unless:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (original_line_islabel && !curbuf->b_ind_js", "           && curbuf->b_ind_jump_label < 0) {", "    amount = 0;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a \"//\" comment and there is a \"//\" comment in a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cin_islinecomment(theline)", "           && (trypos = find_line_comment()) != NULL) { /* XXX */", "    /* find how indented the line beginning the comment is */"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  if (cin_islinecomment(theline)", "           && (trypos = find_line_comment()) != NULL) { /* XXX */", "    /* find how indented the line beginning the comment is */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           && (trypos = find_line_comment()) != NULL) { /* XXX */", "    /* find how indented the line beginning the comment is */", "    getvcol(curwin, trypos, &col, NULL, NULL);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a comment and not looking at the start of the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  if (!cin_iscomment(theline) && comment_pos != NULL) { /* XXX */", "    int lead_start_len = 2;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int lead_middle_len = 1;", "    char_u lead_start[COM_MAX_LEN];             /* start-comment string */", "    char_u lead_middle[COM_MAX_LEN];            /* middle-comment string */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    char_u lead_start[COM_MAX_LEN];             /* start-comment string */", "    char_u lead_middle[COM_MAX_LEN];            /* middle-comment string */", "    char_u lead_end[COM_MAX_LEN];               /* end-comment string */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    char_u lead_middle[COM_MAX_LEN];            /* middle-comment string */", "    char_u lead_end[COM_MAX_LEN];               /* end-comment string */", "    char_u  *p;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "    /* find how indented the line beginning the comment is */", "    getvcol(curwin, comment_pos, &col, NULL, NULL);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      if (*p == ':')", "        ++p;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (*p == ':')", "        ++p;", "      (void)copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");"], "readability/increment"]
["src/nvim/indent_c.c", ["      } else if (what == COM_END) {", "        /* If our line starts with the middle comment string, line it", "         * up with the comment opener per the 'comments' option. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (curwin->w_cursor.lnum > 1) {", "            /* If the start comment string matches in the previous", "             * line, use the indent of that line plus offset.  If"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));", "            if (STRNCMP(look, lead_start, lead_start_len) == 0)", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "readability/braces"]
["src/nvim/indent_c.c", ["              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);", "            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {"], "readability/braces"]
["src/nvim/indent_c.c", ["            else if (STRNCMP(look, lead_middle,", "                         lead_middle_len) == 0) {", "              amount = get_indent_lnum(curwin->w_cursor.lnum - 1);"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            } else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,", "                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                        lead_start, lead_start_len) != 0) {", "              /* If the start comment string doesn't match with the", "               * start of the comment, skip this entry. XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          if (start_off != 0)", "            amount += start_off;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += start_off;", "          else if (start_align == COM_RIGHT)", "            amount += vim_strsize(lead_start)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        /* If our line starts with the end comment string, line it up", "         * with the middle comment */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          amount = get_indent_lnum(curwin->w_cursor.lnum - 1);", "          /* XXX */", "          if (off != 0)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          /* XXX */", "          if (off != 0)", "            amount += off;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += off;", "          else if (align == COM_RIGHT)", "            amount += vim_strsize(lead_start)"], "readability/braces"]
["src/nvim/indent_c.c", ["                      - vim_strsize(lead_middle);", "          done = TRUE;", "          break;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "    /* If our line starts with an asterisk, line up with the", "     * asterisk in the comment opener; otherwise, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (done)", "      ;"], "readability/braces"]
["src/nvim/indent_c.c", ["    if (done)", "      ;", "    else if (theline[0] == '*')"], "whitespace/semicolon"]
["src/nvim/indent_c.c", ["      ;", "    else if (theline[0] == '*')", "      amount += 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      amount += 1;", "    else {", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["    else {", "      /*", "       * If we are more than one line away from the comment opener, take"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      amount = -1;", "      for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum) {", "        if (linewhite(lnum))                        /* skip blank lines */"], "readability/increment"]
["src/nvim/indent_c.c", ["      for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum) {", "        if (linewhite(lnum))                        /* skip blank lines */", "          continue;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum) {", "        if (linewhite(lnum))                        /* skip blank lines */", "          continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["          continue;", "        amount = get_indent_lnum(lnum);             /* XXX */", "        break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      if (amount == -1) {                           /* use the comment opener */", "        if (!curbuf->b_ind_in_comment2) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            start = ml_get(comment_pos->lnum);", "            look = start + comment_pos->col + 2; /* skip / and * */", "          if (*look != NUL)                         /* if something after it */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            look = start + comment_pos->col + 2; /* skip / and * */", "          if (*look != NUL)                         /* if something after it */", "              comment_pos->col = (colnr_T)(skipwhite(look) - start);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            look = start + comment_pos->col + 2; /* skip / and * */", "          if (*look != NUL)                         /* if something after it */", "              comment_pos->col = (colnr_T)(skipwhite(look) - start);"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (curbuf->b_ind_in_comment2 || *look == NUL)", "          amount += curbuf->b_ind_in_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["  if (*skipwhite(theline) == ']'", "           && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL) {", "    // align with the line containing the '['."], "whitespace/alignment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * Are we inside parentheses or braces?"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   * Are we inside parentheses or braces?", "   */\t\t\t\t\t\t    /* XXX */", "  if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL", "            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["            && curbuf->b_ind_java == 0)", "           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["           || (tryposBrace = find_start_brace()) != NULL", "           || trypos != NULL) {", "    if (trypos != NULL && tryposBrace != NULL) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["    if (trypos != NULL && tryposBrace != NULL) {", "      /* Both an unmatched '(' and '{' is found.  Use the one which is", "       * closer to the current cursor position, set the other to NULL. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       * closer to the current cursor position, set the other to NULL. */", "      if (trypos->lnum != tryposBrace->lnum", "          ? trypos->lnum < tryposBrace->lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["        trypos = NULL;", "      else", "        tryposBrace = NULL;"], "readability/braces"]
["src/nvim/indent_c.c", ["      our_paren_pos = *trypos;", "      /*", "       * If the matching paren is more than one line away, use the indent of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (theline[0] == ')' && curbuf->b_ind_paren_prev) {", "        /* Line up with the start of the matching paren line. */", "        amount = get_indent_lnum(curwin->w_cursor.lnum - 1);      /* XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        /* Line up with the start of the matching paren line. */", "        amount = get_indent_lnum(curwin->w_cursor.lnum - 1);      /* XXX */", "      } else {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = -1;", "        for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum) {", "          l = skipwhite(ml_get(lnum));"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* XXX */", "          if ((trypos = find_match_paren("], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          if ((trypos = find_match_paren(", "                   corr_ind_maxparen(&cur_curpos))) != NULL", "              && trypos->lnum == our_paren_pos.lnum"], "whitespace/indent"]
["src/nvim/indent_c.c", ["              && trypos->col == our_paren_pos.col) {", "            amount = get_indent_lnum(lnum);             /* XXX */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (theline[0] == ')') {", "              if (our_paren_pos.lnum != lnum", "                  && cur_amount > amount)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Line up with line where the matching paren is. XXX"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (curbuf->b_ind_if_for_while) {", "          /* Look for the outermost opening parenthesis on this line", "           * and check whether it belongs to an \"if\", \"for\" or \"while\". */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /* Ignore a '(' in front of the line that has a match before", "           * our matching '('. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          curwin->w_cursor.col = look_col + 1;", "          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))"], "readability/braces"]
["src/nvim/indent_c.c", ["          if ((trypos = findmatchlimit(NULL, ')', 0,", "                   curbuf->b_ind_maxparen))", "              != NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                && ignore_paren_col == 0)) {", "          /*", "           * If we're looking at a close paren, line up right there;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && cin_ends_in(l, (char_u *)\"(\", NULL)) {", "              /* look for opening unmatched paren, indent one level", "               * for each additional level */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              n = 1;", "              for (col = 0; col < our_paren_pos.col; ++col) {", "                switch (l[col]) {"], "readability/increment"]
["src/nvim/indent_c.c", ["                case '}': if (n > 1)", "                    --n;", "                  break;"], "readability/increment"]
["src/nvim/indent_c.c", ["              amount += n * curbuf->b_ind_unclosed_wrapped;", "            } else if (curbuf->b_ind_unclosed_whiteok)", "              our_paren_pos.col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              our_paren_pos.col++;", "            else {", "              col = our_paren_pos.col + 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["              col = our_paren_pos.col + 1;", "              while (ascii_iswhite(l[col]))", "                col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["                col++;", "              if (l[col] != NUL)                /* In case of trailing space */", "                our_paren_pos.col = col;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                col++;", "              if (l[col] != NUL)                /* In case of trailing space */", "                our_paren_pos.col = col;"], "readability/braces"]
["src/nvim/indent_c.c", ["                our_paren_pos.col = col;", "              else", "                our_paren_pos.col++;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Find how indented the paren is, or the character after it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            getvcol(curwin, &our_paren_pos, &col, NULL, NULL);", "            if (cur_amount > (int)col)", "              cur_amount = col;"], "readability/braces"]
["src/nvim/indent_c.c", ["        if (theline[0] == ')' && curbuf->b_ind_matching_paren) {", "          /* Line up with the start of the matching paren line. */", "        } else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                       && *look == '(' && ignore_paren_col == 0)) {", "          if (cur_amount != MAXCOL)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        } else {", "          /* Add b_ind_unclosed2 for each '(' before our matching one,", "           * but ignore (void) before the line (ignore_paren_col). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          while ((int)our_paren_pos.col > ignore_paren_col) {", "            --our_paren_pos.col;", "            switch (*ml_get_pos(&our_paren_pos)) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* Use b_ind_unclosed once, when the first '(' is not inside", "           * braces */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           * braces */", "          if (col == MAXCOL)", "            amount += curbuf->b_ind_unclosed;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["            amount += curbuf->b_ind_unclosed;", "          else {", "            curwin->w_cursor.lnum = our_paren_pos.lnum;"], "readability/braces"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * For a line starting with ')' use the minimum of the two"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          if (cur_amount < amount)", "            amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /* add extra indent for a comment */", "      if (cin_iscomment(theline))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      /* add extra indent for a comment */", "      if (cin_iscomment(theline))", "        amount += curbuf->b_ind_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /*", "       * Now figure out how indented the line is in general."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        amount = col;", "        if (*start == '{')", "          start_brace = BRACE_IN_COL0;"], "readability/braces"]
["src/nvim/indent_c.c", ["          start_brace = BRACE_IN_COL0;", "        else", "          start_brace = BRACE_AT_START;"], "readability/braces"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        // It could have been something like", "        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t   case 1: if (asdf &&", "        //\t\t\tldfd) {", "        //\t\t    }"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/tab"]
["src/nvim/indent_c.c", ["        //\t\t\tldfd) {", "        //\t\t    }", "        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)"], "whitespace/comments"]
["src/nvim/indent_c.c", ["        if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)", "            && cin_iscase(skipwhite(get_cursor_line_ptr()), FALSE)) {", "          amount = get_indent();"], "readability/bool"]
["src/nvim/indent_c.c", ["      if (theline[0] == '}') {", "        /*", "         * they may want closing braces to line up with something"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else {", "        /*", "         * If we're looking at an \"else\", try to find an \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        lookfor = LOOKFOR_INITIAL;", "        if (cin_iselse(theline))", "          lookfor = LOOKFOR_IF;"], "readability/braces"]
["src/nvim/indent_c.c", ["          lookfor = LOOKFOR_IF;", "        else if (cin_iswhileofdo(theline, cur_curpos.lnum))     /* XXX */", "          lookfor = LOOKFOR_DO;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          lookfor = LOOKFOR_IF;", "        else if (cin_iswhileofdo(theline, cur_curpos.lnum))     /* XXX */", "          lookfor = LOOKFOR_DO;"], "readability/braces"]
["src/nvim/indent_c.c", ["          if (find_match(lookfor, ourscope) == OK) {", "            amount = get_indent();              /* XXX */", "            goto theend;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * We get here if we are not on an \"while-of-do\" or \"else\" (or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * if the '{' is  _really_ at the left margin, use the imaginary"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          } else {", "            /* Compensate for adding b_ind_open_extra later. */", "            amount -= curbuf->b_ind_open_extra;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            amount -= curbuf->b_ind_open_extra;", "            if (amount < 0)", "              amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "        if (cin_iscase(theline, FALSE)) {       /* it's a switch() label */", "          lookfor = LOOKFOR_CASE;       /* find a previous switch() label */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        if (cin_iscase(theline, FALSE)) {       /* it's a switch() label */", "          lookfor = LOOKFOR_CASE;       /* find a previous switch() label */"], "readability/bool"]
["src/nvim/indent_c.c", ["        if (cin_iscase(theline, FALSE)) {       /* it's a switch() label */", "          lookfor = LOOKFOR_CASE;       /* find a previous switch() label */", "          amount += curbuf->b_ind_case;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          amount += curbuf->b_ind_case;", "        } else if (cin_isscopedecl(theline)) { /* private:, ... */", "          lookfor = LOOKFOR_SCOPEDECL;          /* class decl is this block */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        } else if (cin_isscopedecl(theline)) { /* private:, ... */", "          lookfor = LOOKFOR_SCOPEDECL;          /* class decl is this block */", "          amount += curbuf->b_ind_scopedecl;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        } else {", "          if (curbuf->b_ind_case_break && cin_isbreak(theline))", "            /* break; ... */"], "readability/braces"]
["src/nvim/indent_c.c", ["          if (curbuf->b_ind_case_break && cin_isbreak(theline))", "            /* break; ... */", "            lookfor_break = TRUE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            /* break; ... */", "            lookfor_break = TRUE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["          lookfor = LOOKFOR_INITIAL;", "          /* b_ind_level from start of block */", "          amount += curbuf->b_ind_level;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * If we went all the way back to the start of our scope, line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  < ourscope - curbuf->b_ind_maxparen) {", "                /* nothing found (abuse curbuf->b_ind_maxparen as", "                 * limit) assume terminated line (i.e. a variable"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * initialization) */", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else if (!curbuf->b_ind_js)", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're in a comment or raw string now, skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (cin_nocode(l))", "                continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we are at top level and the line looks like a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0)) {", "                /* if the line is terminated with another ','", "                 * it is a continued variable initialization."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated == ',')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* if it is an enum declaration or an assignment,", "                 * we are done."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (terminated != ';' && cin_isinit())", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* nothing useful found */", "                if (terminated == 0 || terminated == '{')"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                /* nothing useful found */", "                if (terminated == 0 || terminated == '{')", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (terminated != ';') {", "                /* Skip parens and braces. Position the cursor", "                 * over the rightmost paren, so that matching it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * will take us back to the start of the line.", "                 */\t\t\t\t\t/* XXX */", "                trypos = NULL;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                trypos = NULL;", "                if (find_last_paren(l, '(', ')'))", "                  trypos = find_match_paren("], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (trypos == NULL && find_last_paren(l, '{', '}'))", "                  trypos = find_start_brace();"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /* it's a variable declaration, add indentation", "               * like in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            } else if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (lookfor_cpp_namespace) {", "                /*", "                 * Looking for C++ namespace, need to look further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 */", "                if (curwin->w_cursor.lnum == ourscope)", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if (curwin->w_cursor.lnum == 0", "                    || curwin->w_cursor.lnum"], "readability/braces"]
["src/nvim/indent_c.c", ["", "                /* If we're in a comment or raw string now, skip", "                 * to the start of it. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                /* Finally the actual check for \"namespace\". */", "                if (cin_is_cpp_namespace(l)) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                if (cin_nocode(l))", "                  continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * If this is a switch() label, may line up relative to that."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          iscase = cin_iscase(l, FALSE);", "          if (iscase || cin_isscopedecl(l)) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (iscase || cin_isscopedecl(l)) {", "            /* we are only looking for cpp base class", "             * declaration/initialization any longer */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * declaration/initialization any longer */", "            if (lookfor == LOOKFOR_CPP_BASECLASS)", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /* When looking for a \"do\" we are not interested in", "             * labels. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             * labels. */", "            if (whilelevel > 0)", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\tcase xx:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\tcase xx:\t<- line up with this case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (       (iscase && lookfor == LOOKFOR_CASE)", "                       || (iscase && lookfor_break)", "                       || (!iscase && lookfor == LOOKFOR_SCOPEDECL)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                       || (iscase && lookfor_break)", "                       || (!iscase && lookfor == LOOKFOR_SCOPEDECL)) {", "              /*"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["                       || (!iscase && lookfor == LOOKFOR_SCOPEDECL)) {", "              /*", "               * Check that this case label is not for another"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               * switch()", "               */\t\t\t\t    /* XXX */", "              if ((trypos = find_start_brace()) == NULL"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || trypos->lnum == ourscope) {", "                amount = get_indent();                  /* XXX */", "                break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            n = get_indent_nolabel(curwin->w_cursor.lnum);          /* XXX */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: if (cond)\t    <- line up with this if"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (n)", "                amount = n;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              if (!lookfor_break)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             *\t case xx: x = x + 1;\t    <- line up with this x"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (l != NULL && cin_is_cinword(l)) {", "                if (theline[0] == '{')", "                  amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount += curbuf->b_ind_open_extra;", "                else", "                  amount += curbuf->b_ind_level"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Try to get the indent of a statement before the switch"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            scope_amount = get_indent() + (iscase            /* XXX */", "                                           ? curbuf->b_ind_case_code"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Looking for a switch() label or C++ scope declaration,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore jump labels with nothing after them."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            l = after_label(get_cursor_line_ptr());", "            if (l == NULL || cin_nocode(l))", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore #defines, #if, etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Are we at the start of a cpp base class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           * constructor initialization?", "           */\t\t\t\t\t\t    /* XXX */", "          n = FALSE;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */\t\t\t\t\t\t    /* XXX */", "          n = FALSE;", "          if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0) {"], "readability/bool"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_UNTERM) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["            } else if (theline[0] == '{') {", "              /* Need to find start of the declaration. */", "              lookfor = LOOKFOR_UNTERM;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              continue;", "            } else", "              /* XXX */"], "readability/braces"]
["src/nvim/indent_c.c", ["            } else", "              /* XXX */", "              amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {", "            /* only look, whether there is a cpp base class", "             * declaration or initialization before the opening brace."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/braces"]
["src/nvim/indent_c.c", ["             */", "            if (cin_isterminated(l, TRUE, FALSE))", "              break;"], "readability/bool"]
["src/nvim/indent_c.c", ["              break;", "            else", "              continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "          /*", "           * What happens next depends on the line being terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["          if (js_cur_has_key) {", "            js_cur_has_key = false; // only check the first line", "            if (curbuf->b_ind_js && terminated == ',') {"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/tab"]
["src/nvim/indent_c.c", ["            // that starts it so we can get the right prevailing indent", "            //\t   if ( foo &&", "            //\t\t    bar )"], "whitespace/comments"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/tab"]
["src/nvim/indent_c.c", ["            //\t   if ( foo &&", "            //\t\t    bar )", ""], "whitespace/comments"]
["src/nvim/indent_c.c", ["            // braces.", "            if (trypos == NULL && terminated == ','", "                && find_last_paren(l, '{', '}'))"], "readability/braces"]
["src/nvim/indent_c.c", ["            if (trypos != NULL) {", "              /*", "               * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              l = get_cursor_line_ptr();", "              if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                ++curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["              if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                ++curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Skip over continuation lines to find the one to get the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = ml_get(curwin->w_cursor.lnum - 1);", "                if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If this is just above the line we are indenting, and it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              /*", "               * Only add b_ind_open_extra when the current line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               */", "              if (*skipwhite(l) != '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js) {", "                /* have to look back, whether it is a cpp base", "                 * class declaration or initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Check if we are after an \"if\", \"while\", etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (cin_is_cinword(l) || cin_iselse(skipwhite(l))) {", "              /*", "               * Found an unterminated line after an if (), line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || lookfor == LOOKFOR_ENUM_OR_INIT) {", "                if (cont_amount > 0)", "                  amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  amount = cont_amount;", "                else", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If this is just above the line we are indenting, we"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * Special trick: when expecting the while () after a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_isdo(l)) {", "                if (whilelevel == 0)", "                  break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  break;", "                --whilelevel;", "              }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When searching for a terminated line, don't use the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_iselse(l) && whilelevel == 0) {", "                /* If we're looking at \"} else\", let's make sure we", "                 * find the opening brace of the enclosing scope,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                 * not the one from \"if () {\". */", "                if (*l == '}')", "                  curwin->w_cursor.col ="], "readability/braces"]
["src/nvim/indent_c.c", ["", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If we're below an unterminated line that is not an"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * Found two unterminated lines on a row, line up with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_UNTERM) {", "                /* When line ends in a comma add extra indent */", "                if (terminated == ',')"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                /* When line ends in a comma add extra indent */", "                if (terminated == ',')", "                  amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_ENUM_OR_INIT) {", "                /* Found two lines ending in ',', lineup with the", "                 * lowest one, but check for cpp base class"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                if (terminated == ',') {", "                  if (curbuf->b_ind_cpp_baseclass == 0)", "                    break;"], "readability/braces"]
["src/nvim/indent_c.c", ["                    // XXX", "                    cont_amount = cin_get_equal_amount( curwin->w_cursor.lnum);", "                  }"], "whitespace/parens"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * Check if we are after a while (cond);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*", "             * Found an unterminated line after a while ();, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["              lookfor = LOOKFOR_TERM;", "              amount = get_indent();                /* XXX */", "              if (theline[0] == '{')"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = get_indent();                /* XXX */", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            ++whilelevel;", "          }"], "readability/increment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * We are after a \"normal\" statement."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["          else {", "            /*", "             * Skip single break line, if before a switch label. It"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Handle \"do {\" line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_isdo(l)) {", "                amount = get_indent();                  /* XXX */", "                --whilelevel;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                amount = get_indent();                  /* XXX */", "                --whilelevel;", "                continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above an unterminated line. Add"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                || lookfor == LOOKFOR_ENUM_OR_INIT) {", "              if (cont_amount > 0)", "                amount = cont_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount = cont_amount;", "              else", "                amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above a terminated line or \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            if (lookfor == LOOKFOR_TERM) {", "              if (!lookfor_break && whilelevel == 0)", "                break;"], "readability/braces"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * First line above the one we're indenting is terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * position the cursor over the rightmost paren, so"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                  && (trypos = find_match_paren(", "                          curbuf->b_ind_maxparen)) != NULL) {", "                /*"], "whitespace/indent"]
["src/nvim/indent_c.c", ["                          curbuf->b_ind_maxparen)) != NULL) {", "                /*", "                 * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = get_cursor_line_ptr();", "                if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                  ++curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["                if (cin_iscase(l, FALSE) || cin_isscopedecl(l)) {", "                  ++curwin->w_cursor.lnum;", "                  curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "              /* When aligning with the case statement, don't align", "               * with a statement after it."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              iscase = (curbuf->b_ind_keep_case_label", "                        && cin_iscase(l, FALSE));", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              if (theline[0] == '{')", "                amount += curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["                amount += curbuf->b_ind_open_extra;", "              /* See remark above: \"Only add b_ind_open_extra..\" */", "              l = skipwhite(l);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              l = skipwhite(l);", "              if (*l == '{')", "                amount -= curbuf->b_ind_open_extra;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * When a terminated line starts with \"else\" skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  && whilelevel == 0) {", "                if ((trypos = find_start_brace()) == NULL", "                    || find_match(LOOKFOR_IF, trypos->lnum)"], "readability/braces"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're at the end of a block, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              l = get_cursor_line_ptr();", "              if (find_last_paren(l, '{', '}')           /* XXX */", "                  && (trypos = find_start_brace()) != NULL) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                curwin->w_cursor = *trypos;", "                /* if not \"else {\" check for terminated again */", "                /* but skip block for \"} else {\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                /* if not \"else {\" check for terminated again */", "                /* but skip block for \"} else {\" */", "                l = cin_skipcomment(get_cursor_line_ptr());"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                l = cin_skipcomment(get_cursor_line_ptr());", "                if (*l == '}' || !cin_iselse(l))", "                  goto term_again;"], "readability/braces"]
["src/nvim/indent_c.c", ["                  goto term_again;", "                ++curwin->w_cursor.lnum;", "                curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /* add extra indent for a comment */", "    if (cin_iscomment(theline))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    /* add extra indent for a comment */", "    if (cin_iscomment(theline))", "      amount += curbuf->b_ind_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /* subtract extra left-shift for jump labels */", "    if (curbuf->b_ind_jump_label > 0 && original_line_islabel)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    /* subtract extra left-shift for jump labels */", "    if (curbuf->b_ind_jump_label > 0 && original_line_islabel)", "      amount -= curbuf->b_ind_jump_label;"], "readability/braces"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If the NEXT line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (cur_curpos.lnum < curbuf->b_ml.ml_line_count", "          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_nocode(theline)", "          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '{') == NULL", "          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && vim_strchr(theline, '}') == NULL", "          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\":\", NULL)", "          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && !cin_ends_in(theline, (char_u *)\",\", NULL)", "          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {", "    amount = curbuf->b_ind_func_type;"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["          && cin_isfuncdecl(NULL, cur_curpos.lnum + 1,", "              cur_curpos.lnum + 1)", "          && !cin_isterminated(theline, false, true)) {"], "whitespace/alignment"]
["src/nvim/indent_c.c", ["", "  /* search backwards until we find something we recognize */", "  amount = 0;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (n) {", "      /* XXX */", "      amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    if (cin_nocode(l))", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ',', use one level of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\\\')) {", "      /* take us back to opening paren */", "      if (find_last_paren(l, '(', ')')"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      /* take us back to opening paren */", "      if (find_last_paren(l, '(', ')')", "          && (trypos = find_match_paren("], "readability/braces"]
["src/nvim/indent_c.c", ["", "      /* For a line ending in ',' that is a continuation line go", "       * back to the first line with a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        l = ml_get(curwin->w_cursor.lnum - 1);", "        if (*l == NUL || l[STRLEN(l) - 1] != '\\\\')", "          break;"], "readability/braces"]
["src/nvim/indent_c.c", ["          break;", "        --curwin->w_cursor.lnum;", "        curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "      amount = get_indent();                    /* XXX */", ""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      if (amount == 0)", "        amount = cin_first_id_amount();"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cin_first_id_amount();", "      if (amount == 0)", "        amount = ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the line looks like a function declaration, and we're"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))          /* XXX */", "      break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))          /* XXX */", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Finding the closing '}' of a previous function.  Put"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (*skipwhite(l) == '}')", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*\t\t\t    (matching {)", "     * If the previous line ends on '};' (maybe followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (cin_ends_in(l, (char_u *)\"};\", NULL))", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Find a line only has a semicolon that belongs to a previous"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      if (curwin->w_cursor.lnum > 0", "          && cin_ends_in(look, (char_u *)\"}\", NULL))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the PREVIOUS line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ';' and the line before the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      l = ml_get(curwin->w_cursor.lnum - 1);", "      if (cin_ends_in(l, (char_u *)\",\", NULL)", "          || (*l != NUL && l[STRLEN(l) - 1] == '\\\\'))"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * Doesn't look like anything interesting -- so just"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)", "      curwin->w_cursor = *trypos;"], "readability/braces"]
["src/nvim/indent_c.c", ["      curwin->w_cursor = *trypos;", "    amount = get_indent();              /* XXX */", "    break;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* add extra indent for a comment */", "  if (cin_iscomment(theline))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  /* add extra indent for a comment */", "  if (cin_iscomment(theline))", "    amount += curbuf->b_ind_comment;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "  /* add extra indent if the previous line ended in a backslash:", "   *\t      \"asdfasdf\\"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);", "      if (cur_amount > 0)", "        amount = cur_amount;"], "readability/braces"]
["src/nvim/indent_c.c", ["        amount = cur_amount;", "      else if (cur_amount == 0)", "        amount += ind_continuation;"], "readability/braces"]
["src/nvim/indent_c.c", ["theend:", "  if (amount < 0)", "    amount = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["laterend:", "  /* put the cursor back where it belongs */", "  curwin->w_cursor = cur_curpos;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  return amount;", "}", ""], "readability/fn_size"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["        && !cin_isif(look)", "        && !cin_isdo(look)                                   /* XXX */", "        && !cin_iswhileofdo(look, curwin->w_cursor.lnum)) {"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've gone outside the braces entirely,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    theirscope = find_start_brace();        /* XXX */", "    if (theirscope == NULL)"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    theirscope = find_start_brace();        /* XXX */", "    if (theirscope == NULL)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if the brace enclosing this is further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum < ourscope)", "      break;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if they're enclosed in a *deeper* brace,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["     */", "    if (theirscope->lnum > ourscope)", "      continue;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was an \"else\" (that's not an \"else if\")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      mightbeif = cin_skipcomment(look + 4);", "      if (!cin_isif(mightbeif))", "        ++elselevel;"], "readability/braces"]
["src/nvim/indent_c.c", ["      if (!cin_isif(mightbeif))", "        ++elselevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was a \"while\" then we need to go back to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_iswhileofdo(look, curwin->w_cursor.lnum)) {", "      ++whilelevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /* If it's an \"if\" decrement elselevel */", "    look = cin_skipcomment(get_cursor_line_ptr());"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_isif(look)) {", "      elselevel--;", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      elselevel--;", "      /*", "       * When looking for an \"if\" ignore \"while\"s that"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["       */", "      if (elselevel == 0 && lookfor == LOOKFOR_IF)", "        whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /* If it's a \"do\" decrement whilelevel */", "    if (cin_isdo(look))"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    /* If it's a \"do\" decrement whilelevel */", "    if (cin_isdo(look))", "      whilelevel--;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've used up all the elses, then"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Do C or expression indenting on the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  if (*curbuf->b_p_inde != NUL)", "    fixthisline(get_expr_indent);"], "readability/braces"]
["src/nvim/indent_c.c", ["    fixthisline(get_expr_indent);", "  else", "    fixthisline(get_c_indent);"], "readability/braces"]

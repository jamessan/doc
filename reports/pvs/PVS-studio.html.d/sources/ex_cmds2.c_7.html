
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/// @file ex_cmds2.c</a>
<a name="ln5">///</a>
<a name="ln6">/// Some more functions for command line commands</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;fcntl.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#ifdef HAVE_LOCALE_H</a>
<a name="ln17"># include &lt;locale.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln30">#include &quot;nvim/mark.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln34">#include &quot;nvim/garray.h&quot;</a>
<a name="ln35">#include &quot;nvim/memory.h&quot;</a>
<a name="ln36">#include &quot;nvim/move.h&quot;</a>
<a name="ln37">#include &quot;nvim/normal.h&quot;</a>
<a name="ln38">#include &quot;nvim/ops.h&quot;</a>
<a name="ln39">#include &quot;nvim/option.h&quot;</a>
<a name="ln40">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln43">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln44">#include &quot;nvim/screen.h&quot;</a>
<a name="ln45">#include &quot;nvim/strings.h&quot;</a>
<a name="ln46">#include &quot;nvim/undo.h&quot;</a>
<a name="ln47">#include &quot;nvim/version.h&quot;</a>
<a name="ln48">#include &quot;nvim/window.h&quot;</a>
<a name="ln49">#include &quot;nvim/profile.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln54">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">/// Growarray to store info about already sourced scripts.</a>
<a name="ln58">/// Also store the dev/ino, so that we don't have to stat() each</a>
<a name="ln59">/// script when going through the list.</a>
<a name="ln60">typedef struct scriptitem_S {</a>
<a name="ln61">  char_u      *sn_name;</a>
<a name="ln62">  bool file_id_valid;</a>
<a name="ln63">  FileID file_id;</a>
<a name="ln64">  bool sn_prof_on;              ///&lt; true when script is/was profiled</a>
<a name="ln65">  bool sn_pr_force;             ///&lt; forceit: profile functions in this script</a>
<a name="ln66">  proftime_T sn_pr_child;       ///&lt; time set when going into first child</a>
<a name="ln67">  int sn_pr_nest;               ///&lt; nesting for sn_pr_child</a>
<a name="ln68">  // profiling the script as a whole</a>
<a name="ln69">  int sn_pr_count;              ///&lt; nr of times sourced</a>
<a name="ln70">  proftime_T sn_pr_total;       ///&lt; time spent in script + children</a>
<a name="ln71">  proftime_T sn_pr_self;        ///&lt; time spent in script itself</a>
<a name="ln72">  proftime_T sn_pr_start;       ///&lt; time at script start</a>
<a name="ln73">  proftime_T sn_pr_children;    ///&lt; time in children after script start</a>
<a name="ln74">  // profiling the script per line</a>
<a name="ln75">  garray_T sn_prl_ga;           ///&lt; things stored for every line</a>
<a name="ln76">  proftime_T sn_prl_start;      ///&lt; start time for current line</a>
<a name="ln77">  proftime_T sn_prl_children;   ///&lt; time spent in children for this line</a>
<a name="ln78">  proftime_T sn_prl_wait;       ///&lt; wait start time for current line</a>
<a name="ln79">  linenr_T sn_prl_idx;          ///&lt; index of line being timed; -1 if none</a>
<a name="ln80">  int sn_prl_execed;            ///&lt; line being timed was executed</a>
<a name="ln81">} scriptitem_T;</a>
<a name="ln82"> </a>
<a name="ln83">static garray_T script_items = { 0, 0, sizeof(scriptitem_T), 4, NULL };</a>
<a name="ln84">#define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])</a>
<a name="ln85"> </a>
<a name="ln86">// Struct used in sn_prl_ga for every line of a script.</a>
<a name="ln87">typedef struct sn_prl_S {</a>
<a name="ln88">  int snp_count;                ///&lt; nr of times line was executed</a>
<a name="ln89">  proftime_T sn_prl_total;      ///&lt; time spent in a line + children</a>
<a name="ln90">  proftime_T sn_prl_self;       ///&lt; time spent in a line itself</a>
<a name="ln91">} sn_prl_T;</a>
<a name="ln92"> </a>
<a name="ln93">/// Structure used to store info for each sourced file.</a>
<a name="ln94">/// It is shared between do_source() and getsourceline().</a>
<a name="ln95">/// This is required, because it needs to be handed to do_cmdline() and</a>
<a name="ln96">/// sourcing can be done recursively.</a>
<a name="ln97">struct source_cookie {</a>
<a name="ln98">  FILE *fp;                     ///&lt; opened file for sourcing</a>
<a name="ln99">  char_u *nextline;             ///&lt; if not NULL: line that was read ahead</a>
<a name="ln100">  linenr_T sourcing_lnum;       ///&lt; line number of the source file</a>
<a name="ln101">  int finished;                 ///&lt; &quot;:finish&quot; used</a>
<a name="ln102">#if defined(USE_CRNL)</a>
<a name="ln103">  int fileformat;               ///&lt; EOL_UNKNOWN, EOL_UNIX or EOL_DOS</a>
<a name="ln104">  bool error;                   ///&lt; true if LF found after CR-LF</a>
<a name="ln105">#endif</a>
<a name="ln106">  linenr_T breakpoint;          ///&lt; next line with breakpoint or zero</a>
<a name="ln107">  char_u *fname;                ///&lt; name of sourced file</a>
<a name="ln108">  int dbg_tick;                 ///&lt; debug_tick when breakpoint was set</a>
<a name="ln109">  int level;                    ///&lt; top nesting level of sourced file</a>
<a name="ln110">  vimconv_T conv;               ///&lt; type of conversion</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">#  define PRL_ITEM(si, idx)     (((sn_prl_T *)(si)-&gt;sn_prl_ga.ga_data)[(idx)])</a>
<a name="ln114"> </a>
<a name="ln115">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln116"># include &quot;ex_cmds2.c.generated.h&quot;</a>
<a name="ln117">#endif</a>
<a name="ln118"> </a>
<a name="ln119">/// batch mode debugging: don't save and restore typeahead.</a>
<a name="ln120">static bool debug_greedy = false;</a>
<a name="ln121"> </a>
<a name="ln122">/// Debug mode. Repeatedly get Ex commands, until told to continue normal</a>
<a name="ln123">/// execution.</a>
<a name="ln124">void do_debug(char_u *cmd)</a>
<a name="ln125">{</a>
<a name="ln126">  int save_msg_scroll = msg_scroll;</a>
<a name="ln127">  int save_State = State;</a>
<a name="ln128">  int save_did_emsg = did_emsg;</a>
<a name="ln129">  const bool save_cmd_silent = cmd_silent;</a>
<a name="ln130">  int save_msg_silent = msg_silent;</a>
<a name="ln131">  int save_emsg_silent = emsg_silent;</a>
<a name="ln132">  int save_redir_off = redir_off;</a>
<a name="ln133">  tasave_T typeaheadbuf;</a>
<a name="ln134">  bool typeahead_saved = false;</a>
<a name="ln135">  int save_ignore_script = 0;</a>
<a name="ln136">  int save_ex_normal_busy;</a>
<a name="ln137">  int n;</a>
<a name="ln138">  char_u      *cmdline = NULL;</a>
<a name="ln139">  char_u      *p;</a>
<a name="ln140">  char        *tail = NULL;</a>
<a name="ln141">  static int last_cmd = 0;</a>
<a name="ln142">#define CMD_CONT        1</a>
<a name="ln143">#define CMD_NEXT        2</a>
<a name="ln144">#define CMD_STEP        3</a>
<a name="ln145">#define CMD_FINISH      4</a>
<a name="ln146">#define CMD_QUIT        5</a>
<a name="ln147">#define CMD_INTERRUPT   6</a>
<a name="ln148">#define CMD_BACKTRACE   7</a>
<a name="ln149">#define CMD_FRAME       8</a>
<a name="ln150">#define CMD_UP          9</a>
<a name="ln151">#define CMD_DOWN        10</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">  RedrawingDisabled++;          // don't redisplay the window</a>
<a name="ln155">  no_wait_return++;             // don't wait for return</a>
<a name="ln156">  did_emsg = false;             // don't use error from debugged stuff</a>
<a name="ln157">  cmd_silent = false;           // display commands</a>
<a name="ln158">  msg_silent = false;           // display messages</a>
<a name="ln159">  emsg_silent = false;          // display error messages</a>
<a name="ln160">  redir_off = true;             // don't redirect debug commands</a>
<a name="ln161"> </a>
<a name="ln162">  State = NORMAL;</a>
<a name="ln163">  debug_mode = true;</a>
<a name="ln164"> </a>
<a name="ln165">  if (!debug_did_msg) {</a>
<a name="ln166">    MSG(_(&quot;Entering Debug mode.  Type \&quot;cont\&quot; to continue.&quot;));</a>
<a name="ln167">  }</a>
<a name="ln168">  if (sourcing_name != NULL) {</a>
<a name="ln169">    msg(sourcing_name);</a>
<a name="ln170">  }</a>
<a name="ln171">  if (sourcing_lnum != 0) {</a>
<a name="ln172">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln173">  } else {</a>
<a name="ln174">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  // Repeat getting a command and executing it.</a>
<a name="ln178">  for (;; ) {</a>
<a name="ln179">    msg_scroll = true;</a>
<a name="ln180">    need_wait_return = false;</a>
<a name="ln181">    // Save the current typeahead buffer and replace it with an empty one.</a>
<a name="ln182">    // This makes sure we get input from the user here and don't interfere</a>
<a name="ln183">    // with the commands being executed.  Reset &quot;ex_normal_busy&quot; to avoid</a>
<a name="ln184">    // the side effects of using &quot;:normal&quot;. Save the stuff buffer and make</a>
<a name="ln185">    // it empty. Set ignore_script to avoid reading from script input.</a>
<a name="ln186">    save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln187">    ex_normal_busy = 0;</a>
<a name="ln188">    if (!debug_greedy) {</a>
<a name="ln189">      save_typeahead(&amp;typeaheadbuf);</a>
<a name="ln190">      typeahead_saved = true;</a>
<a name="ln191">      save_ignore_script = ignore_script;</a>
<a name="ln192">      ignore_script = true;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">    xfree(cmdline);</a>
<a name="ln196">    cmdline = (char_u *)getcmdline_prompt('&gt;', NULL, 0, EXPAND_NOTHING, NULL,</a>
<a name="ln197">                                          CALLBACK_NONE);</a>
<a name="ln198"> </a>
<a name="ln199">    if (typeahead_saved) {</a>
<a name="ln200">      restore_typeahead(&amp;typeaheadbuf);</a>
<a name="ln201">      ignore_script = save_ignore_script;</a>
<a name="ln202">    }</a>
<a name="ln203">    ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln204"> </a>
<a name="ln205">    cmdline_row = msg_row;</a>
<a name="ln206">    msg_starthere();</a>
<a name="ln207">    if (cmdline != NULL) {</a>
<a name="ln208">      // If this is a debug command, set &quot;last_cmd&quot;.</a>
<a name="ln209">      // If not, reset &quot;last_cmd&quot;.</a>
<a name="ln210">      // For a blank line use previous command.</a>
<a name="ln211">      p = skipwhite(cmdline);</a>
<a name="ln212">      if (*p != NUL) {</a>
<a name="ln213">        switch (*p) {</a>
<a name="ln214">        case 'c': last_cmd = CMD_CONT;</a>
<a name="ln215">          tail = &quot;ont&quot;;</a>
<a name="ln216">          break;</a>
<a name="ln217">        case 'n': last_cmd = CMD_NEXT;</a>
<a name="ln218">          tail = &quot;ext&quot;;</a>
<a name="ln219">          break;</a>
<a name="ln220">        case 's': last_cmd = CMD_STEP;</a>
<a name="ln221">          tail = &quot;tep&quot;;</a>
<a name="ln222">          break;</a>
<a name="ln223">        case 'f':</a>
<a name="ln224">          last_cmd = 0;</a>
<a name="ln225">          if (p[1] == 'r') {</a>
<a name="ln226">            last_cmd = CMD_FRAME;</a>
<a name="ln227">            tail = &quot;rame&quot;;</a>
<a name="ln228">          } else {</a>
<a name="ln229">            last_cmd = CMD_FINISH;</a>
<a name="ln230">            tail = &quot;inish&quot;;</a>
<a name="ln231">          }</a>
<a name="ln232">          break;</a>
<a name="ln233">        case 'q': last_cmd = CMD_QUIT;</a>
<a name="ln234">          tail = &quot;uit&quot;;</a>
<a name="ln235">          break;</a>
<a name="ln236">        case 'i': last_cmd = CMD_INTERRUPT;</a>
<a name="ln237">          tail = &quot;nterrupt&quot;;</a>
<a name="ln238">          break;</a>
<a name="ln239">        case 'b':</a>
<a name="ln240">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln241">          if (p[1] == 't') {</a>
<a name="ln242">            tail = &quot;t&quot;;</a>
<a name="ln243">          } else {</a>
<a name="ln244">            tail = &quot;acktrace&quot;;</a>
<a name="ln245">          }</a>
<a name="ln246">          break;</a>
<a name="ln247">        case 'w':</a>
<a name="ln248">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln249">          tail = &quot;here&quot;;</a>
<a name="ln250">          break;</a>
<a name="ln251">        case 'u':</a>
<a name="ln252">          last_cmd = CMD_UP;</a>
<a name="ln253">          tail = &quot;p&quot;;</a>
<a name="ln254">          break;</a>
<a name="ln255">        case 'd':</a>
<a name="ln256">          last_cmd = CMD_DOWN;</a>
<a name="ln257">          tail = &quot;own&quot;;</a>
<a name="ln258">          break;</a>
<a name="ln259">        default: last_cmd = 0;</a>
<a name="ln260">        }</a>
<a name="ln261">        if (last_cmd != 0) {</a>
<a name="ln262">          // Check that the tail matches.</a>
<a name="ln263">          p++;</a>
<a name="ln264">          while (*p != NUL &amp;&amp; *p == *tail) {</a>
<a name="ln265">            p++;</a>
<a name="ln266">            tail++;</a>
<a name="ln267">          }</a>
<a name="ln268">          if (ASCII_ISALPHA(*p) &amp;&amp; last_cmd != CMD_FRAME) {</a>
<a name="ln269">            last_cmd = 0;</a>
<a name="ln270">          }</a>
<a name="ln271">        }</a>
<a name="ln272">      }</a>
<a name="ln273"> </a>
<a name="ln274">      if (last_cmd != 0) {</a>
<a name="ln275">        // Execute debug command: decided where to break next and return.</a>
<a name="ln276">        switch (last_cmd) {</a>
<a name="ln277">        case CMD_CONT:</a>
<a name="ln278">          debug_break_level = -1;</a>
<a name="ln279">          break;</a>
<a name="ln280">        case CMD_NEXT:</a>
<a name="ln281">          debug_break_level = ex_nesting_level;</a>
<a name="ln282">          break;</a>
<a name="ln283">        case CMD_STEP:</a>
<a name="ln284">          debug_break_level = 9999;</a>
<a name="ln285">          break;</a>
<a name="ln286">        case CMD_FINISH:</a>
<a name="ln287">          debug_break_level = ex_nesting_level - 1;</a>
<a name="ln288">          break;</a>
<a name="ln289">        case CMD_QUIT:</a>
<a name="ln290">          got_int = true;</a>
<a name="ln291">          debug_break_level = -1;</a>
<a name="ln292">          break;</a>
<a name="ln293">        case CMD_INTERRUPT:</a>
<a name="ln294">          got_int = true;</a>
<a name="ln295">          debug_break_level = 9999;</a>
<a name="ln296">          // Do not repeat &quot;&gt;interrupt&quot; cmd, continue stepping.</a>
<a name="ln297">          last_cmd = CMD_STEP;</a>
<a name="ln298">          break;</a>
<a name="ln299">        case CMD_BACKTRACE:</a>
<a name="ln300">          do_showbacktrace(cmd);</a>
<a name="ln301">          continue;</a>
<a name="ln302">        case CMD_FRAME:</a>
<a name="ln303">          if (*p == NUL) {</a>
<a name="ln304">            do_showbacktrace(cmd);</a>
<a name="ln305">          } else {</a>
<a name="ln306">            p = skipwhite(p);</a>
<a name="ln307">            do_setdebugtracelevel(p);</a>
<a name="ln308">          }</a>
<a name="ln309">          continue;</a>
<a name="ln310">        case CMD_UP:</a>
<a name="ln311">          debug_backtrace_level++;</a>
<a name="ln312">          do_checkbacktracelevel();</a>
<a name="ln313">          continue;</a>
<a name="ln314">        case CMD_DOWN:</a>
<a name="ln315">          debug_backtrace_level--;</a>
<a name="ln316">          do_checkbacktracelevel();</a>
<a name="ln317">          continue;</a>
<a name="ln318">        }</a>
<a name="ln319">        // Going out reset backtrace_level</a>
<a name="ln320">        debug_backtrace_level = 0;</a>
<a name="ln321">        break;</a>
<a name="ln322">      }</a>
<a name="ln323"> </a>
<a name="ln324">      // don't debug this command</a>
<a name="ln325">      n = debug_break_level;</a>
<a name="ln326">      debug_break_level = -1;</a>
<a name="ln327">      (void)do_cmdline(cmdline, getexline, NULL,</a>
<a name="ln328">                       DOCMD_VERBOSE|DOCMD_EXCRESET);</a>
<a name="ln329">      debug_break_level = n;</a>
<a name="ln330">    }</a>
<a name="ln331">    lines_left = (int)(Rows - 1);</a>
<a name="ln332">  }</a>
<a name="ln333">  xfree(cmdline);</a>
<a name="ln334"> </a>
<a name="ln335">  RedrawingDisabled--;</a>
<a name="ln336">  no_wait_return--;</a>
<a name="ln337">  redraw_all_later(NOT_VALID);</a>
<a name="ln338">  need_wait_return = false;</a>
<a name="ln339">  msg_scroll = save_msg_scroll;</a>
<a name="ln340">  lines_left = (int)(Rows - 1);</a>
<a name="ln341">  State = save_State;</a>
<a name="ln342">  debug_mode = false;</a>
<a name="ln343">  did_emsg = save_did_emsg;</a>
<a name="ln344">  cmd_silent = save_cmd_silent;</a>
<a name="ln345">  msg_silent = save_msg_silent;</a>
<a name="ln346">  emsg_silent = save_emsg_silent;</a>
<a name="ln347">  redir_off = save_redir_off;</a>
<a name="ln348"> </a>
<a name="ln349">  // Only print the message again when typing a command before coming back here.</a>
<a name="ln350">  debug_did_msg = true;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static int get_maxbacktrace_level(void)</a>
<a name="ln354">{</a>
<a name="ln355">  int maxbacktrace = 0;</a>
<a name="ln356"> </a>
<a name="ln357">  if (sourcing_name != NULL) {</a>
<a name="ln358">    char *p = (char *)sourcing_name;</a>
<a name="ln359">    char *q;</a>
<a name="ln360">    while ((q = strstr(p, &quot;..&quot;)) != NULL) {</a>
<a name="ln361">      p = q + 2;</a>
<a name="ln362">      maxbacktrace++;</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365">  return maxbacktrace;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static void do_setdebugtracelevel(char_u *arg)</a>
<a name="ln369">{</a>
<a name="ln370">  int level = atoi((char *)arg);</a>
<a name="ln371">  if (*arg == '+' || level &lt; 0) {</a>
<a name="ln372">    debug_backtrace_level += level;</a>
<a name="ln373">  } else {</a>
<a name="ln374">    debug_backtrace_level = level;</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  do_checkbacktracelevel();</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">static void do_checkbacktracelevel(void)</a>
<a name="ln381">{</a>
<a name="ln382">  if (debug_backtrace_level &lt; 0) {</a>
<a name="ln383">    debug_backtrace_level = 0;</a>
<a name="ln384">    MSG(_(&quot;frame is zero&quot;));</a>
<a name="ln385">  } else {</a>
<a name="ln386">    int max = get_maxbacktrace_level();</a>
<a name="ln387">    if (debug_backtrace_level &gt; max) {</a>
<a name="ln388">      debug_backtrace_level = max;</a>
<a name="ln389">      smsg(_(&quot;frame at highest level: %d&quot;), max);</a>
<a name="ln390">    }</a>
<a name="ln391">  }</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">static void do_showbacktrace(char_u *cmd)</a>
<a name="ln395">{</a>
<a name="ln396">  if (sourcing_name != NULL) {</a>
<a name="ln397">    int i = 0;</a>
<a name="ln398">    int max = get_maxbacktrace_level();</a>
<a name="ln399">    char *cur = (char *)sourcing_name;</a>
<a name="ln400">    while (!got_int) {</a>
<a name="ln401">      char *next = strstr(cur, &quot;..&quot;);</a>
<a name="ln402">      if (next != NULL) {</a>
<a name="ln403">        *next = NUL;</a>
<a name="ln404">      }</a>
<a name="ln405">      if (i == max - debug_backtrace_level) {</a>
<a name="ln406">        smsg(&quot;-&gt;%d %s&quot;, max - i, cur);</a>
<a name="ln407">      } else {</a>
<a name="ln408">        smsg(&quot;  %d %s&quot;, max - i, cur);</a>
<a name="ln409">      }</a>
<a name="ln410">      i++;</a>
<a name="ln411">      if (next == NULL) {</a>
<a name="ln412">        break;</a>
<a name="ln413">      }</a>
<a name="ln414">      *next = '.';</a>
<a name="ln415">      cur = next + 2;</a>
<a name="ln416">    }</a>
<a name="ln417">  }</a>
<a name="ln418">  if (sourcing_lnum != 0) {</a>
<a name="ln419">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln420">  } else {</a>
<a name="ln421">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln422">  }</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">/// &quot;:debug&quot;.</a>
<a name="ln427">void ex_debug(exarg_T *eap)</a>
<a name="ln428">{</a>
<a name="ln429">  int debug_break_level_save = debug_break_level;</a>
<a name="ln430"> </a>
<a name="ln431">  debug_break_level = 9999;</a>
<a name="ln432">  do_cmdline_cmd((char *)eap-&gt;arg);</a>
<a name="ln433">  debug_break_level = debug_break_level_save;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">static char_u   *debug_breakpoint_name = NULL;</a>
<a name="ln437">static linenr_T debug_breakpoint_lnum;</a>
<a name="ln438"> </a>
<a name="ln439">/// When debugging or a breakpoint is set on a skipped command, no debug prompt</a>
<a name="ln440">/// is shown by do_one_cmd().  This situation is indicated by debug_skipped, and</a>
<a name="ln441">/// debug_skipped_name is then set to the source name in the breakpoint case. If</a>
<a name="ln442">/// a skipped command decides itself that a debug prompt should be displayed, it</a>
<a name="ln443">/// can do so by calling dbg_check_skipped().</a>
<a name="ln444">static int debug_skipped;</a>
<a name="ln445">static char_u   *debug_skipped_name;</a>
<a name="ln446"> </a>
<a name="ln447">/// Go to debug mode when a breakpoint was encountered or &quot;ex_nesting_level&quot; is</a>
<a name="ln448">/// at or below the break level.  But only when the line is actually</a>
<a name="ln449">/// executed.  Return true and set breakpoint_name for skipped commands that</a>
<a name="ln450">/// decide to execute something themselves.</a>
<a name="ln451">/// Called from do_one_cmd() before executing a command.</a>
<a name="ln452">void dbg_check_breakpoint(exarg_T *eap)</a>
<a name="ln453">{</a>
<a name="ln454">  char_u      *p;</a>
<a name="ln455"> </a>
<a name="ln456">  debug_skipped = false;</a>
<a name="ln457">  if (debug_breakpoint_name != NULL) {</a>
<a name="ln458">    if (!eap-&gt;skip) {</a>
<a name="ln459">      // replace K_SNR with &quot;&lt;SNR&gt;&quot;</a>
<a name="ln460">      if (debug_breakpoint_name[0] == K_SPECIAL</a>
<a name="ln461">          &amp;&amp; debug_breakpoint_name[1] == KS_EXTRA</a>
<a name="ln462">          &amp;&amp; debug_breakpoint_name[2] == (int)KE_SNR) {</a>
<a name="ln463">        p = (char_u *)&quot;&lt;SNR&gt;&quot;;</a>
<a name="ln464">      } else {</a>
<a name="ln465">        p = (char_u *)&quot;&quot;;</a>
<a name="ln466">      }</a>
<a name="ln467">      smsg(_(&quot;Breakpoint in \&quot;%s%s\&quot; line %&quot; PRId64),</a>
<a name="ln468">           p,</a>
<a name="ln469">           debug_breakpoint_name + (*p == NUL ? 0 : 3),</a>
<a name="ln470">           (int64_t)debug_breakpoint_lnum);</a>
<a name="ln471">      debug_breakpoint_name = NULL;</a>
<a name="ln472">      do_debug(eap-&gt;cmd);</a>
<a name="ln473">    } else {</a>
<a name="ln474">      debug_skipped = true;</a>
<a name="ln475">      debug_skipped_name = debug_breakpoint_name;</a>
<a name="ln476">      debug_breakpoint_name = NULL;</a>
<a name="ln477">    }</a>
<a name="ln478">  } else if (ex_nesting_level &lt;= debug_break_level) {</a>
<a name="ln479">    if (!eap-&gt;skip) {</a>
<a name="ln480">      do_debug(eap-&gt;cmd);</a>
<a name="ln481">    } else {</a>
<a name="ln482">      debug_skipped = true;</a>
<a name="ln483">      debug_skipped_name = NULL;</a>
<a name="ln484">    }</a>
<a name="ln485">  }</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">/// Go to debug mode if skipped by dbg_check_breakpoint() because eap-&gt;skip was</a>
<a name="ln489">/// set.</a>
<a name="ln490">///</a>
<a name="ln491">/// @return true when the debug mode is entered this time.</a>
<a name="ln492">bool dbg_check_skipped(exarg_T *eap)</a>
<a name="ln493">{</a>
<a name="ln494">  int prev_got_int;</a>
<a name="ln495"> </a>
<a name="ln496">  if (debug_skipped) {</a>
<a name="ln497">    // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln498">    // interruption cause flushing the input buffer.</a>
<a name="ln499">    prev_got_int = got_int;</a>
<a name="ln500">    got_int = false;</a>
<a name="ln501">    debug_breakpoint_name = debug_skipped_name;</a>
<a name="ln502">    // eap-&gt;skip is true</a>
<a name="ln503">    eap-&gt;skip = false;</a>
<a name="ln504">    dbg_check_breakpoint(eap);</a>
<a name="ln505">    eap-&gt;skip = true;</a>
<a name="ln506">    got_int |= prev_got_int;</a>
<a name="ln507">    return true;</a>
<a name="ln508">  }</a>
<a name="ln509">  return false;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/// The list of breakpoints: dbg_breakp.</a>
<a name="ln513">/// This is a grow-array of structs.</a>
<a name="ln514">struct debuggy {</a>
<a name="ln515">  int dbg_nr;                   ///&lt; breakpoint number</a>
<a name="ln516">  int dbg_type;                 ///&lt; DBG_FUNC or DBG_FILE</a>
<a name="ln517">  char_u *dbg_name;             ///&lt; function or file name</a>
<a name="ln518">  regprog_T *dbg_prog;          ///&lt; regexp program</a>
<a name="ln519">  linenr_T dbg_lnum;            ///&lt; line number in function or file</a>
<a name="ln520">  int dbg_forceit;              ///&lt; ! used</a>
<a name="ln521">};</a>
<a name="ln522"> </a>
<a name="ln523">static garray_T dbg_breakp = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln524">#define BREAKP(idx)             (((struct debuggy *)dbg_breakp.ga_data)[idx])</a>
<a name="ln525">#define DEBUGGY(gap, idx)       (((struct debuggy *)gap-&gt;ga_data)[idx])</a>
<a name="ln526">static int last_breakp = 0;     // nr of last defined breakpoint</a>
<a name="ln527"> </a>
<a name="ln528">// Profiling uses file and func names similar to breakpoints.</a>
<a name="ln529">static garray_T prof_ga = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln530">#define DBG_FUNC        1</a>
<a name="ln531">#define DBG_FILE        2</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">/// Parse the arguments of &quot;:profile&quot;, &quot;:breakadd&quot; or &quot;:breakdel&quot; and put them</a>
<a name="ln535">/// in the entry just after the last one in dbg_breakp.  Note that &quot;dbg_name&quot;</a>
<a name="ln536">/// is allocated.</a>
<a name="ln537">/// Returns FAIL for failure.</a>
<a name="ln538">///</a>
<a name="ln539">/// @param arg</a>
<a name="ln540">/// @param gap  either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln541">static int dbg_parsearg(char_u *arg, garray_T *gap)</a>
<a name="ln542">{</a>
<a name="ln543">  char_u      *p = arg;</a>
<a name="ln544">  char_u      *q;</a>
<a name="ln545">  struct debuggy *bp;</a>
<a name="ln546">  bool here = false;</a>
<a name="ln547"> </a>
<a name="ln548">  ga_grow(gap, 1);</a>
<a name="ln549"> </a>
<a name="ln550">  bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln551"> </a>
<a name="ln552">  // Find &quot;func&quot; or &quot;file&quot;.</a>
<a name="ln553">  if (STRNCMP(p, &quot;func&quot;, 4) == 0) {</a>
<a name="ln554">    bp-&gt;dbg_type = DBG_FUNC;</a>
<a name="ln555">  } else if (STRNCMP(p, &quot;file&quot;, 4) == 0) {</a>
<a name="ln556">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln557">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;here&quot;, 4) == 0) {</a>
<a name="ln558">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln559">      EMSG(_(e_noname));</a>
<a name="ln560">      return FAIL;</a>
<a name="ln561">    }</a>
<a name="ln562">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln563">    here = true;</a>
<a name="ln564">  } else {</a>
<a name="ln565">    EMSG2(_(e_invarg2), p);</a>
<a name="ln566">    return FAIL;</a>
<a name="ln567">  }</a>
<a name="ln568">  p = skipwhite(p + 4);</a>
<a name="ln569"> </a>
<a name="ln570">  // Find optional line number.</a>
<a name="ln571">  if (here) {</a>
<a name="ln572">    bp-&gt;dbg_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln573">  } else if (gap != &amp;prof_ga &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln574">    bp-&gt;dbg_lnum = getdigits_long(&amp;p, true, 0);</a>
<a name="ln575">    p = skipwhite(p);</a>
<a name="ln576">  } else {</a>
<a name="ln577">    bp-&gt;dbg_lnum = 0;</a>
<a name="ln578">  }</a>
<a name="ln579"> </a>
<a name="ln580">  // Find the function or file name.  Don't accept a function name with ().</a>
<a name="ln581">  if ((!here &amp;&amp; *p == NUL)</a>
<a name="ln582">      || (here &amp;&amp; *p != NUL)</a>
<a name="ln583">      || (bp-&gt;dbg_type == DBG_FUNC &amp;&amp; strstr((char *)p, &quot;()&quot;) != NULL)) {</a>
<a name="ln584">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln585">    return FAIL;</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  if (bp-&gt;dbg_type == DBG_FUNC) {</a>
<a name="ln589">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln590">  } else if (here) {</a>
<a name="ln591">    bp-&gt;dbg_name = vim_strsave(curbuf-&gt;b_ffname);</a>
<a name="ln592">  } else {</a>
<a name="ln593">    // Expand the file name in the same way as do_source().  This means</a>
<a name="ln594">    // doing it twice, so that $DIR/file gets expanded when $DIR is</a>
<a name="ln595">    // &quot;~/dir&quot;.</a>
<a name="ln596">    q = expand_env_save(p);</a>
<a name="ln597">    if (q == NULL) {</a>
<a name="ln598">      return FAIL;</a>
<a name="ln599">    }</a>
<a name="ln600">    p = expand_env_save(q);</a>
<a name="ln601">    xfree(q);</a>
<a name="ln602">    if (p == NULL) {</a>
<a name="ln603">      return FAIL;</a>
<a name="ln604">    }</a>
<a name="ln605">    if (*p != '*') {</a>
<a name="ln606">      bp-&gt;dbg_name = (char_u *)fix_fname((char *)p);</a>
<a name="ln607">      xfree(p);</a>
<a name="ln608">    } else {</a>
<a name="ln609">      bp-&gt;dbg_name = p;</a>
<a name="ln610">    }</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  if (bp-&gt;dbg_name == NULL) {</a>
<a name="ln614">    return FAIL;</a>
<a name="ln615">  }</a>
<a name="ln616">  return OK;</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">/// &quot;:breakadd&quot;.  Also used for &quot;:profile&quot;.</a>
<a name="ln620">void ex_breakadd(exarg_T *eap)</a>
<a name="ln621">{</a>
<a name="ln622">  struct debuggy *bp;</a>
<a name="ln623">  char_u      *pat;</a>
<a name="ln624">  garray_T    *gap;</a>
<a name="ln625"> </a>
<a name="ln626">  gap = &amp;dbg_breakp;</a>
<a name="ln627">  if (eap-&gt;cmdidx == CMD_profile) {</a>
<a name="ln628">    gap = &amp;prof_ga;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  if (dbg_parsearg(eap-&gt;arg, gap) == OK) {</a>
<a name="ln632">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln633">    bp-&gt;dbg_forceit = eap-&gt;forceit;</a>
<a name="ln634"> </a>
<a name="ln635">    pat = file_pat_to_reg_pat(bp-&gt;dbg_name, NULL, NULL, false);</a>
<a name="ln636">    if (pat != NULL) {</a>
<a name="ln637">      bp-&gt;dbg_prog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln638">      xfree(pat);</a>
<a name="ln639">    }</a>
<a name="ln640">    if (pat == NULL || bp-&gt;dbg_prog == NULL) {</a>
<a name="ln641">      xfree(bp-&gt;dbg_name);</a>
<a name="ln642">    } else {</a>
<a name="ln643">      if (bp-&gt;dbg_lnum == 0) {           // default line number is 1</a>
<a name="ln644">        bp-&gt;dbg_lnum = 1;</a>
<a name="ln645">      }</a>
<a name="ln646">      if (eap-&gt;cmdidx != CMD_profile) {</a>
<a name="ln647">        DEBUGGY(gap, gap-&gt;ga_len).dbg_nr = ++last_breakp;</a>
<a name="ln648">        debug_tick++;</a>
<a name="ln649">      }</a>
<a name="ln650">      gap-&gt;ga_len++;</a>
<a name="ln651">    }</a>
<a name="ln652">  }</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">/// &quot;:debuggreedy&quot;.</a>
<a name="ln656">void ex_debuggreedy(exarg_T *eap)</a>
<a name="ln657">{</a>
<a name="ln658">  if (eap-&gt;addr_count == 0 || eap-&gt;line2 != 0) {</a>
<a name="ln659">    debug_greedy = true;</a>
<a name="ln660">  } else {</a>
<a name="ln661">    debug_greedy = false;</a>
<a name="ln662">  }</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/// &quot;:breakdel&quot; and &quot;:profdel&quot;.</a>
<a name="ln666">void ex_breakdel(exarg_T *eap)</a>
<a name="ln667">{</a>
<a name="ln668">  struct debuggy *bp, *bpi;</a>
<a name="ln669">  int nr;</a>
<a name="ln670">  int todel = -1;</a>
<a name="ln671">  bool del_all = false;</a>
<a name="ln672">  linenr_T best_lnum = 0;</a>
<a name="ln673">  garray_T    *gap;</a>
<a name="ln674"> </a>
<a name="ln675">  gap = &amp;dbg_breakp;</a>
<a name="ln676">  if (eap-&gt;cmdidx == CMD_profdel) {</a>
<a name="ln677">    gap = &amp;prof_ga;</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  if (ascii_isdigit(*eap-&gt;arg)) {</a>
<a name="ln681">    // &quot;:breakdel {nr}&quot;</a>
<a name="ln682">    nr = atoi((char *)eap-&gt;arg);</a>
<a name="ln683">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln684">      if (DEBUGGY(gap, i).dbg_nr == nr) {</a>
<a name="ln685">        todel = i;</a>
<a name="ln686">        break;</a>
<a name="ln687">      }</a>
<a name="ln688">    }</a>
<a name="ln689">  } else if (*eap-&gt;arg == '*') {</a>
<a name="ln690">    todel = 0;</a>
<a name="ln691">    del_all = true;</a>
<a name="ln692">  } else {</a>
<a name="ln693">    // &quot;:breakdel {func|file} [lnum] {name}&quot;</a>
<a name="ln694">    if (dbg_parsearg(eap-&gt;arg, gap) == FAIL) {</a>
<a name="ln695">      return;</a>
<a name="ln696">    }</a>
<a name="ln697">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln698">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln699">      bpi = &amp;DEBUGGY(gap, i);</a>
<a name="ln700">      if (bp-&gt;dbg_type == bpi-&gt;dbg_type</a>
<a name="ln701">          &amp;&amp; STRCMP(bp-&gt;dbg_name, bpi-&gt;dbg_name) == 0</a>
<a name="ln702">          &amp;&amp; (bp-&gt;dbg_lnum == bpi-&gt;dbg_lnum</a>
<a name="ln703">              || (bp-&gt;dbg_lnum == 0</a>
<a name="ln704">                  &amp;&amp; (best_lnum == 0</a>
<a name="ln705">                      || bpi-&gt;dbg_lnum &lt; best_lnum)))) {</a>
<a name="ln706">        todel = i;</a>
<a name="ln707">        best_lnum = bpi-&gt;dbg_lnum;</a>
<a name="ln708">      }</a>
<a name="ln709">    }</a>
<a name="ln710">    xfree(bp-&gt;dbg_name);</a>
<a name="ln711">  }</a>
<a name="ln712"> </a>
<a name="ln713">  if (todel &lt; 0) {</a>
<a name="ln714">    EMSG2(_(&quot;E161: Breakpoint not found: %s&quot;), eap-&gt;arg);</a>
<a name="ln715">  } else {</a>
<a name="ln716">    while (!GA_EMPTY(gap)) {</a>
<a name="ln717">      xfree(DEBUGGY(gap, todel).dbg_name);</a>
<a name="ln718">      vim_regfree(DEBUGGY(gap, todel).dbg_prog);</a>
<a name="ln719">      gap-&gt;ga_len--;</a>
<a name="ln720">      if (todel &lt; gap-&gt;ga_len) {</a>
<a name="ln721">        memmove(&amp;DEBUGGY(gap, todel), &amp;DEBUGGY(gap, todel + 1),</a>
<a name="ln722">                (size_t)(gap-&gt;ga_len - todel) * sizeof(struct debuggy));</a>
<a name="ln723">      }</a>
<a name="ln724">      if (eap-&gt;cmdidx == CMD_breakdel) {</a>
<a name="ln725">        debug_tick++;</a>
<a name="ln726">      }</a>
<a name="ln727">      if (!del_all) {</a>
<a name="ln728">        break;</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    // If all breakpoints were removed clear the array.</a>
<a name="ln733">    if (GA_EMPTY(gap)) {</a>
<a name="ln734">      ga_clear(gap);</a>
<a name="ln735">    }</a>
<a name="ln736">  }</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">/// &quot;:breaklist&quot;.</a>
<a name="ln740">void ex_breaklist(exarg_T *eap)</a>
<a name="ln741">{</a>
<a name="ln742">  struct debuggy *bp;</a>
<a name="ln743"> </a>
<a name="ln744">  if (GA_EMPTY(&amp;dbg_breakp)) {</a>
<a name="ln745">    MSG(_(&quot;No breakpoints defined&quot;));</a>
<a name="ln746">  } else {</a>
<a name="ln747">    for (int i = 0; i &lt; dbg_breakp.ga_len; i++) {</a>
<a name="ln748">      bp = &amp;BREAKP(i);</a>
<a name="ln749">      if (bp-&gt;dbg_type == DBG_FILE) {</a>
<a name="ln750">        home_replace(NULL, bp-&gt;dbg_name, NameBuff, MAXPATHL, true);</a>
<a name="ln751">      }</a>
<a name="ln752">      smsg(_(&quot;%3d  %s %s  line %&quot; PRId64),</a>
<a name="ln753">           bp-&gt;dbg_nr,</a>
<a name="ln754">           bp-&gt;dbg_type == DBG_FUNC ? &quot;func&quot; : &quot;file&quot;,</a>
<a name="ln755">           bp-&gt;dbg_type == DBG_FUNC ? bp-&gt;dbg_name : NameBuff,</a>
<a name="ln756">           (int64_t)bp-&gt;dbg_lnum);</a>
<a name="ln757">    }</a>
<a name="ln758">  }</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/// Find a breakpoint for a function or sourced file.</a>
<a name="ln762">/// Returns line number at which to break; zero when no matching breakpoint.</a>
<a name="ln763">linenr_T</a>
<a name="ln764">dbg_find_breakpoint(</a>
<a name="ln765">    bool file,             // true for a file, false for a function</a>
<a name="ln766">    char_u *fname,         // file or function name</a>
<a name="ln767">    linenr_T after         // after this line number</a>
<a name="ln768">)</a>
<a name="ln769">{</a>
<a name="ln770">  return debuggy_find(file, fname, after, &amp;dbg_breakp, NULL);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/// @param file     true for a file, false for a function</a>
<a name="ln774">/// @param fname    file or function name</a>
<a name="ln775">/// @param fp[out]  forceit</a>
<a name="ln776">///</a>
<a name="ln777">/// @returns true if profiling is on for a function or sourced file.</a>
<a name="ln778">bool has_profiling(bool file, char_u *fname, bool *fp)</a>
<a name="ln779">{</a>
<a name="ln780">  return debuggy_find(file, fname, (linenr_T)0, &amp;prof_ga, fp)</a>
<a name="ln781">         != (linenr_T)0;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">/// Common code for dbg_find_breakpoint() and has_profiling().</a>
<a name="ln785">static linenr_T</a>
<a name="ln786">debuggy_find(</a>
<a name="ln787">    bool file,            // true for a file, false for a function</a>
<a name="ln788">    char_u *fname,        // file or function name</a>
<a name="ln789">    linenr_T after,       // after this line number</a>
<a name="ln790">    garray_T *gap,        // either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln791">    bool *fp              // if not NULL: return forceit</a>
<a name="ln792">)</a>
<a name="ln793">{</a>
<a name="ln794">  struct debuggy *bp;</a>
<a name="ln795">  linenr_T lnum = 0;</a>
<a name="ln796">  char_u      *name = fname;</a>
<a name="ln797">  int prev_got_int;</a>
<a name="ln798"> </a>
<a name="ln799">  // Return quickly when there are no breakpoints.</a>
<a name="ln800">  if (GA_EMPTY(gap)) {</a>
<a name="ln801">    return (linenr_T)0;</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  // Replace K_SNR in function name with &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln805">  if (!file &amp;&amp; fname[0] == K_SPECIAL) {</a>
<a name="ln806">    name = xmalloc(STRLEN(fname) + 3);</a>
<a name="ln807">    STRCPY(name, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln808">    STRCPY(name + 5, fname + 3);</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln812">    // Skip entries that are not useful or are for a line that is beyond</a>
<a name="ln813">    // an already found breakpoint.</a>
<a name="ln814">    bp = &amp;DEBUGGY(gap, i);</a>
<a name="ln815">    if ((bp-&gt;dbg_type == DBG_FILE) == file</a>
<a name="ln816">        &amp;&amp; (gap == &amp;prof_ga</a>
<a name="ln817">            || (bp-&gt;dbg_lnum &gt; after &amp;&amp; (lnum == 0 || bp-&gt;dbg_lnum &lt; lnum)))) {</a>
<a name="ln818">      // Save the value of got_int and reset it.  We don't want a</a>
<a name="ln819">      // previous interruption cancel matching, only hitting CTRL-C</a>
<a name="ln820">      // while matching should abort it.</a>
<a name="ln821">      prev_got_int = got_int;</a>
<a name="ln822">      got_int = false;</a>
<a name="ln823">      if (vim_regexec_prog(&amp;bp-&gt;dbg_prog, false, name, (colnr_T)0)) {</a>
<a name="ln824">        lnum = bp-&gt;dbg_lnum;</a>
<a name="ln825">        if (fp != NULL) {</a>
<a name="ln826">          *fp = bp-&gt;dbg_forceit;</a>
<a name="ln827">        }</a>
<a name="ln828">      }</a>
<a name="ln829">      got_int |= prev_got_int;</a>
<a name="ln830">    }</a>
<a name="ln831">  }</a>
<a name="ln832">  if (name != fname) {</a>
<a name="ln833">    xfree(name);</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  return lnum;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">/// Called when a breakpoint was encountered.</a>
<a name="ln840">void dbg_breakpoint(char_u *name, linenr_T lnum)</a>
<a name="ln841">{</a>
<a name="ln842">  // We need to check if this line is actually executed in do_one_cmd()</a>
<a name="ln843">  debug_breakpoint_name = name;</a>
<a name="ln844">  debug_breakpoint_lnum = lnum;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">static char_u   *profile_fname = NULL;</a>
<a name="ln848"> </a>
<a name="ln849">/// &quot;:profile cmd args&quot;</a>
<a name="ln850">void ex_profile(exarg_T *eap)</a>
<a name="ln851">{</a>
<a name="ln852">  static proftime_T pause_time;</a>
<a name="ln853"> </a>
<a name="ln854">  char_u      *e;</a>
<a name="ln855">  int len;</a>
<a name="ln856"> </a>
<a name="ln857">  e = skiptowhite(eap-&gt;arg);</a>
<a name="ln858">  len = (int)(e - eap-&gt;arg);</a>
<a name="ln859">  e = skipwhite(e);</a>
<a name="ln860"> </a>
<a name="ln861">  if (len == 5 &amp;&amp; STRNCMP(eap-&gt;arg, &quot;start&quot;, 5) == 0 &amp;&amp; *e != NUL) {</a>
<a name="ln862">    xfree(profile_fname);</a>
<a name="ln863">    profile_fname = expand_env_save_opt(e, true);</a>
<a name="ln864">    do_profiling = PROF_YES;</a>
<a name="ln865">    profile_set_wait(profile_zero());</a>
<a name="ln866">    set_vim_var_nr(VV_PROFILING, 1L);</a>
<a name="ln867">  } else if (do_profiling == PROF_NONE) {</a>
<a name="ln868">    EMSG(_(&quot;E750: First use \&quot;:profile start {fname}\&quot;&quot;));</a>
<a name="ln869">  } else if (STRCMP(eap-&gt;arg, &quot;stop&quot;) == 0) {</a>
<a name="ln870">    profile_dump();</a>
<a name="ln871">    do_profiling = PROF_NONE;</a>
<a name="ln872">    set_vim_var_nr(VV_PROFILING, 0L);</a>
<a name="ln873">    profile_reset();</a>
<a name="ln874">  } else if (STRCMP(eap-&gt;arg, &quot;pause&quot;) == 0) {</a>
<a name="ln875">    if (do_profiling == PROF_YES) {</a>
<a name="ln876">      pause_time = profile_start();</a>
<a name="ln877">    }</a>
<a name="ln878">    do_profiling = PROF_PAUSED;</a>
<a name="ln879">  } else if (STRCMP(eap-&gt;arg, &quot;continue&quot;) == 0) {</a>
<a name="ln880">    if (do_profiling == PROF_PAUSED) {</a>
<a name="ln881">      pause_time = profile_end(pause_time);</a>
<a name="ln882">      profile_set_wait(profile_add(profile_get_wait(), pause_time));</a>
<a name="ln883">    }</a>
<a name="ln884">    do_profiling = PROF_YES;</a>
<a name="ln885">  } else if (STRCMP(eap-&gt;arg, &quot;dump&quot;) == 0) {</a>
<a name="ln886">    profile_dump();</a>
<a name="ln887">  } else {</a>
<a name="ln888">    // The rest is similar to &quot;:breakadd&quot;.</a>
<a name="ln889">    ex_breakadd(eap);</a>
<a name="ln890">  }</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">void ex_python(exarg_T *eap)</a>
<a name="ln894">{</a>
<a name="ln895">  script_host_execute(&quot;python&quot;, eap);</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">void ex_pyfile(exarg_T *eap)</a>
<a name="ln899">{</a>
<a name="ln900">  script_host_execute_file(&quot;python&quot;, eap);</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void ex_pydo(exarg_T *eap)</a>
<a name="ln904">{</a>
<a name="ln905">  script_host_do_range(&quot;python&quot;, eap);</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">void ex_ruby(exarg_T *eap)</a>
<a name="ln909">{</a>
<a name="ln910">  script_host_execute(&quot;ruby&quot;, eap);</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">void ex_rubyfile(exarg_T *eap)</a>
<a name="ln914">{</a>
<a name="ln915">  script_host_execute_file(&quot;ruby&quot;, eap);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">void ex_rubydo(exarg_T *eap)</a>
<a name="ln919">{</a>
<a name="ln920">  script_host_do_range(&quot;ruby&quot;, eap);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">void ex_python3(exarg_T *eap)</a>
<a name="ln924">{</a>
<a name="ln925">  script_host_execute(&quot;python3&quot;, eap);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">void ex_py3file(exarg_T *eap)</a>
<a name="ln929">{</a>
<a name="ln930">  script_host_execute_file(&quot;python3&quot;, eap);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">void ex_pydo3(exarg_T *eap)</a>
<a name="ln934">{</a>
<a name="ln935">  script_host_do_range(&quot;python3&quot;, eap);</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">void ex_perl(exarg_T *eap)</a>
<a name="ln939">{</a>
<a name="ln940">  script_host_execute(&quot;perl&quot;, eap);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">void ex_perlfile(exarg_T *eap)</a>
<a name="ln944">{</a>
<a name="ln945">  script_host_execute_file(&quot;perl&quot;, eap);</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">void ex_perldo(exarg_T *eap)</a>
<a name="ln949">{</a>
<a name="ln950">  script_host_do_range(&quot;perl&quot;, eap);</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">// Command line expansion for :profile.</a>
<a name="ln954">static enum {</a>
<a name="ln955">  PEXP_SUBCMD,          ///&lt; expand :profile sub-commands</a>
<a name="ln956">  PEXP_FUNC             ///&lt; expand :profile func {funcname}</a>
<a name="ln957">} pexpand_what;</a>
<a name="ln958"> </a>
<a name="ln959">static char *pexpand_cmds[] = {</a>
<a name="ln960">  &quot;continue&quot;,</a>
<a name="ln961">  &quot;dump&quot;,</a>
<a name="ln962">  &quot;file&quot;,</a>
<a name="ln963">  &quot;func&quot;,</a>
<a name="ln964">  &quot;pause&quot;,</a>
<a name="ln965">  &quot;start&quot;,</a>
<a name="ln966">  &quot;stop&quot;,</a>
<a name="ln967">  NULL</a>
<a name="ln968">};</a>
<a name="ln969"> </a>
<a name="ln970">/// Function given to ExpandGeneric() to obtain the profile command</a>
<a name="ln971">/// specific expansion.</a>
<a name="ln972">char_u *get_profile_name(expand_T *xp, int idx)</a>
<a name="ln973">{</a>
<a name="ln974">  switch (pexpand_what) {</a>
<a name="ln975">  case PEXP_SUBCMD:</a>
<a name="ln976">    return (char_u *)pexpand_cmds[idx];</a>
<a name="ln977">  // case PEXP_FUNC: TODO</a>
<a name="ln978">  default:</a>
<a name="ln979">    return NULL;</a>
<a name="ln980">  }</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">/// Handle command line completion for :profile command.</a>
<a name="ln984">void set_context_in_profile_cmd(expand_T *xp, const char *arg)</a>
<a name="ln985">{</a>
<a name="ln986">  // Default: expand subcommands.</a>
<a name="ln987">  xp-&gt;xp_context = EXPAND_PROFILE;</a>
<a name="ln988">  pexpand_what = PEXP_SUBCMD;</a>
<a name="ln989">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln990"> </a>
<a name="ln991">  char_u *const end_subcmd = skiptowhite((const char_u *)arg);</a>
<a name="ln992">  if (*end_subcmd == NUL) {</a>
<a name="ln993">    return;</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  if ((const char *)end_subcmd - arg == 5 &amp;&amp; strncmp(arg, &quot;start&quot;, 5) == 0) {</a>
<a name="ln997">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln998">    xp-&gt;xp_pattern = skipwhite((const char_u *)end_subcmd);</a>
<a name="ln999">    return;</a>
<a name="ln1000">  }</a>
<a name="ln1001"> </a>
<a name="ln1002">  // TODO(tarruda): expand function names after &quot;func&quot;</a>
<a name="ln1003">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">/// Dump the profiling info.</a>
<a name="ln1007">void profile_dump(void)</a>
<a name="ln1008">{</a>
<a name="ln1009">  FILE        *fd;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (profile_fname != NULL) {</a>
<a name="ln1012">    fd = os_fopen((char *)profile_fname, &quot;w&quot;);</a>
<a name="ln1013">    if (fd == NULL) {</a>
<a name="ln1014">      EMSG2(_(e_notopen), profile_fname);</a>
<a name="ln1015">    } else {</a>
<a name="ln1016">      script_dump_profile(fd);</a>
<a name="ln1017">      func_dump_profile(fd);</a>
<a name="ln1018">      fclose(fd);</a>
<a name="ln1019">    }</a>
<a name="ln1020">  }</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">/// Reset all profiling information.</a>
<a name="ln1024">static void profile_reset(void)</a>
<a name="ln1025">{</a>
<a name="ln1026">  // Reset sourced files.</a>
<a name="ln1027">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1028">    scriptitem_T *si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1029">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1030">      si-&gt;sn_prof_on      = false;</a>
<a name="ln1031">      si-&gt;sn_pr_force     = false;</a>
<a name="ln1032">      si-&gt;sn_pr_child     = profile_zero();</a>
<a name="ln1033">      si-&gt;sn_pr_nest      = 0;</a>
<a name="ln1034">      si-&gt;sn_pr_count     = 0;</a>
<a name="ln1035">      si-&gt;sn_pr_total     = profile_zero();</a>
<a name="ln1036">      si-&gt;sn_pr_self      = profile_zero();</a>
<a name="ln1037">      si-&gt;sn_pr_start     = profile_zero();</a>
<a name="ln1038">      si-&gt;sn_pr_children  = profile_zero();</a>
<a name="ln1039">      ga_clear(&amp;si-&gt;sn_prl_ga);</a>
<a name="ln1040">      si-&gt;sn_prl_start    = profile_zero();</a>
<a name="ln1041">      si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln1042">      si-&gt;sn_prl_wait     = profile_zero();</a>
<a name="ln1043">      si-&gt;sn_prl_idx      = -1;</a>
<a name="ln1044">      si-&gt;sn_prl_execed   = 0;</a>
<a name="ln1045">    }</a>
<a name="ln1046">  }</a>
<a name="ln1047"> </a>
<a name="ln1048">  // Reset functions.</a>
<a name="ln1049">  size_t      n  = func_hashtab.ht_used;</a>
<a name="ln1050">  hashitem_T *hi = func_hashtab.ht_array;</a>
<a name="ln1051"> </a>
<a name="ln1052">  for (; n &gt; (size_t)0; hi++) {</a>
<a name="ln1053">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1054">      n--;</a>
<a name="ln1055">      ufunc_T *uf = HI2UF(hi);</a>
<a name="ln1056">      if (uf-&gt;uf_prof_initialized) {</a>
<a name="ln1057">        uf-&gt;uf_profiling    = 0;</a>
<a name="ln1058">        uf-&gt;uf_tm_count     = 0;</a>
<a name="ln1059">        uf-&gt;uf_tm_total     = profile_zero();</a>
<a name="ln1060">        uf-&gt;uf_tm_self      = profile_zero();</a>
<a name="ln1061">        uf-&gt;uf_tm_children  = profile_zero();</a>
<a name="ln1062"> </a>
<a name="ln1063">        for (int i = 0; i &lt; uf-&gt;uf_lines.ga_len; i++) {</a>
<a name="ln1064">          uf-&gt;uf_tml_count[i] = 0;</a>
<a name="ln1065">          uf-&gt;uf_tml_total[i] = uf-&gt;uf_tml_self[i] = 0;</a>
<a name="ln1066">        }</a>
<a name="ln1067"> </a>
<a name="ln1068">        uf-&gt;uf_tml_start    = profile_zero();</a>
<a name="ln1069">        uf-&gt;uf_tml_children = profile_zero();</a>
<a name="ln1070">        uf-&gt;uf_tml_wait     = profile_zero();</a>
<a name="ln1071">        uf-&gt;uf_tml_idx      = -1;</a>
<a name="ln1072">        uf-&gt;uf_tml_execed   = 0;</a>
<a name="ln1073">      }</a>
<a name="ln1074">    }</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  XFREE_CLEAR(profile_fname);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">/// Start profiling a script.</a>
<a name="ln1081">static void profile_init(scriptitem_T *si)</a>
<a name="ln1082">{</a>
<a name="ln1083">  si-&gt;sn_pr_count = 0;</a>
<a name="ln1084">  si-&gt;sn_pr_total = profile_zero();</a>
<a name="ln1085">  si-&gt;sn_pr_self = profile_zero();</a>
<a name="ln1086"> </a>
<a name="ln1087">  ga_init(&amp;si-&gt;sn_prl_ga, sizeof(sn_prl_T), 100);</a>
<a name="ln1088">  si-&gt;sn_prl_idx = -1;</a>
<a name="ln1089">  si-&gt;sn_prof_on = true;</a>
<a name="ln1090">  si-&gt;sn_pr_nest = 0;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">/// Save time when starting to invoke another script or function.</a>
<a name="ln1094">void script_prof_save(</a>
<a name="ln1095">    proftime_T  *tm             // place to store wait time</a>
<a name="ln1096">)</a>
<a name="ln1097">{</a>
<a name="ln1098">  scriptitem_T    *si;</a>
<a name="ln1099"> </a>
<a name="ln1100">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1101">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1102">    if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_pr_nest++ == 0) {</a>
<a name="ln1103">      si-&gt;sn_pr_child = profile_start();</a>
<a name="ln1104">    }</a>
<a name="ln1105">  }</a>
<a name="ln1106">  *tm = profile_get_wait();</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">/// Count time spent in children after invoking another script or function.</a>
<a name="ln1110">void script_prof_restore(proftime_T *tm)</a>
<a name="ln1111">{</a>
<a name="ln1112">  scriptitem_T    *si;</a>
<a name="ln1113"> </a>
<a name="ln1114">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1115">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1116">    if (si-&gt;sn_prof_on &amp;&amp; --si-&gt;sn_pr_nest == 0) {</a>
<a name="ln1117">      si-&gt;sn_pr_child = profile_end(si-&gt;sn_pr_child);</a>
<a name="ln1118">      // don't count wait time</a>
<a name="ln1119">      si-&gt;sn_pr_child = profile_sub_wait(*tm, si-&gt;sn_pr_child);</a>
<a name="ln1120">      si-&gt;sn_pr_children = profile_add(si-&gt;sn_pr_children, si-&gt;sn_pr_child);</a>
<a name="ln1121">      si-&gt;sn_prl_children = profile_add(si-&gt;sn_prl_children, si-&gt;sn_pr_child);</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static proftime_T inchar_time;</a>
<a name="ln1127"> </a>
<a name="ln1128">/// Called when starting to wait for the user to type a character.</a>
<a name="ln1129">void prof_inchar_enter(void)</a>
<a name="ln1130">{</a>
<a name="ln1131">  inchar_time = profile_start();</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">/// Called when finished waiting for the user to type a character.</a>
<a name="ln1135">void prof_inchar_exit(void)</a>
<a name="ln1136">{</a>
<a name="ln1137">  inchar_time = profile_end(inchar_time);</a>
<a name="ln1138">  profile_set_wait(profile_add(profile_get_wait(), inchar_time));</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">/// Dump the profiling results for all scripts in file &quot;fd&quot;.</a>
<a name="ln1142">static void script_dump_profile(FILE *fd)</a>
<a name="ln1143">{</a>
<a name="ln1144">  scriptitem_T    *si;</a>
<a name="ln1145">  FILE            *sfd;</a>
<a name="ln1146">  sn_prl_T        *pp;</a>
<a name="ln1147"> </a>
<a name="ln1148">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1149">    si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1150">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1151">      fprintf(fd, &quot;SCRIPT  %s\n&quot;, si-&gt;sn_name);</a>
<a name="ln1152">      if (si-&gt;sn_pr_count == 1) {</a>
<a name="ln1153">        fprintf(fd, &quot;Sourced 1 time\n&quot;);</a>
<a name="ln1154">      } else {</a>
<a name="ln1155">        fprintf(fd, &quot;Sourced %d times\n&quot;, si-&gt;sn_pr_count);</a>
<a name="ln1156">      }</a>
<a name="ln1157">      fprintf(fd, &quot;Total time: %s\n&quot;, profile_msg(si-&gt;sn_pr_total));</a>
<a name="ln1158">      fprintf(fd, &quot; Self time: %s\n&quot;, profile_msg(si-&gt;sn_pr_self));</a>
<a name="ln1159">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1160">      fprintf(fd, &quot;count  total (s)   self (s)\n&quot;);</a>
<a name="ln1161"> </a>
<a name="ln1162">      sfd = os_fopen((char *)si-&gt;sn_name, &quot;r&quot;);</a>
<a name="ln1163">      if (sfd == NULL) {</a>
<a name="ln1164">        fprintf(fd, &quot;Cannot open file!\n&quot;);</a>
<a name="ln1165">      } else {</a>
<a name="ln1166">        // Keep going till the end of file, so that trailing</a>
<a name="ln1167">        // continuation lines are listed.</a>
<a name="ln1168">        for (int i = 0; ; i++) {</a>
<a name="ln1169">          if (vim_fgets(IObuff, IOSIZE, sfd)) {</a>
<a name="ln1170">            break;</a>
<a name="ln1171">          }</a>
<a name="ln1172">          // When a line has been truncated, append NL, taking care</a>
<a name="ln1173">          // of multi-byte characters .</a>
<a name="ln1174">          if (IObuff[IOSIZE - 2] != NUL &amp;&amp; IObuff[IOSIZE - 2] != NL) {</a>
<a name="ln1175">            int n = IOSIZE - 2;</a>
<a name="ln1176"> </a>
<a name="ln1177">            // Move to the first byte of this char.</a>
<a name="ln1178">            // utf_head_off() doesn't work, because it checks</a>
<a name="ln1179">            // for a truncated character.</a>
<a name="ln1180">            while (n &gt; 0 &amp;&amp; (IObuff[n] &amp; 0xc0) == 0x80) {</a>
<a name="ln1181">              n--;</a>
<a name="ln1182">            }</a>
<a name="ln1183"> </a>
<a name="ln1184">            IObuff[n] = NL;</a>
<a name="ln1185">            IObuff[n + 1] = NUL;</a>
<a name="ln1186">          }</a>
<a name="ln1187">          if (i &lt; si-&gt;sn_prl_ga.ga_len</a>
<a name="ln1188">              &amp;&amp; (pp = &amp;PRL_ITEM(si, i))-&gt;snp_count &gt; 0) {</a>
<a name="ln1189">            fprintf(fd, &quot;%5d &quot;, pp-&gt;snp_count);</a>
<a name="ln1190">            if (profile_equal(pp-&gt;sn_prl_total, pp-&gt;sn_prl_self)) {</a>
<a name="ln1191">              fprintf(fd, &quot;           &quot;);</a>
<a name="ln1192">            } else {</a>
<a name="ln1193">              fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_total));</a>
<a name="ln1194">            }</a>
<a name="ln1195">            fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_self));</a>
<a name="ln1196">          } else {</a>
<a name="ln1197">            fprintf(fd, &quot;                            &quot;);</a>
<a name="ln1198">          }</a>
<a name="ln1199">          fprintf(fd, &quot;%s&quot;, IObuff);</a>
<a name="ln1200">        }</a>
<a name="ln1201">        fclose(sfd);</a>
<a name="ln1202">      }</a>
<a name="ln1203">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1204">    }</a>
<a name="ln1205">  }</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">/// Return true when a function defined in the current script should be</a>
<a name="ln1209">/// profiled.</a>
<a name="ln1210">bool prof_def_func(void)</a>
<a name="ln1211">{</a>
<a name="ln1212">  if (current_sctx.sc_sid &gt; 0) {</a>
<a name="ln1213">    return SCRIPT_ITEM(current_sctx.sc_sid).sn_pr_force;</a>
<a name="ln1214">  }</a>
<a name="ln1215">  return false;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/// If 'autowrite' option set, try to write the file.</a>
<a name="ln1219">/// Careful: autocommands may make &quot;buf&quot; invalid!</a>
<a name="ln1220">///</a>
<a name="ln1221">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1222">int autowrite(buf_T *buf, int forceit)</a>
<a name="ln1223">{</a>
<a name="ln1224">  int r;</a>
<a name="ln1225">  bufref_T bufref;</a>
<a name="ln1226"> </a>
<a name="ln1227">  if (!(p_aw || p_awa) || !p_write</a>
<a name="ln1228">      // never autowrite a &quot;nofile&quot; or &quot;nowrite&quot; buffer</a>
<a name="ln1229">      || bt_dontwrite(buf)</a>
<a name="ln1230">      || (!forceit &amp;&amp; buf-&gt;b_p_ro) || buf-&gt;b_ffname == NULL) {</a>
<a name="ln1231">    return FAIL;</a>
<a name="ln1232">  }</a>
<a name="ln1233">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1234">  r = buf_write_all(buf, forceit);</a>
<a name="ln1235"> </a>
<a name="ln1236">  // Writing may succeed but the buffer still changed, e.g., when there is a</a>
<a name="ln1237">  // conversion error.  We do want to return FAIL then.</a>
<a name="ln1238">  if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1239">    r = FAIL;</a>
<a name="ln1240">  }</a>
<a name="ln1241">  return r;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">/// Flush all buffers, except the ones that are readonly or are never written.</a>
<a name="ln1245">void autowrite_all(void)</a>
<a name="ln1246">{</a>
<a name="ln1247">  if (!(p_aw || p_awa) || !p_write) {</a>
<a name="ln1248">    return;</a>
<a name="ln1249">  }</a>
<a name="ln1250"> </a>
<a name="ln1251">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1252">    if (bufIsChanged(buf) &amp;&amp; !buf-&gt;b_p_ro &amp;&amp; !bt_dontwrite(buf)) {</a>
<a name="ln1253">      bufref_T bufref;</a>
<a name="ln1254">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1255">      (void)buf_write_all(buf, false);</a>
<a name="ln1256">      // an autocommand may have deleted the buffer</a>
<a name="ln1257">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1258">        buf = firstbuf;</a>
<a name="ln1259">      }</a>
<a name="ln1260">    }</a>
<a name="ln1261">  }</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/// Return true if buffer was changed and cannot be abandoned.</a>
<a name="ln1265">/// For flags use the CCGD_ values.</a>
<a name="ln1266">bool check_changed(buf_T *buf, int flags)</a>
<a name="ln1267">{</a>
<a name="ln1268">  int forceit = (flags &amp; CCGD_FORCEIT);</a>
<a name="ln1269">  bufref_T bufref;</a>
<a name="ln1270">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1271"> </a>
<a name="ln1272">  if (!forceit</a>
<a name="ln1273">      &amp;&amp; bufIsChanged(buf)</a>
<a name="ln1274">      &amp;&amp; ((flags &amp; CCGD_MULTWIN) || buf-&gt;b_nwindows &lt;= 1)</a>
<a name="ln1275">      &amp;&amp; (!(flags &amp; CCGD_AW) || autowrite(buf, forceit) == FAIL)) {</a>
<a name="ln1276">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln1277">      int count = 0;</a>
<a name="ln1278"> </a>
<a name="ln1279">      if (flags &amp; CCGD_ALLBUF) {</a>
<a name="ln1280">        FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1281">          if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL)) {</a>
<a name="ln1282">            count++;</a>
<a name="ln1283">          }</a>
<a name="ln1284">        }</a>
<a name="ln1285">      }</a>
<a name="ln1286">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1287">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1288">        return false;</a>
<a name="ln1289">      }</a>
<a name="ln1290">      dialog_changed(buf, count &gt; 1);</a>
<a name="ln1291">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1292">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1293">        return false;</a>
<a name="ln1294">      }</a>
<a name="ln1295">      return bufIsChanged(buf);</a>
<a name="ln1296">    }</a>
<a name="ln1297">    if (flags &amp; CCGD_EXCMD) {</a>
<a name="ln1298">      no_write_message();</a>
<a name="ln1299">    } else {</a>
<a name="ln1300">      no_write_message_nobang(curbuf);</a>
<a name="ln1301">    }</a>
<a name="ln1302">    return true;</a>
<a name="ln1303">  }</a>
<a name="ln1304">  return false;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">/// Ask the user what to do when abandoning a changed buffer.</a>
<a name="ln1310">/// Must check 'write' option first!</a>
<a name="ln1311">///</a>
<a name="ln1312">/// @param buf</a>
<a name="ln1313">/// @param checkall may abandon all changed buffers</a>
<a name="ln1314">void dialog_changed(buf_T *buf, bool checkall)</a>
<a name="ln1315">{</a>
<a name="ln1316">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1317">  int ret;</a>
<a name="ln1318">  // Init ea pseudo-structure, this is needed for the check_overwrite()</a>
<a name="ln1319">  // function.</a>
<a name="ln1320">  exarg_T ea = {</a>
<a name="ln1321">    .append = false,</a>
<a name="ln1322">    .forceit = false,</a>
<a name="ln1323">  };</a>
<a name="ln1324"> </a>
<a name="ln1325">  dialog_msg(buff, _(&quot;Save changes to \&quot;%s\&quot;?&quot;), buf-&gt;b_fname);</a>
<a name="ln1326">  if (checkall) {</a>
<a name="ln1327">    ret = vim_dialog_yesnoallcancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1328">  } else {</a>
<a name="ln1329">    ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1330">  }</a>
<a name="ln1331"> </a>
<a name="ln1332">  if (ret == VIM_YES) {</a>
<a name="ln1333">    if (buf-&gt;b_fname != NULL</a>
<a name="ln1334">        &amp;&amp; check_overwrite(&amp;ea,</a>
<a name="ln1335">                           buf,</a>
<a name="ln1336">                           buf-&gt;b_fname,</a>
<a name="ln1337">                           buf-&gt;b_ffname,</a>
<a name="ln1338">                           false) == OK) {</a>
<a name="ln1339">      // didn't hit Cancel</a>
<a name="ln1340">      (void)buf_write_all(buf, false);</a>
<a name="ln1341">    }</a>
<a name="ln1342">  } else if (ret == VIM_NO) {</a>
<a name="ln1343">    unchanged(buf, true, false);</a>
<a name="ln1344">  } else if (ret == VIM_ALL) {</a>
<a name="ln1345">    // Write all modified files that can be written.</a>
<a name="ln1346">    // Skip readonly buffers, these need to be confirmed</a>
<a name="ln1347">    // individually.</a>
<a name="ln1348">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1349">      if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL) &amp;&amp; !buf2-&gt;b_p_ro) {</a>
<a name="ln1350">        bufref_T bufref;</a>
<a name="ln1351">        set_bufref(&amp;bufref, buf2);</a>
<a name="ln1352"> </a>
<a name="ln1353">        if (buf2-&gt;b_fname != NULL</a>
<a name="ln1354">            &amp;&amp; check_overwrite(&amp;ea, buf2, buf2-&gt;b_fname,</a>
<a name="ln1355">                               buf2-&gt;b_ffname, false) == OK) {</a>
<a name="ln1356">          // didn't hit Cancel</a>
<a name="ln1357">          (void)buf_write_all(buf2, false);</a>
<a name="ln1358">        }</a>
<a name="ln1359">        // an autocommand may have deleted the buffer</a>
<a name="ln1360">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1361">          buf2 = firstbuf;</a>
<a name="ln1362">        }</a>
<a name="ln1363">      }</a>
<a name="ln1364">    }</a>
<a name="ln1365">  } else if (ret == VIM_DISCARDALL) {</a>
<a name="ln1366">    // mark all buffers as unchanged</a>
<a name="ln1367">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1368">      unchanged(buf2, true, false);</a>
<a name="ln1369">    }</a>
<a name="ln1370">  }</a>
<a name="ln1371">}</a>
<a name="ln1372"> </a>
<a name="ln1373">/// Ask the user whether to close the terminal buffer or not.</a>
<a name="ln1374">///</a>
<a name="ln1375">/// @param buf The terminal buffer.</a>
<a name="ln1376">/// @return bool Whether to close the buffer or not.</a>
<a name="ln1377">bool dialog_close_terminal(buf_T *buf)</a>
<a name="ln1378">{</a>
<a name="ln1379">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1380"> </a>
<a name="ln1381">  dialog_msg(buff, _(&quot;Close \&quot;%s\&quot;?&quot;),</a>
<a name="ln1382">             (buf-&gt;b_fname != NULL) ? buf-&gt;b_fname : (char_u *)&quot;?&quot;);</a>
<a name="ln1383"> </a>
<a name="ln1384">  int ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1385"> </a>
<a name="ln1386">  return (ret == VIM_YES) ? true : false;</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/// Return true if the buffer &quot;buf&quot; can be abandoned, either by making it</a>
<a name="ln1390">/// hidden, autowriting it or unloading it.</a>
<a name="ln1391">bool can_abandon(buf_T *buf, int forceit)</a>
<a name="ln1392">{</a>
<a name="ln1393">  return buf_hide(buf)</a>
<a name="ln1394">         || !bufIsChanged(buf)</a>
<a name="ln1395">         || buf-&gt;b_nwindows &gt; 1</a>
<a name="ln1396">         || autowrite(buf, forceit) == OK</a>
<a name="ln1397">         || forceit;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">/// Add a buffer number to &quot;bufnrs&quot;, unless it's already there.</a>
<a name="ln1402">static void add_bufnum(int *bufnrs, int *bufnump, int nr)</a>
<a name="ln1403">{</a>
<a name="ln1404">  int i;</a>
<a name="ln1405"> </a>
<a name="ln1406">  for (i = 0; i &lt; *bufnump; i++) {</a>
<a name="ln1407">    if (bufnrs[i] == nr) {</a>
<a name="ln1408">      return;</a>
<a name="ln1409">    }</a>
<a name="ln1410">  }</a>
<a name="ln1411">  bufnrs[*bufnump] = nr;</a>
<a name="ln1412">  *bufnump = *bufnump + 1;</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">/// Check if any buffer was changed and cannot be abandoned.</a>
<a name="ln1416">/// That changed buffer becomes the current buffer.</a>
<a name="ln1417">/// When &quot;unload&quot; is true the current buffer is unloaded instead of making it</a>
<a name="ln1418">/// hidden.  This is used for &quot;:q!&quot;.</a>
<a name="ln1419">///</a>
<a name="ln1420">/// @param[in] hidden specifies whether to check only hidden buffers.</a>
<a name="ln1421">/// @param[in] unload specifies whether to unload, instead of hide, the buffer.</a>
<a name="ln1422">///</a>
<a name="ln1423">/// @returns          true if any buffer is changed and cannot be abandoned</a>
<a name="ln1424">bool check_changed_any(bool hidden, bool unload)</a>
<a name="ln1425">{</a>
<a name="ln1426">  bool ret = false;</a>
<a name="ln1427">  int save;</a>
<a name="ln1428">  int i;</a>
<a name="ln1429">  int bufnum = 0;</a>
<a name="ln1430">  size_t bufcount = 0;</a>
<a name="ln1431">  int         *bufnrs;</a>
<a name="ln1432"> </a>
<a name="ln1433">  // Make a list of all buffers, with the most important ones first.</a>
<a name="ln1434">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1435">    bufcount++;</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  if (bufcount == 0) {</a>
<a name="ln1439">    return false;</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  bufnrs = xmalloc(sizeof(*bufnrs) * bufcount);</a>
<a name="ln1443"> </a>
<a name="ln1444">  // curbuf</a>
<a name="ln1445">  bufnrs[bufnum++] = curbuf-&gt;b_fnum;</a>
<a name="ln1446"> </a>
<a name="ln1447">  // buffers in current tab</a>
<a name="ln1448">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1449">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln1450">      add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1451">    }</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  // buffers in other tabs</a>
<a name="ln1455">  FOR_ALL_TABS(tp) {</a>
<a name="ln1456">    if (tp != curtab) {</a>
<a name="ln1457">      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln1458">        add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1459">      }</a>
<a name="ln1460">    }</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463">  // any other buffer</a>
<a name="ln1464">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1465">    add_bufnum(bufnrs, &amp;bufnum, buf-&gt;b_fnum);</a>
<a name="ln1466">  }</a>
<a name="ln1467"> </a>
<a name="ln1468">  buf_T *buf = NULL;</a>
<a name="ln1469">  for (i = 0; i &lt; bufnum; i++) {</a>
<a name="ln1470">    buf = buflist_findnr(bufnrs[i]);</a>
<a name="ln1471">    if (buf == NULL) {</a>
<a name="ln1472">      continue;</a>
<a name="ln1473">    }</a>
<a name="ln1474">    if ((!hidden || buf-&gt;b_nwindows == 0) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1475">      bufref_T bufref;</a>
<a name="ln1476">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1477"> </a>
<a name="ln1478">      // Try auto-writing the buffer.  If this fails but the buffer no</a>
<a name="ln1479">      // longer exists it's not changed, that's OK.</a>
<a name="ln1480">      if (check_changed(buf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln1481">                        | CCGD_MULTWIN</a>
<a name="ln1482">                        | CCGD_ALLBUF) &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln1483">        break;    // didn't save - still changes</a>
<a name="ln1484">      }</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  if (i &gt;= bufnum) {</a>
<a name="ln1489">    goto theend;</a>
<a name="ln1490">  }</a>
<a name="ln1491"> </a>
<a name="ln1492">  // Get here if &quot;buf&quot; cannot be abandoned.</a>
<a name="ln1493">  ret = true;</a>
<a name="ln1494">  exiting = false;</a>
<a name="ln1495">  // When &quot;:confirm&quot; used, don't give an error message.</a>
<a name="ln1496">  if (!(p_confirm || cmdmod.confirm)) {</a>
<a name="ln1497">    // There must be a wait_return for this message, do_buffer()</a>
<a name="ln1498">    // may cause a redraw.  But wait_return() is a no-op when vgetc()</a>
<a name="ln1499">    // is busy (Quit used from window menu), then make sure we don't</a>
<a name="ln1500">    // cause a scroll up.</a>
<a name="ln1501">    if (vgetc_busy &gt; 0) {</a>
<a name="ln1502">      msg_row = cmdline_row;</a>
<a name="ln1503">      msg_col = 0;</a>
<a name="ln1504">      msg_didout = false;</a>
<a name="ln1505">    }</a>
<a name="ln1506">    if ((buf-&gt;terminal &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel))</a>
<a name="ln1507">        ? EMSG2(_(&quot;E947: Job still running in buffer \&quot;%s\&quot;&quot;), buf-&gt;b_fname)</a>
<a name="ln1508">        : EMSG2(_(&quot;E162: No write since last change for buffer \&quot;%s\&quot;&quot;),</a>
<a name="ln1509">                buf_spname(buf) != NULL ? buf_spname(buf) : buf-&gt;b_fname)) {</a>
<a name="ln1510">      save = no_wait_return;</a>
<a name="ln1511">      no_wait_return = false;</a>
<a name="ln1512">      wait_return(false);</a>
<a name="ln1513">      no_wait_return = save;</a>
<a name="ln1514">    }</a>
<a name="ln1515">  }</a>
<a name="ln1516"> </a>
<a name="ln1517">  // Try to find a window that contains the buffer.</a>
<a name="ln1518">  if (buf != curbuf) {</a>
<a name="ln1519">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1520">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1521">        bufref_T bufref;</a>
<a name="ln1522">        set_bufref(&amp;bufref, buf);</a>
<a name="ln1523">        goto_tabpage_win(tp, wp);</a>
<a name="ln1524">        // Paranoia: did autocmds wipe out the buffer with changes?</a>
<a name="ln1525">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1526">          goto theend;</a>
<a name="ln1527">        }</a>
<a name="ln1528">        goto buf_found;</a>
<a name="ln1529">      }</a>
<a name="ln1530">    }</a>
<a name="ln1531">  }</a>
<a name="ln1532">buf_found:</a>
<a name="ln1533"> </a>
<a name="ln1534">  // Open the changed buffer in the current window.</a>
<a name="ln1535">  if (buf != curbuf) {</a>
<a name="ln1536">    set_curbuf(buf, unload ? DOBUF_UNLOAD : DOBUF_GOTO);</a>
<a name="ln1537">  }</a>
<a name="ln1538"> </a>
<a name="ln1539">theend:</a>
<a name="ln1540">  xfree(bufnrs);</a>
<a name="ln1541">  return ret;</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">/// Return FAIL if there is no file name, OK if there is one.</a>
<a name="ln1545">/// Give error message for FAIL.</a>
<a name="ln1546">int check_fname(void)</a>
<a name="ln1547">{</a>
<a name="ln1548">  if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1549">    EMSG(_(e_noname));</a>
<a name="ln1550">    return FAIL;</a>
<a name="ln1551">  }</a>
<a name="ln1552">  return OK;</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">/// Flush the contents of a buffer, unless it has no file name.</a>
<a name="ln1556">///</a>
<a name="ln1557">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1558">int buf_write_all(buf_T *buf, int forceit)</a>
<a name="ln1559">{</a>
<a name="ln1560">  int retval;</a>
<a name="ln1561">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1562"> </a>
<a name="ln1563">  retval = (buf_write(buf, buf-&gt;b_ffname, buf-&gt;b_fname,</a>
<a name="ln1564">                      (linenr_T)1, buf-&gt;b_ml.ml_line_count, NULL,</a>
<a name="ln1565">                      false, forceit, true, false));</a>
<a name="ln1566">  if (curbuf != old_curbuf) {</a>
<a name="ln1567">    msg_source(HL_ATTR(HLF_W));</a>
<a name="ln1568">    MSG(_(&quot;Warning: Entered other buffer unexpectedly (check autocommands)&quot;));</a>
<a name="ln1569">  }</a>
<a name="ln1570">  return retval;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573">/// Code to handle the argument list.</a>
<a name="ln1574"> </a>
<a name="ln1575">#define AL_SET  1</a>
<a name="ln1576">#define AL_ADD  2</a>
<a name="ln1577">#define AL_DEL  3</a>
<a name="ln1578"> </a>
<a name="ln1579">/// Isolate one argument, taking backticks.</a>
<a name="ln1580">/// Changes the argument in-place, puts a NUL after it.  Backticks remain.</a>
<a name="ln1581">/// Return a pointer to the start of the next argument.</a>
<a name="ln1582">static char_u *do_one_arg(char_u *str)</a>
<a name="ln1583">{</a>
<a name="ln1584">  char_u      *p;</a>
<a name="ln1585">  bool inbacktick;</a>
<a name="ln1586"> </a>
<a name="ln1587">  inbacktick = false;</a>
<a name="ln1588">  for (p = str; *str; str++) {</a>
<a name="ln1589">    // When the backslash is used for escaping the special meaning of a</a>
<a name="ln1590">    // character we need to keep it until wildcard expansion.</a>
<a name="ln1591">    if (rem_backslash(str)) {</a>
<a name="ln1592">      *p++ = *str++;</a>
<a name="ln1593">      *p++ = *str;</a>
<a name="ln1594">    } else {</a>
<a name="ln1595">      // An item ends at a space not in backticks</a>
<a name="ln1596">      if (!inbacktick &amp;&amp; ascii_isspace(*str)) {</a>
<a name="ln1597">        break;</a>
<a name="ln1598">      }</a>
<a name="ln1599">      if (*str == '`') {</a>
<a name="ln1600">        inbacktick ^= true;</a>
<a name="ln1601">      }</a>
<a name="ln1602">      *p++ = *str;</a>
<a name="ln1603">    }</a>
<a name="ln1604">  }</a>
<a name="ln1605">  str = skipwhite(str);</a>
<a name="ln1606">  *p = NUL;</a>
<a name="ln1607"> </a>
<a name="ln1608">  return str;</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">/// Separate the arguments in &quot;str&quot; and return a list of pointers in the</a>
<a name="ln1612">/// growarray &quot;gap&quot;.</a>
<a name="ln1613">static void get_arglist(garray_T *gap, char_u *str, int escaped)</a>
<a name="ln1614">{</a>
<a name="ln1615">  ga_init(gap, (int)sizeof(char_u *), 20);</a>
<a name="ln1616">  while (*str != NUL) {</a>
<a name="ln1617">    GA_APPEND(char_u *, gap, str);</a>
<a name="ln1618"> </a>
<a name="ln1619">    // If str is escaped, don't handle backslashes or spaces</a>
<a name="ln1620">    if (!escaped) {</a>
<a name="ln1621">      return;</a>
<a name="ln1622">    }</a>
<a name="ln1623"> </a>
<a name="ln1624">    // Isolate one argument, change it in-place, put a NUL after it.</a>
<a name="ln1625">    str = do_one_arg(str);</a>
<a name="ln1626">  }</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629">/// Parse a list of arguments (file names), expand them and return in</a>
<a name="ln1630">/// &quot;fnames[fcountp]&quot;.  When &quot;wig&quot; is true, removes files matching 'wildignore'.</a>
<a name="ln1631">///</a>
<a name="ln1632">/// @return FAIL or OK.</a>
<a name="ln1633">int get_arglist_exp(char_u *str, int *fcountp, char_u ***fnamesp, bool wig)</a>
<a name="ln1634">{</a>
<a name="ln1635">  garray_T ga;</a>
<a name="ln1636">  int i;</a>
<a name="ln1637"> </a>
<a name="ln1638">  get_arglist(&amp;ga, str, true);</a>
<a name="ln1639"> </a>
<a name="ln1640">  if (wig) {</a>
<a name="ln1641">    i = expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1642">                         fcountp, fnamesp, EW_FILE|EW_NOTFOUND);</a>
<a name="ln1643">  } else {</a>
<a name="ln1644">    i = gen_expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1645">                             fcountp, fnamesp, EW_FILE|EW_NOTFOUND);</a>
<a name="ln1646">  }</a>
<a name="ln1647"> </a>
<a name="ln1648">  ga_clear(&amp;ga);</a>
<a name="ln1649">  return i;</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652"> </a>
<a name="ln1653">/// @param str</a>
<a name="ln1654">/// @param what</a>
<a name="ln1655">///         AL_SET: Redefine the argument list to 'str'.</a>
<a name="ln1656">///         AL_ADD: add files in 'str' to the argument list after &quot;after&quot;.</a>
<a name="ln1657">///         AL_DEL: remove files in 'str' from the argument list.</a>
<a name="ln1658">/// @param after</a>
<a name="ln1659">///         0 means before first one</a>
<a name="ln1660">///</a>
<a name="ln1661">/// @return FAIL for failure, OK otherwise.</a>
<a name="ln1662">static int do_arglist(char_u *str, int what, int after)</a>
<a name="ln1663">{</a>
<a name="ln1664">  garray_T new_ga;</a>
<a name="ln1665">  int exp_count;</a>
<a name="ln1666">  char_u      **exp_files;</a>
<a name="ln1667">  char_u      *p;</a>
<a name="ln1668">  int match;</a>
<a name="ln1669">  int arg_escaped = true;</a>
<a name="ln1670"> </a>
<a name="ln1671">  // Set default argument for &quot;:argadd&quot; command.</a>
<a name="ln1672">  if (what == AL_ADD &amp;&amp; *str == NUL) {</a>
<a name="ln1673">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1674">      return FAIL;</a>
<a name="ln1675">    }</a>
<a name="ln1676">    str = curbuf-&gt;b_fname;</a>
<a name="ln1677">    arg_escaped = false;</a>
<a name="ln1678">  }</a>
<a name="ln1679"> </a>
<a name="ln1680">  // Collect all file name arguments in &quot;new_ga&quot;.</a>
<a name="ln1681">  get_arglist(&amp;new_ga, str, arg_escaped);</a>
<a name="ln1682"> </a>
<a name="ln1683">  if (what == AL_DEL) {</a>
<a name="ln1684">    regmatch_T regmatch;</a>
<a name="ln1685">    bool didone;</a>
<a name="ln1686"> </a>
<a name="ln1687">    // Delete the items: use each item as a regexp and find a match in the</a>
<a name="ln1688">    // argument list.</a>
<a name="ln1689">    regmatch.rm_ic = p_fic;     // ignore case when 'fileignorecase' is set</a>
<a name="ln1690">    for (int i = 0; i &lt; new_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln1691">      p = ((char_u **)new_ga.ga_data)[i];</a>
<a name="ln1692">      p = file_pat_to_reg_pat(p, NULL, NULL, false);</a>
<a name="ln1693">      if (p == NULL) {</a>
<a name="ln1694">        break;</a>
<a name="ln1695">      }</a>
<a name="ln1696">      regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);</a>
<a name="ln1697">      if (regmatch.regprog == NULL) {</a>
<a name="ln1698">        xfree(p);</a>
<a name="ln1699">        break;</a>
<a name="ln1700">      }</a>
<a name="ln1701"> </a>
<a name="ln1702">      didone = false;</a>
<a name="ln1703">      for (match = 0; match &lt; ARGCOUNT; match++) {</a>
<a name="ln1704">        if (vim_regexec(&amp;regmatch, alist_name(&amp;ARGLIST[match]),</a>
<a name="ln1705">                        (colnr_T)0)) {</a>
<a name="ln1706">          didone = true;</a>
<a name="ln1707">          xfree(ARGLIST[match].ae_fname);</a>
<a name="ln1708">          memmove(ARGLIST + match, ARGLIST + match + 1,</a>
<a name="ln1709">                  (size_t)(ARGCOUNT - match - 1) * sizeof(aentry_T));</a>
<a name="ln1710">          ALIST(curwin)-&gt;al_ga.ga_len--;</a>
<a name="ln1711">          if (curwin-&gt;w_arg_idx &gt; match) {</a>
<a name="ln1712">            curwin-&gt;w_arg_idx--;</a>
<a name="ln1713">          }</a>
<a name="ln1714">          match--;</a>
<a name="ln1715">        }</a>
<a name="ln1716">      }</a>
<a name="ln1717"> </a>
<a name="ln1718">      vim_regfree(regmatch.regprog);</a>
<a name="ln1719">      xfree(p);</a>
<a name="ln1720">      if (!didone) {</a>
<a name="ln1721">        EMSG2(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);</a>
<a name="ln1722">      }</a>
<a name="ln1723">    }</a>
<a name="ln1724">    ga_clear(&amp;new_ga);</a>
<a name="ln1725">  } else {</a>
<a name="ln1726">    int i = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,</a>
<a name="ln1727">                             &amp;exp_count, &amp;exp_files,</a>
<a name="ln1728">                             EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);</a>
<a name="ln1729">    ga_clear(&amp;new_ga);</a>
<a name="ln1730">    if (i == FAIL || exp_count == 0) {</a>
<a name="ln1731">      EMSG(_(e_nomatch));</a>
<a name="ln1732">      return FAIL;</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735">    if (what == AL_ADD) {</a>
<a name="ln1736">      (void)alist_add_list(exp_count, exp_files, after);</a>
<a name="ln1737">      xfree(exp_files);</a>
<a name="ln1738">    } else {  // what == AL_SET</a>
<a name="ln1739">      alist_set(ALIST(curwin), exp_count, exp_files, false, NULL, 0);</a>
<a name="ln1740">    }</a>
<a name="ln1741">  }</a>
<a name="ln1742"> </a>
<a name="ln1743">  alist_check_arg_idx();</a>
<a name="ln1744"> </a>
<a name="ln1745">  return OK;</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748">/// Check the validity of the arg_idx for each other window.</a>
<a name="ln1749">static void alist_check_arg_idx(void)</a>
<a name="ln1750">{</a>
<a name="ln1751">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln1752">    if (win-&gt;w_alist == curwin-&gt;w_alist) {</a>
<a name="ln1753">      check_arg_idx(win);</a>
<a name="ln1754">    }</a>
<a name="ln1755">  }</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758">/// Return true if window &quot;win&quot; is editing the file at the current argument</a>
<a name="ln1759">/// index.</a>
<a name="ln1760">static bool editing_arg_idx(win_T *win)</a>
<a name="ln1761">{</a>
<a name="ln1762">  return !(win-&gt;w_arg_idx &gt;= WARGCOUNT(win)</a>
<a name="ln1763">           || (win-&gt;w_buffer-&gt;b_fnum</a>
<a name="ln1764">               != WARGLIST(win)[win-&gt;w_arg_idx].ae_fnum</a>
<a name="ln1765">               &amp;&amp; (win-&gt;w_buffer-&gt;b_ffname == NULL</a>
<a name="ln1766">                   || !(path_full_compare(</a>
<a name="ln1767">                       alist_name(&amp;WARGLIST(win)[win-&gt;w_arg_idx]),</a>
<a name="ln1768">                       win-&gt;w_buffer-&gt;b_ffname, true, true) &amp; kEqualFiles))));</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">/// Check if window &quot;win&quot; is editing the w_arg_idx file in its argument list.</a>
<a name="ln1772">void check_arg_idx(win_T *win)</a>
<a name="ln1773">{</a>
<a name="ln1774">  if (WARGCOUNT(win) &gt; 1 &amp;&amp; !editing_arg_idx(win)) {</a>
<a name="ln1775">    // We are not editing the current entry in the argument list.</a>
<a name="ln1776">    // Set &quot;arg_had_last&quot; if we are editing the last one.</a>
<a name="ln1777">    win-&gt;w_arg_idx_invalid = true;</a>
<a name="ln1778">    if (win-&gt;w_arg_idx != WARGCOUNT(win) - 1</a>
<a name="ln1779">        &amp;&amp; arg_had_last == false</a>
<a name="ln1780">        &amp;&amp; ALIST(win) == &amp;global_alist</a>
<a name="ln1781">        &amp;&amp; GARGCOUNT &gt; 0</a>
<a name="ln1782">        &amp;&amp; win-&gt;w_arg_idx &lt; GARGCOUNT</a>
<a name="ln1783">        &amp;&amp; (win-&gt;w_buffer-&gt;b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum</a>
<a name="ln1784">            || (win-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln1785">                &amp;&amp; (path_full_compare(alist_name(&amp;GARGLIST[GARGCOUNT - 1]),</a>
<a name="ln1786">                                      win-&gt;w_buffer-&gt;b_ffname, true, true)</a>
<a name="ln1787">                    &amp; kEqualFiles)))) {</a>
<a name="ln1788">      arg_had_last = true;</a>
<a name="ln1789">    }</a>
<a name="ln1790">  } else {</a>
<a name="ln1791">    // We are editing the current entry in the argument list.</a>
<a name="ln1792">    // Set &quot;arg_had_last&quot; if it's also the last one</a>
<a name="ln1793">    win-&gt;w_arg_idx_invalid = false;</a>
<a name="ln1794">    if (win-&gt;w_arg_idx == WARGCOUNT(win) - 1</a>
<a name="ln1795">        &amp;&amp; win-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1796">      arg_had_last = true;</a>
<a name="ln1797">    }</a>
<a name="ln1798">  }</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">/// &quot;:args&quot;, &quot;:argslocal&quot; and &quot;:argsglobal&quot;.</a>
<a name="ln1802">void ex_args(exarg_T *eap)</a>
<a name="ln1803">{</a>
<a name="ln1804">  if (eap-&gt;cmdidx != CMD_args) {</a>
<a name="ln1805">    alist_unlink(ALIST(curwin));</a>
<a name="ln1806">    if (eap-&gt;cmdidx == CMD_argglobal) {</a>
<a name="ln1807">      ALIST(curwin) = &amp;global_alist;</a>
<a name="ln1808">    } else {     // eap-&gt;cmdidx == CMD_arglocal</a>
<a name="ln1809">      alist_new();</a>
<a name="ln1810">    }</a>
<a name="ln1811">  }</a>
<a name="ln1812"> </a>
<a name="ln1813">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1814">    // &quot;:args file ..&quot;: define new argument list, handle like &quot;:next&quot;</a>
<a name="ln1815">    // Also for &quot;:argslocal file ..&quot; and &quot;:argsglobal file ..&quot;.</a>
<a name="ln1816">    ex_next(eap);</a>
<a name="ln1817">  } else if (eap-&gt;cmdidx == CMD_args) {</a>
<a name="ln1818">    // &quot;:args&quot;: list arguments.</a>
<a name="ln1819">    if (ARGCOUNT &gt; 0) {</a>
<a name="ln1820">      char_u **items = xmalloc(sizeof(char_u *) * (size_t)ARGCOUNT);</a>
<a name="ln1821">      // Overwrite the command, for a short list there is no scrolling</a>
<a name="ln1822">      // required and no wait_return().</a>
<a name="ln1823">      gotocmdline(true);</a>
<a name="ln1824">      for (int i = 0; i &lt; ARGCOUNT; i++) {</a>
<a name="ln1825">        items[i] = alist_name(&amp;ARGLIST[i]);</a>
<a name="ln1826">      }</a>
<a name="ln1827">      list_in_columns(items, ARGCOUNT, curwin-&gt;w_arg_idx);</a>
<a name="ln1828">      xfree(items);</a>
<a name="ln1829">    }</a>
<a name="ln1830">  } else if (eap-&gt;cmdidx == CMD_arglocal) {</a>
<a name="ln1831">    garray_T        *gap = &amp;curwin-&gt;w_alist-&gt;al_ga;</a>
<a name="ln1832"> </a>
<a name="ln1833">    // &quot;:argslocal&quot;: make a local copy of the global argument list.</a>
<a name="ln1834">    ga_grow(gap, GARGCOUNT);</a>
<a name="ln1835">    for (int i = 0; i &lt; GARGCOUNT; i++) {</a>
<a name="ln1836">      if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln1837">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fname =</a>
<a name="ln1838">          vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln1839">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fnum =</a>
<a name="ln1840">          GARGLIST[i].ae_fnum;</a>
<a name="ln1841">        gap-&gt;ga_len++;</a>
<a name="ln1842">      }</a>
<a name="ln1843">    }</a>
<a name="ln1844">  }</a>
<a name="ln1845">}</a>
<a name="ln1846"> </a>
<a name="ln1847">/// &quot;:previous&quot;, &quot;:sprevious&quot;, &quot;:Next&quot; and &quot;:sNext&quot;.</a>
<a name="ln1848">void ex_previous(exarg_T *eap)</a>
<a name="ln1849">{</a>
<a name="ln1850">  // If past the last one already, go to the last one.</a>
<a name="ln1851">  if (curwin-&gt;w_arg_idx - (int)eap-&gt;line2 &gt;= ARGCOUNT) {</a>
<a name="ln1852">    do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1853">  } else {</a>
<a name="ln1854">    do_argfile(eap, curwin-&gt;w_arg_idx - (int)eap-&gt;line2);</a>
<a name="ln1855">  }</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858">/// &quot;:rewind&quot;, &quot;:first&quot;, &quot;:sfirst&quot; and &quot;:srewind&quot;.</a>
<a name="ln1859">void ex_rewind(exarg_T *eap)</a>
<a name="ln1860">{</a>
<a name="ln1861">  do_argfile(eap, 0);</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864">/// &quot;:last&quot; and &quot;:slast&quot;.</a>
<a name="ln1865">void ex_last(exarg_T *eap)</a>
<a name="ln1866">{</a>
<a name="ln1867">  do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870">/// &quot;:argument&quot; and &quot;:sargument&quot;.</a>
<a name="ln1871">void ex_argument(exarg_T *eap)</a>
<a name="ln1872">{</a>
<a name="ln1873">  int i;</a>
<a name="ln1874"> </a>
<a name="ln1875">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1876">    i = (int)eap-&gt;line2 - 1;</a>
<a name="ln1877">  } else {</a>
<a name="ln1878">    i = curwin-&gt;w_arg_idx;</a>
<a name="ln1879">  }</a>
<a name="ln1880">  do_argfile(eap, i);</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">/// Edit file &quot;argn&quot; of the argument lists.</a>
<a name="ln1884">void do_argfile(exarg_T *eap, int argn)</a>
<a name="ln1885">{</a>
<a name="ln1886">  int other;</a>
<a name="ln1887">  char_u      *p;</a>
<a name="ln1888">  int old_arg_idx = curwin-&gt;w_arg_idx;</a>
<a name="ln1889"> </a>
<a name="ln1890">  if (argn &lt; 0 || argn &gt;= ARGCOUNT) {</a>
<a name="ln1891">    if (ARGCOUNT &lt;= 1) {</a>
<a name="ln1892">      EMSG(_(&quot;E163: There is only one file to edit&quot;));</a>
<a name="ln1893">    } else if (argn &lt; 0) {</a>
<a name="ln1894">      EMSG(_(&quot;E164: Cannot go before first file&quot;));</a>
<a name="ln1895">    } else {</a>
<a name="ln1896">      EMSG(_(&quot;E165: Cannot go beyond last file&quot;));</a>
<a name="ln1897">    }</a>
<a name="ln1898">  } else {</a>
<a name="ln1899">    setpcmark();</a>
<a name="ln1900"> </a>
<a name="ln1901">    // split window or create new tab page first</a>
<a name="ln1902">    if (*eap-&gt;cmd == 's' || cmdmod.tab != 0) {</a>
<a name="ln1903">      if (win_split(0, 0) == FAIL) {</a>
<a name="ln1904">        return;</a>
<a name="ln1905">      }</a>
<a name="ln1906">      RESET_BINDING(curwin);</a>
<a name="ln1907">    } else {</a>
<a name="ln1908">      // if 'hidden' set, only check for changed file when re-editing</a>
<a name="ln1909">      // the same buffer</a>
<a name="ln1910">      other = true;</a>
<a name="ln1911">      if (buf_hide(curbuf)) {</a>
<a name="ln1912">        p = (char_u *)fix_fname((char *)alist_name(&amp;ARGLIST[argn]));</a>
<a name="ln1913">        other = otherfile(p);</a>
<a name="ln1914">        xfree(p);</a>
<a name="ln1915">      }</a>
<a name="ln1916">      if ((!buf_hide(curbuf) || !other)</a>
<a name="ln1917">          &amp;&amp; check_changed(curbuf, CCGD_AW</a>
<a name="ln1918">                           | (other ? 0 : CCGD_MULTWIN)</a>
<a name="ln1919">                           | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln1920">                           | CCGD_EXCMD)) {</a>
<a name="ln1921">        return;</a>
<a name="ln1922">      }</a>
<a name="ln1923">    }</a>
<a name="ln1924"> </a>
<a name="ln1925">    curwin-&gt;w_arg_idx = argn;</a>
<a name="ln1926">    if (argn == ARGCOUNT - 1</a>
<a name="ln1927">        &amp;&amp; curwin-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1928">      arg_had_last = true;</a>
<a name="ln1929">    }</a>
<a name="ln1930"> </a>
<a name="ln1931">    // Edit the file; always use the last known line number.</a>
<a name="ln1932">    // When it fails (e.g. Abort for already edited file) restore the</a>
<a name="ln1933">    // argument index.</a>
<a name="ln1934">    if (do_ecmd(0, alist_name(&amp;ARGLIST[curwin-&gt;w_arg_idx]), NULL,</a>
<a name="ln1935">                eap, ECMD_LAST,</a>
<a name="ln1936">                (buf_hide(curwin-&gt;w_buffer) ? ECMD_HIDE : 0)</a>
<a name="ln1937">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0), curwin) == FAIL) {</a>
<a name="ln1938">      curwin-&gt;w_arg_idx = old_arg_idx;</a>
<a name="ln1939">    } else if (eap-&gt;cmdidx != CMD_argdo) {</a>
<a name="ln1940">      // like Vi: set the mark where the cursor is in the file.</a>
<a name="ln1941">      setmark('\'');</a>
<a name="ln1942">    }</a>
<a name="ln1943">  }</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946">/// &quot;:next&quot;, and commands that behave like it.</a>
<a name="ln1947">void ex_next(exarg_T *eap)</a>
<a name="ln1948">{</a>
<a name="ln1949">  int i;</a>
<a name="ln1950"> </a>
<a name="ln1951">  // check for changed buffer now, if this fails the argument list is not</a>
<a name="ln1952">  // redefined.</a>
<a name="ln1953">  if (buf_hide(curbuf)</a>
<a name="ln1954">      || eap-&gt;cmdidx == CMD_snext</a>
<a name="ln1955">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln1956">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln1957">                        | CCGD_EXCMD)) {</a>
<a name="ln1958">    if (*eap-&gt;arg != NUL) {                 // redefine file list</a>
<a name="ln1959">      if (do_arglist(eap-&gt;arg, AL_SET, 0) == FAIL) {</a>
<a name="ln1960">        return;</a>
<a name="ln1961">      }</a>
<a name="ln1962">      i = 0;</a>
<a name="ln1963">    } else {</a>
<a name="ln1964">      i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln1965">    }</a>
<a name="ln1966">    do_argfile(eap, i);</a>
<a name="ln1967">  }</a>
<a name="ln1968">}</a>
<a name="ln1969"> </a>
<a name="ln1970">/// &quot;:argedit&quot;</a>
<a name="ln1971">void ex_argedit(exarg_T *eap)</a>
<a name="ln1972">{</a>
<a name="ln1973">  int i = eap-&gt;addr_count ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1;</a>
<a name="ln1974">  // Whether curbuf will be reused, curbuf-&gt;b_ffname will be set.</a>
<a name="ln1975">  bool curbuf_is_reusable = curbuf_reusable();</a>
<a name="ln1976"> </a>
<a name="ln1977">  if (do_arglist(eap-&gt;arg, AL_ADD, i) == FAIL) {</a>
<a name="ln1978">    return;</a>
<a name="ln1979">  }</a>
<a name="ln1980">  maketitle();</a>
<a name="ln1981"> </a>
<a name="ln1982">  if (curwin-&gt;w_arg_idx == 0</a>
<a name="ln1983">      &amp;&amp; (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln1984">      &amp;&amp; (curbuf-&gt;b_ffname == NULL || curbuf_is_reusable)) {</a>
<a name="ln1985">    i = 0;</a>
<a name="ln1986">  }</a>
<a name="ln1987">  // Edit the argument.</a>
<a name="ln1988">  if (i &lt; ARGCOUNT) {</a>
<a name="ln1989">    do_argfile(eap, i);</a>
<a name="ln1990">  }</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">/// &quot;:argadd&quot;</a>
<a name="ln1994">void ex_argadd(exarg_T *eap)</a>
<a name="ln1995">{</a>
<a name="ln1996">  do_arglist(eap-&gt;arg, AL_ADD,</a>
<a name="ln1997">             eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1);</a>
<a name="ln1998">  maketitle();</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">/// &quot;:argdelete&quot;</a>
<a name="ln2002">void ex_argdelete(exarg_T *eap)</a>
<a name="ln2003">{</a>
<a name="ln2004">  if (eap-&gt;addr_count &gt; 0 || *eap-&gt;arg == NUL) {</a>
<a name="ln2005">    // &quot;:argdel&quot; works like &quot;:.argdel&quot;</a>
<a name="ln2006">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln2007">      if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2008">        EMSG(_(&quot;E610: No argument to delete&quot;));</a>
<a name="ln2009">        return;</a>
<a name="ln2010">      }</a>
<a name="ln2011">      eap-&gt;line1 = eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2012">    } else if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2013">      // &quot;:1,4argdel&quot;: Delete all arguments in the range.</a>
<a name="ln2014">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2015">    }</a>
<a name="ln2016">    linenr_T n = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln2017">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln2018">      // Can't have both a range and an argument.</a>
<a name="ln2019">      EMSG(_(e_invarg));</a>
<a name="ln2020">    } else if (n &lt;= 0) {</a>
<a name="ln2021">      // Don't give an error for &quot;:%argdel&quot; if the list is empty.</a>
<a name="ln2022">      if (eap-&gt;line1 != 1 || eap-&gt;line2 != 0) {</a>
<a name="ln2023">        EMSG(_(e_invrange));</a>
<a name="ln2024">      }</a>
<a name="ln2025">    } else {</a>
<a name="ln2026">      for (linenr_T i = eap-&gt;line1; i &lt;= eap-&gt;line2; i++) {</a>
<a name="ln2027">        xfree(ARGLIST[i - 1].ae_fname);</a>
<a name="ln2028">      }</a>
<a name="ln2029">      memmove(ARGLIST + eap-&gt;line1 - 1, ARGLIST + eap-&gt;line2,</a>
<a name="ln2030">              (size_t)(ARGCOUNT - eap-&gt;line2) * sizeof(aentry_T));</a>
<a name="ln2031">      ALIST(curwin)-&gt;al_ga.ga_len -= (int)n;</a>
<a name="ln2032">      if (curwin-&gt;w_arg_idx &gt;= eap-&gt;line2) {</a>
<a name="ln2033">        curwin-&gt;w_arg_idx -= (int)n;</a>
<a name="ln2034">      } else if (curwin-&gt;w_arg_idx &gt; eap-&gt;line1) {</a>
<a name="ln2035">        curwin-&gt;w_arg_idx = (int)eap-&gt;line1;</a>
<a name="ln2036">      }</a>
<a name="ln2037">      if (ARGCOUNT == 0) {</a>
<a name="ln2038">          curwin-&gt;w_arg_idx = 0;</a>
<a name="ln2039">      } else if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2040">          curwin-&gt;w_arg_idx = ARGCOUNT - 1;</a>
<a name="ln2041">      }</a>
<a name="ln2042">    }</a>
<a name="ln2043">  } else {</a>
<a name="ln2044">    do_arglist(eap-&gt;arg, AL_DEL, 0);</a>
<a name="ln2045">  }</a>
<a name="ln2046">  maketitle();</a>
<a name="ln2047">}</a>
<a name="ln2048"> </a>
<a name="ln2049">/// &quot;:argdo&quot;, &quot;:windo&quot;, &quot;:bufdo&quot;, &quot;:tabdo&quot;, &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;</a>
<a name="ln2050">void ex_listdo(exarg_T *eap)</a>
<a name="ln2051">{</a>
<a name="ln2052">  int i;</a>
<a name="ln2053">  win_T       *wp;</a>
<a name="ln2054">  tabpage_T   *tp;</a>
<a name="ln2055">  int next_fnum = 0;</a>
<a name="ln2056">  char_u      *save_ei = NULL;</a>
<a name="ln2057">  char_u      *p_shm_save;</a>
<a name="ln2058"> </a>
<a name="ln2059">  if (eap-&gt;cmdidx != CMD_windo &amp;&amp; eap-&gt;cmdidx != CMD_tabdo) {</a>
<a name="ln2060">    // Don't do syntax HL autocommands.  Skipping the syntax file is a</a>
<a name="ln2061">    // great speed improvement.</a>
<a name="ln2062">    save_ei = au_event_disable(&quot;,Syntax&quot;);</a>
<a name="ln2063"> </a>
<a name="ln2064">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2065">      buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2066">    }</a>
<a name="ln2067">  }</a>
<a name="ln2068"> </a>
<a name="ln2069">  if (eap-&gt;cmdidx == CMD_windo</a>
<a name="ln2070">      || eap-&gt;cmdidx == CMD_tabdo</a>
<a name="ln2071">      || buf_hide(curbuf)</a>
<a name="ln2072">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2073">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2074">                        | CCGD_EXCMD)) {</a>
<a name="ln2075">    i = 0;</a>
<a name="ln2076">    // start at the eap-&gt;line1 argument/window/buffer</a>
<a name="ln2077">    wp = firstwin;</a>
<a name="ln2078">    tp = first_tabpage;</a>
<a name="ln2079">    switch (eap-&gt;cmdidx) {</a>
<a name="ln2080">    case CMD_windo:</a>
<a name="ln2081">      for (; wp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; wp = wp-&gt;w_next) {</a>
<a name="ln2082">        i++;</a>
<a name="ln2083">      }</a>
<a name="ln2084">      break;</a>
<a name="ln2085">    case CMD_tabdo:</a>
<a name="ln2086">      for (; tp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; tp = tp-&gt;tp_next) {</a>
<a name="ln2087">        i++;</a>
<a name="ln2088">      }</a>
<a name="ln2089">      break;</a>
<a name="ln2090">    case CMD_argdo:</a>
<a name="ln2091">      i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2092">      break;</a>
<a name="ln2093">    default:</a>
<a name="ln2094">      break;</a>
<a name="ln2095">    }</a>
<a name="ln2096"> </a>
<a name="ln2097">    buf_T *buf = curbuf;</a>
<a name="ln2098">    size_t qf_size = 0;</a>
<a name="ln2099"> </a>
<a name="ln2100">    // set pcmark now</a>
<a name="ln2101">    if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2102">      // Advance to the first listed buffer after &quot;eap-&gt;line1&quot;.</a>
<a name="ln2103">      for (buf = firstbuf;</a>
<a name="ln2104">           buf != NULL &amp;&amp; (buf-&gt;b_fnum &lt; eap-&gt;line1 || !buf-&gt;b_p_bl);</a>
<a name="ln2105">           buf = buf-&gt;b_next) {</a>
<a name="ln2106">        if (buf-&gt;b_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2107">          buf = NULL;</a>
<a name="ln2108">          break;</a>
<a name="ln2109">        }</a>
<a name="ln2110">      }</a>
<a name="ln2111">      if (buf != NULL) {</a>
<a name="ln2112">        goto_buffer(eap, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum);</a>
<a name="ln2113">      }</a>
<a name="ln2114">    } else if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2115">               || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2116">      qf_size = qf_get_valid_size(eap);</a>
<a name="ln2117">      assert(eap-&gt;line1 &gt;= 0);</a>
<a name="ln2118">      if (qf_size == 0 || (size_t)eap-&gt;line1 &gt; qf_size) {</a>
<a name="ln2119">        buf = NULL;</a>
<a name="ln2120">      } else {</a>
<a name="ln2121">        ex_cc(eap);</a>
<a name="ln2122"> </a>
<a name="ln2123">        buf = curbuf;</a>
<a name="ln2124">        i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2125">        if (eap-&gt;addr_count &lt;= 0) {</a>
<a name="ln2126">          // Default to all quickfix/location list entries.</a>
<a name="ln2127">          assert(qf_size &lt; MAXLNUM);</a>
<a name="ln2128">          eap-&gt;line2 = (linenr_T)qf_size;</a>
<a name="ln2129">        }</a>
<a name="ln2130">      }</a>
<a name="ln2131">    } else {</a>
<a name="ln2132">      setpcmark();</a>
<a name="ln2133">    }</a>
<a name="ln2134">    listcmd_busy = true;            // avoids setting pcmark below</a>
<a name="ln2135"> </a>
<a name="ln2136">    while (!got_int &amp;&amp; buf != NULL) {</a>
<a name="ln2137">      if (eap-&gt;cmdidx == CMD_argdo) {</a>
<a name="ln2138">        // go to argument &quot;i&quot;</a>
<a name="ln2139">        if (i == ARGCOUNT) {</a>
<a name="ln2140">          break;</a>
<a name="ln2141">        }</a>
<a name="ln2142">        // Don't call do_argfile() when already there, it will try</a>
<a name="ln2143">        // reloading the file.</a>
<a name="ln2144">        if (curwin-&gt;w_arg_idx != i || !editing_arg_idx(curwin)) {</a>
<a name="ln2145">          // Clear 'shm' to avoid that the file message overwrites</a>
<a name="ln2146">          // any output from the command.</a>
<a name="ln2147">          p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2148">          set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2149">          do_argfile(eap, i);</a>
<a name="ln2150">          set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2151">          xfree(p_shm_save);</a>
<a name="ln2152">        }</a>
<a name="ln2153">        if (curwin-&gt;w_arg_idx != i) {</a>
<a name="ln2154">          break;</a>
<a name="ln2155">        }</a>
<a name="ln2156">      } else if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2157">        // go to window &quot;wp&quot;</a>
<a name="ln2158">        if (!win_valid(wp)) {</a>
<a name="ln2159">          break;</a>
<a name="ln2160">        }</a>
<a name="ln2161">        assert(wp);</a>
<a name="ln2162">        win_goto(wp);</a>
<a name="ln2163">        if (curwin != wp) {</a>
<a name="ln2164">          break;    // something must be wrong</a>
<a name="ln2165">        }</a>
<a name="ln2166">        wp = curwin-&gt;w_next;</a>
<a name="ln2167">      } else if (eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2168">        // go to window &quot;tp&quot;</a>
<a name="ln2169">        if (!valid_tabpage(tp)) {</a>
<a name="ln2170">          break;</a>
<a name="ln2171">        }</a>
<a name="ln2172">        assert(tp);</a>
<a name="ln2173">        goto_tabpage_tp(tp, true, true);</a>
<a name="ln2174">        tp = tp-&gt;tp_next;</a>
<a name="ln2175">      } else if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2176">        // Remember the number of the next listed buffer, in case</a>
<a name="ln2177">        // &quot;:bwipe&quot; is used or autocommands do something strange.</a>
<a name="ln2178">        next_fnum = -1;</a>
<a name="ln2179">        for (buf_T *bp = curbuf-&gt;b_next; bp != NULL; bp = bp-&gt;b_next) {</a>
<a name="ln2180">          if (bp-&gt;b_p_bl) {</a>
<a name="ln2181">            next_fnum = bp-&gt;b_fnum;</a>
<a name="ln2182">            break;</a>
<a name="ln2183">          }</a>
<a name="ln2184">        }</a>
<a name="ln2185">      }</a>
<a name="ln2186"> </a>
<a name="ln2187">      i++;</a>
<a name="ln2188">      // execute the command</a>
<a name="ln2189">      do_cmdline(eap-&gt;arg, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln2190">                 DOCMD_VERBOSE + DOCMD_NOWAIT);</a>
<a name="ln2191"> </a>
<a name="ln2192">      if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2193">        // Done?</a>
<a name="ln2194">        if (next_fnum &lt; 0 || next_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2195">          break;</a>
<a name="ln2196">        }</a>
<a name="ln2197"> </a>
<a name="ln2198">        // Check if the buffer still exists.</a>
<a name="ln2199">        bool buf_still_exists = false;</a>
<a name="ln2200">        FOR_ALL_BUFFERS(bp) {</a>
<a name="ln2201">          if (bp-&gt;b_fnum == next_fnum) {</a>
<a name="ln2202">            buf_still_exists = true;</a>
<a name="ln2203">            break;</a>
<a name="ln2204">          }</a>
<a name="ln2205">        }</a>
<a name="ln2206">        if (!buf_still_exists) {</a>
<a name="ln2207">          break;</a>
<a name="ln2208">        }</a>
<a name="ln2209"> </a>
<a name="ln2210">        // Go to the next buffer.  Clear 'shm' to avoid that the file</a>
<a name="ln2211">        // message overwrites any output from the command.</a>
<a name="ln2212">        p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2213">        set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2214">        goto_buffer(eap, DOBUF_FIRST, FORWARD, next_fnum);</a>
<a name="ln2215">        set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2216">        xfree(p_shm_save);</a>
<a name="ln2217"> </a>
<a name="ln2218">        // If autocommands took us elsewhere, quit here.</a>
<a name="ln2219">        if (curbuf-&gt;b_fnum != next_fnum) {</a>
<a name="ln2220">          break;</a>
<a name="ln2221">        }</a>
<a name="ln2222">      }</a>
<a name="ln2223"> </a>
<a name="ln2224">      if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2225">          || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2226">        assert(i &gt;= 0);</a>
<a name="ln2227">        if ((size_t)i &gt;= qf_size || i &gt;= eap-&gt;line2) {</a>
<a name="ln2228">          break;</a>
<a name="ln2229">        }</a>
<a name="ln2230"> </a>
<a name="ln2231">        size_t qf_idx = qf_get_cur_idx(eap);</a>
<a name="ln2232"> </a>
<a name="ln2233">        ex_cnext(eap);</a>
<a name="ln2234"> </a>
<a name="ln2235">        // If jumping to the next quickfix entry fails, quit here.</a>
<a name="ln2236">        if (qf_get_cur_idx(eap) == qf_idx) {</a>
<a name="ln2237">          break;</a>
<a name="ln2238">        }</a>
<a name="ln2239">      }</a>
<a name="ln2240"> </a>
<a name="ln2241">      if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2242">        validate_cursor();              // cursor may have moved</a>
<a name="ln2243">        // required when 'scrollbind' has been set</a>
<a name="ln2244">        if (curwin-&gt;w_p_scb) {</a>
<a name="ln2245">          do_check_scrollbind(true);</a>
<a name="ln2246">        }</a>
<a name="ln2247">      }</a>
<a name="ln2248">      if (eap-&gt;cmdidx == CMD_windo || eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2249">        if (i + 1 &gt; eap-&gt;line2) {</a>
<a name="ln2250">          break;</a>
<a name="ln2251">        }</a>
<a name="ln2252">      }</a>
<a name="ln2253">      if (eap-&gt;cmdidx == CMD_argdo &amp;&amp; i &gt;= eap-&gt;line2) {</a>
<a name="ln2254">        break;</a>
<a name="ln2255">      }</a>
<a name="ln2256">    }</a>
<a name="ln2257">    listcmd_busy = false;</a>
<a name="ln2258">  }</a>
<a name="ln2259"> </a>
<a name="ln2260">  if (save_ei != NULL) {</a>
<a name="ln2261">    buf_T *bnext;</a>
<a name="ln2262">    aco_save_T aco;</a>
<a name="ln2263"> </a>
<a name="ln2264">    au_event_restore(save_ei);</a>
<a name="ln2265"> </a>
<a name="ln2266">    for (buf_T *buf = firstbuf; buf != NULL; buf = bnext) {</a>
<a name="ln2267">      bnext = buf-&gt;b_next;</a>
<a name="ln2268">      if (buf-&gt;b_nwindows &gt; 0 &amp;&amp; (buf-&gt;b_flags &amp; BF_SYN_SET)) {</a>
<a name="ln2269">        buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2270"> </a>
<a name="ln2271">        // buffer was opened while Syntax autocommands were disabled,</a>
<a name="ln2272">        // need to trigger them now.</a>
<a name="ln2273">        if (buf == curbuf) {</a>
<a name="ln2274">          apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn,</a>
<a name="ln2275">                         curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln2276">        } else {</a>
<a name="ln2277">          aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2278">          apply_autocmds(EVENT_SYNTAX, buf-&gt;b_p_syn,</a>
<a name="ln2279">                         buf-&gt;b_fname, true, buf);</a>
<a name="ln2280">          aucmd_restbuf(&amp;aco);</a>
<a name="ln2281">        }</a>
<a name="ln2282"> </a>
<a name="ln2283">        // start over, in case autocommands messed things up.</a>
<a name="ln2284">        bnext = firstbuf;</a>
<a name="ln2285">      }</a>
<a name="ln2286">    }</a>
<a name="ln2287">  }</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/// Add files[count] to the arglist of the current window after arg &quot;after&quot;.</a>
<a name="ln2291">/// The file names in files[count] must have been allocated and are taken over.</a>
<a name="ln2292">/// Files[] itself is not taken over.</a>
<a name="ln2293">///</a>
<a name="ln2294">/// @param after: where to add: 0 = before first one</a>
<a name="ln2295">///</a>
<a name="ln2296">/// @return index of first added argument</a>
<a name="ln2297">static int alist_add_list(int count, char_u **files, int after)</a>
<a name="ln2298">{</a>
<a name="ln2299">  int old_argcount = ARGCOUNT;</a>
<a name="ln2300">  ga_grow(&amp;ALIST(curwin)-&gt;al_ga, count);</a>
<a name="ln2301">  {</a>
<a name="ln2302">    if (after &lt; 0) {</a>
<a name="ln2303">      after = 0;</a>
<a name="ln2304">    }</a>
<a name="ln2305">    if (after &gt; ARGCOUNT) {</a>
<a name="ln2306">      after = ARGCOUNT;</a>
<a name="ln2307">    }</a>
<a name="ln2308">    if (after &lt; ARGCOUNT) {</a>
<a name="ln2309">      memmove(&amp;(ARGLIST[after + count]), &amp;(ARGLIST[after]),</a>
<a name="ln2310">              (size_t)(ARGCOUNT - after) * sizeof(aentry_T));</a>
<a name="ln2311">    }</a>
<a name="ln2312">    for (int i = 0; i &lt; count; i++) {</a>
<a name="ln2313">      ARGLIST[after + i].ae_fname = files[i];</a>
<a name="ln2314">      ARGLIST[after + i].ae_fnum = buflist_add(files[i],</a>
<a name="ln2315">                                               BLN_LISTED | BLN_CURBUF);</a>
<a name="ln2316">    }</a>
<a name="ln2317">    ALIST(curwin)-&gt;al_ga.ga_len += count;</a>
<a name="ln2318">    if (old_argcount &gt; 0 &amp;&amp; curwin-&gt;w_arg_idx &gt;= after) {</a>
<a name="ln2319">      curwin-&gt;w_arg_idx += count;</a>
<a name="ln2320">    }</a>
<a name="ln2321">    return after;</a>
<a name="ln2322">  }</a>
<a name="ln2323">}</a>
<a name="ln2324"> </a>
<a name="ln2325">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln2326">// argedit and argdelete commands.</a>
<a name="ln2327">char_u *get_arglist_name(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln2328">{</a>
<a name="ln2329">  if (idx &gt;= ARGCOUNT) {</a>
<a name="ln2330">    return NULL;</a>
<a name="ln2331">  }</a>
<a name="ln2332">  return alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln2333">}</a>
<a name="ln2334"> </a>
<a name="ln2335">/// &quot;:compiler[!] {name}&quot;</a>
<a name="ln2336">void ex_compiler(exarg_T *eap)</a>
<a name="ln2337">{</a>
<a name="ln2338">  char_u      *buf;</a>
<a name="ln2339">  char_u      *old_cur_comp = NULL;</a>
<a name="ln2340">  char_u      *p;</a>
<a name="ln2341"> </a>
<a name="ln2342">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln2343">    // List all compiler scripts.</a>
<a name="ln2344">    do_cmdline_cmd(&quot;echo globpath(&amp;rtp, 'compiler/*.vim')&quot;);  // NOLINT</a>
<a name="ln2345">  } else {</a>
<a name="ln2346">    size_t bufsize = STRLEN(eap-&gt;arg) + 14;</a>
<a name="ln2347">    buf = xmalloc(bufsize);</a>
<a name="ln2348">    if (eap-&gt;forceit) {</a>
<a name="ln2349">      // &quot;:compiler! {name}&quot; sets global options</a>
<a name="ln2350">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet set &lt;args&gt;&quot;);</a>
<a name="ln2351">    } else {</a>
<a name="ln2352">      // &quot;:compiler! {name}&quot; sets local options.</a>
<a name="ln2353">      // To remain backwards compatible &quot;current_compiler&quot; is always</a>
<a name="ln2354">      // used.  A user's compiler plugin may set it, the distributed</a>
<a name="ln2355">      // plugin will then skip the settings.  Afterwards set</a>
<a name="ln2356">      // &quot;b:current_compiler&quot; and restore &quot;current_compiler&quot;.</a>
<a name="ln2357">      // Explicitly prepend &quot;g:&quot; to make it work in a function.</a>
<a name="ln2358">      old_cur_comp = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2359">      if (old_cur_comp != NULL) {</a>
<a name="ln2360">        old_cur_comp = vim_strsave(old_cur_comp);</a>
<a name="ln2361">      }</a>
<a name="ln2362">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet setlocal &lt;args&gt;&quot;);</a>
<a name="ln2363">    }</a>
<a name="ln2364">    do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2365">    do_unlet(S_LEN(&quot;b:current_compiler&quot;), true);</a>
<a name="ln2366"> </a>
<a name="ln2367">    snprintf((char *)buf, bufsize, &quot;compiler/%s.vim&quot;, eap-&gt;arg);</a>
<a name="ln2368">    if (source_in_path(p_rtp, buf, DIP_ALL) == FAIL) {</a>
<a name="ln2369">      EMSG2(_(&quot;E666: compiler not supported: %s&quot;), eap-&gt;arg);</a>
<a name="ln2370">    }</a>
<a name="ln2371">    xfree(buf);</a>
<a name="ln2372"> </a>
<a name="ln2373">    do_cmdline_cmd(&quot;:delcommand CompilerSet&quot;);</a>
<a name="ln2374"> </a>
<a name="ln2375">    // Set &quot;b:current_compiler&quot; from &quot;current_compiler&quot;.</a>
<a name="ln2376">    p = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2377">    if (p != NULL) {</a>
<a name="ln2378">      set_internal_string_var((char_u *)&quot;b:current_compiler&quot;, p);</a>
<a name="ln2379">    }</a>
<a name="ln2380"> </a>
<a name="ln2381">    // Restore &quot;current_compiler&quot; for &quot;:compiler {name}&quot;.</a>
<a name="ln2382">    if (!eap-&gt;forceit) {</a>
<a name="ln2383">      if (old_cur_comp != NULL) {</a>
<a name="ln2384">        set_internal_string_var((char_u *)&quot;g:current_compiler&quot;,</a>
<a name="ln2385">                                old_cur_comp);</a>
<a name="ln2386">        xfree(old_cur_comp);</a>
<a name="ln2387">      } else {</a>
<a name="ln2388">        do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2389">      }</a>
<a name="ln2390">    }</a>
<a name="ln2391">  }</a>
<a name="ln2392">}</a>
<a name="ln2393"> </a>
<a name="ln2394"> </a>
<a name="ln2395">/// &quot;:options&quot;</a>
<a name="ln2396">void ex_options(exarg_T *eap)</a>
<a name="ln2397">{</a>
<a name="ln2398">  os_setenv(&quot;OPTWIN_CMD&quot;, cmdmod.tab ? &quot;tab&quot; : &quot;&quot;, 1);</a>
<a name="ln2399">  os_setenv(&quot;OPTWIN_CMD&quot;,</a>
<a name="ln2400">            cmdmod.tab ? &quot;tab&quot; :</a>
<a name="ln2401">            (cmdmod.split &amp; WSP_VERT) ? &quot;vert&quot; : &quot;&quot;, 1);</a>
<a name="ln2402">  cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);</a>
<a name="ln2403">}</a>
<a name="ln2404"> </a>
<a name="ln2405">// Detect Python 3 or 2, and initialize 'pyxversion'.</a>
<a name="ln2406">void init_pyxversion(void)</a>
<a name="ln2407">{</a>
<a name="ln2408">  if (p_pyx == 0) {</a>
<a name="ln2409">    if (eval_has_provider(&quot;python3&quot;)) {</a>
<a name="ln2410">      p_pyx = 3;</a>
<a name="ln2411">    } else if (eval_has_provider(&quot;python&quot;)) {</a>
<a name="ln2412">      p_pyx = 2;</a>
<a name="ln2413">    }</a>
<a name="ln2414">  }</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">// Does a file contain one of the following strings at the beginning of any</a>
<a name="ln2418">// line?</a>
<a name="ln2419">// &quot;#!(any string)python2&quot;  =&gt; returns 2</a>
<a name="ln2420">// &quot;#!(any string)python3&quot;  =&gt; returns 3</a>
<a name="ln2421">// &quot;# requires python 2.x&quot;  =&gt; returns 2</a>
<a name="ln2422">// &quot;# requires python 3.x&quot;  =&gt; returns 3</a>
<a name="ln2423">// otherwise return 0.</a>
<a name="ln2424">static int requires_py_version(char_u *filename)</a>
<a name="ln2425">{</a>
<a name="ln2426">  FILE      *file;</a>
<a name="ln2427">  int       requires_py_version = 0;</a>
<a name="ln2428">  int       i, lines;</a>
<a name="ln2429"> </a>
<a name="ln2430">  lines = (int)p_mls;</a>
<a name="ln2431">  if (lines &lt; 0) {</a>
<a name="ln2432">    lines = 5;</a>
<a name="ln2433">  }</a>
<a name="ln2434"> </a>
<a name="ln2435">  file = os_fopen((char *)filename, &quot;r&quot;);</a>
<a name="ln2436">  if (file != NULL) {</a>
<a name="ln2437">    for (i = 0; i &lt; lines; i++) {</a>
<a name="ln2438">      if (vim_fgets(IObuff, IOSIZE, file)) {</a>
<a name="ln2439">        break;</a>
<a name="ln2440">      }</a>
<a name="ln2441">      if (i == 0 &amp;&amp; IObuff[0] == '#' &amp;&amp; IObuff[1] == '!') {</a>
<a name="ln2442">        // Check shebang.</a>
<a name="ln2443">        if (strstr((char *)IObuff + 2, &quot;python2&quot;) != NULL) {</a>
<a name="ln2444">          requires_py_version = 2;</a>
<a name="ln2445">          break;</a>
<a name="ln2446">        }</a>
<a name="ln2447">        if (strstr((char *)IObuff + 2, &quot;python3&quot;) != NULL) {</a>
<a name="ln2448">          requires_py_version = 3;</a>
<a name="ln2449">          break;</a>
<a name="ln2450">        }</a>
<a name="ln2451">      }</a>
<a name="ln2452">      IObuff[21] = '\0';</a>
<a name="ln2453">      if (STRCMP(&quot;# requires python 2.x&quot;, IObuff) == 0) {</a>
<a name="ln2454">        requires_py_version = 2;</a>
<a name="ln2455">        break;</a>
<a name="ln2456">      }</a>
<a name="ln2457">      if (STRCMP(&quot;# requires python 3.x&quot;, IObuff) == 0) {</a>
<a name="ln2458">        requires_py_version = 3;</a>
<a name="ln2459">        break;</a>
<a name="ln2460">      }</a>
<a name="ln2461">    }</a>
<a name="ln2462">    fclose(file);</a>
<a name="ln2463">  }</a>
<a name="ln2464">  return requires_py_version;</a>
<a name="ln2465">}</a>
<a name="ln2466"> </a>
<a name="ln2467"> </a>
<a name="ln2468">// Source a python file using the requested python version.</a>
<a name="ln2469">static void source_pyx_file(exarg_T *eap, char_u *fname)</a>
<a name="ln2470">{</a>
<a name="ln2471">  exarg_T ex;</a>
<a name="ln2472">  long int v = requires_py_version(fname);</a>
<a name="ln2473"> </a>
<a name="ln2474">  init_pyxversion();</a>
<a name="ln2475">  if (v == 0) {</a>
<a name="ln2476">    // user didn't choose a preference, 'pyx' is used</a>
<a name="ln2477">    v = p_pyx;</a>
<a name="ln2478">  }</a>
<a name="ln2479"> </a>
<a name="ln2480">  // now source, if required python version is not supported show</a>
<a name="ln2481">  // unobtrusive message.</a>
<a name="ln2482">  if (eap == NULL) {</a>
<a name="ln2483">    memset(&amp;ex, 0, sizeof(ex));</a>
<a name="ln2484">  } else {</a>
<a name="ln2485">    ex = *eap;</a>
<a name="ln2486">  }</a>
<a name="ln2487">  ex.arg = fname;</a>
<a name="ln2488">  ex.cmd = (char_u *)(v == 2 ? &quot;pyfile&quot; : &quot;pyfile3&quot;);</a>
<a name="ln2489"> </a>
<a name="ln2490">  if (v == 2) {</a>
<a name="ln2491">    ex_pyfile(&amp;ex);</a>
<a name="ln2492">  } else {</a>
<a name="ln2493">    ex_py3file(&amp;ex);</a>
<a name="ln2494">  }</a>
<a name="ln2495">}</a>
<a name="ln2496"> </a>
<a name="ln2497">// &quot;:pyxfile {fname}&quot;</a>
<a name="ln2498">void ex_pyxfile(exarg_T *eap)</a>
<a name="ln2499">{</a>
<a name="ln2500">  source_pyx_file(eap, eap-&gt;arg);</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">// &quot;:pyx&quot;</a>
<a name="ln2504">void ex_pyx(exarg_T *eap)</a>
<a name="ln2505">{</a>
<a name="ln2506">  init_pyxversion();</a>
<a name="ln2507">  if (p_pyx == 2) {</a>
<a name="ln2508">    ex_python(eap);</a>
<a name="ln2509">  } else {</a>
<a name="ln2510">    ex_python3(eap);</a>
<a name="ln2511">  }</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514">// &quot;:pyxdo&quot;</a>
<a name="ln2515">void ex_pyxdo(exarg_T *eap)</a>
<a name="ln2516">{</a>
<a name="ln2517">  init_pyxversion();</a>
<a name="ln2518">  if (p_pyx == 2) {</a>
<a name="ln2519">    ex_pydo(eap);</a>
<a name="ln2520">  } else {</a>
<a name="ln2521">    ex_pydo3(eap);</a>
<a name="ln2522">  }</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525">/// &quot;:source {fname}&quot;</a>
<a name="ln2526">void ex_source(exarg_T *eap)</a>
<a name="ln2527">{</a>
<a name="ln2528">  cmd_source(eap-&gt;arg, eap);</a>
<a name="ln2529">}</a>
<a name="ln2530"> </a>
<a name="ln2531">static void cmd_source(char_u *fname, exarg_T *eap)</a>
<a name="ln2532">{</a>
<a name="ln2533">  if (*fname == NUL) {</a>
<a name="ln2534">    EMSG(_(e_argreq));</a>
<a name="ln2535">  } else if (eap != NULL &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln2536">    // &quot;:source!&quot;: read Normal mode commands</a>
<a name="ln2537">    // Need to execute the commands directly.  This is required at least</a>
<a name="ln2538">    // for:</a>
<a name="ln2539">    // - &quot;:g&quot; command busy</a>
<a name="ln2540">    // - after &quot;:argdo&quot;, &quot;:windo&quot; or &quot;:bufdo&quot;</a>
<a name="ln2541">    // - another command follows</a>
<a name="ln2542">    // - inside a loop</a>
<a name="ln2543">    openscript(fname, global_busy || listcmd_busy || eap-&gt;nextcmd != NULL</a>
<a name="ln2544">               || eap-&gt;cstack-&gt;cs_idx &gt;= 0);</a>
<a name="ln2545"> </a>
<a name="ln2546">    // &quot;:source&quot; read ex commands</a>
<a name="ln2547">  } else if (do_source(fname, false, DOSO_NONE) == FAIL) {</a>
<a name="ln2548">    EMSG2(_(e_notopen), fname);</a>
<a name="ln2549">  }</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">/// &quot;:source&quot; and associated commands.</a>
<a name="ln2553">///</a>
<a name="ln2554">/// @return address holding the next breakpoint line for a source cookie</a>
<a name="ln2555">linenr_T *source_breakpoint(void *cookie)</a>
<a name="ln2556">{</a>
<a name="ln2557">  return &amp;((struct source_cookie *)cookie)-&gt;breakpoint;</a>
<a name="ln2558">}</a>
<a name="ln2559"> </a>
<a name="ln2560">/// Return the address holding the debug tick for a source cookie.</a>
<a name="ln2561">int *source_dbg_tick(void *cookie)</a>
<a name="ln2562">{</a>
<a name="ln2563">  return &amp;((struct source_cookie *)cookie)-&gt;dbg_tick;</a>
<a name="ln2564">}</a>
<a name="ln2565"> </a>
<a name="ln2566">/// Return the nesting level for a source cookie.</a>
<a name="ln2567">int source_level(void *cookie)</a>
<a name="ln2568">{</a>
<a name="ln2569">  return ((struct source_cookie *)cookie)-&gt;level;</a>
<a name="ln2570">}</a>
<a name="ln2571"> </a>
<a name="ln2572">/// Special function to open a file without handle inheritance.</a>
<a name="ln2573">/// If possible the handle is closed on exec().</a>
<a name="ln2574">static FILE *fopen_noinh_readbin(char *filename)</a>
<a name="ln2575">{</a>
<a name="ln2576">#ifdef WIN32</a>
<a name="ln2577">  int fd_tmp = os_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);</a>
<a name="ln2578">#else</a>
<a name="ln2579">  int fd_tmp = os_open(filename, O_RDONLY, 0);</a>
<a name="ln2580">#endif</a>
<a name="ln2581"> </a>
<a name="ln2582">  if (fd_tmp &lt; 0) {</a>
<a name="ln2583">    return NULL;</a>
<a name="ln2584">  }</a>
<a name="ln2585"> </a>
<a name="ln2586">  (void)os_set_cloexec(fd_tmp);</a>
<a name="ln2587"> </a>
<a name="ln2588">  return fdopen(fd_tmp, READBIN);</a>
<a name="ln2589">}</a>
<a name="ln2590"> </a>
<a name="ln2591">typedef struct {</a>
<a name="ln2592">  char_u *buf;</a>
<a name="ln2593">  size_t offset;</a>
<a name="ln2594">} GetStrLineCookie;</a>
<a name="ln2595"> </a>
<a name="ln2596">/// Get one full line from a sourced string (in-memory, no file).</a>
<a name="ln2597">/// Called by do_cmdline() when it's called from do_source_str().</a>
<a name="ln2598">///</a>
<a name="ln2599">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln2600">///         some error.</a>
<a name="ln2601">static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2602">{</a>
<a name="ln2603">  GetStrLineCookie *p = cookie;</a>
<a name="ln2604">  size_t i = p-&gt;offset;</a>
<a name="ln2605">  if (strlen((char *)p-&gt;buf) &lt;= p-&gt;offset) {</a>
<a name="ln2606">    return NULL;</a>
<a name="ln2607">  }</a>
<a name="ln2608">  while (!(p-&gt;buf[i] == '\n' || p-&gt;buf[i] == '\0')) {</a>
<a name="ln2609">    i++;</a>
<a name="ln2610">  }</a>
<a name="ln2611">  char buf[2046];</a>
<a name="ln2612">  char *dst;</a>
<a name="ln2613">  dst = xstpncpy(buf, (char *)p-&gt;buf + p-&gt;offset, i - p-&gt;offset);</a>
<a name="ln2614">  if ((uint32_t)(dst - buf) != i - p-&gt;offset) {</a>
<a name="ln2615">    smsg(_(&quot;:source error parsing command %s&quot;), p-&gt;buf);</a>
<a name="ln2616">    return NULL;</a>
<a name="ln2617">  }</a>
<a name="ln2618">  buf[i - p-&gt;offset] = '\0';</a>
<a name="ln2619">  p-&gt;offset = i + 1;</a>
<a name="ln2620">  return (char_u *)xstrdup(buf);</a>
<a name="ln2621">}</a>
<a name="ln2622"> </a>
<a name="ln2623">/// Executes lines in `src` as Ex commands.</a>
<a name="ln2624">///</a>
<a name="ln2625">/// @see do_source()</a>
<a name="ln2626">int do_source_str(const char *cmd, const char *traceback_name)</a>
<a name="ln2627">{</a>
<a name="ln2628">  char_u *save_sourcing_name = sourcing_name;</a>
<a name="ln2629">  linenr_T save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2630">  char_u sourcing_name_buf[256];</a>
<a name="ln2631">  if (save_sourcing_name == NULL) {</a>
<a name="ln2632">    sourcing_name = (char_u *)traceback_name;</a>
<a name="ln2633">  } else {</a>
<a name="ln2634">    snprintf((char *)sourcing_name_buf, sizeof(sourcing_name_buf),</a>
<a name="ln2635">             &quot;%s called at %s:%&quot;PRIdLINENR, traceback_name, save_sourcing_name,</a>
<a name="ln2636">             save_sourcing_lnum);</a>
<a name="ln2637">    sourcing_name = sourcing_name_buf;</a>
<a name="ln2638">  }</a>
<a name="ln2639">  sourcing_lnum = 0;</a>
<a name="ln2640"> </a>
<a name="ln2641">  GetStrLineCookie cookie = {</a>
<a name="ln2642">    .buf = (char_u *)cmd,</a>
<a name="ln2643">    .offset = 0,</a>
<a name="ln2644">  };</a>
<a name="ln2645">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2646">  current_sctx.sc_sid = SID_STR;</a>
<a name="ln2647">  current_sctx.sc_seq = 0;</a>
<a name="ln2648">  current_sctx.sc_lnum = save_sourcing_lnum;</a>
<a name="ln2649">  int retval = do_cmdline(NULL, get_str_line, (void *)&amp;cookie,</a>
<a name="ln2650">                          DOCMD_VERBOSE | DOCMD_NOWAIT | DOCMD_REPEAT);</a>
<a name="ln2651">  current_sctx = save_current_sctx;</a>
<a name="ln2652">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln2653">  sourcing_name = save_sourcing_name;</a>
<a name="ln2654">  return retval;</a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657">/// Reads the file `fname` and executes its lines as Ex commands.</a>
<a name="ln2658">///</a>
<a name="ln2659">/// This function may be called recursively!</a>
<a name="ln2660">///</a>
<a name="ln2661">/// @see do_source_str</a>
<a name="ln2662">///</a>
<a name="ln2663">/// @param fname</a>
<a name="ln2664">/// @param check_other  check for .vimrc and _vimrc</a>
<a name="ln2665">/// @param is_vimrc     DOSO_ value</a>
<a name="ln2666">///</a>
<a name="ln2667">/// @return FAIL if file could not be opened, OK otherwise</a>
<a name="ln2668">int do_source(char_u *fname, int check_other, int is_vimrc)</a>
<a name="ln2669">{</a>
<a name="ln2670">  struct source_cookie cookie;</a>
<a name="ln2671">  char_u                  *save_sourcing_name;</a>
<a name="ln2672">  linenr_T save_sourcing_lnum;</a>
<a name="ln2673">  char_u                  *p;</a>
<a name="ln2674">  char_u                  *fname_exp;</a>
<a name="ln2675">  char_u                  *firstline = NULL;</a>
<a name="ln2676">  int retval = FAIL;</a>
<a name="ln2677">  static scid_T last_current_SID = 0;</a>
<a name="ln2678">  static int last_current_SID_seq = 0;</a>
<a name="ln2679">  int save_debug_break_level = debug_break_level;</a>
<a name="ln2680">  scriptitem_T            *si = NULL;</a>
<a name="ln2681">  proftime_T wait_start;</a>
<a name="ln2682">  bool trigger_source_post = false;</a>
<a name="ln2683"> </a>
<a name="ln2684">  p = expand_env_save(fname);</a>
<a name="ln2685">  if (p == NULL) {</a>
<a name="ln2686">    return retval;</a>
<a name="ln2687">  }</a>
<a name="ln2688">  fname_exp = (char_u *)fix_fname((char *)p);</a>
<a name="ln2689">  xfree(p);</a>
<a name="ln2690">  if (fname_exp == NULL) {</a>
<a name="ln2691">    return retval;</a>
<a name="ln2692">  }</a>
<a name="ln2693">  if (os_isdir(fname_exp)) {</a>
<a name="ln2694">    smsg(_(&quot;Cannot source a directory: \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2695">    goto theend;</a>
<a name="ln2696">  }</a>
<a name="ln2697"> </a>
<a name="ln2698">  // Apply SourceCmd autocommands, they should get the file and source it.</a>
<a name="ln2699">  if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)</a>
<a name="ln2700">      &amp;&amp; apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,</a>
<a name="ln2701">                        false, curbuf)) {</a>
<a name="ln2702">    retval = aborting() ? FAIL : OK;</a>
<a name="ln2703">    if (retval == OK) {</a>
<a name="ln2704">      // Apply SourcePost autocommands.</a>
<a name="ln2705">      apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2706">    }</a>
<a name="ln2707">    goto theend;</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  // Apply SourcePre autocommands, they may get the file.</a>
<a name="ln2711">  apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2712"> </a>
<a name="ln2713">  cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2714">  if (cookie.fp == NULL &amp;&amp; check_other) {</a>
<a name="ln2715">    // Try again, replacing file name &quot;.vimrc&quot; by &quot;_vimrc&quot; or vice versa,</a>
<a name="ln2716">    // and &quot;.exrc&quot; by &quot;_exrc&quot; or vice versa.</a>
<a name="ln2717">    p = path_tail(fname_exp);</a>
<a name="ln2718">    if ((*p == '.' || *p == '_')</a>
<a name="ln2719">        &amp;&amp; (STRICMP(p + 1, &quot;nvimrc&quot;) == 0 || STRICMP(p + 1, &quot;exrc&quot;) == 0)) {</a>
<a name="ln2720">      *p = (*p == '_') ? '.' : '_';</a>
<a name="ln2721">      cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2722">    }</a>
<a name="ln2723">  }</a>
<a name="ln2724"> </a>
<a name="ln2725">  if (cookie.fp == NULL) {</a>
<a name="ln2726">    if (p_verbose &gt; 0) {</a>
<a name="ln2727">      verbose_enter();</a>
<a name="ln2728">      if (sourcing_name == NULL) {</a>
<a name="ln2729">        smsg(_(&quot;could not source \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2730">      } else {</a>
<a name="ln2731">        smsg(_(&quot;line %&quot; PRId64 &quot;: could not source \&quot;%s\&quot;&quot;),</a>
<a name="ln2732">             (int64_t)sourcing_lnum, fname);</a>
<a name="ln2733">      }</a>
<a name="ln2734">      verbose_leave();</a>
<a name="ln2735">    }</a>
<a name="ln2736">    goto theend;</a>
<a name="ln2737">  }</a>
<a name="ln2738"> </a>
<a name="ln2739">  // The file exists.</a>
<a name="ln2740">  // - In verbose mode, give a message.</a>
<a name="ln2741">  // - For a vimrc file, may want to call vimrc_found().</a>
<a name="ln2742">  if (p_verbose &gt; 1) {</a>
<a name="ln2743">    verbose_enter();</a>
<a name="ln2744">    if (sourcing_name == NULL) {</a>
<a name="ln2745">      smsg(_(&quot;sourcing \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2746">    } else {</a>
<a name="ln2747">      smsg(_(&quot;line %&quot; PRId64 &quot;: sourcing \&quot;%s\&quot;&quot;),</a>
<a name="ln2748">           (int64_t)sourcing_lnum, fname);</a>
<a name="ln2749">    }</a>
<a name="ln2750">    verbose_leave();</a>
<a name="ln2751">  }</a>
<a name="ln2752">  if (is_vimrc == DOSO_VIMRC) {</a>
<a name="ln2753">    vimrc_found(fname_exp, (char_u *)&quot;MYVIMRC&quot;);</a>
<a name="ln2754">  }</a>
<a name="ln2755"> </a>
<a name="ln2756">#ifdef USE_CRNL</a>
<a name="ln2757">  // If no automatic file format: Set default to CR-NL.</a>
<a name="ln2758">  if (*p_ffs == NUL) {</a>
<a name="ln2759">    cookie.fileformat = EOL_DOS;</a>
<a name="ln2760">  } else {</a>
<a name="ln2761">    cookie.fileformat = EOL_UNKNOWN;</a>
<a name="ln2762">  }</a>
<a name="ln2763">  cookie.error = false;</a>
<a name="ln2764">#endif</a>
<a name="ln2765"> </a>
<a name="ln2766">  cookie.nextline = NULL;</a>
<a name="ln2767">  cookie.sourcing_lnum = 0;</a>
<a name="ln2768">  cookie.finished = false;</a>
<a name="ln2769"> </a>
<a name="ln2770">  // Check if this script has a breakpoint.</a>
<a name="ln2771">  cookie.breakpoint = dbg_find_breakpoint(true, fname_exp, (linenr_T)0);</a>
<a name="ln2772">  cookie.fname = fname_exp;</a>
<a name="ln2773">  cookie.dbg_tick = debug_tick;</a>
<a name="ln2774"> </a>
<a name="ln2775">  cookie.level = ex_nesting_level;</a>
<a name="ln2776"> </a>
<a name="ln2777">  // Keep the sourcing name/lnum, for recursive calls.</a>
<a name="ln2778">  save_sourcing_name = sourcing_name;</a>
<a name="ln2779">  sourcing_name = fname_exp;</a>
<a name="ln2780">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2781">  sourcing_lnum = 0;</a>
<a name="ln2782"> </a>
<a name="ln2783">  // start measuring script load time if --startuptime was passed and</a>
<a name="ln2784">  // time_fd was successfully opened afterwards.</a>
<a name="ln2785">  proftime_T rel_time;</a>
<a name="ln2786">  proftime_T start_time;</a>
<a name="ln2787">  FILE * const l_time_fd = time_fd;</a>
<a name="ln2788">  if (l_time_fd != NULL) {</a>
<a name="ln2789">    time_push(&amp;rel_time, &amp;start_time);</a>
<a name="ln2790">  }</a>
<a name="ln2791"> </a>
<a name="ln2792">  const int l_do_profiling = do_profiling;</a>
<a name="ln2793">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2794">    prof_child_enter(&amp;wait_start);    // entering a child now</a>
<a name="ln2795">  }</a>
<a name="ln2796"> </a>
<a name="ln2797">  // Don't use local function variables, if called from a function.</a>
<a name="ln2798">  // Also starts profiling timer for nested script.</a>
<a name="ln2799">  funccal_entry_T funccalp_entry;</a>
<a name="ln2800">  save_funccal(&amp;funccalp_entry);</a>
<a name="ln2801"> </a>
<a name="ln2802">  // Check if this script was sourced before to finds its SID.</a>
<a name="ln2803">  // If it's new, generate a new SID.</a>
<a name="ln2804">  // Always use a new sequence number.</a>
<a name="ln2805">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2806">  current_sctx.sc_seq = ++last_current_SID_seq;</a>
<a name="ln2807">  current_sctx.sc_lnum = 0;</a>
<a name="ln2808">  FileID file_id;</a>
<a name="ln2809">  bool file_id_ok = os_fileid((char *)fname_exp, &amp;file_id);</a>
<a name="ln2810">  assert(script_items.ga_len &gt;= 0);</a>
<a name="ln2811">  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid &gt; 0;</a>
<a name="ln2812">       current_sctx.sc_sid--) {</a>
<a name="ln2813">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2814">    // Compare dev/ino when possible, it catches symbolic links.</a>
<a name="ln2815">    // Also compare file names, the inode may change when the file was edited.</a>
<a name="ln2816">    bool file_id_equal = file_id_ok &amp;&amp; si-&gt;file_id_valid</a>
<a name="ln2817">                         &amp;&amp; os_fileid_equal(&amp;(si-&gt;file_id), &amp;file_id);</a>
<a name="ln2818">    if (si-&gt;sn_name != NULL</a>
<a name="ln2819">        &amp;&amp; (file_id_equal || fnamecmp(si-&gt;sn_name, fname_exp) == 0)) {</a>
<a name="ln2820">      break;</a>
<a name="ln2821">    }</a>
<a name="ln2822">  }</a>
<a name="ln2823">  if (current_sctx.sc_sid == 0) {</a>
<a name="ln2824">    current_sctx.sc_sid = ++last_current_SID;</a>
<a name="ln2825">    ga_grow(&amp;script_items, (int)(current_sctx.sc_sid - script_items.ga_len));</a>
<a name="ln2826">    while (script_items.ga_len &lt; current_sctx.sc_sid) {</a>
<a name="ln2827">      script_items.ga_len++;</a>
<a name="ln2828">      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;</a>
<a name="ln2829">      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;</a>
<a name="ln2830">    }</a>
<a name="ln2831">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2832">    si-&gt;sn_name = fname_exp;</a>
<a name="ln2833">    fname_exp = vim_strsave(si-&gt;sn_name);  // used for autocmd</a>
<a name="ln2834">    if (file_id_ok) {</a>
<a name="ln2835">      si-&gt;file_id_valid = true;</a>
<a name="ln2836">      si-&gt;file_id = file_id;</a>
<a name="ln2837">    } else {</a>
<a name="ln2838">      si-&gt;file_id_valid = false;</a>
<a name="ln2839">    }</a>
<a name="ln2840"> </a>
<a name="ln2841">    // Allocate the local script variables to use for this script.</a>
<a name="ln2842">    new_script_vars(current_sctx.sc_sid);</a>
<a name="ln2843">  }</a>
<a name="ln2844"> </a>
<a name="ln2845">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2846">    bool forceit;</a>
<a name="ln2847"> </a>
<a name="ln2848">    // Check if we do profiling for this script.</a>
<a name="ln2849">    if (!si-&gt;sn_prof_on &amp;&amp; has_profiling(true, si-&gt;sn_name, &amp;forceit)) {</a>
<a name="ln2850">      profile_init(si);</a>
<a name="ln2851">      si-&gt;sn_pr_force = forceit;</a>
<a name="ln2852">    }</a>
<a name="ln2853">    if (si-&gt;sn_prof_on) {</a>
<a name="ln2854">      si-&gt;sn_pr_count++;</a>
<a name="ln2855">      si-&gt;sn_pr_start = profile_start();</a>
<a name="ln2856">      si-&gt;sn_pr_children = profile_zero();</a>
<a name="ln2857">    }</a>
<a name="ln2858">  }</a>
<a name="ln2859"> </a>
<a name="ln2860">  cookie.conv.vc_type = CONV_NONE;              // no conversion</a>
<a name="ln2861"> </a>
<a name="ln2862">  // Read the first line so we can check for a UTF-8 BOM.</a>
<a name="ln2863">  firstline = getsourceline(0, (void *)&amp;cookie, 0, true);</a>
<a name="ln2864">  if (firstline != NULL &amp;&amp; STRLEN(firstline) &gt;= 3 &amp;&amp; firstline[0] == 0xef</a>
<a name="ln2865">      &amp;&amp; firstline[1] == 0xbb &amp;&amp; firstline[2] == 0xbf) {</a>
<a name="ln2866">    // Found BOM; setup conversion, skip over BOM and recode the line.</a>
<a name="ln2867">    convert_setup(&amp;cookie.conv, (char_u *)&quot;utf-8&quot;, p_enc);</a>
<a name="ln2868">    p = string_convert(&amp;cookie.conv, firstline + 3, NULL);</a>
<a name="ln2869">    if (p == NULL) {</a>
<a name="ln2870">      p = vim_strsave(firstline + 3);</a>
<a name="ln2871">    }</a>
<a name="ln2872">    xfree(firstline);</a>
<a name="ln2873">    firstline = p;</a>
<a name="ln2874">  }</a>
<a name="ln2875"> </a>
<a name="ln2876">  // Call do_cmdline, which will call getsourceline() to get the lines.</a>
<a name="ln2877">  do_cmdline(firstline, getsourceline, (void *)&amp;cookie,</a>
<a name="ln2878">             DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);</a>
<a name="ln2879">  retval = OK;</a>
<a name="ln2880"> </a>
<a name="ln2881">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2882">    // Get &quot;si&quot; again, &quot;script_items&quot; may have been reallocated.</a>
<a name="ln2883">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2884">    if (si-&gt;sn_prof_on) {</a>
<a name="ln2885">      si-&gt;sn_pr_start = profile_end(si-&gt;sn_pr_start);</a>
<a name="ln2886">      si-&gt;sn_pr_start = profile_sub_wait(wait_start, si-&gt;sn_pr_start);</a>
<a name="ln2887">      si-&gt;sn_pr_total = profile_add(si-&gt;sn_pr_total, si-&gt;sn_pr_start);</a>
<a name="ln2888">      si-&gt;sn_pr_self = profile_self(si-&gt;sn_pr_self, si-&gt;sn_pr_start,</a>
<a name="ln2889">                                    si-&gt;sn_pr_children);</a>
<a name="ln2890">    }</a>
<a name="ln2891">  }</a>
<a name="ln2892"> </a>
<a name="ln2893">  if (got_int) {</a>
<a name="ln2894">    EMSG(_(e_interr));</a>
<a name="ln2895">  }</a>
<a name="ln2896">  sourcing_name = save_sourcing_name;</a>
<a name="ln2897">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln2898">  if (p_verbose &gt; 1) {</a>
<a name="ln2899">    verbose_enter();</a>
<a name="ln2900">    smsg(_(&quot;finished sourcing %s&quot;), fname);</a>
<a name="ln2901">    if (sourcing_name != NULL) {</a>
<a name="ln2902">      smsg(_(&quot;continuing in %s&quot;), sourcing_name);</a>
<a name="ln2903">    }</a>
<a name="ln2904">    verbose_leave();</a>
<a name="ln2905">  }</a>
<a name="ln2906"> </a>
<a name="ln2907">  if (l_time_fd != NULL) {</a>
<a name="ln2908">    vim_snprintf((char *)IObuff, IOSIZE, &quot;sourcing %s&quot;, fname);</a>
<a name="ln2909">    time_msg((char *)IObuff, &amp;start_time);</a>
<a name="ln2910">    time_pop(rel_time);</a>
<a name="ln2911">  }</a>
<a name="ln2912"> </a>
<a name="ln2913">  if (!got_int) {</a>
<a name="ln2914">    trigger_source_post = true;</a>
<a name="ln2915">  }</a>
<a name="ln2916"> </a>
<a name="ln2917">  // After a &quot;finish&quot; in debug mode, need to break at first command of next</a>
<a name="ln2918">  // sourced file.</a>
<a name="ln2919">  if (save_debug_break_level &gt; ex_nesting_level</a>
<a name="ln2920">      &amp;&amp; debug_break_level == ex_nesting_level) {</a>
<a name="ln2921">    debug_break_level++;</a>
<a name="ln2922">  }</a>
<a name="ln2923"> </a>
<a name="ln2924">  current_sctx = save_current_sctx;</a>
<a name="ln2925">  restore_funccal();</a>
<a name="ln2926">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2927">    prof_child_exit(&amp;wait_start);    // leaving a child now</a>
<a name="ln2928">  }</a>
<a name="ln2929">  fclose(cookie.fp);</a>
<a name="ln2930">  xfree(cookie.nextline);</a>
<a name="ln2931">  xfree(firstline);</a>
<a name="ln2932">  convert_setup(&amp;cookie.conv, NULL, NULL);</a>
<a name="ln2933"> </a>
<a name="ln2934">  if (trigger_source_post) {</a>
<a name="ln2935">    apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2936">  }</a>
<a name="ln2937"> </a>
<a name="ln2938">theend:</a>
<a name="ln2939">  xfree(fname_exp);</a>
<a name="ln2940">  return retval;</a>
<a name="ln2941">}</a>
<a name="ln2942"> </a>
<a name="ln2943"> </a>
<a name="ln2944">/// &quot;:scriptnames&quot;</a>
<a name="ln2945">void ex_scriptnames(exarg_T *eap)</a>
<a name="ln2946">{</a>
<a name="ln2947">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln2948">    // :script {scriptId}: edit the script</a>
<a name="ln2949">    if (eap-&gt;line2 &lt; 1 || eap-&gt;line2 &gt; script_items.ga_len) {</a>
<a name="ln2950">      EMSG(_(e_invarg));</a>
<a name="ln2951">    } else {</a>
<a name="ln2952">      eap-&gt;arg = SCRIPT_ITEM(eap-&gt;line2).sn_name;</a>
<a name="ln2953">      do_exedit(eap, NULL);</a>
<a name="ln2954">    }</a>
<a name="ln2955">    return;</a>
<a name="ln2956">  }</a>
<a name="ln2957"> </a>
<a name="ln2958">  for (int i = 1; i &lt;= script_items.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln2959">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln2960">      home_replace(NULL, SCRIPT_ITEM(i).sn_name,</a>
<a name="ln2961">                   NameBuff, MAXPATHL, true);</a>
<a name="ln2962">      smsg(&quot;%3d: %s&quot;, i, NameBuff);</a>
<a name="ln2963">    }</a>
<a name="ln2964">  }</a>
<a name="ln2965">}</a>
<a name="ln2966"> </a>
<a name="ln2967"># if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln2968">/// Fix slashes in the list of script names for 'shellslash'.</a>
<a name="ln2969">void scriptnames_slash_adjust(void)</a>
<a name="ln2970">{</a>
<a name="ln2971">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln2972">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln2973">      slash_adjust(SCRIPT_ITEM(i).sn_name);</a>
<a name="ln2974">    }</a>
<a name="ln2975">  }</a>
<a name="ln2976">}</a>
<a name="ln2977"> </a>
<a name="ln2978"># endif</a>
<a name="ln2979"> </a>
<a name="ln2980">/// Get a pointer to a script name.  Used for &quot;:verbose set&quot;.</a>
<a name="ln2981">char_u *get_scriptname(LastSet last_set, bool *should_free)</a>
<a name="ln2982">{</a>
<a name="ln2983">  *should_free = false;</a>
<a name="ln2984"> </a>
<a name="ln2985">  switch (last_set.script_ctx.sc_sid) {</a>
<a name="ln2986">    case SID_MODELINE:</a>
<a name="ln2987">      return (char_u *)_(&quot;modeline&quot;);</a>
<a name="ln2988">    case SID_CMDARG:</a>
<a name="ln2989">      return (char_u *)_(&quot;--cmd argument&quot;);</a>
<a name="ln2990">    case SID_CARG:</a>
<a name="ln2991">      return (char_u *)_(&quot;-c argument&quot;);</a>
<a name="ln2992">    case SID_ENV:</a>
<a name="ln2993">      return (char_u *)_(&quot;environment variable&quot;);</a>
<a name="ln2994">    case SID_ERROR:</a>
<a name="ln2995">      return (char_u *)_(&quot;error handler&quot;);</a>
<a name="ln2996">    case SID_LUA:</a>
<a name="ln2997">      return (char_u *)_(&quot;Lua&quot;);</a>
<a name="ln2998">    case SID_API_CLIENT:</a>
<a name="ln2999">      vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln3000">                   _(&quot;API client (channel id %&quot; PRIu64 &quot;)&quot;),</a>
<a name="ln3001">                   last_set.channel_id);</a>
<a name="ln3002">      return IObuff;</a>
<a name="ln3003">    case SID_STR:</a>
<a name="ln3004">      return (char_u *)_(&quot;anonymous :source&quot;);</a>
<a name="ln3005">    default:</a>
<a name="ln3006">      *should_free = true;</a>
<a name="ln3007">      return home_replace_save(NULL,</a>
<a name="ln3008">                               SCRIPT_ITEM(last_set.script_ctx.sc_sid).sn_name);</a>
<a name="ln3009">  }</a>
<a name="ln3010">}</a>
<a name="ln3011"> </a>
<a name="ln3012"># if defined(EXITFREE)</a>
<a name="ln3013">void free_scriptnames(void)</a>
<a name="ln3014">{</a>
<a name="ln3015">  profile_reset();</a>
<a name="ln3016"> </a>
<a name="ln3017"># define FREE_SCRIPTNAME(item) xfree((item)-&gt;sn_name)</a>
<a name="ln3018">  GA_DEEP_CLEAR(&amp;script_items, scriptitem_T, FREE_SCRIPTNAME);</a>
<a name="ln3019">}</a>
<a name="ln3020"># endif</a>
<a name="ln3021"> </a>
<a name="ln3022">linenr_T get_sourced_lnum(LineGetter fgetline, void *cookie)</a>
<a name="ln3023">{</a>
<a name="ln3024">    return fgetline == getsourceline</a>
<a name="ln3025">        ? ((struct source_cookie *)cookie)-&gt;sourcing_lnum</a>
<a name="ln3026">        : sourcing_lnum;</a>
<a name="ln3027">}</a>
<a name="ln3028"> </a>
<a name="ln3029"> </a>
<a name="ln3030">/// Get one full line from a sourced file.</a>
<a name="ln3031">/// Called by do_cmdline() when it's called from do_source().</a>
<a name="ln3032">///</a>
<a name="ln3033">/// @return pointer to the line in allocated memory, or NULL for end-of-file or</a>
<a name="ln3034">///         some error.</a>
<a name="ln3035">char_u *getsourceline(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3036">{</a>
<a name="ln3037">  struct source_cookie *sp = (struct source_cookie *)cookie;</a>
<a name="ln3038">  char_u *line;</a>
<a name="ln3039">  char_u *p;</a>
<a name="ln3040"> </a>
<a name="ln3041">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3042">  if (sp-&gt;dbg_tick &lt; debug_tick) {</a>
<a name="ln3043">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3044">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3045">  }</a>
<a name="ln3046">  if (do_profiling == PROF_YES) {</a>
<a name="ln3047">    script_line_end();</a>
<a name="ln3048">  }</a>
<a name="ln3049">  // Set the current sourcing line number.</a>
<a name="ln3050">  sourcing_lnum = sp-&gt;sourcing_lnum + 1;</a>
<a name="ln3051">  // Get current line.  If there is a read-ahead line, use it, otherwise get</a>
<a name="ln3052">  // one now.</a>
<a name="ln3053">  if (sp-&gt;finished) {</a>
<a name="ln3054">    line = NULL;</a>
<a name="ln3055">  } else if (sp-&gt;nextline == NULL) {</a>
<a name="ln3056">    line = get_one_sourceline(sp);</a>
<a name="ln3057">  } else {</a>
<a name="ln3058">    line = sp-&gt;nextline;</a>
<a name="ln3059">    sp-&gt;nextline = NULL;</a>
<a name="ln3060">    sp-&gt;sourcing_lnum++;</a>
<a name="ln3061">  }</a>
<a name="ln3062">  if (line != NULL &amp;&amp; do_profiling == PROF_YES) {</a>
<a name="ln3063">    script_line_start();</a>
<a name="ln3064">  }</a>
<a name="ln3065"> </a>
<a name="ln3066">  // Only concatenate lines starting with a \ when 'cpoptions' doesn't</a>
<a name="ln3067">  // contain the 'C' flag.</a>
<a name="ln3068">  if (line != NULL &amp;&amp; do_concat &amp;&amp; (vim_strchr(p_cpo, CPO_CONCAT) == NULL)) {</a>
<a name="ln3069">    // compensate for the one line read-ahead</a>
<a name="ln3070">    sp-&gt;sourcing_lnum--;</a>
<a name="ln3071"> </a>
<a name="ln3072">    // Get the next line and concatenate it when it starts with a</a>
<a name="ln3073">    // backslash. We always need to read the next line, keep it in</a>
<a name="ln3074">    // sp-&gt;nextline.</a>
<a name="ln3075">    // Also check for a comment in between continuation lines: &quot;\ .</a>
<a name="ln3076">    sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3077">    if (sp-&gt;nextline != NULL</a>
<a name="ln3078">        &amp;&amp; (*(p = skipwhite(sp-&gt;nextline)) == '\\'</a>
<a name="ln3079">            || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' '))) {</a>
<a name="ln3080">      garray_T ga;</a>
<a name="ln3081"> </a>
<a name="ln3082">      ga_init(&amp;ga, (int)sizeof(char_u), 400);</a>
<a name="ln3083">      ga_concat(&amp;ga, line);</a>
<a name="ln3084">      if (*p == '\\') {</a>
<a name="ln3085">        ga_concat(&amp;ga, p + 1);</a>
<a name="ln3086">      }</a>
<a name="ln3087">      for (;; ) {</a>
<a name="ln3088">        xfree(sp-&gt;nextline);</a>
<a name="ln3089">        sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3090">        if (sp-&gt;nextline == NULL) {</a>
<a name="ln3091">          break;</a>
<a name="ln3092">        }</a>
<a name="ln3093">        p = skipwhite(sp-&gt;nextline);</a>
<a name="ln3094">        if (*p == '\\') {</a>
<a name="ln3095">          // Adjust the growsize to the current length to speed up</a>
<a name="ln3096">          // concatenating many lines.</a>
<a name="ln3097">          if (ga.ga_len &gt; 400) {</a>
<a name="ln3098">            ga_set_growsize(&amp;ga, (ga.ga_len &gt; 8000) ? 8000 : ga.ga_len);</a>
<a name="ln3099">          }</a>
<a name="ln3100">          ga_concat(&amp;ga, p + 1);</a>
<a name="ln3101">        } else if (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ') {</a>
<a name="ln3102">          break;</a>
<a name="ln3103">        }</a>
<a name="ln3104">      }</a>
<a name="ln3105">      ga_append(&amp;ga, NUL);</a>
<a name="ln3106">      xfree(line);</a>
<a name="ln3107">      line = ga.ga_data;</a>
<a name="ln3108">    }</a>
<a name="ln3109">  }</a>
<a name="ln3110"> </a>
<a name="ln3111">  if (line != NULL &amp;&amp; sp-&gt;conv.vc_type != CONV_NONE) {</a>
<a name="ln3112">    char_u  *s;</a>
<a name="ln3113"> </a>
<a name="ln3114">    // Convert the encoding of the script line.</a>
<a name="ln3115">    s = string_convert(&amp;sp-&gt;conv, line, NULL);</a>
<a name="ln3116">    if (s != NULL) {</a>
<a name="ln3117">      xfree(line);</a>
<a name="ln3118">      line = s;</a>
<a name="ln3119">    }</a>
<a name="ln3120">  }</a>
<a name="ln3121"> </a>
<a name="ln3122">  // Did we encounter a breakpoint?</a>
<a name="ln3123">  if (sp-&gt;breakpoint != 0 &amp;&amp; sp-&gt;breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln3124">    dbg_breakpoint(sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3125">    // Find next breakpoint.</a>
<a name="ln3126">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3127">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3128">  }</a>
<a name="ln3129"> </a>
<a name="ln3130">  return line;</a>
<a name="ln3131">}</a>
<a name="ln3132"> </a>
<a name="ln3133">static char_u *get_one_sourceline(struct source_cookie *sp)</a>
<a name="ln3134">{</a>
<a name="ln3135">  garray_T ga;</a>
<a name="ln3136">  int len;</a>
<a name="ln3137">  int c;</a>
<a name="ln3138">  char_u              *buf;</a>
<a name="ln3139">#ifdef USE_CRNL</a>
<a name="ln3140">  int has_cr;                           // CR-LF found</a>
<a name="ln3141">#endif</a>
<a name="ln3142">  bool have_read = false;</a>
<a name="ln3143"> </a>
<a name="ln3144">  // use a growarray to store the sourced line</a>
<a name="ln3145">  ga_init(&amp;ga, 1, 250);</a>
<a name="ln3146"> </a>
<a name="ln3147">  // Loop until there is a finished line (or end-of-file).</a>
<a name="ln3148">  sp-&gt;sourcing_lnum++;</a>
<a name="ln3149">  for (;; ) {</a>
<a name="ln3150">    // make room to read at least 120 (more) characters</a>
<a name="ln3151">    ga_grow(&amp;ga, 120);</a>
<a name="ln3152">    buf = (char_u *)ga.ga_data;</a>
<a name="ln3153"> </a>
<a name="ln3154">retry:</a>
<a name="ln3155">    errno = 0;</a>
<a name="ln3156">    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,</a>
<a name="ln3157">              sp-&gt;fp) == NULL) {</a>
<a name="ln3158">      if (errno == EINTR) {</a>
<a name="ln3159">        goto retry;</a>
<a name="ln3160">      }</a>
<a name="ln3161"> </a>
<a name="ln3162">      break;</a>
<a name="ln3163">    }</a>
<a name="ln3164">    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);</a>
<a name="ln3165">#ifdef USE_CRNL</a>
<a name="ln3166">    // Ignore a trailing CTRL-Z, when in Dos mode. Only recognize the</a>
<a name="ln3167">    // CTRL-Z by its own, or after a NL.</a>
<a name="ln3168">    if ((len == 1 || (len &gt;= 2 &amp;&amp; buf[len - 2] == '\n'))</a>
<a name="ln3169">        &amp;&amp; sp-&gt;fileformat == EOL_DOS</a>
<a name="ln3170">        &amp;&amp; buf[len - 1] == Ctrl_Z) {</a>
<a name="ln3171">      buf[len - 1] = NUL;</a>
<a name="ln3172">      break;</a>
<a name="ln3173">    }</a>
<a name="ln3174">#endif</a>
<a name="ln3175"> </a>
<a name="ln3176">    have_read = true;</a>
<a name="ln3177">    ga.ga_len = len;</a>
<a name="ln3178"> </a>
<a name="ln3179">    // If the line was longer than the buffer, read more.</a>
<a name="ln3180">    if (ga.ga_maxlen - ga.ga_len == 1 &amp;&amp; buf[len - 1] != '\n') {</a>
<a name="ln3181">      continue;</a>
<a name="ln3182">    }</a>
<a name="ln3183"> </a>
<a name="ln3184">    if (len &gt;= 1 &amp;&amp; buf[len - 1] == '\n') {     // remove trailing NL</a>
<a name="ln3185">#ifdef USE_CRNL</a>
<a name="ln3186">      has_cr = (len &gt;= 2 &amp;&amp; buf[len - 2] == '\r');</a>
<a name="ln3187">      if (sp-&gt;fileformat == EOL_UNKNOWN) {</a>
<a name="ln3188">        if (has_cr) {</a>
<a name="ln3189">          sp-&gt;fileformat = EOL_DOS;</a>
<a name="ln3190">        } else {</a>
<a name="ln3191">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3192">        }</a>
<a name="ln3193">      }</a>
<a name="ln3194"> </a>
<a name="ln3195">      if (sp-&gt;fileformat == EOL_DOS) {</a>
<a name="ln3196">        if (has_cr) {               // replace trailing CR</a>
<a name="ln3197">          buf[len - 2] = '\n';</a>
<a name="ln3198">          len--;</a>
<a name="ln3199">          ga.ga_len--;</a>
<a name="ln3200">        } else {          // lines like &quot;:map xx yy^M&quot; will have failed</a>
<a name="ln3201">          if (!sp-&gt;error) {</a>
<a name="ln3202">            msg_source(HL_ATTR(HLF_W));</a>
<a name="ln3203">            EMSG(_(&quot;W15: Warning: Wrong line separator, ^M may be missing&quot;));</a>
<a name="ln3204">          }</a>
<a name="ln3205">          sp-&gt;error = true;</a>
<a name="ln3206">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3207">        }</a>
<a name="ln3208">      }</a>
<a name="ln3209">#endif</a>
<a name="ln3210">      // The '\n' is escaped if there is an odd number of ^V's just</a>
<a name="ln3211">      // before it, first set &quot;c&quot; just before the 'V's and then check</a>
<a name="ln3212">      // len&amp;c parities (is faster than ((len-c)%2 == 0)) -- Acevedo</a>
<a name="ln3213">      for (c = len - 2; c &gt;= 0 &amp;&amp; buf[c] == Ctrl_V; c--) {}</a>
<a name="ln3214">      if ((len &amp; 1) != (c &amp; 1)) {       // escaped NL, read more</a>
<a name="ln3215">        sp-&gt;sourcing_lnum++;</a>
<a name="ln3216">        continue;</a>
<a name="ln3217">      }</a>
<a name="ln3218"> </a>
<a name="ln3219">      buf[len - 1] = NUL;               // remove the NL</a>
<a name="ln3220">    }</a>
<a name="ln3221"> </a>
<a name="ln3222">    // Check for ^C here now and then, so recursive :so can be broken.</a>
<a name="ln3223">    line_breakcheck();</a>
<a name="ln3224">    break;</a>
<a name="ln3225">  }</a>
<a name="ln3226"> </a>
<a name="ln3227">  if (have_read) {</a>
<a name="ln3228">    return (char_u *)ga.ga_data;</a>
<a name="ln3229">  }</a>
<a name="ln3230"> </a>
<a name="ln3231">  xfree(ga.ga_data);</a>
<a name="ln3232">  return NULL;</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">/// Called when starting to read a script line.</a>
<a name="ln3236">/// &quot;sourcing_lnum&quot; must be correct!</a>
<a name="ln3237">/// When skipping lines it may not actually be executed, but we won't find out</a>
<a name="ln3238">/// until later and we need to store the time now.</a>
<a name="ln3239">void script_line_start(void)</a>
<a name="ln3240">{</a>
<a name="ln3241">  scriptitem_T    *si;</a>
<a name="ln3242">  sn_prl_T        *pp;</a>
<a name="ln3243"> </a>
<a name="ln3244">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3245">    return;</a>
<a name="ln3246">  }</a>
<a name="ln3247">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3248">  if (si-&gt;sn_prof_on &amp;&amp; sourcing_lnum &gt;= 1) {</a>
<a name="ln3249">    // Grow the array before starting the timer, so that the time spent</a>
<a name="ln3250">    // here isn't counted.</a>
<a name="ln3251">    (void)ga_grow(&amp;si-&gt;sn_prl_ga,</a>
<a name="ln3252">                  (int)(sourcing_lnum - si-&gt;sn_prl_ga.ga_len));</a>
<a name="ln3253">    si-&gt;sn_prl_idx = sourcing_lnum - 1;</a>
<a name="ln3254">    while (si-&gt;sn_prl_ga.ga_len &lt;= si-&gt;sn_prl_idx</a>
<a name="ln3255">           &amp;&amp; si-&gt;sn_prl_ga.ga_len &lt; si-&gt;sn_prl_ga.ga_maxlen) {</a>
<a name="ln3256">      // Zero counters for a line that was not used before.</a>
<a name="ln3257">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_ga.ga_len);</a>
<a name="ln3258">      pp-&gt;snp_count = 0;</a>
<a name="ln3259">      pp-&gt;sn_prl_total = profile_zero();</a>
<a name="ln3260">      pp-&gt;sn_prl_self = profile_zero();</a>
<a name="ln3261">      si-&gt;sn_prl_ga.ga_len++;</a>
<a name="ln3262">    }</a>
<a name="ln3263">    si-&gt;sn_prl_execed = false;</a>
<a name="ln3264">    si-&gt;sn_prl_start = profile_start();</a>
<a name="ln3265">    si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln3266">    si-&gt;sn_prl_wait = profile_get_wait();</a>
<a name="ln3267">  }</a>
<a name="ln3268">}</a>
<a name="ln3269"> </a>
<a name="ln3270">/// Called when actually executing a function line.</a>
<a name="ln3271">void script_line_exec(void)</a>
<a name="ln3272">{</a>
<a name="ln3273">  scriptitem_T    *si;</a>
<a name="ln3274"> </a>
<a name="ln3275">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3276">    return;</a>
<a name="ln3277">  }</a>
<a name="ln3278">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3279">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0) {</a>
<a name="ln3280">    si-&gt;sn_prl_execed = true;</a>
<a name="ln3281">  }</a>
<a name="ln3282">}</a>
<a name="ln3283"> </a>
<a name="ln3284">/// Called when done with a function line.</a>
<a name="ln3285">void script_line_end(void)</a>
<a name="ln3286">{</a>
<a name="ln3287">  scriptitem_T    *si;</a>
<a name="ln3288">  sn_prl_T        *pp;</a>
<a name="ln3289"> </a>
<a name="ln3290">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3291">    return;</a>
<a name="ln3292">  }</a>
<a name="ln3293">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3294">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0</a>
<a name="ln3295">      &amp;&amp; si-&gt;sn_prl_idx &lt; si-&gt;sn_prl_ga.ga_len) {</a>
<a name="ln3296">    if (si-&gt;sn_prl_execed) {</a>
<a name="ln3297">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_idx);</a>
<a name="ln3298">      pp-&gt;snp_count++;</a>
<a name="ln3299">      si-&gt;sn_prl_start = profile_end(si-&gt;sn_prl_start);</a>
<a name="ln3300">      si-&gt;sn_prl_start = profile_sub_wait(si-&gt;sn_prl_wait, si-&gt;sn_prl_start);</a>
<a name="ln3301">      pp-&gt;sn_prl_total = profile_add(pp-&gt;sn_prl_total, si-&gt;sn_prl_start);</a>
<a name="ln3302">      pp-&gt;sn_prl_self = profile_self(pp-&gt;sn_prl_self, si-&gt;sn_prl_start,</a>
<a name="ln3303">                                     si-&gt;sn_prl_children);</a>
<a name="ln3304">    }</a>
<a name="ln3305">    si-&gt;sn_prl_idx = -1;</a>
<a name="ln3306">  }</a>
<a name="ln3307">}</a>
<a name="ln3308"> </a>
<a name="ln3309">/// &quot;:scriptencoding&quot;: Set encoding conversion for a sourced script.</a>
<a name="ln3310">/// Without the multi-byte feature it's simply ignored.</a>
<a name="ln3311">void ex_scriptencoding(exarg_T *eap)</a>
<a name="ln3312">{</a>
<a name="ln3313">  struct source_cookie        *sp;</a>
<a name="ln3314">  char_u                      *name;</a>
<a name="ln3315"> </a>
<a name="ln3316">  if (!getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3317">    EMSG(_(&quot;E167: :scriptencoding used outside of a sourced file&quot;));</a>
<a name="ln3318">    return;</a>
<a name="ln3319">  }</a>
<a name="ln3320"> </a>
<a name="ln3321">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln3322">    name = enc_canonize(eap-&gt;arg);</a>
<a name="ln3323">  } else {</a>
<a name="ln3324">    name = eap-&gt;arg;</a>
<a name="ln3325">  }</a>
<a name="ln3326"> </a>
<a name="ln3327">  // Setup for conversion from the specified encoding to 'encoding'.</a>
<a name="ln3328">  sp = (struct source_cookie *)getline_cookie(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln3329">  convert_setup(&amp;sp-&gt;conv, name, p_enc);</a>
<a name="ln3330"> </a>
<a name="ln3331">  if (name != eap-&gt;arg) {</a>
<a name="ln3332">    xfree(name);</a>
<a name="ln3333">  }</a>
<a name="ln3334">}</a>
<a name="ln3335"> </a>
<a name="ln3336">/// &quot;:finish&quot;: Mark a sourced file as finished.</a>
<a name="ln3337">void ex_finish(exarg_T *eap)</a>
<a name="ln3338">{</a>
<a name="ln3339">  if (getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3340">    do_finish(eap, false);</a>
<a name="ln3341">  } else {</a>
<a name="ln3342">    EMSG(_(&quot;E168: :finish used outside of a sourced file&quot;));</a>
<a name="ln3343">  }</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">/// Mark a sourced file as finished.  Possibly makes the &quot;:finish&quot; pending.</a>
<a name="ln3347">/// Also called for a pending finish at the &quot;:endtry&quot; or after returning from</a>
<a name="ln3348">/// an extra do_cmdline().  &quot;reanimate&quot; is used in the latter case.</a>
<a name="ln3349">void do_finish(exarg_T *eap, int reanimate)</a>
<a name="ln3350">{</a>
<a name="ln3351">  int idx;</a>
<a name="ln3352"> </a>
<a name="ln3353">  if (reanimate) {</a>
<a name="ln3354">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3355">                                            eap-&gt;cookie))-&gt;finished = false;</a>
<a name="ln3356">  }</a>
<a name="ln3357"> </a>
<a name="ln3358">  // Cleanup (and inactivate) conditionals, but stop when a try conditional</a>
<a name="ln3359">  // not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln3360">  // In this case, make the &quot;:finish&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln3361">  // Otherwise, finish normally.</a>
<a name="ln3362">  idx = cleanup_conditionals(eap-&gt;cstack, 0, true);</a>
<a name="ln3363">  if (idx &gt;= 0) {</a>
<a name="ln3364">    eap-&gt;cstack-&gt;cs_pending[idx] = CSTP_FINISH;</a>
<a name="ln3365">    report_make_pending(CSTP_FINISH, NULL);</a>
<a name="ln3366">  } else {</a>
<a name="ln3367">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3368">                                            eap-&gt;cookie))-&gt;finished = true;</a>
<a name="ln3369">  }</a>
<a name="ln3370">}</a>
<a name="ln3371"> </a>
<a name="ln3372"> </a>
<a name="ln3373">/// Return true when a sourced file had the &quot;:finish&quot; command: Don't give error</a>
<a name="ln3374">/// message for missing &quot;:endif&quot;.</a>
<a name="ln3375">/// Return false when not sourcing a file.</a>
<a name="ln3376">bool source_finished(LineGetter fgetline, void *cookie)</a>
<a name="ln3377">{</a>
<a name="ln3378">  return getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln3379">         &amp;&amp; ((struct source_cookie *)getline_cookie(</a>
<a name="ln3380">             fgetline, cookie))-&gt;finished;</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">/// &quot;:checktime [buffer]&quot;</a>
<a name="ln3384">void ex_checktime(exarg_T *eap)</a>
<a name="ln3385">{</a>
<a name="ln3386">  buf_T       *buf;</a>
<a name="ln3387">  int save_no_check_timestamps = no_check_timestamps;</a>
<a name="ln3388"> </a>
<a name="ln3389">  no_check_timestamps = 0;</a>
<a name="ln3390">  if (eap-&gt;addr_count == 0) {    // default is all buffers</a>
<a name="ln3391">    check_timestamps(false);</a>
<a name="ln3392">  } else {</a>
<a name="ln3393">    buf = buflist_findnr((int)eap-&gt;line2);</a>
<a name="ln3394">    if (buf != NULL) {           // cannot happen?</a>
<a name="ln3395">      (void)buf_check_timestamp(buf);</a>
<a name="ln3396">    }</a>
<a name="ln3397">  }</a>
<a name="ln3398">  no_check_timestamps = save_no_check_timestamps;</a>
<a name="ln3399">}</a>
<a name="ln3400"> </a>
<a name="ln3401">#if defined(HAVE_LOCALE_H)</a>
<a name="ln3402"># define HAVE_GET_LOCALE_VAL</a>
<a name="ln3403"> </a>
<a name="ln3404">static char *get_locale_val(int what)</a>
<a name="ln3405">{</a>
<a name="ln3406">  // Obtain the locale value from the libraries.</a>
<a name="ln3407">  char *loc = setlocale(what, NULL);</a>
<a name="ln3408"> </a>
<a name="ln3409">  return loc;</a>
<a name="ln3410">}</a>
<a name="ln3411">#endif</a>
<a name="ln3412"> </a>
<a name="ln3413">// Return true when &quot;lang&quot; starts with a valid language name.</a>
<a name="ln3414">// Rejects NULL, empty string, &quot;C&quot;, &quot;C.UTF-8&quot; and others.</a>
<a name="ln3415">static bool is_valid_mess_lang(char *lang)</a>
<a name="ln3416">{</a>
<a name="ln3417">  return lang != NULL &amp;&amp; ASCII_ISALPHA(lang[0]) &amp;&amp; ASCII_ISALPHA(lang[1]);</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">/// Obtain the current messages language.  Used to set the default for</a>
<a name="ln3421">/// 'helplang'.  May return NULL or an empty string.</a>
<a name="ln3422">char *get_mess_lang(void)</a>
<a name="ln3423">{</a>
<a name="ln3424">  char *p;</a>
<a name="ln3425"> </a>
<a name="ln3426"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3427">#  if defined(LC_MESSAGES)</a>
<a name="ln3428">  p = get_locale_val(LC_MESSAGES);</a>
<a name="ln3429">#  else</a>
<a name="ln3430">  // This is necessary for Win32, where LC_MESSAGES is not defined and $LANG</a>
<a name="ln3431">  // may be set to the LCID number.  LC_COLLATE is the best guess, LC_TIME</a>
<a name="ln3432">  // and LC_MONETARY may be set differently for a Japanese working in the</a>
<a name="ln3433">  // US.</a>
<a name="ln3434">  p = get_locale_val(LC_COLLATE);</a>
<a name="ln3435">#  endif</a>
<a name="ln3436"># else</a>
<a name="ln3437">  p = os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3438">  if (!is_valid_mess_lang(p)) {</a>
<a name="ln3439">    p = os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3440">    if (!is_valid_mess_lang(p)) {</a>
<a name="ln3441">      p = os_getenv(&quot;LANG&quot;);</a>
<a name="ln3442">    }</a>
<a name="ln3443">  }</a>
<a name="ln3444"># endif</a>
<a name="ln3445">  return is_valid_mess_lang(p) ? p : NULL;</a>
<a name="ln3446">}</a>
<a name="ln3447"> </a>
<a name="ln3448">// Complicated #if; matches with where get_mess_env() is used below.</a>
<a name="ln3449">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3450">/// Get the language used for messages from the environment.</a>
<a name="ln3451">static char_u *get_mess_env(void)</a>
<a name="ln3452">{</a>
<a name="ln3453">  char_u      *p;</a>
<a name="ln3454"> </a>
<a name="ln3455">  p = (char_u *)os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3456">  if (p == NULL) {</a>
<a name="ln3457">    p = (char_u *)os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3458">    if (p == NULL) {</a>
<a name="ln3459">      p = (char_u *)os_getenv(&quot;LANG&quot;);</a>
<a name="ln3460">      if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln3461">        p = NULL;                       // ignore something like &quot;1043&quot;</a>
<a name="ln3462">      }</a>
<a name="ln3463"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3464">      if (p == NULL) {</a>
<a name="ln3465">        p = (char_u *)get_locale_val(LC_CTYPE);</a>
<a name="ln3466">      }</a>
<a name="ln3467"># endif</a>
<a name="ln3468">    }</a>
<a name="ln3469">  }</a>
<a name="ln3470">  return p;</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473">#endif</a>
<a name="ln3474"> </a>
<a name="ln3475"> </a>
<a name="ln3476">/// Set the &quot;v:lang&quot; variable according to the current locale setting.</a>
<a name="ln3477">/// Also do &quot;v:lc_time&quot;and &quot;v:ctype&quot;.</a>
<a name="ln3478">void set_lang_var(void)</a>
<a name="ln3479">{</a>
<a name="ln3480">  const char *loc;</a>
<a name="ln3481"> </a>
<a name="ln3482"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3483">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3484"># else</a>
<a name="ln3485">  // setlocale() not supported: use the default value</a>
<a name="ln3486">  loc = &quot;C&quot;;</a>
<a name="ln3487"># endif</a>
<a name="ln3488">  set_vim_var_string(VV_CTYPE, loc, -1);</a>
<a name="ln3489"> </a>
<a name="ln3490">  // When LC_MESSAGES isn't defined use the value from $LC_MESSAGES, fall</a>
<a name="ln3491">  // back to LC_CTYPE if it's empty.</a>
<a name="ln3492"># ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3493">  loc = (char *)get_mess_env();</a>
<a name="ln3494"># elif defined(LC_MESSAGES)</a>
<a name="ln3495">  loc = get_locale_val(LC_MESSAGES);</a>
<a name="ln3496"># else</a>
<a name="ln3497">  // In Windows LC_MESSAGES is not defined fallback to LC_CTYPE</a>
<a name="ln3498">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3499"># endif</a>
<a name="ln3500">  set_vim_var_string(VV_LANG, loc, -1);</a>
<a name="ln3501"> </a>
<a name="ln3502"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3503">  loc = get_locale_val(LC_TIME);</a>
<a name="ln3504"># endif</a>
<a name="ln3505">  set_vim_var_string(VV_LC_TIME, loc, -1);</a>
<a name="ln3506">}</a>
<a name="ln3507"> </a>
<a name="ln3508">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3509">///</a>
<a name="ln3510">/// &quot;:language&quot;:  Set the language (locale).</a>
<a name="ln3511">///</a>
<a name="ln3512">/// @param eap</a>
<a name="ln3513">///</a>
<a name="ln3514">void ex_language(exarg_T *eap)</a>
<a name="ln3515">{</a>
<a name="ln3516">  char        *loc;</a>
<a name="ln3517">  char_u      *p;</a>
<a name="ln3518">  char_u      *name;</a>
<a name="ln3519">  int what = LC_ALL;</a>
<a name="ln3520">  char        *whatstr = &quot;&quot;;</a>
<a name="ln3521">#ifdef LC_MESSAGES</a>
<a name="ln3522"># define VIM_LC_MESSAGES LC_MESSAGES</a>
<a name="ln3523">#else</a>
<a name="ln3524"># define VIM_LC_MESSAGES 6789</a>
<a name="ln3525">#endif</a>
<a name="ln3526"> </a>
<a name="ln3527">  name = eap-&gt;arg;</a>
<a name="ln3528"> </a>
<a name="ln3529">  // Check for &quot;messages {name}&quot;, &quot;ctype {name}&quot; or &quot;time {name}&quot; argument.</a>
<a name="ln3530">  // Allow abbreviation, but require at least 3 characters to avoid</a>
<a name="ln3531">  // confusion with a two letter language name &quot;me&quot; or &quot;ct&quot;.</a>
<a name="ln3532">  p = skiptowhite(eap-&gt;arg);</a>
<a name="ln3533">  if ((*p == NUL || ascii_iswhite(*p)) &amp;&amp; p - eap-&gt;arg &gt;= 3) {</a>
<a name="ln3534">    if (STRNICMP(eap-&gt;arg, &quot;messages&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3535">      what = VIM_LC_MESSAGES;</a>
<a name="ln3536">      name = skipwhite(p);</a>
<a name="ln3537">      whatstr = &quot;messages &quot;;</a>
<a name="ln3538">    } else if (STRNICMP(eap-&gt;arg, &quot;ctype&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3539">      what = LC_CTYPE;</a>
<a name="ln3540">      name = skipwhite(p);</a>
<a name="ln3541">      whatstr = &quot;ctype &quot;;</a>
<a name="ln3542">    } else if (STRNICMP(eap-&gt;arg, &quot;time&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3543">      what = LC_TIME;</a>
<a name="ln3544">      name = skipwhite(p);</a>
<a name="ln3545">      whatstr = &quot;time &quot;;</a>
<a name="ln3546">    }</a>
<a name="ln3547">  }</a>
<a name="ln3548"> </a>
<a name="ln3549">  if (*name == NUL) {</a>
<a name="ln3550">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3551">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3552">      p = get_mess_env();</a>
<a name="ln3553">    } else {</a>
<a name="ln3554">#endif</a>
<a name="ln3555">      p = (char_u *)setlocale(what, NULL);</a>
<a name="ln3556">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3557">    }</a>
<a name="ln3558">#endif</a>
<a name="ln3559">    if (p == NULL || *p == NUL) {</a>
<a name="ln3560">      p = (char_u *)&quot;Unknown&quot;;</a>
<a name="ln3561">    }</a>
<a name="ln3562">    smsg(_(&quot;Current %slanguage: \&quot;%s\&quot;&quot;), whatstr, p);</a>
<a name="ln3563">  } else {</a>
<a name="ln3564">#ifndef LC_MESSAGES</a>
<a name="ln3565">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3566">      loc = &quot;&quot;;</a>
<a name="ln3567">    } else {</a>
<a name="ln3568">#endif</a>
<a name="ln3569">      loc = setlocale(what, (char *)name);</a>
<a name="ln3570">#ifdef LC_NUMERIC</a>
<a name="ln3571">      // Make sure strtod() uses a decimal point, not a comma.</a>
<a name="ln3572">      setlocale(LC_NUMERIC, &quot;C&quot;);</a>
<a name="ln3573">#endif</a>
<a name="ln3574">#ifndef LC_MESSAGES</a>
<a name="ln3575">    }</a>
<a name="ln3576">#endif</a>
<a name="ln3577">    if (loc == NULL) {</a>
<a name="ln3578">      EMSG2(_(&quot;E197: Cannot set language to \&quot;%s\&quot;&quot;), name);</a>
<a name="ln3579">    } else {</a>
<a name="ln3580">#ifdef HAVE_NL_MSG_CAT_CNTR</a>
<a name="ln3581">      // Need to do this for GNU gettext, otherwise cached translations</a>
<a name="ln3582">      // will be used again.</a>
<a name="ln3583">      extern int _nl_msg_cat_cntr;</a>
<a name="ln3584"> </a>
<a name="ln3585">      _nl_msg_cat_cntr++;</a>
<a name="ln3586">#endif</a>
<a name="ln3587">      // Reset $LC_ALL, otherwise it would overrule everything.</a>
<a name="ln3588">      os_setenv(&quot;LC_ALL&quot;, &quot;&quot;, 1);</a>
<a name="ln3589"> </a>
<a name="ln3590">      if (what != LC_TIME) {</a>
<a name="ln3591">        // Tell gettext() what to translate to.  It apparently doesn't</a>
<a name="ln3592">        // use the currently effective locale.</a>
<a name="ln3593">        if (what == LC_ALL) {</a>
<a name="ln3594">          os_setenv(&quot;LANG&quot;, (char *)name, 1);</a>
<a name="ln3595"> </a>
<a name="ln3596">          // Clear $LANGUAGE because GNU gettext uses it.</a>
<a name="ln3597">          os_setenv(&quot;LANGUAGE&quot;, &quot;&quot;, 1);</a>
<a name="ln3598">        }</a>
<a name="ln3599">        if (what != LC_CTYPE) {</a>
<a name="ln3600">          os_setenv(&quot;LC_MESSAGES&quot;, (char *)name, 1);</a>
<a name="ln3601">          set_helplang_default((char *)name);</a>
<a name="ln3602">        }</a>
<a name="ln3603">      }</a>
<a name="ln3604"> </a>
<a name="ln3605">      // Set v:lang, v:lc_time and v:ctype to the final result.</a>
<a name="ln3606">      set_lang_var();</a>
<a name="ln3607">      maketitle();</a>
<a name="ln3608">    }</a>
<a name="ln3609">  }</a>
<a name="ln3610">}</a>
<a name="ln3611"> </a>
<a name="ln3612"> </a>
<a name="ln3613">static char_u **locales = NULL;       // Array of all available locales</a>
<a name="ln3614"> </a>
<a name="ln3615">#ifndef WIN32</a>
<a name="ln3616">static bool did_init_locales = false;</a>
<a name="ln3617"> </a>
<a name="ln3618">/// Return an array of strings for all available locales + NULL for the</a>
<a name="ln3619">/// last element.  Return NULL in case of error.</a>
<a name="ln3620">static char_u **find_locales(void)</a>
<a name="ln3621">{</a>
<a name="ln3622">  garray_T locales_ga;</a>
<a name="ln3623">  char_u      *loc;</a>
<a name="ln3624">  char *saveptr = NULL;</a>
<a name="ln3625"> </a>
<a name="ln3626">  // Find all available locales by running command &quot;locale -a&quot;.  If this</a>
<a name="ln3627">  // doesn't work we won't have completion.</a>
<a name="ln3628">  char_u *locale_a = get_cmd_output((char_u *)&quot;locale -a&quot;, NULL,</a>
<a name="ln3629">                                    kShellOptSilent, NULL);</a>
<a name="ln3630">  if (locale_a == NULL) {</a>
<a name="ln3631">    return NULL;</a>
<a name="ln3632">  }</a>
<a name="ln3633">  ga_init(&amp;locales_ga, sizeof(char_u *), 20);</a>
<a name="ln3634"> </a>
<a name="ln3635">  // Transform locale_a string where each locale is separated by &quot;\n&quot;</a>
<a name="ln3636">  // into an array of locale strings.</a>
<a name="ln3637">  loc = (char_u *)os_strtok((char *)locale_a, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3638"> </a>
<a name="ln3639">  while (loc != NULL) {</a>
<a name="ln3640">    loc = vim_strsave(loc);</a>
<a name="ln3641">    GA_APPEND(char_u *, &amp;locales_ga, loc);</a>
<a name="ln3642">    loc = (char_u *)os_strtok(NULL, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3643">  }</a>
<a name="ln3644">  xfree(locale_a);</a>
<a name="ln3645">  // Guarantee that .ga_data is NULL terminated</a>
<a name="ln3646">  ga_grow(&amp;locales_ga, 1);</a>
<a name="ln3647">  ((char_u **)locales_ga.ga_data)[locales_ga.ga_len] = NULL;</a>
<a name="ln3648">  return (char_u **)locales_ga.ga_data;</a>
<a name="ln3649">}</a>
<a name="ln3650">#endif</a>
<a name="ln3651"> </a>
<a name="ln3652">/// Lazy initialization of all available locales.</a>
<a name="ln3653">static void init_locales(void)</a>
<a name="ln3654">{</a>
<a name="ln3655">#ifndef WIN32</a>
<a name="ln3656">  if (!did_init_locales) {</a>
<a name="ln3657">    did_init_locales = true;</a>
<a name="ln3658">    locales = find_locales();</a>
<a name="ln3659">  }</a>
<a name="ln3660">#endif</a>
<a name="ln3661">}</a>
<a name="ln3662"> </a>
<a name="ln3663">#  if defined(EXITFREE)</a>
<a name="ln3664">void free_locales(void)</a>
<a name="ln3665">{</a>
<a name="ln3666">  int i;</a>
<a name="ln3667">  if (locales != NULL) {</a>
<a name="ln3668">    for (i = 0; locales[i] != NULL; i++) {</a>
<a name="ln3669">      xfree(locales[i]);</a>
<a name="ln3670">    }</a>
<a name="ln3671">    XFREE_CLEAR(locales);</a>
<a name="ln3672">  }</a>
<a name="ln3673">}</a>
<a name="ln3674"> </a>
<a name="ln3675">#  endif</a>
<a name="ln3676"> </a>
<a name="ln3677">/// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln3678">/// &quot;:language&quot; command.</a>
<a name="ln3679">char_u *get_lang_arg(expand_T *xp, int idx)</a>
<a name="ln3680">{</a>
<a name="ln3681">  if (idx == 0) {</a>
<a name="ln3682">    return (char_u *)&quot;messages&quot;;</a>
<a name="ln3683">  }</a>
<a name="ln3684">  if (idx == 1) {</a>
<a name="ln3685">    return (char_u *)&quot;ctype&quot;;</a>
<a name="ln3686">  }</a>
<a name="ln3687">  if (idx == 2) {</a>
<a name="ln3688">    return (char_u *)&quot;time&quot;;</a>
<a name="ln3689">  }</a>
<a name="ln3690"> </a>
<a name="ln3691">  init_locales();</a>
<a name="ln3692">  if (locales == NULL) {</a>
<a name="ln3693">    return NULL;</a>
<a name="ln3694">  }</a>
<a name="ln3695">  return locales[idx - 3];</a>
<a name="ln3696">}</a>
<a name="ln3697"> </a>
<a name="ln3698">/// Function given to ExpandGeneric() to obtain the available locales.</a>
<a name="ln3699">char_u *get_locales(expand_T *xp, int idx)</a>
<a name="ln3700">{</a>
<a name="ln3701">  init_locales();</a>
<a name="ln3702">  if (locales == NULL) {</a>
<a name="ln3703">    return NULL;</a>
<a name="ln3704">  }</a>
<a name="ln3705">  return locales[idx];</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708">#endif</a>
<a name="ln3709"> </a>
<a name="ln3710"> </a>
<a name="ln3711">static void script_host_execute(char *name, exarg_T *eap)</a>
<a name="ln3712">{</a>
<a name="ln3713">  size_t len;</a>
<a name="ln3714">  char *const script = script_get(eap, &amp;len);</a>
<a name="ln3715"> </a>
<a name="ln3716">  if (script != NULL) {</a>
<a name="ln3717">    list_T *const args = tv_list_alloc(3);</a>
<a name="ln3718">    // script</a>
<a name="ln3719">    tv_list_append_allocated_string(args, script);</a>
<a name="ln3720">    // current range</a>
<a name="ln3721">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3722">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3723"> </a>
<a name="ln3724">    (void)eval_call_provider(name, &quot;execute&quot;, args, true);</a>
<a name="ln3725">  }</a>
<a name="ln3726">}</a>
<a name="ln3727"> </a>
<a name="ln3728">static void script_host_execute_file(char *name, exarg_T *eap)</a>
<a name="ln3729">{</a>
<a name="ln3730">  if (!eap-&gt;skip) {</a>
<a name="ln3731">    uint8_t buffer[MAXPATHL];</a>
<a name="ln3732">    vim_FullName((char *)eap-&gt;arg, (char *)buffer, sizeof(buffer), false);</a>
<a name="ln3733"> </a>
<a name="ln3734">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3735">    // filename</a>
<a name="ln3736">    tv_list_append_string(args, (const char *)buffer, -1);</a>
<a name="ln3737">    // current range</a>
<a name="ln3738">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3739">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3740">    (void)eval_call_provider(name, &quot;execute_file&quot;, args, true);</a>
<a name="ln3741">  }</a>
<a name="ln3742">}</a>
<a name="ln3743"> </a>
<a name="ln3744">static void script_host_do_range(char *name, exarg_T *eap)</a>
<a name="ln3745">{</a>
<a name="ln3746">  if (!eap-&gt;skip) {</a>
<a name="ln3747">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3748">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3749">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3750">    tv_list_append_string(args, (const char *)eap-&gt;arg, -1);</a>
<a name="ln3751">    (void)eval_call_provider(name, &quot;do_range&quot;, args, true);</a>
<a name="ln3752">  }</a>
<a name="ln3753">}</a>
<a name="ln3754"> </a>
<a name="ln3755">/// &quot;:drop&quot;</a>
<a name="ln3756">/// Opens the first argument in a window.  When there are two or more arguments</a>
<a name="ln3757">/// the argument list is redefined.</a>
<a name="ln3758">void ex_drop(exarg_T   *eap)</a>
<a name="ln3759">{</a>
<a name="ln3760">  bool split = false;</a>
<a name="ln3761">  buf_T *buf;</a>
<a name="ln3762"> </a>
<a name="ln3763">  // Check if the first argument is already being edited in a window.  If</a>
<a name="ln3764">  // so, jump to that window.</a>
<a name="ln3765">  // We would actually need to check all arguments, but that's complicated</a>
<a name="ln3766">  // and mostly only one file is dropped.</a>
<a name="ln3767">  // This also ignores wildcards, since it is very unlikely the user is</a>
<a name="ln3768">  // editing a file name with a wildcard character.</a>
<a name="ln3769">  do_arglist(eap-&gt;arg, AL_SET, 0);</a>
<a name="ln3770"> </a>
<a name="ln3771">  // Expanding wildcards may result in an empty argument list.  E.g. when</a>
<a name="ln3772">  // editing &quot;foo.pyc&quot; and &quot;.pyc&quot; is in 'wildignore'.  Assume that we</a>
<a name="ln3773">  // already did an error message for this.</a>
<a name="ln3774">  if (ARGCOUNT == 0) {</a>
<a name="ln3775">    return;</a>
<a name="ln3776">  }</a>
<a name="ln3777"> </a>
<a name="ln3778">  if (cmdmod.tab) {</a>
<a name="ln3779">    // &quot;:tab drop file ...&quot;: open a tab for each argument that isn't</a>
<a name="ln3780">    // edited in a window yet.  It's like &quot;:tab all&quot; but without closing</a>
<a name="ln3781">    // windows or tabs.</a>
<a name="ln3782">    ex_all(eap);</a>
<a name="ln3783">  } else {</a>
<a name="ln3784">    // &quot;:drop file ...&quot;: Edit the first argument.  Jump to an existing</a>
<a name="ln3785">    // window if possible, edit in current window if the current buffer</a>
<a name="ln3786">    // can be abandoned, otherwise open a new window.</a>
<a name="ln3787">    buf = buflist_findnr(ARGLIST[0].ae_fnum);</a>
<a name="ln3788"> </a>
<a name="ln3789">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln3790">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln3791">        goto_tabpage_win(tp, wp);</a>
<a name="ln3792">        curwin-&gt;w_arg_idx = 0;</a>
<a name="ln3793">        if (!bufIsChanged(curbuf)) {</a>
<a name="ln3794">          const int save_ar = curbuf-&gt;b_p_ar;</a>
<a name="ln3795"> </a>
<a name="ln3796">          // reload the file if it is newer</a>
<a name="ln3797">          curbuf-&gt;b_p_ar = 1;</a>
<a name="ln3798">          buf_check_timestamp(curbuf);</a>
<a name="ln3799">          curbuf-&gt;b_p_ar = save_ar;</a>
<a name="ln3800">        }</a>
<a name="ln3801">        return;</a>
<a name="ln3802">      }</a>
<a name="ln3803">    }</a>
<a name="ln3804"> </a>
<a name="ln3805">    // Check whether the current buffer is changed. If so, we will need</a>
<a name="ln3806">    // to split the current window or data could be lost.</a>
<a name="ln3807">    // Skip the check if the 'hidden' option is set, as in this case the</a>
<a name="ln3808">    // buffer won't be lost.</a>
<a name="ln3809">    if (!buf_hide(curbuf)) {</a>
<a name="ln3810">      emsg_off++;</a>
<a name="ln3811">      split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);</a>
<a name="ln3812">      emsg_off--;</a>
<a name="ln3813">    }</a>
<a name="ln3814"> </a>
<a name="ln3815">    // Fake a &quot;:sfirst&quot; or &quot;:first&quot; command edit the first argument.</a>
<a name="ln3816">    if (split) {</a>
<a name="ln3817">      eap-&gt;cmdidx = CMD_sfirst;</a>
<a name="ln3818">      eap-&gt;cmd[0] = 's';</a>
<a name="ln3819">    } else {</a>
<a name="ln3820">      eap-&gt;cmdidx = CMD_first;</a>
<a name="ln3821">    }</a>
<a name="ln3822">    ex_rewind(eap);</a>
<a name="ln3823">  }</a>
<a name="ln3824">}</a>

</code></pre>
<div class="balloon" rel="2637"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'sourcing_name_buf' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

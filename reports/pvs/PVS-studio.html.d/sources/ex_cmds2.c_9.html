
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/// @file ex_cmds2.c</a>
<a name="ln5">///</a>
<a name="ln6">/// Some more functions for command line commands</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;fcntl.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#ifdef HAVE_LOCALE_H</a>
<a name="ln17"># include &lt;locale.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln30">#include &quot;nvim/mark.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln34">#include &quot;nvim/garray.h&quot;</a>
<a name="ln35">#include &quot;nvim/memory.h&quot;</a>
<a name="ln36">#include &quot;nvim/move.h&quot;</a>
<a name="ln37">#include &quot;nvim/normal.h&quot;</a>
<a name="ln38">#include &quot;nvim/ops.h&quot;</a>
<a name="ln39">#include &quot;nvim/option.h&quot;</a>
<a name="ln40">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln43">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln44">#include &quot;nvim/screen.h&quot;</a>
<a name="ln45">#include &quot;nvim/strings.h&quot;</a>
<a name="ln46">#include &quot;nvim/undo.h&quot;</a>
<a name="ln47">#include &quot;nvim/version.h&quot;</a>
<a name="ln48">#include &quot;nvim/window.h&quot;</a>
<a name="ln49">#include &quot;nvim/profile.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln54">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">/// Growarray to store info about already sourced scripts.</a>
<a name="ln58">/// Also store the dev/ino, so that we don't have to stat() each</a>
<a name="ln59">/// script when going through the list.</a>
<a name="ln60">typedef struct scriptitem_S {</a>
<a name="ln61">  char_u      *sn_name;</a>
<a name="ln62">  bool file_id_valid;</a>
<a name="ln63">  FileID file_id;</a>
<a name="ln64">  bool sn_prof_on;              ///&lt; true when script is/was profiled</a>
<a name="ln65">  bool sn_pr_force;             ///&lt; forceit: profile functions in this script</a>
<a name="ln66">  proftime_T sn_pr_child;       ///&lt; time set when going into first child</a>
<a name="ln67">  int sn_pr_nest;               ///&lt; nesting for sn_pr_child</a>
<a name="ln68">  // profiling the script as a whole</a>
<a name="ln69">  int sn_pr_count;              ///&lt; nr of times sourced</a>
<a name="ln70">  proftime_T sn_pr_total;       ///&lt; time spent in script + children</a>
<a name="ln71">  proftime_T sn_pr_self;        ///&lt; time spent in script itself</a>
<a name="ln72">  proftime_T sn_pr_start;       ///&lt; time at script start</a>
<a name="ln73">  proftime_T sn_pr_children;    ///&lt; time in children after script start</a>
<a name="ln74">  // profiling the script per line</a>
<a name="ln75">  garray_T sn_prl_ga;           ///&lt; things stored for every line</a>
<a name="ln76">  proftime_T sn_prl_start;      ///&lt; start time for current line</a>
<a name="ln77">  proftime_T sn_prl_children;   ///&lt; time spent in children for this line</a>
<a name="ln78">  proftime_T sn_prl_wait;       ///&lt; wait start time for current line</a>
<a name="ln79">  linenr_T sn_prl_idx;          ///&lt; index of line being timed; -1 if none</a>
<a name="ln80">  int sn_prl_execed;            ///&lt; line being timed was executed</a>
<a name="ln81">} scriptitem_T;</a>
<a name="ln82"> </a>
<a name="ln83">static garray_T script_items = { 0, 0, sizeof(scriptitem_T), 4, NULL };</a>
<a name="ln84">#define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])</a>
<a name="ln85"> </a>
<a name="ln86">// Struct used in sn_prl_ga for every line of a script.</a>
<a name="ln87">typedef struct sn_prl_S {</a>
<a name="ln88">  int snp_count;                ///&lt; nr of times line was executed</a>
<a name="ln89">  proftime_T sn_prl_total;      ///&lt; time spent in a line + children</a>
<a name="ln90">  proftime_T sn_prl_self;       ///&lt; time spent in a line itself</a>
<a name="ln91">} sn_prl_T;</a>
<a name="ln92"> </a>
<a name="ln93">/// Structure used to store info for each sourced file.</a>
<a name="ln94">/// It is shared between do_source() and getsourceline().</a>
<a name="ln95">/// This is required, because it needs to be handed to do_cmdline() and</a>
<a name="ln96">/// sourcing can be done recursively.</a>
<a name="ln97">struct source_cookie {</a>
<a name="ln98">  FILE *fp;                     ///&lt; opened file for sourcing</a>
<a name="ln99">  char_u *nextline;             ///&lt; if not NULL: line that was read ahead</a>
<a name="ln100">  linenr_T sourcing_lnum;       ///&lt; line number of the source file</a>
<a name="ln101">  int finished;                 ///&lt; &quot;:finish&quot; used</a>
<a name="ln102">#if defined(USE_CRNL)</a>
<a name="ln103">  int fileformat;               ///&lt; EOL_UNKNOWN, EOL_UNIX or EOL_DOS</a>
<a name="ln104">  bool error;                   ///&lt; true if LF found after CR-LF</a>
<a name="ln105">#endif</a>
<a name="ln106">  linenr_T breakpoint;          ///&lt; next line with breakpoint or zero</a>
<a name="ln107">  char_u *fname;                ///&lt; name of sourced file</a>
<a name="ln108">  int dbg_tick;                 ///&lt; debug_tick when breakpoint was set</a>
<a name="ln109">  int level;                    ///&lt; top nesting level of sourced file</a>
<a name="ln110">  vimconv_T conv;               ///&lt; type of conversion</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113">#  define PRL_ITEM(si, idx)     (((sn_prl_T *)(si)-&gt;sn_prl_ga.ga_data)[(idx)])</a>
<a name="ln114"> </a>
<a name="ln115">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln116"># include &quot;ex_cmds2.c.generated.h&quot;</a>
<a name="ln117">#endif</a>
<a name="ln118"> </a>
<a name="ln119">/// batch mode debugging: don't save and restore typeahead.</a>
<a name="ln120">static bool debug_greedy = false;</a>
<a name="ln121"> </a>
<a name="ln122">/// Debug mode. Repeatedly get Ex commands, until told to continue normal</a>
<a name="ln123">/// execution.</a>
<a name="ln124">void do_debug(char_u *cmd)</a>
<a name="ln125">{</a>
<a name="ln126">  int save_msg_scroll = msg_scroll;</a>
<a name="ln127">  int save_State = State;</a>
<a name="ln128">  int save_did_emsg = did_emsg;</a>
<a name="ln129">  const bool save_cmd_silent = cmd_silent;</a>
<a name="ln130">  int save_msg_silent = msg_silent;</a>
<a name="ln131">  int save_emsg_silent = emsg_silent;</a>
<a name="ln132">  int save_redir_off = redir_off;</a>
<a name="ln133">  tasave_T typeaheadbuf;</a>
<a name="ln134">  bool typeahead_saved = false;</a>
<a name="ln135">  int save_ignore_script = 0;</a>
<a name="ln136">  int save_ex_normal_busy;</a>
<a name="ln137">  int n;</a>
<a name="ln138">  char_u      *cmdline = NULL;</a>
<a name="ln139">  char_u      *p;</a>
<a name="ln140">  char        *tail = NULL;</a>
<a name="ln141">  static int last_cmd = 0;</a>
<a name="ln142">#define CMD_CONT        1</a>
<a name="ln143">#define CMD_NEXT        2</a>
<a name="ln144">#define CMD_STEP        3</a>
<a name="ln145">#define CMD_FINISH      4</a>
<a name="ln146">#define CMD_QUIT        5</a>
<a name="ln147">#define CMD_INTERRUPT   6</a>
<a name="ln148">#define CMD_BACKTRACE   7</a>
<a name="ln149">#define CMD_FRAME       8</a>
<a name="ln150">#define CMD_UP          9</a>
<a name="ln151">#define CMD_DOWN        10</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">  RedrawingDisabled++;          // don't redisplay the window</a>
<a name="ln155">  no_wait_return++;             // don't wait for return</a>
<a name="ln156">  did_emsg = false;             // don't use error from debugged stuff</a>
<a name="ln157">  cmd_silent = false;           // display commands</a>
<a name="ln158">  msg_silent = false;           // display messages</a>
<a name="ln159">  emsg_silent = false;          // display error messages</a>
<a name="ln160">  redir_off = true;             // don't redirect debug commands</a>
<a name="ln161"> </a>
<a name="ln162">  State = NORMAL;</a>
<a name="ln163">  debug_mode = true;</a>
<a name="ln164"> </a>
<a name="ln165">  if (!debug_did_msg) {</a>
<a name="ln166">    MSG(_(&quot;Entering Debug mode.  Type \&quot;cont\&quot; to continue.&quot;));</a>
<a name="ln167">  }</a>
<a name="ln168">  if (sourcing_name != NULL) {</a>
<a name="ln169">    msg(sourcing_name);</a>
<a name="ln170">  }</a>
<a name="ln171">  if (sourcing_lnum != 0) {</a>
<a name="ln172">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln173">  } else {</a>
<a name="ln174">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  // Repeat getting a command and executing it.</a>
<a name="ln178">  for (;; ) {</a>
<a name="ln179">    msg_scroll = true;</a>
<a name="ln180">    need_wait_return = false;</a>
<a name="ln181">    // Save the current typeahead buffer and replace it with an empty one.</a>
<a name="ln182">    // This makes sure we get input from the user here and don't interfere</a>
<a name="ln183">    // with the commands being executed.  Reset &quot;ex_normal_busy&quot; to avoid</a>
<a name="ln184">    // the side effects of using &quot;:normal&quot;. Save the stuff buffer and make</a>
<a name="ln185">    // it empty. Set ignore_script to avoid reading from script input.</a>
<a name="ln186">    save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln187">    ex_normal_busy = 0;</a>
<a name="ln188">    if (!debug_greedy) {</a>
<a name="ln189">      save_typeahead(&amp;typeaheadbuf);</a>
<a name="ln190">      typeahead_saved = true;</a>
<a name="ln191">      save_ignore_script = ignore_script;</a>
<a name="ln192">      ignore_script = true;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">    xfree(cmdline);</a>
<a name="ln196">    cmdline = (char_u *)getcmdline_prompt('&gt;', NULL, 0, EXPAND_NOTHING, NULL,</a>
<a name="ln197">                                          CALLBACK_NONE);</a>
<a name="ln198"> </a>
<a name="ln199">    if (typeahead_saved) {</a>
<a name="ln200">      restore_typeahead(&amp;typeaheadbuf);</a>
<a name="ln201">      ignore_script = save_ignore_script;</a>
<a name="ln202">    }</a>
<a name="ln203">    ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln204"> </a>
<a name="ln205">    cmdline_row = msg_row;</a>
<a name="ln206">    msg_starthere();</a>
<a name="ln207">    if (cmdline != NULL) {</a>
<a name="ln208">      // If this is a debug command, set &quot;last_cmd&quot;.</a>
<a name="ln209">      // If not, reset &quot;last_cmd&quot;.</a>
<a name="ln210">      // For a blank line use previous command.</a>
<a name="ln211">      p = skipwhite(cmdline);</a>
<a name="ln212">      if (*p != NUL) {</a>
<a name="ln213">        switch (*p) {</a>
<a name="ln214">        case 'c': last_cmd = CMD_CONT;</a>
<a name="ln215">          tail = &quot;ont&quot;;</a>
<a name="ln216">          break;</a>
<a name="ln217">        case 'n': last_cmd = CMD_NEXT;</a>
<a name="ln218">          tail = &quot;ext&quot;;</a>
<a name="ln219">          break;</a>
<a name="ln220">        case 's': last_cmd = CMD_STEP;</a>
<a name="ln221">          tail = &quot;tep&quot;;</a>
<a name="ln222">          break;</a>
<a name="ln223">        case 'f':</a>
<a name="ln224">          last_cmd = 0;</a>
<a name="ln225">          if (p[1] == 'r') {</a>
<a name="ln226">            last_cmd = CMD_FRAME;</a>
<a name="ln227">            tail = &quot;rame&quot;;</a>
<a name="ln228">          } else {</a>
<a name="ln229">            last_cmd = CMD_FINISH;</a>
<a name="ln230">            tail = &quot;inish&quot;;</a>
<a name="ln231">          }</a>
<a name="ln232">          break;</a>
<a name="ln233">        case 'q': last_cmd = CMD_QUIT;</a>
<a name="ln234">          tail = &quot;uit&quot;;</a>
<a name="ln235">          break;</a>
<a name="ln236">        case 'i': last_cmd = CMD_INTERRUPT;</a>
<a name="ln237">          tail = &quot;nterrupt&quot;;</a>
<a name="ln238">          break;</a>
<a name="ln239">        case 'b':</a>
<a name="ln240">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln241">          if (p[1] == 't') {</a>
<a name="ln242">            tail = &quot;t&quot;;</a>
<a name="ln243">          } else {</a>
<a name="ln244">            tail = &quot;acktrace&quot;;</a>
<a name="ln245">          }</a>
<a name="ln246">          break;</a>
<a name="ln247">        case 'w':</a>
<a name="ln248">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln249">          tail = &quot;here&quot;;</a>
<a name="ln250">          break;</a>
<a name="ln251">        case 'u':</a>
<a name="ln252">          last_cmd = CMD_UP;</a>
<a name="ln253">          tail = &quot;p&quot;;</a>
<a name="ln254">          break;</a>
<a name="ln255">        case 'd':</a>
<a name="ln256">          last_cmd = CMD_DOWN;</a>
<a name="ln257">          tail = &quot;own&quot;;</a>
<a name="ln258">          break;</a>
<a name="ln259">        default: last_cmd = 0;</a>
<a name="ln260">        }</a>
<a name="ln261">        if (last_cmd != 0) {</a>
<a name="ln262">          // Check that the tail matches.</a>
<a name="ln263">          p++;</a>
<a name="ln264">          while (*p != NUL &amp;&amp; *p == *tail) {</a>
<a name="ln265">            p++;</a>
<a name="ln266">            tail++;</a>
<a name="ln267">          }</a>
<a name="ln268">          if (ASCII_ISALPHA(*p) &amp;&amp; last_cmd != CMD_FRAME) {</a>
<a name="ln269">            last_cmd = 0;</a>
<a name="ln270">          }</a>
<a name="ln271">        }</a>
<a name="ln272">      }</a>
<a name="ln273"> </a>
<a name="ln274">      if (last_cmd != 0) {</a>
<a name="ln275">        // Execute debug command: decided where to break next and return.</a>
<a name="ln276">        switch (last_cmd) {</a>
<a name="ln277">        case CMD_CONT:</a>
<a name="ln278">          debug_break_level = -1;</a>
<a name="ln279">          break;</a>
<a name="ln280">        case CMD_NEXT:</a>
<a name="ln281">          debug_break_level = ex_nesting_level;</a>
<a name="ln282">          break;</a>
<a name="ln283">        case CMD_STEP:</a>
<a name="ln284">          debug_break_level = 9999;</a>
<a name="ln285">          break;</a>
<a name="ln286">        case CMD_FINISH:</a>
<a name="ln287">          debug_break_level = ex_nesting_level - 1;</a>
<a name="ln288">          break;</a>
<a name="ln289">        case CMD_QUIT:</a>
<a name="ln290">          got_int = true;</a>
<a name="ln291">          debug_break_level = -1;</a>
<a name="ln292">          break;</a>
<a name="ln293">        case CMD_INTERRUPT:</a>
<a name="ln294">          got_int = true;</a>
<a name="ln295">          debug_break_level = 9999;</a>
<a name="ln296">          // Do not repeat &quot;&gt;interrupt&quot; cmd, continue stepping.</a>
<a name="ln297">          last_cmd = CMD_STEP;</a>
<a name="ln298">          break;</a>
<a name="ln299">        case CMD_BACKTRACE:</a>
<a name="ln300">          do_showbacktrace(cmd);</a>
<a name="ln301">          continue;</a>
<a name="ln302">        case CMD_FRAME:</a>
<a name="ln303">          if (*p == NUL) {</a>
<a name="ln304">            do_showbacktrace(cmd);</a>
<a name="ln305">          } else {</a>
<a name="ln306">            p = skipwhite(p);</a>
<a name="ln307">            do_setdebugtracelevel(p);</a>
<a name="ln308">          }</a>
<a name="ln309">          continue;</a>
<a name="ln310">        case CMD_UP:</a>
<a name="ln311">          debug_backtrace_level++;</a>
<a name="ln312">          do_checkbacktracelevel();</a>
<a name="ln313">          continue;</a>
<a name="ln314">        case CMD_DOWN:</a>
<a name="ln315">          debug_backtrace_level--;</a>
<a name="ln316">          do_checkbacktracelevel();</a>
<a name="ln317">          continue;</a>
<a name="ln318">        }</a>
<a name="ln319">        // Going out reset backtrace_level</a>
<a name="ln320">        debug_backtrace_level = 0;</a>
<a name="ln321">        break;</a>
<a name="ln322">      }</a>
<a name="ln323"> </a>
<a name="ln324">      // don't debug this command</a>
<a name="ln325">      n = debug_break_level;</a>
<a name="ln326">      debug_break_level = -1;</a>
<a name="ln327">      (void)do_cmdline(cmdline, getexline, NULL,</a>
<a name="ln328">                       DOCMD_VERBOSE|DOCMD_EXCRESET);</a>
<a name="ln329">      debug_break_level = n;</a>
<a name="ln330">    }</a>
<a name="ln331">    lines_left = (int)(Rows - 1);</a>
<a name="ln332">  }</a>
<a name="ln333">  xfree(cmdline);</a>
<a name="ln334"> </a>
<a name="ln335">  RedrawingDisabled--;</a>
<a name="ln336">  no_wait_return--;</a>
<a name="ln337">  redraw_all_later(NOT_VALID);</a>
<a name="ln338">  need_wait_return = false;</a>
<a name="ln339">  msg_scroll = save_msg_scroll;</a>
<a name="ln340">  lines_left = (int)(Rows - 1);</a>
<a name="ln341">  State = save_State;</a>
<a name="ln342">  debug_mode = false;</a>
<a name="ln343">  did_emsg = save_did_emsg;</a>
<a name="ln344">  cmd_silent = save_cmd_silent;</a>
<a name="ln345">  msg_silent = save_msg_silent;</a>
<a name="ln346">  emsg_silent = save_emsg_silent;</a>
<a name="ln347">  redir_off = save_redir_off;</a>
<a name="ln348"> </a>
<a name="ln349">  // Only print the message again when typing a command before coming back here.</a>
<a name="ln350">  debug_did_msg = true;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static int get_maxbacktrace_level(void)</a>
<a name="ln354">{</a>
<a name="ln355">  int maxbacktrace = 0;</a>
<a name="ln356"> </a>
<a name="ln357">  if (sourcing_name != NULL) {</a>
<a name="ln358">    char *p = (char *)sourcing_name;</a>
<a name="ln359">    char *q;</a>
<a name="ln360">    while ((q = strstr(p, &quot;..&quot;)) != NULL) {</a>
<a name="ln361">      p = q + 2;</a>
<a name="ln362">      maxbacktrace++;</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365">  return maxbacktrace;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static void do_setdebugtracelevel(char_u *arg)</a>
<a name="ln369">{</a>
<a name="ln370">  int level = atoi((char *)arg);</a>
<a name="ln371">  if (*arg == '+' || level &lt; 0) {</a>
<a name="ln372">    debug_backtrace_level += level;</a>
<a name="ln373">  } else {</a>
<a name="ln374">    debug_backtrace_level = level;</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  do_checkbacktracelevel();</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">static void do_checkbacktracelevel(void)</a>
<a name="ln381">{</a>
<a name="ln382">  if (debug_backtrace_level &lt; 0) {</a>
<a name="ln383">    debug_backtrace_level = 0;</a>
<a name="ln384">    MSG(_(&quot;frame is zero&quot;));</a>
<a name="ln385">  } else {</a>
<a name="ln386">    int max = get_maxbacktrace_level();</a>
<a name="ln387">    if (debug_backtrace_level &gt; max) {</a>
<a name="ln388">      debug_backtrace_level = max;</a>
<a name="ln389">      smsg(_(&quot;frame at highest level: %d&quot;), max);</a>
<a name="ln390">    }</a>
<a name="ln391">  }</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">static void do_showbacktrace(char_u *cmd)</a>
<a name="ln395">{</a>
<a name="ln396">  if (sourcing_name != NULL) {</a>
<a name="ln397">    int i = 0;</a>
<a name="ln398">    int max = get_maxbacktrace_level();</a>
<a name="ln399">    char *cur = (char *)sourcing_name;</a>
<a name="ln400">    while (!got_int) {</a>
<a name="ln401">      char *next = strstr(cur, &quot;..&quot;);</a>
<a name="ln402">      if (next != NULL) {</a>
<a name="ln403">        *next = NUL;</a>
<a name="ln404">      }</a>
<a name="ln405">      if (i == max - debug_backtrace_level) {</a>
<a name="ln406">        smsg(&quot;-&gt;%d %s&quot;, max - i, cur);</a>
<a name="ln407">      } else {</a>
<a name="ln408">        smsg(&quot;  %d %s&quot;, max - i, cur);</a>
<a name="ln409">      }</a>
<a name="ln410">      i++;</a>
<a name="ln411">      if (next == NULL) {</a>
<a name="ln412">        break;</a>
<a name="ln413">      }</a>
<a name="ln414">      *next = '.';</a>
<a name="ln415">      cur = next + 2;</a>
<a name="ln416">    }</a>
<a name="ln417">  }</a>
<a name="ln418">  if (sourcing_lnum != 0) {</a>
<a name="ln419">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln420">  } else {</a>
<a name="ln421">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln422">  }</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">/// &quot;:debug&quot;.</a>
<a name="ln427">void ex_debug(exarg_T *eap)</a>
<a name="ln428">{</a>
<a name="ln429">  int debug_break_level_save = debug_break_level;</a>
<a name="ln430"> </a>
<a name="ln431">  debug_break_level = 9999;</a>
<a name="ln432">  do_cmdline_cmd((char *)eap-&gt;arg);</a>
<a name="ln433">  debug_break_level = debug_break_level_save;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">static char_u   *debug_breakpoint_name = NULL;</a>
<a name="ln437">static linenr_T debug_breakpoint_lnum;</a>
<a name="ln438"> </a>
<a name="ln439">/// When debugging or a breakpoint is set on a skipped command, no debug prompt</a>
<a name="ln440">/// is shown by do_one_cmd().  This situation is indicated by debug_skipped, and</a>
<a name="ln441">/// debug_skipped_name is then set to the source name in the breakpoint case. If</a>
<a name="ln442">/// a skipped command decides itself that a debug prompt should be displayed, it</a>
<a name="ln443">/// can do so by calling dbg_check_skipped().</a>
<a name="ln444">static int debug_skipped;</a>
<a name="ln445">static char_u   *debug_skipped_name;</a>
<a name="ln446"> </a>
<a name="ln447">/// Go to debug mode when a breakpoint was encountered or &quot;ex_nesting_level&quot; is</a>
<a name="ln448">/// at or below the break level.  But only when the line is actually</a>
<a name="ln449">/// executed.  Return true and set breakpoint_name for skipped commands that</a>
<a name="ln450">/// decide to execute something themselves.</a>
<a name="ln451">/// Called from do_one_cmd() before executing a command.</a>
<a name="ln452">void dbg_check_breakpoint(exarg_T *eap)</a>
<a name="ln453">{</a>
<a name="ln454">  char_u      *p;</a>
<a name="ln455"> </a>
<a name="ln456">  debug_skipped = false;</a>
<a name="ln457">  if (debug_breakpoint_name != NULL) {</a>
<a name="ln458">    if (!eap-&gt;skip) {</a>
<a name="ln459">      // replace K_SNR with &quot;&lt;SNR&gt;&quot;</a>
<a name="ln460">      if (debug_breakpoint_name[0] == K_SPECIAL</a>
<a name="ln461">          &amp;&amp; debug_breakpoint_name[1] == KS_EXTRA</a>
<a name="ln462">          &amp;&amp; debug_breakpoint_name[2] == (int)KE_SNR) {</a>
<a name="ln463">        p = (char_u *)&quot;&lt;SNR&gt;&quot;;</a>
<a name="ln464">      } else {</a>
<a name="ln465">        p = (char_u *)&quot;&quot;;</a>
<a name="ln466">      }</a>
<a name="ln467">      smsg(_(&quot;Breakpoint in \&quot;%s%s\&quot; line %&quot; PRId64),</a>
<a name="ln468">           p,</a>
<a name="ln469">           debug_breakpoint_name + (*p == NUL ? 0 : 3),</a>
<a name="ln470">           (int64_t)debug_breakpoint_lnum);</a>
<a name="ln471">      debug_breakpoint_name = NULL;</a>
<a name="ln472">      do_debug(eap-&gt;cmd);</a>
<a name="ln473">    } else {</a>
<a name="ln474">      debug_skipped = true;</a>
<a name="ln475">      debug_skipped_name = debug_breakpoint_name;</a>
<a name="ln476">      debug_breakpoint_name = NULL;</a>
<a name="ln477">    }</a>
<a name="ln478">  } else if (ex_nesting_level &lt;= debug_break_level) {</a>
<a name="ln479">    if (!eap-&gt;skip) {</a>
<a name="ln480">      do_debug(eap-&gt;cmd);</a>
<a name="ln481">    } else {</a>
<a name="ln482">      debug_skipped = true;</a>
<a name="ln483">      debug_skipped_name = NULL;</a>
<a name="ln484">    }</a>
<a name="ln485">  }</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">/// Go to debug mode if skipped by dbg_check_breakpoint() because eap-&gt;skip was</a>
<a name="ln489">/// set.</a>
<a name="ln490">///</a>
<a name="ln491">/// @return true when the debug mode is entered this time.</a>
<a name="ln492">bool dbg_check_skipped(exarg_T *eap)</a>
<a name="ln493">{</a>
<a name="ln494">  int prev_got_int;</a>
<a name="ln495"> </a>
<a name="ln496">  if (debug_skipped) {</a>
<a name="ln497">    // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln498">    // interruption cause flushing the input buffer.</a>
<a name="ln499">    prev_got_int = got_int;</a>
<a name="ln500">    got_int = false;</a>
<a name="ln501">    debug_breakpoint_name = debug_skipped_name;</a>
<a name="ln502">    // eap-&gt;skip is true</a>
<a name="ln503">    eap-&gt;skip = false;</a>
<a name="ln504">    dbg_check_breakpoint(eap);</a>
<a name="ln505">    eap-&gt;skip = true;</a>
<a name="ln506">    got_int |= prev_got_int;</a>
<a name="ln507">    return true;</a>
<a name="ln508">  }</a>
<a name="ln509">  return false;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/// The list of breakpoints: dbg_breakp.</a>
<a name="ln513">/// This is a grow-array of structs.</a>
<a name="ln514">struct debuggy {</a>
<a name="ln515">  int dbg_nr;                   ///&lt; breakpoint number</a>
<a name="ln516">  int dbg_type;                 ///&lt; DBG_FUNC or DBG_FILE</a>
<a name="ln517">  char_u *dbg_name;             ///&lt; function or file name</a>
<a name="ln518">  regprog_T *dbg_prog;          ///&lt; regexp program</a>
<a name="ln519">  linenr_T dbg_lnum;            ///&lt; line number in function or file</a>
<a name="ln520">  int dbg_forceit;              ///&lt; ! used</a>
<a name="ln521">};</a>
<a name="ln522"> </a>
<a name="ln523">static garray_T dbg_breakp = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln524">#define BREAKP(idx)             (((struct debuggy *)dbg_breakp.ga_data)[idx])</a>
<a name="ln525">#define DEBUGGY(gap, idx)       (((struct debuggy *)gap-&gt;ga_data)[idx])</a>
<a name="ln526">static int last_breakp = 0;     // nr of last defined breakpoint</a>
<a name="ln527"> </a>
<a name="ln528">// Profiling uses file and func names similar to breakpoints.</a>
<a name="ln529">static garray_T prof_ga = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln530">#define DBG_FUNC        1</a>
<a name="ln531">#define DBG_FILE        2</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">/// Parse the arguments of &quot;:profile&quot;, &quot;:breakadd&quot; or &quot;:breakdel&quot; and put them</a>
<a name="ln535">/// in the entry just after the last one in dbg_breakp.  Note that &quot;dbg_name&quot;</a>
<a name="ln536">/// is allocated.</a>
<a name="ln537">/// Returns FAIL for failure.</a>
<a name="ln538">///</a>
<a name="ln539">/// @param arg</a>
<a name="ln540">/// @param gap  either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln541">static int dbg_parsearg(char_u *arg, garray_T *gap)</a>
<a name="ln542">{</a>
<a name="ln543">  char_u      *p = arg;</a>
<a name="ln544">  char_u      *q;</a>
<a name="ln545">  struct debuggy *bp;</a>
<a name="ln546">  bool here = false;</a>
<a name="ln547"> </a>
<a name="ln548">  ga_grow(gap, 1);</a>
<a name="ln549"> </a>
<a name="ln550">  bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln551"> </a>
<a name="ln552">  // Find &quot;func&quot; or &quot;file&quot;.</a>
<a name="ln553">  if (STRNCMP(p, &quot;func&quot;, 4) == 0) {</a>
<a name="ln554">    bp-&gt;dbg_type = DBG_FUNC;</a>
<a name="ln555">  } else if (STRNCMP(p, &quot;file&quot;, 4) == 0) {</a>
<a name="ln556">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln557">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;here&quot;, 4) == 0) {</a>
<a name="ln558">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln559">      EMSG(_(e_noname));</a>
<a name="ln560">      return FAIL;</a>
<a name="ln561">    }</a>
<a name="ln562">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln563">    here = true;</a>
<a name="ln564">  } else {</a>
<a name="ln565">    EMSG2(_(e_invarg2), p);</a>
<a name="ln566">    return FAIL;</a>
<a name="ln567">  }</a>
<a name="ln568">  p = skipwhite(p + 4);</a>
<a name="ln569"> </a>
<a name="ln570">  // Find optional line number.</a>
<a name="ln571">  if (here) {</a>
<a name="ln572">    bp-&gt;dbg_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln573">  } else if (gap != &amp;prof_ga &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln574">    bp-&gt;dbg_lnum = getdigits_long(&amp;p, true, 0);</a>
<a name="ln575">    p = skipwhite(p);</a>
<a name="ln576">  } else {</a>
<a name="ln577">    bp-&gt;dbg_lnum = 0;</a>
<a name="ln578">  }</a>
<a name="ln579"> </a>
<a name="ln580">  // Find the function or file name.  Don't accept a function name with ().</a>
<a name="ln581">  if ((!here &amp;&amp; *p == NUL)</a>
<a name="ln582">      || (here &amp;&amp; *p != NUL)</a>
<a name="ln583">      || (bp-&gt;dbg_type == DBG_FUNC &amp;&amp; strstr((char *)p, &quot;()&quot;) != NULL)) {</a>
<a name="ln584">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln585">    return FAIL;</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  if (bp-&gt;dbg_type == DBG_FUNC) {</a>
<a name="ln589">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln590">  } else if (here) {</a>
<a name="ln591">    bp-&gt;dbg_name = vim_strsave(curbuf-&gt;b_ffname);</a>
<a name="ln592">  } else {</a>
<a name="ln593">    // Expand the file name in the same way as do_source().  This means</a>
<a name="ln594">    // doing it twice, so that $DIR/file gets expanded when $DIR is</a>
<a name="ln595">    // &quot;~/dir&quot;.</a>
<a name="ln596">    q = expand_env_save(p);</a>
<a name="ln597">    if (q == NULL) {</a>
<a name="ln598">      return FAIL;</a>
<a name="ln599">    }</a>
<a name="ln600">    p = expand_env_save(q);</a>
<a name="ln601">    xfree(q);</a>
<a name="ln602">    if (p == NULL) {</a>
<a name="ln603">      return FAIL;</a>
<a name="ln604">    }</a>
<a name="ln605">    if (*p != '*') {</a>
<a name="ln606">      bp-&gt;dbg_name = (char_u *)fix_fname((char *)p);</a>
<a name="ln607">      xfree(p);</a>
<a name="ln608">    } else {</a>
<a name="ln609">      bp-&gt;dbg_name = p;</a>
<a name="ln610">    }</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  if (bp-&gt;dbg_name == NULL) {</a>
<a name="ln614">    return FAIL;</a>
<a name="ln615">  }</a>
<a name="ln616">  return OK;</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">/// &quot;:breakadd&quot;.  Also used for &quot;:profile&quot;.</a>
<a name="ln620">void ex_breakadd(exarg_T *eap)</a>
<a name="ln621">{</a>
<a name="ln622">  struct debuggy *bp;</a>
<a name="ln623">  char_u      *pat;</a>
<a name="ln624">  garray_T    *gap;</a>
<a name="ln625"> </a>
<a name="ln626">  gap = &amp;dbg_breakp;</a>
<a name="ln627">  if (eap-&gt;cmdidx == CMD_profile) {</a>
<a name="ln628">    gap = &amp;prof_ga;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  if (dbg_parsearg(eap-&gt;arg, gap) == OK) {</a>
<a name="ln632">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln633">    bp-&gt;dbg_forceit = eap-&gt;forceit;</a>
<a name="ln634"> </a>
<a name="ln635">    pat = file_pat_to_reg_pat(bp-&gt;dbg_name, NULL, NULL, false);</a>
<a name="ln636">    if (pat != NULL) {</a>
<a name="ln637">      bp-&gt;dbg_prog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln638">      xfree(pat);</a>
<a name="ln639">    }</a>
<a name="ln640">    if (pat == NULL || bp-&gt;dbg_prog == NULL) {</a>
<a name="ln641">      xfree(bp-&gt;dbg_name);</a>
<a name="ln642">    } else {</a>
<a name="ln643">      if (bp-&gt;dbg_lnum == 0) {           // default line number is 1</a>
<a name="ln644">        bp-&gt;dbg_lnum = 1;</a>
<a name="ln645">      }</a>
<a name="ln646">      if (eap-&gt;cmdidx != CMD_profile) {</a>
<a name="ln647">        DEBUGGY(gap, gap-&gt;ga_len).dbg_nr = ++last_breakp;</a>
<a name="ln648">        debug_tick++;</a>
<a name="ln649">      }</a>
<a name="ln650">      gap-&gt;ga_len++;</a>
<a name="ln651">    }</a>
<a name="ln652">  }</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">/// &quot;:debuggreedy&quot;.</a>
<a name="ln656">void ex_debuggreedy(exarg_T *eap)</a>
<a name="ln657">{</a>
<a name="ln658">  if (eap-&gt;addr_count == 0 || eap-&gt;line2 != 0) {</a>
<a name="ln659">    debug_greedy = true;</a>
<a name="ln660">  } else {</a>
<a name="ln661">    debug_greedy = false;</a>
<a name="ln662">  }</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/// &quot;:breakdel&quot; and &quot;:profdel&quot;.</a>
<a name="ln666">void ex_breakdel(exarg_T *eap)</a>
<a name="ln667">{</a>
<a name="ln668">  struct debuggy *bp, *bpi;</a>
<a name="ln669">  int nr;</a>
<a name="ln670">  int todel = -1;</a>
<a name="ln671">  bool del_all = false;</a>
<a name="ln672">  linenr_T best_lnum = 0;</a>
<a name="ln673">  garray_T    *gap;</a>
<a name="ln674"> </a>
<a name="ln675">  gap = &amp;dbg_breakp;</a>
<a name="ln676">  if (eap-&gt;cmdidx == CMD_profdel) {</a>
<a name="ln677">    gap = &amp;prof_ga;</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  if (ascii_isdigit(*eap-&gt;arg)) {</a>
<a name="ln681">    // &quot;:breakdel {nr}&quot;</a>
<a name="ln682">    nr = atoi((char *)eap-&gt;arg);</a>
<a name="ln683">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln684">      if (DEBUGGY(gap, i).dbg_nr == nr) {</a>
<a name="ln685">        todel = i;</a>
<a name="ln686">        break;</a>
<a name="ln687">      }</a>
<a name="ln688">    }</a>
<a name="ln689">  } else if (*eap-&gt;arg == '*') {</a>
<a name="ln690">    todel = 0;</a>
<a name="ln691">    del_all = true;</a>
<a name="ln692">  } else {</a>
<a name="ln693">    // &quot;:breakdel {func|file} [lnum] {name}&quot;</a>
<a name="ln694">    if (dbg_parsearg(eap-&gt;arg, gap) == FAIL) {</a>
<a name="ln695">      return;</a>
<a name="ln696">    }</a>
<a name="ln697">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln698">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln699">      bpi = &amp;DEBUGGY(gap, i);</a>
<a name="ln700">      if (bp-&gt;dbg_type == bpi-&gt;dbg_type</a>
<a name="ln701">          &amp;&amp; STRCMP(bp-&gt;dbg_name, bpi-&gt;dbg_name) == 0</a>
<a name="ln702">          &amp;&amp; (bp-&gt;dbg_lnum == bpi-&gt;dbg_lnum</a>
<a name="ln703">              || (bp-&gt;dbg_lnum == 0</a>
<a name="ln704">                  &amp;&amp; (best_lnum == 0</a>
<a name="ln705">                      || bpi-&gt;dbg_lnum &lt; best_lnum)))) {</a>
<a name="ln706">        todel = i;</a>
<a name="ln707">        best_lnum = bpi-&gt;dbg_lnum;</a>
<a name="ln708">      }</a>
<a name="ln709">    }</a>
<a name="ln710">    xfree(bp-&gt;dbg_name);</a>
<a name="ln711">  }</a>
<a name="ln712"> </a>
<a name="ln713">  if (todel &lt; 0) {</a>
<a name="ln714">    EMSG2(_(&quot;E161: Breakpoint not found: %s&quot;), eap-&gt;arg);</a>
<a name="ln715">  } else {</a>
<a name="ln716">    while (!GA_EMPTY(gap)) {</a>
<a name="ln717">      xfree(DEBUGGY(gap, todel).dbg_name);</a>
<a name="ln718">      vim_regfree(DEBUGGY(gap, todel).dbg_prog);</a>
<a name="ln719">      gap-&gt;ga_len--;</a>
<a name="ln720">      if (todel &lt; gap-&gt;ga_len) {</a>
<a name="ln721">        memmove(&amp;DEBUGGY(gap, todel), &amp;DEBUGGY(gap, todel + 1),</a>
<a name="ln722">                (size_t)(gap-&gt;ga_len - todel) * sizeof(struct debuggy));</a>
<a name="ln723">      }</a>
<a name="ln724">      if (eap-&gt;cmdidx == CMD_breakdel) {</a>
<a name="ln725">        debug_tick++;</a>
<a name="ln726">      }</a>
<a name="ln727">      if (!del_all) {</a>
<a name="ln728">        break;</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    // If all breakpoints were removed clear the array.</a>
<a name="ln733">    if (GA_EMPTY(gap)) {</a>
<a name="ln734">      ga_clear(gap);</a>
<a name="ln735">    }</a>
<a name="ln736">  }</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">/// &quot;:breaklist&quot;.</a>
<a name="ln740">void ex_breaklist(exarg_T *eap)</a>
<a name="ln741">{</a>
<a name="ln742">  struct debuggy *bp;</a>
<a name="ln743"> </a>
<a name="ln744">  if (GA_EMPTY(&amp;dbg_breakp)) {</a>
<a name="ln745">    MSG(_(&quot;No breakpoints defined&quot;));</a>
<a name="ln746">  } else {</a>
<a name="ln747">    for (int i = 0; i &lt; dbg_breakp.ga_len; i++) {</a>
<a name="ln748">      bp = &amp;BREAKP(i);</a>
<a name="ln749">      if (bp-&gt;dbg_type == DBG_FILE) {</a>
<a name="ln750">        home_replace(NULL, bp-&gt;dbg_name, NameBuff, MAXPATHL, true);</a>
<a name="ln751">      }</a>
<a name="ln752">      smsg(_(&quot;%3d  %s %s  line %&quot; PRId64),</a>
<a name="ln753">           bp-&gt;dbg_nr,</a>
<a name="ln754">           bp-&gt;dbg_type == DBG_FUNC ? &quot;func&quot; : &quot;file&quot;,</a>
<a name="ln755">           bp-&gt;dbg_type == DBG_FUNC ? bp-&gt;dbg_name : NameBuff,</a>
<a name="ln756">           (int64_t)bp-&gt;dbg_lnum);</a>
<a name="ln757">    }</a>
<a name="ln758">  }</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/// Find a breakpoint for a function or sourced file.</a>
<a name="ln762">/// Returns line number at which to break; zero when no matching breakpoint.</a>
<a name="ln763">linenr_T</a>
<a name="ln764">dbg_find_breakpoint(</a>
<a name="ln765">    bool file,             // true for a file, false for a function</a>
<a name="ln766">    char_u *fname,         // file or function name</a>
<a name="ln767">    linenr_T after         // after this line number</a>
<a name="ln768">)</a>
<a name="ln769">{</a>
<a name="ln770">  return debuggy_find(file, fname, after, &amp;dbg_breakp, NULL);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/// @param file     true for a file, false for a function</a>
<a name="ln774">/// @param fname    file or function name</a>
<a name="ln775">/// @param fp[out]  forceit</a>
<a name="ln776">///</a>
<a name="ln777">/// @returns true if profiling is on for a function or sourced file.</a>
<a name="ln778">bool has_profiling(bool file, char_u *fname, bool *fp)</a>
<a name="ln779">{</a>
<a name="ln780">  return debuggy_find(file, fname, (linenr_T)0, &amp;prof_ga, fp)</a>
<a name="ln781">         != (linenr_T)0;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">/// Common code for dbg_find_breakpoint() and has_profiling().</a>
<a name="ln785">static linenr_T</a>
<a name="ln786">debuggy_find(</a>
<a name="ln787">    bool file,            // true for a file, false for a function</a>
<a name="ln788">    char_u *fname,        // file or function name</a>
<a name="ln789">    linenr_T after,       // after this line number</a>
<a name="ln790">    garray_T *gap,        // either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln791">    bool *fp              // if not NULL: return forceit</a>
<a name="ln792">)</a>
<a name="ln793">{</a>
<a name="ln794">  struct debuggy *bp;</a>
<a name="ln795">  linenr_T lnum = 0;</a>
<a name="ln796">  char_u      *name = fname;</a>
<a name="ln797">  int prev_got_int;</a>
<a name="ln798"> </a>
<a name="ln799">  // Return quickly when there are no breakpoints.</a>
<a name="ln800">  if (GA_EMPTY(gap)) {</a>
<a name="ln801">    return (linenr_T)0;</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  // Replace K_SNR in function name with &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln805">  if (!file &amp;&amp; fname[0] == K_SPECIAL) {</a>
<a name="ln806">    name = xmalloc(STRLEN(fname) + 3);</a>
<a name="ln807">    STRCPY(name, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln808">    STRCPY(name + 5, fname + 3);</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln812">    // Skip entries that are not useful or are for a line that is beyond</a>
<a name="ln813">    // an already found breakpoint.</a>
<a name="ln814">    bp = &amp;DEBUGGY(gap, i);</a>
<a name="ln815">    if ((bp-&gt;dbg_type == DBG_FILE) == file</a>
<a name="ln816">        &amp;&amp; (gap == &amp;prof_ga</a>
<a name="ln817">            || (bp-&gt;dbg_lnum &gt; after &amp;&amp; (lnum == 0 || bp-&gt;dbg_lnum &lt; lnum)))) {</a>
<a name="ln818">      // Save the value of got_int and reset it.  We don't want a</a>
<a name="ln819">      // previous interruption cancel matching, only hitting CTRL-C</a>
<a name="ln820">      // while matching should abort it.</a>
<a name="ln821">      prev_got_int = got_int;</a>
<a name="ln822">      got_int = false;</a>
<a name="ln823">      if (vim_regexec_prog(&amp;bp-&gt;dbg_prog, false, name, (colnr_T)0)) {</a>
<a name="ln824">        lnum = bp-&gt;dbg_lnum;</a>
<a name="ln825">        if (fp != NULL) {</a>
<a name="ln826">          *fp = bp-&gt;dbg_forceit;</a>
<a name="ln827">        }</a>
<a name="ln828">      }</a>
<a name="ln829">      got_int |= prev_got_int;</a>
<a name="ln830">    }</a>
<a name="ln831">  }</a>
<a name="ln832">  if (name != fname) {</a>
<a name="ln833">    xfree(name);</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  return lnum;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">/// Called when a breakpoint was encountered.</a>
<a name="ln840">void dbg_breakpoint(char_u *name, linenr_T lnum)</a>
<a name="ln841">{</a>
<a name="ln842">  // We need to check if this line is actually executed in do_one_cmd()</a>
<a name="ln843">  debug_breakpoint_name = name;</a>
<a name="ln844">  debug_breakpoint_lnum = lnum;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">static char_u   *profile_fname = NULL;</a>
<a name="ln848"> </a>
<a name="ln849">/// &quot;:profile cmd args&quot;</a>
<a name="ln850">void ex_profile(exarg_T *eap)</a>
<a name="ln851">{</a>
<a name="ln852">  static proftime_T pause_time;</a>
<a name="ln853"> </a>
<a name="ln854">  char_u      *e;</a>
<a name="ln855">  int len;</a>
<a name="ln856"> </a>
<a name="ln857">  e = skiptowhite(eap-&gt;arg);</a>
<a name="ln858">  len = (int)(e - eap-&gt;arg);</a>
<a name="ln859">  e = skipwhite(e);</a>
<a name="ln860"> </a>
<a name="ln861">  if (len == 5 &amp;&amp; STRNCMP(eap-&gt;arg, &quot;start&quot;, 5) == 0 &amp;&amp; *e != NUL) {</a>
<a name="ln862">    xfree(profile_fname);</a>
<a name="ln863">    profile_fname = expand_env_save_opt(e, true);</a>
<a name="ln864">    do_profiling = PROF_YES;</a>
<a name="ln865">    profile_set_wait(profile_zero());</a>
<a name="ln866">    set_vim_var_nr(VV_PROFILING, 1L);</a>
<a name="ln867">  } else if (do_profiling == PROF_NONE) {</a>
<a name="ln868">    EMSG(_(&quot;E750: First use \&quot;:profile start {fname}\&quot;&quot;));</a>
<a name="ln869">  } else if (STRCMP(eap-&gt;arg, &quot;stop&quot;) == 0) {</a>
<a name="ln870">    profile_dump();</a>
<a name="ln871">    do_profiling = PROF_NONE;</a>
<a name="ln872">    set_vim_var_nr(VV_PROFILING, 0L);</a>
<a name="ln873">    profile_reset();</a>
<a name="ln874">  } else if (STRCMP(eap-&gt;arg, &quot;pause&quot;) == 0) {</a>
<a name="ln875">    if (do_profiling == PROF_YES) {</a>
<a name="ln876">      pause_time = profile_start();</a>
<a name="ln877">    }</a>
<a name="ln878">    do_profiling = PROF_PAUSED;</a>
<a name="ln879">  } else if (STRCMP(eap-&gt;arg, &quot;continue&quot;) == 0) {</a>
<a name="ln880">    if (do_profiling == PROF_PAUSED) {</a>
<a name="ln881">      pause_time = profile_end(pause_time);</a>
<a name="ln882">      profile_set_wait(profile_add(profile_get_wait(), pause_time));</a>
<a name="ln883">    }</a>
<a name="ln884">    do_profiling = PROF_YES;</a>
<a name="ln885">  } else if (STRCMP(eap-&gt;arg, &quot;dump&quot;) == 0) {</a>
<a name="ln886">    profile_dump();</a>
<a name="ln887">  } else {</a>
<a name="ln888">    // The rest is similar to &quot;:breakadd&quot;.</a>
<a name="ln889">    ex_breakadd(eap);</a>
<a name="ln890">  }</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">void ex_python(exarg_T *eap)</a>
<a name="ln894">{</a>
<a name="ln895">  script_host_execute(&quot;python&quot;, eap);</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">void ex_pyfile(exarg_T *eap)</a>
<a name="ln899">{</a>
<a name="ln900">  script_host_execute_file(&quot;python&quot;, eap);</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void ex_pydo(exarg_T *eap)</a>
<a name="ln904">{</a>
<a name="ln905">  script_host_do_range(&quot;python&quot;, eap);</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">void ex_ruby(exarg_T *eap)</a>
<a name="ln909">{</a>
<a name="ln910">  script_host_execute(&quot;ruby&quot;, eap);</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">void ex_rubyfile(exarg_T *eap)</a>
<a name="ln914">{</a>
<a name="ln915">  script_host_execute_file(&quot;ruby&quot;, eap);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">void ex_rubydo(exarg_T *eap)</a>
<a name="ln919">{</a>
<a name="ln920">  script_host_do_range(&quot;ruby&quot;, eap);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">void ex_python3(exarg_T *eap)</a>
<a name="ln924">{</a>
<a name="ln925">  script_host_execute(&quot;python3&quot;, eap);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">void ex_py3file(exarg_T *eap)</a>
<a name="ln929">{</a>
<a name="ln930">  script_host_execute_file(&quot;python3&quot;, eap);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">void ex_pydo3(exarg_T *eap)</a>
<a name="ln934">{</a>
<a name="ln935">  script_host_do_range(&quot;python3&quot;, eap);</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">void ex_perl(exarg_T *eap)</a>
<a name="ln939">{</a>
<a name="ln940">  script_host_execute(&quot;perl&quot;, eap);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">void ex_perlfile(exarg_T *eap)</a>
<a name="ln944">{</a>
<a name="ln945">  script_host_execute_file(&quot;perl&quot;, eap);</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">void ex_perldo(exarg_T *eap)</a>
<a name="ln949">{</a>
<a name="ln950">  script_host_do_range(&quot;perl&quot;, eap);</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">// Command line expansion for :profile.</a>
<a name="ln954">static enum {</a>
<a name="ln955">  PEXP_SUBCMD,          ///&lt; expand :profile sub-commands</a>
<a name="ln956">  PEXP_FUNC             ///&lt; expand :profile func {funcname}</a>
<a name="ln957">} pexpand_what;</a>
<a name="ln958"> </a>
<a name="ln959">static char *pexpand_cmds[] = {</a>
<a name="ln960">  &quot;continue&quot;,</a>
<a name="ln961">  &quot;dump&quot;,</a>
<a name="ln962">  &quot;file&quot;,</a>
<a name="ln963">  &quot;func&quot;,</a>
<a name="ln964">  &quot;pause&quot;,</a>
<a name="ln965">  &quot;start&quot;,</a>
<a name="ln966">  &quot;stop&quot;,</a>
<a name="ln967">  NULL</a>
<a name="ln968">};</a>
<a name="ln969"> </a>
<a name="ln970">/// Function given to ExpandGeneric() to obtain the profile command</a>
<a name="ln971">/// specific expansion.</a>
<a name="ln972">char_u *get_profile_name(expand_T *xp, int idx)</a>
<a name="ln973">{</a>
<a name="ln974">  switch (pexpand_what) {</a>
<a name="ln975">  case PEXP_SUBCMD:</a>
<a name="ln976">    return (char_u *)pexpand_cmds[idx];</a>
<a name="ln977">  // case PEXP_FUNC: TODO</a>
<a name="ln978">  default:</a>
<a name="ln979">    return NULL;</a>
<a name="ln980">  }</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">/// Handle command line completion for :profile command.</a>
<a name="ln984">void set_context_in_profile_cmd(expand_T *xp, const char *arg)</a>
<a name="ln985">{</a>
<a name="ln986">  // Default: expand subcommands.</a>
<a name="ln987">  xp-&gt;xp_context = EXPAND_PROFILE;</a>
<a name="ln988">  pexpand_what = PEXP_SUBCMD;</a>
<a name="ln989">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln990"> </a>
<a name="ln991">  char_u *const end_subcmd = skiptowhite((const char_u *)arg);</a>
<a name="ln992">  if (*end_subcmd == NUL) {</a>
<a name="ln993">    return;</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  if ((const char *)end_subcmd - arg == 5 &amp;&amp; strncmp(arg, &quot;start&quot;, 5) == 0) {</a>
<a name="ln997">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln998">    xp-&gt;xp_pattern = skipwhite((const char_u *)end_subcmd);</a>
<a name="ln999">    return;</a>
<a name="ln1000">  }</a>
<a name="ln1001"> </a>
<a name="ln1002">  // TODO(tarruda): expand function names after &quot;func&quot;</a>
<a name="ln1003">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">/// Dump the profiling info.</a>
<a name="ln1007">void profile_dump(void)</a>
<a name="ln1008">{</a>
<a name="ln1009">  FILE        *fd;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (profile_fname != NULL) {</a>
<a name="ln1012">    fd = os_fopen((char *)profile_fname, &quot;w&quot;);</a>
<a name="ln1013">    if (fd == NULL) {</a>
<a name="ln1014">      EMSG2(_(e_notopen), profile_fname);</a>
<a name="ln1015">    } else {</a>
<a name="ln1016">      script_dump_profile(fd);</a>
<a name="ln1017">      func_dump_profile(fd);</a>
<a name="ln1018">      fclose(fd);</a>
<a name="ln1019">    }</a>
<a name="ln1020">  }</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">/// Reset all profiling information.</a>
<a name="ln1024">static void profile_reset(void)</a>
<a name="ln1025">{</a>
<a name="ln1026">  // Reset sourced files.</a>
<a name="ln1027">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1028">    scriptitem_T *si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1029">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1030">      si-&gt;sn_prof_on      = false;</a>
<a name="ln1031">      si-&gt;sn_pr_force     = false;</a>
<a name="ln1032">      si-&gt;sn_pr_child     = profile_zero();</a>
<a name="ln1033">      si-&gt;sn_pr_nest      = 0;</a>
<a name="ln1034">      si-&gt;sn_pr_count     = 0;</a>
<a name="ln1035">      si-&gt;sn_pr_total     = profile_zero();</a>
<a name="ln1036">      si-&gt;sn_pr_self      = profile_zero();</a>
<a name="ln1037">      si-&gt;sn_pr_start     = profile_zero();</a>
<a name="ln1038">      si-&gt;sn_pr_children  = profile_zero();</a>
<a name="ln1039">      ga_clear(&amp;si-&gt;sn_prl_ga);</a>
<a name="ln1040">      si-&gt;sn_prl_start    = profile_zero();</a>
<a name="ln1041">      si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln1042">      si-&gt;sn_prl_wait     = profile_zero();</a>
<a name="ln1043">      si-&gt;sn_prl_idx      = -1;</a>
<a name="ln1044">      si-&gt;sn_prl_execed   = 0;</a>
<a name="ln1045">    }</a>
<a name="ln1046">  }</a>
<a name="ln1047"> </a>
<a name="ln1048">  // Reset functions.</a>
<a name="ln1049">  size_t      n  = func_hashtab.ht_used;</a>
<a name="ln1050">  hashitem_T *hi = func_hashtab.ht_array;</a>
<a name="ln1051"> </a>
<a name="ln1052">  for (; n &gt; (size_t)0; hi++) {</a>
<a name="ln1053">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1054">      n--;</a>
<a name="ln1055">      ufunc_T *uf = HI2UF(hi);</a>
<a name="ln1056">      if (uf-&gt;uf_prof_initialized) {</a>
<a name="ln1057">        uf-&gt;uf_profiling    = 0;</a>
<a name="ln1058">        uf-&gt;uf_tm_count     = 0;</a>
<a name="ln1059">        uf-&gt;uf_tm_total     = profile_zero();</a>
<a name="ln1060">        uf-&gt;uf_tm_self      = profile_zero();</a>
<a name="ln1061">        uf-&gt;uf_tm_children  = profile_zero();</a>
<a name="ln1062"> </a>
<a name="ln1063">        for (int i = 0; i &lt; uf-&gt;uf_lines.ga_len; i++) {</a>
<a name="ln1064">          uf-&gt;uf_tml_count[i] = 0;</a>
<a name="ln1065">          uf-&gt;uf_tml_total[i] = uf-&gt;uf_tml_self[i] = 0;</a>
<a name="ln1066">        }</a>
<a name="ln1067"> </a>
<a name="ln1068">        uf-&gt;uf_tml_start    = profile_zero();</a>
<a name="ln1069">        uf-&gt;uf_tml_children = profile_zero();</a>
<a name="ln1070">        uf-&gt;uf_tml_wait     = profile_zero();</a>
<a name="ln1071">        uf-&gt;uf_tml_idx      = -1;</a>
<a name="ln1072">        uf-&gt;uf_tml_execed   = 0;</a>
<a name="ln1073">      }</a>
<a name="ln1074">    }</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  XFREE_CLEAR(profile_fname);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">/// Start profiling a script.</a>
<a name="ln1081">static void profile_init(scriptitem_T *si)</a>
<a name="ln1082">{</a>
<a name="ln1083">  si-&gt;sn_pr_count = 0;</a>
<a name="ln1084">  si-&gt;sn_pr_total = profile_zero();</a>
<a name="ln1085">  si-&gt;sn_pr_self = profile_zero();</a>
<a name="ln1086"> </a>
<a name="ln1087">  ga_init(&amp;si-&gt;sn_prl_ga, sizeof(sn_prl_T), 100);</a>
<a name="ln1088">  si-&gt;sn_prl_idx = -1;</a>
<a name="ln1089">  si-&gt;sn_prof_on = true;</a>
<a name="ln1090">  si-&gt;sn_pr_nest = 0;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">/// Save time when starting to invoke another script or function.</a>
<a name="ln1094">void script_prof_save(</a>
<a name="ln1095">    proftime_T  *tm             // place to store wait time</a>
<a name="ln1096">)</a>
<a name="ln1097">{</a>
<a name="ln1098">  scriptitem_T    *si;</a>
<a name="ln1099"> </a>
<a name="ln1100">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1101">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1102">    if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_pr_nest++ == 0) {</a>
<a name="ln1103">      si-&gt;sn_pr_child = profile_start();</a>
<a name="ln1104">    }</a>
<a name="ln1105">  }</a>
<a name="ln1106">  *tm = profile_get_wait();</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">/// Count time spent in children after invoking another script or function.</a>
<a name="ln1110">void script_prof_restore(proftime_T *tm)</a>
<a name="ln1111">{</a>
<a name="ln1112">  scriptitem_T    *si;</a>
<a name="ln1113"> </a>
<a name="ln1114">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1115">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1116">    if (si-&gt;sn_prof_on &amp;&amp; --si-&gt;sn_pr_nest == 0) {</a>
<a name="ln1117">      si-&gt;sn_pr_child = profile_end(si-&gt;sn_pr_child);</a>
<a name="ln1118">      // don't count wait time</a>
<a name="ln1119">      si-&gt;sn_pr_child = profile_sub_wait(*tm, si-&gt;sn_pr_child);</a>
<a name="ln1120">      si-&gt;sn_pr_children = profile_add(si-&gt;sn_pr_children, si-&gt;sn_pr_child);</a>
<a name="ln1121">      si-&gt;sn_prl_children = profile_add(si-&gt;sn_prl_children, si-&gt;sn_pr_child);</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static proftime_T inchar_time;</a>
<a name="ln1127"> </a>
<a name="ln1128">/// Called when starting to wait for the user to type a character.</a>
<a name="ln1129">void prof_inchar_enter(void)</a>
<a name="ln1130">{</a>
<a name="ln1131">  inchar_time = profile_start();</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">/// Called when finished waiting for the user to type a character.</a>
<a name="ln1135">void prof_inchar_exit(void)</a>
<a name="ln1136">{</a>
<a name="ln1137">  inchar_time = profile_end(inchar_time);</a>
<a name="ln1138">  profile_set_wait(profile_add(profile_get_wait(), inchar_time));</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">/// Dump the profiling results for all scripts in file &quot;fd&quot;.</a>
<a name="ln1142">static void script_dump_profile(FILE *fd)</a>
<a name="ln1143">{</a>
<a name="ln1144">  scriptitem_T    *si;</a>
<a name="ln1145">  FILE            *sfd;</a>
<a name="ln1146">  sn_prl_T        *pp;</a>
<a name="ln1147"> </a>
<a name="ln1148">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1149">    si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1150">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1151">      fprintf(fd, &quot;SCRIPT  %s\n&quot;, si-&gt;sn_name);</a>
<a name="ln1152">      if (si-&gt;sn_pr_count == 1) {</a>
<a name="ln1153">        fprintf(fd, &quot;Sourced 1 time\n&quot;);</a>
<a name="ln1154">      } else {</a>
<a name="ln1155">        fprintf(fd, &quot;Sourced %d times\n&quot;, si-&gt;sn_pr_count);</a>
<a name="ln1156">      }</a>
<a name="ln1157">      fprintf(fd, &quot;Total time: %s\n&quot;, profile_msg(si-&gt;sn_pr_total));</a>
<a name="ln1158">      fprintf(fd, &quot; Self time: %s\n&quot;, profile_msg(si-&gt;sn_pr_self));</a>
<a name="ln1159">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1160">      fprintf(fd, &quot;count  total (s)   self (s)\n&quot;);</a>
<a name="ln1161"> </a>
<a name="ln1162">      sfd = os_fopen((char *)si-&gt;sn_name, &quot;r&quot;);</a>
<a name="ln1163">      if (sfd == NULL) {</a>
<a name="ln1164">        fprintf(fd, &quot;Cannot open file!\n&quot;);</a>
<a name="ln1165">      } else {</a>
<a name="ln1166">        // Keep going till the end of file, so that trailing</a>
<a name="ln1167">        // continuation lines are listed.</a>
<a name="ln1168">        for (int i = 0; ; i++) {</a>
<a name="ln1169">          if (vim_fgets(IObuff, IOSIZE, sfd)) {</a>
<a name="ln1170">            break;</a>
<a name="ln1171">          }</a>
<a name="ln1172">          // When a line has been truncated, append NL, taking care</a>
<a name="ln1173">          // of multi-byte characters .</a>
<a name="ln1174">          if (IObuff[IOSIZE - 2] != NUL &amp;&amp; IObuff[IOSIZE - 2] != NL) {</a>
<a name="ln1175">            int n = IOSIZE - 2;</a>
<a name="ln1176"> </a>
<a name="ln1177">            // Move to the first byte of this char.</a>
<a name="ln1178">            // utf_head_off() doesn't work, because it checks</a>
<a name="ln1179">            // for a truncated character.</a>
<a name="ln1180">            while (n &gt; 0 &amp;&amp; (IObuff[n] &amp; 0xc0) == 0x80) {</a>
<a name="ln1181">              n--;</a>
<a name="ln1182">            }</a>
<a name="ln1183"> </a>
<a name="ln1184">            IObuff[n] = NL;</a>
<a name="ln1185">            IObuff[n + 1] = NUL;</a>
<a name="ln1186">          }</a>
<a name="ln1187">          if (i &lt; si-&gt;sn_prl_ga.ga_len</a>
<a name="ln1188">              &amp;&amp; (pp = &amp;PRL_ITEM(si, i))-&gt;snp_count &gt; 0) {</a>
<a name="ln1189">            fprintf(fd, &quot;%5d &quot;, pp-&gt;snp_count);</a>
<a name="ln1190">            if (profile_equal(pp-&gt;sn_prl_total, pp-&gt;sn_prl_self)) {</a>
<a name="ln1191">              fprintf(fd, &quot;           &quot;);</a>
<a name="ln1192">            } else {</a>
<a name="ln1193">              fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_total));</a>
<a name="ln1194">            }</a>
<a name="ln1195">            fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_self));</a>
<a name="ln1196">          } else {</a>
<a name="ln1197">            fprintf(fd, &quot;                            &quot;);</a>
<a name="ln1198">          }</a>
<a name="ln1199">          fprintf(fd, &quot;%s&quot;, IObuff);</a>
<a name="ln1200">        }</a>
<a name="ln1201">        fclose(sfd);</a>
<a name="ln1202">      }</a>
<a name="ln1203">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1204">    }</a>
<a name="ln1205">  }</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">/// Return true when a function defined in the current script should be</a>
<a name="ln1209">/// profiled.</a>
<a name="ln1210">bool prof_def_func(void)</a>
<a name="ln1211">{</a>
<a name="ln1212">  if (current_sctx.sc_sid &gt; 0) {</a>
<a name="ln1213">    return SCRIPT_ITEM(current_sctx.sc_sid).sn_pr_force;</a>
<a name="ln1214">  }</a>
<a name="ln1215">  return false;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/// If 'autowrite' option set, try to write the file.</a>
<a name="ln1219">/// Careful: autocommands may make &quot;buf&quot; invalid!</a>
<a name="ln1220">///</a>
<a name="ln1221">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1222">int autowrite(buf_T *buf, int forceit)</a>
<a name="ln1223">{</a>
<a name="ln1224">  int r;</a>
<a name="ln1225">  bufref_T bufref;</a>
<a name="ln1226"> </a>
<a name="ln1227">  if (!(p_aw || p_awa) || !p_write</a>
<a name="ln1228">      // never autowrite a &quot;nofile&quot; or &quot;nowrite&quot; buffer</a>
<a name="ln1229">      || bt_dontwrite(buf)</a>
<a name="ln1230">      || (!forceit &amp;&amp; buf-&gt;b_p_ro) || buf-&gt;b_ffname == NULL) {</a>
<a name="ln1231">    return FAIL;</a>
<a name="ln1232">  }</a>
<a name="ln1233">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1234">  r = buf_write_all(buf, forceit);</a>
<a name="ln1235"> </a>
<a name="ln1236">  // Writing may succeed but the buffer still changed, e.g., when there is a</a>
<a name="ln1237">  // conversion error.  We do want to return FAIL then.</a>
<a name="ln1238">  if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1239">    r = FAIL;</a>
<a name="ln1240">  }</a>
<a name="ln1241">  return r;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">/// Flush all buffers, except the ones that are readonly or are never written.</a>
<a name="ln1245">void autowrite_all(void)</a>
<a name="ln1246">{</a>
<a name="ln1247">  if (!(p_aw || p_awa) || !p_write) {</a>
<a name="ln1248">    return;</a>
<a name="ln1249">  }</a>
<a name="ln1250"> </a>
<a name="ln1251">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1252">    if (bufIsChanged(buf) &amp;&amp; !buf-&gt;b_p_ro &amp;&amp; !bt_dontwrite(buf)) {</a>
<a name="ln1253">      bufref_T bufref;</a>
<a name="ln1254">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1255">      (void)buf_write_all(buf, false);</a>
<a name="ln1256">      // an autocommand may have deleted the buffer</a>
<a name="ln1257">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1258">        buf = firstbuf;</a>
<a name="ln1259">      }</a>
<a name="ln1260">    }</a>
<a name="ln1261">  }</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/// Return true if buffer was changed and cannot be abandoned.</a>
<a name="ln1265">/// For flags use the CCGD_ values.</a>
<a name="ln1266">bool check_changed(buf_T *buf, int flags)</a>
<a name="ln1267">{</a>
<a name="ln1268">  int forceit = (flags &amp; CCGD_FORCEIT);</a>
<a name="ln1269">  bufref_T bufref;</a>
<a name="ln1270">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1271"> </a>
<a name="ln1272">  if (!forceit</a>
<a name="ln1273">      &amp;&amp; bufIsChanged(buf)</a>
<a name="ln1274">      &amp;&amp; ((flags &amp; CCGD_MULTWIN) || buf-&gt;b_nwindows &lt;= 1)</a>
<a name="ln1275">      &amp;&amp; (!(flags &amp; CCGD_AW) || autowrite(buf, forceit) == FAIL)) {</a>
<a name="ln1276">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln1277">      int count = 0;</a>
<a name="ln1278"> </a>
<a name="ln1279">      if (flags &amp; CCGD_ALLBUF) {</a>
<a name="ln1280">        FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1281">          if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL)) {</a>
<a name="ln1282">            count++;</a>
<a name="ln1283">          }</a>
<a name="ln1284">        }</a>
<a name="ln1285">      }</a>
<a name="ln1286">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1287">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1288">        return false;</a>
<a name="ln1289">      }</a>
<a name="ln1290">      dialog_changed(buf, count &gt; 1);</a>
<a name="ln1291">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1292">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1293">        return false;</a>
<a name="ln1294">      }</a>
<a name="ln1295">      return bufIsChanged(buf);</a>
<a name="ln1296">    }</a>
<a name="ln1297">    if (flags &amp; CCGD_EXCMD) {</a>
<a name="ln1298">      no_write_message();</a>
<a name="ln1299">    } else {</a>
<a name="ln1300">      no_write_message_nobang();</a>
<a name="ln1301">    }</a>
<a name="ln1302">    return true;</a>
<a name="ln1303">  }</a>
<a name="ln1304">  return false;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">/// Ask the user what to do when abandoning a changed buffer.</a>
<a name="ln1310">/// Must check 'write' option first!</a>
<a name="ln1311">///</a>
<a name="ln1312">/// @param buf</a>
<a name="ln1313">/// @param checkall may abandon all changed buffers</a>
<a name="ln1314">void dialog_changed(buf_T *buf, bool checkall)</a>
<a name="ln1315">{</a>
<a name="ln1316">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1317">  int ret;</a>
<a name="ln1318">  // Init ea pseudo-structure, this is needed for the check_overwrite()</a>
<a name="ln1319">  // function.</a>
<a name="ln1320">  exarg_T ea = {</a>
<a name="ln1321">    .append = false,</a>
<a name="ln1322">    .forceit = false,</a>
<a name="ln1323">  };</a>
<a name="ln1324"> </a>
<a name="ln1325">  dialog_msg(buff, _(&quot;Save changes to \&quot;%s\&quot;?&quot;), buf-&gt;b_fname);</a>
<a name="ln1326">  if (checkall) {</a>
<a name="ln1327">    ret = vim_dialog_yesnoallcancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1328">  } else {</a>
<a name="ln1329">    ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1330">  }</a>
<a name="ln1331"> </a>
<a name="ln1332">  if (ret == VIM_YES) {</a>
<a name="ln1333">    if (buf-&gt;b_fname != NULL</a>
<a name="ln1334">        &amp;&amp; check_overwrite(&amp;ea,</a>
<a name="ln1335">                           buf,</a>
<a name="ln1336">                           buf-&gt;b_fname,</a>
<a name="ln1337">                           buf-&gt;b_ffname,</a>
<a name="ln1338">                           false) == OK) {</a>
<a name="ln1339">      // didn't hit Cancel</a>
<a name="ln1340">      (void)buf_write_all(buf, false);</a>
<a name="ln1341">    }</a>
<a name="ln1342">  } else if (ret == VIM_NO) {</a>
<a name="ln1343">    unchanged(buf, true, false);</a>
<a name="ln1344">  } else if (ret == VIM_ALL) {</a>
<a name="ln1345">    // Write all modified files that can be written.</a>
<a name="ln1346">    // Skip readonly buffers, these need to be confirmed</a>
<a name="ln1347">    // individually.</a>
<a name="ln1348">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1349">      if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL) &amp;&amp; !buf2-&gt;b_p_ro) {</a>
<a name="ln1350">        bufref_T bufref;</a>
<a name="ln1351">        set_bufref(&amp;bufref, buf2);</a>
<a name="ln1352"> </a>
<a name="ln1353">        if (buf2-&gt;b_fname != NULL</a>
<a name="ln1354">            &amp;&amp; check_overwrite(&amp;ea, buf2, buf2-&gt;b_fname,</a>
<a name="ln1355">                               buf2-&gt;b_ffname, false) == OK) {</a>
<a name="ln1356">          // didn't hit Cancel</a>
<a name="ln1357">          (void)buf_write_all(buf2, false);</a>
<a name="ln1358">        }</a>
<a name="ln1359">        // an autocommand may have deleted the buffer</a>
<a name="ln1360">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1361">          buf2 = firstbuf;</a>
<a name="ln1362">        }</a>
<a name="ln1363">      }</a>
<a name="ln1364">    }</a>
<a name="ln1365">  } else if (ret == VIM_DISCARDALL) {</a>
<a name="ln1366">    // mark all buffers as unchanged</a>
<a name="ln1367">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1368">      unchanged(buf2, true, false);</a>
<a name="ln1369">    }</a>
<a name="ln1370">  }</a>
<a name="ln1371">}</a>
<a name="ln1372"> </a>
<a name="ln1373">/// Ask the user whether to close the terminal buffer or not.</a>
<a name="ln1374">///</a>
<a name="ln1375">/// @param buf The terminal buffer.</a>
<a name="ln1376">/// @return bool Whether to close the buffer or not.</a>
<a name="ln1377">bool dialog_close_terminal(buf_T *buf)</a>
<a name="ln1378">{</a>
<a name="ln1379">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1380"> </a>
<a name="ln1381">  dialog_msg(buff, _(&quot;Close \&quot;%s\&quot;?&quot;),</a>
<a name="ln1382">             (buf-&gt;b_fname != NULL) ? buf-&gt;b_fname : (char_u *)&quot;?&quot;);</a>
<a name="ln1383"> </a>
<a name="ln1384">  int ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1385"> </a>
<a name="ln1386">  return (ret == VIM_YES) ? true : false;</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/// Return true if the buffer &quot;buf&quot; can be abandoned, either by making it</a>
<a name="ln1390">/// hidden, autowriting it or unloading it.</a>
<a name="ln1391">bool can_abandon(buf_T *buf, int forceit)</a>
<a name="ln1392">{</a>
<a name="ln1393">  return buf_hide(buf)</a>
<a name="ln1394">         || !bufIsChanged(buf)</a>
<a name="ln1395">         || buf-&gt;b_nwindows &gt; 1</a>
<a name="ln1396">         || autowrite(buf, forceit) == OK</a>
<a name="ln1397">         || forceit;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">/// Add a buffer number to &quot;bufnrs&quot;, unless it's already there.</a>
<a name="ln1402">static void add_bufnum(int *bufnrs, int *bufnump, int nr)</a>
<a name="ln1403">{</a>
<a name="ln1404">  int i;</a>
<a name="ln1405"> </a>
<a name="ln1406">  for (i = 0; i &lt; *bufnump; i++) {</a>
<a name="ln1407">    if (bufnrs[i] == nr) {</a>
<a name="ln1408">      return;</a>
<a name="ln1409">    }</a>
<a name="ln1410">  }</a>
<a name="ln1411">  bufnrs[*bufnump] = nr;</a>
<a name="ln1412">  *bufnump = *bufnump + 1;</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">/// Check if any buffer was changed and cannot be abandoned.</a>
<a name="ln1416">/// That changed buffer becomes the current buffer.</a>
<a name="ln1417">/// When &quot;unload&quot; is true the current buffer is unloaded instead of making it</a>
<a name="ln1418">/// hidden.  This is used for &quot;:q!&quot;.</a>
<a name="ln1419">///</a>
<a name="ln1420">/// @param[in] hidden specifies whether to check only hidden buffers.</a>
<a name="ln1421">/// @param[in] unload specifies whether to unload, instead of hide, the buffer.</a>
<a name="ln1422">///</a>
<a name="ln1423">/// @returns          true if any buffer is changed and cannot be abandoned</a>
<a name="ln1424">bool check_changed_any(bool hidden, bool unload)</a>
<a name="ln1425">{</a>
<a name="ln1426">  bool ret = false;</a>
<a name="ln1427">  int save;</a>
<a name="ln1428">  int i;</a>
<a name="ln1429">  int bufnum = 0;</a>
<a name="ln1430">  size_t bufcount = 0;</a>
<a name="ln1431">  int         *bufnrs;</a>
<a name="ln1432"> </a>
<a name="ln1433">  // Make a list of all buffers, with the most important ones first.</a>
<a name="ln1434">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1435">    bufcount++;</a>
<a name="ln1436">  }</a>
<a name="ln1437"> </a>
<a name="ln1438">  if (bufcount == 0) {</a>
<a name="ln1439">    return false;</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  bufnrs = xmalloc(sizeof(*bufnrs) * bufcount);</a>
<a name="ln1443"> </a>
<a name="ln1444">  // curbuf</a>
<a name="ln1445">  bufnrs[bufnum++] = curbuf-&gt;b_fnum;</a>
<a name="ln1446"> </a>
<a name="ln1447">  // buffers in current tab</a>
<a name="ln1448">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1449">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln1450">      add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1451">    }</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  // buffers in other tabs</a>
<a name="ln1455">  FOR_ALL_TABS(tp) {</a>
<a name="ln1456">    if (tp != curtab) {</a>
<a name="ln1457">      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln1458">        add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1459">      }</a>
<a name="ln1460">    }</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463">  // any other buffer</a>
<a name="ln1464">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1465">    add_bufnum(bufnrs, &amp;bufnum, buf-&gt;b_fnum);</a>
<a name="ln1466">  }</a>
<a name="ln1467"> </a>
<a name="ln1468">  buf_T *buf = NULL;</a>
<a name="ln1469">  for (i = 0; i &lt; bufnum; i++) {</a>
<a name="ln1470">    buf = buflist_findnr(bufnrs[i]);</a>
<a name="ln1471">    if (buf == NULL) {</a>
<a name="ln1472">      continue;</a>
<a name="ln1473">    }</a>
<a name="ln1474">    if ((!hidden || buf-&gt;b_nwindows == 0) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1475">      bufref_T bufref;</a>
<a name="ln1476">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1477"> </a>
<a name="ln1478">      // Try auto-writing the buffer.  If this fails but the buffer no</a>
<a name="ln1479">      // longer exists it's not changed, that's OK.</a>
<a name="ln1480">      if (check_changed(buf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln1481">                        | CCGD_MULTWIN</a>
<a name="ln1482">                        | CCGD_ALLBUF) &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln1483">        break;    // didn't save - still changes</a>
<a name="ln1484">      }</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  if (i &gt;= bufnum) {</a>
<a name="ln1489">    goto theend;</a>
<a name="ln1490">  }</a>
<a name="ln1491"> </a>
<a name="ln1492">  // Get here if &quot;buf&quot; cannot be abandoned.</a>
<a name="ln1493">  ret = true;</a>
<a name="ln1494">  exiting = false;</a>
<a name="ln1495">  // When &quot;:confirm&quot; used, don't give an error message.</a>
<a name="ln1496">  if (!(p_confirm || cmdmod.confirm)) {</a>
<a name="ln1497">    // There must be a wait_return for this message, do_buffer()</a>
<a name="ln1498">    // may cause a redraw.  But wait_return() is a no-op when vgetc()</a>
<a name="ln1499">    // is busy (Quit used from window menu), then make sure we don't</a>
<a name="ln1500">    // cause a scroll up.</a>
<a name="ln1501">    if (vgetc_busy &gt; 0) {</a>
<a name="ln1502">      msg_row = cmdline_row;</a>
<a name="ln1503">      msg_col = 0;</a>
<a name="ln1504">      msg_didout = false;</a>
<a name="ln1505">    }</a>
<a name="ln1506">    if (EMSG2(_(&quot;E162: No write since last change for buffer \&quot;%s\&quot;&quot;),</a>
<a name="ln1507">              buf_spname(buf) != NULL ? buf_spname(buf) : buf-&gt;b_fname)) {</a>
<a name="ln1508">      save = no_wait_return;</a>
<a name="ln1509">      no_wait_return = false;</a>
<a name="ln1510">      wait_return(false);</a>
<a name="ln1511">      no_wait_return = save;</a>
<a name="ln1512">    }</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  // Try to find a window that contains the buffer.</a>
<a name="ln1516">  if (buf != curbuf) {</a>
<a name="ln1517">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1518">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1519">        bufref_T bufref;</a>
<a name="ln1520">        set_bufref(&amp;bufref, buf);</a>
<a name="ln1521">        goto_tabpage_win(tp, wp);</a>
<a name="ln1522">        // Paranoia: did autocmds wipe out the buffer with changes?</a>
<a name="ln1523">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1524">          goto theend;</a>
<a name="ln1525">        }</a>
<a name="ln1526">        goto buf_found;</a>
<a name="ln1527">      }</a>
<a name="ln1528">    }</a>
<a name="ln1529">  }</a>
<a name="ln1530">buf_found:</a>
<a name="ln1531"> </a>
<a name="ln1532">  // Open the changed buffer in the current window.</a>
<a name="ln1533">  if (buf != curbuf) {</a>
<a name="ln1534">    set_curbuf(buf, unload ? DOBUF_UNLOAD : DOBUF_GOTO);</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">theend:</a>
<a name="ln1538">  xfree(bufnrs);</a>
<a name="ln1539">  return ret;</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542">/// Return FAIL if there is no file name, OK if there is one.</a>
<a name="ln1543">/// Give error message for FAIL.</a>
<a name="ln1544">int check_fname(void)</a>
<a name="ln1545">{</a>
<a name="ln1546">  if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1547">    EMSG(_(e_noname));</a>
<a name="ln1548">    return FAIL;</a>
<a name="ln1549">  }</a>
<a name="ln1550">  return OK;</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">/// Flush the contents of a buffer, unless it has no file name.</a>
<a name="ln1554">///</a>
<a name="ln1555">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1556">int buf_write_all(buf_T *buf, int forceit)</a>
<a name="ln1557">{</a>
<a name="ln1558">  int retval;</a>
<a name="ln1559">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1560"> </a>
<a name="ln1561">  retval = (buf_write(buf, buf-&gt;b_ffname, buf-&gt;b_fname,</a>
<a name="ln1562">                      (linenr_T)1, buf-&gt;b_ml.ml_line_count, NULL,</a>
<a name="ln1563">                      false, forceit, true, false));</a>
<a name="ln1564">  if (curbuf != old_curbuf) {</a>
<a name="ln1565">    msg_source(HL_ATTR(HLF_W));</a>
<a name="ln1566">    MSG(_(&quot;Warning: Entered other buffer unexpectedly (check autocommands)&quot;));</a>
<a name="ln1567">  }</a>
<a name="ln1568">  return retval;</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">/// Code to handle the argument list.</a>
<a name="ln1572"> </a>
<a name="ln1573">#define AL_SET  1</a>
<a name="ln1574">#define AL_ADD  2</a>
<a name="ln1575">#define AL_DEL  3</a>
<a name="ln1576"> </a>
<a name="ln1577">/// Isolate one argument, taking backticks.</a>
<a name="ln1578">/// Changes the argument in-place, puts a NUL after it.  Backticks remain.</a>
<a name="ln1579">/// Return a pointer to the start of the next argument.</a>
<a name="ln1580">static char_u *do_one_arg(char_u *str)</a>
<a name="ln1581">{</a>
<a name="ln1582">  char_u      *p;</a>
<a name="ln1583">  bool inbacktick;</a>
<a name="ln1584"> </a>
<a name="ln1585">  inbacktick = false;</a>
<a name="ln1586">  for (p = str; *str; str++) {</a>
<a name="ln1587">    // When the backslash is used for escaping the special meaning of a</a>
<a name="ln1588">    // character we need to keep it until wildcard expansion.</a>
<a name="ln1589">    if (rem_backslash(str)) {</a>
<a name="ln1590">      *p++ = *str++;</a>
<a name="ln1591">      *p++ = *str;</a>
<a name="ln1592">    } else {</a>
<a name="ln1593">      // An item ends at a space not in backticks</a>
<a name="ln1594">      if (!inbacktick &amp;&amp; ascii_isspace(*str)) {</a>
<a name="ln1595">        break;</a>
<a name="ln1596">      }</a>
<a name="ln1597">      if (*str == '`') {</a>
<a name="ln1598">        inbacktick ^= true;</a>
<a name="ln1599">      }</a>
<a name="ln1600">      *p++ = *str;</a>
<a name="ln1601">    }</a>
<a name="ln1602">  }</a>
<a name="ln1603">  str = skipwhite(str);</a>
<a name="ln1604">  *p = NUL;</a>
<a name="ln1605"> </a>
<a name="ln1606">  return str;</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">/// Separate the arguments in &quot;str&quot; and return a list of pointers in the</a>
<a name="ln1610">/// growarray &quot;gap&quot;.</a>
<a name="ln1611">static void get_arglist(garray_T *gap, char_u *str, int escaped)</a>
<a name="ln1612">{</a>
<a name="ln1613">  ga_init(gap, (int)sizeof(char_u *), 20);</a>
<a name="ln1614">  while (*str != NUL) {</a>
<a name="ln1615">    GA_APPEND(char_u *, gap, str);</a>
<a name="ln1616"> </a>
<a name="ln1617">    // If str is escaped, don't handle backslashes or spaces</a>
<a name="ln1618">    if (!escaped) {</a>
<a name="ln1619">      return;</a>
<a name="ln1620">    }</a>
<a name="ln1621"> </a>
<a name="ln1622">    // Isolate one argument, change it in-place, put a NUL after it.</a>
<a name="ln1623">    str = do_one_arg(str);</a>
<a name="ln1624">  }</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">/// Parse a list of arguments (file names), expand them and return in</a>
<a name="ln1628">/// &quot;fnames[fcountp]&quot;.  When &quot;wig&quot; is true, removes files matching 'wildignore'.</a>
<a name="ln1629">///</a>
<a name="ln1630">/// @return FAIL or OK.</a>
<a name="ln1631">int get_arglist_exp(char_u *str, int *fcountp, char_u ***fnamesp, bool wig)</a>
<a name="ln1632">{</a>
<a name="ln1633">  garray_T ga;</a>
<a name="ln1634">  int i;</a>
<a name="ln1635"> </a>
<a name="ln1636">  get_arglist(&amp;ga, str, true);</a>
<a name="ln1637"> </a>
<a name="ln1638">  if (wig) {</a>
<a name="ln1639">    i = expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1640">                         fcountp, fnamesp, EW_FILE|EW_NOTFOUND);</a>
<a name="ln1641">  } else {</a>
<a name="ln1642">    i = gen_expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1643">                             fcountp, fnamesp, EW_FILE|EW_NOTFOUND);</a>
<a name="ln1644">  }</a>
<a name="ln1645"> </a>
<a name="ln1646">  ga_clear(&amp;ga);</a>
<a name="ln1647">  return i;</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650"> </a>
<a name="ln1651">/// @param str</a>
<a name="ln1652">/// @param what</a>
<a name="ln1653">///         AL_SET: Redefine the argument list to 'str'.</a>
<a name="ln1654">///         AL_ADD: add files in 'str' to the argument list after &quot;after&quot;.</a>
<a name="ln1655">///         AL_DEL: remove files in 'str' from the argument list.</a>
<a name="ln1656">/// @param after</a>
<a name="ln1657">///         0 means before first one</a>
<a name="ln1658">///</a>
<a name="ln1659">/// @return FAIL for failure, OK otherwise.</a>
<a name="ln1660">static int do_arglist(char_u *str, int what, int after)</a>
<a name="ln1661">{</a>
<a name="ln1662">  garray_T new_ga;</a>
<a name="ln1663">  int exp_count;</a>
<a name="ln1664">  char_u      **exp_files;</a>
<a name="ln1665">  char_u      *p;</a>
<a name="ln1666">  int match;</a>
<a name="ln1667">  int arg_escaped = true;</a>
<a name="ln1668"> </a>
<a name="ln1669">  // Set default argument for &quot;:argadd&quot; command.</a>
<a name="ln1670">  if (what == AL_ADD &amp;&amp; *str == NUL) {</a>
<a name="ln1671">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1672">      return FAIL;</a>
<a name="ln1673">    }</a>
<a name="ln1674">    str = curbuf-&gt;b_fname;</a>
<a name="ln1675">    arg_escaped = false;</a>
<a name="ln1676">  }</a>
<a name="ln1677"> </a>
<a name="ln1678">  // Collect all file name arguments in &quot;new_ga&quot;.</a>
<a name="ln1679">  get_arglist(&amp;new_ga, str, arg_escaped);</a>
<a name="ln1680"> </a>
<a name="ln1681">  if (what == AL_DEL) {</a>
<a name="ln1682">    regmatch_T regmatch;</a>
<a name="ln1683">    bool didone;</a>
<a name="ln1684"> </a>
<a name="ln1685">    // Delete the items: use each item as a regexp and find a match in the</a>
<a name="ln1686">    // argument list.</a>
<a name="ln1687">    regmatch.rm_ic = p_fic;     // ignore case when 'fileignorecase' is set</a>
<a name="ln1688">    for (int i = 0; i &lt; new_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln1689">      p = ((char_u **)new_ga.ga_data)[i];</a>
<a name="ln1690">      p = file_pat_to_reg_pat(p, NULL, NULL, false);</a>
<a name="ln1691">      if (p == NULL) {</a>
<a name="ln1692">        break;</a>
<a name="ln1693">      }</a>
<a name="ln1694">      regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);</a>
<a name="ln1695">      if (regmatch.regprog == NULL) {</a>
<a name="ln1696">        xfree(p);</a>
<a name="ln1697">        break;</a>
<a name="ln1698">      }</a>
<a name="ln1699"> </a>
<a name="ln1700">      didone = false;</a>
<a name="ln1701">      for (match = 0; match &lt; ARGCOUNT; match++) {</a>
<a name="ln1702">        if (vim_regexec(&amp;regmatch, alist_name(&amp;ARGLIST[match]),</a>
<a name="ln1703">                        (colnr_T)0)) {</a>
<a name="ln1704">          didone = true;</a>
<a name="ln1705">          xfree(ARGLIST[match].ae_fname);</a>
<a name="ln1706">          memmove(ARGLIST + match, ARGLIST + match + 1,</a>
<a name="ln1707">                  (size_t)(ARGCOUNT - match - 1) * sizeof(aentry_T));</a>
<a name="ln1708">          ALIST(curwin)-&gt;al_ga.ga_len--;</a>
<a name="ln1709">          if (curwin-&gt;w_arg_idx &gt; match) {</a>
<a name="ln1710">            curwin-&gt;w_arg_idx--;</a>
<a name="ln1711">          }</a>
<a name="ln1712">          match--;</a>
<a name="ln1713">        }</a>
<a name="ln1714">      }</a>
<a name="ln1715"> </a>
<a name="ln1716">      vim_regfree(regmatch.regprog);</a>
<a name="ln1717">      xfree(p);</a>
<a name="ln1718">      if (!didone) {</a>
<a name="ln1719">        EMSG2(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);</a>
<a name="ln1720">      }</a>
<a name="ln1721">    }</a>
<a name="ln1722">    ga_clear(&amp;new_ga);</a>
<a name="ln1723">  } else {</a>
<a name="ln1724">    int i = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,</a>
<a name="ln1725">                             &amp;exp_count, &amp;exp_files,</a>
<a name="ln1726">                             EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);</a>
<a name="ln1727">    ga_clear(&amp;new_ga);</a>
<a name="ln1728">    if (i == FAIL || exp_count == 0) {</a>
<a name="ln1729">      EMSG(_(e_nomatch));</a>
<a name="ln1730">      return FAIL;</a>
<a name="ln1731">    }</a>
<a name="ln1732"> </a>
<a name="ln1733">    if (what == AL_ADD) {</a>
<a name="ln1734">      (void)alist_add_list(exp_count, exp_files, after);</a>
<a name="ln1735">      xfree(exp_files);</a>
<a name="ln1736">    } else {  // what == AL_SET</a>
<a name="ln1737">      alist_set(ALIST(curwin), exp_count, exp_files, false, NULL, 0);</a>
<a name="ln1738">    }</a>
<a name="ln1739">  }</a>
<a name="ln1740"> </a>
<a name="ln1741">  alist_check_arg_idx();</a>
<a name="ln1742"> </a>
<a name="ln1743">  return OK;</a>
<a name="ln1744">}</a>
<a name="ln1745"> </a>
<a name="ln1746">/// Check the validity of the arg_idx for each other window.</a>
<a name="ln1747">static void alist_check_arg_idx(void)</a>
<a name="ln1748">{</a>
<a name="ln1749">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln1750">    if (win-&gt;w_alist == curwin-&gt;w_alist) {</a>
<a name="ln1751">      check_arg_idx(win);</a>
<a name="ln1752">    }</a>
<a name="ln1753">  }</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/// Return true if window &quot;win&quot; is editing the file at the current argument</a>
<a name="ln1757">/// index.</a>
<a name="ln1758">static bool editing_arg_idx(win_T *win)</a>
<a name="ln1759">{</a>
<a name="ln1760">  return !(win-&gt;w_arg_idx &gt;= WARGCOUNT(win)</a>
<a name="ln1761">           || (win-&gt;w_buffer-&gt;b_fnum</a>
<a name="ln1762">               != WARGLIST(win)[win-&gt;w_arg_idx].ae_fnum</a>
<a name="ln1763">               &amp;&amp; (win-&gt;w_buffer-&gt;b_ffname == NULL</a>
<a name="ln1764">                   || !(path_full_compare(</a>
<a name="ln1765">                       alist_name(&amp;WARGLIST(win)[win-&gt;w_arg_idx]),</a>
<a name="ln1766">                       win-&gt;w_buffer-&gt;b_ffname, true, true) &amp; kEqualFiles))));</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/// Check if window &quot;win&quot; is editing the w_arg_idx file in its argument list.</a>
<a name="ln1770">void check_arg_idx(win_T *win)</a>
<a name="ln1771">{</a>
<a name="ln1772">  if (WARGCOUNT(win) &gt; 1 &amp;&amp; !editing_arg_idx(win)) {</a>
<a name="ln1773">    // We are not editing the current entry in the argument list.</a>
<a name="ln1774">    // Set &quot;arg_had_last&quot; if we are editing the last one.</a>
<a name="ln1775">    win-&gt;w_arg_idx_invalid = true;</a>
<a name="ln1776">    if (win-&gt;w_arg_idx != WARGCOUNT(win) - 1</a>
<a name="ln1777">        &amp;&amp; arg_had_last == false</a>
<a name="ln1778">        &amp;&amp; ALIST(win) == &amp;global_alist</a>
<a name="ln1779">        &amp;&amp; GARGCOUNT &gt; 0</a>
<a name="ln1780">        &amp;&amp; win-&gt;w_arg_idx &lt; GARGCOUNT</a>
<a name="ln1781">        &amp;&amp; (win-&gt;w_buffer-&gt;b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum</a>
<a name="ln1782">            || (win-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln1783">                &amp;&amp; (path_full_compare(alist_name(&amp;GARGLIST[GARGCOUNT - 1]),</a>
<a name="ln1784">                                      win-&gt;w_buffer-&gt;b_ffname, true, true)</a>
<a name="ln1785">                    &amp; kEqualFiles)))) {</a>
<a name="ln1786">      arg_had_last = true;</a>
<a name="ln1787">    }</a>
<a name="ln1788">  } else {</a>
<a name="ln1789">    // We are editing the current entry in the argument list.</a>
<a name="ln1790">    // Set &quot;arg_had_last&quot; if it's also the last one</a>
<a name="ln1791">    win-&gt;w_arg_idx_invalid = false;</a>
<a name="ln1792">    if (win-&gt;w_arg_idx == WARGCOUNT(win) - 1</a>
<a name="ln1793">        &amp;&amp; win-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1794">      arg_had_last = true;</a>
<a name="ln1795">    }</a>
<a name="ln1796">  }</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799">/// &quot;:args&quot;, &quot;:argslocal&quot; and &quot;:argsglobal&quot;.</a>
<a name="ln1800">void ex_args(exarg_T *eap)</a>
<a name="ln1801">{</a>
<a name="ln1802">  if (eap-&gt;cmdidx != CMD_args) {</a>
<a name="ln1803">    alist_unlink(ALIST(curwin));</a>
<a name="ln1804">    if (eap-&gt;cmdidx == CMD_argglobal) {</a>
<a name="ln1805">      ALIST(curwin) = &amp;global_alist;</a>
<a name="ln1806">    } else {     // eap-&gt;cmdidx == CMD_arglocal</a>
<a name="ln1807">      alist_new();</a>
<a name="ln1808">    }</a>
<a name="ln1809">  }</a>
<a name="ln1810"> </a>
<a name="ln1811">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1812">    // &quot;:args file ..&quot;: define new argument list, handle like &quot;:next&quot;</a>
<a name="ln1813">    // Also for &quot;:argslocal file ..&quot; and &quot;:argsglobal file ..&quot;.</a>
<a name="ln1814">    ex_next(eap);</a>
<a name="ln1815">  } else if (eap-&gt;cmdidx == CMD_args) {</a>
<a name="ln1816">    // &quot;:args&quot;: list arguments.</a>
<a name="ln1817">    if (ARGCOUNT &gt; 0) {</a>
<a name="ln1818">      char_u **items = xmalloc(sizeof(char_u *) * (size_t)ARGCOUNT);</a>
<a name="ln1819">      // Overwrite the command, for a short list there is no scrolling</a>
<a name="ln1820">      // required and no wait_return().</a>
<a name="ln1821">      gotocmdline(true);</a>
<a name="ln1822">      for (int i = 0; i &lt; ARGCOUNT; i++) {</a>
<a name="ln1823">        items[i] = alist_name(&amp;ARGLIST[i]);</a>
<a name="ln1824">      }</a>
<a name="ln1825">      list_in_columns(items, ARGCOUNT, curwin-&gt;w_arg_idx);</a>
<a name="ln1826">      xfree(items);</a>
<a name="ln1827">    }</a>
<a name="ln1828">  } else if (eap-&gt;cmdidx == CMD_arglocal) {</a>
<a name="ln1829">    garray_T        *gap = &amp;curwin-&gt;w_alist-&gt;al_ga;</a>
<a name="ln1830"> </a>
<a name="ln1831">    // &quot;:argslocal&quot;: make a local copy of the global argument list.</a>
<a name="ln1832">    ga_grow(gap, GARGCOUNT);</a>
<a name="ln1833">    for (int i = 0; i &lt; GARGCOUNT; i++) {</a>
<a name="ln1834">      if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln1835">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fname =</a>
<a name="ln1836">          vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln1837">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fnum =</a>
<a name="ln1838">          GARGLIST[i].ae_fnum;</a>
<a name="ln1839">        gap-&gt;ga_len++;</a>
<a name="ln1840">      }</a>
<a name="ln1841">    }</a>
<a name="ln1842">  }</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845">/// &quot;:previous&quot;, &quot;:sprevious&quot;, &quot;:Next&quot; and &quot;:sNext&quot;.</a>
<a name="ln1846">void ex_previous(exarg_T *eap)</a>
<a name="ln1847">{</a>
<a name="ln1848">  // If past the last one already, go to the last one.</a>
<a name="ln1849">  if (curwin-&gt;w_arg_idx - (int)eap-&gt;line2 &gt;= ARGCOUNT) {</a>
<a name="ln1850">    do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1851">  } else {</a>
<a name="ln1852">    do_argfile(eap, curwin-&gt;w_arg_idx - (int)eap-&gt;line2);</a>
<a name="ln1853">  }</a>
<a name="ln1854">}</a>
<a name="ln1855"> </a>
<a name="ln1856">/// &quot;:rewind&quot;, &quot;:first&quot;, &quot;:sfirst&quot; and &quot;:srewind&quot;.</a>
<a name="ln1857">void ex_rewind(exarg_T *eap)</a>
<a name="ln1858">{</a>
<a name="ln1859">  do_argfile(eap, 0);</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">/// &quot;:last&quot; and &quot;:slast&quot;.</a>
<a name="ln1863">void ex_last(exarg_T *eap)</a>
<a name="ln1864">{</a>
<a name="ln1865">  do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">/// &quot;:argument&quot; and &quot;:sargument&quot;.</a>
<a name="ln1869">void ex_argument(exarg_T *eap)</a>
<a name="ln1870">{</a>
<a name="ln1871">  int i;</a>
<a name="ln1872"> </a>
<a name="ln1873">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1874">    i = (int)eap-&gt;line2 - 1;</a>
<a name="ln1875">  } else {</a>
<a name="ln1876">    i = curwin-&gt;w_arg_idx;</a>
<a name="ln1877">  }</a>
<a name="ln1878">  do_argfile(eap, i);</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">/// Edit file &quot;argn&quot; of the argument lists.</a>
<a name="ln1882">void do_argfile(exarg_T *eap, int argn)</a>
<a name="ln1883">{</a>
<a name="ln1884">  int other;</a>
<a name="ln1885">  char_u      *p;</a>
<a name="ln1886">  int old_arg_idx = curwin-&gt;w_arg_idx;</a>
<a name="ln1887"> </a>
<a name="ln1888">  if (argn &lt; 0 || argn &gt;= ARGCOUNT) {</a>
<a name="ln1889">    if (ARGCOUNT &lt;= 1) {</a>
<a name="ln1890">      EMSG(_(&quot;E163: There is only one file to edit&quot;));</a>
<a name="ln1891">    } else if (argn &lt; 0) {</a>
<a name="ln1892">      EMSG(_(&quot;E164: Cannot go before first file&quot;));</a>
<a name="ln1893">    } else {</a>
<a name="ln1894">      EMSG(_(&quot;E165: Cannot go beyond last file&quot;));</a>
<a name="ln1895">    }</a>
<a name="ln1896">  } else {</a>
<a name="ln1897">    setpcmark();</a>
<a name="ln1898"> </a>
<a name="ln1899">    // split window or create new tab page first</a>
<a name="ln1900">    if (*eap-&gt;cmd == 's' || cmdmod.tab != 0) {</a>
<a name="ln1901">      if (win_split(0, 0) == FAIL) {</a>
<a name="ln1902">        return;</a>
<a name="ln1903">      }</a>
<a name="ln1904">      RESET_BINDING(curwin);</a>
<a name="ln1905">    } else {</a>
<a name="ln1906">      // if 'hidden' set, only check for changed file when re-editing</a>
<a name="ln1907">      // the same buffer</a>
<a name="ln1908">      other = true;</a>
<a name="ln1909">      if (buf_hide(curbuf)) {</a>
<a name="ln1910">        p = (char_u *)fix_fname((char *)alist_name(&amp;ARGLIST[argn]));</a>
<a name="ln1911">        other = otherfile(p);</a>
<a name="ln1912">        xfree(p);</a>
<a name="ln1913">      }</a>
<a name="ln1914">      if ((!buf_hide(curbuf) || !other)</a>
<a name="ln1915">          &amp;&amp; check_changed(curbuf, CCGD_AW</a>
<a name="ln1916">                           | (other ? 0 : CCGD_MULTWIN)</a>
<a name="ln1917">                           | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln1918">                           | CCGD_EXCMD)) {</a>
<a name="ln1919">        return;</a>
<a name="ln1920">      }</a>
<a name="ln1921">    }</a>
<a name="ln1922"> </a>
<a name="ln1923">    curwin-&gt;w_arg_idx = argn;</a>
<a name="ln1924">    if (argn == ARGCOUNT - 1</a>
<a name="ln1925">        &amp;&amp; curwin-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1926">      arg_had_last = true;</a>
<a name="ln1927">    }</a>
<a name="ln1928"> </a>
<a name="ln1929">    // Edit the file; always use the last known line number.</a>
<a name="ln1930">    // When it fails (e.g. Abort for already edited file) restore the</a>
<a name="ln1931">    // argument index.</a>
<a name="ln1932">    if (do_ecmd(0, alist_name(&amp;ARGLIST[curwin-&gt;w_arg_idx]), NULL,</a>
<a name="ln1933">                eap, ECMD_LAST,</a>
<a name="ln1934">                (buf_hide(curwin-&gt;w_buffer) ? ECMD_HIDE : 0)</a>
<a name="ln1935">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0), curwin) == FAIL) {</a>
<a name="ln1936">      curwin-&gt;w_arg_idx = old_arg_idx;</a>
<a name="ln1937">    } else if (eap-&gt;cmdidx != CMD_argdo) {</a>
<a name="ln1938">      // like Vi: set the mark where the cursor is in the file.</a>
<a name="ln1939">      setmark('\'');</a>
<a name="ln1940">    }</a>
<a name="ln1941">  }</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">/// &quot;:next&quot;, and commands that behave like it.</a>
<a name="ln1945">void ex_next(exarg_T *eap)</a>
<a name="ln1946">{</a>
<a name="ln1947">  int i;</a>
<a name="ln1948"> </a>
<a name="ln1949">  // check for changed buffer now, if this fails the argument list is not</a>
<a name="ln1950">  // redefined.</a>
<a name="ln1951">  if (buf_hide(curbuf)</a>
<a name="ln1952">      || eap-&gt;cmdidx == CMD_snext</a>
<a name="ln1953">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln1954">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln1955">                        | CCGD_EXCMD)) {</a>
<a name="ln1956">    if (*eap-&gt;arg != NUL) {                 // redefine file list</a>
<a name="ln1957">      if (do_arglist(eap-&gt;arg, AL_SET, 0) == FAIL) {</a>
<a name="ln1958">        return;</a>
<a name="ln1959">      }</a>
<a name="ln1960">      i = 0;</a>
<a name="ln1961">    } else {</a>
<a name="ln1962">      i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln1963">    }</a>
<a name="ln1964">    do_argfile(eap, i);</a>
<a name="ln1965">  }</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">/// &quot;:argedit&quot;</a>
<a name="ln1969">void ex_argedit(exarg_T *eap)</a>
<a name="ln1970">{</a>
<a name="ln1971">  int i = eap-&gt;addr_count ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1;</a>
<a name="ln1972">  // Whether curbuf will be reused, curbuf-&gt;b_ffname will be set.</a>
<a name="ln1973">  bool curbuf_is_reusable = curbuf_reusable();</a>
<a name="ln1974"> </a>
<a name="ln1975">  if (do_arglist(eap-&gt;arg, AL_ADD, i) == FAIL) {</a>
<a name="ln1976">    return;</a>
<a name="ln1977">  }</a>
<a name="ln1978">  maketitle();</a>
<a name="ln1979"> </a>
<a name="ln1980">  if (curwin-&gt;w_arg_idx == 0</a>
<a name="ln1981">      &amp;&amp; (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln1982">      &amp;&amp; (curbuf-&gt;b_ffname == NULL || curbuf_is_reusable)) {</a>
<a name="ln1983">    i = 0;</a>
<a name="ln1984">  }</a>
<a name="ln1985">  // Edit the argument.</a>
<a name="ln1986">  if (i &lt; ARGCOUNT) {</a>
<a name="ln1987">    do_argfile(eap, i);</a>
<a name="ln1988">  }</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">/// &quot;:argadd&quot;</a>
<a name="ln1992">void ex_argadd(exarg_T *eap)</a>
<a name="ln1993">{</a>
<a name="ln1994">  do_arglist(eap-&gt;arg, AL_ADD,</a>
<a name="ln1995">             eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1);</a>
<a name="ln1996">  maketitle();</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">/// &quot;:argdelete&quot;</a>
<a name="ln2000">void ex_argdelete(exarg_T *eap)</a>
<a name="ln2001">{</a>
<a name="ln2002">  if (eap-&gt;addr_count &gt; 0 || *eap-&gt;arg == NUL) {</a>
<a name="ln2003">    // &quot;:argdel&quot; works like &quot;:.argdel&quot;</a>
<a name="ln2004">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln2005">      if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2006">        EMSG(_(&quot;E610: No argument to delete&quot;));</a>
<a name="ln2007">        return;</a>
<a name="ln2008">      }</a>
<a name="ln2009">      eap-&gt;line1 = eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2010">    } else if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2011">      // &quot;:1,4argdel&quot;: Delete all arguments in the range.</a>
<a name="ln2012">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2013">    }</a>
<a name="ln2014">    linenr_T n = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln2015">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln2016">      // Can't have both a range and an argument.</a>
<a name="ln2017">      EMSG(_(e_invarg));</a>
<a name="ln2018">    } else if (n &lt;= 0) {</a>
<a name="ln2019">      // Don't give an error for &quot;:%argdel&quot; if the list is empty.</a>
<a name="ln2020">      if (eap-&gt;line1 != 1 || eap-&gt;line2 != 0) {</a>
<a name="ln2021">        EMSG(_(e_invrange));</a>
<a name="ln2022">      }</a>
<a name="ln2023">    } else {</a>
<a name="ln2024">      for (linenr_T i = eap-&gt;line1; i &lt;= eap-&gt;line2; i++) {</a>
<a name="ln2025">        xfree(ARGLIST[i - 1].ae_fname);</a>
<a name="ln2026">      }</a>
<a name="ln2027">      memmove(ARGLIST + eap-&gt;line1 - 1, ARGLIST + eap-&gt;line2,</a>
<a name="ln2028">              (size_t)(ARGCOUNT - eap-&gt;line2) * sizeof(aentry_T));</a>
<a name="ln2029">      ALIST(curwin)-&gt;al_ga.ga_len -= (int)n;</a>
<a name="ln2030">      if (curwin-&gt;w_arg_idx &gt;= eap-&gt;line2) {</a>
<a name="ln2031">        curwin-&gt;w_arg_idx -= (int)n;</a>
<a name="ln2032">      } else if (curwin-&gt;w_arg_idx &gt; eap-&gt;line1) {</a>
<a name="ln2033">        curwin-&gt;w_arg_idx = (int)eap-&gt;line1;</a>
<a name="ln2034">      }</a>
<a name="ln2035">      if (ARGCOUNT == 0) {</a>
<a name="ln2036">          curwin-&gt;w_arg_idx = 0;</a>
<a name="ln2037">      } else if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2038">          curwin-&gt;w_arg_idx = ARGCOUNT - 1;</a>
<a name="ln2039">      }</a>
<a name="ln2040">    }</a>
<a name="ln2041">  } else {</a>
<a name="ln2042">    do_arglist(eap-&gt;arg, AL_DEL, 0);</a>
<a name="ln2043">  }</a>
<a name="ln2044">  maketitle();</a>
<a name="ln2045">}</a>
<a name="ln2046"> </a>
<a name="ln2047">/// &quot;:argdo&quot;, &quot;:windo&quot;, &quot;:bufdo&quot;, &quot;:tabdo&quot;, &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;</a>
<a name="ln2048">void ex_listdo(exarg_T *eap)</a>
<a name="ln2049">{</a>
<a name="ln2050">  int i;</a>
<a name="ln2051">  win_T       *wp;</a>
<a name="ln2052">  tabpage_T   *tp;</a>
<a name="ln2053">  int next_fnum = 0;</a>
<a name="ln2054">  char_u      *save_ei = NULL;</a>
<a name="ln2055">  char_u      *p_shm_save;</a>
<a name="ln2056"> </a>
<a name="ln2057">  if (eap-&gt;cmdidx != CMD_windo &amp;&amp; eap-&gt;cmdidx != CMD_tabdo) {</a>
<a name="ln2058">    // Don't do syntax HL autocommands.  Skipping the syntax file is a</a>
<a name="ln2059">    // great speed improvement.</a>
<a name="ln2060">    save_ei = au_event_disable(&quot;,Syntax&quot;);</a>
<a name="ln2061"> </a>
<a name="ln2062">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2063">      buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2064">    }</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  if (eap-&gt;cmdidx == CMD_windo</a>
<a name="ln2068">      || eap-&gt;cmdidx == CMD_tabdo</a>
<a name="ln2069">      || buf_hide(curbuf)</a>
<a name="ln2070">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2071">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2072">                        | CCGD_EXCMD)) {</a>
<a name="ln2073">    i = 0;</a>
<a name="ln2074">    // start at the eap-&gt;line1 argument/window/buffer</a>
<a name="ln2075">    wp = firstwin;</a>
<a name="ln2076">    tp = first_tabpage;</a>
<a name="ln2077">    switch (eap-&gt;cmdidx) {</a>
<a name="ln2078">    case CMD_windo:</a>
<a name="ln2079">      for (; wp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; wp = wp-&gt;w_next) {</a>
<a name="ln2080">        i++;</a>
<a name="ln2081">      }</a>
<a name="ln2082">      break;</a>
<a name="ln2083">    case CMD_tabdo:</a>
<a name="ln2084">      for (; tp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; tp = tp-&gt;tp_next) {</a>
<a name="ln2085">        i++;</a>
<a name="ln2086">      }</a>
<a name="ln2087">      break;</a>
<a name="ln2088">    case CMD_argdo:</a>
<a name="ln2089">      i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2090">      break;</a>
<a name="ln2091">    default:</a>
<a name="ln2092">      break;</a>
<a name="ln2093">    }</a>
<a name="ln2094"> </a>
<a name="ln2095">    buf_T *buf = curbuf;</a>
<a name="ln2096">    size_t qf_size = 0;</a>
<a name="ln2097"> </a>
<a name="ln2098">    // set pcmark now</a>
<a name="ln2099">    if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2100">      // Advance to the first listed buffer after &quot;eap-&gt;line1&quot;.</a>
<a name="ln2101">      for (buf = firstbuf;</a>
<a name="ln2102">           buf != NULL &amp;&amp; (buf-&gt;b_fnum &lt; eap-&gt;line1 || !buf-&gt;b_p_bl);</a>
<a name="ln2103">           buf = buf-&gt;b_next) {</a>
<a name="ln2104">        if (buf-&gt;b_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2105">          buf = NULL;</a>
<a name="ln2106">          break;</a>
<a name="ln2107">        }</a>
<a name="ln2108">      }</a>
<a name="ln2109">      if (buf != NULL) {</a>
<a name="ln2110">        goto_buffer(eap, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum);</a>
<a name="ln2111">      }</a>
<a name="ln2112">    } else if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2113">               || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2114">      qf_size = qf_get_size(eap);</a>
<a name="ln2115">      assert(eap-&gt;line1 &gt;= 0);</a>
<a name="ln2116">      if (qf_size == 0 || (size_t)eap-&gt;line1 &gt; qf_size) {</a>
<a name="ln2117">        buf = NULL;</a>
<a name="ln2118">      } else {</a>
<a name="ln2119">        ex_cc(eap);</a>
<a name="ln2120"> </a>
<a name="ln2121">        buf = curbuf;</a>
<a name="ln2122">        i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2123">        if (eap-&gt;addr_count &lt;= 0) {</a>
<a name="ln2124">          // Default to all quickfix/location list entries.</a>
<a name="ln2125">          assert(qf_size &lt; MAXLNUM);</a>
<a name="ln2126">          eap-&gt;line2 = (linenr_T)qf_size;</a>
<a name="ln2127">        }</a>
<a name="ln2128">      }</a>
<a name="ln2129">    } else {</a>
<a name="ln2130">      setpcmark();</a>
<a name="ln2131">    }</a>
<a name="ln2132">    listcmd_busy = true;            // avoids setting pcmark below</a>
<a name="ln2133"> </a>
<a name="ln2134">    while (!got_int &amp;&amp; buf != NULL) {</a>
<a name="ln2135">      if (eap-&gt;cmdidx == CMD_argdo) {</a>
<a name="ln2136">        // go to argument &quot;i&quot;</a>
<a name="ln2137">        if (i == ARGCOUNT) {</a>
<a name="ln2138">          break;</a>
<a name="ln2139">        }</a>
<a name="ln2140">        // Don't call do_argfile() when already there, it will try</a>
<a name="ln2141">        // reloading the file.</a>
<a name="ln2142">        if (curwin-&gt;w_arg_idx != i || !editing_arg_idx(curwin)) {</a>
<a name="ln2143">          // Clear 'shm' to avoid that the file message overwrites</a>
<a name="ln2144">          // any output from the command.</a>
<a name="ln2145">          p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2146">          set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2147">          do_argfile(eap, i);</a>
<a name="ln2148">          set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2149">          xfree(p_shm_save);</a>
<a name="ln2150">        }</a>
<a name="ln2151">        if (curwin-&gt;w_arg_idx != i) {</a>
<a name="ln2152">          break;</a>
<a name="ln2153">        }</a>
<a name="ln2154">      } else if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2155">        // go to window &quot;wp&quot;</a>
<a name="ln2156">        if (!win_valid(wp)) {</a>
<a name="ln2157">          break;</a>
<a name="ln2158">        }</a>
<a name="ln2159">        assert(wp);</a>
<a name="ln2160">        win_goto(wp);</a>
<a name="ln2161">        if (curwin != wp) {</a>
<a name="ln2162">          break;    // something must be wrong</a>
<a name="ln2163">        }</a>
<a name="ln2164">        wp = curwin-&gt;w_next;</a>
<a name="ln2165">      } else if (eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2166">        // go to window &quot;tp&quot;</a>
<a name="ln2167">        if (!valid_tabpage(tp)) {</a>
<a name="ln2168">          break;</a>
<a name="ln2169">        }</a>
<a name="ln2170">        assert(tp);</a>
<a name="ln2171">        goto_tabpage_tp(tp, true, true);</a>
<a name="ln2172">        tp = tp-&gt;tp_next;</a>
<a name="ln2173">      } else if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2174">        // Remember the number of the next listed buffer, in case</a>
<a name="ln2175">        // &quot;:bwipe&quot; is used or autocommands do something strange.</a>
<a name="ln2176">        next_fnum = -1;</a>
<a name="ln2177">        for (buf_T *bp = curbuf-&gt;b_next; bp != NULL; bp = bp-&gt;b_next) {</a>
<a name="ln2178">          if (bp-&gt;b_p_bl) {</a>
<a name="ln2179">            next_fnum = bp-&gt;b_fnum;</a>
<a name="ln2180">            break;</a>
<a name="ln2181">          }</a>
<a name="ln2182">        }</a>
<a name="ln2183">      }</a>
<a name="ln2184"> </a>
<a name="ln2185">      i++;</a>
<a name="ln2186">      // execute the command</a>
<a name="ln2187">      do_cmdline(eap-&gt;arg, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln2188">                 DOCMD_VERBOSE + DOCMD_NOWAIT);</a>
<a name="ln2189"> </a>
<a name="ln2190">      if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2191">        // Done?</a>
<a name="ln2192">        if (next_fnum &lt; 0 || next_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2193">          break;</a>
<a name="ln2194">        }</a>
<a name="ln2195"> </a>
<a name="ln2196">        // Check if the buffer still exists.</a>
<a name="ln2197">        bool buf_still_exists = false;</a>
<a name="ln2198">        FOR_ALL_BUFFERS(bp) {</a>
<a name="ln2199">          if (bp-&gt;b_fnum == next_fnum) {</a>
<a name="ln2200">            buf_still_exists = true;</a>
<a name="ln2201">            break;</a>
<a name="ln2202">          }</a>
<a name="ln2203">        }</a>
<a name="ln2204">        if (!buf_still_exists) {</a>
<a name="ln2205">          break;</a>
<a name="ln2206">        }</a>
<a name="ln2207"> </a>
<a name="ln2208">        // Go to the next buffer.  Clear 'shm' to avoid that the file</a>
<a name="ln2209">        // message overwrites any output from the command.</a>
<a name="ln2210">        p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2211">        set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2212">        goto_buffer(eap, DOBUF_FIRST, FORWARD, next_fnum);</a>
<a name="ln2213">        set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2214">        xfree(p_shm_save);</a>
<a name="ln2215"> </a>
<a name="ln2216">        // If autocommands took us elsewhere, quit here.</a>
<a name="ln2217">        if (curbuf-&gt;b_fnum != next_fnum) {</a>
<a name="ln2218">          break;</a>
<a name="ln2219">        }</a>
<a name="ln2220">      }</a>
<a name="ln2221"> </a>
<a name="ln2222">      if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2223">          || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2224">        assert(i &gt;= 0);</a>
<a name="ln2225">        if ((size_t)i &gt;= qf_size || i &gt;= eap-&gt;line2) {</a>
<a name="ln2226">          break;</a>
<a name="ln2227">        }</a>
<a name="ln2228"> </a>
<a name="ln2229">        size_t qf_idx = qf_get_cur_idx(eap);</a>
<a name="ln2230"> </a>
<a name="ln2231">        ex_cnext(eap);</a>
<a name="ln2232"> </a>
<a name="ln2233">        // If jumping to the next quickfix entry fails, quit here.</a>
<a name="ln2234">        if (qf_get_cur_idx(eap) == qf_idx) {</a>
<a name="ln2235">          break;</a>
<a name="ln2236">        }</a>
<a name="ln2237">      }</a>
<a name="ln2238"> </a>
<a name="ln2239">      if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2240">        validate_cursor();              // cursor may have moved</a>
<a name="ln2241">        // required when 'scrollbind' has been set</a>
<a name="ln2242">        if (curwin-&gt;w_p_scb) {</a>
<a name="ln2243">          do_check_scrollbind(true);</a>
<a name="ln2244">        }</a>
<a name="ln2245">      }</a>
<a name="ln2246">      if (eap-&gt;cmdidx == CMD_windo || eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2247">        if (i + 1 &gt; eap-&gt;line2) {</a>
<a name="ln2248">          break;</a>
<a name="ln2249">        }</a>
<a name="ln2250">      }</a>
<a name="ln2251">      if (eap-&gt;cmdidx == CMD_argdo &amp;&amp; i &gt;= eap-&gt;line2) {</a>
<a name="ln2252">        break;</a>
<a name="ln2253">      }</a>
<a name="ln2254">    }</a>
<a name="ln2255">    listcmd_busy = false;</a>
<a name="ln2256">  }</a>
<a name="ln2257"> </a>
<a name="ln2258">  if (save_ei != NULL) {</a>
<a name="ln2259">    buf_T *bnext;</a>
<a name="ln2260">    aco_save_T aco;</a>
<a name="ln2261"> </a>
<a name="ln2262">    au_event_restore(save_ei);</a>
<a name="ln2263"> </a>
<a name="ln2264">    for (buf_T *buf = firstbuf; buf != NULL; buf = bnext) {</a>
<a name="ln2265">      bnext = buf-&gt;b_next;</a>
<a name="ln2266">      if (buf-&gt;b_nwindows &gt; 0 &amp;&amp; (buf-&gt;b_flags &amp; BF_SYN_SET)) {</a>
<a name="ln2267">        buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2268"> </a>
<a name="ln2269">        // buffer was opened while Syntax autocommands were disabled,</a>
<a name="ln2270">        // need to trigger them now.</a>
<a name="ln2271">        if (buf == curbuf) {</a>
<a name="ln2272">          apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn,</a>
<a name="ln2273">                         curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln2274">        } else {</a>
<a name="ln2275">          aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2276">          apply_autocmds(EVENT_SYNTAX, buf-&gt;b_p_syn,</a>
<a name="ln2277">                         buf-&gt;b_fname, true, buf);</a>
<a name="ln2278">          aucmd_restbuf(&amp;aco);</a>
<a name="ln2279">        }</a>
<a name="ln2280"> </a>
<a name="ln2281">        // start over, in case autocommands messed things up.</a>
<a name="ln2282">        bnext = firstbuf;</a>
<a name="ln2283">      }</a>
<a name="ln2284">    }</a>
<a name="ln2285">  }</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">/// Add files[count] to the arglist of the current window after arg &quot;after&quot;.</a>
<a name="ln2289">/// The file names in files[count] must have been allocated and are taken over.</a>
<a name="ln2290">/// Files[] itself is not taken over.</a>
<a name="ln2291">///</a>
<a name="ln2292">/// @param after: where to add: 0 = before first one</a>
<a name="ln2293">///</a>
<a name="ln2294">/// @return index of first added argument</a>
<a name="ln2295">static int alist_add_list(int count, char_u **files, int after)</a>
<a name="ln2296">{</a>
<a name="ln2297">  int old_argcount = ARGCOUNT;</a>
<a name="ln2298">  ga_grow(&amp;ALIST(curwin)-&gt;al_ga, count);</a>
<a name="ln2299">  {</a>
<a name="ln2300">    if (after &lt; 0) {</a>
<a name="ln2301">      after = 0;</a>
<a name="ln2302">    }</a>
<a name="ln2303">    if (after &gt; ARGCOUNT) {</a>
<a name="ln2304">      after = ARGCOUNT;</a>
<a name="ln2305">    }</a>
<a name="ln2306">    if (after &lt; ARGCOUNT) {</a>
<a name="ln2307">      memmove(&amp;(ARGLIST[after + count]), &amp;(ARGLIST[after]),</a>
<a name="ln2308">              (size_t)(ARGCOUNT - after) * sizeof(aentry_T));</a>
<a name="ln2309">    }</a>
<a name="ln2310">    for (int i = 0; i &lt; count; i++) {</a>
<a name="ln2311">      ARGLIST[after + i].ae_fname = files[i];</a>
<a name="ln2312">      ARGLIST[after + i].ae_fnum = buflist_add(files[i],</a>
<a name="ln2313">                                               BLN_LISTED | BLN_CURBUF);</a>
<a name="ln2314">    }</a>
<a name="ln2315">    ALIST(curwin)-&gt;al_ga.ga_len += count;</a>
<a name="ln2316">    if (old_argcount &gt; 0 &amp;&amp; curwin-&gt;w_arg_idx &gt;= after) {</a>
<a name="ln2317">      curwin-&gt;w_arg_idx += count;</a>
<a name="ln2318">    }</a>
<a name="ln2319">    return after;</a>
<a name="ln2320">  }</a>
<a name="ln2321">}</a>
<a name="ln2322"> </a>
<a name="ln2323">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln2324">// argedit and argdelete commands.</a>
<a name="ln2325">char_u *get_arglist_name(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln2326">{</a>
<a name="ln2327">  if (idx &gt;= ARGCOUNT) {</a>
<a name="ln2328">    return NULL;</a>
<a name="ln2329">  }</a>
<a name="ln2330">  return alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">/// &quot;:compiler[!] {name}&quot;</a>
<a name="ln2334">void ex_compiler(exarg_T *eap)</a>
<a name="ln2335">{</a>
<a name="ln2336">  char_u      *buf;</a>
<a name="ln2337">  char_u      *old_cur_comp = NULL;</a>
<a name="ln2338">  char_u      *p;</a>
<a name="ln2339"> </a>
<a name="ln2340">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln2341">    // List all compiler scripts.</a>
<a name="ln2342">    do_cmdline_cmd(&quot;echo globpath(&amp;rtp, 'compiler/*.vim')&quot;);  // NOLINT</a>
<a name="ln2343">  } else {</a>
<a name="ln2344">    size_t bufsize = STRLEN(eap-&gt;arg) + 14;</a>
<a name="ln2345">    buf = xmalloc(bufsize);</a>
<a name="ln2346">    if (eap-&gt;forceit) {</a>
<a name="ln2347">      // &quot;:compiler! {name}&quot; sets global options</a>
<a name="ln2348">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet set &lt;args&gt;&quot;);</a>
<a name="ln2349">    } else {</a>
<a name="ln2350">      // &quot;:compiler! {name}&quot; sets local options.</a>
<a name="ln2351">      // To remain backwards compatible &quot;current_compiler&quot; is always</a>
<a name="ln2352">      // used.  A user's compiler plugin may set it, the distributed</a>
<a name="ln2353">      // plugin will then skip the settings.  Afterwards set</a>
<a name="ln2354">      // &quot;b:current_compiler&quot; and restore &quot;current_compiler&quot;.</a>
<a name="ln2355">      // Explicitly prepend &quot;g:&quot; to make it work in a function.</a>
<a name="ln2356">      old_cur_comp = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2357">      if (old_cur_comp != NULL) {</a>
<a name="ln2358">        old_cur_comp = vim_strsave(old_cur_comp);</a>
<a name="ln2359">      }</a>
<a name="ln2360">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet setlocal &lt;args&gt;&quot;);</a>
<a name="ln2361">    }</a>
<a name="ln2362">    do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2363">    do_unlet(S_LEN(&quot;b:current_compiler&quot;), true);</a>
<a name="ln2364"> </a>
<a name="ln2365">    snprintf((char *)buf, bufsize, &quot;compiler/%s.vim&quot;, eap-&gt;arg);</a>
<a name="ln2366">    if (source_in_path(p_rtp, buf, DIP_ALL) == FAIL) {</a>
<a name="ln2367">      EMSG2(_(&quot;E666: compiler not supported: %s&quot;), eap-&gt;arg);</a>
<a name="ln2368">    }</a>
<a name="ln2369">    xfree(buf);</a>
<a name="ln2370"> </a>
<a name="ln2371">    do_cmdline_cmd(&quot;:delcommand CompilerSet&quot;);</a>
<a name="ln2372"> </a>
<a name="ln2373">    // Set &quot;b:current_compiler&quot; from &quot;current_compiler&quot;.</a>
<a name="ln2374">    p = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2375">    if (p != NULL) {</a>
<a name="ln2376">      set_internal_string_var((char_u *)&quot;b:current_compiler&quot;, p);</a>
<a name="ln2377">    }</a>
<a name="ln2378"> </a>
<a name="ln2379">    // Restore &quot;current_compiler&quot; for &quot;:compiler {name}&quot;.</a>
<a name="ln2380">    if (!eap-&gt;forceit) {</a>
<a name="ln2381">      if (old_cur_comp != NULL) {</a>
<a name="ln2382">        set_internal_string_var((char_u *)&quot;g:current_compiler&quot;,</a>
<a name="ln2383">                                old_cur_comp);</a>
<a name="ln2384">        xfree(old_cur_comp);</a>
<a name="ln2385">      } else {</a>
<a name="ln2386">        do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2387">      }</a>
<a name="ln2388">    }</a>
<a name="ln2389">  }</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392">/// &quot;:runtime [what] {name}&quot;</a>
<a name="ln2393">void ex_runtime(exarg_T *eap)</a>
<a name="ln2394">{</a>
<a name="ln2395">  char_u *arg = eap-&gt;arg;</a>
<a name="ln2396">  char_u *p = skiptowhite(arg);</a>
<a name="ln2397">  ptrdiff_t len = p - arg;</a>
<a name="ln2398">  int flags = eap-&gt;forceit ? DIP_ALL : 0;</a>
<a name="ln2399"> </a>
<a name="ln2400">  if (STRNCMP(arg, &quot;START&quot;, len) == 0) {</a>
<a name="ln2401">    flags += DIP_START + DIP_NORTP;</a>
<a name="ln2402">    arg = skipwhite(arg + len);</a>
<a name="ln2403">  } else if (STRNCMP(arg, &quot;OPT&quot;, len) == 0) {</a>
<a name="ln2404">    flags += DIP_OPT + DIP_NORTP;</a>
<a name="ln2405">    arg = skipwhite(arg + len);</a>
<a name="ln2406">  } else if (STRNCMP(arg, &quot;PACK&quot;, len) == 0) {</a>
<a name="ln2407">    flags += DIP_START + DIP_OPT + DIP_NORTP;</a>
<a name="ln2408">    arg = skipwhite(arg + len);</a>
<a name="ln2409">  } else if (STRNCMP(arg, &quot;ALL&quot;, len) == 0) {</a>
<a name="ln2410">    flags += DIP_START + DIP_OPT;</a>
<a name="ln2411">    arg = skipwhite(arg + len);</a>
<a name="ln2412">  }</a>
<a name="ln2413"> </a>
<a name="ln2414">  source_runtime(arg, flags);</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417"> </a>
<a name="ln2418">static void source_callback(char_u *fname, void *cookie)</a>
<a name="ln2419">{</a>
<a name="ln2420">  (void)do_source(fname, false, DOSO_NONE);</a>
<a name="ln2421">}</a>
<a name="ln2422"> </a>
<a name="ln2423">/// Find the file &quot;name&quot; in all directories in &quot;path&quot; and invoke</a>
<a name="ln2424">/// &quot;callback(fname, cookie)&quot;.</a>
<a name="ln2425">/// &quot;name&quot; can contain wildcards.</a>
<a name="ln2426">/// When &quot;flags&quot; has DIP_ALL: source all files, otherwise only the first one.</a>
<a name="ln2427">/// When &quot;flags&quot; has DIP_DIR: find directories instead of files.</a>
<a name="ln2428">/// When &quot;flags&quot; has DIP_ERR: give an error message if there is no match.</a>
<a name="ln2429">///</a>
<a name="ln2430">/// return FAIL when no file could be sourced, OK otherwise.</a>
<a name="ln2431">int do_in_path(char_u *path, char_u *name, int flags,</a>
<a name="ln2432">               DoInRuntimepathCB callback, void *cookie)</a>
<a name="ln2433">{</a>
<a name="ln2434">  char_u      *tail;</a>
<a name="ln2435">  int num_files;</a>
<a name="ln2436">  char_u      **files;</a>
<a name="ln2437">  int i;</a>
<a name="ln2438">  bool did_one = false;</a>
<a name="ln2439"> </a>
<a name="ln2440">  // Make a copy of 'runtimepath'.  Invoking the callback may change the</a>
<a name="ln2441">  // value.</a>
<a name="ln2442">  char_u *rtp_copy = vim_strsave(path);</a>
<a name="ln2443">  char_u *buf = xmallocz(MAXPATHL);</a>
<a name="ln2444">  {</a>
<a name="ln2445">    if (p_verbose &gt; 10 &amp;&amp; name != NULL) {</a>
<a name="ln2446">      verbose_enter();</a>
<a name="ln2447">      smsg(_(&quot;Searching for \&quot;%s\&quot; in \&quot;%s\&quot;&quot;),</a>
<a name="ln2448">           (char *)name, (char *)path);</a>
<a name="ln2449">      verbose_leave();</a>
<a name="ln2450">    }</a>
<a name="ln2451"> </a>
<a name="ln2452">    // Loop over all entries in 'runtimepath'.</a>
<a name="ln2453">    char_u *rtp = rtp_copy;</a>
<a name="ln2454">    while (*rtp != NUL &amp;&amp; ((flags &amp; DIP_ALL) || !did_one)) {</a>
<a name="ln2455">      // Copy the path from 'runtimepath' to buf[].</a>
<a name="ln2456">      copy_option_part(&amp;rtp, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2457">      size_t buflen = STRLEN(buf);</a>
<a name="ln2458"> </a>
<a name="ln2459">      // Skip after or non-after directories.</a>
<a name="ln2460">      if (flags &amp; (DIP_NOAFTER | DIP_AFTER)) {</a>
<a name="ln2461">        bool is_after = buflen &gt;= 5</a>
<a name="ln2462">          &amp;&amp; STRCMP(buf + buflen - 5, &quot;after&quot;) == 0;</a>
<a name="ln2463"> </a>
<a name="ln2464">        if ((is_after &amp;&amp; (flags &amp; DIP_NOAFTER))</a>
<a name="ln2465">            || (!is_after &amp;&amp; (flags &amp; DIP_AFTER))) {</a>
<a name="ln2466">          continue;</a>
<a name="ln2467">        }</a>
<a name="ln2468">      }</a>
<a name="ln2469"> </a>
<a name="ln2470">      if (name == NULL) {</a>
<a name="ln2471">        (*callback)(buf, (void *)&amp;cookie);</a>
<a name="ln2472">        if (!did_one) {</a>
<a name="ln2473">          did_one = (cookie == NULL);</a>
<a name="ln2474">        }</a>
<a name="ln2475">      } else if (buflen + STRLEN(name) + 2 &lt; MAXPATHL) {</a>
<a name="ln2476">        add_pathsep((char *)buf);</a>
<a name="ln2477">        tail = buf + STRLEN(buf);</a>
<a name="ln2478"> </a>
<a name="ln2479">        // Loop over all patterns in &quot;name&quot;</a>
<a name="ln2480">        char_u *np = name;</a>
<a name="ln2481">        while (*np != NUL &amp;&amp; ((flags &amp; DIP_ALL) || !did_one)) {</a>
<a name="ln2482">          // Append the pattern from &quot;name&quot; to buf[].</a>
<a name="ln2483">          assert(MAXPATHL &gt;= (tail - buf));</a>
<a name="ln2484">          copy_option_part(&amp;np, tail, (size_t)(MAXPATHL - (tail - buf)),</a>
<a name="ln2485">                           &quot;\t &quot;);</a>
<a name="ln2486"> </a>
<a name="ln2487">          if (p_verbose &gt; 10) {</a>
<a name="ln2488">            verbose_enter();</a>
<a name="ln2489">            smsg(_(&quot;Searching for \&quot;%s\&quot;&quot;), buf);</a>
<a name="ln2490">            verbose_leave();</a>
<a name="ln2491">          }</a>
<a name="ln2492"> </a>
<a name="ln2493">          // Expand wildcards, invoke the callback for each match.</a>
<a name="ln2494">          if (gen_expand_wildcards(1, &amp;buf, &amp;num_files, &amp;files,</a>
<a name="ln2495">                                   (flags &amp; DIP_DIR) ? EW_DIR</a>
<a name="ln2496">                                                     : EW_FILE) == OK) {</a>
<a name="ln2497">            for (i = 0; i &lt; num_files; i++) {</a>
<a name="ln2498">              (*callback)(files[i], cookie);</a>
<a name="ln2499">              did_one = true;</a>
<a name="ln2500">              if (!(flags &amp; DIP_ALL)) {</a>
<a name="ln2501">                break;</a>
<a name="ln2502">              }</a>
<a name="ln2503">            }</a>
<a name="ln2504">            FreeWild(num_files, files);</a>
<a name="ln2505">          }</a>
<a name="ln2506">        }</a>
<a name="ln2507">      }</a>
<a name="ln2508">    }</a>
<a name="ln2509">  }</a>
<a name="ln2510">  xfree(buf);</a>
<a name="ln2511">  xfree(rtp_copy);</a>
<a name="ln2512">  if (!did_one &amp;&amp; name != NULL) {</a>
<a name="ln2513">    char *basepath = path == p_rtp ? &quot;runtimepath&quot; : &quot;packpath&quot;;</a>
<a name="ln2514"> </a>
<a name="ln2515">    if (flags &amp; DIP_ERR) {</a>
<a name="ln2516">      EMSG3(_(e_dirnotf), basepath, name);</a>
<a name="ln2517">    } else if (p_verbose &gt; 0) {</a>
<a name="ln2518">      verbose_enter();</a>
<a name="ln2519">      smsg(_(&quot;not found in '%s': \&quot;%s\&quot;&quot;), basepath, name);</a>
<a name="ln2520">      verbose_leave();</a>
<a name="ln2521">    }</a>
<a name="ln2522">  }</a>
<a name="ln2523"> </a>
<a name="ln2524"> </a>
<a name="ln2525">  return did_one ? OK : FAIL;</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">/// Find &quot;name&quot; in &quot;path&quot;.  When found, invoke the callback function for</a>
<a name="ln2529">/// it: callback(fname, &quot;cookie&quot;)</a>
<a name="ln2530">/// When &quot;flags&quot; has DIP_ALL repeat for all matches, otherwise only the first</a>
<a name="ln2531">/// one is used.</a>
<a name="ln2532">/// Returns OK when at least one match found, FAIL otherwise.</a>
<a name="ln2533">/// If &quot;name&quot; is NULL calls callback for each entry in &quot;path&quot;. Cookie is</a>
<a name="ln2534">/// passed by reference in this case, setting it to NULL indicates that callback</a>
<a name="ln2535">/// has done its job.</a>
<a name="ln2536">int do_in_path_and_pp(char_u *path, char_u *name, int flags,</a>
<a name="ln2537">                      DoInRuntimepathCB callback, void *cookie)</a>
<a name="ln2538">{</a>
<a name="ln2539">  int done = FAIL;</a>
<a name="ln2540"> </a>
<a name="ln2541">  if ((flags &amp; DIP_NORTP) == 0) {</a>
<a name="ln2542">    done = do_in_path(path, name, flags, callback, cookie);</a>
<a name="ln2543">  }</a>
<a name="ln2544"> </a>
<a name="ln2545">  if ((done == FAIL || (flags &amp; DIP_ALL)) &amp;&amp; (flags &amp; DIP_START)) {</a>
<a name="ln2546">    char *start_dir = &quot;pack/*/start/*/%s&quot;;  // NOLINT</a>
<a name="ln2547">    size_t len = STRLEN(start_dir) + STRLEN(name);</a>
<a name="ln2548">    char_u *s = xmallocz(len);</a>
<a name="ln2549"> </a>
<a name="ln2550">    vim_snprintf((char *)s, len, start_dir, name);</a>
<a name="ln2551">    done = do_in_path(p_pp, s, flags, callback, cookie);</a>
<a name="ln2552"> </a>
<a name="ln2553">    xfree(s);</a>
<a name="ln2554">  }</a>
<a name="ln2555"> </a>
<a name="ln2556">  if ((done == FAIL || (flags &amp; DIP_ALL)) &amp;&amp; (flags &amp; DIP_OPT)) {</a>
<a name="ln2557">    char *opt_dir = &quot;pack/*/opt/*/%s&quot;;  // NOLINT</a>
<a name="ln2558">    size_t len = STRLEN(opt_dir) + STRLEN(name);</a>
<a name="ln2559">    char_u *s = xmallocz(len);</a>
<a name="ln2560"> </a>
<a name="ln2561">    vim_snprintf((char *)s, len, opt_dir, name);</a>
<a name="ln2562">    done = do_in_path(p_pp, s, flags, callback, cookie);</a>
<a name="ln2563"> </a>
<a name="ln2564">    xfree(s);</a>
<a name="ln2565">  }</a>
<a name="ln2566"> </a>
<a name="ln2567">  return done;</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">/// Just like do_in_path_and_pp(), using 'runtimepath' for &quot;path&quot;.</a>
<a name="ln2571">int do_in_runtimepath(char_u *name, int flags, DoInRuntimepathCB callback,</a>
<a name="ln2572">                      void *cookie)</a>
<a name="ln2573">{</a>
<a name="ln2574">  return do_in_path_and_pp(p_rtp, name, flags, callback, cookie);</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577">/// Source the file &quot;name&quot; from all directories in 'runtimepath'.</a>
<a name="ln2578">/// &quot;name&quot; can contain wildcards.</a>
<a name="ln2579">/// When &quot;flags&quot; has DIP_ALL: source all files, otherwise only the first one.</a>
<a name="ln2580">///</a>
<a name="ln2581">/// return FAIL when no file could be sourced, OK otherwise.</a>
<a name="ln2582">int source_runtime(char_u *name, int flags)</a>
<a name="ln2583">{</a>
<a name="ln2584">  flags |= (flags &amp; DIP_NORTP) ? 0 : DIP_START;</a>
<a name="ln2585">  return source_in_path(p_rtp, name, flags);</a>
<a name="ln2586">}</a>
<a name="ln2587"> </a>
<a name="ln2588">/// Just like source_runtime(), but use &quot;path&quot; instead of 'runtimepath'.</a>
<a name="ln2589">int source_in_path(char_u *path, char_u *name, int flags)</a>
<a name="ln2590">{</a>
<a name="ln2591">  return do_in_path_and_pp(path, name, flags, source_callback, NULL);</a>
<a name="ln2592">}</a>
<a name="ln2593"> </a>
<a name="ln2594">// Expand wildcards in &quot;pat&quot; and invoke do_source() for each match.</a>
<a name="ln2595">static void source_all_matches(char_u *pat)</a>
<a name="ln2596">{</a>
<a name="ln2597">  int num_files;</a>
<a name="ln2598">  char_u **files;</a>
<a name="ln2599"> </a>
<a name="ln2600">  if (gen_expand_wildcards(1, &amp;pat, &amp;num_files, &amp;files, EW_FILE) == OK) {</a>
<a name="ln2601">    for (int i = 0; i &lt; num_files; i++) {</a>
<a name="ln2602">      (void)do_source(files[i], false, DOSO_NONE);</a>
<a name="ln2603">    }</a>
<a name="ln2604">    FreeWild(num_files, files);</a>
<a name="ln2605">  }</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">/// Add the package directory to 'runtimepath'</a>
<a name="ln2609">static int add_pack_dir_to_rtp(char_u *fname)</a>
<a name="ln2610">{</a>
<a name="ln2611">  char_u *p4, *p3, *p2, *p1, *p;</a>
<a name="ln2612">  char_u *buf = NULL;</a>
<a name="ln2613">  char *afterdir = NULL;</a>
<a name="ln2614">  int retval = FAIL;</a>
<a name="ln2615"> </a>
<a name="ln2616">  p4 = p3 = p2 = p1 = get_past_head(fname);</a>
<a name="ln2617">  for (p = p1; *p; MB_PTR_ADV(p)) {</a>
<a name="ln2618">    if (vim_ispathsep_nocolon(*p)) {</a>
<a name="ln2619">      p4 = p3; p3 = p2; p2 = p1; p1 = p;</a>
<a name="ln2620">    }</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  // now we have:</a>
<a name="ln2624">  // rtp/pack/name/start/name</a>
<a name="ln2625">  //    p4   p3   p2   p1</a>
<a name="ln2626">  //</a>
<a name="ln2627">  // find the part up to &quot;pack&quot; in 'runtimepath'</a>
<a name="ln2628">  p4++;  // append pathsep in order to expand symlink</a>
<a name="ln2629">  char_u c = *p4;</a>
<a name="ln2630">  *p4 = NUL;</a>
<a name="ln2631">  char *const ffname = fix_fname((char *)fname);</a>
<a name="ln2632">  *p4 = c;</a>
<a name="ln2633"> </a>
<a name="ln2634">  if (ffname == NULL) {</a>
<a name="ln2635">    return FAIL;</a>
<a name="ln2636">  }</a>
<a name="ln2637"> </a>
<a name="ln2638">  // Find &quot;ffname&quot; in &quot;p_rtp&quot;, ignoring '/' vs '\' differences</a>
<a name="ln2639">  // Also stop at the first &quot;after&quot; directory</a>
<a name="ln2640">  size_t fname_len = strlen(ffname);</a>
<a name="ln2641">  buf = try_malloc(MAXPATHL);</a>
<a name="ln2642">  if (buf == NULL) {</a>
<a name="ln2643">    goto theend;</a>
<a name="ln2644">  }</a>
<a name="ln2645">  const char *insp = NULL;</a>
<a name="ln2646">  const char *after_insp = NULL;</a>
<a name="ln2647">  for (const char *entry = (const char *)p_rtp; *entry != NUL; ) {</a>
<a name="ln2648">    const char *cur_entry = entry;</a>
<a name="ln2649"> </a>
<a name="ln2650">    copy_option_part((char_u **)&amp;entry, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2651">    if (insp == NULL) {</a>
<a name="ln2652">      add_pathsep((char *)buf);</a>
<a name="ln2653">      char *const rtp_ffname = fix_fname((char *)buf);</a>
<a name="ln2654">      if (rtp_ffname == NULL) {</a>
<a name="ln2655">        goto theend;</a>
<a name="ln2656">      }</a>
<a name="ln2657">      bool match = path_fnamencmp(rtp_ffname, ffname, fname_len) == 0;</a>
<a name="ln2658">      xfree(rtp_ffname);</a>
<a name="ln2659">      if (match) {</a>
<a name="ln2660">        // Insert &quot;ffname&quot; after this entry (and comma).</a>
<a name="ln2661">        insp = entry;</a>
<a name="ln2662">      }</a>
<a name="ln2663">    }</a>
<a name="ln2664"> </a>
<a name="ln2665">    if ((p = (char_u *)strstr((char *)buf, &quot;after&quot;)) != NULL</a>
<a name="ln2666">        &amp;&amp; p &gt; buf</a>
<a name="ln2667">        &amp;&amp; vim_ispathsep(p[-1])</a>
<a name="ln2668">        &amp;&amp; (vim_ispathsep(p[5]) || p[5] == NUL || p[5] == ',')) {</a>
<a name="ln2669">      if (insp == NULL) {</a>
<a name="ln2670">        // Did not find &quot;ffname&quot; before the first &quot;after&quot; directory,</a>
<a name="ln2671">        // insert it before this entry.</a>
<a name="ln2672">        insp = cur_entry;</a>
<a name="ln2673">      }</a>
<a name="ln2674">      after_insp = cur_entry;</a>
<a name="ln2675">      break;</a>
<a name="ln2676">    }</a>
<a name="ln2677">  }</a>
<a name="ln2678"> </a>
<a name="ln2679">  if (insp == NULL) {</a>
<a name="ln2680">    // Both &quot;fname&quot; and &quot;after&quot; not found, append at the end.</a>
<a name="ln2681">    insp = (const char *)p_rtp + STRLEN(p_rtp);</a>
<a name="ln2682">  }</a>
<a name="ln2683"> </a>
<a name="ln2684">  // check if rtp/pack/name/start/name/after exists</a>
<a name="ln2685">  afterdir = concat_fnames((char *)fname, &quot;after&quot;, true);</a>
<a name="ln2686">  size_t afterlen = 0;</a>
<a name="ln2687">  if (os_isdir((char_u *)afterdir)) {</a>
<a name="ln2688">    afterlen = strlen(afterdir) + 1;  // add one for comma</a>
<a name="ln2689">  }</a>
<a name="ln2690"> </a>
<a name="ln2691">  const size_t oldlen = STRLEN(p_rtp);</a>
<a name="ln2692">  const size_t addlen = STRLEN(fname) + 1;  // add one for comma</a>
<a name="ln2693">  const size_t new_rtp_capacity = oldlen + addlen + afterlen + 1;</a>
<a name="ln2694">  // add one for NUL ------------------------------------------^</a>
<a name="ln2695">  char *const new_rtp = try_malloc(new_rtp_capacity);</a>
<a name="ln2696">  if (new_rtp == NULL) {</a>
<a name="ln2697">    goto theend;</a>
<a name="ln2698">  }</a>
<a name="ln2699"> </a>
<a name="ln2700">  // We now have 'rtp' parts: {keep}{keep_after}{rest}.</a>
<a name="ln2701">  // Create new_rtp, first: {keep},{fname}</a>
<a name="ln2702">  size_t keep = (size_t)(insp - (const char *)p_rtp);</a>
<a name="ln2703">  memmove(new_rtp, p_rtp, keep);</a>
<a name="ln2704">  size_t new_rtp_len = keep;</a>
<a name="ln2705">  if (*insp == NUL) {</a>
<a name="ln2706">    new_rtp[new_rtp_len++] = ',';  // add comma before</a>
<a name="ln2707">  }</a>
<a name="ln2708">  memmove(new_rtp + new_rtp_len, fname, addlen - 1);</a>
<a name="ln2709">  new_rtp_len += addlen - 1;</a>
<a name="ln2710">  if (*insp != NUL) {</a>
<a name="ln2711">    new_rtp[new_rtp_len++] = ',';  // add comma after</a>
<a name="ln2712">  }</a>
<a name="ln2713"> </a>
<a name="ln2714">  if (afterlen &gt; 0 &amp;&amp; after_insp != NULL) {</a>
<a name="ln2715">    size_t keep_after = (size_t)(after_insp - (const char *)p_rtp);</a>
<a name="ln2716"> </a>
<a name="ln2717">    // Add to new_rtp: {keep},{fname}{keep_after},{afterdir}</a>
<a name="ln2718">    memmove(new_rtp + new_rtp_len, p_rtp + keep, keep_after - keep);</a>
<a name="ln2719">    new_rtp_len += keep_after - keep;</a>
<a name="ln2720">    memmove(new_rtp + new_rtp_len, afterdir, afterlen - 1);</a>
<a name="ln2721">    new_rtp_len += afterlen - 1;</a>
<a name="ln2722">    new_rtp[new_rtp_len++] = ',';</a>
<a name="ln2723">    keep = keep_after;</a>
<a name="ln2724">  }</a>
<a name="ln2725"> </a>
<a name="ln2726">  if (p_rtp[keep] != NUL) {</a>
<a name="ln2727">    // Append rest: {keep},{fname}{keep_after},{afterdir}{rest}</a>
<a name="ln2728">    memmove(new_rtp + new_rtp_len, p_rtp + keep, oldlen - keep + 1);</a>
<a name="ln2729">  } else {</a>
<a name="ln2730">    new_rtp[new_rtp_len] = NUL;</a>
<a name="ln2731">  }</a>
<a name="ln2732"> </a>
<a name="ln2733">  if (afterlen &gt; 0 &amp;&amp; after_insp == NULL) {</a>
<a name="ln2734">    // Append afterdir when &quot;after&quot; was not found:</a>
<a name="ln2735">    // {keep},{fname}{rest},{afterdir}</a>
<a name="ln2736">    xstrlcat(new_rtp, &quot;,&quot;, new_rtp_capacity);</a>
<a name="ln2737">    xstrlcat(new_rtp, afterdir, new_rtp_capacity);</a>
<a name="ln2738">  }</a>
<a name="ln2739"> </a>
<a name="ln2740">  set_option_value(&quot;rtp&quot;, 0L, new_rtp, 0);</a>
<a name="ln2741">  xfree(new_rtp);</a>
<a name="ln2742">  retval = OK;</a>
<a name="ln2743"> </a>
<a name="ln2744">theend:</a>
<a name="ln2745">  xfree(buf);</a>
<a name="ln2746">  xfree(ffname);</a>
<a name="ln2747">  xfree(afterdir);</a>
<a name="ln2748">  return retval;</a>
<a name="ln2749">}</a>
<a name="ln2750"> </a>
<a name="ln2751">/// Load scripts in &quot;plugin&quot; and &quot;ftdetect&quot; directories of the package.</a>
<a name="ln2752">static int load_pack_plugin(char_u *fname)</a>
<a name="ln2753">{</a>
<a name="ln2754">  static const char *plugpat = &quot;%s/plugin/**/*.vim&quot;;  // NOLINT</a>
<a name="ln2755">  static const char *ftpat = &quot;%s/ftdetect/*.vim&quot;;  // NOLINT</a>
<a name="ln2756"> </a>
<a name="ln2757">  int retval = FAIL;</a>
<a name="ln2758">  char *const ffname = fix_fname((char *)fname);</a>
<a name="ln2759">  size_t len = strlen(ffname) + STRLEN(ftpat);</a>
<a name="ln2760">  char_u *pat = try_malloc(len + 1);</a>
<a name="ln2761">  if (pat == NULL) {</a>
<a name="ln2762">    goto theend;</a>
<a name="ln2763">  }</a>
<a name="ln2764">  vim_snprintf((char *)pat, len, plugpat, ffname);</a>
<a name="ln2765">  source_all_matches(pat);</a>
<a name="ln2766"> </a>
<a name="ln2767">  char_u *cmd = vim_strsave((char_u *)&quot;g:did_load_filetypes&quot;);</a>
<a name="ln2768"> </a>
<a name="ln2769">  // If runtime/filetype.vim wasn't loaded yet, the scripts will be</a>
<a name="ln2770">  // found when it loads.</a>
<a name="ln2771">  if (eval_to_number(cmd) &gt; 0) {</a>
<a name="ln2772">    do_cmdline_cmd(&quot;augroup filetypedetect&quot;);</a>
<a name="ln2773">    vim_snprintf((char *)pat, len, ftpat, ffname);</a>
<a name="ln2774">    source_all_matches(pat);</a>
<a name="ln2775">    do_cmdline_cmd(&quot;augroup END&quot;);</a>
<a name="ln2776">  }</a>
<a name="ln2777">  xfree(cmd);</a>
<a name="ln2778">  xfree(pat);</a>
<a name="ln2779">  retval = OK;</a>
<a name="ln2780"> </a>
<a name="ln2781">theend:</a>
<a name="ln2782">  xfree(ffname);</a>
<a name="ln2783"> </a>
<a name="ln2784">  return retval;</a>
<a name="ln2785">}</a>
<a name="ln2786"> </a>
<a name="ln2787">// used for &quot;cookie&quot; of add_pack_plugin()</a>
<a name="ln2788">static int APP_ADD_DIR;</a>
<a name="ln2789">static int APP_LOAD;</a>
<a name="ln2790">static int APP_BOTH;</a>
<a name="ln2791"> </a>
<a name="ln2792">static void add_pack_plugin(char_u *fname, void *cookie)</a>
<a name="ln2793">{</a>
<a name="ln2794">  if (cookie != &amp;APP_LOAD) {</a>
<a name="ln2795">    char *buf = xmalloc(MAXPATHL);</a>
<a name="ln2796">    bool found = false;</a>
<a name="ln2797"> </a>
<a name="ln2798">    const char *p = (const char *)p_rtp;</a>
<a name="ln2799">    while (*p != NUL) {</a>
<a name="ln2800">      copy_option_part((char_u **)&amp;p, (char_u *)buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2801">      if (path_fnamecmp(buf, (char *)fname) == 0) {</a>
<a name="ln2802">        found = true;</a>
<a name="ln2803">        break;</a>
<a name="ln2804">      }</a>
<a name="ln2805">    }</a>
<a name="ln2806">    xfree(buf);</a>
<a name="ln2807">    if (!found) {</a>
<a name="ln2808">      // directory is not yet in 'runtimepath', add it</a>
<a name="ln2809">      if (add_pack_dir_to_rtp(fname) == FAIL) {</a>
<a name="ln2810">        return;</a>
<a name="ln2811">      }</a>
<a name="ln2812">    }</a>
<a name="ln2813">  }</a>
<a name="ln2814"> </a>
<a name="ln2815">  if (cookie != &amp;APP_ADD_DIR) {</a>
<a name="ln2816">    load_pack_plugin(fname);</a>
<a name="ln2817">  }</a>
<a name="ln2818">}</a>
<a name="ln2819"> </a>
<a name="ln2820">/// Add all packages in the &quot;start&quot; directory to 'runtimepath'.</a>
<a name="ln2821">void add_pack_start_dirs(void)</a>
<a name="ln2822">{</a>
<a name="ln2823">  do_in_path(p_pp, (char_u *)&quot;pack/*/start/*&quot;, DIP_ALL + DIP_DIR,  // NOLINT</a>
<a name="ln2824">             add_pack_plugin, &amp;APP_ADD_DIR);</a>
<a name="ln2825">}</a>
<a name="ln2826"> </a>
<a name="ln2827">/// Load plugins from all packages in the &quot;start&quot; directory.</a>
<a name="ln2828">void load_start_packages(void)</a>
<a name="ln2829">{</a>
<a name="ln2830">  did_source_packages = true;</a>
<a name="ln2831">  do_in_path(p_pp, (char_u *)&quot;pack/*/start/*&quot;, DIP_ALL + DIP_DIR,  // NOLINT</a>
<a name="ln2832">             add_pack_plugin, &amp;APP_LOAD);</a>
<a name="ln2833">}</a>
<a name="ln2834"> </a>
<a name="ln2835">// &quot;:packloadall&quot;</a>
<a name="ln2836">// Find plugins in the package directories and source them.</a>
<a name="ln2837">void ex_packloadall(exarg_T *eap)</a>
<a name="ln2838">{</a>
<a name="ln2839">  if (!did_source_packages || eap-&gt;forceit) {</a>
<a name="ln2840">    // First do a round to add all directories to 'runtimepath', then load</a>
<a name="ln2841">    // the plugins. This allows for plugins to use an autoload directory</a>
<a name="ln2842">    // of another plugin.</a>
<a name="ln2843">    add_pack_start_dirs();</a>
<a name="ln2844">    load_start_packages();</a>
<a name="ln2845">  }</a>
<a name="ln2846">}</a>
<a name="ln2847"> </a>
<a name="ln2848">/// &quot;:packadd[!] {name}&quot;</a>
<a name="ln2849">void ex_packadd(exarg_T *eap)</a>
<a name="ln2850">{</a>
<a name="ln2851">  static const char *plugpat = &quot;pack/*/%s/%s&quot;;    // NOLINT</a>
<a name="ln2852">  int res = OK;</a>
<a name="ln2853"> </a>
<a name="ln2854">  // Round 1: use &quot;start&quot;, round 2: use &quot;opt&quot;.</a>
<a name="ln2855">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln2856">    // Only look under &quot;start&quot; when loading packages wasn't done yet.</a>
<a name="ln2857">    if (round == 1 &amp;&amp; did_source_packages) {</a>
<a name="ln2858">      continue;</a>
<a name="ln2859">    }</a>
<a name="ln2860"> </a>
<a name="ln2861">    const size_t len = STRLEN(plugpat) + STRLEN(eap-&gt;arg) + 5;</a>
<a name="ln2862">    char *pat = xmallocz(len);</a>
<a name="ln2863">    vim_snprintf(pat, len, plugpat, round == 1 ? &quot;start&quot; : &quot;opt&quot;, eap-&gt;arg);</a>
<a name="ln2864">    // The first round don't give a &quot;not found&quot; error, in the second round</a>
<a name="ln2865">    // only when nothing was found in the first round.</a>
<a name="ln2866">    res = do_in_path(p_pp, (char_u *)pat,</a>
<a name="ln2867">                     DIP_ALL + DIP_DIR</a>
<a name="ln2868">                     + (round == 2 &amp;&amp; res == FAIL ? DIP_ERR : 0),</a>
<a name="ln2869">                     add_pack_plugin, eap-&gt;forceit ? &amp;APP_ADD_DIR : &amp;APP_BOTH);</a>
<a name="ln2870">    xfree(pat);</a>
<a name="ln2871">  }</a>
<a name="ln2872">}</a>
<a name="ln2873"> </a>
<a name="ln2874">/// &quot;:options&quot;</a>
<a name="ln2875">void ex_options(exarg_T *eap)</a>
<a name="ln2876">{</a>
<a name="ln2877">  os_setenv(&quot;OPTWIN_CMD&quot;, cmdmod.tab ? &quot;tab&quot; : &quot;&quot;, 1);</a>
<a name="ln2878">  os_setenv(&quot;OPTWIN_CMD&quot;,</a>
<a name="ln2879">            cmdmod.tab ? &quot;tab&quot; :</a>
<a name="ln2880">            (cmdmod.split &amp; WSP_VERT) ? &quot;vert&quot; : &quot;&quot;, 1);</a>
<a name="ln2881">  cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);</a>
<a name="ln2882">}</a>
<a name="ln2883"> </a>
<a name="ln2884">// Detect Python 3 or 2, and initialize 'pyxversion'.</a>
<a name="ln2885">void init_pyxversion(void)</a>
<a name="ln2886">{</a>
<a name="ln2887">  if (p_pyx == 0) {</a>
<a name="ln2888">    if (eval_has_provider(&quot;python3&quot;)) {</a>
<a name="ln2889">      p_pyx = 3;</a>
<a name="ln2890">    } else if (eval_has_provider(&quot;python&quot;)) {</a>
<a name="ln2891">      p_pyx = 2;</a>
<a name="ln2892">    }</a>
<a name="ln2893">  }</a>
<a name="ln2894">}</a>
<a name="ln2895"> </a>
<a name="ln2896">// Does a file contain one of the following strings at the beginning of any</a>
<a name="ln2897">// line?</a>
<a name="ln2898">// &quot;#!(any string)python2&quot;  =&gt; returns 2</a>
<a name="ln2899">// &quot;#!(any string)python3&quot;  =&gt; returns 3</a>
<a name="ln2900">// &quot;# requires python 2.x&quot;  =&gt; returns 2</a>
<a name="ln2901">// &quot;# requires python 3.x&quot;  =&gt; returns 3</a>
<a name="ln2902">// otherwise return 0.</a>
<a name="ln2903">static int requires_py_version(char_u *filename)</a>
<a name="ln2904">{</a>
<a name="ln2905">  FILE      *file;</a>
<a name="ln2906">  int       requires_py_version = 0;</a>
<a name="ln2907">  int       i, lines;</a>
<a name="ln2908"> </a>
<a name="ln2909">  lines = (int)p_mls;</a>
<a name="ln2910">  if (lines &lt; 0) {</a>
<a name="ln2911">    lines = 5;</a>
<a name="ln2912">  }</a>
<a name="ln2913"> </a>
<a name="ln2914">  file = os_fopen((char *)filename, &quot;r&quot;);</a>
<a name="ln2915">  if (file != NULL) {</a>
<a name="ln2916">    for (i = 0; i &lt; lines; i++) {</a>
<a name="ln2917">      if (vim_fgets(IObuff, IOSIZE, file)) {</a>
<a name="ln2918">        break;</a>
<a name="ln2919">      }</a>
<a name="ln2920">      if (i == 0 &amp;&amp; IObuff[0] == '#' &amp;&amp; IObuff[1] == '!') {</a>
<a name="ln2921">        // Check shebang.</a>
<a name="ln2922">        if (strstr((char *)IObuff + 2, &quot;python2&quot;) != NULL) {</a>
<a name="ln2923">          requires_py_version = 2;</a>
<a name="ln2924">          break;</a>
<a name="ln2925">        }</a>
<a name="ln2926">        if (strstr((char *)IObuff + 2, &quot;python3&quot;) != NULL) {</a>
<a name="ln2927">          requires_py_version = 3;</a>
<a name="ln2928">          break;</a>
<a name="ln2929">        }</a>
<a name="ln2930">      }</a>
<a name="ln2931">      IObuff[21] = '\0';</a>
<a name="ln2932">      if (STRCMP(&quot;# requires python 2.x&quot;, IObuff) == 0) {</a>
<a name="ln2933">        requires_py_version = 2;</a>
<a name="ln2934">        break;</a>
<a name="ln2935">      }</a>
<a name="ln2936">      if (STRCMP(&quot;# requires python 3.x&quot;, IObuff) == 0) {</a>
<a name="ln2937">        requires_py_version = 3;</a>
<a name="ln2938">        break;</a>
<a name="ln2939">      }</a>
<a name="ln2940">    }</a>
<a name="ln2941">    fclose(file);</a>
<a name="ln2942">  }</a>
<a name="ln2943">  return requires_py_version;</a>
<a name="ln2944">}</a>
<a name="ln2945"> </a>
<a name="ln2946"> </a>
<a name="ln2947">// Source a python file using the requested python version.</a>
<a name="ln2948">static void source_pyx_file(exarg_T *eap, char_u *fname)</a>
<a name="ln2949">{</a>
<a name="ln2950">  exarg_T ex;</a>
<a name="ln2951">  long int v = requires_py_version(fname);</a>
<a name="ln2952"> </a>
<a name="ln2953">  init_pyxversion();</a>
<a name="ln2954">  if (v == 0) {</a>
<a name="ln2955">    // user didn't choose a preference, 'pyx' is used</a>
<a name="ln2956">    v = p_pyx;</a>
<a name="ln2957">  }</a>
<a name="ln2958"> </a>
<a name="ln2959">  // now source, if required python version is not supported show</a>
<a name="ln2960">  // unobtrusive message.</a>
<a name="ln2961">  if (eap == NULL) {</a>
<a name="ln2962">    memset(&amp;ex, 0, sizeof(ex));</a>
<a name="ln2963">  } else {</a>
<a name="ln2964">    ex = *eap;</a>
<a name="ln2965">  }</a>
<a name="ln2966">  ex.arg = fname;</a>
<a name="ln2967">  ex.cmd = (char_u *)(v == 2 ? &quot;pyfile&quot; : &quot;pyfile3&quot;);</a>
<a name="ln2968"> </a>
<a name="ln2969">  if (v == 2) {</a>
<a name="ln2970">    ex_pyfile(&amp;ex);</a>
<a name="ln2971">  } else {</a>
<a name="ln2972">    ex_py3file(&amp;ex);</a>
<a name="ln2973">  }</a>
<a name="ln2974">}</a>
<a name="ln2975"> </a>
<a name="ln2976">// &quot;:pyxfile {fname}&quot;</a>
<a name="ln2977">void ex_pyxfile(exarg_T *eap)</a>
<a name="ln2978">{</a>
<a name="ln2979">  source_pyx_file(eap, eap-&gt;arg);</a>
<a name="ln2980">}</a>
<a name="ln2981"> </a>
<a name="ln2982">// &quot;:pyx&quot;</a>
<a name="ln2983">void ex_pyx(exarg_T *eap)</a>
<a name="ln2984">{</a>
<a name="ln2985">  init_pyxversion();</a>
<a name="ln2986">  if (p_pyx == 2) {</a>
<a name="ln2987">    ex_python(eap);</a>
<a name="ln2988">  } else {</a>
<a name="ln2989">    ex_python3(eap);</a>
<a name="ln2990">  }</a>
<a name="ln2991">}</a>
<a name="ln2992"> </a>
<a name="ln2993">// &quot;:pyxdo&quot;</a>
<a name="ln2994">void ex_pyxdo(exarg_T *eap)</a>
<a name="ln2995">{</a>
<a name="ln2996">  init_pyxversion();</a>
<a name="ln2997">  if (p_pyx == 2) {</a>
<a name="ln2998">    ex_pydo(eap);</a>
<a name="ln2999">  } else {</a>
<a name="ln3000">    ex_pydo3(eap);</a>
<a name="ln3001">  }</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004">/// &quot;:source {fname}&quot;</a>
<a name="ln3005">void ex_source(exarg_T *eap)</a>
<a name="ln3006">{</a>
<a name="ln3007">  cmd_source(eap-&gt;arg, eap);</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010">static void cmd_source(char_u *fname, exarg_T *eap)</a>
<a name="ln3011">{</a>
<a name="ln3012">  if (*fname == NUL) {</a>
<a name="ln3013">    EMSG(_(e_argreq));</a>
<a name="ln3014">  } else if (eap != NULL &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln3015">    // &quot;:source!&quot;: read Normal mode commands</a>
<a name="ln3016">    // Need to execute the commands directly.  This is required at least</a>
<a name="ln3017">    // for:</a>
<a name="ln3018">    // - &quot;:g&quot; command busy</a>
<a name="ln3019">    // - after &quot;:argdo&quot;, &quot;:windo&quot; or &quot;:bufdo&quot;</a>
<a name="ln3020">    // - another command follows</a>
<a name="ln3021">    // - inside a loop</a>
<a name="ln3022">    openscript(fname, global_busy || listcmd_busy || eap-&gt;nextcmd != NULL</a>
<a name="ln3023">               || eap-&gt;cstack-&gt;cs_idx &gt;= 0);</a>
<a name="ln3024"> </a>
<a name="ln3025">    // &quot;:source&quot; read ex commands</a>
<a name="ln3026">  } else if (do_source(fname, false, DOSO_NONE) == FAIL) {</a>
<a name="ln3027">    EMSG2(_(e_notopen), fname);</a>
<a name="ln3028">  }</a>
<a name="ln3029">}</a>
<a name="ln3030"> </a>
<a name="ln3031">/// &quot;:source&quot; and associated commands.</a>
<a name="ln3032">///</a>
<a name="ln3033">/// @return address holding the next breakpoint line for a source cookie</a>
<a name="ln3034">linenr_T *source_breakpoint(void *cookie)</a>
<a name="ln3035">{</a>
<a name="ln3036">  return &amp;((struct source_cookie *)cookie)-&gt;breakpoint;</a>
<a name="ln3037">}</a>
<a name="ln3038"> </a>
<a name="ln3039">/// Return the address holding the debug tick for a source cookie.</a>
<a name="ln3040">int *source_dbg_tick(void *cookie)</a>
<a name="ln3041">{</a>
<a name="ln3042">  return &amp;((struct source_cookie *)cookie)-&gt;dbg_tick;</a>
<a name="ln3043">}</a>
<a name="ln3044"> </a>
<a name="ln3045">/// Return the nesting level for a source cookie.</a>
<a name="ln3046">int source_level(void *cookie)</a>
<a name="ln3047">{</a>
<a name="ln3048">  return ((struct source_cookie *)cookie)-&gt;level;</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051">/// Special function to open a file without handle inheritance.</a>
<a name="ln3052">/// If possible the handle is closed on exec().</a>
<a name="ln3053">static FILE *fopen_noinh_readbin(char *filename)</a>
<a name="ln3054">{</a>
<a name="ln3055">#ifdef WIN32</a>
<a name="ln3056">  int fd_tmp = os_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);</a>
<a name="ln3057">#else</a>
<a name="ln3058">  int fd_tmp = os_open(filename, O_RDONLY, 0);</a>
<a name="ln3059">#endif</a>
<a name="ln3060"> </a>
<a name="ln3061">  if (fd_tmp &lt; 0) {</a>
<a name="ln3062">    return NULL;</a>
<a name="ln3063">  }</a>
<a name="ln3064"> </a>
<a name="ln3065">  (void)os_set_cloexec(fd_tmp);</a>
<a name="ln3066"> </a>
<a name="ln3067">  return fdopen(fd_tmp, READBIN);</a>
<a name="ln3068">}</a>
<a name="ln3069"> </a>
<a name="ln3070">typedef struct {</a>
<a name="ln3071">  char_u *buf;</a>
<a name="ln3072">  size_t offset;</a>
<a name="ln3073">} GetStrLineCookie;</a>
<a name="ln3074"> </a>
<a name="ln3075">/// Get one full line from a sourced string (in-memory, no file).</a>
<a name="ln3076">/// Called by do_cmdline() when it's called from do_source_str().</a>
<a name="ln3077">///</a>
<a name="ln3078">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln3079">///         some error.</a>
<a name="ln3080">static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3081">{</a>
<a name="ln3082">  GetStrLineCookie *p = cookie;</a>
<a name="ln3083">  size_t i = p-&gt;offset;</a>
<a name="ln3084">  if (strlen((char *)p-&gt;buf) &lt;= p-&gt;offset) {</a>
<a name="ln3085">    return NULL;</a>
<a name="ln3086">  }</a>
<a name="ln3087">  while (!(p-&gt;buf[i] == '\n' || p-&gt;buf[i] == '\0')) {</a>
<a name="ln3088">    i++;</a>
<a name="ln3089">  }</a>
<a name="ln3090">  char buf[2046];</a>
<a name="ln3091">  char *dst;</a>
<a name="ln3092">  dst = xstpncpy(buf, (char *)p-&gt;buf + p-&gt;offset, i - p-&gt;offset);</a>
<a name="ln3093">  if ((uint32_t)(dst - buf) != i - p-&gt;offset) {</a>
<a name="ln3094">    smsg(_(&quot;:source error parsing command %s&quot;), p-&gt;buf);</a>
<a name="ln3095">    return NULL;</a>
<a name="ln3096">  }</a>
<a name="ln3097">  buf[i - p-&gt;offset] = '\0';</a>
<a name="ln3098">  p-&gt;offset = i + 1;</a>
<a name="ln3099">  return (char_u *)xstrdup(buf);</a>
<a name="ln3100">}</a>
<a name="ln3101"> </a>
<a name="ln3102">/// Executes lines in `src` as Ex commands.</a>
<a name="ln3103">///</a>
<a name="ln3104">/// @see do_source()</a>
<a name="ln3105">int do_source_str(const char *cmd, const char *traceback_name)</a>
<a name="ln3106">{</a>
<a name="ln3107">  char_u *save_sourcing_name = sourcing_name;</a>
<a name="ln3108">  linenr_T save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln3109">  char_u sourcing_name_buf[256];</a>
<a name="ln3110">  if (save_sourcing_name == NULL) {</a>
<a name="ln3111">    sourcing_name = (char_u *)traceback_name;</a>
<a name="ln3112">  } else {</a>
<a name="ln3113">    snprintf((char *)sourcing_name_buf, sizeof(sourcing_name_buf),</a>
<a name="ln3114">             &quot;%s called at %s:%&quot;PRIdLINENR, traceback_name, save_sourcing_name,</a>
<a name="ln3115">             save_sourcing_lnum);</a>
<a name="ln3116">    sourcing_name = sourcing_name_buf;</a>
<a name="ln3117">  }</a>
<a name="ln3118">  sourcing_lnum = 0;</a>
<a name="ln3119"> </a>
<a name="ln3120">  GetStrLineCookie cookie = {</a>
<a name="ln3121">    .buf = (char_u *)cmd,</a>
<a name="ln3122">    .offset = 0,</a>
<a name="ln3123">  };</a>
<a name="ln3124">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln3125">  current_sctx.sc_sid = SID_STR;</a>
<a name="ln3126">  current_sctx.sc_seq = 0;</a>
<a name="ln3127">  current_sctx.sc_lnum = save_sourcing_lnum;</a>
<a name="ln3128">  int retval = do_cmdline(NULL, get_str_line, (void *)&amp;cookie,</a>
<a name="ln3129">                          DOCMD_VERBOSE | DOCMD_NOWAIT | DOCMD_REPEAT);</a>
<a name="ln3130">  current_sctx = save_current_sctx;</a>
<a name="ln3131">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln3132">  sourcing_name = save_sourcing_name;</a>
<a name="ln3133">  return retval;</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136">/// Reads the file `fname` and executes its lines as Ex commands.</a>
<a name="ln3137">///</a>
<a name="ln3138">/// This function may be called recursively!</a>
<a name="ln3139">///</a>
<a name="ln3140">/// @see do_source_str</a>
<a name="ln3141">///</a>
<a name="ln3142">/// @param fname</a>
<a name="ln3143">/// @param check_other  check for .vimrc and _vimrc</a>
<a name="ln3144">/// @param is_vimrc     DOSO_ value</a>
<a name="ln3145">///</a>
<a name="ln3146">/// @return FAIL if file could not be opened, OK otherwise</a>
<a name="ln3147">int do_source(char_u *fname, int check_other, int is_vimrc)</a>
<a name="ln3148">{</a>
<a name="ln3149">  struct source_cookie cookie;</a>
<a name="ln3150">  char_u                  *save_sourcing_name;</a>
<a name="ln3151">  linenr_T save_sourcing_lnum;</a>
<a name="ln3152">  char_u                  *p;</a>
<a name="ln3153">  char_u                  *fname_exp;</a>
<a name="ln3154">  char_u                  *firstline = NULL;</a>
<a name="ln3155">  int retval = FAIL;</a>
<a name="ln3156">  static scid_T last_current_SID = 0;</a>
<a name="ln3157">  static int last_current_SID_seq = 0;</a>
<a name="ln3158">  int save_debug_break_level = debug_break_level;</a>
<a name="ln3159">  scriptitem_T            *si = NULL;</a>
<a name="ln3160">  proftime_T wait_start;</a>
<a name="ln3161">  bool trigger_source_post = false;</a>
<a name="ln3162"> </a>
<a name="ln3163">  p = expand_env_save(fname);</a>
<a name="ln3164">  if (p == NULL) {</a>
<a name="ln3165">    return retval;</a>
<a name="ln3166">  }</a>
<a name="ln3167">  fname_exp = (char_u *)fix_fname((char *)p);</a>
<a name="ln3168">  xfree(p);</a>
<a name="ln3169">  if (fname_exp == NULL) {</a>
<a name="ln3170">    return retval;</a>
<a name="ln3171">  }</a>
<a name="ln3172">  if (os_isdir(fname_exp)) {</a>
<a name="ln3173">    smsg(_(&quot;Cannot source a directory: \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln3174">    goto theend;</a>
<a name="ln3175">  }</a>
<a name="ln3176"> </a>
<a name="ln3177">  // Apply SourceCmd autocommands, they should get the file and source it.</a>
<a name="ln3178">  if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)</a>
<a name="ln3179">      &amp;&amp; apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,</a>
<a name="ln3180">                        false, curbuf)) {</a>
<a name="ln3181">    retval = aborting() ? FAIL : OK;</a>
<a name="ln3182">    if (retval == OK) {</a>
<a name="ln3183">      // Apply SourcePost autocommands.</a>
<a name="ln3184">      apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln3185">    }</a>
<a name="ln3186">    goto theend;</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189">  // Apply SourcePre autocommands, they may get the file.</a>
<a name="ln3190">  apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln3191"> </a>
<a name="ln3192">  cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln3193">  if (cookie.fp == NULL &amp;&amp; check_other) {</a>
<a name="ln3194">    // Try again, replacing file name &quot;.vimrc&quot; by &quot;_vimrc&quot; or vice versa,</a>
<a name="ln3195">    // and &quot;.exrc&quot; by &quot;_exrc&quot; or vice versa.</a>
<a name="ln3196">    p = path_tail(fname_exp);</a>
<a name="ln3197">    if ((*p == '.' || *p == '_')</a>
<a name="ln3198">        &amp;&amp; (STRICMP(p + 1, &quot;nvimrc&quot;) == 0 || STRICMP(p + 1, &quot;exrc&quot;) == 0)) {</a>
<a name="ln3199">      *p = (*p == '_') ? '.' : '_';</a>
<a name="ln3200">      cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln3201">    }</a>
<a name="ln3202">  }</a>
<a name="ln3203"> </a>
<a name="ln3204">  if (cookie.fp == NULL) {</a>
<a name="ln3205">    if (p_verbose &gt; 0) {</a>
<a name="ln3206">      verbose_enter();</a>
<a name="ln3207">      if (sourcing_name == NULL) {</a>
<a name="ln3208">        smsg(_(&quot;could not source \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln3209">      } else {</a>
<a name="ln3210">        smsg(_(&quot;line %&quot; PRId64 &quot;: could not source \&quot;%s\&quot;&quot;),</a>
<a name="ln3211">             (int64_t)sourcing_lnum, fname);</a>
<a name="ln3212">      }</a>
<a name="ln3213">      verbose_leave();</a>
<a name="ln3214">    }</a>
<a name="ln3215">    goto theend;</a>
<a name="ln3216">  }</a>
<a name="ln3217"> </a>
<a name="ln3218">  // The file exists.</a>
<a name="ln3219">  // - In verbose mode, give a message.</a>
<a name="ln3220">  // - For a vimrc file, may want to call vimrc_found().</a>
<a name="ln3221">  if (p_verbose &gt; 1) {</a>
<a name="ln3222">    verbose_enter();</a>
<a name="ln3223">    if (sourcing_name == NULL) {</a>
<a name="ln3224">      smsg(_(&quot;sourcing \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln3225">    } else {</a>
<a name="ln3226">      smsg(_(&quot;line %&quot; PRId64 &quot;: sourcing \&quot;%s\&quot;&quot;),</a>
<a name="ln3227">           (int64_t)sourcing_lnum, fname);</a>
<a name="ln3228">    }</a>
<a name="ln3229">    verbose_leave();</a>
<a name="ln3230">  }</a>
<a name="ln3231">  if (is_vimrc == DOSO_VIMRC) {</a>
<a name="ln3232">    vimrc_found(fname_exp, (char_u *)&quot;MYVIMRC&quot;);</a>
<a name="ln3233">  }</a>
<a name="ln3234"> </a>
<a name="ln3235">#ifdef USE_CRNL</a>
<a name="ln3236">  // If no automatic file format: Set default to CR-NL.</a>
<a name="ln3237">  if (*p_ffs == NUL) {</a>
<a name="ln3238">    cookie.fileformat = EOL_DOS;</a>
<a name="ln3239">  } else {</a>
<a name="ln3240">    cookie.fileformat = EOL_UNKNOWN;</a>
<a name="ln3241">  }</a>
<a name="ln3242">  cookie.error = false;</a>
<a name="ln3243">#endif</a>
<a name="ln3244"> </a>
<a name="ln3245">  cookie.nextline = NULL;</a>
<a name="ln3246">  cookie.sourcing_lnum = 0;</a>
<a name="ln3247">  cookie.finished = false;</a>
<a name="ln3248"> </a>
<a name="ln3249">  // Check if this script has a breakpoint.</a>
<a name="ln3250">  cookie.breakpoint = dbg_find_breakpoint(true, fname_exp, (linenr_T)0);</a>
<a name="ln3251">  cookie.fname = fname_exp;</a>
<a name="ln3252">  cookie.dbg_tick = debug_tick;</a>
<a name="ln3253"> </a>
<a name="ln3254">  cookie.level = ex_nesting_level;</a>
<a name="ln3255"> </a>
<a name="ln3256">  // Keep the sourcing name/lnum, for recursive calls.</a>
<a name="ln3257">  save_sourcing_name = sourcing_name;</a>
<a name="ln3258">  sourcing_name = fname_exp;</a>
<a name="ln3259">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln3260">  sourcing_lnum = 0;</a>
<a name="ln3261"> </a>
<a name="ln3262">  // start measuring script load time if --startuptime was passed and</a>
<a name="ln3263">  // time_fd was successfully opened afterwards.</a>
<a name="ln3264">  proftime_T rel_time;</a>
<a name="ln3265">  proftime_T start_time;</a>
<a name="ln3266">  FILE * const l_time_fd = time_fd;</a>
<a name="ln3267">  if (l_time_fd != NULL) {</a>
<a name="ln3268">    time_push(&amp;rel_time, &amp;start_time);</a>
<a name="ln3269">  }</a>
<a name="ln3270"> </a>
<a name="ln3271">  const int l_do_profiling = do_profiling;</a>
<a name="ln3272">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3273">    prof_child_enter(&amp;wait_start);    // entering a child now</a>
<a name="ln3274">  }</a>
<a name="ln3275"> </a>
<a name="ln3276">  // Don't use local function variables, if called from a function.</a>
<a name="ln3277">  // Also starts profiling timer for nested script.</a>
<a name="ln3278">  funccal_entry_T funccalp_entry;</a>
<a name="ln3279">  save_funccal(&amp;funccalp_entry);</a>
<a name="ln3280"> </a>
<a name="ln3281">  // Check if this script was sourced before to finds its SID.</a>
<a name="ln3282">  // If it's new, generate a new SID.</a>
<a name="ln3283">  // Always use a new sequence number.</a>
<a name="ln3284">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln3285">  current_sctx.sc_seq = ++last_current_SID_seq;</a>
<a name="ln3286">  current_sctx.sc_lnum = 0;</a>
<a name="ln3287">  FileID file_id;</a>
<a name="ln3288">  bool file_id_ok = os_fileid((char *)fname_exp, &amp;file_id);</a>
<a name="ln3289">  assert(script_items.ga_len &gt;= 0);</a>
<a name="ln3290">  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid &gt; 0;</a>
<a name="ln3291">       current_sctx.sc_sid--) {</a>
<a name="ln3292">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3293">    // Compare dev/ino when possible, it catches symbolic links.</a>
<a name="ln3294">    // Also compare file names, the inode may change when the file was edited.</a>
<a name="ln3295">    bool file_id_equal = file_id_ok &amp;&amp; si-&gt;file_id_valid</a>
<a name="ln3296">                         &amp;&amp; os_fileid_equal(&amp;(si-&gt;file_id), &amp;file_id);</a>
<a name="ln3297">    if (si-&gt;sn_name != NULL</a>
<a name="ln3298">        &amp;&amp; (file_id_equal || fnamecmp(si-&gt;sn_name, fname_exp) == 0)) {</a>
<a name="ln3299">      break;</a>
<a name="ln3300">    }</a>
<a name="ln3301">  }</a>
<a name="ln3302">  if (current_sctx.sc_sid == 0) {</a>
<a name="ln3303">    current_sctx.sc_sid = ++last_current_SID;</a>
<a name="ln3304">    ga_grow(&amp;script_items, (int)(current_sctx.sc_sid - script_items.ga_len));</a>
<a name="ln3305">    while (script_items.ga_len &lt; current_sctx.sc_sid) {</a>
<a name="ln3306">      script_items.ga_len++;</a>
<a name="ln3307">      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;</a>
<a name="ln3308">      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;</a>
<a name="ln3309">    }</a>
<a name="ln3310">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3311">    si-&gt;sn_name = fname_exp;</a>
<a name="ln3312">    fname_exp = vim_strsave(si-&gt;sn_name);  // used for autocmd</a>
<a name="ln3313">    if (file_id_ok) {</a>
<a name="ln3314">      si-&gt;file_id_valid = true;</a>
<a name="ln3315">      si-&gt;file_id = file_id;</a>
<a name="ln3316">    } else {</a>
<a name="ln3317">      si-&gt;file_id_valid = false;</a>
<a name="ln3318">    }</a>
<a name="ln3319"> </a>
<a name="ln3320">    // Allocate the local script variables to use for this script.</a>
<a name="ln3321">    new_script_vars(current_sctx.sc_sid);</a>
<a name="ln3322">  }</a>
<a name="ln3323"> </a>
<a name="ln3324">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3325">    bool forceit;</a>
<a name="ln3326"> </a>
<a name="ln3327">    // Check if we do profiling for this script.</a>
<a name="ln3328">    if (!si-&gt;sn_prof_on &amp;&amp; has_profiling(true, si-&gt;sn_name, &amp;forceit)) {</a>
<a name="ln3329">      profile_init(si);</a>
<a name="ln3330">      si-&gt;sn_pr_force = forceit;</a>
<a name="ln3331">    }</a>
<a name="ln3332">    if (si-&gt;sn_prof_on) {</a>
<a name="ln3333">      si-&gt;sn_pr_count++;</a>
<a name="ln3334">      si-&gt;sn_pr_start = profile_start();</a>
<a name="ln3335">      si-&gt;sn_pr_children = profile_zero();</a>
<a name="ln3336">    }</a>
<a name="ln3337">  }</a>
<a name="ln3338"> </a>
<a name="ln3339">  cookie.conv.vc_type = CONV_NONE;              // no conversion</a>
<a name="ln3340"> </a>
<a name="ln3341">  // Read the first line so we can check for a UTF-8 BOM.</a>
<a name="ln3342">  firstline = getsourceline(0, (void *)&amp;cookie, 0, true);</a>
<a name="ln3343">  if (firstline != NULL &amp;&amp; STRLEN(firstline) &gt;= 3 &amp;&amp; firstline[0] == 0xef</a>
<a name="ln3344">      &amp;&amp; firstline[1] == 0xbb &amp;&amp; firstline[2] == 0xbf) {</a>
<a name="ln3345">    // Found BOM; setup conversion, skip over BOM and recode the line.</a>
<a name="ln3346">    convert_setup(&amp;cookie.conv, (char_u *)&quot;utf-8&quot;, p_enc);</a>
<a name="ln3347">    p = string_convert(&amp;cookie.conv, firstline + 3, NULL);</a>
<a name="ln3348">    if (p == NULL) {</a>
<a name="ln3349">      p = vim_strsave(firstline + 3);</a>
<a name="ln3350">    }</a>
<a name="ln3351">    xfree(firstline);</a>
<a name="ln3352">    firstline = p;</a>
<a name="ln3353">  }</a>
<a name="ln3354"> </a>
<a name="ln3355">  // Call do_cmdline, which will call getsourceline() to get the lines.</a>
<a name="ln3356">  do_cmdline(firstline, getsourceline, (void *)&amp;cookie,</a>
<a name="ln3357">             DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);</a>
<a name="ln3358">  retval = OK;</a>
<a name="ln3359"> </a>
<a name="ln3360">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3361">    // Get &quot;si&quot; again, &quot;script_items&quot; may have been reallocated.</a>
<a name="ln3362">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3363">    if (si-&gt;sn_prof_on) {</a>
<a name="ln3364">      si-&gt;sn_pr_start = profile_end(si-&gt;sn_pr_start);</a>
<a name="ln3365">      si-&gt;sn_pr_start = profile_sub_wait(wait_start, si-&gt;sn_pr_start);</a>
<a name="ln3366">      si-&gt;sn_pr_total = profile_add(si-&gt;sn_pr_total, si-&gt;sn_pr_start);</a>
<a name="ln3367">      si-&gt;sn_pr_self = profile_self(si-&gt;sn_pr_self, si-&gt;sn_pr_start,</a>
<a name="ln3368">                                    si-&gt;sn_pr_children);</a>
<a name="ln3369">    }</a>
<a name="ln3370">  }</a>
<a name="ln3371"> </a>
<a name="ln3372">  if (got_int) {</a>
<a name="ln3373">    EMSG(_(e_interr));</a>
<a name="ln3374">  }</a>
<a name="ln3375">  sourcing_name = save_sourcing_name;</a>
<a name="ln3376">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln3377">  if (p_verbose &gt; 1) {</a>
<a name="ln3378">    verbose_enter();</a>
<a name="ln3379">    smsg(_(&quot;finished sourcing %s&quot;), fname);</a>
<a name="ln3380">    if (sourcing_name != NULL) {</a>
<a name="ln3381">      smsg(_(&quot;continuing in %s&quot;), sourcing_name);</a>
<a name="ln3382">    }</a>
<a name="ln3383">    verbose_leave();</a>
<a name="ln3384">  }</a>
<a name="ln3385"> </a>
<a name="ln3386">  if (l_time_fd != NULL) {</a>
<a name="ln3387">    vim_snprintf((char *)IObuff, IOSIZE, &quot;sourcing %s&quot;, fname);</a>
<a name="ln3388">    time_msg((char *)IObuff, &amp;start_time);</a>
<a name="ln3389">    time_pop(rel_time);</a>
<a name="ln3390">  }</a>
<a name="ln3391"> </a>
<a name="ln3392">  if (!got_int) {</a>
<a name="ln3393">    trigger_source_post = true;</a>
<a name="ln3394">  }</a>
<a name="ln3395"> </a>
<a name="ln3396">  // After a &quot;finish&quot; in debug mode, need to break at first command of next</a>
<a name="ln3397">  // sourced file.</a>
<a name="ln3398">  if (save_debug_break_level &gt; ex_nesting_level</a>
<a name="ln3399">      &amp;&amp; debug_break_level == ex_nesting_level) {</a>
<a name="ln3400">    debug_break_level++;</a>
<a name="ln3401">  }</a>
<a name="ln3402"> </a>
<a name="ln3403">  current_sctx = save_current_sctx;</a>
<a name="ln3404">  restore_funccal();</a>
<a name="ln3405">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3406">    prof_child_exit(&amp;wait_start);    // leaving a child now</a>
<a name="ln3407">  }</a>
<a name="ln3408">  fclose(cookie.fp);</a>
<a name="ln3409">  xfree(cookie.nextline);</a>
<a name="ln3410">  xfree(firstline);</a>
<a name="ln3411">  convert_setup(&amp;cookie.conv, NULL, NULL);</a>
<a name="ln3412"> </a>
<a name="ln3413">  if (trigger_source_post) {</a>
<a name="ln3414">    apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln3415">  }</a>
<a name="ln3416"> </a>
<a name="ln3417">theend:</a>
<a name="ln3418">  xfree(fname_exp);</a>
<a name="ln3419">  return retval;</a>
<a name="ln3420">}</a>
<a name="ln3421"> </a>
<a name="ln3422"> </a>
<a name="ln3423">/// &quot;:scriptnames&quot;</a>
<a name="ln3424">void ex_scriptnames(exarg_T *eap)</a>
<a name="ln3425">{</a>
<a name="ln3426">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln3427">    // :script {scriptId}: edit the script</a>
<a name="ln3428">    if (eap-&gt;line2 &lt; 1 || eap-&gt;line2 &gt; script_items.ga_len) {</a>
<a name="ln3429">      EMSG(_(e_invarg));</a>
<a name="ln3430">    } else {</a>
<a name="ln3431">      eap-&gt;arg = SCRIPT_ITEM(eap-&gt;line2).sn_name;</a>
<a name="ln3432">      do_exedit(eap, NULL);</a>
<a name="ln3433">    }</a>
<a name="ln3434">    return;</a>
<a name="ln3435">  }</a>
<a name="ln3436"> </a>
<a name="ln3437">  for (int i = 1; i &lt;= script_items.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln3438">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3439">      home_replace(NULL, SCRIPT_ITEM(i).sn_name,</a>
<a name="ln3440">                   NameBuff, MAXPATHL, true);</a>
<a name="ln3441">      smsg(&quot;%3d: %s&quot;, i, NameBuff);</a>
<a name="ln3442">    }</a>
<a name="ln3443">  }</a>
<a name="ln3444">}</a>
<a name="ln3445"> </a>
<a name="ln3446"># if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3447">/// Fix slashes in the list of script names for 'shellslash'.</a>
<a name="ln3448">void scriptnames_slash_adjust(void)</a>
<a name="ln3449">{</a>
<a name="ln3450">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln3451">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3452">      slash_adjust(SCRIPT_ITEM(i).sn_name);</a>
<a name="ln3453">    }</a>
<a name="ln3454">  }</a>
<a name="ln3455">}</a>
<a name="ln3456"> </a>
<a name="ln3457"># endif</a>
<a name="ln3458"> </a>
<a name="ln3459">/// Get a pointer to a script name.  Used for &quot;:verbose set&quot;.</a>
<a name="ln3460">char_u *get_scriptname(LastSet last_set, bool *should_free)</a>
<a name="ln3461">{</a>
<a name="ln3462">  *should_free = false;</a>
<a name="ln3463"> </a>
<a name="ln3464">  switch (last_set.script_ctx.sc_sid) {</a>
<a name="ln3465">    case SID_MODELINE:</a>
<a name="ln3466">      return (char_u *)_(&quot;modeline&quot;);</a>
<a name="ln3467">    case SID_CMDARG:</a>
<a name="ln3468">      return (char_u *)_(&quot;--cmd argument&quot;);</a>
<a name="ln3469">    case SID_CARG:</a>
<a name="ln3470">      return (char_u *)_(&quot;-c argument&quot;);</a>
<a name="ln3471">    case SID_ENV:</a>
<a name="ln3472">      return (char_u *)_(&quot;environment variable&quot;);</a>
<a name="ln3473">    case SID_ERROR:</a>
<a name="ln3474">      return (char_u *)_(&quot;error handler&quot;);</a>
<a name="ln3475">    case SID_LUA:</a>
<a name="ln3476">      return (char_u *)_(&quot;Lua&quot;);</a>
<a name="ln3477">    case SID_API_CLIENT:</a>
<a name="ln3478">      vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln3479">                   _(&quot;API client (channel id %&quot; PRIu64 &quot;)&quot;),</a>
<a name="ln3480">                   last_set.channel_id);</a>
<a name="ln3481">      return IObuff;</a>
<a name="ln3482">    case SID_STR:</a>
<a name="ln3483">      return (char_u *)_(&quot;anonymous :source&quot;);</a>
<a name="ln3484">    default:</a>
<a name="ln3485">      *should_free = true;</a>
<a name="ln3486">      return home_replace_save(NULL,</a>
<a name="ln3487">                               SCRIPT_ITEM(last_set.script_ctx.sc_sid).sn_name);</a>
<a name="ln3488">  }</a>
<a name="ln3489">}</a>
<a name="ln3490"> </a>
<a name="ln3491"># if defined(EXITFREE)</a>
<a name="ln3492">void free_scriptnames(void)</a>
<a name="ln3493">{</a>
<a name="ln3494">  profile_reset();</a>
<a name="ln3495"> </a>
<a name="ln3496"># define FREE_SCRIPTNAME(item) xfree((item)-&gt;sn_name)</a>
<a name="ln3497">  GA_DEEP_CLEAR(&amp;script_items, scriptitem_T, FREE_SCRIPTNAME);</a>
<a name="ln3498">}</a>
<a name="ln3499"># endif</a>
<a name="ln3500"> </a>
<a name="ln3501">linenr_T get_sourced_lnum(LineGetter fgetline, void *cookie)</a>
<a name="ln3502">{</a>
<a name="ln3503">    return fgetline == getsourceline</a>
<a name="ln3504">        ? ((struct source_cookie *)cookie)-&gt;sourcing_lnum</a>
<a name="ln3505">        : sourcing_lnum;</a>
<a name="ln3506">}</a>
<a name="ln3507"> </a>
<a name="ln3508"> </a>
<a name="ln3509">/// Get one full line from a sourced file.</a>
<a name="ln3510">/// Called by do_cmdline() when it's called from do_source().</a>
<a name="ln3511">///</a>
<a name="ln3512">/// @return pointer to the line in allocated memory, or NULL for end-of-file or</a>
<a name="ln3513">///         some error.</a>
<a name="ln3514">char_u *getsourceline(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3515">{</a>
<a name="ln3516">  struct source_cookie *sp = (struct source_cookie *)cookie;</a>
<a name="ln3517">  char_u *line;</a>
<a name="ln3518">  char_u *p;</a>
<a name="ln3519"> </a>
<a name="ln3520">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3521">  if (sp-&gt;dbg_tick &lt; debug_tick) {</a>
<a name="ln3522">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3523">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3524">  }</a>
<a name="ln3525">  if (do_profiling == PROF_YES) {</a>
<a name="ln3526">    script_line_end();</a>
<a name="ln3527">  }</a>
<a name="ln3528">  // Set the current sourcing line number.</a>
<a name="ln3529">  sourcing_lnum = sp-&gt;sourcing_lnum + 1;</a>
<a name="ln3530">  // Get current line.  If there is a read-ahead line, use it, otherwise get</a>
<a name="ln3531">  // one now.</a>
<a name="ln3532">  if (sp-&gt;finished) {</a>
<a name="ln3533">    line = NULL;</a>
<a name="ln3534">  } else if (sp-&gt;nextline == NULL) {</a>
<a name="ln3535">    line = get_one_sourceline(sp);</a>
<a name="ln3536">  } else {</a>
<a name="ln3537">    line = sp-&gt;nextline;</a>
<a name="ln3538">    sp-&gt;nextline = NULL;</a>
<a name="ln3539">    sp-&gt;sourcing_lnum++;</a>
<a name="ln3540">  }</a>
<a name="ln3541">  if (line != NULL &amp;&amp; do_profiling == PROF_YES) {</a>
<a name="ln3542">    script_line_start();</a>
<a name="ln3543">  }</a>
<a name="ln3544"> </a>
<a name="ln3545">  // Only concatenate lines starting with a \ when 'cpoptions' doesn't</a>
<a name="ln3546">  // contain the 'C' flag.</a>
<a name="ln3547">  if (line != NULL &amp;&amp; do_concat &amp;&amp; (vim_strchr(p_cpo, CPO_CONCAT) == NULL)) {</a>
<a name="ln3548">    // compensate for the one line read-ahead</a>
<a name="ln3549">    sp-&gt;sourcing_lnum--;</a>
<a name="ln3550"> </a>
<a name="ln3551">    // Get the next line and concatenate it when it starts with a</a>
<a name="ln3552">    // backslash. We always need to read the next line, keep it in</a>
<a name="ln3553">    // sp-&gt;nextline.</a>
<a name="ln3554">    // Also check for a comment in between continuation lines: &quot;\ .</a>
<a name="ln3555">    sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3556">    if (sp-&gt;nextline != NULL</a>
<a name="ln3557">        &amp;&amp; (*(p = skipwhite(sp-&gt;nextline)) == '\\'</a>
<a name="ln3558">            || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' '))) {</a>
<a name="ln3559">      garray_T ga;</a>
<a name="ln3560"> </a>
<a name="ln3561">      ga_init(&amp;ga, (int)sizeof(char_u), 400);</a>
<a name="ln3562">      ga_concat(&amp;ga, line);</a>
<a name="ln3563">      if (*p == '\\') {</a>
<a name="ln3564">        ga_concat(&amp;ga, p + 1);</a>
<a name="ln3565">      }</a>
<a name="ln3566">      for (;; ) {</a>
<a name="ln3567">        xfree(sp-&gt;nextline);</a>
<a name="ln3568">        sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3569">        if (sp-&gt;nextline == NULL) {</a>
<a name="ln3570">          break;</a>
<a name="ln3571">        }</a>
<a name="ln3572">        p = skipwhite(sp-&gt;nextline);</a>
<a name="ln3573">        if (*p == '\\') {</a>
<a name="ln3574">          // Adjust the growsize to the current length to speed up</a>
<a name="ln3575">          // concatenating many lines.</a>
<a name="ln3576">          if (ga.ga_len &gt; 400) {</a>
<a name="ln3577">            ga_set_growsize(&amp;ga, (ga.ga_len &gt; 8000) ? 8000 : ga.ga_len);</a>
<a name="ln3578">          }</a>
<a name="ln3579">          ga_concat(&amp;ga, p + 1);</a>
<a name="ln3580">        } else if (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ') {</a>
<a name="ln3581">          break;</a>
<a name="ln3582">        }</a>
<a name="ln3583">      }</a>
<a name="ln3584">      ga_append(&amp;ga, NUL);</a>
<a name="ln3585">      xfree(line);</a>
<a name="ln3586">      line = ga.ga_data;</a>
<a name="ln3587">    }</a>
<a name="ln3588">  }</a>
<a name="ln3589"> </a>
<a name="ln3590">  if (line != NULL &amp;&amp; sp-&gt;conv.vc_type != CONV_NONE) {</a>
<a name="ln3591">    char_u  *s;</a>
<a name="ln3592"> </a>
<a name="ln3593">    // Convert the encoding of the script line.</a>
<a name="ln3594">    s = string_convert(&amp;sp-&gt;conv, line, NULL);</a>
<a name="ln3595">    if (s != NULL) {</a>
<a name="ln3596">      xfree(line);</a>
<a name="ln3597">      line = s;</a>
<a name="ln3598">    }</a>
<a name="ln3599">  }</a>
<a name="ln3600"> </a>
<a name="ln3601">  // Did we encounter a breakpoint?</a>
<a name="ln3602">  if (sp-&gt;breakpoint != 0 &amp;&amp; sp-&gt;breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln3603">    dbg_breakpoint(sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3604">    // Find next breakpoint.</a>
<a name="ln3605">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3606">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3607">  }</a>
<a name="ln3608"> </a>
<a name="ln3609">  return line;</a>
<a name="ln3610">}</a>
<a name="ln3611"> </a>
<a name="ln3612">static char_u *get_one_sourceline(struct source_cookie *sp)</a>
<a name="ln3613">{</a>
<a name="ln3614">  garray_T ga;</a>
<a name="ln3615">  int len;</a>
<a name="ln3616">  int c;</a>
<a name="ln3617">  char_u              *buf;</a>
<a name="ln3618">#ifdef USE_CRNL</a>
<a name="ln3619">  int has_cr;                           // CR-LF found</a>
<a name="ln3620">#endif</a>
<a name="ln3621">  bool have_read = false;</a>
<a name="ln3622"> </a>
<a name="ln3623">  // use a growarray to store the sourced line</a>
<a name="ln3624">  ga_init(&amp;ga, 1, 250);</a>
<a name="ln3625"> </a>
<a name="ln3626">  // Loop until there is a finished line (or end-of-file).</a>
<a name="ln3627">  sp-&gt;sourcing_lnum++;</a>
<a name="ln3628">  for (;; ) {</a>
<a name="ln3629">    // make room to read at least 120 (more) characters</a>
<a name="ln3630">    ga_grow(&amp;ga, 120);</a>
<a name="ln3631">    buf = (char_u *)ga.ga_data;</a>
<a name="ln3632"> </a>
<a name="ln3633">retry:</a>
<a name="ln3634">    errno = 0;</a>
<a name="ln3635">    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,</a>
<a name="ln3636">              sp-&gt;fp) == NULL) {</a>
<a name="ln3637">      if (errno == EINTR) {</a>
<a name="ln3638">        goto retry;</a>
<a name="ln3639">      }</a>
<a name="ln3640"> </a>
<a name="ln3641">      break;</a>
<a name="ln3642">    }</a>
<a name="ln3643">    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);</a>
<a name="ln3644">#ifdef USE_CRNL</a>
<a name="ln3645">    // Ignore a trailing CTRL-Z, when in Dos mode. Only recognize the</a>
<a name="ln3646">    // CTRL-Z by its own, or after a NL.</a>
<a name="ln3647">    if ((len == 1 || (len &gt;= 2 &amp;&amp; buf[len - 2] == '\n'))</a>
<a name="ln3648">        &amp;&amp; sp-&gt;fileformat == EOL_DOS</a>
<a name="ln3649">        &amp;&amp; buf[len - 1] == Ctrl_Z) {</a>
<a name="ln3650">      buf[len - 1] = NUL;</a>
<a name="ln3651">      break;</a>
<a name="ln3652">    }</a>
<a name="ln3653">#endif</a>
<a name="ln3654"> </a>
<a name="ln3655">    have_read = true;</a>
<a name="ln3656">    ga.ga_len = len;</a>
<a name="ln3657"> </a>
<a name="ln3658">    // If the line was longer than the buffer, read more.</a>
<a name="ln3659">    if (ga.ga_maxlen - ga.ga_len == 1 &amp;&amp; buf[len - 1] != '\n') {</a>
<a name="ln3660">      continue;</a>
<a name="ln3661">    }</a>
<a name="ln3662"> </a>
<a name="ln3663">    if (len &gt;= 1 &amp;&amp; buf[len - 1] == '\n') {     // remove trailing NL</a>
<a name="ln3664">#ifdef USE_CRNL</a>
<a name="ln3665">      has_cr = (len &gt;= 2 &amp;&amp; buf[len - 2] == '\r');</a>
<a name="ln3666">      if (sp-&gt;fileformat == EOL_UNKNOWN) {</a>
<a name="ln3667">        if (has_cr) {</a>
<a name="ln3668">          sp-&gt;fileformat = EOL_DOS;</a>
<a name="ln3669">        } else {</a>
<a name="ln3670">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3671">        }</a>
<a name="ln3672">      }</a>
<a name="ln3673"> </a>
<a name="ln3674">      if (sp-&gt;fileformat == EOL_DOS) {</a>
<a name="ln3675">        if (has_cr) {               // replace trailing CR</a>
<a name="ln3676">          buf[len - 2] = '\n';</a>
<a name="ln3677">          len--;</a>
<a name="ln3678">          ga.ga_len--;</a>
<a name="ln3679">        } else {          // lines like &quot;:map xx yy^M&quot; will have failed</a>
<a name="ln3680">          if (!sp-&gt;error) {</a>
<a name="ln3681">            msg_source(HL_ATTR(HLF_W));</a>
<a name="ln3682">            EMSG(_(&quot;W15: Warning: Wrong line separator, ^M may be missing&quot;));</a>
<a name="ln3683">          }</a>
<a name="ln3684">          sp-&gt;error = true;</a>
<a name="ln3685">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3686">        }</a>
<a name="ln3687">      }</a>
<a name="ln3688">#endif</a>
<a name="ln3689">      // The '\n' is escaped if there is an odd number of ^V's just</a>
<a name="ln3690">      // before it, first set &quot;c&quot; just before the 'V's and then check</a>
<a name="ln3691">      // len&amp;c parities (is faster than ((len-c)%2 == 0)) -- Acevedo</a>
<a name="ln3692">      for (c = len - 2; c &gt;= 0 &amp;&amp; buf[c] == Ctrl_V; c--) {}</a>
<a name="ln3693">      if ((len &amp; 1) != (c &amp; 1)) {       // escaped NL, read more</a>
<a name="ln3694">        sp-&gt;sourcing_lnum++;</a>
<a name="ln3695">        continue;</a>
<a name="ln3696">      }</a>
<a name="ln3697"> </a>
<a name="ln3698">      buf[len - 1] = NUL;               // remove the NL</a>
<a name="ln3699">    }</a>
<a name="ln3700"> </a>
<a name="ln3701">    // Check for ^C here now and then, so recursive :so can be broken.</a>
<a name="ln3702">    line_breakcheck();</a>
<a name="ln3703">    break;</a>
<a name="ln3704">  }</a>
<a name="ln3705"> </a>
<a name="ln3706">  if (have_read) {</a>
<a name="ln3707">    return (char_u *)ga.ga_data;</a>
<a name="ln3708">  }</a>
<a name="ln3709"> </a>
<a name="ln3710">  xfree(ga.ga_data);</a>
<a name="ln3711">  return NULL;</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">/// Called when starting to read a script line.</a>
<a name="ln3715">/// &quot;sourcing_lnum&quot; must be correct!</a>
<a name="ln3716">/// When skipping lines it may not actually be executed, but we won't find out</a>
<a name="ln3717">/// until later and we need to store the time now.</a>
<a name="ln3718">void script_line_start(void)</a>
<a name="ln3719">{</a>
<a name="ln3720">  scriptitem_T    *si;</a>
<a name="ln3721">  sn_prl_T        *pp;</a>
<a name="ln3722"> </a>
<a name="ln3723">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3724">    return;</a>
<a name="ln3725">  }</a>
<a name="ln3726">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3727">  if (si-&gt;sn_prof_on &amp;&amp; sourcing_lnum &gt;= 1) {</a>
<a name="ln3728">    // Grow the array before starting the timer, so that the time spent</a>
<a name="ln3729">    // here isn't counted.</a>
<a name="ln3730">    (void)ga_grow(&amp;si-&gt;sn_prl_ga,</a>
<a name="ln3731">                  (int)(sourcing_lnum - si-&gt;sn_prl_ga.ga_len));</a>
<a name="ln3732">    si-&gt;sn_prl_idx = sourcing_lnum - 1;</a>
<a name="ln3733">    while (si-&gt;sn_prl_ga.ga_len &lt;= si-&gt;sn_prl_idx</a>
<a name="ln3734">           &amp;&amp; si-&gt;sn_prl_ga.ga_len &lt; si-&gt;sn_prl_ga.ga_maxlen) {</a>
<a name="ln3735">      // Zero counters for a line that was not used before.</a>
<a name="ln3736">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_ga.ga_len);</a>
<a name="ln3737">      pp-&gt;snp_count = 0;</a>
<a name="ln3738">      pp-&gt;sn_prl_total = profile_zero();</a>
<a name="ln3739">      pp-&gt;sn_prl_self = profile_zero();</a>
<a name="ln3740">      si-&gt;sn_prl_ga.ga_len++;</a>
<a name="ln3741">    }</a>
<a name="ln3742">    si-&gt;sn_prl_execed = false;</a>
<a name="ln3743">    si-&gt;sn_prl_start = profile_start();</a>
<a name="ln3744">    si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln3745">    si-&gt;sn_prl_wait = profile_get_wait();</a>
<a name="ln3746">  }</a>
<a name="ln3747">}</a>
<a name="ln3748"> </a>
<a name="ln3749">/// Called when actually executing a function line.</a>
<a name="ln3750">void script_line_exec(void)</a>
<a name="ln3751">{</a>
<a name="ln3752">  scriptitem_T    *si;</a>
<a name="ln3753"> </a>
<a name="ln3754">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3755">    return;</a>
<a name="ln3756">  }</a>
<a name="ln3757">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3758">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0) {</a>
<a name="ln3759">    si-&gt;sn_prl_execed = true;</a>
<a name="ln3760">  }</a>
<a name="ln3761">}</a>
<a name="ln3762"> </a>
<a name="ln3763">/// Called when done with a function line.</a>
<a name="ln3764">void script_line_end(void)</a>
<a name="ln3765">{</a>
<a name="ln3766">  scriptitem_T    *si;</a>
<a name="ln3767">  sn_prl_T        *pp;</a>
<a name="ln3768"> </a>
<a name="ln3769">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3770">    return;</a>
<a name="ln3771">  }</a>
<a name="ln3772">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3773">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0</a>
<a name="ln3774">      &amp;&amp; si-&gt;sn_prl_idx &lt; si-&gt;sn_prl_ga.ga_len) {</a>
<a name="ln3775">    if (si-&gt;sn_prl_execed) {</a>
<a name="ln3776">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_idx);</a>
<a name="ln3777">      pp-&gt;snp_count++;</a>
<a name="ln3778">      si-&gt;sn_prl_start = profile_end(si-&gt;sn_prl_start);</a>
<a name="ln3779">      si-&gt;sn_prl_start = profile_sub_wait(si-&gt;sn_prl_wait, si-&gt;sn_prl_start);</a>
<a name="ln3780">      pp-&gt;sn_prl_total = profile_add(pp-&gt;sn_prl_total, si-&gt;sn_prl_start);</a>
<a name="ln3781">      pp-&gt;sn_prl_self = profile_self(pp-&gt;sn_prl_self, si-&gt;sn_prl_start,</a>
<a name="ln3782">                                     si-&gt;sn_prl_children);</a>
<a name="ln3783">    }</a>
<a name="ln3784">    si-&gt;sn_prl_idx = -1;</a>
<a name="ln3785">  }</a>
<a name="ln3786">}</a>
<a name="ln3787"> </a>
<a name="ln3788">/// &quot;:scriptencoding&quot;: Set encoding conversion for a sourced script.</a>
<a name="ln3789">/// Without the multi-byte feature it's simply ignored.</a>
<a name="ln3790">void ex_scriptencoding(exarg_T *eap)</a>
<a name="ln3791">{</a>
<a name="ln3792">  struct source_cookie        *sp;</a>
<a name="ln3793">  char_u                      *name;</a>
<a name="ln3794"> </a>
<a name="ln3795">  if (!getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3796">    EMSG(_(&quot;E167: :scriptencoding used outside of a sourced file&quot;));</a>
<a name="ln3797">    return;</a>
<a name="ln3798">  }</a>
<a name="ln3799"> </a>
<a name="ln3800">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln3801">    name = enc_canonize(eap-&gt;arg);</a>
<a name="ln3802">  } else {</a>
<a name="ln3803">    name = eap-&gt;arg;</a>
<a name="ln3804">  }</a>
<a name="ln3805"> </a>
<a name="ln3806">  // Setup for conversion from the specified encoding to 'encoding'.</a>
<a name="ln3807">  sp = (struct source_cookie *)getline_cookie(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln3808">  convert_setup(&amp;sp-&gt;conv, name, p_enc);</a>
<a name="ln3809"> </a>
<a name="ln3810">  if (name != eap-&gt;arg) {</a>
<a name="ln3811">    xfree(name);</a>
<a name="ln3812">  }</a>
<a name="ln3813">}</a>
<a name="ln3814"> </a>
<a name="ln3815">/// &quot;:finish&quot;: Mark a sourced file as finished.</a>
<a name="ln3816">void ex_finish(exarg_T *eap)</a>
<a name="ln3817">{</a>
<a name="ln3818">  if (getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3819">    do_finish(eap, false);</a>
<a name="ln3820">  } else {</a>
<a name="ln3821">    EMSG(_(&quot;E168: :finish used outside of a sourced file&quot;));</a>
<a name="ln3822">  }</a>
<a name="ln3823">}</a>
<a name="ln3824"> </a>
<a name="ln3825">/// Mark a sourced file as finished.  Possibly makes the &quot;:finish&quot; pending.</a>
<a name="ln3826">/// Also called for a pending finish at the &quot;:endtry&quot; or after returning from</a>
<a name="ln3827">/// an extra do_cmdline().  &quot;reanimate&quot; is used in the latter case.</a>
<a name="ln3828">void do_finish(exarg_T *eap, int reanimate)</a>
<a name="ln3829">{</a>
<a name="ln3830">  int idx;</a>
<a name="ln3831"> </a>
<a name="ln3832">  if (reanimate) {</a>
<a name="ln3833">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3834">                                            eap-&gt;cookie))-&gt;finished = false;</a>
<a name="ln3835">  }</a>
<a name="ln3836"> </a>
<a name="ln3837">  // Cleanup (and inactivate) conditionals, but stop when a try conditional</a>
<a name="ln3838">  // not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln3839">  // In this case, make the &quot;:finish&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln3840">  // Otherwise, finish normally.</a>
<a name="ln3841">  idx = cleanup_conditionals(eap-&gt;cstack, 0, true);</a>
<a name="ln3842">  if (idx &gt;= 0) {</a>
<a name="ln3843">    eap-&gt;cstack-&gt;cs_pending[idx] = CSTP_FINISH;</a>
<a name="ln3844">    report_make_pending(CSTP_FINISH, NULL);</a>
<a name="ln3845">  } else {</a>
<a name="ln3846">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3847">                                            eap-&gt;cookie))-&gt;finished = true;</a>
<a name="ln3848">  }</a>
<a name="ln3849">}</a>
<a name="ln3850"> </a>
<a name="ln3851"> </a>
<a name="ln3852">/// Return true when a sourced file had the &quot;:finish&quot; command: Don't give error</a>
<a name="ln3853">/// message for missing &quot;:endif&quot;.</a>
<a name="ln3854">/// Return false when not sourcing a file.</a>
<a name="ln3855">bool source_finished(LineGetter fgetline, void *cookie)</a>
<a name="ln3856">{</a>
<a name="ln3857">  return getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln3858">         &amp;&amp; ((struct source_cookie *)getline_cookie(</a>
<a name="ln3859">             fgetline, cookie))-&gt;finished;</a>
<a name="ln3860">}</a>
<a name="ln3861"> </a>
<a name="ln3862">/// &quot;:checktime [buffer]&quot;</a>
<a name="ln3863">void ex_checktime(exarg_T *eap)</a>
<a name="ln3864">{</a>
<a name="ln3865">  buf_T       *buf;</a>
<a name="ln3866">  int save_no_check_timestamps = no_check_timestamps;</a>
<a name="ln3867"> </a>
<a name="ln3868">  no_check_timestamps = 0;</a>
<a name="ln3869">  if (eap-&gt;addr_count == 0) {    // default is all buffers</a>
<a name="ln3870">    check_timestamps(false);</a>
<a name="ln3871">  } else {</a>
<a name="ln3872">    buf = buflist_findnr((int)eap-&gt;line2);</a>
<a name="ln3873">    if (buf != NULL) {           // cannot happen?</a>
<a name="ln3874">      (void)buf_check_timestamp(buf, false);</a>
<a name="ln3875">    }</a>
<a name="ln3876">  }</a>
<a name="ln3877">  no_check_timestamps = save_no_check_timestamps;</a>
<a name="ln3878">}</a>
<a name="ln3879"> </a>
<a name="ln3880">#if defined(HAVE_LOCALE_H)</a>
<a name="ln3881"># define HAVE_GET_LOCALE_VAL</a>
<a name="ln3882"> </a>
<a name="ln3883">static char *get_locale_val(int what)</a>
<a name="ln3884">{</a>
<a name="ln3885">  // Obtain the locale value from the libraries.</a>
<a name="ln3886">  char *loc = setlocale(what, NULL);</a>
<a name="ln3887"> </a>
<a name="ln3888">  return loc;</a>
<a name="ln3889">}</a>
<a name="ln3890">#endif</a>
<a name="ln3891"> </a>
<a name="ln3892">// Return true when &quot;lang&quot; starts with a valid language name.</a>
<a name="ln3893">// Rejects NULL, empty string, &quot;C&quot;, &quot;C.UTF-8&quot; and others.</a>
<a name="ln3894">static bool is_valid_mess_lang(char *lang)</a>
<a name="ln3895">{</a>
<a name="ln3896">  return lang != NULL &amp;&amp; ASCII_ISALPHA(lang[0]) &amp;&amp; ASCII_ISALPHA(lang[1]);</a>
<a name="ln3897">}</a>
<a name="ln3898"> </a>
<a name="ln3899">/// Obtain the current messages language.  Used to set the default for</a>
<a name="ln3900">/// 'helplang'.  May return NULL or an empty string.</a>
<a name="ln3901">char *get_mess_lang(void)</a>
<a name="ln3902">{</a>
<a name="ln3903">  char *p;</a>
<a name="ln3904"> </a>
<a name="ln3905"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3906">#  if defined(LC_MESSAGES)</a>
<a name="ln3907">  p = get_locale_val(LC_MESSAGES);</a>
<a name="ln3908">#  else</a>
<a name="ln3909">  // This is necessary for Win32, where LC_MESSAGES is not defined and $LANG</a>
<a name="ln3910">  // may be set to the LCID number.  LC_COLLATE is the best guess, LC_TIME</a>
<a name="ln3911">  // and LC_MONETARY may be set differently for a Japanese working in the</a>
<a name="ln3912">  // US.</a>
<a name="ln3913">  p = get_locale_val(LC_COLLATE);</a>
<a name="ln3914">#  endif</a>
<a name="ln3915"># else</a>
<a name="ln3916">  p = os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3917">  if (!is_valid_mess_lang(p)) {</a>
<a name="ln3918">    p = os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3919">    if (!is_valid_mess_lang(p)) {</a>
<a name="ln3920">      p = os_getenv(&quot;LANG&quot;);</a>
<a name="ln3921">    }</a>
<a name="ln3922">  }</a>
<a name="ln3923"># endif</a>
<a name="ln3924">  return is_valid_mess_lang(p) ? p : NULL;</a>
<a name="ln3925">}</a>
<a name="ln3926"> </a>
<a name="ln3927">// Complicated #if; matches with where get_mess_env() is used below.</a>
<a name="ln3928">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3929">/// Get the language used for messages from the environment.</a>
<a name="ln3930">static char_u *get_mess_env(void)</a>
<a name="ln3931">{</a>
<a name="ln3932">  char_u      *p;</a>
<a name="ln3933"> </a>
<a name="ln3934">  p = (char_u *)os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3935">  if (p == NULL) {</a>
<a name="ln3936">    p = (char_u *)os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3937">    if (p == NULL) {</a>
<a name="ln3938">      p = (char_u *)os_getenv(&quot;LANG&quot;);</a>
<a name="ln3939">      if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln3940">        p = NULL;                       // ignore something like &quot;1043&quot;</a>
<a name="ln3941">      }</a>
<a name="ln3942"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3943">      if (p == NULL) {</a>
<a name="ln3944">        p = (char_u *)get_locale_val(LC_CTYPE);</a>
<a name="ln3945">      }</a>
<a name="ln3946"># endif</a>
<a name="ln3947">    }</a>
<a name="ln3948">  }</a>
<a name="ln3949">  return p;</a>
<a name="ln3950">}</a>
<a name="ln3951"> </a>
<a name="ln3952">#endif</a>
<a name="ln3953"> </a>
<a name="ln3954"> </a>
<a name="ln3955">/// Set the &quot;v:lang&quot; variable according to the current locale setting.</a>
<a name="ln3956">/// Also do &quot;v:lc_time&quot;and &quot;v:ctype&quot;.</a>
<a name="ln3957">void set_lang_var(void)</a>
<a name="ln3958">{</a>
<a name="ln3959">  const char *loc;</a>
<a name="ln3960"> </a>
<a name="ln3961"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3962">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3963"># else</a>
<a name="ln3964">  // setlocale() not supported: use the default value</a>
<a name="ln3965">  loc = &quot;C&quot;;</a>
<a name="ln3966"># endif</a>
<a name="ln3967">  set_vim_var_string(VV_CTYPE, loc, -1);</a>
<a name="ln3968"> </a>
<a name="ln3969">  // When LC_MESSAGES isn't defined use the value from $LC_MESSAGES, fall</a>
<a name="ln3970">  // back to LC_CTYPE if it's empty.</a>
<a name="ln3971"># ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3972">  loc = (char *)get_mess_env();</a>
<a name="ln3973"># elif defined(LC_MESSAGES)</a>
<a name="ln3974">  loc = get_locale_val(LC_MESSAGES);</a>
<a name="ln3975"># else</a>
<a name="ln3976">  // In Windows LC_MESSAGES is not defined fallback to LC_CTYPE</a>
<a name="ln3977">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3978"># endif</a>
<a name="ln3979">  set_vim_var_string(VV_LANG, loc, -1);</a>
<a name="ln3980"> </a>
<a name="ln3981"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3982">  loc = get_locale_val(LC_TIME);</a>
<a name="ln3983"># endif</a>
<a name="ln3984">  set_vim_var_string(VV_LC_TIME, loc, -1);</a>
<a name="ln3985">}</a>
<a name="ln3986"> </a>
<a name="ln3987">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3988">///</a>
<a name="ln3989">/// &quot;:language&quot;:  Set the language (locale).</a>
<a name="ln3990">///</a>
<a name="ln3991">/// @param eap</a>
<a name="ln3992">///</a>
<a name="ln3993">void ex_language(exarg_T *eap)</a>
<a name="ln3994">{</a>
<a name="ln3995">  char        *loc;</a>
<a name="ln3996">  char_u      *p;</a>
<a name="ln3997">  char_u      *name;</a>
<a name="ln3998">  int what = LC_ALL;</a>
<a name="ln3999">  char        *whatstr = &quot;&quot;;</a>
<a name="ln4000">#ifdef LC_MESSAGES</a>
<a name="ln4001"># define VIM_LC_MESSAGES LC_MESSAGES</a>
<a name="ln4002">#else</a>
<a name="ln4003"># define VIM_LC_MESSAGES 6789</a>
<a name="ln4004">#endif</a>
<a name="ln4005"> </a>
<a name="ln4006">  name = eap-&gt;arg;</a>
<a name="ln4007"> </a>
<a name="ln4008">  // Check for &quot;messages {name}&quot;, &quot;ctype {name}&quot; or &quot;time {name}&quot; argument.</a>
<a name="ln4009">  // Allow abbreviation, but require at least 3 characters to avoid</a>
<a name="ln4010">  // confusion with a two letter language name &quot;me&quot; or &quot;ct&quot;.</a>
<a name="ln4011">  p = skiptowhite(eap-&gt;arg);</a>
<a name="ln4012">  if ((*p == NUL || ascii_iswhite(*p)) &amp;&amp; p - eap-&gt;arg &gt;= 3) {</a>
<a name="ln4013">    if (STRNICMP(eap-&gt;arg, &quot;messages&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln4014">      what = VIM_LC_MESSAGES;</a>
<a name="ln4015">      name = skipwhite(p);</a>
<a name="ln4016">      whatstr = &quot;messages &quot;;</a>
<a name="ln4017">    } else if (STRNICMP(eap-&gt;arg, &quot;ctype&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln4018">      what = LC_CTYPE;</a>
<a name="ln4019">      name = skipwhite(p);</a>
<a name="ln4020">      whatstr = &quot;ctype &quot;;</a>
<a name="ln4021">    } else if (STRNICMP(eap-&gt;arg, &quot;time&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln4022">      what = LC_TIME;</a>
<a name="ln4023">      name = skipwhite(p);</a>
<a name="ln4024">      whatstr = &quot;time &quot;;</a>
<a name="ln4025">    }</a>
<a name="ln4026">  }</a>
<a name="ln4027"> </a>
<a name="ln4028">  if (*name == NUL) {</a>
<a name="ln4029">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln4030">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln4031">      p = get_mess_env();</a>
<a name="ln4032">    } else {</a>
<a name="ln4033">#endif</a>
<a name="ln4034">      p = (char_u *)setlocale(what, NULL);</a>
<a name="ln4035">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln4036">    }</a>
<a name="ln4037">#endif</a>
<a name="ln4038">    if (p == NULL || *p == NUL) {</a>
<a name="ln4039">      p = (char_u *)&quot;Unknown&quot;;</a>
<a name="ln4040">    }</a>
<a name="ln4041">    smsg(_(&quot;Current %slanguage: \&quot;%s\&quot;&quot;), whatstr, p);</a>
<a name="ln4042">  } else {</a>
<a name="ln4043">#ifndef LC_MESSAGES</a>
<a name="ln4044">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln4045">      loc = &quot;&quot;;</a>
<a name="ln4046">    } else {</a>
<a name="ln4047">#endif</a>
<a name="ln4048">      loc = setlocale(what, (char *)name);</a>
<a name="ln4049">#ifdef LC_NUMERIC</a>
<a name="ln4050">      // Make sure strtod() uses a decimal point, not a comma.</a>
<a name="ln4051">      setlocale(LC_NUMERIC, &quot;C&quot;);</a>
<a name="ln4052">#endif</a>
<a name="ln4053">#ifndef LC_MESSAGES</a>
<a name="ln4054">    }</a>
<a name="ln4055">#endif</a>
<a name="ln4056">    if (loc == NULL) {</a>
<a name="ln4057">      EMSG2(_(&quot;E197: Cannot set language to \&quot;%s\&quot;&quot;), name);</a>
<a name="ln4058">    } else {</a>
<a name="ln4059">#ifdef HAVE_NL_MSG_CAT_CNTR</a>
<a name="ln4060">      // Need to do this for GNU gettext, otherwise cached translations</a>
<a name="ln4061">      // will be used again.</a>
<a name="ln4062">      extern int _nl_msg_cat_cntr;</a>
<a name="ln4063"> </a>
<a name="ln4064">      _nl_msg_cat_cntr++;</a>
<a name="ln4065">#endif</a>
<a name="ln4066">      // Reset $LC_ALL, otherwise it would overrule everything.</a>
<a name="ln4067">      os_setenv(&quot;LC_ALL&quot;, &quot;&quot;, 1);</a>
<a name="ln4068"> </a>
<a name="ln4069">      if (what != LC_TIME) {</a>
<a name="ln4070">        // Tell gettext() what to translate to.  It apparently doesn't</a>
<a name="ln4071">        // use the currently effective locale.</a>
<a name="ln4072">        if (what == LC_ALL) {</a>
<a name="ln4073">          os_setenv(&quot;LANG&quot;, (char *)name, 1);</a>
<a name="ln4074"> </a>
<a name="ln4075">          // Clear $LANGUAGE because GNU gettext uses it.</a>
<a name="ln4076">          os_setenv(&quot;LANGUAGE&quot;, &quot;&quot;, 1);</a>
<a name="ln4077">        }</a>
<a name="ln4078">        if (what != LC_CTYPE) {</a>
<a name="ln4079">          os_setenv(&quot;LC_MESSAGES&quot;, (char *)name, 1);</a>
<a name="ln4080">          set_helplang_default((char *)name);</a>
<a name="ln4081">        }</a>
<a name="ln4082">      }</a>
<a name="ln4083"> </a>
<a name="ln4084">      // Set v:lang, v:lc_time and v:ctype to the final result.</a>
<a name="ln4085">      set_lang_var();</a>
<a name="ln4086">      maketitle();</a>
<a name="ln4087">    }</a>
<a name="ln4088">  }</a>
<a name="ln4089">}</a>
<a name="ln4090"> </a>
<a name="ln4091"> </a>
<a name="ln4092">static char_u **locales = NULL;       // Array of all available locales</a>
<a name="ln4093"> </a>
<a name="ln4094">#ifndef WIN32</a>
<a name="ln4095">static bool did_init_locales = false;</a>
<a name="ln4096"> </a>
<a name="ln4097">/// Return an array of strings for all available locales + NULL for the</a>
<a name="ln4098">/// last element.  Return NULL in case of error.</a>
<a name="ln4099">static char_u **find_locales(void)</a>
<a name="ln4100">{</a>
<a name="ln4101">  garray_T locales_ga;</a>
<a name="ln4102">  char_u      *loc;</a>
<a name="ln4103">  char *saveptr = NULL;</a>
<a name="ln4104"> </a>
<a name="ln4105">  // Find all available locales by running command &quot;locale -a&quot;.  If this</a>
<a name="ln4106">  // doesn't work we won't have completion.</a>
<a name="ln4107">  char_u *locale_a = get_cmd_output((char_u *)&quot;locale -a&quot;, NULL,</a>
<a name="ln4108">                                    kShellOptSilent, NULL);</a>
<a name="ln4109">  if (locale_a == NULL) {</a>
<a name="ln4110">    return NULL;</a>
<a name="ln4111">  }</a>
<a name="ln4112">  ga_init(&amp;locales_ga, sizeof(char_u *), 20);</a>
<a name="ln4113"> </a>
<a name="ln4114">  // Transform locale_a string where each locale is separated by &quot;\n&quot;</a>
<a name="ln4115">  // into an array of locale strings.</a>
<a name="ln4116">  loc = (char_u *)os_strtok((char *)locale_a, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln4117"> </a>
<a name="ln4118">  while (loc != NULL) {</a>
<a name="ln4119">    loc = vim_strsave(loc);</a>
<a name="ln4120">    GA_APPEND(char_u *, &amp;locales_ga, loc);</a>
<a name="ln4121">    loc = (char_u *)os_strtok(NULL, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln4122">  }</a>
<a name="ln4123">  xfree(locale_a);</a>
<a name="ln4124">  // Guarantee that .ga_data is NULL terminated</a>
<a name="ln4125">  ga_grow(&amp;locales_ga, 1);</a>
<a name="ln4126">  ((char_u **)locales_ga.ga_data)[locales_ga.ga_len] = NULL;</a>
<a name="ln4127">  return (char_u **)locales_ga.ga_data;</a>
<a name="ln4128">}</a>
<a name="ln4129">#endif</a>
<a name="ln4130"> </a>
<a name="ln4131">/// Lazy initialization of all available locales.</a>
<a name="ln4132">static void init_locales(void)</a>
<a name="ln4133">{</a>
<a name="ln4134">#ifndef WIN32</a>
<a name="ln4135">  if (!did_init_locales) {</a>
<a name="ln4136">    did_init_locales = true;</a>
<a name="ln4137">    locales = find_locales();</a>
<a name="ln4138">  }</a>
<a name="ln4139">#endif</a>
<a name="ln4140">}</a>
<a name="ln4141"> </a>
<a name="ln4142">#  if defined(EXITFREE)</a>
<a name="ln4143">void free_locales(void)</a>
<a name="ln4144">{</a>
<a name="ln4145">  int i;</a>
<a name="ln4146">  if (locales != NULL) {</a>
<a name="ln4147">    for (i = 0; locales[i] != NULL; i++) {</a>
<a name="ln4148">      xfree(locales[i]);</a>
<a name="ln4149">    }</a>
<a name="ln4150">    XFREE_CLEAR(locales);</a>
<a name="ln4151">  }</a>
<a name="ln4152">}</a>
<a name="ln4153"> </a>
<a name="ln4154">#  endif</a>
<a name="ln4155"> </a>
<a name="ln4156">/// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln4157">/// &quot;:language&quot; command.</a>
<a name="ln4158">char_u *get_lang_arg(expand_T *xp, int idx)</a>
<a name="ln4159">{</a>
<a name="ln4160">  if (idx == 0) {</a>
<a name="ln4161">    return (char_u *)&quot;messages&quot;;</a>
<a name="ln4162">  }</a>
<a name="ln4163">  if (idx == 1) {</a>
<a name="ln4164">    return (char_u *)&quot;ctype&quot;;</a>
<a name="ln4165">  }</a>
<a name="ln4166">  if (idx == 2) {</a>
<a name="ln4167">    return (char_u *)&quot;time&quot;;</a>
<a name="ln4168">  }</a>
<a name="ln4169"> </a>
<a name="ln4170">  init_locales();</a>
<a name="ln4171">  if (locales == NULL) {</a>
<a name="ln4172">    return NULL;</a>
<a name="ln4173">  }</a>
<a name="ln4174">  return locales[idx - 3];</a>
<a name="ln4175">}</a>
<a name="ln4176"> </a>
<a name="ln4177">/// Function given to ExpandGeneric() to obtain the available locales.</a>
<a name="ln4178">char_u *get_locales(expand_T *xp, int idx)</a>
<a name="ln4179">{</a>
<a name="ln4180">  init_locales();</a>
<a name="ln4181">  if (locales == NULL) {</a>
<a name="ln4182">    return NULL;</a>
<a name="ln4183">  }</a>
<a name="ln4184">  return locales[idx];</a>
<a name="ln4185">}</a>
<a name="ln4186"> </a>
<a name="ln4187">#endif</a>
<a name="ln4188"> </a>
<a name="ln4189"> </a>
<a name="ln4190">static void script_host_execute(char *name, exarg_T *eap)</a>
<a name="ln4191">{</a>
<a name="ln4192">  size_t len;</a>
<a name="ln4193">  char *const script = script_get(eap, &amp;len);</a>
<a name="ln4194"> </a>
<a name="ln4195">  if (script != NULL) {</a>
<a name="ln4196">    list_T *const args = tv_list_alloc(3);</a>
<a name="ln4197">    // script</a>
<a name="ln4198">    tv_list_append_allocated_string(args, script);</a>
<a name="ln4199">    // current range</a>
<a name="ln4200">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln4201">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln4202"> </a>
<a name="ln4203">    (void)eval_call_provider(name, &quot;execute&quot;, args, true);</a>
<a name="ln4204">  }</a>
<a name="ln4205">}</a>
<a name="ln4206"> </a>
<a name="ln4207">static void script_host_execute_file(char *name, exarg_T *eap)</a>
<a name="ln4208">{</a>
<a name="ln4209">  uint8_t buffer[MAXPATHL];</a>
<a name="ln4210">  vim_FullName((char *)eap-&gt;arg, (char *)buffer, sizeof(buffer), false);</a>
<a name="ln4211"> </a>
<a name="ln4212">  list_T *args = tv_list_alloc(3);</a>
<a name="ln4213">  // filename</a>
<a name="ln4214">  tv_list_append_string(args, (const char *)buffer, -1);</a>
<a name="ln4215">  // current range</a>
<a name="ln4216">  tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln4217">  tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln4218">  (void)eval_call_provider(name, &quot;execute_file&quot;, args, true);</a>
<a name="ln4219">}</a>
<a name="ln4220"> </a>
<a name="ln4221">static void script_host_do_range(char *name, exarg_T *eap)</a>
<a name="ln4222">{</a>
<a name="ln4223">  list_T *args = tv_list_alloc(3);</a>
<a name="ln4224">  tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln4225">  tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln4226">  tv_list_append_string(args, (const char *)eap-&gt;arg, -1);</a>
<a name="ln4227">  (void)eval_call_provider(name, &quot;do_range&quot;, args, true);</a>
<a name="ln4228">}</a>
<a name="ln4229"> </a>
<a name="ln4230">/// &quot;:drop&quot;</a>
<a name="ln4231">/// Opens the first argument in a window.  When there are two or more arguments</a>
<a name="ln4232">/// the argument list is redefined.</a>
<a name="ln4233">void ex_drop(exarg_T   *eap)</a>
<a name="ln4234">{</a>
<a name="ln4235">  bool split = false;</a>
<a name="ln4236">  buf_T *buf;</a>
<a name="ln4237"> </a>
<a name="ln4238">  // Check if the first argument is already being edited in a window.  If</a>
<a name="ln4239">  // so, jump to that window.</a>
<a name="ln4240">  // We would actually need to check all arguments, but that's complicated</a>
<a name="ln4241">  // and mostly only one file is dropped.</a>
<a name="ln4242">  // This also ignores wildcards, since it is very unlikely the user is</a>
<a name="ln4243">  // editing a file name with a wildcard character.</a>
<a name="ln4244">  do_arglist(eap-&gt;arg, AL_SET, 0);</a>
<a name="ln4245"> </a>
<a name="ln4246">  // Expanding wildcards may result in an empty argument list.  E.g. when</a>
<a name="ln4247">  // editing &quot;foo.pyc&quot; and &quot;.pyc&quot; is in 'wildignore'.  Assume that we</a>
<a name="ln4248">  // already did an error message for this.</a>
<a name="ln4249">  if (ARGCOUNT == 0) {</a>
<a name="ln4250">    return;</a>
<a name="ln4251">  }</a>
<a name="ln4252"> </a>
<a name="ln4253">  if (cmdmod.tab) {</a>
<a name="ln4254">    // &quot;:tab drop file ...&quot;: open a tab for each argument that isn't</a>
<a name="ln4255">    // edited in a window yet.  It's like &quot;:tab all&quot; but without closing</a>
<a name="ln4256">    // windows or tabs.</a>
<a name="ln4257">    ex_all(eap);</a>
<a name="ln4258">  } else {</a>
<a name="ln4259">    // &quot;:drop file ...&quot;: Edit the first argument.  Jump to an existing</a>
<a name="ln4260">    // window if possible, edit in current window if the current buffer</a>
<a name="ln4261">    // can be abandoned, otherwise open a new window.</a>
<a name="ln4262">    buf = buflist_findnr(ARGLIST[0].ae_fnum);</a>
<a name="ln4263"> </a>
<a name="ln4264">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4265">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln4266">        goto_tabpage_win(tp, wp);</a>
<a name="ln4267">        curwin-&gt;w_arg_idx = 0;</a>
<a name="ln4268">        return;</a>
<a name="ln4269">      }</a>
<a name="ln4270">    }</a>
<a name="ln4271"> </a>
<a name="ln4272">    // Check whether the current buffer is changed. If so, we will need</a>
<a name="ln4273">    // to split the current window or data could be lost.</a>
<a name="ln4274">    // Skip the check if the 'hidden' option is set, as in this case the</a>
<a name="ln4275">    // buffer won't be lost.</a>
<a name="ln4276">    if (!buf_hide(curbuf)) {</a>
<a name="ln4277">      emsg_off++;</a>
<a name="ln4278">      split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);</a>
<a name="ln4279">      emsg_off--;</a>
<a name="ln4280">    }</a>
<a name="ln4281"> </a>
<a name="ln4282">    // Fake a &quot;:sfirst&quot; or &quot;:first&quot; command edit the first argument.</a>
<a name="ln4283">    if (split) {</a>
<a name="ln4284">      eap-&gt;cmdidx = CMD_sfirst;</a>
<a name="ln4285">      eap-&gt;cmd[0] = 's';</a>
<a name="ln4286">    } else {</a>
<a name="ln4287">      eap-&gt;cmdidx = CMD_first;</a>
<a name="ln4288">    }</a>
<a name="ln4289">    ex_rewind(eap);</a>
<a name="ln4290">  }</a>
<a name="ln4291">}</a>

</code></pre>
<div class="balloon" rel="3116"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'sourcing_name_buf' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_docmd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_docmd.c: functions for executing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;nvim/vim.h&quot;</a>
<a name="ln13">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln14">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/change.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln19">#include &quot;nvim/diff.h&quot;</a>
<a name="ln20">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln21">#include &quot;nvim/edit.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/fold.h&quot;</a>
<a name="ln30">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln31">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln32">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln33">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln34">#include &quot;nvim/main.h&quot;</a>
<a name="ln35">#include &quot;nvim/mark.h&quot;</a>
<a name="ln36">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln37">#include &quot;nvim/memline.h&quot;</a>
<a name="ln38">#include &quot;nvim/memory.h&quot;</a>
<a name="ln39">#include &quot;nvim/menu.h&quot;</a>
<a name="ln40">#include &quot;nvim/message.h&quot;</a>
<a name="ln41">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln43">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln44">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln45">#include &quot;nvim/garray.h&quot;</a>
<a name="ln46">#include &quot;nvim/move.h&quot;</a>
<a name="ln47">#include &quot;nvim/normal.h&quot;</a>
<a name="ln48">#include &quot;nvim/ops.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln51">#include &quot;nvim/path.h&quot;</a>
<a name="ln52">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln53">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln54">#include &quot;nvim/screen.h&quot;</a>
<a name="ln55">#include &quot;nvim/search.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln59">#include &quot;nvim/strings.h&quot;</a>
<a name="ln60">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln61">#include &quot;nvim/tag.h&quot;</a>
<a name="ln62">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln63">#include &quot;nvim/ui.h&quot;</a>
<a name="ln64">#include &quot;nvim/undo.h&quot;</a>
<a name="ln65">#include &quot;nvim/version.h&quot;</a>
<a name="ln66">#include &quot;nvim/window.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln68">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln70">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln71">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln72">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln73">#include &quot;nvim/event/wstream.h&quot;</a>
<a name="ln74">#include &quot;nvim/shada.h&quot;</a>
<a name="ln75">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln76">#include &quot;nvim/globals.h&quot;</a>
<a name="ln77">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79">static int quitmore = 0;</a>
<a name="ln80">static bool ex_pressedreturn = false;</a>
<a name="ln81"> </a>
<a name="ln82">typedef struct ucmd {</a>
<a name="ln83">  char_u      *uc_name;         // The command name</a>
<a name="ln84">  uint32_t uc_argt;             // The argument type</a>
<a name="ln85">  char_u      *uc_rep;          // The command's replacement string</a>
<a name="ln86">  long uc_def;                  // The default value for a range/count</a>
<a name="ln87">  int uc_compl;                 // completion type</a>
<a name="ln88">  cmd_addr_T uc_addr_type;      // The command's address type</a>
<a name="ln89">  sctx_T uc_script_ctx;         // SCTX where the command was defined</a>
<a name="ln90">  char_u      *uc_compl_arg;    // completion argument if any</a>
<a name="ln91">} ucmd_T;</a>
<a name="ln92"> </a>
<a name="ln93">#define UC_BUFFER       1       /* -buffer: local to current buffer */</a>
<a name="ln94"> </a>
<a name="ln95">static garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};</a>
<a name="ln96"> </a>
<a name="ln97">#define USER_CMD(i) (&amp;((ucmd_T *)(ucmds.ga_data))[i])</a>
<a name="ln98">#define USER_CMD_GA(gap, i) (&amp;((ucmd_T *)((gap)-&gt;ga_data))[i])</a>
<a name="ln99"> </a>
<a name="ln100">/* Wether a command index indicates a user command. */</a>
<a name="ln101"># define IS_USER_CMDIDX(idx) ((int)(idx) &lt; 0)</a>
<a name="ln102"> </a>
<a name="ln103">/* Struct for storing a line inside a while/for loop */</a>
<a name="ln104">typedef struct {</a>
<a name="ln105">  char_u      *line;            /* command line */</a>
<a name="ln106">  linenr_T lnum;                /* sourcing_lnum of the line */</a>
<a name="ln107">} wcmd_T;</a>
<a name="ln108"> </a>
<a name="ln109">#define FREE_WCMD(wcmd) xfree((wcmd)-&gt;line)</a>
<a name="ln110"> </a>
<a name="ln111">/*</a>
<a name="ln112"> * Structure used to store info for line position in a while or for loop.</a>
<a name="ln113"> * This is required, because do_one_cmd() may invoke ex_function(), which</a>
<a name="ln114"> * reads more lines that may come from the while/for loop.</a>
<a name="ln115"> */</a>
<a name="ln116">struct loop_cookie {</a>
<a name="ln117">  garray_T    *lines_gap;               // growarray with line info</a>
<a name="ln118">  int current_line;                     // last read line from growarray</a>
<a name="ln119">  int repeating;                        // TRUE when looping a second time</a>
<a name="ln120">  // When &quot;repeating&quot; is FALSE use &quot;getline&quot; and &quot;cookie&quot; to get lines</a>
<a name="ln121">  char_u      *(*getline)(int, void *, int, bool);</a>
<a name="ln122">  void        *cookie;</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">/* Struct to save a few things while debugging.  Used in do_cmdline() only. */</a>
<a name="ln127">struct dbg_stuff {</a>
<a name="ln128">  int trylevel;</a>
<a name="ln129">  int force_abort;</a>
<a name="ln130">  except_T    *caught_stack;</a>
<a name="ln131">  char_u      *vv_exception;</a>
<a name="ln132">  char_u      *vv_throwpoint;</a>
<a name="ln133">  int did_emsg;</a>
<a name="ln134">  int got_int;</a>
<a name="ln135">  int need_rethrow;</a>
<a name="ln136">  int check_cstack;</a>
<a name="ln137">  except_T    *current_exception;</a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln141"># include &quot;ex_docmd.c.generated.h&quot;</a>
<a name="ln142">#endif</a>
<a name="ln143"> </a>
<a name="ln144">#ifndef HAVE_WORKING_LIBINTL</a>
<a name="ln145"># define ex_language            ex_ni</a>
<a name="ln146">#endif</a>
<a name="ln147"> </a>
<a name="ln148">/*</a>
<a name="ln149"> * Declare cmdnames[].</a>
<a name="ln150"> */</a>
<a name="ln151">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln152"># include &quot;ex_cmds_defs.generated.h&quot;</a>
<a name="ln153">#endif</a>
<a name="ln154"> </a>
<a name="ln155">static char_u dollar_command[2] = {'$', 0};</a>
<a name="ln156"> </a>
<a name="ln157">static void save_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln158">{</a>
<a name="ln159">  dsp-&gt;trylevel       = trylevel;             trylevel = 0;</a>
<a name="ln160">  dsp-&gt;force_abort    = force_abort;          force_abort = FALSE;</a>
<a name="ln161">  dsp-&gt;caught_stack   = caught_stack;         caught_stack = NULL;</a>
<a name="ln162">  dsp-&gt;vv_exception   = v_exception(NULL);</a>
<a name="ln163">  dsp-&gt;vv_throwpoint  = v_throwpoint(NULL);</a>
<a name="ln164"> </a>
<a name="ln165">  // Necessary for debugging an inactive &quot;:catch&quot;, &quot;:finally&quot;, &quot;:endtry&quot;.</a>
<a name="ln166">  dsp-&gt;did_emsg       = did_emsg;             did_emsg     = false;</a>
<a name="ln167">  dsp-&gt;got_int        = got_int;              got_int      = false;</a>
<a name="ln168">  dsp-&gt;need_rethrow   = need_rethrow;         need_rethrow = false;</a>
<a name="ln169">  dsp-&gt;check_cstack   = check_cstack;         check_cstack = false;</a>
<a name="ln170">  dsp-&gt;current_exception = current_exception; current_exception = NULL;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void restore_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln174">{</a>
<a name="ln175">  suppress_errthrow = false;</a>
<a name="ln176">  trylevel = dsp-&gt;trylevel;</a>
<a name="ln177">  force_abort = dsp-&gt;force_abort;</a>
<a name="ln178">  caught_stack = dsp-&gt;caught_stack;</a>
<a name="ln179">  (void)v_exception(dsp-&gt;vv_exception);</a>
<a name="ln180">  (void)v_throwpoint(dsp-&gt;vv_throwpoint);</a>
<a name="ln181">  did_emsg = dsp-&gt;did_emsg;</a>
<a name="ln182">  got_int = dsp-&gt;got_int;</a>
<a name="ln183">  need_rethrow = dsp-&gt;need_rethrow;</a>
<a name="ln184">  check_cstack = dsp-&gt;check_cstack;</a>
<a name="ln185">  current_exception = dsp-&gt;current_exception;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">/// Repeatedly get commands for Ex mode, until the &quot;:vi&quot; command is given.</a>
<a name="ln189">void do_exmode(int improved)</a>
<a name="ln190">{</a>
<a name="ln191">  int save_msg_scroll;</a>
<a name="ln192">  int prev_msg_row;</a>
<a name="ln193">  linenr_T prev_line;</a>
<a name="ln194">  int changedtick;</a>
<a name="ln195"> </a>
<a name="ln196">  if (improved)</a>
<a name="ln197">    exmode_active = EXMODE_VIM;</a>
<a name="ln198">  else</a>
<a name="ln199">    exmode_active = EXMODE_NORMAL;</a>
<a name="ln200">  State = NORMAL;</a>
<a name="ln201"> </a>
<a name="ln202">  /* When using &quot;:global /pat/ visual&quot; and then &quot;Q&quot; we return to continue</a>
<a name="ln203">   * the :global command. */</a>
<a name="ln204">  if (global_busy)</a>
<a name="ln205">    return;</a>
<a name="ln206"> </a>
<a name="ln207">  save_msg_scroll = msg_scroll;</a>
<a name="ln208">  RedrawingDisabled++;  // don't redisplay the window</a>
<a name="ln209">  no_wait_return++;  // don't wait for return</a>
<a name="ln210"> </a>
<a name="ln211">  MSG(_(&quot;Entering Ex mode.  Type \&quot;visual\&quot; to go to Normal mode.&quot;));</a>
<a name="ln212">  while (exmode_active) {</a>
<a name="ln213">    /* Check for a &quot;:normal&quot; command and no more characters left. */</a>
<a name="ln214">    if (ex_normal_busy &gt; 0 &amp;&amp; typebuf.tb_len == 0) {</a>
<a name="ln215">      exmode_active = FALSE;</a>
<a name="ln216">      break;</a>
<a name="ln217">    }</a>
<a name="ln218">    msg_scroll = true;</a>
<a name="ln219">    need_wait_return = false;</a>
<a name="ln220">    ex_pressedreturn = false;</a>
<a name="ln221">    ex_no_reprint = false;</a>
<a name="ln222">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln223">    prev_msg_row = msg_row;</a>
<a name="ln224">    prev_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln225">    cmdline_row = msg_row;</a>
<a name="ln226">    do_cmdline(NULL, getexline, NULL, 0);</a>
<a name="ln227">    lines_left = Rows - 1;</a>
<a name="ln228"> </a>
<a name="ln229">    if ((prev_line != curwin-&gt;w_cursor.lnum</a>
<a name="ln230">         || changedtick != buf_get_changedtick(curbuf)) &amp;&amp; !ex_no_reprint) {</a>
<a name="ln231">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln232">        EMSG(_(e_emptybuf));</a>
<a name="ln233">      } else {</a>
<a name="ln234">        if (ex_pressedreturn) {</a>
<a name="ln235">          /* go up one line, to overwrite the &quot;:&lt;CR&gt;&quot; line, so the</a>
<a name="ln236">           * output doesn't contain empty lines. */</a>
<a name="ln237">          msg_row = prev_msg_row;</a>
<a name="ln238">          if (prev_msg_row == Rows - 1)</a>
<a name="ln239">            msg_row--;</a>
<a name="ln240">        }</a>
<a name="ln241">        msg_col = 0;</a>
<a name="ln242">        print_line_no_prefix(curwin-&gt;w_cursor.lnum, FALSE, FALSE);</a>
<a name="ln243">        msg_clr_eos();</a>
<a name="ln244">      }</a>
<a name="ln245">    } else if (ex_pressedreturn &amp;&amp; !ex_no_reprint) {  /* must be at EOF */</a>
<a name="ln246">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln247">        EMSG(_(e_emptybuf));</a>
<a name="ln248">      else</a>
<a name="ln249">        EMSG(_(&quot;E501: At end-of-file&quot;));</a>
<a name="ln250">    }</a>
<a name="ln251">  }</a>
<a name="ln252"> </a>
<a name="ln253">  RedrawingDisabled--;</a>
<a name="ln254">  no_wait_return--;</a>
<a name="ln255">  redraw_all_later(NOT_VALID);</a>
<a name="ln256">  update_screen(NOT_VALID);</a>
<a name="ln257">  need_wait_return = false;</a>
<a name="ln258">  msg_scroll = save_msg_scroll;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">// Print the executed command for when 'verbose' is set.</a>
<a name="ln262">// When &quot;lnum&quot; is 0 only print the command.</a>
<a name="ln263">static void msg_verbose_cmd(linenr_T lnum, char_u *cmd)</a>
<a name="ln264">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln265">{</a>
<a name="ln266">  no_wait_return++;</a>
<a name="ln267">  verbose_enter_scroll();</a>
<a name="ln268"> </a>
<a name="ln269">  if (lnum == 0) {</a>
<a name="ln270">    smsg(_(&quot;Executing: %s&quot;), cmd);</a>
<a name="ln271">  } else {</a>
<a name="ln272">    smsg(_(&quot;line %&quot; PRIdLINENR &quot;: %s&quot;), lnum, cmd);</a>
<a name="ln273">  }</a>
<a name="ln274">  if (msg_silent == 0) {</a>
<a name="ln275">    msg_puts(&quot;\n&quot;);   // don't overwrite this</a>
<a name="ln276">  }</a>
<a name="ln277"> </a>
<a name="ln278">  verbose_leave_scroll();</a>
<a name="ln279">  no_wait_return--;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/*</a>
<a name="ln283"> * Execute a simple command line.  Used for translated commands like &quot;*&quot;.</a>
<a name="ln284"> */</a>
<a name="ln285">int do_cmdline_cmd(const char *cmd)</a>
<a name="ln286">{</a>
<a name="ln287">  return do_cmdline((char_u *)cmd, NULL, NULL,</a>
<a name="ln288">                    DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">/// do_cmdline(): execute one Ex command line</a>
<a name="ln292">///</a>
<a name="ln293">/// 1. Execute &quot;cmdline&quot; when it is not NULL.</a>
<a name="ln294">///    If &quot;cmdline&quot; is NULL, or more lines are needed, fgetline() is used.</a>
<a name="ln295">/// 2. Split up in parts separated with '|'.</a>
<a name="ln296">///</a>
<a name="ln297">/// This function can be called recursively!</a>
<a name="ln298">///</a>
<a name="ln299">/// flags:</a>
<a name="ln300">///   DOCMD_VERBOSE  - The command will be included in the error message.</a>
<a name="ln301">///   DOCMD_NOWAIT   - Don't call wait_return() and friends.</a>
<a name="ln302">///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.</a>
<a name="ln303">///   DOCMD_KEYTYPED - Don't reset KeyTyped.</a>
<a name="ln304">///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).</a>
<a name="ln305">///   DOCMD_KEEPLINE - Store first typed line (for repeating with &quot;.&quot;).</a>
<a name="ln306">///</a>
<a name="ln307">/// @return FAIL if cmdline could not be executed, OK otherwise</a>
<a name="ln308">int do_cmdline(char_u *cmdline, LineGetter fgetline,</a>
<a name="ln309">               void *cookie, /* argument for fgetline() */</a>
<a name="ln310">               int flags)</a>
<a name="ln311">{</a>
<a name="ln312">  char_u      *next_cmdline;            /* next cmd to execute */</a>
<a name="ln313">  char_u      *cmdline_copy = NULL;     /* copy of cmd line */</a>
<a name="ln314">  int used_getline = FALSE;             /* used &quot;fgetline&quot; to obtain command */</a>
<a name="ln315">  static int recursive = 0;             /* recursive depth */</a>
<a name="ln316">  int msg_didout_before_start = 0;</a>
<a name="ln317">  int count = 0;                        /* line number count */</a>
<a name="ln318">  int did_inc = FALSE;                  /* incremented RedrawingDisabled */</a>
<a name="ln319">  int retval = OK;</a>
<a name="ln320">  cstack_T cstack;                      // conditional stack</a>
<a name="ln321">  garray_T lines_ga;                    // keep lines for &quot;:while&quot;/&quot;:for&quot;</a>
<a name="ln322">  int current_line = 0;                 // active line in lines_ga</a>
<a name="ln323">  char_u   *fname = NULL;               // function or script name</a>
<a name="ln324">  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie</a>
<a name="ln325">  int      *dbg_tick = NULL;            // ptr to dbg_tick field in cookie</a>
<a name="ln326">  struct dbg_stuff debug_saved;         // saved things for debug mode</a>
<a name="ln327">  int initial_trylevel;</a>
<a name="ln328">  struct msglist      **saved_msg_list = NULL;</a>
<a name="ln329">  struct msglist      *private_msg_list;</a>
<a name="ln330"> </a>
<a name="ln331">  // &quot;fgetline&quot; and &quot;cookie&quot; passed to do_one_cmd()</a>
<a name="ln332">  char_u      *(*cmd_getline)(int, void *, int, bool);</a>
<a name="ln333">  void        *cmd_cookie;</a>
<a name="ln334">  struct loop_cookie cmd_loop_cookie;</a>
<a name="ln335">  void        *real_cookie;</a>
<a name="ln336">  int getline_is_func;</a>
<a name="ln337">  static int call_depth = 0;            /* recursiveness */</a>
<a name="ln338"> </a>
<a name="ln339">  /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory</a>
<a name="ln340">   * location for storing error messages to be converted to an exception.</a>
<a name="ln341">   * This ensures that the do_errthrow() call in do_one_cmd() does not</a>
<a name="ln342">   * combine the messages stored by an earlier invocation of do_one_cmd()</a>
<a name="ln343">   * with the command name of the later one.  This would happen when</a>
<a name="ln344">   * BufWritePost autocommands are executed after a write error. */</a>
<a name="ln345">  saved_msg_list = msg_list;</a>
<a name="ln346">  msg_list = &amp;private_msg_list;</a>
<a name="ln347">  private_msg_list = NULL;</a>
<a name="ln348"> </a>
<a name="ln349">  // It's possible to create an endless loop with &quot;:execute&quot;, catch that</a>
<a name="ln350">  // here.  The value of 200 allows nested function calls, &quot;:source&quot;, etc.</a>
<a name="ln351">  // Allow 200 or 'maxfuncdepth', whatever is larger.</a>
<a name="ln352">  if (call_depth &gt;= 200 &amp;&amp; call_depth &gt;= p_mfd) {</a>
<a name="ln353">    EMSG(_(&quot;E169: Command too recursive&quot;));</a>
<a name="ln354">    // When converting to an exception, we do not include the command name</a>
<a name="ln355">    // since this is not an error of the specific command.</a>
<a name="ln356">    do_errthrow((cstack_T *)NULL, (char_u *)NULL);</a>
<a name="ln357">    msg_list = saved_msg_list;</a>
<a name="ln358">    return FAIL;</a>
<a name="ln359">  }</a>
<a name="ln360">  call_depth++;</a>
<a name="ln361">  start_batch_changes();</a>
<a name="ln362"> </a>
<a name="ln363">  cstack.cs_idx = -1;</a>
<a name="ln364">  cstack.cs_looplevel = 0;</a>
<a name="ln365">  cstack.cs_trylevel = 0;</a>
<a name="ln366">  cstack.cs_emsg_silent_list = NULL;</a>
<a name="ln367">  cstack.cs_lflags = 0;</a>
<a name="ln368">  ga_init(&amp;lines_ga, (int)sizeof(wcmd_T), 10);</a>
<a name="ln369"> </a>
<a name="ln370">  real_cookie = getline_cookie(fgetline, cookie);</a>
<a name="ln371"> </a>
<a name="ln372">  /* Inside a function use a higher nesting level. */</a>
<a name="ln373">  getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln374">  if (getline_is_func &amp;&amp; ex_nesting_level == func_level(real_cookie))</a>
<a name="ln375">    ++ex_nesting_level;</a>
<a name="ln376"> </a>
<a name="ln377">  /* Get the function or script name and the address where the next breakpoint</a>
<a name="ln378">   * line and the debug tick for a function or script are stored. */</a>
<a name="ln379">  if (getline_is_func) {</a>
<a name="ln380">    fname = func_name(real_cookie);</a>
<a name="ln381">    breakpoint = func_breakpoint(real_cookie);</a>
<a name="ln382">    dbg_tick = func_dbg_tick(real_cookie);</a>
<a name="ln383">  } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln384">    fname = sourcing_name;</a>
<a name="ln385">    breakpoint = source_breakpoint(real_cookie);</a>
<a name="ln386">    dbg_tick = source_dbg_tick(real_cookie);</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  /*</a>
<a name="ln390">   * Initialize &quot;force_abort&quot;  and &quot;suppress_errthrow&quot; at the top level.</a>
<a name="ln391">   */</a>
<a name="ln392">  if (!recursive) {</a>
<a name="ln393">    force_abort = false;</a>
<a name="ln394">    suppress_errthrow = false;</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  // If requested, store and reset the global values controlling the</a>
<a name="ln398">  // exception handling (used when debugging).  Otherwise clear it to avoid</a>
<a name="ln399">  // a bogus compiler warning when the optimizer uses inline functions...</a>
<a name="ln400">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln401">    save_dbg_stuff(&amp;debug_saved);</a>
<a name="ln402">  } else {</a>
<a name="ln403">    memset(&amp;debug_saved, 0, sizeof(debug_saved));</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  initial_trylevel = trylevel;</a>
<a name="ln407"> </a>
<a name="ln408">  current_exception = NULL;</a>
<a name="ln409">  // &quot;did_emsg&quot; will be set to TRUE when emsg() is used, in which case we</a>
<a name="ln410">  // cancel the whole command line, and any if/endif or loop.</a>
<a name="ln411">  // If force_abort is set, we cancel everything.</a>
<a name="ln412">  did_emsg = false;</a>
<a name="ln413"> </a>
<a name="ln414">  // KeyTyped is only set when calling vgetc().  Reset it here when not</a>
<a name="ln415">  // calling vgetc() (sourced command lines).</a>
<a name="ln416">  if (!(flags &amp; DOCMD_KEYTYPED)</a>
<a name="ln417">      &amp;&amp; !getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln418">    KeyTyped = false;</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  /*</a>
<a name="ln422">   * Continue executing command lines:</a>
<a name="ln423">   * - when inside an &quot;:if&quot;, &quot;:while&quot; or &quot;:for&quot;</a>
<a name="ln424">   * - for multiple commands on one line, separated with '|'</a>
<a name="ln425">   * - when repeating until there are no more lines (for &quot;:source&quot;)</a>
<a name="ln426">   */</a>
<a name="ln427">  next_cmdline = cmdline;</a>
<a name="ln428">  do {</a>
<a name="ln429">    getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln430"> </a>
<a name="ln431">    /* stop skipping cmds for an error msg after all endif/while/for */</a>
<a name="ln432">    if (next_cmdline == NULL</a>
<a name="ln433">        &amp;&amp; !force_abort</a>
<a name="ln434">        &amp;&amp; cstack.cs_idx &lt; 0</a>
<a name="ln435">        &amp;&amp; !(getline_is_func &amp;&amp; func_has_abort(real_cookie))</a>
<a name="ln436">        )</a>
<a name="ln437">      did_emsg = FALSE;</a>
<a name="ln438"> </a>
<a name="ln439">    /*</a>
<a name="ln440">     * 1. If repeating a line in a loop, get a line from lines_ga.</a>
<a name="ln441">     * 2. If no line given: Get an allocated line with fgetline().</a>
<a name="ln442">     * 3. If a line is given: Make a copy, so we can mess with it.</a>
<a name="ln443">     */</a>
<a name="ln444"> </a>
<a name="ln445">    /* 1. If repeating, get a previous line from lines_ga. */</a>
<a name="ln446">    if (cstack.cs_looplevel &gt; 0 &amp;&amp; current_line &lt; lines_ga.ga_len) {</a>
<a name="ln447">      /* Each '|' separated command is stored separately in lines_ga, to</a>
<a name="ln448">       * be able to jump to it.  Don't use next_cmdline now. */</a>
<a name="ln449">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln450"> </a>
<a name="ln451">      /* Check if a function has returned or, unless it has an unclosed</a>
<a name="ln452">       * try conditional, aborted. */</a>
<a name="ln453">      if (getline_is_func) {</a>
<a name="ln454">        if (do_profiling == PROF_YES)</a>
<a name="ln455">          func_line_end(real_cookie);</a>
<a name="ln456">        if (func_has_ended(real_cookie)) {</a>
<a name="ln457">          retval = FAIL;</a>
<a name="ln458">          break;</a>
<a name="ln459">        }</a>
<a name="ln460">      } else if (do_profiling == PROF_YES</a>
<a name="ln461">                 &amp;&amp; getline_equal(fgetline, cookie, getsourceline))</a>
<a name="ln462">        script_line_end();</a>
<a name="ln463"> </a>
<a name="ln464">      /* Check if a sourced file hit a &quot;:finish&quot; command. */</a>
<a name="ln465">      if (source_finished(fgetline, cookie)) {</a>
<a name="ln466">        retval = FAIL;</a>
<a name="ln467">        break;</a>
<a name="ln468">      }</a>
<a name="ln469"> </a>
<a name="ln470">      /* If breakpoints have been added/deleted need to check for it. */</a>
<a name="ln471">      if (breakpoint != NULL &amp;&amp; dbg_tick != NULL</a>
<a name="ln472">          &amp;&amp; *dbg_tick != debug_tick) {</a>
<a name="ln473">        *breakpoint = dbg_find_breakpoint(</a>
<a name="ln474">            getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln475">            fname, sourcing_lnum);</a>
<a name="ln476">        *dbg_tick = debug_tick;</a>
<a name="ln477">      }</a>
<a name="ln478"> </a>
<a name="ln479">      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;</a>
<a name="ln480">      sourcing_lnum = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;</a>
<a name="ln481"> </a>
<a name="ln482">      /* Did we encounter a breakpoint? */</a>
<a name="ln483">      if (breakpoint != NULL &amp;&amp; *breakpoint != 0</a>
<a name="ln484">          &amp;&amp; *breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln485">        dbg_breakpoint(fname, sourcing_lnum);</a>
<a name="ln486">        /* Find next breakpoint. */</a>
<a name="ln487">        *breakpoint = dbg_find_breakpoint(</a>
<a name="ln488">            getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln489">            fname, sourcing_lnum);</a>
<a name="ln490">        *dbg_tick = debug_tick;</a>
<a name="ln491">      }</a>
<a name="ln492">      if (do_profiling == PROF_YES) {</a>
<a name="ln493">        if (getline_is_func)</a>
<a name="ln494">          func_line_start(real_cookie);</a>
<a name="ln495">        else if (getline_equal(fgetline, cookie, getsourceline))</a>
<a name="ln496">          script_line_start();</a>
<a name="ln497">      }</a>
<a name="ln498">    }</a>
<a name="ln499"> </a>
<a name="ln500">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln501">      /* Inside a while/for loop we need to store the lines and use them</a>
<a name="ln502">       * again.  Pass a different &quot;fgetline&quot; function to do_one_cmd()</a>
<a name="ln503">       * below, so that it stores lines in or reads them from</a>
<a name="ln504">       * &quot;lines_ga&quot;.  Makes it possible to define a function inside a</a>
<a name="ln505">       * while/for loop. */</a>
<a name="ln506">      cmd_getline = get_loop_line;</a>
<a name="ln507">      cmd_cookie = (void *)&amp;cmd_loop_cookie;</a>
<a name="ln508">      cmd_loop_cookie.lines_gap = &amp;lines_ga;</a>
<a name="ln509">      cmd_loop_cookie.current_line = current_line;</a>
<a name="ln510">      cmd_loop_cookie.getline = fgetline;</a>
<a name="ln511">      cmd_loop_cookie.cookie = cookie;</a>
<a name="ln512">      cmd_loop_cookie.repeating = (current_line &lt; lines_ga.ga_len);</a>
<a name="ln513">    } else {</a>
<a name="ln514">      cmd_getline = fgetline;</a>
<a name="ln515">      cmd_cookie = cookie;</a>
<a name="ln516">    }</a>
<a name="ln517"> </a>
<a name="ln518">    /* 2. If no line given, get an allocated line with fgetline(). */</a>
<a name="ln519">    if (next_cmdline == NULL) {</a>
<a name="ln520">      /*</a>
<a name="ln521">       * Need to set msg_didout for the first line after an &quot;:if&quot;,</a>
<a name="ln522">       * otherwise the &quot;:if&quot; will be overwritten.</a>
<a name="ln523">       */</a>
<a name="ln524">      if (count == 1 &amp;&amp; getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln525">        msg_didout = true;</a>
<a name="ln526">      }</a>
<a name="ln527">      if (fgetline == NULL</a>
<a name="ln528">          || (next_cmdline = fgetline(':', cookie,</a>
<a name="ln529">                                      cstack.cs_idx &lt;</a>
<a name="ln530">                                      0 ? 0 : (cstack.cs_idx + 1) * 2,</a>
<a name="ln531">                                      true)) == NULL) {</a>
<a name="ln532">        // Don't call wait_return for aborted command line.  The NULL</a>
<a name="ln533">        // returned for the end of a sourced file or executed function</a>
<a name="ln534">        // doesn't do this.</a>
<a name="ln535">        if (KeyTyped &amp;&amp; !(flags &amp; DOCMD_REPEAT)) {</a>
<a name="ln536">          need_wait_return = false;</a>
<a name="ln537">        }</a>
<a name="ln538">        retval = FAIL;</a>
<a name="ln539">        break;</a>
<a name="ln540">      }</a>
<a name="ln541">      used_getline = TRUE;</a>
<a name="ln542"> </a>
<a name="ln543">      /*</a>
<a name="ln544">       * Keep the first typed line.  Clear it when more lines are typed.</a>
<a name="ln545">       */</a>
<a name="ln546">      if (flags &amp; DOCMD_KEEPLINE) {</a>
<a name="ln547">        xfree(repeat_cmdline);</a>
<a name="ln548">        if (count == 0)</a>
<a name="ln549">          repeat_cmdline = vim_strsave(next_cmdline);</a>
<a name="ln550">        else</a>
<a name="ln551">          repeat_cmdline = NULL;</a>
<a name="ln552">      }</a>
<a name="ln553">    }</a>
<a name="ln554">    /* 3. Make a copy of the command so we can mess with it. */</a>
<a name="ln555">    else if (cmdline_copy == NULL) {</a>
<a name="ln556">      next_cmdline = vim_strsave(next_cmdline);</a>
<a name="ln557">    }</a>
<a name="ln558">    cmdline_copy = next_cmdline;</a>
<a name="ln559"> </a>
<a name="ln560">    /*</a>
<a name="ln561">     * Save the current line when inside a &quot;:while&quot; or &quot;:for&quot;, and when</a>
<a name="ln562">     * the command looks like a &quot;:while&quot; or &quot;:for&quot;, because we may need it</a>
<a name="ln563">     * later.  When there is a '|' and another command, it is stored</a>
<a name="ln564">     * separately, because we need to be able to jump back to it from an</a>
<a name="ln565">     * :endwhile/:endfor.</a>
<a name="ln566">     */</a>
<a name="ln567">    if (current_line == lines_ga.ga_len</a>
<a name="ln568">        &amp;&amp; (cstack.cs_looplevel || has_loop_cmd(next_cmdline))) {</a>
<a name="ln569">      store_loop_line(&amp;lines_ga, next_cmdline);</a>
<a name="ln570">    }</a>
<a name="ln571">    did_endif = FALSE;</a>
<a name="ln572"> </a>
<a name="ln573">    if (count++ == 0) {</a>
<a name="ln574">      /*</a>
<a name="ln575">       * All output from the commands is put below each other, without</a>
<a name="ln576">       * waiting for a return. Don't do this when executing commands</a>
<a name="ln577">       * from a script or when being called recursive (e.g. for &quot;:e</a>
<a name="ln578">       * +command file&quot;).</a>
<a name="ln579">       */</a>
<a name="ln580">      if (!(flags &amp; DOCMD_NOWAIT) &amp;&amp; !recursive) {</a>
<a name="ln581">        msg_didout_before_start = msg_didout;</a>
<a name="ln582">        msg_didany = FALSE;         /* no output yet */</a>
<a name="ln583">        msg_start();</a>
<a name="ln584">        msg_scroll = TRUE;          /* put messages below each other */</a>
<a name="ln585">        ++no_wait_return;           /* don't wait for return until finished */</a>
<a name="ln586">        ++RedrawingDisabled;</a>
<a name="ln587">        did_inc = TRUE;</a>
<a name="ln588">      }</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">    if ((p_verbose &gt;= 15 &amp;&amp; sourcing_name != NULL) || p_verbose &gt;= 16) {</a>
<a name="ln592">      msg_verbose_cmd(sourcing_lnum, cmdline_copy);</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    /*</a>
<a name="ln596">     * 2. Execute one '|' separated command.</a>
<a name="ln597">     *    do_one_cmd() will return NULL if there is no trailing '|'.</a>
<a name="ln598">     *    &quot;cmdline_copy&quot; can change, e.g. for '%' and '#' expansion.</a>
<a name="ln599">     */</a>
<a name="ln600">    recursive++;</a>
<a name="ln601">    next_cmdline = do_one_cmd(&amp;cmdline_copy, flags,</a>
<a name="ln602">                              &amp;cstack,</a>
<a name="ln603">                              cmd_getline, cmd_cookie);</a>
<a name="ln604">    recursive--;</a>
<a name="ln605"> </a>
<a name="ln606">    // Ignore trailing '|'-separated commands in preview-mode ('inccommand').</a>
<a name="ln607">    if (State &amp; CMDPREVIEW) {</a>
<a name="ln608">      next_cmdline = NULL;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">    if (cmd_cookie == (void *)&amp;cmd_loop_cookie)</a>
<a name="ln612">      /* Use &quot;current_line&quot; from &quot;cmd_loop_cookie&quot;, it may have been</a>
<a name="ln613">       * incremented when defining a function. */</a>
<a name="ln614">      current_line = cmd_loop_cookie.current_line;</a>
<a name="ln615"> </a>
<a name="ln616">    if (next_cmdline == NULL) {</a>
<a name="ln617">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln618">      //</a>
<a name="ln619">      // If the command was typed, remember it for the ':' register.</a>
<a name="ln620">      // Do this AFTER executing the command to make :@: work.</a>
<a name="ln621">      //</a>
<a name="ln622">      if (getline_equal(fgetline, cookie, getexline)</a>
<a name="ln623">          &amp;&amp; new_last_cmdline != NULL) {</a>
<a name="ln624">        xfree(last_cmdline);</a>
<a name="ln625">        last_cmdline = new_last_cmdline;</a>
<a name="ln626">        new_last_cmdline = NULL;</a>
<a name="ln627">      }</a>
<a name="ln628">    } else {</a>
<a name="ln629">      /* need to copy the command after the '|' to cmdline_copy, for the</a>
<a name="ln630">       * next do_one_cmd() */</a>
<a name="ln631">      STRMOVE(cmdline_copy, next_cmdline);</a>
<a name="ln632">      next_cmdline = cmdline_copy;</a>
<a name="ln633">    }</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">    /* reset did_emsg for a function that is not aborted by an error */</a>
<a name="ln637">    if (did_emsg &amp;&amp; !force_abort</a>
<a name="ln638">        &amp;&amp; getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln639">        &amp;&amp; !func_has_abort(real_cookie))</a>
<a name="ln640">      did_emsg = FALSE;</a>
<a name="ln641"> </a>
<a name="ln642">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln643">      ++current_line;</a>
<a name="ln644"> </a>
<a name="ln645">      /*</a>
<a name="ln646">       * An &quot;:endwhile&quot;, &quot;:endfor&quot; and &quot;:continue&quot; is handled here.</a>
<a name="ln647">       * If we were executing commands, jump back to the &quot;:while&quot; or</a>
<a name="ln648">       * &quot;:for&quot;.</a>
<a name="ln649">       * If we were not executing commands, decrement cs_looplevel.</a>
<a name="ln650">       */</a>
<a name="ln651">      if (cstack.cs_lflags &amp; (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {</a>
<a name="ln652">        cstack.cs_lflags &amp;= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);</a>
<a name="ln653"> </a>
<a name="ln654">        /* Jump back to the matching &quot;:while&quot; or &quot;:for&quot;.  Be careful</a>
<a name="ln655">         * not to use a cs_line[] from an entry that isn't a &quot;:while&quot;</a>
<a name="ln656">         * or &quot;:for&quot;: It would make &quot;current_line&quot; invalid and can</a>
<a name="ln657">         * cause a crash. */</a>
<a name="ln658">        if (!did_emsg &amp;&amp; !got_int &amp;&amp; !current_exception</a>
<a name="ln659">            &amp;&amp; cstack.cs_idx &gt;= 0</a>
<a name="ln660">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx]</a>
<a name="ln661">                &amp; (CSF_WHILE | CSF_FOR))</a>
<a name="ln662">            &amp;&amp; cstack.cs_line[cstack.cs_idx] &gt;= 0</a>
<a name="ln663">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx] &amp; CSF_ACTIVE)) {</a>
<a name="ln664">          current_line = cstack.cs_line[cstack.cs_idx];</a>
<a name="ln665">          /* remember we jumped there */</a>
<a name="ln666">          cstack.cs_lflags |= CSL_HAD_LOOP;</a>
<a name="ln667">          line_breakcheck();                    /* check if CTRL-C typed */</a>
<a name="ln668"> </a>
<a name="ln669">          /* Check for the next breakpoint at or after the &quot;:while&quot;</a>
<a name="ln670">           * or &quot;:for&quot;. */</a>
<a name="ln671">          if (breakpoint != NULL) {</a>
<a name="ln672">            *breakpoint = dbg_find_breakpoint(</a>
<a name="ln673">                getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln674">                fname,</a>
<a name="ln675">                ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);</a>
<a name="ln676">            *dbg_tick = debug_tick;</a>
<a name="ln677">          }</a>
<a name="ln678">        } else {</a>
<a name="ln679">          /* can only get here with &quot;:endwhile&quot; or &quot;:endfor&quot; */</a>
<a name="ln680">          if (cstack.cs_idx &gt;= 0)</a>
<a name="ln681">            rewind_conditionals(&amp;cstack, cstack.cs_idx - 1,</a>
<a name="ln682">                CSF_WHILE | CSF_FOR, &amp;cstack.cs_looplevel);</a>
<a name="ln683">        }</a>
<a name="ln684">      }</a>
<a name="ln685">      /*</a>
<a name="ln686">       * For a &quot;:while&quot; or &quot;:for&quot; we need to remember the line number.</a>
<a name="ln687">       */</a>
<a name="ln688">      else if (cstack.cs_lflags &amp; CSL_HAD_LOOP) {</a>
<a name="ln689">        cstack.cs_lflags &amp;= ~CSL_HAD_LOOP;</a>
<a name="ln690">        cstack.cs_line[cstack.cs_idx] = current_line - 1;</a>
<a name="ln691">      }</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    /*</a>
<a name="ln695">     * When not inside any &quot;:while&quot; loop, clear remembered lines.</a>
<a name="ln696">     */</a>
<a name="ln697">    if (cstack.cs_looplevel == 0) {</a>
<a name="ln698">      if (!GA_EMPTY(&amp;lines_ga)) {</a>
<a name="ln699">        sourcing_lnum = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;</a>
<a name="ln700">        GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln701">      }</a>
<a name="ln702">      current_line = 0;</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    /*</a>
<a name="ln706">     * A &quot;:finally&quot; makes did_emsg, got_int and current_exception pending for</a>
<a name="ln707">     * being restored at the &quot;:endtry&quot;.  Reset them here and set the</a>
<a name="ln708">     * ACTIVE and FINALLY flags, so that the finally clause gets executed.</a>
<a name="ln709">     * This includes the case where a missing &quot;:endif&quot;, &quot;:endwhile&quot; or</a>
<a name="ln710">     * &quot;:endfor&quot; was detected by the &quot;:finally&quot; itself.</a>
<a name="ln711">     */</a>
<a name="ln712">    if (cstack.cs_lflags &amp; CSL_HAD_FINA) {</a>
<a name="ln713">      cstack.cs_lflags &amp;= ~CSL_HAD_FINA;</a>
<a name="ln714">      report_make_pending((cstack.cs_pending[cstack.cs_idx]</a>
<a name="ln715">                           &amp; (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),</a>
<a name="ln716">                          current_exception);</a>
<a name="ln717">      did_emsg = got_int = false;</a>
<a name="ln718">      current_exception = NULL;</a>
<a name="ln719">      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;</a>
<a name="ln720">    }</a>
<a name="ln721"> </a>
<a name="ln722">    /* Update global &quot;trylevel&quot; for recursive calls to do_cmdline() from</a>
<a name="ln723">     * within this loop. */</a>
<a name="ln724">    trylevel = initial_trylevel + cstack.cs_trylevel;</a>
<a name="ln725"> </a>
<a name="ln726">    // If the outermost try conditional (across function calls and sourced</a>
<a name="ln727">    // files) is aborted because of an error, an interrupt, or an uncaught</a>
<a name="ln728">    // exception, cancel everything.  If it is left normally, reset</a>
<a name="ln729">    // force_abort to get the non-EH compatible abortion behavior for</a>
<a name="ln730">    // the rest of the script.</a>
<a name="ln731">    if (trylevel == 0 &amp;&amp; !did_emsg &amp;&amp; !got_int &amp;&amp; !current_exception) {</a>
<a name="ln732">      force_abort = false;</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    /* Convert an interrupt to an exception if appropriate. */</a>
<a name="ln736">    (void)do_intthrow(&amp;cstack);</a>
<a name="ln737"> </a>
<a name="ln738">  }</a>
<a name="ln739">  /*</a>
<a name="ln740">   * Continue executing command lines when:</a>
<a name="ln741">   * - no CTRL-C typed, no aborting error, no exception thrown or try</a>
<a name="ln742">   *   conditionals need to be checked for executing finally clauses or</a>
<a name="ln743">   *   catching an interrupt exception</a>
<a name="ln744">   * - didn't get an error message or lines are not typed</a>
<a name="ln745">   * - there is a command after '|', inside a :if, :while, :for or :try, or</a>
<a name="ln746">   *   looping for &quot;:source&quot; command or function call.</a>
<a name="ln747">   */</a>
<a name="ln748">  while (!((got_int || (did_emsg &amp;&amp; force_abort) || current_exception)</a>
<a name="ln749">           &amp;&amp; cstack.cs_trylevel == 0)</a>
<a name="ln750">         &amp;&amp; !(did_emsg</a>
<a name="ln751">              /* Keep going when inside try/catch, so that the error can be</a>
<a name="ln752">               * deal with, except when it is a syntax error, it may cause</a>
<a name="ln753">               * the :endtry to be missed. */</a>
<a name="ln754">              &amp;&amp; (cstack.cs_trylevel == 0 || did_emsg_syntax)</a>
<a name="ln755">              &amp;&amp; used_getline</a>
<a name="ln756">              &amp;&amp; (getline_equal(fgetline, cookie, getexmodeline)</a>
<a name="ln757">                  || getline_equal(fgetline, cookie, getexline)))</a>
<a name="ln758">         &amp;&amp; (next_cmdline != NULL</a>
<a name="ln759">             || cstack.cs_idx &gt;= 0</a>
<a name="ln760">             || (flags &amp; DOCMD_REPEAT)));</a>
<a name="ln761"> </a>
<a name="ln762">  xfree(cmdline_copy);</a>
<a name="ln763">  did_emsg_syntax = FALSE;</a>
<a name="ln764">  GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln765"> </a>
<a name="ln766">  if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln767">    /*</a>
<a name="ln768">     * If a sourced file or executed function ran to its end, report the</a>
<a name="ln769">     * unclosed conditional.</a>
<a name="ln770">     */</a>
<a name="ln771">    if (!got_int &amp;&amp; !current_exception</a>
<a name="ln772">        &amp;&amp; ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln773">             &amp;&amp; !source_finished(fgetline, cookie))</a>
<a name="ln774">            || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln775">                &amp;&amp; !func_has_ended(real_cookie)))) {</a>
<a name="ln776">      if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_TRY)</a>
<a name="ln777">        EMSG(_(e_endtry));</a>
<a name="ln778">      else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_WHILE)</a>
<a name="ln779">        EMSG(_(e_endwhile));</a>
<a name="ln780">      else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_FOR)</a>
<a name="ln781">        EMSG(_(e_endfor));</a>
<a name="ln782">      else</a>
<a name="ln783">        EMSG(_(e_endif));</a>
<a name="ln784">    }</a>
<a name="ln785"> </a>
<a name="ln786">    /*</a>
<a name="ln787">     * Reset &quot;trylevel&quot; in case of a &quot;:finish&quot; or &quot;:return&quot; or a missing</a>
<a name="ln788">     * &quot;:endtry&quot; in a sourced file or executed function.  If the try</a>
<a name="ln789">     * conditional is in its finally clause, ignore anything pending.</a>
<a name="ln790">     * If it is in a catch clause, finish the caught exception.</a>
<a name="ln791">     * Also cleanup any &quot;cs_forinfo&quot; structures.</a>
<a name="ln792">     */</a>
<a name="ln793">    do {</a>
<a name="ln794">      int idx = cleanup_conditionals(&amp;cstack, 0, TRUE);</a>
<a name="ln795"> </a>
<a name="ln796">      if (idx &gt;= 0)</a>
<a name="ln797">        --idx;              /* remove try block not in its finally clause */</a>
<a name="ln798">      rewind_conditionals(&amp;cstack, idx, CSF_WHILE | CSF_FOR,</a>
<a name="ln799">          &amp;cstack.cs_looplevel);</a>
<a name="ln800">    } while (cstack.cs_idx &gt;= 0);</a>
<a name="ln801">    trylevel = initial_trylevel;</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  /* If a missing &quot;:endtry&quot;, &quot;:endwhile&quot;, &quot;:endfor&quot;, or &quot;:endif&quot; or a memory</a>
<a name="ln805">   * lack was reported above and the error message is to be converted to an</a>
<a name="ln806">   * exception, do this now after rewinding the cstack. */</a>
<a name="ln807">  do_errthrow(&amp;cstack, getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln808">      ? (char_u *)&quot;endfunction&quot; : (char_u *)NULL);</a>
<a name="ln809"> </a>
<a name="ln810">  if (trylevel == 0) {</a>
<a name="ln811">    // When an exception is being thrown out of the outermost try</a>
<a name="ln812">    // conditional, discard the uncaught exception, disable the conversion</a>
<a name="ln813">    // of interrupts or errors to exceptions, and ensure that no more</a>
<a name="ln814">    // commands are executed.</a>
<a name="ln815">    if (current_exception) {</a>
<a name="ln816">      void *p = NULL;</a>
<a name="ln817">      char_u *saved_sourcing_name;</a>
<a name="ln818">      int saved_sourcing_lnum;</a>
<a name="ln819">      struct msglist *messages = NULL;</a>
<a name="ln820">      struct msglist *next;</a>
<a name="ln821"> </a>
<a name="ln822">      /*</a>
<a name="ln823">       * If the uncaught exception is a user exception, report it as an</a>
<a name="ln824">       * error.  If it is an error exception, display the saved error</a>
<a name="ln825">       * message now.  For an interrupt exception, do nothing; the</a>
<a name="ln826">       * interrupt message is given elsewhere.</a>
<a name="ln827">       */</a>
<a name="ln828">      switch (current_exception-&gt;type) {</a>
<a name="ln829">      case ET_USER:</a>
<a name="ln830">        vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln831">            _(&quot;E605: Exception not caught: %s&quot;),</a>
<a name="ln832">            current_exception-&gt;value);</a>
<a name="ln833">        p = vim_strsave(IObuff);</a>
<a name="ln834">        break;</a>
<a name="ln835">      case ET_ERROR:</a>
<a name="ln836">        messages = current_exception-&gt;messages;</a>
<a name="ln837">        current_exception-&gt;messages = NULL;</a>
<a name="ln838">        break;</a>
<a name="ln839">      case ET_INTERRUPT:</a>
<a name="ln840">        break;</a>
<a name="ln841">      }</a>
<a name="ln842"> </a>
<a name="ln843">      saved_sourcing_name = sourcing_name;</a>
<a name="ln844">      saved_sourcing_lnum = sourcing_lnum;</a>
<a name="ln845">      sourcing_name = current_exception-&gt;throw_name;</a>
<a name="ln846">      sourcing_lnum = current_exception-&gt;throw_lnum;</a>
<a name="ln847">      current_exception-&gt;throw_name = NULL;</a>
<a name="ln848"> </a>
<a name="ln849">      discard_current_exception();              // uses IObuff if 'verbose'</a>
<a name="ln850">      suppress_errthrow = true;</a>
<a name="ln851">      force_abort = true;</a>
<a name="ln852">      msg_ext_set_kind(&quot;emsg&quot;);  // kind=emsg for :throw, exceptions. #9993</a>
<a name="ln853"> </a>
<a name="ln854">      if (messages != NULL) {</a>
<a name="ln855">        do {</a>
<a name="ln856">          next = messages-&gt;next;</a>
<a name="ln857">          emsg(messages-&gt;msg);</a>
<a name="ln858">          xfree(messages-&gt;msg);</a>
<a name="ln859">          xfree(messages);</a>
<a name="ln860">          messages = next;</a>
<a name="ln861">        } while (messages != NULL);</a>
<a name="ln862">      } else if (p != NULL) {</a>
<a name="ln863">        emsg(p);</a>
<a name="ln864">        xfree(p);</a>
<a name="ln865">      }</a>
<a name="ln866">      xfree(sourcing_name);</a>
<a name="ln867">      sourcing_name = saved_sourcing_name;</a>
<a name="ln868">      sourcing_lnum = saved_sourcing_lnum;</a>
<a name="ln869">    } else if (got_int || (did_emsg &amp;&amp; force_abort)) {</a>
<a name="ln870">      // On an interrupt or an aborting error not converted to an exception,</a>
<a name="ln871">      // disable the conversion of errors to exceptions.  (Interrupts are not</a>
<a name="ln872">      // converted any more, here.) This enables also the interrupt message</a>
<a name="ln873">      // when force_abort is set and did_emsg unset in case of an interrupt</a>
<a name="ln874">      // from a finally clause after an error.</a>
<a name="ln875">      suppress_errthrow = true;</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  // The current cstack will be freed when do_cmdline() returns.  An uncaught</a>
<a name="ln880">  // exception will have to be rethrown in the previous cstack.  If a function</a>
<a name="ln881">  // has just returned or a script file was just finished and the previous</a>
<a name="ln882">  // cstack belongs to the same function or, respectively, script file, it</a>
<a name="ln883">  // will have to be checked for finally clauses to be executed due to the</a>
<a name="ln884">  // &quot;:return&quot; or &quot;:finish&quot;.  This is done in do_one_cmd().</a>
<a name="ln885">  if (current_exception) {</a>
<a name="ln886">    need_rethrow = true;</a>
<a name="ln887">  }</a>
<a name="ln888">  if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln889">       &amp;&amp; ex_nesting_level &gt; source_level(real_cookie))</a>
<a name="ln890">      || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln891">          &amp;&amp; ex_nesting_level &gt; func_level(real_cookie) + 1)) {</a>
<a name="ln892">    if (!current_exception) {</a>
<a name="ln893">      check_cstack = true;</a>
<a name="ln894">    }</a>
<a name="ln895">  } else {</a>
<a name="ln896">    /* When leaving a function, reduce nesting level. */</a>
<a name="ln897">    if (getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln898">      --ex_nesting_level;</a>
<a name="ln899">    /*</a>
<a name="ln900">     * Go to debug mode when returning from a function in which we are</a>
<a name="ln901">     * single-stepping.</a>
<a name="ln902">     */</a>
<a name="ln903">    if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln904">         || getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln905">        &amp;&amp; ex_nesting_level + 1 &lt;= debug_break_level)</a>
<a name="ln906">      do_debug(getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln907">          ? (char_u *)_(&quot;End of sourced file&quot;)</a>
<a name="ln908">          : (char_u *)_(&quot;End of function&quot;));</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  /*</a>
<a name="ln912">   * Restore the exception environment (done after returning from the</a>
<a name="ln913">   * debugger).</a>
<a name="ln914">   */</a>
<a name="ln915">  if (flags &amp; DOCMD_EXCRESET)</a>
<a name="ln916">    restore_dbg_stuff(&amp;debug_saved);</a>
<a name="ln917"> </a>
<a name="ln918">  msg_list = saved_msg_list;</a>
<a name="ln919"> </a>
<a name="ln920">  /*</a>
<a name="ln921">   * If there was too much output to fit on the command line, ask the user to</a>
<a name="ln922">   * hit return before redrawing the screen. With the &quot;:global&quot; command we do</a>
<a name="ln923">   * this only once after the command is finished.</a>
<a name="ln924">   */</a>
<a name="ln925">  if (did_inc) {</a>
<a name="ln926">    --RedrawingDisabled;</a>
<a name="ln927">    --no_wait_return;</a>
<a name="ln928">    msg_scroll = FALSE;</a>
<a name="ln929"> </a>
<a name="ln930">    /*</a>
<a name="ln931">     * When just finished an &quot;:if&quot;-&quot;:else&quot; which was typed, no need to</a>
<a name="ln932">     * wait for hit-return.  Also for an error situation.</a>
<a name="ln933">     */</a>
<a name="ln934">    if (retval == FAIL</a>
<a name="ln935">        || (did_endif &amp;&amp; KeyTyped &amp;&amp; !did_emsg)</a>
<a name="ln936">        ) {</a>
<a name="ln937">      need_wait_return = FALSE;</a>
<a name="ln938">      msg_didany = FALSE;               /* don't wait when restarting edit */</a>
<a name="ln939">    } else if (need_wait_return) {</a>
<a name="ln940">      /*</a>
<a name="ln941">       * The msg_start() above clears msg_didout. The wait_return we do</a>
<a name="ln942">       * here should not overwrite the command that may be shown before</a>
<a name="ln943">       * doing that.</a>
<a name="ln944">       */</a>
<a name="ln945">      msg_didout |= msg_didout_before_start;</a>
<a name="ln946">      wait_return(FALSE);</a>
<a name="ln947">    }</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  did_endif = FALSE;    /* in case do_cmdline used recursively */</a>
<a name="ln951"> </a>
<a name="ln952">  call_depth--;</a>
<a name="ln953">  end_batch_changes();</a>
<a name="ln954">  return retval;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">/*</a>
<a name="ln958"> * Obtain a line when inside a &quot;:while&quot; or &quot;:for&quot; loop.</a>
<a name="ln959"> */</a>
<a name="ln960">static char_u *get_loop_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln961">{</a>
<a name="ln962">  struct loop_cookie  *cp = (struct loop_cookie *)cookie;</a>
<a name="ln963">  wcmd_T              *wp;</a>
<a name="ln964">  char_u              *line;</a>
<a name="ln965"> </a>
<a name="ln966">  if (cp-&gt;current_line + 1 &gt;= cp-&gt;lines_gap-&gt;ga_len) {</a>
<a name="ln967">    if (cp-&gt;repeating)</a>
<a name="ln968">      return NULL;              /* trying to read past &quot;:endwhile&quot;/&quot;:endfor&quot; */</a>
<a name="ln969"> </a>
<a name="ln970">    // First time inside the &quot;:while&quot;/&quot;:for&quot;: get line normally.</a>
<a name="ln971">    if (cp-&gt;getline == NULL) {</a>
<a name="ln972">      line = getcmdline(c, 0L, indent, do_concat);</a>
<a name="ln973">    } else {</a>
<a name="ln974">      line = cp-&gt;getline(c, cp-&gt;cookie, indent, do_concat);</a>
<a name="ln975">    }</a>
<a name="ln976">    if (line != NULL) {</a>
<a name="ln977">      store_loop_line(cp-&gt;lines_gap, line);</a>
<a name="ln978">      ++cp-&gt;current_line;</a>
<a name="ln979">    }</a>
<a name="ln980"> </a>
<a name="ln981">    return line;</a>
<a name="ln982">  }</a>
<a name="ln983"> </a>
<a name="ln984">  KeyTyped = false;</a>
<a name="ln985">  cp-&gt;current_line++;</a>
<a name="ln986">  wp = (wcmd_T *)(cp-&gt;lines_gap-&gt;ga_data) + cp-&gt;current_line;</a>
<a name="ln987">  sourcing_lnum = wp-&gt;lnum;</a>
<a name="ln988">  return vim_strsave(wp-&gt;line);</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">/*</a>
<a name="ln992"> * Store a line in &quot;gap&quot; so that a &quot;:while&quot; loop can execute it again.</a>
<a name="ln993"> */</a>
<a name="ln994">static void store_loop_line(garray_T *gap, char_u *line)</a>
<a name="ln995">{</a>
<a name="ln996">  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);</a>
<a name="ln997">  p-&gt;line = vim_strsave(line);</a>
<a name="ln998">  p-&gt;lnum = sourcing_lnum;</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/*</a>
<a name="ln1002"> * If &quot;fgetline&quot; is get_loop_line(), return TRUE if the getline it uses equals</a>
<a name="ln1003"> * &quot;func&quot;.  * Otherwise return TRUE when &quot;fgetline&quot; equals &quot;func&quot;.</a>
<a name="ln1004"> */</a>
<a name="ln1005">int getline_equal(LineGetter fgetline,</a>
<a name="ln1006">                  void *cookie, /* argument for fgetline() */</a>
<a name="ln1007">                  LineGetter func)</a>
<a name="ln1008">{</a>
<a name="ln1009">  LineGetter gp;</a>
<a name="ln1010">  struct loop_cookie *cp;</a>
<a name="ln1011"> </a>
<a name="ln1012">  /* When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln1013">   * function that's originally used to obtain the lines.  This may be</a>
<a name="ln1014">   * nested several levels. */</a>
<a name="ln1015">  gp = fgetline;</a>
<a name="ln1016">  cp = (struct loop_cookie *)cookie;</a>
<a name="ln1017">  while (gp == get_loop_line) {</a>
<a name="ln1018">    gp = cp-&gt;getline;</a>
<a name="ln1019">    cp = cp-&gt;cookie;</a>
<a name="ln1020">  }</a>
<a name="ln1021">  return gp == func;</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">/*</a>
<a name="ln1025"> * If &quot;fgetline&quot; is get_loop_line(), return the cookie used by the original</a>
<a name="ln1026"> * getline function.  Otherwise return &quot;cookie&quot;.</a>
<a name="ln1027"> */</a>
<a name="ln1028">void * getline_cookie(LineGetter fgetline,</a>
<a name="ln1029">                      void *cookie /* argument for fgetline() */</a>
<a name="ln1030">                      )</a>
<a name="ln1031">{</a>
<a name="ln1032">  LineGetter gp;</a>
<a name="ln1033">  struct loop_cookie *cp;</a>
<a name="ln1034"> </a>
<a name="ln1035">  /* When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln1036">   * cookie that's originally used to obtain the lines.  This may be nested</a>
<a name="ln1037">   * several levels. */</a>
<a name="ln1038">  gp = fgetline;</a>
<a name="ln1039">  cp = (struct loop_cookie *)cookie;</a>
<a name="ln1040">  while (gp == get_loop_line) {</a>
<a name="ln1041">    gp = cp-&gt;getline;</a>
<a name="ln1042">    cp = cp-&gt;cookie;</a>
<a name="ln1043">  }</a>
<a name="ln1044">  return cp;</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">/*</a>
<a name="ln1048"> * Helper function to apply an offset for buffer commands, i.e. &quot;:bdelete&quot;,</a>
<a name="ln1049"> * &quot;:bwipeout&quot;, etc.</a>
<a name="ln1050"> * Returns the buffer number.</a>
<a name="ln1051"> */</a>
<a name="ln1052">static int compute_buffer_local_count(int addr_type, int lnum, int offset)</a>
<a name="ln1053">{</a>
<a name="ln1054">  buf_T *buf;</a>
<a name="ln1055">  buf_T *nextbuf;</a>
<a name="ln1056">  int count = offset;</a>
<a name="ln1057"> </a>
<a name="ln1058">  buf = firstbuf;</a>
<a name="ln1059">  while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_fnum &lt; lnum)</a>
<a name="ln1060">    buf = buf-&gt;b_next;</a>
<a name="ln1061">  while (count != 0) {</a>
<a name="ln1062">    count += (count &lt; 0) ? 1 : -1;</a>
<a name="ln1063">    nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1064">    if (nextbuf == NULL)</a>
<a name="ln1065">      break;</a>
<a name="ln1066">    buf = nextbuf;</a>
<a name="ln1067">    if (addr_type == ADDR_LOADED_BUFFERS)</a>
<a name="ln1068">      /* skip over unloaded buffers */</a>
<a name="ln1069">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1070">        nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1071">        if (nextbuf == NULL) {</a>
<a name="ln1072">          break;</a>
<a name="ln1073">        }</a>
<a name="ln1074">        buf = nextbuf;</a>
<a name="ln1075">      }</a>
<a name="ln1076">  }</a>
<a name="ln1077">  // we might have gone too far, last buffer is not loaded</a>
<a name="ln1078">  if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1079">    while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1080">      nextbuf = (offset &gt;= 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1081">      if (nextbuf == NULL)</a>
<a name="ln1082">        break;</a>
<a name="ln1083">      buf = nextbuf;</a>
<a name="ln1084">    }</a>
<a name="ln1085">  }</a>
<a name="ln1086">  return buf-&gt;b_fnum;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">// Return the window number of &quot;win&quot;.</a>
<a name="ln1090">// When &quot;win&quot; is NULL return the number of windows.</a>
<a name="ln1091">static int current_win_nr(const win_T *win)</a>
<a name="ln1092">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1093">{</a>
<a name="ln1094">  int nr = 0;</a>
<a name="ln1095"> </a>
<a name="ln1096">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1097">    ++nr;</a>
<a name="ln1098">    if (wp == win)</a>
<a name="ln1099">      break;</a>
<a name="ln1100">  }</a>
<a name="ln1101">  return nr;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">static int current_tab_nr(tabpage_T *tab)</a>
<a name="ln1105">{</a>
<a name="ln1106">  int nr = 0;</a>
<a name="ln1107"> </a>
<a name="ln1108">  FOR_ALL_TABS(tp) {</a>
<a name="ln1109">    ++nr;</a>
<a name="ln1110">    if (tp == tab)</a>
<a name="ln1111">      break;</a>
<a name="ln1112">  }</a>
<a name="ln1113">  return nr;</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">#define CURRENT_WIN_NR current_win_nr(curwin)</a>
<a name="ln1117">#define LAST_WIN_NR current_win_nr(NULL)</a>
<a name="ln1118">#define CURRENT_TAB_NR current_tab_nr(curtab)</a>
<a name="ln1119">#define LAST_TAB_NR current_tab_nr(NULL)</a>
<a name="ln1120"> </a>
<a name="ln1121"> </a>
<a name="ln1122">/// Figure out the address type for &quot;:wincmd&quot;.</a>
<a name="ln1123">static void get_wincmd_addr_type(char_u *arg, exarg_T *eap)</a>
<a name="ln1124">{</a>
<a name="ln1125">  switch (*arg) {</a>
<a name="ln1126">    case 'S':</a>
<a name="ln1127">    case Ctrl_S:</a>
<a name="ln1128">    case 's':</a>
<a name="ln1129">    case Ctrl_N:</a>
<a name="ln1130">    case 'n':</a>
<a name="ln1131">    case 'j':</a>
<a name="ln1132">    case Ctrl_J:</a>
<a name="ln1133">    case 'k':</a>
<a name="ln1134">    case Ctrl_K:</a>
<a name="ln1135">    case 'T':</a>
<a name="ln1136">    case Ctrl_R:</a>
<a name="ln1137">    case 'r':</a>
<a name="ln1138">    case 'R':</a>
<a name="ln1139">    case 'K':</a>
<a name="ln1140">    case 'J':</a>
<a name="ln1141">    case '+':</a>
<a name="ln1142">    case '-':</a>
<a name="ln1143">    case Ctrl__:</a>
<a name="ln1144">    case '_':</a>
<a name="ln1145">    case '|':</a>
<a name="ln1146">    case ']':</a>
<a name="ln1147">    case Ctrl_RSB:</a>
<a name="ln1148">    case 'g':</a>
<a name="ln1149">    case Ctrl_G:</a>
<a name="ln1150">    case Ctrl_V:</a>
<a name="ln1151">    case 'v':</a>
<a name="ln1152">    case 'h':</a>
<a name="ln1153">    case Ctrl_H:</a>
<a name="ln1154">    case 'l':</a>
<a name="ln1155">    case Ctrl_L:</a>
<a name="ln1156">    case 'H':</a>
<a name="ln1157">    case 'L':</a>
<a name="ln1158">    case '&gt;':</a>
<a name="ln1159">    case '&lt;':</a>
<a name="ln1160">    case '}':</a>
<a name="ln1161">    case 'f':</a>
<a name="ln1162">    case 'F':</a>
<a name="ln1163">    case Ctrl_F:</a>
<a name="ln1164">    case 'i':</a>
<a name="ln1165">    case Ctrl_I:</a>
<a name="ln1166">    case 'd':</a>
<a name="ln1167">    case Ctrl_D:</a>
<a name="ln1168">      // window size or any count</a>
<a name="ln1169">      eap-&gt;addr_type = ADDR_OTHER;  // -V1037</a>
<a name="ln1170">      break;</a>
<a name="ln1171"> </a>
<a name="ln1172">    case Ctrl_HAT:</a>
<a name="ln1173">    case '^':</a>
<a name="ln1174">      // buffer number</a>
<a name="ln1175">      eap-&gt;addr_type = ADDR_BUFFERS;</a>
<a name="ln1176">      break;</a>
<a name="ln1177"> </a>
<a name="ln1178">    case Ctrl_Q:</a>
<a name="ln1179">    case 'q':</a>
<a name="ln1180">    case Ctrl_C:</a>
<a name="ln1181">    case 'c':</a>
<a name="ln1182">    case Ctrl_O:</a>
<a name="ln1183">    case 'o':</a>
<a name="ln1184">    case Ctrl_W:</a>
<a name="ln1185">    case 'w':</a>
<a name="ln1186">    case 'W':</a>
<a name="ln1187">    case 'x':</a>
<a name="ln1188">    case Ctrl_X:</a>
<a name="ln1189">      // window number</a>
<a name="ln1190">      eap-&gt;addr_type = ADDR_WINDOWS;</a>
<a name="ln1191">      break;</a>
<a name="ln1192"> </a>
<a name="ln1193">    case Ctrl_Z:</a>
<a name="ln1194">    case 'z':</a>
<a name="ln1195">    case 'P':</a>
<a name="ln1196">    case 't':</a>
<a name="ln1197">    case Ctrl_T:</a>
<a name="ln1198">    case 'b':</a>
<a name="ln1199">    case Ctrl_B:</a>
<a name="ln1200">    case 'p':</a>
<a name="ln1201">    case Ctrl_P:</a>
<a name="ln1202">    case '=':</a>
<a name="ln1203">    case CAR:</a>
<a name="ln1204">      // no count</a>
<a name="ln1205">      eap-&gt;addr_type = ADDR_NONE;</a>
<a name="ln1206">      break;</a>
<a name="ln1207">  }</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">/// Skip colons and trailing whitespace, returning a pointer to the first</a>
<a name="ln1211">/// non-colon, non-whitespace character.</a>
<a name="ln1212">//</a>
<a name="ln1213">/// @param skipleadingwhite Skip leading whitespace too</a>
<a name="ln1214">static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)</a>
<a name="ln1215">{</a>
<a name="ln1216">  if (skipleadingwhite) {</a>
<a name="ln1217">    p = skipwhite(p);</a>
<a name="ln1218">  }</a>
<a name="ln1219"> </a>
<a name="ln1220">  while (*p == ':') {</a>
<a name="ln1221">    p = skipwhite(p + 1);</a>
<a name="ln1222">  }</a>
<a name="ln1223"> </a>
<a name="ln1224">  return (char_u *)p;</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">/*</a>
<a name="ln1228"> * Execute one Ex command.</a>
<a name="ln1229"> *</a>
<a name="ln1230"> * If 'sourcing' is TRUE, the command will be included in the error message.</a>
<a name="ln1231"> *</a>
<a name="ln1232"> * 1. skip comment lines and leading space</a>
<a name="ln1233"> * 2. handle command modifiers</a>
<a name="ln1234"> * 3. skip over the range to find the command</a>
<a name="ln1235"> * 4. parse the range</a>
<a name="ln1236"> * 5. parse the command</a>
<a name="ln1237"> * 6. parse arguments</a>
<a name="ln1238"> * 7. switch on command name</a>
<a name="ln1239"> *</a>
<a name="ln1240"> * Note: &quot;fgetline&quot; can be NULL.</a>
<a name="ln1241"> *</a>
<a name="ln1242"> * This function may be called recursively!</a>
<a name="ln1243"> */</a>
<a name="ln1244">static char_u * do_one_cmd(char_u **cmdlinep,</a>
<a name="ln1245">                           int flags,</a>
<a name="ln1246">                           cstack_T *cstack,</a>
<a name="ln1247">                           LineGetter fgetline,</a>
<a name="ln1248">                           void *cookie /* argument for fgetline() */</a>
<a name="ln1249">                           )</a>
<a name="ln1250">{</a>
<a name="ln1251">  char_u              *p;</a>
<a name="ln1252">  linenr_T lnum;</a>
<a name="ln1253">  long n;</a>
<a name="ln1254">  char_u              *errormsg = NULL;  // error message</a>
<a name="ln1255">  char_u              *after_modifier = NULL;</a>
<a name="ln1256">  exarg_T ea;</a>
<a name="ln1257">  const int save_msg_scroll = msg_scroll;</a>
<a name="ln1258">  cmdmod_T save_cmdmod;</a>
<a name="ln1259">  const int save_reg_executing = reg_executing;</a>
<a name="ln1260">  char_u              *cmd;</a>
<a name="ln1261"> </a>
<a name="ln1262">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln1263">  ea.line1 = 1;</a>
<a name="ln1264">  ea.line2 = 1;</a>
<a name="ln1265">  ex_nesting_level++;</a>
<a name="ln1266"> </a>
<a name="ln1267">  /* When the last file has not been edited :q has to be typed twice. */</a>
<a name="ln1268">  if (quitmore</a>
<a name="ln1269">      /* avoid that a function call in 'statusline' does this */</a>
<a name="ln1270">      &amp;&amp; !getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1271">      /* avoid that an autocommand, e.g. QuitPre, does this */</a>
<a name="ln1272">      &amp;&amp; !getline_equal(fgetline, cookie, getnextac)</a>
<a name="ln1273">      )</a>
<a name="ln1274">    --quitmore;</a>
<a name="ln1275"> </a>
<a name="ln1276">  /*</a>
<a name="ln1277">   * Reset browse, confirm, etc..  They are restored when returning, for</a>
<a name="ln1278">   * recursive calls.</a>
<a name="ln1279">   */</a>
<a name="ln1280">  save_cmdmod = cmdmod;</a>
<a name="ln1281"> </a>
<a name="ln1282">  // &quot;#!anything&quot; is handled like a comment.</a>
<a name="ln1283">  if ((*cmdlinep)[0] == '#' &amp;&amp; (*cmdlinep)[1] == '!') {</a>
<a name="ln1284">    goto doend;</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  // 1. Skip comment lines and leading white space and colons.</a>
<a name="ln1288">  // 2. Handle command modifiers.</a>
<a name="ln1289"> </a>
<a name="ln1290">  // The &quot;ea&quot; structure holds the arguments that can be used.</a>
<a name="ln1291">  ea.cmd = *cmdlinep;</a>
<a name="ln1292">  ea.cmdlinep = cmdlinep;</a>
<a name="ln1293">  ea.getline = fgetline;</a>
<a name="ln1294">  ea.cookie = cookie;</a>
<a name="ln1295">  ea.cstack = cstack;</a>
<a name="ln1296"> </a>
<a name="ln1297">  if (parse_command_modifiers(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1298">    goto doend;</a>
<a name="ln1299">  }</a>
<a name="ln1300"> </a>
<a name="ln1301">  after_modifier = ea.cmd;</a>
<a name="ln1302"> </a>
<a name="ln1303">  ea.skip = (did_emsg</a>
<a name="ln1304">             || got_int</a>
<a name="ln1305">             || current_exception</a>
<a name="ln1306">             || (cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1307">                 &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_ACTIVE)));</a>
<a name="ln1308"> </a>
<a name="ln1309">  // 3. Skip over the range to find the command. Let &quot;p&quot; point to after it.</a>
<a name="ln1310">  //</a>
<a name="ln1311">  // We need the command to know what kind of range it uses.</a>
<a name="ln1312">  cmd = ea.cmd;</a>
<a name="ln1313">  ea.cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln1314">  if (*ea.cmd == '*') {</a>
<a name="ln1315">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln1316">  }</a>
<a name="ln1317">  p = find_command(&amp;ea, NULL);</a>
<a name="ln1318"> </a>
<a name="ln1319">  // Count this line for profiling if skip is TRUE.</a>
<a name="ln1320">  if (do_profiling == PROF_YES</a>
<a name="ln1321">      &amp;&amp; (!ea.skip || cstack-&gt;cs_idx == 0</a>
<a name="ln1322">          || (cstack-&gt;cs_idx &gt; 0</a>
<a name="ln1323">              &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx - 1] &amp; CSF_ACTIVE)))) {</a>
<a name="ln1324">    int skip = did_emsg || got_int || current_exception;</a>
<a name="ln1325"> </a>
<a name="ln1326">    if (ea.cmdidx == CMD_catch) {</a>
<a name="ln1327">      skip = !skip &amp;&amp; !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1328">                        &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_THROWN)</a>
<a name="ln1329">                        &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_CAUGHT));</a>
<a name="ln1330">    } else if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif) {</a>
<a name="ln1331">      skip = skip || !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1332">                       &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx]</a>
<a name="ln1333">                            &amp; (CSF_ACTIVE | CSF_TRUE)));</a>
<a name="ln1334">    } else if (ea.cmdidx == CMD_finally) {</a>
<a name="ln1335">      skip = false;</a>
<a name="ln1336">    } else if (ea.cmdidx != CMD_endif</a>
<a name="ln1337">               &amp;&amp; ea.cmdidx != CMD_endfor</a>
<a name="ln1338">               &amp;&amp; ea.cmdidx != CMD_endtry</a>
<a name="ln1339">               &amp;&amp; ea.cmdidx != CMD_endwhile) {</a>
<a name="ln1340">      skip = ea.skip;</a>
<a name="ln1341">    }</a>
<a name="ln1342"> </a>
<a name="ln1343">    if (!skip) {</a>
<a name="ln1344">      if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln1345">        func_line_exec(getline_cookie(fgetline, cookie));</a>
<a name="ln1346">      } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln1347">        script_line_exec();</a>
<a name="ln1348">      }</a>
<a name="ln1349">    }</a>
<a name="ln1350">  }</a>
<a name="ln1351"> </a>
<a name="ln1352">  // May go to debug mode.  If this happens and the &quot;&gt;quit&quot; debug command is</a>
<a name="ln1353">  // used, throw an interrupt exception and skip the next command.</a>
<a name="ln1354">  dbg_check_breakpoint(&amp;ea);</a>
<a name="ln1355">  if (!ea.skip &amp;&amp; got_int) {</a>
<a name="ln1356">    ea.skip = TRUE;</a>
<a name="ln1357">    (void)do_intthrow(cstack);</a>
<a name="ln1358">  }</a>
<a name="ln1359"> </a>
<a name="ln1360">  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln1361">  //</a>
<a name="ln1362">  // where 'addr' is:</a>
<a name="ln1363">  //</a>
<a name="ln1364">  // %          (entire file)</a>
<a name="ln1365">  // $  [+-NUM]</a>
<a name="ln1366">  // 'x [+-NUM] (where x denotes a currently defined mark)</a>
<a name="ln1367">  // .  [+-NUM]</a>
<a name="ln1368">  // [+-NUM]..</a>
<a name="ln1369">  // NUM</a>
<a name="ln1370">  //</a>
<a name="ln1371">  // The ea.cmd pointer is updated to point to the first character following the</a>
<a name="ln1372">  // range spec. If an initial address is found, but no second, the upper bound</a>
<a name="ln1373">  // is equal to the lower.</a>
<a name="ln1374"> </a>
<a name="ln1375">  // ea.addr_type for user commands is set by find_ucmd</a>
<a name="ln1376">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1377">    if (ea.cmdidx != CMD_SIZE) {</a>
<a name="ln1378">      ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;</a>
<a name="ln1379">    } else {</a>
<a name="ln1380">      ea.addr_type = ADDR_LINES;</a>
<a name="ln1381">    }</a>
<a name="ln1382">    // :wincmd range depends on the argument</a>
<a name="ln1383">    if (ea.cmdidx == CMD_wincmd &amp;&amp; p != NULL) {</a>
<a name="ln1384">      get_wincmd_addr_type(skipwhite(p), &amp;ea);</a>
<a name="ln1385">    }</a>
<a name="ln1386">    // :.cc in quickfix window uses line number</a>
<a name="ln1387">    if ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln1388">      ea.addr_type = ADDR_OTHER;</a>
<a name="ln1389">    }</a>
<a name="ln1390">  }</a>
<a name="ln1391"> </a>
<a name="ln1392">  ea.cmd = cmd;</a>
<a name="ln1393">  if (parse_cmd_address(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1394">    goto doend;</a>
<a name="ln1395">  }</a>
<a name="ln1396"> </a>
<a name="ln1397">  /*</a>
<a name="ln1398">   * 5. Parse the command.</a>
<a name="ln1399">   */</a>
<a name="ln1400"> </a>
<a name="ln1401">  /*</a>
<a name="ln1402">   * Skip ':' and any white space</a>
<a name="ln1403">   */</a>
<a name="ln1404">  ea.cmd = skip_colon_white(ea.cmd, true);</a>
<a name="ln1405"> </a>
<a name="ln1406">  /*</a>
<a name="ln1407">   * If we got a line, but no command, then go to the line.</a>
<a name="ln1408">   * If we find a '|' or '\n' we set ea.nextcmd.</a>
<a name="ln1409">   */</a>
<a name="ln1410">  if (*ea.cmd == NUL || *ea.cmd == '&quot;'</a>
<a name="ln1411">      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {</a>
<a name="ln1412">    // strange vi behaviour:</a>
<a name="ln1413">    // &quot;:3&quot;     jumps to line 3</a>
<a name="ln1414">    // &quot;:3|...&quot; prints line 3</a>
<a name="ln1415">    // &quot;:|&quot;     prints current line</a>
<a name="ln1416">    if (ea.skip) {  // skip this if inside :if</a>
<a name="ln1417">      goto doend;</a>
<a name="ln1418">    }</a>
<a name="ln1419">    if (*ea.cmd == '|' || (exmode_active &amp;&amp; ea.line1 != ea.line2)) {</a>
<a name="ln1420">      ea.cmdidx = CMD_print;</a>
<a name="ln1421">      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;</a>
<a name="ln1422">      if ((errormsg = invalid_range(&amp;ea)) == NULL) {</a>
<a name="ln1423">        correct_range(&amp;ea);</a>
<a name="ln1424">        ex_print(&amp;ea);</a>
<a name="ln1425">      }</a>
<a name="ln1426">    } else if (ea.addr_count != 0) {</a>
<a name="ln1427">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1428">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1429">      }</a>
<a name="ln1430"> </a>
<a name="ln1431">      if (ea.line2 &lt; 0)</a>
<a name="ln1432">        errormsg = (char_u *)_(e_invrange);</a>
<a name="ln1433">      else {</a>
<a name="ln1434">        if (ea.line2 == 0)</a>
<a name="ln1435">          curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln1436">        else</a>
<a name="ln1437">          curwin-&gt;w_cursor.lnum = ea.line2;</a>
<a name="ln1438">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln1439">      }</a>
<a name="ln1440">    }</a>
<a name="ln1441">    goto doend;</a>
<a name="ln1442">  }</a>
<a name="ln1443"> </a>
<a name="ln1444">  // If this looks like an undefined user command and there are CmdUndefined</a>
<a name="ln1445">  // autocommands defined, trigger the matching autocommands.</a>
<a name="ln1446">  if (p != NULL &amp;&amp; ea.cmdidx == CMD_SIZE &amp;&amp; !ea.skip</a>
<a name="ln1447">      &amp;&amp; ASCII_ISUPPER(*ea.cmd)</a>
<a name="ln1448">      &amp;&amp; has_event(EVENT_CMDUNDEFINED)) {</a>
<a name="ln1449">    p = ea.cmd;</a>
<a name="ln1450">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln1451">      ++p;</a>
<a name="ln1452">    }</a>
<a name="ln1453">    p = vim_strnsave(ea.cmd, p - ea.cmd);</a>
<a name="ln1454">    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);</a>
<a name="ln1455">    xfree(p);</a>
<a name="ln1456">    // If the autocommands did something and didn't cause an error, try</a>
<a name="ln1457">    // finding the command again.</a>
<a name="ln1458">    p = (ret &amp;&amp; !aborting()) ? find_command(&amp;ea, NULL) : ea.cmd;</a>
<a name="ln1459">  }</a>
<a name="ln1460"> </a>
<a name="ln1461">  if (p == NULL) {</a>
<a name="ln1462">    if (!ea.skip)</a>
<a name="ln1463">      errormsg = (char_u *)_(&quot;E464: Ambiguous use of user-defined command&quot;);</a>
<a name="ln1464">    goto doend;</a>
<a name="ln1465">  }</a>
<a name="ln1466">  // Check for wrong commands.</a>
<a name="ln1467">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln1468">    if (!ea.skip) {</a>
<a name="ln1469">      STRCPY(IObuff, _(&quot;E492: Not an editor command&quot;));</a>
<a name="ln1470">      if (!(flags &amp; DOCMD_VERBOSE)) {</a>
<a name="ln1471">        // If the modifier was parsed OK the error must be in the following</a>
<a name="ln1472">        // command</a>
<a name="ln1473">        if (after_modifier != NULL) {</a>
<a name="ln1474">          append_command(after_modifier);</a>
<a name="ln1475">        } else {</a>
<a name="ln1476">          append_command(*cmdlinep);</a>
<a name="ln1477">        }</a>
<a name="ln1478">      }</a>
<a name="ln1479">      errormsg = IObuff;</a>
<a name="ln1480">      did_emsg_syntax = TRUE;</a>
<a name="ln1481">    }</a>
<a name="ln1482">    goto doend;</a>
<a name="ln1483">  }</a>
<a name="ln1484"> </a>
<a name="ln1485">  // set when Not Implemented</a>
<a name="ln1486">  const int ni = !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1487">    &amp;&amp; (cmdnames[ea.cmdidx].cmd_func == ex_ni</a>
<a name="ln1488">        || cmdnames[ea.cmdidx].cmd_func == ex_script_ni);</a>
<a name="ln1489"> </a>
<a name="ln1490"> </a>
<a name="ln1491">  // Forced commands.</a>
<a name="ln1492">  if (*p == '!' &amp;&amp; ea.cmdidx != CMD_substitute</a>
<a name="ln1493">      &amp;&amp; ea.cmdidx != CMD_smagic &amp;&amp; ea.cmdidx != CMD_snomagic) {</a>
<a name="ln1494">    p++;</a>
<a name="ln1495">    ea.forceit = true;</a>
<a name="ln1496">  } else {</a>
<a name="ln1497">    ea.forceit = false;</a>
<a name="ln1498">  }</a>
<a name="ln1499"> </a>
<a name="ln1500">  // 6. Parse arguments.  Then check for errors.</a>
<a name="ln1501">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1502">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln1503">  }</a>
<a name="ln1504"> </a>
<a name="ln1505">  if (!ea.skip) {</a>
<a name="ln1506">    if (sandbox != 0 &amp;&amp; !(ea.argt &amp; EX_SBOXOK)) {</a>
<a name="ln1507">      // Command not allowed in sandbox.</a>
<a name="ln1508">      errormsg = (char_u *)_(e_sandbox);</a>
<a name="ln1509">      goto doend;</a>
<a name="ln1510">    }</a>
<a name="ln1511">    if (!MODIFIABLE(curbuf) &amp;&amp; (ea.argt &amp; EX_MODIFY)</a>
<a name="ln1512">        // allow :put in terminals</a>
<a name="ln1513">        &amp;&amp; (!curbuf-&gt;terminal || ea.cmdidx != CMD_put)) {</a>
<a name="ln1514">      /* Command not allowed in non-'modifiable' buffer */</a>
<a name="ln1515">      errormsg = (char_u *)_(e_modifiable);</a>
<a name="ln1516">      goto doend;</a>
<a name="ln1517">    }</a>
<a name="ln1518"> </a>
<a name="ln1519">    if (text_locked() &amp;&amp; !(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln1520">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1521">      // Command not allowed when editing the command line.</a>
<a name="ln1522">      errormsg = (char_u *)_(get_text_locked_msg());</a>
<a name="ln1523">      goto doend;</a>
<a name="ln1524">    }</a>
<a name="ln1525"> </a>
<a name="ln1526">    // Disallow editing another buffer when &quot;curbuf_lock&quot; is set.</a>
<a name="ln1527">    // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln1528">    // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln1529">    // Do allow &quot;:file&quot; with no arguments (check for an argument later).</a>
<a name="ln1530">    if (!(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln1531">        &amp;&amp; ea.cmdidx != CMD_checktime</a>
<a name="ln1532">        &amp;&amp; ea.cmdidx != CMD_edit</a>
<a name="ln1533">        &amp;&amp; ea.cmdidx != CMD_file</a>
<a name="ln1534">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1535">        &amp;&amp; curbuf_locked()) {</a>
<a name="ln1536">      goto doend;</a>
<a name="ln1537">    }</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (!ni &amp;&amp; !(ea.argt &amp; EX_RANGE) &amp;&amp; ea.addr_count &gt; 0) {</a>
<a name="ln1540">      // no range allowed</a>
<a name="ln1541">      errormsg = (char_u *)_(e_norange);</a>
<a name="ln1542">      goto doend;</a>
<a name="ln1543">    }</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  if (!ni &amp;&amp; !(ea.argt &amp; EX_BANG) &amp;&amp; ea.forceit) {  // no &lt;!&gt; allowed</a>
<a name="ln1547">    errormsg = (char_u *)_(e_nobang);</a>
<a name="ln1548">    goto doend;</a>
<a name="ln1549">  }</a>
<a name="ln1550"> </a>
<a name="ln1551">  /*</a>
<a name="ln1552">   * Don't complain about the range if it is not used</a>
<a name="ln1553">   * (could happen if line_count is accidentally set to 0).</a>
<a name="ln1554">   */</a>
<a name="ln1555">  if (!ea.skip &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_RANGE)) {</a>
<a name="ln1556">    // If the range is backwards, ask for confirmation and, if given, swap</a>
<a name="ln1557">    // ea.line1 &amp; ea.line2 so it's forwards again.</a>
<a name="ln1558">    // When global command is busy, don't ask, will fail below.</a>
<a name="ln1559">    if (!global_busy &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln1560">      if (msg_silent == 0) {</a>
<a name="ln1561">        if ((flags &amp; DOCMD_VERBOSE) || exmode_active) {</a>
<a name="ln1562">          errormsg = (char_u *)_(&quot;E493: Backwards range given&quot;);</a>
<a name="ln1563">          goto doend;</a>
<a name="ln1564">        }</a>
<a name="ln1565">        if (ask_yesno(_(&quot;Backwards range given, OK to swap&quot;), false) != 'y') {</a>
<a name="ln1566">          goto doend;</a>
<a name="ln1567">        }</a>
<a name="ln1568">      }</a>
<a name="ln1569">      lnum = ea.line1;</a>
<a name="ln1570">      ea.line1 = ea.line2;</a>
<a name="ln1571">      ea.line2 = lnum;</a>
<a name="ln1572">    }</a>
<a name="ln1573">    if ((errormsg = invalid_range(&amp;ea)) != NULL)</a>
<a name="ln1574">      goto doend;</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  if ((ea.addr_type == ADDR_OTHER) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln1578">    // default is 1, not cursor</a>
<a name="ln1579">    ea.line2 = 1;</a>
<a name="ln1580">  }</a>
<a name="ln1581"> </a>
<a name="ln1582">  correct_range(&amp;ea);</a>
<a name="ln1583"> </a>
<a name="ln1584">  if (((ea.argt &amp; EX_WHOLEFOLD) || ea.addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln1585">      &amp;&amp; ea.addr_type == ADDR_LINES) {</a>
<a name="ln1586">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln1587">    // at the end of a closed fold.</a>
<a name="ln1588">    (void)hasFolding(ea.line1, &amp;ea.line1, NULL);</a>
<a name="ln1589">    (void)hasFolding(ea.line2, NULL, &amp;ea.line2);</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  /*</a>
<a name="ln1593">   * For the &quot;:make&quot; and &quot;:grep&quot; commands we insert the 'makeprg'/'grepprg'</a>
<a name="ln1594">   * option here, so things like % get expanded.</a>
<a name="ln1595">   */</a>
<a name="ln1596">  p = replace_makeprg(&amp;ea, p, cmdlinep);</a>
<a name="ln1597">  if (p == NULL)</a>
<a name="ln1598">    goto doend;</a>
<a name="ln1599"> </a>
<a name="ln1600">  /*</a>
<a name="ln1601">   * Skip to start of argument.</a>
<a name="ln1602">   * Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln1603">   */</a>
<a name="ln1604">  if (ea.cmdidx == CMD_bang)</a>
<a name="ln1605">    ea.arg = p;</a>
<a name="ln1606">  else</a>
<a name="ln1607">    ea.arg = skipwhite(p);</a>
<a name="ln1608"> </a>
<a name="ln1609">  // &quot;:file&quot; cannot be run with an argument when &quot;curbuf_lock&quot; is set</a>
<a name="ln1610">  if (ea.cmdidx == CMD_file &amp;&amp; *ea.arg != NUL &amp;&amp; curbuf_locked()) {</a>
<a name="ln1611">    goto doend;</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  /*</a>
<a name="ln1615">   * Check for &quot;++opt=val&quot; argument.</a>
<a name="ln1616">   * Must be first, allow &quot;:w ++enc=utf8 !cmd&quot;</a>
<a name="ln1617">   */</a>
<a name="ln1618">  if (ea.argt &amp; EX_ARGOPT) {</a>
<a name="ln1619">    while (ea.arg[0] == '+' &amp;&amp; ea.arg[1] == '+') {</a>
<a name="ln1620">      if (getargopt(&amp;ea) == FAIL &amp;&amp; !ni) {</a>
<a name="ln1621">        errormsg = (char_u *)_(e_invarg);</a>
<a name="ln1622">        goto doend;</a>
<a name="ln1623">      }</a>
<a name="ln1624">    }</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln1628">    if (*ea.arg == '&gt;') {                       /* append */</a>
<a name="ln1629">      if (*++ea.arg != '&gt;') {                   /* typed wrong */</a>
<a name="ln1630">        errormsg = (char_u *)_(&quot;E494: Use w or w&gt;&gt;&quot;);</a>
<a name="ln1631">        goto doend;</a>
<a name="ln1632">      }</a>
<a name="ln1633">      ea.arg = skipwhite(ea.arg + 1);</a>
<a name="ln1634">      ea.append = TRUE;</a>
<a name="ln1635">    } else if (*ea.arg == '!' &amp;&amp; ea.cmdidx == CMD_write) { /* :w !filter */</a>
<a name="ln1636">      ++ea.arg;</a>
<a name="ln1637">      ea.usefilter = TRUE;</a>
<a name="ln1638">    }</a>
<a name="ln1639">  }</a>
<a name="ln1640"> </a>
<a name="ln1641">  if (ea.cmdidx == CMD_read) {</a>
<a name="ln1642">    if (ea.forceit) {</a>
<a name="ln1643">      ea.usefilter = TRUE;                      /* :r! filter if ea.forceit */</a>
<a name="ln1644">      ea.forceit = FALSE;</a>
<a name="ln1645">    } else if (*ea.arg == '!') {              /* :r !filter */</a>
<a name="ln1646">      ++ea.arg;</a>
<a name="ln1647">      ea.usefilter = TRUE;</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650"> </a>
<a name="ln1651">  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln1652">    ea.amount = 1;</a>
<a name="ln1653">    while (*ea.arg == *ea.cmd) {                /* count number of '&gt;' or '&lt;' */</a>
<a name="ln1654">      ++ea.arg;</a>
<a name="ln1655">      ++ea.amount;</a>
<a name="ln1656">    }</a>
<a name="ln1657">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln1658">  }</a>
<a name="ln1659"> </a>
<a name="ln1660">  /*</a>
<a name="ln1661">   * Check for &quot;+command&quot; argument, before checking for next command.</a>
<a name="ln1662">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1663">   */</a>
<a name="ln1664">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !ea.usefilter) {</a>
<a name="ln1665">    ea.do_ecmd_cmd = getargcmd(&amp;ea.arg);</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  /*</a>
<a name="ln1669">   * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln1670">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1671">   */</a>
<a name="ln1672">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !ea.usefilter) {</a>
<a name="ln1673">    separate_nextcmd(&amp;ea);</a>
<a name="ln1674">  } else if (ea.cmdidx == CMD_bang</a>
<a name="ln1675">             || ea.cmdidx == CMD_terminal</a>
<a name="ln1676">             || ea.cmdidx == CMD_global</a>
<a name="ln1677">             || ea.cmdidx == CMD_vglobal</a>
<a name="ln1678">             || ea.usefilter) {</a>
<a name="ln1679">    // Check for &lt;newline&gt; to end a shell command.</a>
<a name="ln1680">    // Also do this for &quot;:read !cmd&quot;, &quot;:write !cmd&quot; and &quot;:global&quot;.</a>
<a name="ln1681">    // Any others?</a>
<a name="ln1682">    for (p = ea.arg; *p; p++) {</a>
<a name="ln1683">      // Remove one backslash before a newline, so that it's possible to</a>
<a name="ln1684">      // pass a newline to the shell and also a newline that is preceded</a>
<a name="ln1685">      // with a backslash.  This makes it impossible to end a shell</a>
<a name="ln1686">      // command in a backslash, but that doesn't appear useful.</a>
<a name="ln1687">      // Halving the number of backslashes is incompatible with previous</a>
<a name="ln1688">      // versions.</a>
<a name="ln1689">      if (*p == '\\' &amp;&amp; p[1] == '\n') {</a>
<a name="ln1690">        STRMOVE(p, p + 1);</a>
<a name="ln1691">      } else if (*p == '\n') {</a>
<a name="ln1692">        ea.nextcmd = p + 1;</a>
<a name="ln1693">        *p = NUL;</a>
<a name="ln1694">        break;</a>
<a name="ln1695">      }</a>
<a name="ln1696">    }</a>
<a name="ln1697">  }</a>
<a name="ln1698"> </a>
<a name="ln1699">  if ((ea.argt &amp; EX_DFLALL) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln1700">    buf_T *buf;</a>
<a name="ln1701"> </a>
<a name="ln1702">    ea.line1 = 1;</a>
<a name="ln1703">    switch (ea.addr_type) {</a>
<a name="ln1704">      case ADDR_LINES:</a>
<a name="ln1705">      case ADDR_OTHER:</a>
<a name="ln1706">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1707">        break;</a>
<a name="ln1708">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln1709">        buf = firstbuf;</a>
<a name="ln1710">        while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1711">          buf = buf-&gt;b_next;</a>
<a name="ln1712">        }</a>
<a name="ln1713">        ea.line1 = buf-&gt;b_fnum;</a>
<a name="ln1714">        buf = lastbuf;</a>
<a name="ln1715">        while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1716">          buf = buf-&gt;b_prev;</a>
<a name="ln1717">        }</a>
<a name="ln1718">        ea.line2 = buf-&gt;b_fnum;</a>
<a name="ln1719">        break;</a>
<a name="ln1720">      case ADDR_BUFFERS:</a>
<a name="ln1721">        ea.line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln1722">        ea.line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln1723">        break;</a>
<a name="ln1724">      case ADDR_WINDOWS:</a>
<a name="ln1725">        ea.line2 = LAST_WIN_NR;</a>
<a name="ln1726">        break;</a>
<a name="ln1727">      case ADDR_TABS:</a>
<a name="ln1728">        ea.line2 = LAST_TAB_NR;</a>
<a name="ln1729">        break;</a>
<a name="ln1730">      case ADDR_TABS_RELATIVE:</a>
<a name="ln1731">        ea.line2 = 1;</a>
<a name="ln1732">        break;</a>
<a name="ln1733">      case ADDR_ARGUMENTS:</a>
<a name="ln1734">        if (ARGCOUNT == 0) {</a>
<a name="ln1735">          ea.line1 = ea.line2 = 0;</a>
<a name="ln1736">        } else {</a>
<a name="ln1737">          ea.line2 = ARGCOUNT;</a>
<a name="ln1738">        }</a>
<a name="ln1739">        break;</a>
<a name="ln1740">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln1741">        ea.line2 = qf_get_valid_size(&amp;ea);</a>
<a name="ln1742">        if (ea.line2 == 0) {</a>
<a name="ln1743">          ea.line2 = 1;</a>
<a name="ln1744">        }</a>
<a name="ln1745">        break;</a>
<a name="ln1746">      case ADDR_NONE:</a>
<a name="ln1747">      case ADDR_UNSIGNED:</a>
<a name="ln1748">      case ADDR_QUICKFIX:</a>
<a name="ln1749">        IEMSG(_(&quot;INTERNAL: Cannot use EX_DFLALL &quot;</a>
<a name="ln1750">                &quot;with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX&quot;));</a>
<a name="ln1751">        break;</a>
<a name="ln1752">    }</a>
<a name="ln1753">  }</a>
<a name="ln1754"> </a>
<a name="ln1755">  // accept numbered register only when no count allowed (:put)</a>
<a name="ln1756">  if ((ea.argt &amp; EX_REGSTR)</a>
<a name="ln1757">      &amp;&amp; *ea.arg != NUL</a>
<a name="ln1758">      /* Do not allow register = for user commands */</a>
<a name="ln1759">      &amp;&amp; (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')</a>
<a name="ln1760">      &amp;&amp; !((ea.argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*ea.arg))) {</a>
<a name="ln1761">    if (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put</a>
<a name="ln1762">                                 &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)))) {</a>
<a name="ln1763">      ea.regname = *ea.arg++;</a>
<a name="ln1764">      /* for '=' register: accept the rest of the line as an expression */</a>
<a name="ln1765">      if (ea.arg[-1] == '=' &amp;&amp; ea.arg[0] != NUL) {</a>
<a name="ln1766">        set_expr_line(vim_strsave(ea.arg));</a>
<a name="ln1767">        ea.arg += STRLEN(ea.arg);</a>
<a name="ln1768">      }</a>
<a name="ln1769">      ea.arg = skipwhite(ea.arg);</a>
<a name="ln1770">    }</a>
<a name="ln1771">  }</a>
<a name="ln1772"> </a>
<a name="ln1773">  //</a>
<a name="ln1774">  // Check for a count.  When accepting a EX_BUFNAME, don't use &quot;123foo&quot; as a</a>
<a name="ln1775">  // count, it's a buffer name.</a>
<a name="ln1776">  ///</a>
<a name="ln1777">  if ((ea.argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*ea.arg)</a>
<a name="ln1778">      &amp;&amp; (!(ea.argt &amp; EX_BUFNAME) || *(p = skipdigits(ea.arg)) == NUL</a>
<a name="ln1779">          || ascii_iswhite(*p))) {</a>
<a name="ln1780">    n = getdigits_long(&amp;ea.arg, false, -1);</a>
<a name="ln1781">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln1782">    if (n &lt;= 0 &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_ZEROR) == 0) {</a>
<a name="ln1783">      errormsg = (char_u *)_(e_zerocount);</a>
<a name="ln1784">      goto doend;</a>
<a name="ln1785">    }</a>
<a name="ln1786">    if (ea.addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3</a>
<a name="ln1787">      ea.line2 = n;</a>
<a name="ln1788">      if (ea.addr_count == 0)</a>
<a name="ln1789">        ea.addr_count = 1;</a>
<a name="ln1790">    } else {</a>
<a name="ln1791">      ea.line1 = ea.line2;</a>
<a name="ln1792">      ea.line2 += n - 1;</a>
<a name="ln1793">      ++ea.addr_count;</a>
<a name="ln1794">      // Be vi compatible: no error message for out of range.</a>
<a name="ln1795">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1796">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1797">      }</a>
<a name="ln1798">    }</a>
<a name="ln1799">  }</a>
<a name="ln1800"> </a>
<a name="ln1801">  /*</a>
<a name="ln1802">   * Check for flags: 'l', 'p' and '#'.</a>
<a name="ln1803">   */</a>
<a name="ln1804">  if (ea.argt &amp; EX_FLAGS) {</a>
<a name="ln1805">    get_flags(&amp;ea);</a>
<a name="ln1806">  }</a>
<a name="ln1807">  if (!ni &amp;&amp; !(ea.argt &amp; EX_EXTRA) &amp;&amp; *ea.arg != NUL</a>
<a name="ln1808">      &amp;&amp; *ea.arg != '&quot;' &amp;&amp; (*ea.arg != '|' || (ea.argt &amp; EX_TRLBAR) == 0)) {</a>
<a name="ln1809">    // no arguments allowed but there is something</a>
<a name="ln1810">    errormsg = (char_u *)_(e_trailing);</a>
<a name="ln1811">    goto doend;</a>
<a name="ln1812">  }</a>
<a name="ln1813"> </a>
<a name="ln1814">  if (!ni &amp;&amp; (ea.argt &amp; EX_NEEDARG) &amp;&amp; *ea.arg == NUL) {</a>
<a name="ln1815">    errormsg = (char_u *)_(e_argreq);</a>
<a name="ln1816">    goto doend;</a>
<a name="ln1817">  }</a>
<a name="ln1818"> </a>
<a name="ln1819">  /*</a>
<a name="ln1820">   * Skip the command when it's not going to be executed.</a>
<a name="ln1821">   * The commands like :if, :endif, etc. always need to be executed.</a>
<a name="ln1822">   * Also make an exception for commands that handle a trailing command</a>
<a name="ln1823">   * themselves.</a>
<a name="ln1824">   */</a>
<a name="ln1825">  if (ea.skip) {</a>
<a name="ln1826">    switch (ea.cmdidx) {</a>
<a name="ln1827">    /* commands that need evaluation */</a>
<a name="ln1828">    case CMD_while:</a>
<a name="ln1829">    case CMD_endwhile:</a>
<a name="ln1830">    case CMD_for:</a>
<a name="ln1831">    case CMD_endfor:</a>
<a name="ln1832">    case CMD_if:</a>
<a name="ln1833">    case CMD_elseif:</a>
<a name="ln1834">    case CMD_else:</a>
<a name="ln1835">    case CMD_endif:</a>
<a name="ln1836">    case CMD_try:</a>
<a name="ln1837">    case CMD_catch:</a>
<a name="ln1838">    case CMD_finally:</a>
<a name="ln1839">    case CMD_endtry:</a>
<a name="ln1840">    case CMD_function:</a>
<a name="ln1841">      break;</a>
<a name="ln1842"> </a>
<a name="ln1843">    // Commands that handle '|' themselves.  Check: A command should</a>
<a name="ln1844">    // either have the EX_TRLBAR flag, appear in this list or appear in</a>
<a name="ln1845">    // the list at &quot;:help :bar&quot;.</a>
<a name="ln1846">    case CMD_aboveleft:</a>
<a name="ln1847">    case CMD_and:</a>
<a name="ln1848">    case CMD_belowright:</a>
<a name="ln1849">    case CMD_botright:</a>
<a name="ln1850">    case CMD_browse:</a>
<a name="ln1851">    case CMD_call:</a>
<a name="ln1852">    case CMD_confirm:</a>
<a name="ln1853">    case CMD_const:</a>
<a name="ln1854">    case CMD_delfunction:</a>
<a name="ln1855">    case CMD_djump:</a>
<a name="ln1856">    case CMD_dlist:</a>
<a name="ln1857">    case CMD_dsearch:</a>
<a name="ln1858">    case CMD_dsplit:</a>
<a name="ln1859">    case CMD_echo:</a>
<a name="ln1860">    case CMD_echoerr:</a>
<a name="ln1861">    case CMD_echomsg:</a>
<a name="ln1862">    case CMD_echon:</a>
<a name="ln1863">    case CMD_execute:</a>
<a name="ln1864">    case CMD_filter:</a>
<a name="ln1865">    case CMD_help:</a>
<a name="ln1866">    case CMD_hide:</a>
<a name="ln1867">    case CMD_ijump:</a>
<a name="ln1868">    case CMD_ilist:</a>
<a name="ln1869">    case CMD_isearch:</a>
<a name="ln1870">    case CMD_isplit:</a>
<a name="ln1871">    case CMD_keepalt:</a>
<a name="ln1872">    case CMD_keepjumps:</a>
<a name="ln1873">    case CMD_keepmarks:</a>
<a name="ln1874">    case CMD_keeppatterns:</a>
<a name="ln1875">    case CMD_leftabove:</a>
<a name="ln1876">    case CMD_let:</a>
<a name="ln1877">    case CMD_lockmarks:</a>
<a name="ln1878">    case CMD_lockvar:</a>
<a name="ln1879">    case CMD_lua:</a>
<a name="ln1880">    case CMD_match:</a>
<a name="ln1881">    case CMD_mzscheme:</a>
<a name="ln1882">    case CMD_noautocmd:</a>
<a name="ln1883">    case CMD_noswapfile:</a>
<a name="ln1884">    case CMD_perl:</a>
<a name="ln1885">    case CMD_psearch:</a>
<a name="ln1886">    case CMD_python:</a>
<a name="ln1887">    case CMD_py3:</a>
<a name="ln1888">    case CMD_python3:</a>
<a name="ln1889">    case CMD_pythonx:</a>
<a name="ln1890">    case CMD_pyx:</a>
<a name="ln1891">    case CMD_return:</a>
<a name="ln1892">    case CMD_rightbelow:</a>
<a name="ln1893">    case CMD_ruby:</a>
<a name="ln1894">    case CMD_silent:</a>
<a name="ln1895">    case CMD_smagic:</a>
<a name="ln1896">    case CMD_snomagic:</a>
<a name="ln1897">    case CMD_substitute:</a>
<a name="ln1898">    case CMD_syntax:</a>
<a name="ln1899">    case CMD_tab:</a>
<a name="ln1900">    case CMD_tcl:</a>
<a name="ln1901">    case CMD_throw:</a>
<a name="ln1902">    case CMD_tilde:</a>
<a name="ln1903">    case CMD_topleft:</a>
<a name="ln1904">    case CMD_unlet:</a>
<a name="ln1905">    case CMD_unlockvar:</a>
<a name="ln1906">    case CMD_verbose:</a>
<a name="ln1907">    case CMD_vertical:</a>
<a name="ln1908">    case CMD_wincmd:</a>
<a name="ln1909">      break;</a>
<a name="ln1910"> </a>
<a name="ln1911">    default:</a>
<a name="ln1912">      goto doend;</a>
<a name="ln1913">    }</a>
<a name="ln1914">  }</a>
<a name="ln1915"> </a>
<a name="ln1916">  if (ea.argt &amp; EX_XFILE) {</a>
<a name="ln1917">    if (expand_filename(&amp;ea, cmdlinep, &amp;errormsg) == FAIL) {</a>
<a name="ln1918">      goto doend;</a>
<a name="ln1919">    }</a>
<a name="ln1920">  }</a>
<a name="ln1921"> </a>
<a name="ln1922">  /*</a>
<a name="ln1923">   * Accept buffer name.  Cannot be used at the same time with a buffer</a>
<a name="ln1924">   * number.  Don't do this for a user command.</a>
<a name="ln1925">   */</a>
<a name="ln1926">  if ((ea.argt &amp; EX_BUFNAME) &amp;&amp; *ea.arg != NUL &amp;&amp; ea.addr_count == 0</a>
<a name="ln1927">      &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln1928">      ) {</a>
<a name="ln1929">    /*</a>
<a name="ln1930">     * :bdelete, :bwipeout and :bunload take several arguments, separated</a>
<a name="ln1931">     * by spaces: find next space (skipping over escaped characters).</a>
<a name="ln1932">     * The others take one argument: ignore trailing spaces.</a>
<a name="ln1933">     */</a>
<a name="ln1934">    if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout</a>
<a name="ln1935">        || ea.cmdidx == CMD_bunload)</a>
<a name="ln1936">      p = skiptowhite_esc(ea.arg);</a>
<a name="ln1937">    else {</a>
<a name="ln1938">      p = ea.arg + STRLEN(ea.arg);</a>
<a name="ln1939">      while (p &gt; ea.arg &amp;&amp; ascii_iswhite(p[-1]))</a>
<a name="ln1940">        --p;</a>
<a name="ln1941">    }</a>
<a name="ln1942">    ea.line2 = buflist_findpat(ea.arg, p, (ea.argt &amp; EX_BUFUNL) != 0,</a>
<a name="ln1943">                               false, false);</a>
<a name="ln1944">    if (ea.line2 &lt; 0) {  // failed</a>
<a name="ln1945">      goto doend;</a>
<a name="ln1946">    }</a>
<a name="ln1947">    ea.addr_count = 1;</a>
<a name="ln1948">    ea.arg = skipwhite(p);</a>
<a name="ln1949">  }</a>
<a name="ln1950"> </a>
<a name="ln1951">  // The :try command saves the emsg_silent flag, reset it here when</a>
<a name="ln1952">  // &quot;:silent! try&quot; was used, it should only apply to :try itself.</a>
<a name="ln1953">  if (ea.cmdidx == CMD_try &amp;&amp; ea.did_esilent &gt; 0) {</a>
<a name="ln1954">    emsg_silent -= ea.did_esilent;</a>
<a name="ln1955">    if (emsg_silent &lt; 0) {</a>
<a name="ln1956">      emsg_silent = 0;</a>
<a name="ln1957">    }</a>
<a name="ln1958">    ea.did_esilent = 0;</a>
<a name="ln1959">  }</a>
<a name="ln1960"> </a>
<a name="ln1961">  // 7. Execute the command.</a>
<a name="ln1962">  if (IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln1963">    /*</a>
<a name="ln1964">     * Execute a user-defined command.</a>
<a name="ln1965">     */</a>
<a name="ln1966">    do_ucmd(&amp;ea);</a>
<a name="ln1967">  } else {</a>
<a name="ln1968">    /*</a>
<a name="ln1969">     * Call the function to execute the command.</a>
<a name="ln1970">     */</a>
<a name="ln1971">    ea.errmsg = NULL;</a>
<a name="ln1972">    (cmdnames[ea.cmdidx].cmd_func)(&amp;ea);</a>
<a name="ln1973">    if (ea.errmsg != NULL)</a>
<a name="ln1974">      errormsg = (char_u *)_(ea.errmsg);</a>
<a name="ln1975">  }</a>
<a name="ln1976"> </a>
<a name="ln1977">  /*</a>
<a name="ln1978">   * If the command just executed called do_cmdline(), any throw or &quot;:return&quot;</a>
<a name="ln1979">   * or &quot;:finish&quot; encountered there must also check the cstack of the still</a>
<a name="ln1980">   * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught</a>
<a name="ln1981">   * exception, or reanimate a returned function or finished script file and</a>
<a name="ln1982">   * return or finish it again.</a>
<a name="ln1983">   */</a>
<a name="ln1984">  if (need_rethrow)</a>
<a name="ln1985">    do_throw(cstack);</a>
<a name="ln1986">  else if (check_cstack) {</a>
<a name="ln1987">    if (source_finished(fgetline, cookie))</a>
<a name="ln1988">      do_finish(&amp;ea, TRUE);</a>
<a name="ln1989">    else if (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1990">             &amp;&amp; current_func_returned())</a>
<a name="ln1991">      do_return(&amp;ea, TRUE, FALSE, NULL);</a>
<a name="ln1992">  }</a>
<a name="ln1993">  need_rethrow = check_cstack = FALSE;</a>
<a name="ln1994"> </a>
<a name="ln1995">doend:</a>
<a name="ln1996">  // can happen with zero line number</a>
<a name="ln1997">  if (curwin-&gt;w_cursor.lnum == 0) {</a>
<a name="ln1998">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln1999">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2000">  }</a>
<a name="ln2001"> </a>
<a name="ln2002">  if (errormsg != NULL &amp;&amp; *errormsg != NUL &amp;&amp; !did_emsg) {</a>
<a name="ln2003">    if (flags &amp; DOCMD_VERBOSE) {</a>
<a name="ln2004">      if (errormsg != IObuff) {</a>
<a name="ln2005">        STRCPY(IObuff, errormsg);</a>
<a name="ln2006">        errormsg = IObuff;</a>
<a name="ln2007">      }</a>
<a name="ln2008">      append_command(*cmdlinep);</a>
<a name="ln2009">    }</a>
<a name="ln2010">    emsg(errormsg);</a>
<a name="ln2011">  }</a>
<a name="ln2012">  do_errthrow(cstack,</a>
<a name="ln2013">      (ea.cmdidx != CMD_SIZE &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx))</a>
<a name="ln2014">      ? cmdnames[(int)ea.cmdidx].cmd_name</a>
<a name="ln2015">      : (char_u *)NULL);</a>
<a name="ln2016"> </a>
<a name="ln2017">  undo_cmdmod(&amp;ea, save_msg_scroll);</a>
<a name="ln2018">  cmdmod = save_cmdmod;</a>
<a name="ln2019">  reg_executing = save_reg_executing;</a>
<a name="ln2020"> </a>
<a name="ln2021">  if (ea.did_sandbox) {</a>
<a name="ln2022">    sandbox--;</a>
<a name="ln2023">  }</a>
<a name="ln2024"> </a>
<a name="ln2025">  if (ea.nextcmd &amp;&amp; *ea.nextcmd == NUL)         /* not really a next command */</a>
<a name="ln2026">    ea.nextcmd = NULL;</a>
<a name="ln2027"> </a>
<a name="ln2028">  --ex_nesting_level;</a>
<a name="ln2029"> </a>
<a name="ln2030">  return ea.nextcmd;</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033">// Parse and skip over command modifiers:</a>
<a name="ln2034">// - update eap-&gt;cmd</a>
<a name="ln2035">// - store flags in &quot;cmdmod&quot;.</a>
<a name="ln2036">// - Set ex_pressedreturn for an empty command line.</a>
<a name="ln2037">// - set msg_silent for &quot;:silent&quot;</a>
<a name="ln2038">// - set 'eventignore' to &quot;all&quot; for &quot;:noautocmd&quot;</a>
<a name="ln2039">// - set p_verbose for &quot;:verbose&quot;</a>
<a name="ln2040">// - Increment &quot;sandbox&quot; for &quot;:sandbox&quot;</a>
<a name="ln2041">// When &quot;skip_only&quot; is true the global variables are not changed, except for</a>
<a name="ln2042">// &quot;cmdmod&quot;.</a>
<a name="ln2043">// Return FAIL when the command is not to be executed.</a>
<a name="ln2044">// May set &quot;errormsg&quot; to an error message.</a>
<a name="ln2045">int parse_command_modifiers(exarg_T *eap, char_u **errormsg, bool skip_only)</a>
<a name="ln2046">{</a>
<a name="ln2047">  char_u *p;</a>
<a name="ln2048"> </a>
<a name="ln2049">  memset(&amp;cmdmod, 0, sizeof(cmdmod));</a>
<a name="ln2050">  eap-&gt;verbose_save = -1;</a>
<a name="ln2051">  eap-&gt;save_msg_silent = -1;</a>
<a name="ln2052"> </a>
<a name="ln2053">  // Repeat until no more command modifiers are found.</a>
<a name="ln2054">  for (;; ) {</a>
<a name="ln2055">    while (*eap-&gt;cmd == ' '</a>
<a name="ln2056">           || *eap-&gt;cmd == '\t'</a>
<a name="ln2057">           || *eap-&gt;cmd == ':') {</a>
<a name="ln2058">      eap-&gt;cmd++;</a>
<a name="ln2059">    }</a>
<a name="ln2060"> </a>
<a name="ln2061">    // in ex mode, an empty line works like :+</a>
<a name="ln2062">    if (*eap-&gt;cmd == NUL &amp;&amp; exmode_active</a>
<a name="ln2063">        &amp;&amp; (getline_equal(eap-&gt;getline, eap-&gt;cookie, getexmodeline)</a>
<a name="ln2064">            || getline_equal(eap-&gt;getline, eap-&gt;cookie, getexline))</a>
<a name="ln2065">        &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2066">      eap-&gt;cmd = (char_u *)&quot;+&quot;;</a>
<a name="ln2067">      if (!skip_only) {</a>
<a name="ln2068">        ex_pressedreturn = true;</a>
<a name="ln2069">      }</a>
<a name="ln2070">    }</a>
<a name="ln2071"> </a>
<a name="ln2072">    // ignore comment and empty lines</a>
<a name="ln2073">    if (*eap-&gt;cmd == '&quot;') {</a>
<a name="ln2074">      return FAIL;</a>
<a name="ln2075">    }</a>
<a name="ln2076">    if (*eap-&gt;cmd == NUL) {</a>
<a name="ln2077">      if (!skip_only) {</a>
<a name="ln2078">        ex_pressedreturn = true;</a>
<a name="ln2079">      }</a>
<a name="ln2080">      return FAIL;</a>
<a name="ln2081">    }</a>
<a name="ln2082"> </a>
<a name="ln2083">    p = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln2084">    switch (*p) {</a>
<a name="ln2085">    // When adding an entry, also modify cmd_exists().</a>
<a name="ln2086">    case 'a':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;aboveleft&quot;, 3))</a>
<a name="ln2087">        break;</a>
<a name="ln2088">      cmdmod.split |= WSP_ABOVE;</a>
<a name="ln2089">      continue;</a>
<a name="ln2090"> </a>
<a name="ln2091">    case 'b':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;belowright&quot;, 3)) {</a>
<a name="ln2092">        cmdmod.split |= WSP_BELOW;</a>
<a name="ln2093">        continue;</a>
<a name="ln2094">      }</a>
<a name="ln2095">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;browse&quot;, 3)) {</a>
<a name="ln2096">        cmdmod.browse = true;</a>
<a name="ln2097">        continue;</a>
<a name="ln2098">      }</a>
<a name="ln2099">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;botright&quot;, 2)) {</a>
<a name="ln2100">        break;</a>
<a name="ln2101">      }</a>
<a name="ln2102">      cmdmod.split |= WSP_BOT;</a>
<a name="ln2103">      continue;</a>
<a name="ln2104"> </a>
<a name="ln2105">    case 'c':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;confirm&quot;, 4))</a>
<a name="ln2106">        break;</a>
<a name="ln2107">      cmdmod.confirm = true;</a>
<a name="ln2108">      continue;</a>
<a name="ln2109"> </a>
<a name="ln2110">    case 'k':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepmarks&quot;, 3)) {</a>
<a name="ln2111">        cmdmod.keepmarks = true;</a>
<a name="ln2112">        continue;</a>
<a name="ln2113">    }</a>
<a name="ln2114">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepalt&quot;, 5)) {</a>
<a name="ln2115">        cmdmod.keepalt = true;</a>
<a name="ln2116">        continue;</a>
<a name="ln2117">      }</a>
<a name="ln2118">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keeppatterns&quot;, 5)) {</a>
<a name="ln2119">        cmdmod.keeppatterns = true;</a>
<a name="ln2120">        continue;</a>
<a name="ln2121">      }</a>
<a name="ln2122">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;keepjumps&quot;, 5)) {</a>
<a name="ln2123">        break;</a>
<a name="ln2124">      }</a>
<a name="ln2125">      cmdmod.keepjumps = true;</a>
<a name="ln2126">      continue;</a>
<a name="ln2127"> </a>
<a name="ln2128">    case 'f': {  // only accept &quot;:filter {pat} cmd&quot;</a>
<a name="ln2129">      char_u *reg_pat;</a>
<a name="ln2130"> </a>
<a name="ln2131">      if (!checkforcmd(&amp;p, &quot;filter&quot;, 4) || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2132">        break;</a>
<a name="ln2133">      }</a>
<a name="ln2134">      if (*p == '!') {</a>
<a name="ln2135">        cmdmod.filter_force = true;</a>
<a name="ln2136">        p = skipwhite(p + 1);</a>
<a name="ln2137">        if (*p == NUL || ends_excmd(*p)) {</a>
<a name="ln2138">          break;</a>
<a name="ln2139">        }</a>
<a name="ln2140">      }</a>
<a name="ln2141">      if (skip_only) {</a>
<a name="ln2142">        p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln2143">      } else {</a>
<a name="ln2144">        // NOTE: This puts a NUL after the pattern.</a>
<a name="ln2145">        p = skip_vimgrep_pat(p, &amp;reg_pat, NULL);</a>
<a name="ln2146">      }</a>
<a name="ln2147">      if (p == NULL || *p == NUL) {</a>
<a name="ln2148">        break;</a>
<a name="ln2149">      }</a>
<a name="ln2150">      if (!skip_only) {</a>
<a name="ln2151">        cmdmod.filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln2152">        if (cmdmod.filter_regmatch.regprog == NULL) {</a>
<a name="ln2153">          break;</a>
<a name="ln2154">        }</a>
<a name="ln2155">      }</a>
<a name="ln2156">      eap-&gt;cmd = p;</a>
<a name="ln2157">      continue;</a>
<a name="ln2158">    }</a>
<a name="ln2159"> </a>
<a name="ln2160">    // &quot;:hide&quot; and &quot;:hide | cmd&quot; are not modifiers</a>
<a name="ln2161">    case 'h':   if (p != eap-&gt;cmd || !checkforcmd(&amp;p, &quot;hide&quot;, 3)</a>
<a name="ln2162">                    || *p == NUL || ends_excmd(*p))</a>
<a name="ln2163">        break;</a>
<a name="ln2164">      eap-&gt;cmd = p;</a>
<a name="ln2165">      cmdmod.hide = true;</a>
<a name="ln2166">      continue;</a>
<a name="ln2167"> </a>
<a name="ln2168">    case 'l':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;lockmarks&quot;, 3)) {</a>
<a name="ln2169">        cmdmod.lockmarks = true;</a>
<a name="ln2170">        continue;</a>
<a name="ln2171">    }</a>
<a name="ln2172"> </a>
<a name="ln2173">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;leftabove&quot;, 5)) {</a>
<a name="ln2174">        break;</a>
<a name="ln2175">      }</a>
<a name="ln2176">      cmdmod.split |= WSP_ABOVE;</a>
<a name="ln2177">      continue;</a>
<a name="ln2178"> </a>
<a name="ln2179">    case 'n':</a>
<a name="ln2180">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;noautocmd&quot;, 3)) {</a>
<a name="ln2181">        if (cmdmod.save_ei == NULL &amp;&amp; !skip_only) {</a>
<a name="ln2182">          // Set 'eventignore' to &quot;all&quot;. Restore the</a>
<a name="ln2183">          // existing option value later.</a>
<a name="ln2184">          cmdmod.save_ei = vim_strsave(p_ei);</a>
<a name="ln2185">          set_string_option_direct((char_u *)&quot;ei&quot;, -1,</a>
<a name="ln2186">                                   (char_u *)&quot;all&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln2187">        }</a>
<a name="ln2188">        continue;</a>
<a name="ln2189">      }</a>
<a name="ln2190">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;noswapfile&quot;, 3)) {</a>
<a name="ln2191">        break;</a>
<a name="ln2192">      }</a>
<a name="ln2193">      cmdmod.noswapfile = true;</a>
<a name="ln2194">      continue;</a>
<a name="ln2195"> </a>
<a name="ln2196">    case 'r':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;rightbelow&quot;, 6))</a>
<a name="ln2197">        break;</a>
<a name="ln2198">      cmdmod.split |= WSP_BELOW;</a>
<a name="ln2199">      continue;</a>
<a name="ln2200"> </a>
<a name="ln2201">    case 's':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;sandbox&quot;, 3)) {</a>
<a name="ln2202">        if (!skip_only) {</a>
<a name="ln2203">          if (!eap-&gt;did_sandbox) {</a>
<a name="ln2204">            sandbox++;</a>
<a name="ln2205">          }</a>
<a name="ln2206">          eap-&gt;did_sandbox = true;</a>
<a name="ln2207">        }</a>
<a name="ln2208">        continue;</a>
<a name="ln2209">    }</a>
<a name="ln2210">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;silent&quot;, 3)) {</a>
<a name="ln2211">        break;</a>
<a name="ln2212">      }</a>
<a name="ln2213">      if (!skip_only) {</a>
<a name="ln2214">        if (eap-&gt;save_msg_silent == -1) {</a>
<a name="ln2215">          eap-&gt;save_msg_silent = msg_silent;</a>
<a name="ln2216">        }</a>
<a name="ln2217">        msg_silent++;</a>
<a name="ln2218">      }</a>
<a name="ln2219">      if (*eap-&gt;cmd == '!' &amp;&amp; !ascii_iswhite(eap-&gt;cmd[-1])) {</a>
<a name="ln2220">        // &quot;:silent!&quot;, but not &quot;silent !cmd&quot;</a>
<a name="ln2221">        eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln2222">        if (!skip_only) {</a>
<a name="ln2223">          emsg_silent++;</a>
<a name="ln2224">          eap-&gt;did_esilent++;</a>
<a name="ln2225">        }</a>
<a name="ln2226">      }</a>
<a name="ln2227">      continue;</a>
<a name="ln2228"> </a>
<a name="ln2229">    case 't':   if (checkforcmd(&amp;p, &quot;tab&quot;, 3)) {</a>
<a name="ln2230">      if (!skip_only) {</a>
<a name="ln2231">        long tabnr = get_address(</a>
<a name="ln2232">            eap, &amp;eap-&gt;cmd, ADDR_TABS, eap-&gt;skip, skip_only, false, 1);</a>
<a name="ln2233"> </a>
<a name="ln2234">        if (tabnr == MAXLNUM) {</a>
<a name="ln2235">          cmdmod.tab = tabpage_index(curtab) + 1;</a>
<a name="ln2236">        } else {</a>
<a name="ln2237">          if (tabnr &lt; 0 || tabnr &gt; LAST_TAB_NR) {</a>
<a name="ln2238">            *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2239">            return false;</a>
<a name="ln2240">          }</a>
<a name="ln2241">          cmdmod.tab = tabnr + 1;</a>
<a name="ln2242">        }</a>
<a name="ln2243">      }</a>
<a name="ln2244">      eap-&gt;cmd = p;</a>
<a name="ln2245">      continue;</a>
<a name="ln2246">    }</a>
<a name="ln2247">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;topleft&quot;, 2)) {</a>
<a name="ln2248">        break;</a>
<a name="ln2249">      }</a>
<a name="ln2250">      cmdmod.split |= WSP_TOP;</a>
<a name="ln2251">      continue;</a>
<a name="ln2252"> </a>
<a name="ln2253">    case 'u':   if (!checkforcmd(&amp;eap-&gt;cmd, &quot;unsilent&quot;, 3))</a>
<a name="ln2254">        break;</a>
<a name="ln2255">      if (!skip_only) {</a>
<a name="ln2256">        if (eap-&gt;save_msg_silent == -1) {</a>
<a name="ln2257">          eap-&gt;save_msg_silent = msg_silent;</a>
<a name="ln2258">        }</a>
<a name="ln2259">        msg_silent = 0;</a>
<a name="ln2260">      }</a>
<a name="ln2261">      continue;</a>
<a name="ln2262"> </a>
<a name="ln2263">    case 'v':   if (checkforcmd(&amp;eap-&gt;cmd, &quot;vertical&quot;, 4)) {</a>
<a name="ln2264">        cmdmod.split |= WSP_VERT;</a>
<a name="ln2265">        continue;</a>
<a name="ln2266">    }</a>
<a name="ln2267">      if (!checkforcmd(&amp;p, &quot;verbose&quot;, 4))</a>
<a name="ln2268">        break;</a>
<a name="ln2269">      if (!skip_only) {</a>
<a name="ln2270">        if (eap-&gt;verbose_save &lt; 0) {</a>
<a name="ln2271">          eap-&gt;verbose_save = p_verbose;</a>
<a name="ln2272">        }</a>
<a name="ln2273">        if (ascii_isdigit(*eap-&gt;cmd)) {</a>
<a name="ln2274">          p_verbose = atoi((char *)eap-&gt;cmd);</a>
<a name="ln2275">        } else {</a>
<a name="ln2276">          p_verbose = 1;</a>
<a name="ln2277">        }</a>
<a name="ln2278">      }</a>
<a name="ln2279">      eap-&gt;cmd = p;</a>
<a name="ln2280">      continue;</a>
<a name="ln2281">    }</a>
<a name="ln2282">    break;</a>
<a name="ln2283">  }</a>
<a name="ln2284"> </a>
<a name="ln2285">  return OK;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">// Undo and free contents of &quot;cmdmod&quot;.</a>
<a name="ln2289">static void undo_cmdmod(const exarg_T *eap, int save_msg_scroll)</a>
<a name="ln2290">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2291">{</a>
<a name="ln2292">  if (eap-&gt;verbose_save &gt;= 0) {</a>
<a name="ln2293">    p_verbose = eap-&gt;verbose_save;</a>
<a name="ln2294">  }</a>
<a name="ln2295"> </a>
<a name="ln2296">  if (cmdmod.save_ei != NULL) {</a>
<a name="ln2297">    /* Restore 'eventignore' to the value before &quot;:noautocmd&quot;. */</a>
<a name="ln2298">    set_string_option_direct((char_u *)&quot;ei&quot;, -1, cmdmod.save_ei,</a>
<a name="ln2299">        OPT_FREE, SID_NONE);</a>
<a name="ln2300">    free_string_option(cmdmod.save_ei);</a>
<a name="ln2301">  }</a>
<a name="ln2302"> </a>
<a name="ln2303">  vim_regfree(cmdmod.filter_regmatch.regprog);</a>
<a name="ln2304"> </a>
<a name="ln2305">  if (eap-&gt;save_msg_silent != -1) {</a>
<a name="ln2306">    // messages could be enabled for a serious error, need to check if the</a>
<a name="ln2307">    // counters don't become negative</a>
<a name="ln2308">    if (!did_emsg || msg_silent &gt; eap-&gt;save_msg_silent) {</a>
<a name="ln2309">      msg_silent = eap-&gt;save_msg_silent;</a>
<a name="ln2310">    }</a>
<a name="ln2311">    emsg_silent -= eap-&gt;did_esilent;</a>
<a name="ln2312">    if (emsg_silent &lt; 0) {</a>
<a name="ln2313">      emsg_silent = 0;</a>
<a name="ln2314">    }</a>
<a name="ln2315">    // Restore msg_scroll, it's set by file I/O commands, even when no</a>
<a name="ln2316">    // message is actually displayed.</a>
<a name="ln2317">    msg_scroll = save_msg_scroll;</a>
<a name="ln2318"> </a>
<a name="ln2319">    // &quot;silent reg&quot; or &quot;silent echo x&quot; inside &quot;redir&quot; leaves msg_col</a>
<a name="ln2320">    // somewhere in the line.  Put it back in the first column.</a>
<a name="ln2321">    if (redirecting()) {</a>
<a name="ln2322">      msg_col = 0;</a>
<a name="ln2323">    }</a>
<a name="ln2324">  }</a>
<a name="ln2325">}</a>
<a name="ln2326"> </a>
<a name="ln2327"> </a>
<a name="ln2328">// Parse the address range, if any, in &quot;eap&quot;.</a>
<a name="ln2329">// May set the last search pattern, unless &quot;silent&quot; is true.</a>
<a name="ln2330">// Return FAIL and set &quot;errormsg&quot; or return OK.</a>
<a name="ln2331">int parse_cmd_address(exarg_T *eap, char_u **errormsg, bool silent)</a>
<a name="ln2332">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2333">{</a>
<a name="ln2334">  int address_count = 1;</a>
<a name="ln2335">  linenr_T lnum;</a>
<a name="ln2336"> </a>
<a name="ln2337">  // Repeat for all ',' or ';' separated addresses.</a>
<a name="ln2338">  for (;;) {</a>
<a name="ln2339">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2340">    switch (eap-&gt;addr_type) {</a>
<a name="ln2341">      case ADDR_LINES:</a>
<a name="ln2342">      case ADDR_OTHER:</a>
<a name="ln2343">        // default is current line number</a>
<a name="ln2344">        eap-&gt;line2 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2345">        break;</a>
<a name="ln2346">      case ADDR_WINDOWS:</a>
<a name="ln2347">        eap-&gt;line2 = CURRENT_WIN_NR;</a>
<a name="ln2348">        break;</a>
<a name="ln2349">      case ADDR_ARGUMENTS:</a>
<a name="ln2350">        eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2351">        if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2352">          eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2353">        }</a>
<a name="ln2354">        break;</a>
<a name="ln2355">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln2356">      case ADDR_BUFFERS:</a>
<a name="ln2357">        eap-&gt;line2 = curbuf-&gt;b_fnum;</a>
<a name="ln2358">        break;</a>
<a name="ln2359">      case ADDR_TABS:</a>
<a name="ln2360">        eap-&gt;line2 = CURRENT_TAB_NR;</a>
<a name="ln2361">        break;</a>
<a name="ln2362">      case ADDR_TABS_RELATIVE:</a>
<a name="ln2363">      case ADDR_UNSIGNED:</a>
<a name="ln2364">        eap-&gt;line2 = 1;</a>
<a name="ln2365">        break;</a>
<a name="ln2366">      case ADDR_QUICKFIX:</a>
<a name="ln2367">        eap-&gt;line2 = qf_get_cur_idx(eap);</a>
<a name="ln2368">        break;</a>
<a name="ln2369">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln2370">        eap-&gt;line2 = qf_get_cur_valid_idx(eap);</a>
<a name="ln2371">        break;</a>
<a name="ln2372">      case ADDR_NONE:</a>
<a name="ln2373">        // Will give an error later if a range is found.</a>
<a name="ln2374">        break;</a>
<a name="ln2375">    }</a>
<a name="ln2376">    eap-&gt;cmd = skipwhite(eap-&gt;cmd);</a>
<a name="ln2377">    lnum = get_address(eap, &amp;eap-&gt;cmd, eap-&gt;addr_type, eap-&gt;skip, silent,</a>
<a name="ln2378">                       eap-&gt;addr_count == 0, address_count++);</a>
<a name="ln2379">    if (eap-&gt;cmd == NULL) {  // error detected</a>
<a name="ln2380">      return FAIL;</a>
<a name="ln2381">    }</a>
<a name="ln2382">    if (lnum == MAXLNUM) {</a>
<a name="ln2383">      if (*eap-&gt;cmd == '%') {  // '%' - all lines</a>
<a name="ln2384">        eap-&gt;cmd++;</a>
<a name="ln2385">        switch (eap-&gt;addr_type) {</a>
<a name="ln2386">          case ADDR_LINES:</a>
<a name="ln2387">          case ADDR_OTHER:</a>
<a name="ln2388">            eap-&gt;line1 = 1;</a>
<a name="ln2389">            eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2390">            break;</a>
<a name="ln2391">          case ADDR_LOADED_BUFFERS: {</a>
<a name="ln2392">            buf_T *buf = firstbuf;</a>
<a name="ln2393"> </a>
<a name="ln2394">            while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2395">              buf = buf-&gt;b_next;</a>
<a name="ln2396">            }</a>
<a name="ln2397">            eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln2398">            buf = lastbuf;</a>
<a name="ln2399">            while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2400">              buf = buf-&gt;b_prev;</a>
<a name="ln2401">            }</a>
<a name="ln2402">            eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln2403">            break;</a>
<a name="ln2404">          }</a>
<a name="ln2405">          case ADDR_BUFFERS:</a>
<a name="ln2406">            eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln2407">            eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln2408">            break;</a>
<a name="ln2409">          case ADDR_WINDOWS:</a>
<a name="ln2410">          case ADDR_TABS:</a>
<a name="ln2411">            if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln2412">              eap-&gt;line1 = 1;</a>
<a name="ln2413">              eap-&gt;line2 = eap-&gt;addr_type == ADDR_WINDOWS</a>
<a name="ln2414">                ? LAST_WIN_NR : LAST_TAB_NR;</a>
<a name="ln2415">            } else {</a>
<a name="ln2416">              // there is no Vim command which uses '%' and</a>
<a name="ln2417">              // ADDR_WINDOWS or ADDR_TABS</a>
<a name="ln2418">              *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2419">              return FAIL;</a>
<a name="ln2420">            }</a>
<a name="ln2421">            break;</a>
<a name="ln2422">          case ADDR_TABS_RELATIVE:</a>
<a name="ln2423">          case ADDR_UNSIGNED:</a>
<a name="ln2424">          case ADDR_QUICKFIX:</a>
<a name="ln2425">            *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2426">            return FAIL;</a>
<a name="ln2427">          case ADDR_ARGUMENTS:</a>
<a name="ln2428">            if (ARGCOUNT == 0) {</a>
<a name="ln2429">              eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln2430">            } else {</a>
<a name="ln2431">              eap-&gt;line1 = 1;</a>
<a name="ln2432">              eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2433">            }</a>
<a name="ln2434">            break;</a>
<a name="ln2435">          case ADDR_QUICKFIX_VALID:</a>
<a name="ln2436">            eap-&gt;line1 = 1;</a>
<a name="ln2437">            eap-&gt;line2 = qf_get_valid_size(eap);</a>
<a name="ln2438">            if (eap-&gt;line2 == 0) {</a>
<a name="ln2439">              eap-&gt;line2 = 1;</a>
<a name="ln2440">            }</a>
<a name="ln2441">            break;</a>
<a name="ln2442">          case ADDR_NONE:</a>
<a name="ln2443">            // Will give an error later if a range is found.</a>
<a name="ln2444">            break;</a>
<a name="ln2445">        }</a>
<a name="ln2446">        eap-&gt;addr_count++;</a>
<a name="ln2447">      } else if (*eap-&gt;cmd == '*') {</a>
<a name="ln2448">        // '*' - visual area</a>
<a name="ln2449">        if (eap-&gt;addr_type != ADDR_LINES) {</a>
<a name="ln2450">          *errormsg = (char_u *)_(e_invrange);</a>
<a name="ln2451">          return FAIL;</a>
<a name="ln2452">        }</a>
<a name="ln2453"> </a>
<a name="ln2454">        eap-&gt;cmd++;</a>
<a name="ln2455">        if (!eap-&gt;skip) {</a>
<a name="ln2456">          pos_T *fp = getmark('&lt;', false);</a>
<a name="ln2457">          if (check_mark(fp) == FAIL) {</a>
<a name="ln2458">            return FAIL;</a>
<a name="ln2459">          }</a>
<a name="ln2460">          eap-&gt;line1 = fp-&gt;lnum;</a>
<a name="ln2461">          fp = getmark('&gt;', false);</a>
<a name="ln2462">          if (check_mark(fp) == FAIL) {</a>
<a name="ln2463">            return FAIL;</a>
<a name="ln2464">          }</a>
<a name="ln2465">          eap-&gt;line2 = fp-&gt;lnum;</a>
<a name="ln2466">          eap-&gt;addr_count++;</a>
<a name="ln2467">        }</a>
<a name="ln2468">      }</a>
<a name="ln2469">    } else {</a>
<a name="ln2470">      eap-&gt;line2 = lnum;</a>
<a name="ln2471">    }</a>
<a name="ln2472">    eap-&gt;addr_count++;</a>
<a name="ln2473"> </a>
<a name="ln2474">    if (*eap-&gt;cmd == ';') {</a>
<a name="ln2475">      if (!eap-&gt;skip) {</a>
<a name="ln2476">        curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln2477">        // Don't leave the cursor on an illegal line or column, but do</a>
<a name="ln2478">        // accept zero as address, so 0;/PATTERN/ works correctly.</a>
<a name="ln2479">        if (eap-&gt;line2 &gt; 0) {</a>
<a name="ln2480">          check_cursor();</a>
<a name="ln2481">        }</a>
<a name="ln2482">      }</a>
<a name="ln2483">    } else if (*eap-&gt;cmd != ',') {</a>
<a name="ln2484">      break;</a>
<a name="ln2485">    }</a>
<a name="ln2486">    eap-&gt;cmd++;</a>
<a name="ln2487">  }</a>
<a name="ln2488"> </a>
<a name="ln2489">  // One address given: set start and end lines.</a>
<a name="ln2490">  if (eap-&gt;addr_count == 1) {</a>
<a name="ln2491">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2492">    // ... but only implicit: really no address given</a>
<a name="ln2493">    if (lnum == MAXLNUM) {</a>
<a name="ln2494">      eap-&gt;addr_count = 0;</a>
<a name="ln2495">    }</a>
<a name="ln2496">  }</a>
<a name="ln2497">  return OK;</a>
<a name="ln2498">}</a>
<a name="ln2499"> </a>
<a name="ln2500">/*</a>
<a name="ln2501"> * Check for an Ex command with optional tail.</a>
<a name="ln2502"> * If there is a match advance &quot;pp&quot; to the argument and return TRUE.</a>
<a name="ln2503"> */</a>
<a name="ln2504">int</a>
<a name="ln2505">checkforcmd(</a>
<a name="ln2506">    char_u **pp,              // start of command</a>
<a name="ln2507">    char *cmd,                // name of command</a>
<a name="ln2508">    int len                   // required length</a>
<a name="ln2509">)</a>
<a name="ln2510">{</a>
<a name="ln2511">  int i;</a>
<a name="ln2512"> </a>
<a name="ln2513">  for (i = 0; cmd[i] != NUL; ++i)</a>
<a name="ln2514">    if (((char_u *)cmd)[i] != (*pp)[i])</a>
<a name="ln2515">      break;</a>
<a name="ln2516">  if (i &gt;= len &amp;&amp; !isalpha((*pp)[i])) {</a>
<a name="ln2517">    *pp = skipwhite(*pp + i);</a>
<a name="ln2518">    return TRUE;</a>
<a name="ln2519">  }</a>
<a name="ln2520">  return FALSE;</a>
<a name="ln2521">}</a>
<a name="ln2522"> </a>
<a name="ln2523">/*</a>
<a name="ln2524"> * Append &quot;cmd&quot; to the error message in IObuff.</a>
<a name="ln2525"> * Takes care of limiting the length and handling 0xa0, which would be</a>
<a name="ln2526"> * invisible otherwise.</a>
<a name="ln2527"> */</a>
<a name="ln2528">static void append_command(char_u *cmd)</a>
<a name="ln2529">{</a>
<a name="ln2530">  char_u *s = cmd;</a>
<a name="ln2531">  char_u *d;</a>
<a name="ln2532"> </a>
<a name="ln2533">  STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln2534">  d = IObuff + STRLEN(IObuff);</a>
<a name="ln2535">  while (*s != NUL &amp;&amp; d - IObuff &lt; IOSIZE - 7) {</a>
<a name="ln2536">    if (s[0] == 0xc2 &amp;&amp; s[1] == 0xa0) {</a>
<a name="ln2537">      s += 2;</a>
<a name="ln2538">      STRCPY(d, &quot;&lt;a0&gt;&quot;);</a>
<a name="ln2539">      d += 4;</a>
<a name="ln2540">    } else</a>
<a name="ln2541">      MB_COPY_CHAR(s, d);</a>
<a name="ln2542">  }</a>
<a name="ln2543">  *d = NUL;</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546">// Find an Ex command by its name, either built-in or user.</a>
<a name="ln2547">// Start of the name can be found at eap-&gt;cmd.</a>
<a name="ln2548">// Sets eap-&gt;cmdidx and returns a pointer to char after the command name.</a>
<a name="ln2549">// &quot;full&quot; is set to TRUE if the whole command name matched.</a>
<a name="ln2550">// Returns NULL for an ambiguous user command.</a>
<a name="ln2551">static char_u *find_command(exarg_T *eap, int *full)</a>
<a name="ln2552">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2553">{</a>
<a name="ln2554">  int len;</a>
<a name="ln2555">  char_u      *p;</a>
<a name="ln2556">  int i;</a>
<a name="ln2557"> </a>
<a name="ln2558">  /*</a>
<a name="ln2559">   * Isolate the command and search for it in the command table.</a>
<a name="ln2560">   * Exceptions:</a>
<a name="ln2561">   * - the 'k' command can directly be followed by any character.</a>
<a name="ln2562">   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2563">   *	    but :sre[wind] is another command, as are :scr[iptnames],</a>
<a name="ln2564">   *	    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].</a>
<a name="ln2565">   * - the &quot;d&quot; command can directly be followed by 'l' or 'p' flag.</a>
<a name="ln2566">   */</a>
<a name="ln2567">  p = eap-&gt;cmd;</a>
<a name="ln2568">  if (*p == 'k') {</a>
<a name="ln2569">    eap-&gt;cmdidx = CMD_k;</a>
<a name="ln2570">    ++p;</a>
<a name="ln2571">  } else if (p[0] == 's'</a>
<a name="ln2572">             &amp;&amp; ((p[1] == 'c'</a>
<a name="ln2573">                  &amp;&amp; (p[2] == NUL</a>
<a name="ln2574">                      || (p[2] != 's' &amp;&amp; p[2] != 'r'</a>
<a name="ln2575">                          &amp;&amp; (p[3] == NUL</a>
<a name="ln2576">                              || (p[3] != 'i' &amp;&amp; p[4] != 'p')))))</a>
<a name="ln2577">                 || p[1] == 'g'</a>
<a name="ln2578">                 || (p[1] == 'i' &amp;&amp; p[2] != 'm' &amp;&amp; p[2] != 'l' &amp;&amp; p[2] != 'g')</a>
<a name="ln2579">                 || p[1] == 'I'</a>
<a name="ln2580">                 || (p[1] == 'r' &amp;&amp; p[2] != 'e'))) {</a>
<a name="ln2581">    eap-&gt;cmdidx = CMD_substitute;</a>
<a name="ln2582">    ++p;</a>
<a name="ln2583">  } else {</a>
<a name="ln2584">    while (ASCII_ISALPHA(*p))</a>
<a name="ln2585">      ++p;</a>
<a name="ln2586">    /* for python 3.x support &quot;:py3&quot;, &quot;:python3&quot;, &quot;:py3file&quot;, etc. */</a>
<a name="ln2587">    if (eap-&gt;cmd[0] == 'p' &amp;&amp; eap-&gt;cmd[1] == 'y')</a>
<a name="ln2588">      while (ASCII_ISALNUM(*p))</a>
<a name="ln2589">        ++p;</a>
<a name="ln2590"> </a>
<a name="ln2591">    /* check for non-alpha command */</a>
<a name="ln2592">    if (p == eap-&gt;cmd &amp;&amp; vim_strchr((char_u *)&quot;@!=&gt;&lt;&amp;~#&quot;, *p) != NULL)</a>
<a name="ln2593">      ++p;</a>
<a name="ln2594">    len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2595">    if (*eap-&gt;cmd == 'd' &amp;&amp; (p[-1] == 'l' || p[-1] == 'p')) {</a>
<a name="ln2596">      /* Check for &quot;:dl&quot;, &quot;:dell&quot;, etc. to &quot;:deletel&quot;: that's</a>
<a name="ln2597">       * :delete with the 'l' flag.  Same for 'p'. */</a>
<a name="ln2598">      for (i = 0; i &lt; len; ++i)</a>
<a name="ln2599">        if (eap-&gt;cmd[i] != ((char_u *)&quot;delete&quot;)[i])</a>
<a name="ln2600">          break;</a>
<a name="ln2601">      if (i == len - 1) {</a>
<a name="ln2602">        --len;</a>
<a name="ln2603">        if (p[-1] == 'l')</a>
<a name="ln2604">          eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln2605">        else</a>
<a name="ln2606">          eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln2607">      }</a>
<a name="ln2608">    }</a>
<a name="ln2609"> </a>
<a name="ln2610">    if (ASCII_ISLOWER(eap-&gt;cmd[0])) {</a>
<a name="ln2611">      const int c1 = eap-&gt;cmd[0];</a>
<a name="ln2612">      const int c2 = len == 1 ? NUL : eap-&gt;cmd[1];</a>
<a name="ln2613"> </a>
<a name="ln2614">      if (command_count != (int)CMD_SIZE) {</a>
<a name="ln2615">        iemsg((char *)_(&quot;E943: Command table needs to be updated, run 'make'&quot;));</a>
<a name="ln2616">        getout(1);</a>
<a name="ln2617">      }</a>
<a name="ln2618"> </a>
<a name="ln2619">      // Use a precomputed index for fast look-up in cmdnames[]</a>
<a name="ln2620">      // taking into account the first 2 letters of eap-&gt;cmd.</a>
<a name="ln2621">      eap-&gt;cmdidx = cmdidxs1[CharOrdLow(c1)];</a>
<a name="ln2622">      if (ASCII_ISLOWER(c2)) {</a>
<a name="ln2623">        eap-&gt;cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];</a>
<a name="ln2624">      }</a>
<a name="ln2625">    } else {</a>
<a name="ln2626">      eap-&gt;cmdidx = CMD_bang;</a>
<a name="ln2627">    }</a>
<a name="ln2628"> </a>
<a name="ln2629">    for (; (int)eap-&gt;cmdidx &lt; (int)CMD_SIZE;</a>
<a name="ln2630">         eap-&gt;cmdidx = (cmdidx_T)((int)eap-&gt;cmdidx + 1))</a>
<a name="ln2631">      if (STRNCMP(cmdnames[(int)eap-&gt;cmdidx].cmd_name, (char *)eap-&gt;cmd,</a>
<a name="ln2632">              (size_t)len) == 0) {</a>
<a name="ln2633">        if (full != NULL</a>
<a name="ln2634">            &amp;&amp; cmdnames[(int)eap-&gt;cmdidx].cmd_name[len] == NUL)</a>
<a name="ln2635">          *full = TRUE;</a>
<a name="ln2636">        break;</a>
<a name="ln2637">      }</a>
<a name="ln2638"> </a>
<a name="ln2639">    // Look for a user defined command as a last resort.</a>
<a name="ln2640">    if ((eap-&gt;cmdidx == CMD_SIZE)</a>
<a name="ln2641">        &amp;&amp; *eap-&gt;cmd &gt;= 'A' &amp;&amp; *eap-&gt;cmd &lt;= 'Z') {</a>
<a name="ln2642">      /* User defined commands may contain digits. */</a>
<a name="ln2643">      while (ASCII_ISALNUM(*p))</a>
<a name="ln2644">        ++p;</a>
<a name="ln2645">      p = find_ucmd(eap, p, full, NULL, NULL);</a>
<a name="ln2646">    }</a>
<a name="ln2647">    if (p == eap-&gt;cmd)</a>
<a name="ln2648">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  return p;</a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">/*</a>
<a name="ln2655"> * Search for a user command that matches &quot;eap-&gt;cmd&quot;.</a>
<a name="ln2656"> * Return cmdidx in &quot;eap-&gt;cmdidx&quot;, flags in &quot;eap-&gt;argt&quot;, idx in &quot;eap-&gt;useridx&quot;.</a>
<a name="ln2657"> * Return a pointer to just after the command.</a>
<a name="ln2658"> * Return NULL if there is no matching command.</a>
<a name="ln2659"> */</a>
<a name="ln2660">static char_u *</a>
<a name="ln2661">find_ucmd (</a>
<a name="ln2662">    exarg_T *eap,</a>
<a name="ln2663">    char_u *p,      // end of the command (possibly including count)</a>
<a name="ln2664">    int *full,      // set to TRUE for a full match</a>
<a name="ln2665">    expand_T *xp,   // used for completion, NULL otherwise</a>
<a name="ln2666">    int *complp     // completion flags or NULL</a>
<a name="ln2667">)</a>
<a name="ln2668">{</a>
<a name="ln2669">  int len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2670">  int j, k, matchlen = 0;</a>
<a name="ln2671">  ucmd_T      *uc;</a>
<a name="ln2672">  int found = FALSE;</a>
<a name="ln2673">  int possible = FALSE;</a>
<a name="ln2674">  char_u      *cp, *np;             /* Point into typed cmd and test name */</a>
<a name="ln2675">  garray_T    *gap;</a>
<a name="ln2676">  int amb_local = FALSE;            /* Found ambiguous buffer-local command,</a>
<a name="ln2677">                                       only full match global is accepted. */</a>
<a name="ln2678"> </a>
<a name="ln2679">  /*</a>
<a name="ln2680">   * Look for buffer-local user commands first, then global ones.</a>
<a name="ln2681">   */</a>
<a name="ln2682">  gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln2683">  for (;; ) {</a>
<a name="ln2684">    for (j = 0; j &lt; gap-&gt;ga_len; ++j) {</a>
<a name="ln2685">      uc = USER_CMD_GA(gap, j);</a>
<a name="ln2686">      cp = eap-&gt;cmd;</a>
<a name="ln2687">      np = uc-&gt;uc_name;</a>
<a name="ln2688">      k = 0;</a>
<a name="ln2689">      while (k &lt; len &amp;&amp; *np != NUL &amp;&amp; *cp++ == *np++)</a>
<a name="ln2690">        k++;</a>
<a name="ln2691">      if (k == len || (*np == NUL &amp;&amp; ascii_isdigit(eap-&gt;cmd[k]))) {</a>
<a name="ln2692">        /* If finding a second match, the command is ambiguous.  But</a>
<a name="ln2693">         * not if a buffer-local command wasn't a full match and a</a>
<a name="ln2694">         * global command is a full match. */</a>
<a name="ln2695">        if (k == len &amp;&amp; found &amp;&amp; *np != NUL) {</a>
<a name="ln2696">          if (gap == &amp;ucmds)</a>
<a name="ln2697">            return NULL;</a>
<a name="ln2698">          amb_local = TRUE;</a>
<a name="ln2699">        }</a>
<a name="ln2700"> </a>
<a name="ln2701">        if (!found || (k == len &amp;&amp; *np == NUL)) {</a>
<a name="ln2702">          /* If we matched up to a digit, then there could</a>
<a name="ln2703">           * be another command including the digit that we</a>
<a name="ln2704">           * should use instead.</a>
<a name="ln2705">           */</a>
<a name="ln2706">          if (k == len)</a>
<a name="ln2707">            found = TRUE;</a>
<a name="ln2708">          else</a>
<a name="ln2709">            possible = TRUE;</a>
<a name="ln2710"> </a>
<a name="ln2711">          if (gap == &amp;ucmds)</a>
<a name="ln2712">            eap-&gt;cmdidx = CMD_USER;</a>
<a name="ln2713">          else</a>
<a name="ln2714">            eap-&gt;cmdidx = CMD_USER_BUF;</a>
<a name="ln2715">          eap-&gt;argt = uc-&gt;uc_argt;</a>
<a name="ln2716">          eap-&gt;useridx = j;</a>
<a name="ln2717">          eap-&gt;addr_type = uc-&gt;uc_addr_type;</a>
<a name="ln2718"> </a>
<a name="ln2719">          if (complp != NULL) {</a>
<a name="ln2720">            *complp = uc-&gt;uc_compl;</a>
<a name="ln2721">          }</a>
<a name="ln2722">          if (xp != NULL) {</a>
<a name="ln2723">            xp-&gt;xp_arg = uc-&gt;uc_compl_arg;</a>
<a name="ln2724">            xp-&gt;xp_script_ctx = uc-&gt;uc_script_ctx;</a>
<a name="ln2725">            xp-&gt;xp_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln2726">          }</a>
<a name="ln2727">          /* Do not search for further abbreviations</a>
<a name="ln2728">           * if this is an exact match. */</a>
<a name="ln2729">          matchlen = k;</a>
<a name="ln2730">          if (k == len &amp;&amp; *np == NUL) {</a>
<a name="ln2731">            if (full != NULL)</a>
<a name="ln2732">              *full = TRUE;</a>
<a name="ln2733">            amb_local = FALSE;</a>
<a name="ln2734">            break;</a>
<a name="ln2735">          }</a>
<a name="ln2736">        }</a>
<a name="ln2737">      }</a>
<a name="ln2738">    }</a>
<a name="ln2739"> </a>
<a name="ln2740">    /* Stop if we found a full match or searched all. */</a>
<a name="ln2741">    if (j &lt; gap-&gt;ga_len || gap == &amp;ucmds)</a>
<a name="ln2742">      break;</a>
<a name="ln2743">    gap = &amp;ucmds;</a>
<a name="ln2744">  }</a>
<a name="ln2745"> </a>
<a name="ln2746">  /* Only found ambiguous matches. */</a>
<a name="ln2747">  if (amb_local) {</a>
<a name="ln2748">    if (xp != NULL)</a>
<a name="ln2749">      xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2750">    return NULL;</a>
<a name="ln2751">  }</a>
<a name="ln2752"> </a>
<a name="ln2753">  /* The match we found may be followed immediately by a number.  Move &quot;p&quot;</a>
<a name="ln2754">   * back to point to it. */</a>
<a name="ln2755">  if (found || possible)</a>
<a name="ln2756">    return p + (matchlen - len);</a>
<a name="ln2757">  return p;</a>
<a name="ln2758">}</a>
<a name="ln2759"> </a>
<a name="ln2760">static struct cmdmod {</a>
<a name="ln2761">  char        *name;</a>
<a name="ln2762">  int minlen;</a>
<a name="ln2763">  int has_count;            /* :123verbose  :3tab */</a>
<a name="ln2764">} cmdmods[] = {</a>
<a name="ln2765">  { &quot;aboveleft&quot;, 3, false },</a>
<a name="ln2766">  { &quot;belowright&quot;, 3, false },</a>
<a name="ln2767">  { &quot;botright&quot;, 2, false },</a>
<a name="ln2768">  { &quot;browse&quot;, 3, false },</a>
<a name="ln2769">  { &quot;confirm&quot;, 4, false },</a>
<a name="ln2770">  { &quot;filter&quot;, 4, false },</a>
<a name="ln2771">  { &quot;hide&quot;, 3, false },</a>
<a name="ln2772">  { &quot;keepalt&quot;, 5, false },</a>
<a name="ln2773">  { &quot;keepjumps&quot;, 5, false },</a>
<a name="ln2774">  { &quot;keepmarks&quot;, 3, false },</a>
<a name="ln2775">  { &quot;keeppatterns&quot;, 5, false },</a>
<a name="ln2776">  { &quot;leftabove&quot;, 5, false },</a>
<a name="ln2777">  { &quot;lockmarks&quot;, 3, false },</a>
<a name="ln2778">  { &quot;noautocmd&quot;, 3, false },</a>
<a name="ln2779">  { &quot;noswapfile&quot;, 3, false },</a>
<a name="ln2780">  { &quot;rightbelow&quot;, 6, false },</a>
<a name="ln2781">  { &quot;sandbox&quot;, 3, false },</a>
<a name="ln2782">  { &quot;silent&quot;, 3, false },</a>
<a name="ln2783">  { &quot;tab&quot;, 3, true },</a>
<a name="ln2784">  { &quot;topleft&quot;, 2, false },</a>
<a name="ln2785">  { &quot;unsilent&quot;, 3, false },</a>
<a name="ln2786">  { &quot;verbose&quot;, 4, true },</a>
<a name="ln2787">  { &quot;vertical&quot;, 4, false },</a>
<a name="ln2788">};</a>
<a name="ln2789"> </a>
<a name="ln2790">/*</a>
<a name="ln2791"> * Return length of a command modifier (including optional count).</a>
<a name="ln2792"> * Return zero when it's not a modifier.</a>
<a name="ln2793"> */</a>
<a name="ln2794">int modifier_len(char_u *cmd)</a>
<a name="ln2795">{</a>
<a name="ln2796">  int i, j;</a>
<a name="ln2797">  char_u      *p = cmd;</a>
<a name="ln2798"> </a>
<a name="ln2799">  if (ascii_isdigit(*cmd))</a>
<a name="ln2800">    p = skipwhite(skipdigits(cmd));</a>
<a name="ln2801">  for (i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); ++i) {</a>
<a name="ln2802">    for (j = 0; p[j] != NUL; ++j)</a>
<a name="ln2803">      if (p[j] != cmdmods[i].name[j])</a>
<a name="ln2804">        break;</a>
<a name="ln2805">    if (j &gt;= cmdmods[i].minlen</a>
<a name="ln2806">        &amp;&amp; !ASCII_ISALPHA(p[j])</a>
<a name="ln2807">        &amp;&amp; (p == cmd || cmdmods[i].has_count)) {</a>
<a name="ln2808">      return j + (int)(p - cmd);</a>
<a name="ln2809">    }</a>
<a name="ln2810">  }</a>
<a name="ln2811">  return 0;</a>
<a name="ln2812">}</a>
<a name="ln2813"> </a>
<a name="ln2814">/*</a>
<a name="ln2815"> * Return &gt; 0 if an Ex command &quot;name&quot; exists.</a>
<a name="ln2816"> * Return 2 if there is an exact match.</a>
<a name="ln2817"> * Return 3 if there is an ambiguous match.</a>
<a name="ln2818"> */</a>
<a name="ln2819">int cmd_exists(const char *const name)</a>
<a name="ln2820">{</a>
<a name="ln2821">  exarg_T ea;</a>
<a name="ln2822">  char_u      *p;</a>
<a name="ln2823"> </a>
<a name="ln2824">  // Check command modifiers.</a>
<a name="ln2825">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln2826">    int j;</a>
<a name="ln2827">    for (j = 0; name[j] != NUL; j++) {</a>
<a name="ln2828">      if (name[j] != (char)cmdmods[i].name[j]) {</a>
<a name="ln2829">        break;</a>
<a name="ln2830">      }</a>
<a name="ln2831">    }</a>
<a name="ln2832">    if (name[j] == NUL &amp;&amp; j &gt;= cmdmods[i].minlen) {</a>
<a name="ln2833">      return cmdmods[i].name[j] == NUL ? 2 : 1;</a>
<a name="ln2834">    }</a>
<a name="ln2835">  }</a>
<a name="ln2836"> </a>
<a name="ln2837">  /* Check built-in commands and user defined commands.</a>
<a name="ln2838">   * For &quot;:2match&quot; and &quot;:3match&quot; we need to skip the number. */</a>
<a name="ln2839">  ea.cmd = (char_u *)((*name == '2' || *name == '3') ? name + 1 : name);</a>
<a name="ln2840">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln2841">  int full = false;</a>
<a name="ln2842">  p = find_command(&amp;ea, &amp;full);</a>
<a name="ln2843">  if (p == NULL)</a>
<a name="ln2844">    return 3;</a>
<a name="ln2845">  if (ascii_isdigit(*name) &amp;&amp; ea.cmdidx != CMD_match)</a>
<a name="ln2846">    return 0;</a>
<a name="ln2847">  if (*skipwhite(p) != NUL)</a>
<a name="ln2848">    return 0;           /* trailing garbage */</a>
<a name="ln2849">  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);</a>
<a name="ln2850">}</a>
<a name="ln2851"> </a>
<a name="ln2852">/*</a>
<a name="ln2853"> * This is all pretty much copied from do_one_cmd(), with all the extra stuff</a>
<a name="ln2854"> * we don't need/want deleted.	Maybe this could be done better if we didn't</a>
<a name="ln2855"> * repeat all this stuff.  The only problem is that they may not stay</a>
<a name="ln2856"> * perfectly compatible with each other, but then the command line syntax</a>
<a name="ln2857"> * probably won't change that much -- webb.</a>
<a name="ln2858"> */</a>
<a name="ln2859">const char * set_one_cmd_context(</a>
<a name="ln2860">    expand_T *xp,</a>
<a name="ln2861">    const char *buff          // buffer for command string</a>
<a name="ln2862">)</a>
<a name="ln2863">{</a>
<a name="ln2864">  size_t len = 0;</a>
<a name="ln2865">  exarg_T ea;</a>
<a name="ln2866">  int context = EXPAND_NOTHING;</a>
<a name="ln2867">  bool forceit = false;</a>
<a name="ln2868">  bool usefilter = false;  // Filter instead of file name.</a>
<a name="ln2869"> </a>
<a name="ln2870">  ExpandInit(xp);</a>
<a name="ln2871">  xp-&gt;xp_pattern = (char_u *)buff;</a>
<a name="ln2872">  xp-&gt;xp_context = EXPAND_COMMANDS;  // Default until we get past command</a>
<a name="ln2873">  ea.argt = 0;</a>
<a name="ln2874"> </a>
<a name="ln2875">  // 2. skip comment lines and leading space, colons or bars</a>
<a name="ln2876">  const char *cmd;</a>
<a name="ln2877">  for (cmd = buff; vim_strchr((const char_u *)&quot; \t:|&quot;, *cmd) != NULL; cmd++) {</a>
<a name="ln2878">  }</a>
<a name="ln2879">  xp-&gt;xp_pattern = (char_u *)cmd;</a>
<a name="ln2880"> </a>
<a name="ln2881">  if (*cmd == NUL)</a>
<a name="ln2882">    return NULL;</a>
<a name="ln2883">  if (*cmd == '&quot;') {        /* ignore comment lines */</a>
<a name="ln2884">    xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2885">    return NULL;</a>
<a name="ln2886">  }</a>
<a name="ln2887"> </a>
<a name="ln2888">  /*</a>
<a name="ln2889">   * 3. parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln2890">   */</a>
<a name="ln2891">  cmd = (const char *)skip_range((const char_u *)cmd, &amp;xp-&gt;xp_context);</a>
<a name="ln2892"> </a>
<a name="ln2893">  /*</a>
<a name="ln2894">   * 4. parse command</a>
<a name="ln2895">   */</a>
<a name="ln2896">  xp-&gt;xp_pattern = (char_u *)cmd;</a>
<a name="ln2897">  if (*cmd == NUL) {</a>
<a name="ln2898">    return NULL;</a>
<a name="ln2899">  }</a>
<a name="ln2900">  if (*cmd == '&quot;') {</a>
<a name="ln2901">    xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2902">    return NULL;</a>
<a name="ln2903">  }</a>
<a name="ln2904"> </a>
<a name="ln2905">  if (*cmd == '|' || *cmd == '\n')</a>
<a name="ln2906">    return cmd + 1;                     /* There's another command */</a>
<a name="ln2907"> </a>
<a name="ln2908">  /*</a>
<a name="ln2909">   * Isolate the command and search for it in the command table.</a>
<a name="ln2910">   * Exceptions:</a>
<a name="ln2911">   * - the 'k' command can directly be followed by any character, but</a>
<a name="ln2912">   *   do accept &quot;keepmarks&quot;, &quot;keepalt&quot; and &quot;keepjumps&quot;.</a>
<a name="ln2913">   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2914">   */</a>
<a name="ln2915">  const char *p;</a>
<a name="ln2916">  if (*cmd == 'k' &amp;&amp; cmd[1] != 'e') {</a>
<a name="ln2917">    ea.cmdidx = CMD_k;</a>
<a name="ln2918">    p = cmd + 1;</a>
<a name="ln2919">  } else {</a>
<a name="ln2920">    p = cmd;</a>
<a name="ln2921">    while (ASCII_ISALPHA(*p) || *p == '*') {  // Allow * wild card</a>
<a name="ln2922">      p++;</a>
<a name="ln2923">    }</a>
<a name="ln2924">    // a user command may contain digits</a>
<a name="ln2925">    if (ASCII_ISUPPER(cmd[0])) {</a>
<a name="ln2926">      while (ASCII_ISALNUM(*p) || *p == '*') {</a>
<a name="ln2927">        p++;</a>
<a name="ln2928">      }</a>
<a name="ln2929">    }</a>
<a name="ln2930">    // for python 3.x: &quot;:py3*&quot; commands completion</a>
<a name="ln2931">    if (cmd[0] == 'p' &amp;&amp; cmd[1] == 'y' &amp;&amp; p == cmd + 2 &amp;&amp; *p == '3') {</a>
<a name="ln2932">      p++;</a>
<a name="ln2933">      while (ASCII_ISALPHA(*p) || *p == '*') {</a>
<a name="ln2934">        p++;</a>
<a name="ln2935">      }</a>
<a name="ln2936">    }</a>
<a name="ln2937">    // check for non-alpha command</a>
<a name="ln2938">    if (p == cmd &amp;&amp; vim_strchr((const char_u *)&quot;@*!=&gt;&lt;&amp;~#&quot;, *p) != NULL) {</a>
<a name="ln2939">      p++;</a>
<a name="ln2940">    }</a>
<a name="ln2941">    len = (size_t)(p - cmd);</a>
<a name="ln2942"> </a>
<a name="ln2943">    if (len == 0) {</a>
<a name="ln2944">      xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2945">      return NULL;</a>
<a name="ln2946">    }</a>
<a name="ln2947">    for (ea.cmdidx = (cmdidx_T)0; (int)ea.cmdidx &lt; (int)CMD_SIZE;</a>
<a name="ln2948">         ea.cmdidx = (cmdidx_T)((int)ea.cmdidx + 1)) {</a>
<a name="ln2949">      if (STRNCMP(cmdnames[(int)ea.cmdidx].cmd_name, cmd, len) == 0) {</a>
<a name="ln2950">        break;</a>
<a name="ln2951">      }</a>
<a name="ln2952">    }</a>
<a name="ln2953"> </a>
<a name="ln2954">    if (cmd[0] &gt;= 'A' &amp;&amp; cmd[0] &lt;= 'Z') {</a>
<a name="ln2955">      while (ASCII_ISALNUM(*p) || *p == '*') {  // Allow * wild card</a>
<a name="ln2956">        p++;</a>
<a name="ln2957">      }</a>
<a name="ln2958">    }</a>
<a name="ln2959">  }</a>
<a name="ln2960"> </a>
<a name="ln2961">  /*</a>
<a name="ln2962">   * If the cursor is touching the command, and it ends in an alpha-numeric</a>
<a name="ln2963">   * character, complete the command name.</a>
<a name="ln2964">   */</a>
<a name="ln2965">  if (*p == NUL &amp;&amp; ASCII_ISALNUM(p[-1]))</a>
<a name="ln2966">    return NULL;</a>
<a name="ln2967"> </a>
<a name="ln2968">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2969">    if (*cmd == 's' &amp;&amp; vim_strchr((const char_u *)&quot;cgriI&quot;, cmd[1]) != NULL) {</a>
<a name="ln2970">      ea.cmdidx = CMD_substitute;</a>
<a name="ln2971">      p = cmd + 1;</a>
<a name="ln2972">    } else if (cmd[0] &gt;= 'A' &amp;&amp; cmd[0] &lt;= 'Z') {</a>
<a name="ln2973">      ea.cmd = (char_u *)cmd;</a>
<a name="ln2974">      p = (const char *)find_ucmd(&amp;ea, (char_u *)p, NULL, xp, &amp;context);</a>
<a name="ln2975">      if (p == NULL) {</a>
<a name="ln2976">        ea.cmdidx = CMD_SIZE;  // Ambiguous user command.</a>
<a name="ln2977">      }</a>
<a name="ln2978">    }</a>
<a name="ln2979">  }</a>
<a name="ln2980">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2981">    /* Not still touching the command and it was an illegal one */</a>
<a name="ln2982">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln2983">    return NULL;</a>
<a name="ln2984">  }</a>
<a name="ln2985"> </a>
<a name="ln2986">  xp-&gt;xp_context = EXPAND_NOTHING;   /* Default now that we're past command */</a>
<a name="ln2987"> </a>
<a name="ln2988">  if (*p == '!') {                  // forced commands</a>
<a name="ln2989">    forceit = true;</a>
<a name="ln2990">    p++;</a>
<a name="ln2991">  }</a>
<a name="ln2992"> </a>
<a name="ln2993">  /*</a>
<a name="ln2994">   * 5. parse arguments</a>
<a name="ln2995">   */</a>
<a name="ln2996">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2997">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln2998">  }</a>
<a name="ln2999"> </a>
<a name="ln3000">  const char *arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln3001"> </a>
<a name="ln3002">  // Skip over ++argopt argument</a>
<a name="ln3003">  if ((ea.argt &amp; EX_ARGOPT) &amp;&amp; *arg != NUL &amp;&amp; strncmp(arg, &quot;++&quot;, 2) == 0) {</a>
<a name="ln3004">    p = arg;</a>
<a name="ln3005">    while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln3006">      MB_PTR_ADV(p);</a>
<a name="ln3007">    }</a>
<a name="ln3008">    arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln3012">    if (*arg == '&gt;') {  // Append.</a>
<a name="ln3013">      if (*++arg == '&gt;') {</a>
<a name="ln3014">        arg++;</a>
<a name="ln3015">      }</a>
<a name="ln3016">      arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3017">    } else if (*arg == '!' &amp;&amp; ea.cmdidx == CMD_write) {  // :w !filter</a>
<a name="ln3018">      arg++;</a>
<a name="ln3019">      usefilter = true;</a>
<a name="ln3020">    }</a>
<a name="ln3021">  }</a>
<a name="ln3022"> </a>
<a name="ln3023">  if (ea.cmdidx == CMD_read) {</a>
<a name="ln3024">    usefilter = forceit;                        // :r! filter if forced</a>
<a name="ln3025">    if (*arg == '!') {                          // :r !filter</a>
<a name="ln3026">      arg++;</a>
<a name="ln3027">      usefilter = true;</a>
<a name="ln3028">    }</a>
<a name="ln3029">  }</a>
<a name="ln3030"> </a>
<a name="ln3031">  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln3032">    while (*arg == *cmd) {  // allow any number of '&gt;' or '&lt;'</a>
<a name="ln3033">      arg++;</a>
<a name="ln3034">    }</a>
<a name="ln3035">    arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3036">  }</a>
<a name="ln3037"> </a>
<a name="ln3038">  // Does command allow &quot;+command&quot;?</a>
<a name="ln3039">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !usefilter &amp;&amp; *arg == '+') {</a>
<a name="ln3040">    // Check if we're in the +command</a>
<a name="ln3041">    p = arg + 1;</a>
<a name="ln3042">    arg = (const char *)skip_cmd_arg((char_u *)arg, false);</a>
<a name="ln3043"> </a>
<a name="ln3044">    /* Still touching the command after '+'? */</a>
<a name="ln3045">    if (*arg == NUL)</a>
<a name="ln3046">      return p;</a>
<a name="ln3047"> </a>
<a name="ln3048">    // Skip space(s) after +command to get to the real argument.</a>
<a name="ln3049">    arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3050">  }</a>
<a name="ln3051"> </a>
<a name="ln3052">  /*</a>
<a name="ln3053">   * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln3054">   * Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln3055">   */</a>
<a name="ln3056">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !usefilter) {</a>
<a name="ln3057">    p = arg;</a>
<a name="ln3058">    /* &quot;:redir @&quot; is not the start of a comment */</a>
<a name="ln3059">    if (ea.cmdidx == CMD_redir &amp;&amp; p[0] == '@' &amp;&amp; p[1] == '&quot;')</a>
<a name="ln3060">      p += 2;</a>
<a name="ln3061">    while (*p) {</a>
<a name="ln3062">      if (*p == Ctrl_V) {</a>
<a name="ln3063">        if (p[1] != NUL) {</a>
<a name="ln3064">          p++;</a>
<a name="ln3065">        }</a>
<a name="ln3066">      } else if ((*p == '&quot;' &amp;&amp; !(ea.argt &amp; EX_NOTRLCOM))</a>
<a name="ln3067">                 || *p == '|'</a>
<a name="ln3068">                 || *p == '\n') {</a>
<a name="ln3069">        if (*(p - 1) != '\\') {</a>
<a name="ln3070">          if (*p == '|' || *p == '\n')</a>
<a name="ln3071">            return p + 1;</a>
<a name="ln3072">          return NULL;              /* It's a comment */</a>
<a name="ln3073">        }</a>
<a name="ln3074">      }</a>
<a name="ln3075">      MB_PTR_ADV(p);</a>
<a name="ln3076">    }</a>
<a name="ln3077">  }</a>
<a name="ln3078"> </a>
<a name="ln3079">  if (!(ea.argt &amp; EX_EXTRA) &amp;&amp; *arg != NUL &amp;&amp; strchr(&quot;|\&quot;&quot;, *arg) == NULL) {</a>
<a name="ln3080">    // no arguments allowed but there is something</a>
<a name="ln3081">    return NULL;</a>
<a name="ln3082">  }</a>
<a name="ln3083"> </a>
<a name="ln3084">  /* Find start of last argument (argument just before cursor): */</a>
<a name="ln3085">  p = buff;</a>
<a name="ln3086">  xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3087">  len = strlen(buff);</a>
<a name="ln3088">  while (*p &amp;&amp; p &lt; buff + len) {</a>
<a name="ln3089">    if (*p == ' ' || *p == TAB) {</a>
<a name="ln3090">      // Argument starts after a space.</a>
<a name="ln3091">      xp-&gt;xp_pattern = (char_u *)++p;</a>
<a name="ln3092">    } else {</a>
<a name="ln3093">      if (*p == '\\' &amp;&amp; *(p + 1) != NUL) {</a>
<a name="ln3094">        p++;        // skip over escaped character</a>
<a name="ln3095">      }</a>
<a name="ln3096">      MB_PTR_ADV(p);</a>
<a name="ln3097">    }</a>
<a name="ln3098">  }</a>
<a name="ln3099"> </a>
<a name="ln3100">  if (ea.argt &amp; EX_XFILE) {</a>
<a name="ln3101">    int c;</a>
<a name="ln3102">    int in_quote = false;</a>
<a name="ln3103">    const char *bow = NULL;  // Beginning of word.</a>
<a name="ln3104"> </a>
<a name="ln3105">    /*</a>
<a name="ln3106">     * Allow spaces within back-quotes to count as part of the argument</a>
<a name="ln3107">     * being expanded.</a>
<a name="ln3108">     */</a>
<a name="ln3109">    xp-&gt;xp_pattern = skipwhite((const char_u *)arg);</a>
<a name="ln3110">    p = (const char *)xp-&gt;xp_pattern;</a>
<a name="ln3111">    while (*p != NUL) {</a>
<a name="ln3112">      c = utf_ptr2char((const char_u *)p);</a>
<a name="ln3113">      if (c == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln3114">        p++;</a>
<a name="ln3115">      } else if (c == '`') {</a>
<a name="ln3116">        if (!in_quote) {</a>
<a name="ln3117">          xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3118">          bow = p + 1;</a>
<a name="ln3119">        }</a>
<a name="ln3120">        in_quote = !in_quote;</a>
<a name="ln3121">      }</a>
<a name="ln3122">      /* An argument can contain just about everything, except</a>
<a name="ln3123">       * characters that end the command and white space. */</a>
<a name="ln3124">      else if (c == '|'</a>
<a name="ln3125">            || c == '\n'</a>
<a name="ln3126">            || c == '&quot;'</a>
<a name="ln3127">            || ascii_iswhite(c)) {</a>
<a name="ln3128">        len = 0;          /* avoid getting stuck when space is in 'isfname' */</a>
<a name="ln3129">        while (*p != NUL) {</a>
<a name="ln3130">          c = utf_ptr2char((const char_u *)p);</a>
<a name="ln3131">          if (c == '`' || vim_isfilec_or_wc(c)) {</a>
<a name="ln3132">            break;</a>
<a name="ln3133">          }</a>
<a name="ln3134">          len = (size_t)utfc_ptr2len((const char_u *)p);</a>
<a name="ln3135">          MB_PTR_ADV(p);</a>
<a name="ln3136">        }</a>
<a name="ln3137">        if (in_quote) {</a>
<a name="ln3138">          bow = p;</a>
<a name="ln3139">        } else {</a>
<a name="ln3140">          xp-&gt;xp_pattern = (char_u *)p;</a>
<a name="ln3141">        }</a>
<a name="ln3142">        p -= len;</a>
<a name="ln3143">      }</a>
<a name="ln3144">      MB_PTR_ADV(p);</a>
<a name="ln3145">    }</a>
<a name="ln3146"> </a>
<a name="ln3147">    /*</a>
<a name="ln3148">     * If we are still inside the quotes, and we passed a space, just</a>
<a name="ln3149">     * expand from there.</a>
<a name="ln3150">     */</a>
<a name="ln3151">    if (bow != NULL &amp;&amp; in_quote) {</a>
<a name="ln3152">      xp-&gt;xp_pattern = (char_u *)bow;</a>
<a name="ln3153">    }</a>
<a name="ln3154">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln3155"> </a>
<a name="ln3156">    /* For a shell command more chars need to be escaped. */</a>
<a name="ln3157">    if (usefilter || ea.cmdidx == CMD_bang || ea.cmdidx == CMD_terminal) {</a>
<a name="ln3158">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln3159">      xp-&gt;xp_shell = TRUE;</a>
<a name="ln3160">#endif</a>
<a name="ln3161">      // When still after the command name expand executables.</a>
<a name="ln3162">      if (xp-&gt;xp_pattern == skipwhite((const char_u *)arg)) {</a>
<a name="ln3163">        xp-&gt;xp_context = EXPAND_SHELLCMD;</a>
<a name="ln3164">      }</a>
<a name="ln3165">    }</a>
<a name="ln3166"> </a>
<a name="ln3167">    // Check for environment variable.</a>
<a name="ln3168">    if (*xp-&gt;xp_pattern == '$') {</a>
<a name="ln3169">      for (p = (const char *)xp-&gt;xp_pattern + 1; *p != NUL; p++) {</a>
<a name="ln3170">        if (!vim_isIDc((uint8_t)(*p))) {</a>
<a name="ln3171">          break;</a>
<a name="ln3172">        }</a>
<a name="ln3173">      }</a>
<a name="ln3174">      if (*p == NUL) {</a>
<a name="ln3175">        xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln3176">        xp-&gt;xp_pattern++;</a>
<a name="ln3177">        // Avoid that the assignment uses EXPAND_FILES again.</a>
<a name="ln3178">        if (context != EXPAND_USER_DEFINED &amp;&amp; context != EXPAND_USER_LIST) {</a>
<a name="ln3179">          context = EXPAND_ENV_VARS;</a>
<a name="ln3180">        }</a>
<a name="ln3181">      }</a>
<a name="ln3182">    }</a>
<a name="ln3183">    /* Check for user names */</a>
<a name="ln3184">    if (*xp-&gt;xp_pattern == '~') {</a>
<a name="ln3185">      for (p = (const char *)xp-&gt;xp_pattern + 1; *p != NUL &amp;&amp; *p != '/'; p++) {</a>
<a name="ln3186">      }</a>
<a name="ln3187">      // Complete ~user only if it partially matches a user name.</a>
<a name="ln3188">      // A full match ~user&lt;Tab&gt; will be replaced by user's home</a>
<a name="ln3189">      // directory i.e. something like ~user&lt;Tab&gt; -&gt; /home/user/</a>
<a name="ln3190">      if (*p == NUL &amp;&amp; p &gt; (const char *)xp-&gt;xp_pattern + 1</a>
<a name="ln3191">          &amp;&amp; match_user(xp-&gt;xp_pattern + 1) &gt;= 1) {</a>
<a name="ln3192">        xp-&gt;xp_context = EXPAND_USER;</a>
<a name="ln3193">        ++xp-&gt;xp_pattern;</a>
<a name="ln3194">      }</a>
<a name="ln3195">    }</a>
<a name="ln3196">  }</a>
<a name="ln3197"> </a>
<a name="ln3198">  /*</a>
<a name="ln3199">   * 6. switch on command name</a>
<a name="ln3200">   */</a>
<a name="ln3201">  switch (ea.cmdidx) {</a>
<a name="ln3202">  case CMD_find:</a>
<a name="ln3203">  case CMD_sfind:</a>
<a name="ln3204">  case CMD_tabfind:</a>
<a name="ln3205">    if (xp-&gt;xp_context == EXPAND_FILES)</a>
<a name="ln3206">      xp-&gt;xp_context = EXPAND_FILES_IN_PATH;</a>
<a name="ln3207">    break;</a>
<a name="ln3208">  case CMD_cd:</a>
<a name="ln3209">  case CMD_chdir:</a>
<a name="ln3210">  case CMD_lcd:</a>
<a name="ln3211">  case CMD_lchdir:</a>
<a name="ln3212">  case CMD_tcd:</a>
<a name="ln3213">  case CMD_tchdir:</a>
<a name="ln3214">    if (xp-&gt;xp_context == EXPAND_FILES) {</a>
<a name="ln3215">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln3216">    }</a>
<a name="ln3217">    break;</a>
<a name="ln3218">  case CMD_help:</a>
<a name="ln3219">    xp-&gt;xp_context = EXPAND_HELP;</a>
<a name="ln3220">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3221">    break;</a>
<a name="ln3222"> </a>
<a name="ln3223">  /* Command modifiers: return the argument.</a>
<a name="ln3224">   * Also for commands with an argument that is a command. */</a>
<a name="ln3225">  case CMD_aboveleft:</a>
<a name="ln3226">  case CMD_argdo:</a>
<a name="ln3227">  case CMD_belowright:</a>
<a name="ln3228">  case CMD_botright:</a>
<a name="ln3229">  case CMD_browse:</a>
<a name="ln3230">  case CMD_bufdo:</a>
<a name="ln3231">  case CMD_cdo:</a>
<a name="ln3232">  case CMD_cfdo:</a>
<a name="ln3233">  case CMD_confirm:</a>
<a name="ln3234">  case CMD_debug:</a>
<a name="ln3235">  case CMD_folddoclosed:</a>
<a name="ln3236">  case CMD_folddoopen:</a>
<a name="ln3237">  case CMD_hide:</a>
<a name="ln3238">  case CMD_keepalt:</a>
<a name="ln3239">  case CMD_keepjumps:</a>
<a name="ln3240">  case CMD_keepmarks:</a>
<a name="ln3241">  case CMD_keeppatterns:</a>
<a name="ln3242">  case CMD_ldo:</a>
<a name="ln3243">  case CMD_leftabove:</a>
<a name="ln3244">  case CMD_lfdo:</a>
<a name="ln3245">  case CMD_lockmarks:</a>
<a name="ln3246">  case CMD_noautocmd:</a>
<a name="ln3247">  case CMD_noswapfile:</a>
<a name="ln3248">  case CMD_rightbelow:</a>
<a name="ln3249">  case CMD_sandbox:</a>
<a name="ln3250">  case CMD_silent:</a>
<a name="ln3251">  case CMD_tab:</a>
<a name="ln3252">  case CMD_tabdo:</a>
<a name="ln3253">  case CMD_topleft:</a>
<a name="ln3254">  case CMD_verbose:</a>
<a name="ln3255">  case CMD_vertical:</a>
<a name="ln3256">  case CMD_windo:</a>
<a name="ln3257">    return arg;</a>
<a name="ln3258"> </a>
<a name="ln3259">  case CMD_filter:</a>
<a name="ln3260">    if (*arg != NUL) {</a>
<a name="ln3261">      arg = (const char *)skip_vimgrep_pat((char_u *)arg, NULL, NULL);</a>
<a name="ln3262">    }</a>
<a name="ln3263">    if (arg == NULL || *arg == NUL) {</a>
<a name="ln3264">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3265">      return NULL;</a>
<a name="ln3266">    }</a>
<a name="ln3267">    return (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln3268"> </a>
<a name="ln3269">  case CMD_match:</a>
<a name="ln3270">    if (*arg == NUL || !ends_excmd(*arg)) {</a>
<a name="ln3271">      /* also complete &quot;None&quot; */</a>
<a name="ln3272">      set_context_in_echohl_cmd(xp, arg);</a>
<a name="ln3273">      arg = (const char *)skipwhite(skiptowhite((const char_u *)arg));</a>
<a name="ln3274">      if (*arg != NUL) {</a>
<a name="ln3275">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3276">        arg = (const char *)skip_regexp((char_u *)arg + 1, (uint8_t)(*arg),</a>
<a name="ln3277">                                        p_magic, NULL);</a>
<a name="ln3278">      }</a>
<a name="ln3279">    }</a>
<a name="ln3280">    return (const char *)find_nextcmd((char_u *)arg);</a>
<a name="ln3281"> </a>
<a name="ln3282">  /*</a>
<a name="ln3283">   * All completion for the +cmdline_compl feature goes here.</a>
<a name="ln3284">   */</a>
<a name="ln3285"> </a>
<a name="ln3286">  case CMD_command:</a>
<a name="ln3287">    /* Check for attributes */</a>
<a name="ln3288">    while (*arg == '-') {</a>
<a name="ln3289">      arg++;  // Skip &quot;-&quot;.</a>
<a name="ln3290">      p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3291">      if (*p == NUL) {</a>
<a name="ln3292">        // Cursor is still in the attribute.</a>
<a name="ln3293">        p = strchr(arg, '=');</a>
<a name="ln3294">        if (p == NULL) {</a>
<a name="ln3295">          // No &quot;=&quot;, so complete attribute names.</a>
<a name="ln3296">          xp-&gt;xp_context = EXPAND_USER_CMD_FLAGS;</a>
<a name="ln3297">          xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3298">          return NULL;</a>
<a name="ln3299">        }</a>
<a name="ln3300"> </a>
<a name="ln3301">        // For the -complete, -nargs and -addr attributes, we complete</a>
<a name="ln3302">        // their arguments as well.</a>
<a name="ln3303">        if (STRNICMP(arg, &quot;complete&quot;, p - arg) == 0) {</a>
<a name="ln3304">          xp-&gt;xp_context = EXPAND_USER_COMPLETE;</a>
<a name="ln3305">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3306">          return NULL;</a>
<a name="ln3307">        } else if (STRNICMP(arg, &quot;nargs&quot;, p - arg) == 0) {</a>
<a name="ln3308">          xp-&gt;xp_context = EXPAND_USER_NARGS;</a>
<a name="ln3309">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3310">          return NULL;</a>
<a name="ln3311">        } else if (STRNICMP(arg, &quot;addr&quot;, p - arg) == 0) {</a>
<a name="ln3312">          xp-&gt;xp_context = EXPAND_USER_ADDR_TYPE;</a>
<a name="ln3313">          xp-&gt;xp_pattern = (char_u *)p + 1;</a>
<a name="ln3314">          return NULL;</a>
<a name="ln3315">        }</a>
<a name="ln3316">        return NULL;</a>
<a name="ln3317">      }</a>
<a name="ln3318">      arg = (const char *)skipwhite((char_u *)p);</a>
<a name="ln3319">    }</a>
<a name="ln3320"> </a>
<a name="ln3321">    // After the attributes comes the new command name.</a>
<a name="ln3322">    p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3323">    if (*p == NUL) {</a>
<a name="ln3324">      xp-&gt;xp_context = EXPAND_USER_COMMANDS;</a>
<a name="ln3325">      xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3326">      break;</a>
<a name="ln3327">    }</a>
<a name="ln3328"> </a>
<a name="ln3329">    // And finally comes a normal command.</a>
<a name="ln3330">    return (const char *)skipwhite((const char_u *)p);</a>
<a name="ln3331"> </a>
<a name="ln3332">  case CMD_delcommand:</a>
<a name="ln3333">    xp-&gt;xp_context = EXPAND_USER_COMMANDS;</a>
<a name="ln3334">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3335">    break;</a>
<a name="ln3336"> </a>
<a name="ln3337">  case CMD_global:</a>
<a name="ln3338">  case CMD_vglobal: {</a>
<a name="ln3339">    const int delim = (uint8_t)(*arg);  // Get the delimiter.</a>
<a name="ln3340">    if (delim) {</a>
<a name="ln3341">      arg++;  // Skip delimiter if there is one.</a>
<a name="ln3342">    }</a>
<a name="ln3343"> </a>
<a name="ln3344">    while (arg[0] != NUL &amp;&amp; (uint8_t)arg[0] != delim) {</a>
<a name="ln3345">      if (arg[0] == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3346">        arg++;</a>
<a name="ln3347">      }</a>
<a name="ln3348">      arg++;</a>
<a name="ln3349">    }</a>
<a name="ln3350">    if (arg[0] != NUL)</a>
<a name="ln3351">      return arg + 1;</a>
<a name="ln3352">    break;</a>
<a name="ln3353">  }</a>
<a name="ln3354">  case CMD_and:</a>
<a name="ln3355">  case CMD_substitute: {</a>
<a name="ln3356">    const int delim = (uint8_t)(*arg);</a>
<a name="ln3357">    if (delim) {</a>
<a name="ln3358">      // Skip &quot;from&quot; part.</a>
<a name="ln3359">      arg++;</a>
<a name="ln3360">      arg = (const char *)skip_regexp((char_u *)arg, delim, p_magic, NULL);</a>
<a name="ln3361">    }</a>
<a name="ln3362">    // Skip &quot;to&quot; part.</a>
<a name="ln3363">    while (arg[0] != NUL &amp;&amp; (uint8_t)arg[0] != delim) {</a>
<a name="ln3364">      if (arg[0] == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3365">        arg++;</a>
<a name="ln3366">      }</a>
<a name="ln3367">      arg++;</a>
<a name="ln3368">    }</a>
<a name="ln3369">    if (arg[0] != NUL) {  // Skip delimiter.</a>
<a name="ln3370">      arg++;</a>
<a name="ln3371">    }</a>
<a name="ln3372">    while (arg[0] &amp;&amp; strchr(&quot;|\&quot;#&quot;, arg[0]) == NULL) {</a>
<a name="ln3373">      arg++;</a>
<a name="ln3374">    }</a>
<a name="ln3375">    if (arg[0] != NUL) {</a>
<a name="ln3376">      return arg;</a>
<a name="ln3377">    }</a>
<a name="ln3378">    break;</a>
<a name="ln3379">  }</a>
<a name="ln3380">  case CMD_isearch:</a>
<a name="ln3381">  case CMD_dsearch:</a>
<a name="ln3382">  case CMD_ilist:</a>
<a name="ln3383">  case CMD_dlist:</a>
<a name="ln3384">  case CMD_ijump:</a>
<a name="ln3385">  case CMD_psearch:</a>
<a name="ln3386">  case CMD_djump:</a>
<a name="ln3387">  case CMD_isplit:</a>
<a name="ln3388">  case CMD_dsplit:</a>
<a name="ln3389">    // Skip count.</a>
<a name="ln3390">    arg = (const char *)skipwhite(skipdigits((const char_u *)arg));</a>
<a name="ln3391">    if (*arg == '/') {  // Match regexp, not just whole words.</a>
<a name="ln3392">      for (++arg; *arg &amp;&amp; *arg != '/'; arg++) {</a>
<a name="ln3393">        if (*arg == '\\' &amp;&amp; arg[1] != NUL) {</a>
<a name="ln3394">          arg++;</a>
<a name="ln3395">        }</a>
<a name="ln3396">      }</a>
<a name="ln3397">      if (*arg) {</a>
<a name="ln3398">        arg = (const char *)skipwhite((const char_u *)arg + 1);</a>
<a name="ln3399"> </a>
<a name="ln3400">        // Check for trailing illegal characters.</a>
<a name="ln3401">        if (*arg &amp;&amp; strchr(&quot;|\&quot;\n&quot;, *arg) == NULL) {</a>
<a name="ln3402">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3403">        } else {</a>
<a name="ln3404">          return arg;</a>
<a name="ln3405">        }</a>
<a name="ln3406">      }</a>
<a name="ln3407">    }</a>
<a name="ln3408">    break;</a>
<a name="ln3409">  case CMD_autocmd:</a>
<a name="ln3410">    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, false);</a>
<a name="ln3411"> </a>
<a name="ln3412">  case CMD_doautocmd:</a>
<a name="ln3413">  case CMD_doautoall:</a>
<a name="ln3414">    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, true);</a>
<a name="ln3415">  case CMD_set:</a>
<a name="ln3416">    set_context_in_set_cmd(xp, (char_u *)arg, 0);</a>
<a name="ln3417">    break;</a>
<a name="ln3418">  case CMD_setglobal:</a>
<a name="ln3419">    set_context_in_set_cmd(xp, (char_u *)arg, OPT_GLOBAL);</a>
<a name="ln3420">    break;</a>
<a name="ln3421">  case CMD_setlocal:</a>
<a name="ln3422">    set_context_in_set_cmd(xp, (char_u *)arg, OPT_LOCAL);</a>
<a name="ln3423">    break;</a>
<a name="ln3424">  case CMD_tag:</a>
<a name="ln3425">  case CMD_stag:</a>
<a name="ln3426">  case CMD_ptag:</a>
<a name="ln3427">  case CMD_ltag:</a>
<a name="ln3428">  case CMD_tselect:</a>
<a name="ln3429">  case CMD_stselect:</a>
<a name="ln3430">  case CMD_ptselect:</a>
<a name="ln3431">  case CMD_tjump:</a>
<a name="ln3432">  case CMD_stjump:</a>
<a name="ln3433">  case CMD_ptjump:</a>
<a name="ln3434">    if (wop_flags &amp; WOP_TAGFILE) {</a>
<a name="ln3435">      xp-&gt;xp_context = EXPAND_TAGS_LISTFILES;</a>
<a name="ln3436">    } else {</a>
<a name="ln3437">      xp-&gt;xp_context = EXPAND_TAGS;</a>
<a name="ln3438">    }</a>
<a name="ln3439">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3440">    break;</a>
<a name="ln3441">  case CMD_augroup:</a>
<a name="ln3442">    xp-&gt;xp_context = EXPAND_AUGROUP;</a>
<a name="ln3443">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3444">    break;</a>
<a name="ln3445">  case CMD_syntax:</a>
<a name="ln3446">    set_context_in_syntax_cmd(xp, arg);</a>
<a name="ln3447">    break;</a>
<a name="ln3448">  case CMD_const:</a>
<a name="ln3449">  case CMD_let:</a>
<a name="ln3450">  case CMD_if:</a>
<a name="ln3451">  case CMD_elseif:</a>
<a name="ln3452">  case CMD_while:</a>
<a name="ln3453">  case CMD_for:</a>
<a name="ln3454">  case CMD_echo:</a>
<a name="ln3455">  case CMD_echon:</a>
<a name="ln3456">  case CMD_execute:</a>
<a name="ln3457">  case CMD_echomsg:</a>
<a name="ln3458">  case CMD_echoerr:</a>
<a name="ln3459">  case CMD_call:</a>
<a name="ln3460">  case CMD_return:</a>
<a name="ln3461">  case CMD_cexpr:</a>
<a name="ln3462">  case CMD_caddexpr:</a>
<a name="ln3463">  case CMD_cgetexpr:</a>
<a name="ln3464">  case CMD_lexpr:</a>
<a name="ln3465">  case CMD_laddexpr:</a>
<a name="ln3466">  case CMD_lgetexpr:</a>
<a name="ln3467">    set_context_for_expression(xp, (char_u *)arg, ea.cmdidx);</a>
<a name="ln3468">    break;</a>
<a name="ln3469"> </a>
<a name="ln3470">  case CMD_unlet:</a>
<a name="ln3471">    while ((xp-&gt;xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {</a>
<a name="ln3472">      arg = (const char *)xp-&gt;xp_pattern + 1;</a>
<a name="ln3473">    }</a>
<a name="ln3474"> </a>
<a name="ln3475">    xp-&gt;xp_context = EXPAND_USER_VARS;</a>
<a name="ln3476">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3477"> </a>
<a name="ln3478">    if (*xp-&gt;xp_pattern == '$') {</a>
<a name="ln3479">      xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln3480">      xp-&gt;xp_pattern++;</a>
<a name="ln3481">    }</a>
<a name="ln3482"> </a>
<a name="ln3483">    break;</a>
<a name="ln3484"> </a>
<a name="ln3485">  case CMD_function:</a>
<a name="ln3486">  case CMD_delfunction:</a>
<a name="ln3487">    xp-&gt;xp_context = EXPAND_USER_FUNC;</a>
<a name="ln3488">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3489">    break;</a>
<a name="ln3490"> </a>
<a name="ln3491">  case CMD_echohl:</a>
<a name="ln3492">    set_context_in_echohl_cmd(xp, arg);</a>
<a name="ln3493">    break;</a>
<a name="ln3494">  case CMD_highlight:</a>
<a name="ln3495">    set_context_in_highlight_cmd(xp, arg);</a>
<a name="ln3496">    break;</a>
<a name="ln3497">  case CMD_cscope:</a>
<a name="ln3498">  case CMD_lcscope:</a>
<a name="ln3499">  case CMD_scscope:</a>
<a name="ln3500">    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);</a>
<a name="ln3501">    break;</a>
<a name="ln3502">  case CMD_sign:</a>
<a name="ln3503">    set_context_in_sign_cmd(xp, (char_u *)arg);</a>
<a name="ln3504">    break;</a>
<a name="ln3505">  case CMD_bdelete:</a>
<a name="ln3506">  case CMD_bwipeout:</a>
<a name="ln3507">  case CMD_bunload:</a>
<a name="ln3508">    while ((xp-&gt;xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {</a>
<a name="ln3509">      arg = (const char *)xp-&gt;xp_pattern + 1;</a>
<a name="ln3510">    }</a>
<a name="ln3511">    FALLTHROUGH;</a>
<a name="ln3512">  case CMD_buffer:</a>
<a name="ln3513">  case CMD_sbuffer:</a>
<a name="ln3514">  case CMD_checktime:</a>
<a name="ln3515">    xp-&gt;xp_context = EXPAND_BUFFERS;</a>
<a name="ln3516">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3517">    break;</a>
<a name="ln3518">  case CMD_USER:</a>
<a name="ln3519">  case CMD_USER_BUF:</a>
<a name="ln3520">    if (context != EXPAND_NOTHING) {</a>
<a name="ln3521">      // EX_XFILE: file names are handled above.</a>
<a name="ln3522">      if (!(ea.argt &amp; EX_XFILE)) {</a>
<a name="ln3523">        if (context == EXPAND_MENUS) {</a>
<a name="ln3524">          return (const char *)set_context_in_menu_cmd(xp, (char_u *)cmd,</a>
<a name="ln3525">                                                       (char_u *)arg, forceit);</a>
<a name="ln3526">        } else if (context == EXPAND_COMMANDS) {</a>
<a name="ln3527">          return arg;</a>
<a name="ln3528">        } else if (context == EXPAND_MAPPINGS) {</a>
<a name="ln3529">          return (const char *)set_context_in_map_cmd(</a>
<a name="ln3530">              xp, (char_u *)&quot;map&quot;, (char_u *)arg, forceit, false, false,</a>
<a name="ln3531">              CMD_map);</a>
<a name="ln3532">        }</a>
<a name="ln3533">        // Find start of last argument.</a>
<a name="ln3534">        p = arg;</a>
<a name="ln3535">        while (*p) {</a>
<a name="ln3536">          if (*p == ' ') {</a>
<a name="ln3537">            // argument starts after a space</a>
<a name="ln3538">            arg = p + 1;</a>
<a name="ln3539">          } else if (*p == '\\' &amp;&amp; *(p + 1) != NUL) {</a>
<a name="ln3540">            p++;                // skip over escaped character</a>
<a name="ln3541">          }</a>
<a name="ln3542">          MB_PTR_ADV(p);</a>
<a name="ln3543">        }</a>
<a name="ln3544">        xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3545">      }</a>
<a name="ln3546">      xp-&gt;xp_context = context;</a>
<a name="ln3547">    }</a>
<a name="ln3548">    break;</a>
<a name="ln3549">  case CMD_map:       case CMD_noremap:</a>
<a name="ln3550">  case CMD_nmap:      case CMD_nnoremap:</a>
<a name="ln3551">  case CMD_vmap:      case CMD_vnoremap:</a>
<a name="ln3552">  case CMD_omap:      case CMD_onoremap:</a>
<a name="ln3553">  case CMD_imap:      case CMD_inoremap:</a>
<a name="ln3554">  case CMD_cmap:      case CMD_cnoremap:</a>
<a name="ln3555">  case CMD_lmap:      case CMD_lnoremap:</a>
<a name="ln3556">  case CMD_smap:      case CMD_snoremap:</a>
<a name="ln3557">  case CMD_xmap:      case CMD_xnoremap:</a>
<a name="ln3558">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3559">        xp, (char_u *)cmd, (char_u *)arg, forceit, false, false, ea.cmdidx);</a>
<a name="ln3560">  case CMD_unmap:</a>
<a name="ln3561">  case CMD_nunmap:</a>
<a name="ln3562">  case CMD_vunmap:</a>
<a name="ln3563">  case CMD_ounmap:</a>
<a name="ln3564">  case CMD_iunmap:</a>
<a name="ln3565">  case CMD_cunmap:</a>
<a name="ln3566">  case CMD_lunmap:</a>
<a name="ln3567">  case CMD_sunmap:</a>
<a name="ln3568">  case CMD_xunmap:</a>
<a name="ln3569">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3570">        xp, (char_u *)cmd, (char_u *)arg, forceit, false, true, ea.cmdidx);</a>
<a name="ln3571">  case CMD_mapclear:</a>
<a name="ln3572">  case CMD_nmapclear:</a>
<a name="ln3573">  case CMD_vmapclear:</a>
<a name="ln3574">  case CMD_omapclear:</a>
<a name="ln3575">  case CMD_imapclear:</a>
<a name="ln3576">  case CMD_cmapclear:</a>
<a name="ln3577">  case CMD_lmapclear:</a>
<a name="ln3578">  case CMD_smapclear:</a>
<a name="ln3579">  case CMD_xmapclear:</a>
<a name="ln3580">    xp-&gt;xp_context = EXPAND_MAPCLEAR;</a>
<a name="ln3581">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3582">    break;</a>
<a name="ln3583"> </a>
<a name="ln3584">  case CMD_abbreviate:    case CMD_noreabbrev:</a>
<a name="ln3585">  case CMD_cabbrev:       case CMD_cnoreabbrev:</a>
<a name="ln3586">  case CMD_iabbrev:       case CMD_inoreabbrev:</a>
<a name="ln3587">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3588">        xp, (char_u *)cmd, (char_u *)arg, forceit, true, false, ea.cmdidx);</a>
<a name="ln3589">  case CMD_unabbreviate:</a>
<a name="ln3590">  case CMD_cunabbrev:</a>
<a name="ln3591">  case CMD_iunabbrev:</a>
<a name="ln3592">    return (const char *)set_context_in_map_cmd(</a>
<a name="ln3593">        xp, (char_u *)cmd, (char_u *)arg, forceit, true, true, ea.cmdidx);</a>
<a name="ln3594">  case CMD_menu:      case CMD_noremenu:      case CMD_unmenu:</a>
<a name="ln3595">  case CMD_amenu:     case CMD_anoremenu:     case CMD_aunmenu:</a>
<a name="ln3596">  case CMD_nmenu:     case CMD_nnoremenu:     case CMD_nunmenu:</a>
<a name="ln3597">  case CMD_vmenu:     case CMD_vnoremenu:     case CMD_vunmenu:</a>
<a name="ln3598">  case CMD_omenu:     case CMD_onoremenu:     case CMD_ounmenu:</a>
<a name="ln3599">  case CMD_imenu:     case CMD_inoremenu:     case CMD_iunmenu:</a>
<a name="ln3600">  case CMD_cmenu:     case CMD_cnoremenu:     case CMD_cunmenu:</a>
<a name="ln3601">  case CMD_tmenu:                             case CMD_tunmenu:</a>
<a name="ln3602">  case CMD_popup:                             case CMD_emenu:</a>
<a name="ln3603">    return (const char *)set_context_in_menu_cmd(</a>
<a name="ln3604">        xp, (char_u *)cmd, (char_u *)arg, forceit);</a>
<a name="ln3605"> </a>
<a name="ln3606">  case CMD_colorscheme:</a>
<a name="ln3607">    xp-&gt;xp_context = EXPAND_COLORS;</a>
<a name="ln3608">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3609">    break;</a>
<a name="ln3610"> </a>
<a name="ln3611">  case CMD_compiler:</a>
<a name="ln3612">    xp-&gt;xp_context = EXPAND_COMPILER;</a>
<a name="ln3613">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3614">    break;</a>
<a name="ln3615"> </a>
<a name="ln3616">  case CMD_ownsyntax:</a>
<a name="ln3617">    xp-&gt;xp_context = EXPAND_OWNSYNTAX;</a>
<a name="ln3618">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3619">    break;</a>
<a name="ln3620"> </a>
<a name="ln3621">  case CMD_setfiletype:</a>
<a name="ln3622">    xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln3623">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3624">    break;</a>
<a name="ln3625"> </a>
<a name="ln3626">  case CMD_packadd:</a>
<a name="ln3627">    xp-&gt;xp_context = EXPAND_PACKADD;</a>
<a name="ln3628">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3629">    break;</a>
<a name="ln3630"> </a>
<a name="ln3631">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3632">  case CMD_language:</a>
<a name="ln3633">    p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln3634">    if (*p == NUL) {</a>
<a name="ln3635">      xp-&gt;xp_context = EXPAND_LANGUAGE;</a>
<a name="ln3636">      xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3637">    } else {</a>
<a name="ln3638">      if (strncmp(arg, &quot;messages&quot;, p - arg) == 0</a>
<a name="ln3639">          || strncmp(arg, &quot;ctype&quot;, p - arg) == 0</a>
<a name="ln3640">          || strncmp(arg, &quot;time&quot;, p - arg) == 0) {</a>
<a name="ln3641">        xp-&gt;xp_context = EXPAND_LOCALES;</a>
<a name="ln3642">        xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln3643">      } else {</a>
<a name="ln3644">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln3645">      }</a>
<a name="ln3646">    }</a>
<a name="ln3647">    break;</a>
<a name="ln3648">#endif</a>
<a name="ln3649">  case CMD_profile:</a>
<a name="ln3650">    set_context_in_profile_cmd(xp, arg);</a>
<a name="ln3651">    break;</a>
<a name="ln3652">  case CMD_checkhealth:</a>
<a name="ln3653">    xp-&gt;xp_context = EXPAND_CHECKHEALTH;</a>
<a name="ln3654">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3655">    break;</a>
<a name="ln3656">  case CMD_behave:</a>
<a name="ln3657">    xp-&gt;xp_context = EXPAND_BEHAVE;</a>
<a name="ln3658">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3659">    break;</a>
<a name="ln3660"> </a>
<a name="ln3661">  case CMD_messages:</a>
<a name="ln3662">    xp-&gt;xp_context = EXPAND_MESSAGES;</a>
<a name="ln3663">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3664">    break;</a>
<a name="ln3665"> </a>
<a name="ln3666">  case CMD_history:</a>
<a name="ln3667">    xp-&gt;xp_context = EXPAND_HISTORY;</a>
<a name="ln3668">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3669">    break;</a>
<a name="ln3670">  case CMD_syntime:</a>
<a name="ln3671">    xp-&gt;xp_context = EXPAND_SYNTIME;</a>
<a name="ln3672">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3673">    break;</a>
<a name="ln3674"> </a>
<a name="ln3675">  case CMD_argdelete:</a>
<a name="ln3676">    while ((xp-&gt;xp_pattern = vim_strchr((const char_u *)arg, ' ')) != NULL) {</a>
<a name="ln3677">      arg = (const char *)(xp-&gt;xp_pattern + 1);</a>
<a name="ln3678">    }</a>
<a name="ln3679">    xp-&gt;xp_context = EXPAND_ARGLIST;</a>
<a name="ln3680">    xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln3681">    break;</a>
<a name="ln3682"> </a>
<a name="ln3683">  default:</a>
<a name="ln3684">    break;</a>
<a name="ln3685">  }</a>
<a name="ln3686">  return NULL;</a>
<a name="ln3687">}</a>
<a name="ln3688"> </a>
<a name="ln3689">// Skip a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln3690">//</a>
<a name="ln3691">// Backslashed delimiters after / or ? will be skipped, and commands will</a>
<a name="ln3692">// not be expanded between /'s and ?'s or after &quot;'&quot;.</a>
<a name="ln3693">//</a>
<a name="ln3694">// Also skip white space and &quot;:&quot; characters.</a>
<a name="ln3695">// Returns the &quot;cmd&quot; pointer advanced to beyond the range.</a>
<a name="ln3696">char_u *skip_range(</a>
<a name="ln3697">    const char_u *cmd,</a>
<a name="ln3698">    int *ctx       // pointer to xp_context or NULL</a>
<a name="ln3699">)</a>
<a name="ln3700">{</a>
<a name="ln3701">  unsigned delim;</a>
<a name="ln3702"> </a>
<a name="ln3703">  while (vim_strchr((char_u *)&quot; \t0123456789.$%'/?-+,;\\&quot;, *cmd) != NULL) {</a>
<a name="ln3704">    if (*cmd == '\\') {</a>
<a name="ln3705">      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&amp;') {</a>
<a name="ln3706">        cmd++;</a>
<a name="ln3707">      } else {</a>
<a name="ln3708">        break;</a>
<a name="ln3709">      }</a>
<a name="ln3710">    } else if (*cmd == '\'') {</a>
<a name="ln3711">      if (*++cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3712">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3713">      }</a>
<a name="ln3714">    } else if (*cmd == '/' || *cmd == '?') {</a>
<a name="ln3715">      delim = *cmd++;</a>
<a name="ln3716">      while (*cmd != NUL &amp;&amp; *cmd != delim)</a>
<a name="ln3717">        if (*cmd++ == '\\' &amp;&amp; *cmd != NUL)</a>
<a name="ln3718">          ++cmd;</a>
<a name="ln3719">      if (*cmd == NUL &amp;&amp; ctx != NULL)</a>
<a name="ln3720">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3721">    }</a>
<a name="ln3722">    if (*cmd != NUL)</a>
<a name="ln3723">      ++cmd;</a>
<a name="ln3724">  }</a>
<a name="ln3725"> </a>
<a name="ln3726">  // Skip &quot;:&quot; and white space.</a>
<a name="ln3727">  cmd = skip_colon_white(cmd, false);</a>
<a name="ln3728"> </a>
<a name="ln3729">  return (char_u *)cmd;</a>
<a name="ln3730">}</a>
<a name="ln3731"> </a>
<a name="ln3732">static void addr_error(cmd_addr_T addr_type)</a>
<a name="ln3733">{</a>
<a name="ln3734">  if (addr_type == ADDR_NONE) {</a>
<a name="ln3735">    EMSG(_(e_norange));</a>
<a name="ln3736">  } else {</a>
<a name="ln3737">    EMSG(_(e_invrange));</a>
<a name="ln3738">  }</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">// Get a single EX address</a>
<a name="ln3742">//</a>
<a name="ln3743">// Set ptr to the next character after the part that was interpreted.</a>
<a name="ln3744">// Set ptr to NULL when an error is encountered.</a>
<a name="ln3745">// This may set the last used search pattern.</a>
<a name="ln3746">//</a>
<a name="ln3747">// Return MAXLNUM when no Ex address was found.</a>
<a name="ln3748">static linenr_T get_address(exarg_T *eap,</a>
<a name="ln3749">                            char_u **ptr,</a>
<a name="ln3750">                            cmd_addr_T addr_type,</a>
<a name="ln3751">                            int skip,  // only skip the address, don't use it</a>
<a name="ln3752">                            bool silent,  // no errors or side effects</a>
<a name="ln3753">                            int to_other_file,  // flag: may jump to other file</a>
<a name="ln3754">                            int address_count)  // 1 for first, &gt;1 after comma</a>
<a name="ln3755">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3756">{</a>
<a name="ln3757">  int c;</a>
<a name="ln3758">  int i;</a>
<a name="ln3759">  long n;</a>
<a name="ln3760">  char_u      *cmd;</a>
<a name="ln3761">  pos_T pos;</a>
<a name="ln3762">  pos_T       *fp;</a>
<a name="ln3763">  linenr_T lnum;</a>
<a name="ln3764">  buf_T *buf;</a>
<a name="ln3765"> </a>
<a name="ln3766">  cmd = skipwhite(*ptr);</a>
<a name="ln3767">  lnum = MAXLNUM;</a>
<a name="ln3768">  do {</a>
<a name="ln3769">    switch (*cmd) {</a>
<a name="ln3770">    case '.':                               /* '.' - Cursor position */</a>
<a name="ln3771">      ++cmd;</a>
<a name="ln3772">      switch (addr_type) {</a>
<a name="ln3773">        case ADDR_LINES:</a>
<a name="ln3774">        case ADDR_OTHER:</a>
<a name="ln3775">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3776">          break;</a>
<a name="ln3777">        case ADDR_WINDOWS:</a>
<a name="ln3778">          lnum = CURRENT_WIN_NR;</a>
<a name="ln3779">          break;</a>
<a name="ln3780">        case ADDR_ARGUMENTS:</a>
<a name="ln3781">          lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3782">          break;</a>
<a name="ln3783">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3784">        case ADDR_BUFFERS:</a>
<a name="ln3785">          lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3786">          break;</a>
<a name="ln3787">        case ADDR_TABS:</a>
<a name="ln3788">          lnum = CURRENT_TAB_NR;</a>
<a name="ln3789">          break;</a>
<a name="ln3790">        case ADDR_NONE:</a>
<a name="ln3791">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3792">        case ADDR_UNSIGNED:</a>
<a name="ln3793">          addr_error(addr_type);</a>
<a name="ln3794">          cmd = NULL;</a>
<a name="ln3795">          goto error;</a>
<a name="ln3796">          break;</a>
<a name="ln3797">        case ADDR_QUICKFIX:</a>
<a name="ln3798">          lnum = qf_get_cur_idx(eap);</a>
<a name="ln3799">          break;</a>
<a name="ln3800">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3801">          lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3802">          break;</a>
<a name="ln3803">      }</a>
<a name="ln3804">      break;</a>
<a name="ln3805"> </a>
<a name="ln3806">    case '$':                               /* '$' - last line */</a>
<a name="ln3807">      ++cmd;</a>
<a name="ln3808">      switch (addr_type) {</a>
<a name="ln3809">        case ADDR_LINES:</a>
<a name="ln3810">        case ADDR_OTHER:</a>
<a name="ln3811">          lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3812">          break;</a>
<a name="ln3813">        case ADDR_WINDOWS:</a>
<a name="ln3814">          lnum = LAST_WIN_NR;</a>
<a name="ln3815">          break;</a>
<a name="ln3816">        case ADDR_ARGUMENTS:</a>
<a name="ln3817">          lnum = ARGCOUNT;</a>
<a name="ln3818">          break;</a>
<a name="ln3819">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3820">          buf = lastbuf;</a>
<a name="ln3821">          while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3822">            if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3823">              break;</a>
<a name="ln3824">            }</a>
<a name="ln3825">            buf = buf-&gt;b_prev;</a>
<a name="ln3826">          }</a>
<a name="ln3827">          lnum = buf-&gt;b_fnum;</a>
<a name="ln3828">          break;</a>
<a name="ln3829">        case ADDR_BUFFERS:</a>
<a name="ln3830">          lnum = lastbuf-&gt;b_fnum;</a>
<a name="ln3831">          break;</a>
<a name="ln3832">        case ADDR_TABS:</a>
<a name="ln3833">          lnum = LAST_TAB_NR;</a>
<a name="ln3834">          break;</a>
<a name="ln3835">        case ADDR_NONE:</a>
<a name="ln3836">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3837">        case ADDR_UNSIGNED:</a>
<a name="ln3838">          addr_error(addr_type);</a>
<a name="ln3839">          cmd = NULL;</a>
<a name="ln3840">          goto error;</a>
<a name="ln3841">          break;</a>
<a name="ln3842">        case ADDR_QUICKFIX:</a>
<a name="ln3843">          lnum = qf_get_size(eap);</a>
<a name="ln3844">          if (lnum == 0) {</a>
<a name="ln3845">            lnum = 1;</a>
<a name="ln3846">          }</a>
<a name="ln3847">          break;</a>
<a name="ln3848">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3849">          lnum = qf_get_valid_size(eap);</a>
<a name="ln3850">          if (lnum == 0) {</a>
<a name="ln3851">            lnum = 1;</a>
<a name="ln3852">          }</a>
<a name="ln3853">          break;</a>
<a name="ln3854">      }</a>
<a name="ln3855">      break;</a>
<a name="ln3856"> </a>
<a name="ln3857">    case '\'':                              /* ''' - mark */</a>
<a name="ln3858">      if (*++cmd == NUL) {</a>
<a name="ln3859">        cmd = NULL;</a>
<a name="ln3860">        goto error;</a>
<a name="ln3861">      }</a>
<a name="ln3862">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3863">        addr_error(addr_type);</a>
<a name="ln3864">        cmd = NULL;</a>
<a name="ln3865">        goto error;</a>
<a name="ln3866">      }</a>
<a name="ln3867">      if (skip)</a>
<a name="ln3868">        ++cmd;</a>
<a name="ln3869">      else {</a>
<a name="ln3870">        /* Only accept a mark in another file when it is</a>
<a name="ln3871">         * used by itself: &quot;:'M&quot;. */</a>
<a name="ln3872">        fp = getmark(*cmd, to_other_file &amp;&amp; cmd[1] == NUL);</a>
<a name="ln3873">        ++cmd;</a>
<a name="ln3874">        if (fp == (pos_T *)-1)</a>
<a name="ln3875">          /* Jumped to another file. */</a>
<a name="ln3876">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3877">        else {</a>
<a name="ln3878">          if (check_mark(fp) == FAIL) {</a>
<a name="ln3879">            cmd = NULL;</a>
<a name="ln3880">            goto error;</a>
<a name="ln3881">          }</a>
<a name="ln3882">          lnum = fp-&gt;lnum;</a>
<a name="ln3883">        }</a>
<a name="ln3884">      }</a>
<a name="ln3885">      break;</a>
<a name="ln3886"> </a>
<a name="ln3887">    case '/':</a>
<a name="ln3888">    case '?':                           /* '/' or '?' - search */</a>
<a name="ln3889">      c = *cmd++;</a>
<a name="ln3890">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3891">        addr_error(addr_type);</a>
<a name="ln3892">        cmd = NULL;</a>
<a name="ln3893">        goto error;</a>
<a name="ln3894">      }</a>
<a name="ln3895">      if (skip) {                       /* skip &quot;/pat/&quot; */</a>
<a name="ln3896">        cmd = skip_regexp(cmd, c, p_magic, NULL);</a>
<a name="ln3897">        if (*cmd == c)</a>
<a name="ln3898">          ++cmd;</a>
<a name="ln3899">      } else {</a>
<a name="ln3900">        int flags;</a>
<a name="ln3901"> </a>
<a name="ln3902">        pos = curwin-&gt;w_cursor;  // save curwin-&gt;w_cursor</a>
<a name="ln3903"> </a>
<a name="ln3904">        // When '/' or '?' follows another address, start from</a>
<a name="ln3905">        // there.</a>
<a name="ln3906">        if (lnum != MAXLNUM) {</a>
<a name="ln3907">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3908">        }</a>
<a name="ln3909"> </a>
<a name="ln3910">        // Start a forward search at the end of the line (unless</a>
<a name="ln3911">        // before the first line).</a>
<a name="ln3912">        // Start a backward search at the start of the line.</a>
<a name="ln3913">        // This makes sure we never match in the current</a>
<a name="ln3914">        // line, and can match anywhere in the</a>
<a name="ln3915">        // next/previous line.</a>
<a name="ln3916">        if (c == '/' &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 0) {</a>
<a name="ln3917">          curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln3918">        } else {</a>
<a name="ln3919">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3920">        }</a>
<a name="ln3921">        searchcmdlen = 0;</a>
<a name="ln3922">        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;</a>
<a name="ln3923">        if (!do_search(NULL, c, cmd, 1L, flags, NULL)) {</a>
<a name="ln3924">          curwin-&gt;w_cursor = pos;</a>
<a name="ln3925">          cmd = NULL;</a>
<a name="ln3926">          goto error;</a>
<a name="ln3927">        }</a>
<a name="ln3928">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3929">        curwin-&gt;w_cursor = pos;</a>
<a name="ln3930">        /* adjust command string pointer */</a>
<a name="ln3931">        cmd += searchcmdlen;</a>
<a name="ln3932">      }</a>
<a name="ln3933">      break;</a>
<a name="ln3934"> </a>
<a name="ln3935">    case '\\':                      /* &quot;\?&quot;, &quot;\/&quot; or &quot;\&amp;&quot;, repeat search */</a>
<a name="ln3936">      ++cmd;</a>
<a name="ln3937">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3938">        addr_error(addr_type);</a>
<a name="ln3939">        cmd = NULL;</a>
<a name="ln3940">        goto error;</a>
<a name="ln3941">      }</a>
<a name="ln3942">      if (*cmd == '&amp;')</a>
<a name="ln3943">        i = RE_SUBST;</a>
<a name="ln3944">      else if (*cmd == '?' || *cmd == '/')</a>
<a name="ln3945">        i = RE_SEARCH;</a>
<a name="ln3946">      else {</a>
<a name="ln3947">        EMSG(_(e_backslash));</a>
<a name="ln3948">        cmd = NULL;</a>
<a name="ln3949">        goto error;</a>
<a name="ln3950">      }</a>
<a name="ln3951"> </a>
<a name="ln3952">      if (!skip) {</a>
<a name="ln3953">        // When search follows another address, start from there.</a>
<a name="ln3954">        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin-&gt;w_cursor.lnum;</a>
<a name="ln3955">        // Start the search just like for the above do_search().</a>
<a name="ln3956">        pos.col = (*cmd != '?') ? MAXCOL : 0;</a>
<a name="ln3957">        pos.coladd = 0;</a>
<a name="ln3958">        if (searchit(curwin, curbuf, &amp;pos, NULL,</a>
<a name="ln3959">                     *cmd == '?' ? BACKWARD : FORWARD,</a>
<a name="ln3960">                     (char_u *)&quot;&quot;, 1L, SEARCH_MSG, i, NULL) != FAIL) {</a>
<a name="ln3961">          lnum = pos.lnum;</a>
<a name="ln3962">        } else {</a>
<a name="ln3963">          cmd = NULL;</a>
<a name="ln3964">          goto error;</a>
<a name="ln3965">        }</a>
<a name="ln3966">      }</a>
<a name="ln3967">      ++cmd;</a>
<a name="ln3968">      break;</a>
<a name="ln3969"> </a>
<a name="ln3970">    default:</a>
<a name="ln3971">      if (ascii_isdigit(*cmd)) {  // absolute line number</a>
<a name="ln3972">        lnum = getdigits_long(&amp;cmd, false, 0);</a>
<a name="ln3973">      }</a>
<a name="ln3974">    }</a>
<a name="ln3975"> </a>
<a name="ln3976">    for (;; ) {</a>
<a name="ln3977">      cmd = skipwhite(cmd);</a>
<a name="ln3978">      if (*cmd != '-' &amp;&amp; *cmd != '+' &amp;&amp; !ascii_isdigit(*cmd)) {</a>
<a name="ln3979">        break;</a>
<a name="ln3980">      }</a>
<a name="ln3981"> </a>
<a name="ln3982">      if (lnum == MAXLNUM) {</a>
<a name="ln3983">        switch (addr_type) {</a>
<a name="ln3984">          case ADDR_LINES:</a>
<a name="ln3985">          case ADDR_OTHER:</a>
<a name="ln3986">            // &quot;+1&quot; is same as &quot;.+1&quot;</a>
<a name="ln3987">            lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3988">            break;</a>
<a name="ln3989">          case ADDR_WINDOWS:</a>
<a name="ln3990">            lnum = CURRENT_WIN_NR;</a>
<a name="ln3991">            break;</a>
<a name="ln3992">          case ADDR_ARGUMENTS:</a>
<a name="ln3993">            lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3994">            break;</a>
<a name="ln3995">          case ADDR_LOADED_BUFFERS:</a>
<a name="ln3996">          case ADDR_BUFFERS:</a>
<a name="ln3997">            lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3998">            break;</a>
<a name="ln3999">          case ADDR_TABS:</a>
<a name="ln4000">            lnum = CURRENT_TAB_NR;</a>
<a name="ln4001">            break;</a>
<a name="ln4002">          case ADDR_TABS_RELATIVE:</a>
<a name="ln4003">            lnum = 1;</a>
<a name="ln4004">            break;</a>
<a name="ln4005">          case ADDR_QUICKFIX:</a>
<a name="ln4006">            lnum = qf_get_cur_idx(eap);</a>
<a name="ln4007">            break;</a>
<a name="ln4008">          case ADDR_QUICKFIX_VALID:</a>
<a name="ln4009">            lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln4010">            break;</a>
<a name="ln4011">          case ADDR_NONE:</a>
<a name="ln4012">          case ADDR_UNSIGNED:</a>
<a name="ln4013">            lnum = 0;</a>
<a name="ln4014">            break;</a>
<a name="ln4015">        }</a>
<a name="ln4016">      }</a>
<a name="ln4017"> </a>
<a name="ln4018">      if (ascii_isdigit(*cmd)) {</a>
<a name="ln4019">        i = '+';                        // &quot;number&quot; is same as &quot;+number&quot;</a>
<a name="ln4020">      } else {</a>
<a name="ln4021">        i = *cmd++;</a>
<a name="ln4022">      }</a>
<a name="ln4023">      if (!ascii_isdigit(*cmd)) {       // '+' is '+1', but '+0' is not '+1'</a>
<a name="ln4024">        n = 1;</a>
<a name="ln4025">      } else {</a>
<a name="ln4026">        n = getdigits(&amp;cmd, true, 0);</a>
<a name="ln4027">      }</a>
<a name="ln4028"> </a>
<a name="ln4029">      if (addr_type == ADDR_TABS_RELATIVE) {</a>
<a name="ln4030">        EMSG(_(e_invrange));</a>
<a name="ln4031">        cmd = NULL;</a>
<a name="ln4032">        goto error;</a>
<a name="ln4033">      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {</a>
<a name="ln4034">        lnum = compute_buffer_local_count(</a>
<a name="ln4035">            addr_type, lnum, (i == '-') ? -1 * n : n);</a>
<a name="ln4036">      } else {</a>
<a name="ln4037">        // Relative line addressing, need to adjust for folded lines</a>
<a name="ln4038">        // now, but only do it after the first address.</a>
<a name="ln4039">        if (addr_type == ADDR_LINES &amp;&amp; (i == '-' || i == '+')</a>
<a name="ln4040">            &amp;&amp; address_count &gt;= 2) {</a>
<a name="ln4041">          (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln4042">        }</a>
<a name="ln4043">        if (i == '-') {</a>
<a name="ln4044">          lnum -= n;</a>
<a name="ln4045">        } else {</a>
<a name="ln4046">          lnum += n;</a>
<a name="ln4047">        }</a>
<a name="ln4048">      }</a>
<a name="ln4049">    }</a>
<a name="ln4050">  } while (*cmd == '/' || *cmd == '?');</a>
<a name="ln4051"> </a>
<a name="ln4052">error:</a>
<a name="ln4053">  *ptr = cmd;</a>
<a name="ln4054">  return lnum;</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">/*</a>
<a name="ln4058"> * Get flags from an Ex command argument.</a>
<a name="ln4059"> */</a>
<a name="ln4060">static void get_flags(exarg_T *eap)</a>
<a name="ln4061">{</a>
<a name="ln4062">  while (vim_strchr((char_u *)&quot;lp#&quot;, *eap-&gt;arg) != NULL) {</a>
<a name="ln4063">    if (*eap-&gt;arg == 'l')</a>
<a name="ln4064">      eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln4065">    else if (*eap-&gt;arg == 'p')</a>
<a name="ln4066">      eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln4067">    else</a>
<a name="ln4068">      eap-&gt;flags |= EXFLAG_NR;</a>
<a name="ln4069">    eap-&gt;arg = skipwhite(eap-&gt;arg + 1);</a>
<a name="ln4070">  }</a>
<a name="ln4071">}</a>
<a name="ln4072"> </a>
<a name="ln4073">/// Stub function for command which is Not Implemented. NI!</a>
<a name="ln4074">void ex_ni(exarg_T *eap)</a>
<a name="ln4075">{</a>
<a name="ln4076">  if (!eap-&gt;skip)</a>
<a name="ln4077">    eap-&gt;errmsg = (char_u *)N_(</a>
<a name="ln4078">        &quot;E319: The command is not available in this version&quot;);</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081">/// Stub function for script command which is Not Implemented. NI!</a>
<a name="ln4082">/// Skips over &quot;:perl &lt;&lt;EOF&quot; constructs.</a>
<a name="ln4083">static void ex_script_ni(exarg_T *eap)</a>
<a name="ln4084">{</a>
<a name="ln4085">  if (!eap-&gt;skip) {</a>
<a name="ln4086">    ex_ni(eap);</a>
<a name="ln4087">  } else {</a>
<a name="ln4088">    size_t len;</a>
<a name="ln4089">    xfree(script_get(eap, &amp;len));</a>
<a name="ln4090">  }</a>
<a name="ln4091">}</a>
<a name="ln4092"> </a>
<a name="ln4093">/*</a>
<a name="ln4094"> * Check range in Ex command for validity.</a>
<a name="ln4095"> * Return NULL when valid, error message when invalid.</a>
<a name="ln4096"> */</a>
<a name="ln4097">static char_u *invalid_range(exarg_T *eap)</a>
<a name="ln4098">{</a>
<a name="ln4099">  buf_T *buf;</a>
<a name="ln4100">  if (eap-&gt;line1 &lt; 0 || eap-&gt;line2 &lt; 0 || eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln4101">    return (char_u *)_(e_invrange);</a>
<a name="ln4102">  }</a>
<a name="ln4103"> </a>
<a name="ln4104">  if (eap-&gt;argt &amp; EX_RANGE) {</a>
<a name="ln4105">    switch (eap-&gt;addr_type) {</a>
<a name="ln4106">      case ADDR_LINES:</a>
<a name="ln4107">        if (eap-&gt;line2 &gt; (curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln4108">                          + (eap-&gt;cmdidx == CMD_diffget))) {</a>
<a name="ln4109">          return (char_u *)_(e_invrange);</a>
<a name="ln4110">        }</a>
<a name="ln4111">        break;</a>
<a name="ln4112">      case ADDR_ARGUMENTS:</a>
<a name="ln4113">        // add 1 if ARGCOUNT is 0</a>
<a name="ln4114">        if (eap-&gt;line2 &gt; ARGCOUNT + (!ARGCOUNT)) {</a>
<a name="ln4115">          return (char_u *)_(e_invrange);</a>
<a name="ln4116">        }</a>
<a name="ln4117">        break;</a>
<a name="ln4118">      case ADDR_BUFFERS:</a>
<a name="ln4119">        if (eap-&gt;line1 &lt; firstbuf-&gt;b_fnum</a>
<a name="ln4120">            || eap-&gt;line2 &gt; lastbuf-&gt;b_fnum) {</a>
<a name="ln4121">          return (char_u *)_(e_invrange);</a>
<a name="ln4122">        }</a>
<a name="ln4123">        break;</a>
<a name="ln4124">     case ADDR_LOADED_BUFFERS:</a>
<a name="ln4125">        buf = firstbuf;</a>
<a name="ln4126">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln4127">          if (buf-&gt;b_next == NULL) {</a>
<a name="ln4128">            return (char_u *)_(e_invrange);</a>
<a name="ln4129">          }</a>
<a name="ln4130">          buf = buf-&gt;b_next;</a>
<a name="ln4131">        }</a>
<a name="ln4132">        if (eap-&gt;line1 &lt; buf-&gt;b_fnum) {</a>
<a name="ln4133">          return (char_u *)_(e_invrange);</a>
<a name="ln4134">        }</a>
<a name="ln4135">        buf = lastbuf;</a>
<a name="ln4136">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln4137">          if (buf-&gt;b_prev == NULL) {</a>
<a name="ln4138">            return (char_u *)_(e_invrange);</a>
<a name="ln4139">          }</a>
<a name="ln4140">          buf = buf-&gt;b_prev;</a>
<a name="ln4141">        }</a>
<a name="ln4142">        if (eap-&gt;line2 &gt; buf-&gt;b_fnum) {</a>
<a name="ln4143">          return (char_u *)_(e_invrange);</a>
<a name="ln4144">        }</a>
<a name="ln4145">        break;</a>
<a name="ln4146">      case ADDR_WINDOWS:</a>
<a name="ln4147">        if (eap-&gt;line2 &gt; LAST_WIN_NR) {</a>
<a name="ln4148">          return (char_u *)_(e_invrange);</a>
<a name="ln4149">        }</a>
<a name="ln4150">        break;</a>
<a name="ln4151">      case ADDR_TABS:</a>
<a name="ln4152">        if (eap-&gt;line2 &gt; LAST_TAB_NR) {</a>
<a name="ln4153">          return (char_u *)_(e_invrange);</a>
<a name="ln4154">        }</a>
<a name="ln4155">        break;</a>
<a name="ln4156">      case ADDR_TABS_RELATIVE:</a>
<a name="ln4157">      case ADDR_OTHER:</a>
<a name="ln4158">        // Any range is OK.</a>
<a name="ln4159">        break;</a>
<a name="ln4160">      case ADDR_QUICKFIX:</a>
<a name="ln4161">        assert(eap-&gt;line2 &gt;= 0);</a>
<a name="ln4162">        // No error for value that is too big, will use the last entry.</a>
<a name="ln4163">        if (eap-&gt;line2 &lt;= 0) {</a>
<a name="ln4164">          return (char_u *)_(e_invrange);</a>
<a name="ln4165">        }</a>
<a name="ln4166">        break;</a>
<a name="ln4167">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln4168">        if ((eap-&gt;line2 != 1 &amp;&amp; (size_t)eap-&gt;line2 &gt; qf_get_valid_size(eap))</a>
<a name="ln4169">            || eap-&gt;line2 &lt; 0) {</a>
<a name="ln4170">          return (char_u *)_(e_invrange);</a>
<a name="ln4171">        }</a>
<a name="ln4172">        break;</a>
<a name="ln4173">      case ADDR_UNSIGNED:</a>
<a name="ln4174">        if (eap-&gt;line2 &lt; 0) {</a>
<a name="ln4175">          return (char_u *)_(e_invrange);</a>
<a name="ln4176">        }</a>
<a name="ln4177">        break;</a>
<a name="ln4178">      case ADDR_NONE:</a>
<a name="ln4179">        // Will give an error elsewhere.</a>
<a name="ln4180">        break;</a>
<a name="ln4181">    }</a>
<a name="ln4182">  }</a>
<a name="ln4183">  return NULL;</a>
<a name="ln4184">}</a>
<a name="ln4185"> </a>
<a name="ln4186">/*</a>
<a name="ln4187"> * Correct the range for zero line number, if required.</a>
<a name="ln4188"> */</a>
<a name="ln4189">static void correct_range(exarg_T *eap)</a>
<a name="ln4190">{</a>
<a name="ln4191">  if (!(eap-&gt;argt &amp; EX_ZEROR)) {  // zero in range not allowed</a>
<a name="ln4192">    if (eap-&gt;line1 == 0) {</a>
<a name="ln4193">      eap-&gt;line1 = 1;</a>
<a name="ln4194">    }</a>
<a name="ln4195">    if (eap-&gt;line2 == 0) {</a>
<a name="ln4196">      eap-&gt;line2 = 1;</a>
<a name="ln4197">    }</a>
<a name="ln4198">  }</a>
<a name="ln4199">}</a>
<a name="ln4200"> </a>
<a name="ln4201"> </a>
<a name="ln4202">/*</a>
<a name="ln4203"> * For a &quot;:vimgrep&quot; or &quot;:vimgrepadd&quot; command return a pointer past the</a>
<a name="ln4204"> * pattern.  Otherwise return eap-&gt;arg.</a>
<a name="ln4205"> */</a>
<a name="ln4206">static char_u *skip_grep_pat(exarg_T *eap)</a>
<a name="ln4207">{</a>
<a name="ln4208">  char_u      *p = eap-&gt;arg;</a>
<a name="ln4209"> </a>
<a name="ln4210">  if (*p != NUL &amp;&amp; (eap-&gt;cmdidx == CMD_vimgrep || eap-&gt;cmdidx == CMD_lvimgrep</a>
<a name="ln4211">                    || eap-&gt;cmdidx == CMD_vimgrepadd</a>
<a name="ln4212">                    || eap-&gt;cmdidx == CMD_lvimgrepadd</a>
<a name="ln4213">                    || grep_internal(eap-&gt;cmdidx))) {</a>
<a name="ln4214">    p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln4215">    if (p == NULL)</a>
<a name="ln4216">      p = eap-&gt;arg;</a>
<a name="ln4217">  }</a>
<a name="ln4218">  return p;</a>
<a name="ln4219">}</a>
<a name="ln4220"> </a>
<a name="ln4221">/*</a>
<a name="ln4222"> * For the &quot;:make&quot; and &quot;:grep&quot; commands insert the 'makeprg'/'grepprg' option</a>
<a name="ln4223"> * in the command line, so that things like % get expanded.</a>
<a name="ln4224"> */</a>
<a name="ln4225">static char_u *replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)</a>
<a name="ln4226">{</a>
<a name="ln4227">  char_u      *new_cmdline;</a>
<a name="ln4228">  char_u      *program;</a>
<a name="ln4229">  char_u      *pos;</a>
<a name="ln4230">  char_u      *ptr;</a>
<a name="ln4231">  int len;</a>
<a name="ln4232">  int i;</a>
<a name="ln4233"> </a>
<a name="ln4234">  /*</a>
<a name="ln4235">   * Don't do it when &quot;:vimgrep&quot; is used for &quot;:grep&quot;.</a>
<a name="ln4236">   */</a>
<a name="ln4237">  if ((eap-&gt;cmdidx == CMD_make || eap-&gt;cmdidx == CMD_lmake</a>
<a name="ln4238">       || eap-&gt;cmdidx == CMD_grep || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln4239">       || eap-&gt;cmdidx == CMD_grepadd</a>
<a name="ln4240">       || eap-&gt;cmdidx == CMD_lgrepadd)</a>
<a name="ln4241">      &amp;&amp; !grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln4242">    if (eap-&gt;cmdidx == CMD_grep || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln4243">        || eap-&gt;cmdidx == CMD_grepadd || eap-&gt;cmdidx == CMD_lgrepadd) {</a>
<a name="ln4244">      if (*curbuf-&gt;b_p_gp == NUL)</a>
<a name="ln4245">        program = p_gp;</a>
<a name="ln4246">      else</a>
<a name="ln4247">        program = curbuf-&gt;b_p_gp;</a>
<a name="ln4248">    } else {</a>
<a name="ln4249">      if (*curbuf-&gt;b_p_mp == NUL)</a>
<a name="ln4250">        program = p_mp;</a>
<a name="ln4251">      else</a>
<a name="ln4252">        program = curbuf-&gt;b_p_mp;</a>
<a name="ln4253">    }</a>
<a name="ln4254"> </a>
<a name="ln4255">    p = skipwhite(p);</a>
<a name="ln4256"> </a>
<a name="ln4257">    if ((pos = (char_u *)strstr((char *)program, &quot;$*&quot;)) != NULL) {</a>
<a name="ln4258">      /* replace $* by given arguments */</a>
<a name="ln4259">      i = 1;</a>
<a name="ln4260">      while ((pos = (char_u *)strstr((char *)pos + 2, &quot;$*&quot;)) != NULL)</a>
<a name="ln4261">        ++i;</a>
<a name="ln4262">      len = (int)STRLEN(p);</a>
<a name="ln4263">      new_cmdline = xmalloc(STRLEN(program) + i * (len - 2) + 1);</a>
<a name="ln4264">      ptr = new_cmdline;</a>
<a name="ln4265">      while ((pos = (char_u *)strstr((char *)program, &quot;$*&quot;)) != NULL) {</a>
<a name="ln4266">        i = (int)(pos - program);</a>
<a name="ln4267">        memcpy(ptr, program, i);</a>
<a name="ln4268">        STRCPY(ptr += i, p);</a>
<a name="ln4269">        ptr += len;</a>
<a name="ln4270">        program = pos + 2;</a>
<a name="ln4271">      }</a>
<a name="ln4272">      STRCPY(ptr, program);</a>
<a name="ln4273">    } else {</a>
<a name="ln4274">      new_cmdline = xmalloc(STRLEN(program) + STRLEN(p) + 2);</a>
<a name="ln4275">      STRCPY(new_cmdline, program);</a>
<a name="ln4276">      STRCAT(new_cmdline, &quot; &quot;);</a>
<a name="ln4277">      STRCAT(new_cmdline, p);</a>
<a name="ln4278">    }</a>
<a name="ln4279">    msg_make(p);</a>
<a name="ln4280"> </a>
<a name="ln4281">    /* 'eap-&gt;cmd' is not set here, because it is not used at CMD_make */</a>
<a name="ln4282">    xfree(*cmdlinep);</a>
<a name="ln4283">    *cmdlinep = new_cmdline;</a>
<a name="ln4284">    p = new_cmdline;</a>
<a name="ln4285">  }</a>
<a name="ln4286">  return p;</a>
<a name="ln4287">}</a>
<a name="ln4288"> </a>
<a name="ln4289">// Expand file name in Ex command argument.</a>
<a name="ln4290">// When an error is detected, &quot;errormsgp&quot; is set to a non-NULL pointer.</a>
<a name="ln4291">// Return FAIL for failure, OK otherwise.</a>
<a name="ln4292">int expand_filename(exarg_T *eap, char_u **cmdlinep, char_u **errormsgp)</a>
<a name="ln4293">{</a>
<a name="ln4294">  int has_wildcards;            /* need to expand wildcards */</a>
<a name="ln4295">  char_u      *repl;</a>
<a name="ln4296">  size_t srclen;</a>
<a name="ln4297">  char_u      *p;</a>
<a name="ln4298">  int escaped;</a>
<a name="ln4299"> </a>
<a name="ln4300">  /* Skip a regexp pattern for &quot;:vimgrep[add] pat file...&quot; */</a>
<a name="ln4301">  p = skip_grep_pat(eap);</a>
<a name="ln4302"> </a>
<a name="ln4303">  /*</a>
<a name="ln4304">   * Decide to expand wildcards *before* replacing '%', '#', etc.  If</a>
<a name="ln4305">   * the file name contains a wildcard it should not cause expanding.</a>
<a name="ln4306">   * (it will be expanded anyway if there is a wildcard before replacing).</a>
<a name="ln4307">   */</a>
<a name="ln4308">  has_wildcards = path_has_wildcard(p);</a>
<a name="ln4309">  while (*p != NUL) {</a>
<a name="ln4310">    /* Skip over `=expr`, wildcards in it are not expanded. */</a>
<a name="ln4311">    if (p[0] == '`' &amp;&amp; p[1] == '=') {</a>
<a name="ln4312">      p += 2;</a>
<a name="ln4313">      (void)skip_expr(&amp;p);</a>
<a name="ln4314">      if (*p == '`')</a>
<a name="ln4315">        ++p;</a>
<a name="ln4316">      continue;</a>
<a name="ln4317">    }</a>
<a name="ln4318">    /*</a>
<a name="ln4319">     * Quick check if this cannot be the start of a special string.</a>
<a name="ln4320">     * Also removes backslash before '%', '#' and '&lt;'.</a>
<a name="ln4321">     */</a>
<a name="ln4322">    if (vim_strchr((char_u *)&quot;%#&lt;&quot;, *p) == NULL) {</a>
<a name="ln4323">      ++p;</a>
<a name="ln4324">      continue;</a>
<a name="ln4325">    }</a>
<a name="ln4326"> </a>
<a name="ln4327">    /*</a>
<a name="ln4328">     * Try to find a match at this position.</a>
<a name="ln4329">     */</a>
<a name="ln4330">    repl = eval_vars(p, eap-&gt;arg, &amp;srclen, &amp;(eap-&gt;do_ecmd_lnum),</a>
<a name="ln4331">        errormsgp, &amp;escaped);</a>
<a name="ln4332">    if (*errormsgp != NULL)             /* error detected */</a>
<a name="ln4333">      return FAIL;</a>
<a name="ln4334">    if (repl == NULL) {                 /* no match found */</a>
<a name="ln4335">      p += srclen;</a>
<a name="ln4336">      continue;</a>
<a name="ln4337">    }</a>
<a name="ln4338"> </a>
<a name="ln4339">    /* Wildcards won't be expanded below, the replacement is taken</a>
<a name="ln4340">     * literally.  But do expand &quot;~/file&quot;, &quot;~user/file&quot; and &quot;$HOME/file&quot;. */</a>
<a name="ln4341">    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {</a>
<a name="ln4342">      char_u *l = repl;</a>
<a name="ln4343"> </a>
<a name="ln4344">      repl = expand_env_save(repl);</a>
<a name="ln4345">      xfree(l);</a>
<a name="ln4346">    }</a>
<a name="ln4347"> </a>
<a name="ln4348">    /* Need to escape white space et al. with a backslash.</a>
<a name="ln4349">     * Don't do this for:</a>
<a name="ln4350">     * - replacement that already has been escaped: &quot;##&quot;</a>
<a name="ln4351">     * - shell commands (may have to use quotes instead).</a>
<a name="ln4352">     */</a>
<a name="ln4353">    if (!eap-&gt;usefilter</a>
<a name="ln4354">        &amp;&amp; !escaped</a>
<a name="ln4355">        &amp;&amp; eap-&gt;cmdidx != CMD_bang</a>
<a name="ln4356">        &amp;&amp; eap-&gt;cmdidx != CMD_grep</a>
<a name="ln4357">        &amp;&amp; eap-&gt;cmdidx != CMD_grepadd</a>
<a name="ln4358">        &amp;&amp; eap-&gt;cmdidx != CMD_hardcopy</a>
<a name="ln4359">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrep</a>
<a name="ln4360">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln4361">        &amp;&amp; eap-&gt;cmdidx != CMD_lmake</a>
<a name="ln4362">        &amp;&amp; eap-&gt;cmdidx != CMD_make</a>
<a name="ln4363">        &amp;&amp; eap-&gt;cmdidx != CMD_terminal</a>
<a name="ln4364">        &amp;&amp; !(eap-&gt;argt &amp; EX_NOSPC)</a>
<a name="ln4365">        ) {</a>
<a name="ln4366">      char_u      *l;</a>
<a name="ln4367">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4368">      /* Don't escape a backslash here, because rem_backslash() doesn't</a>
<a name="ln4369">       * remove it later. */</a>
<a name="ln4370">      static char_u *nobslash = (char_u *)&quot; \t\&quot;|&quot;;</a>
<a name="ln4371"># define ESCAPE_CHARS nobslash</a>
<a name="ln4372">#else</a>
<a name="ln4373"># define ESCAPE_CHARS escape_chars</a>
<a name="ln4374">#endif</a>
<a name="ln4375"> </a>
<a name="ln4376">      for (l = repl; *l; ++l)</a>
<a name="ln4377">        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {</a>
<a name="ln4378">          l = vim_strsave_escaped(repl, ESCAPE_CHARS);</a>
<a name="ln4379">          xfree(repl);</a>
<a name="ln4380">          repl = l;</a>
<a name="ln4381">          break;</a>
<a name="ln4382">        }</a>
<a name="ln4383">    }</a>
<a name="ln4384"> </a>
<a name="ln4385">    // For a shell command a '!' must be escaped.</a>
<a name="ln4386">    if ((eap-&gt;usefilter</a>
<a name="ln4387">         || eap-&gt;cmdidx == CMD_bang</a>
<a name="ln4388">         || eap-&gt;cmdidx == CMD_terminal)</a>
<a name="ln4389">        &amp;&amp; vim_strpbrk(repl, (char_u *)&quot;!&quot;) != NULL) {</a>
<a name="ln4390">      char_u      *l;</a>
<a name="ln4391"> </a>
<a name="ln4392">      l = vim_strsave_escaped(repl, (char_u *)&quot;!&quot;);</a>
<a name="ln4393">      xfree(repl);</a>
<a name="ln4394">      repl = l;</a>
<a name="ln4395">    }</a>
<a name="ln4396"> </a>
<a name="ln4397">    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);</a>
<a name="ln4398">    xfree(repl);</a>
<a name="ln4399">  }</a>
<a name="ln4400"> </a>
<a name="ln4401">  /*</a>
<a name="ln4402">   * One file argument: Expand wildcards.</a>
<a name="ln4403">   * Don't do this with &quot;:r !command&quot; or &quot;:w !command&quot;.</a>
<a name="ln4404">   */</a>
<a name="ln4405">  if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; !eap-&gt;usefilter) {</a>
<a name="ln4406">    // Replace environment variables.</a>
<a name="ln4407">    if (has_wildcards) {</a>
<a name="ln4408">      /*</a>
<a name="ln4409">       * May expand environment variables.  This</a>
<a name="ln4410">       * can be done much faster with expand_env() than with</a>
<a name="ln4411">       * something else (e.g., calling a shell).</a>
<a name="ln4412">       * After expanding environment variables, check again</a>
<a name="ln4413">       * if there are still wildcards present.</a>
<a name="ln4414">       */</a>
<a name="ln4415">      if (vim_strchr(eap-&gt;arg, '$') != NULL</a>
<a name="ln4416">          || vim_strchr(eap-&gt;arg, '~') != NULL) {</a>
<a name="ln4417">        expand_env_esc(eap-&gt;arg, NameBuff, MAXPATHL,</a>
<a name="ln4418">            TRUE, TRUE, NULL);</a>
<a name="ln4419">        has_wildcards = path_has_wildcard(NameBuff);</a>
<a name="ln4420">        p = NameBuff;</a>
<a name="ln4421">      } else</a>
<a name="ln4422">        p = NULL;</a>
<a name="ln4423">      if (p != NULL) {</a>
<a name="ln4424">        (void)repl_cmdline(eap, eap-&gt;arg, STRLEN(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln4425">      }</a>
<a name="ln4426">    }</a>
<a name="ln4427"> </a>
<a name="ln4428">    /*</a>
<a name="ln4429">     * Halve the number of backslashes (this is Vi compatible).</a>
<a name="ln4430">     * For Unix, when wildcards are expanded, this is</a>
<a name="ln4431">     * done by ExpandOne() below.</a>
<a name="ln4432">     */</a>
<a name="ln4433">#ifdef UNIX</a>
<a name="ln4434">    if (!has_wildcards)</a>
<a name="ln4435">#endif</a>
<a name="ln4436">    backslash_halve(eap-&gt;arg);</a>
<a name="ln4437"> </a>
<a name="ln4438">    if (has_wildcards) {</a>
<a name="ln4439">      expand_T xpc;</a>
<a name="ln4440">      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;</a>
<a name="ln4441"> </a>
<a name="ln4442">      ExpandInit(&amp;xpc);</a>
<a name="ln4443">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln4444">      if (p_wic)</a>
<a name="ln4445">        options += WILD_ICASE;</a>
<a name="ln4446">      p = ExpandOne(&amp;xpc, eap-&gt;arg, NULL, options, WILD_EXPAND_FREE);</a>
<a name="ln4447">      if (p == NULL) {</a>
<a name="ln4448">        return FAIL;</a>
<a name="ln4449">      }</a>
<a name="ln4450">      (void)repl_cmdline(eap, eap-&gt;arg, STRLEN(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln4451">      xfree(p);</a>
<a name="ln4452">    }</a>
<a name="ln4453">  }</a>
<a name="ln4454">  return OK;</a>
<a name="ln4455">}</a>
<a name="ln4456"> </a>
<a name="ln4457">/*</a>
<a name="ln4458"> * Replace part of the command line, keeping eap-&gt;cmd, eap-&gt;arg and</a>
<a name="ln4459"> * eap-&gt;nextcmd correct.</a>
<a name="ln4460"> * &quot;src&quot; points to the part that is to be replaced, of length &quot;srclen&quot;.</a>
<a name="ln4461"> * &quot;repl&quot; is the replacement string.</a>
<a name="ln4462"> * Returns a pointer to the character after the replaced string.</a>
<a name="ln4463"> */</a>
<a name="ln4464">static char_u *repl_cmdline(exarg_T *eap, char_u *src, size_t srclen,</a>
<a name="ln4465">                            char_u *repl, char_u **cmdlinep)</a>
<a name="ln4466">{</a>
<a name="ln4467">  /*</a>
<a name="ln4468">   * The new command line is build in new_cmdline[].</a>
<a name="ln4469">   * First allocate it.</a>
<a name="ln4470">   * Careful: a &quot;+cmd&quot; argument may have been NUL terminated.</a>
<a name="ln4471">   */</a>
<a name="ln4472">  size_t len = STRLEN(repl);</a>
<a name="ln4473">  size_t i = (size_t)(src - *cmdlinep) + STRLEN(src + srclen) + len + 3;</a>
<a name="ln4474">  if (eap-&gt;nextcmd != NULL)</a>
<a name="ln4475">    i += STRLEN(eap-&gt;nextcmd);    /* add space for next command */</a>
<a name="ln4476">  char_u *new_cmdline = xmalloc(i);</a>
<a name="ln4477"> </a>
<a name="ln4478">  /*</a>
<a name="ln4479">   * Copy the stuff before the expanded part.</a>
<a name="ln4480">   * Copy the expanded stuff.</a>
<a name="ln4481">   * Copy what came after the expanded part.</a>
<a name="ln4482">   * Copy the next commands, if there are any.</a>
<a name="ln4483">   */</a>
<a name="ln4484">  i = (size_t)(src - *cmdlinep);   /* length of part before match */</a>
<a name="ln4485">  memmove(new_cmdline, *cmdlinep, i);</a>
<a name="ln4486"> </a>
<a name="ln4487">  memmove(new_cmdline + i, repl, len);</a>
<a name="ln4488">  i += len;                             /* remember the end of the string */</a>
<a name="ln4489">  STRCPY(new_cmdline + i, src + srclen);</a>
<a name="ln4490">  src = new_cmdline + i;                /* remember where to continue */</a>
<a name="ln4491"> </a>
<a name="ln4492">  if (eap-&gt;nextcmd != NULL) {           /* append next command */</a>
<a name="ln4493">    i = STRLEN(new_cmdline) + 1;</a>
<a name="ln4494">    STRCPY(new_cmdline + i, eap-&gt;nextcmd);</a>
<a name="ln4495">    eap-&gt;nextcmd = new_cmdline + i;</a>
<a name="ln4496">  }</a>
<a name="ln4497">  eap-&gt;cmd = new_cmdline + (eap-&gt;cmd - *cmdlinep);</a>
<a name="ln4498">  eap-&gt;arg = new_cmdline + (eap-&gt;arg - *cmdlinep);</a>
<a name="ln4499">  if (eap-&gt;do_ecmd_cmd != NULL &amp;&amp; eap-&gt;do_ecmd_cmd != dollar_command)</a>
<a name="ln4500">    eap-&gt;do_ecmd_cmd = new_cmdline + (eap-&gt;do_ecmd_cmd - *cmdlinep);</a>
<a name="ln4501">  xfree(*cmdlinep);</a>
<a name="ln4502">  *cmdlinep = new_cmdline;</a>
<a name="ln4503"> </a>
<a name="ln4504">  return src;</a>
<a name="ln4505">}</a>
<a name="ln4506"> </a>
<a name="ln4507">/*</a>
<a name="ln4508"> * Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln4509"> */</a>
<a name="ln4510">void separate_nextcmd(exarg_T *eap)</a>
<a name="ln4511">{</a>
<a name="ln4512">  char_u      *p;</a>
<a name="ln4513"> </a>
<a name="ln4514">  p = skip_grep_pat(eap);</a>
<a name="ln4515"> </a>
<a name="ln4516">  for (; *p; MB_PTR_ADV(p)) {</a>
<a name="ln4517">    if (*p == Ctrl_V) {</a>
<a name="ln4518">      if (eap-&gt;argt &amp; (EX_CTRLV | EX_XFILE)) {</a>
<a name="ln4519">        p++;  // skip CTRL-V and next char</a>
<a name="ln4520">      } else {</a>
<a name="ln4521">        // remove CTRL-V and skip next char</a>
<a name="ln4522">        STRMOVE(p, p + 1);</a>
<a name="ln4523">      }</a>
<a name="ln4524">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4525">        break;</a>
<a name="ln4526">      }</a>
<a name="ln4527">    } else if (p[0] == '`' &amp;&amp; p[1] == '=' &amp;&amp; (eap-&gt;argt &amp; EX_XFILE)) {</a>
<a name="ln4528">      // Skip over `=expr` when wildcards are expanded.</a>
<a name="ln4529">      p += 2;</a>
<a name="ln4530">      (void)skip_expr(&amp;p);</a>
<a name="ln4531">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4532">        break;</a>
<a name="ln4533">      }</a>
<a name="ln4534">    } else if (</a>
<a name="ln4535">        // Check for '&quot;': start of comment or '|': next command */</a>
<a name="ln4536">        // :@&quot; does not start a comment!</a>
<a name="ln4537">        // :redir @&quot; doesn't either.</a>
<a name="ln4538">        (*p == '&quot;'</a>
<a name="ln4539">         &amp;&amp; !(eap-&gt;argt &amp; EX_NOTRLCOM)</a>
<a name="ln4540">         &amp;&amp; (eap-&gt;cmdidx != CMD_at || p != eap-&gt;arg)</a>
<a name="ln4541">         &amp;&amp; (eap-&gt;cmdidx != CMD_redir</a>
<a name="ln4542">             || p != eap-&gt;arg + 1 || p[-1] != '@'))</a>
<a name="ln4543">        || *p == '|'</a>
<a name="ln4544">        || *p == '\n') {</a>
<a name="ln4545">      // We remove the '\' before the '|', unless EX_CTRLV is used</a>
<a name="ln4546">      // AND 'b' is present in 'cpoptions'.</a>
<a name="ln4547">      if ((vim_strchr(p_cpo, CPO_BAR) == NULL</a>
<a name="ln4548">           || !(eap-&gt;argt &amp; EX_CTRLV)) &amp;&amp; *(p - 1) == '\\') {</a>
<a name="ln4549">        STRMOVE(p - 1, p);  // remove the '\'</a>
<a name="ln4550">        p--;</a>
<a name="ln4551">      } else {</a>
<a name="ln4552">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln4553">        *p = NUL;</a>
<a name="ln4554">        break;</a>
<a name="ln4555">      }</a>
<a name="ln4556">    }</a>
<a name="ln4557">  }</a>
<a name="ln4558"> </a>
<a name="ln4559">  if (!(eap-&gt;argt &amp; EX_NOTRLCOM)) {  // remove trailing spaces</a>
<a name="ln4560">    del_trailing_spaces(eap-&gt;arg);</a>
<a name="ln4561">  }</a>
<a name="ln4562">}</a>
<a name="ln4563"> </a>
<a name="ln4564">/*</a>
<a name="ln4565"> * get + command from ex argument</a>
<a name="ln4566"> */</a>
<a name="ln4567">static char_u *getargcmd(char_u **argp)</a>
<a name="ln4568">{</a>
<a name="ln4569">  char_u *arg = *argp;</a>
<a name="ln4570">  char_u *command = NULL;</a>
<a name="ln4571"> </a>
<a name="ln4572">  if (*arg == '+') {        /* +[command] */</a>
<a name="ln4573">    ++arg;</a>
<a name="ln4574">    if (ascii_isspace(*arg) || *arg == '\0')</a>
<a name="ln4575">      command = dollar_command;</a>
<a name="ln4576">    else {</a>
<a name="ln4577">      command = arg;</a>
<a name="ln4578">      arg = skip_cmd_arg(command, TRUE);</a>
<a name="ln4579">      if (*arg != NUL)</a>
<a name="ln4580">        *arg++ = NUL;                   /* terminate command with NUL */</a>
<a name="ln4581">    }</a>
<a name="ln4582"> </a>
<a name="ln4583">    arg = skipwhite(arg);       /* skip over spaces */</a>
<a name="ln4584">    *argp = arg;</a>
<a name="ln4585">  }</a>
<a name="ln4586">  return command;</a>
<a name="ln4587">}</a>
<a name="ln4588"> </a>
<a name="ln4589">/*</a>
<a name="ln4590"> * Find end of &quot;+command&quot; argument.  Skip over &quot;\ &quot; and &quot;\\&quot;.</a>
<a name="ln4591"> */</a>
<a name="ln4592">static char_u *</a>
<a name="ln4593">skip_cmd_arg (</a>
<a name="ln4594">    char_u *p,</a>
<a name="ln4595">    int rembs              /* TRUE to halve the number of backslashes */</a>
<a name="ln4596">)</a>
<a name="ln4597">{</a>
<a name="ln4598">  while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln4599">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4600">      if (rembs)</a>
<a name="ln4601">        STRMOVE(p, p + 1);</a>
<a name="ln4602">      else</a>
<a name="ln4603">        ++p;</a>
<a name="ln4604">    }</a>
<a name="ln4605">    MB_PTR_ADV(p);</a>
<a name="ln4606">  }</a>
<a name="ln4607">  return p;</a>
<a name="ln4608">}</a>
<a name="ln4609"> </a>
<a name="ln4610">int get_bad_opt(const char_u *p, exarg_T *eap)</a>
<a name="ln4611">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4612">{</a>
<a name="ln4613">  if (STRICMP(p, &quot;keep&quot;) == 0) {</a>
<a name="ln4614">    eap-&gt;bad_char = BAD_KEEP;</a>
<a name="ln4615">  } else if (STRICMP(p, &quot;drop&quot;) == 0) {</a>
<a name="ln4616">    eap-&gt;bad_char = BAD_DROP;</a>
<a name="ln4617">  } else if (MB_BYTE2LEN(*p) == 1 &amp;&amp; p[1] == NUL) {</a>
<a name="ln4618">    eap-&gt;bad_char = *p;</a>
<a name="ln4619">  } else {</a>
<a name="ln4620">    return FAIL;</a>
<a name="ln4621">  }</a>
<a name="ln4622">  return OK;</a>
<a name="ln4623">}</a>
<a name="ln4624"> </a>
<a name="ln4625">/*</a>
<a name="ln4626"> * Get &quot;++opt=arg&quot; argument.</a>
<a name="ln4627"> * Return FAIL or OK.</a>
<a name="ln4628"> */</a>
<a name="ln4629">static int getargopt(exarg_T *eap)</a>
<a name="ln4630">{</a>
<a name="ln4631">  char_u      *arg = eap-&gt;arg + 2;</a>
<a name="ln4632">  int         *pp = NULL;</a>
<a name="ln4633">  int bad_char_idx;</a>
<a name="ln4634">  char_u      *p;</a>
<a name="ln4635"> </a>
<a name="ln4636">  /* &quot;:edit ++[no]bin[ary] file&quot; */</a>
<a name="ln4637">  if (STRNCMP(arg, &quot;bin&quot;, 3) == 0 || STRNCMP(arg, &quot;nobin&quot;, 5) == 0) {</a>
<a name="ln4638">    if (*arg == 'n') {</a>
<a name="ln4639">      arg += 2;</a>
<a name="ln4640">      eap-&gt;force_bin = FORCE_NOBIN;</a>
<a name="ln4641">    } else</a>
<a name="ln4642">      eap-&gt;force_bin = FORCE_BIN;</a>
<a name="ln4643">    if (!checkforcmd(&amp;arg, &quot;binary&quot;, 3))</a>
<a name="ln4644">      return FAIL;</a>
<a name="ln4645">    eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4646">    return OK;</a>
<a name="ln4647">  }</a>
<a name="ln4648"> </a>
<a name="ln4649">  /* &quot;:read ++edit file&quot; */</a>
<a name="ln4650">  if (STRNCMP(arg, &quot;edit&quot;, 4) == 0) {</a>
<a name="ln4651">    eap-&gt;read_edit = TRUE;</a>
<a name="ln4652">    eap-&gt;arg = skipwhite(arg + 4);</a>
<a name="ln4653">    return OK;</a>
<a name="ln4654">  }</a>
<a name="ln4655"> </a>
<a name="ln4656">  if (STRNCMP(arg, &quot;ff&quot;, 2) == 0) {</a>
<a name="ln4657">    arg += 2;</a>
<a name="ln4658">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4659">  } else if (STRNCMP(arg, &quot;fileformat&quot;, 10) == 0) {</a>
<a name="ln4660">    arg += 10;</a>
<a name="ln4661">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4662">  } else if (STRNCMP(arg, &quot;enc&quot;, 3) == 0) {</a>
<a name="ln4663">    if (STRNCMP(arg, &quot;encoding&quot;, 8) == 0)</a>
<a name="ln4664">      arg += 8;</a>
<a name="ln4665">    else</a>
<a name="ln4666">      arg += 3;</a>
<a name="ln4667">    pp = &amp;eap-&gt;force_enc;</a>
<a name="ln4668">  } else if (STRNCMP(arg, &quot;bad&quot;, 3) == 0) {</a>
<a name="ln4669">    arg += 3;</a>
<a name="ln4670">    pp = &amp;bad_char_idx;</a>
<a name="ln4671">  }</a>
<a name="ln4672"> </a>
<a name="ln4673">  if (pp == NULL || *arg != '=')</a>
<a name="ln4674">    return FAIL;</a>
<a name="ln4675"> </a>
<a name="ln4676">  ++arg;</a>
<a name="ln4677">  *pp = (int)(arg - eap-&gt;cmd);</a>
<a name="ln4678">  arg = skip_cmd_arg(arg, FALSE);</a>
<a name="ln4679">  eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4680">  *arg = NUL;</a>
<a name="ln4681"> </a>
<a name="ln4682">  if (pp == &amp;eap-&gt;force_ff) {</a>
<a name="ln4683">    if (check_ff_value(eap-&gt;cmd + eap-&gt;force_ff) == FAIL) {</a>
<a name="ln4684">      return FAIL;</a>
<a name="ln4685">    }</a>
<a name="ln4686">    eap-&gt;force_ff = eap-&gt;cmd[eap-&gt;force_ff];</a>
<a name="ln4687">  } else if (pp == &amp;eap-&gt;force_enc) {</a>
<a name="ln4688">    /* Make 'fileencoding' lower case. */</a>
<a name="ln4689">    for (p = eap-&gt;cmd + eap-&gt;force_enc; *p != NUL; ++p)</a>
<a name="ln4690">      *p = TOLOWER_ASC(*p);</a>
<a name="ln4691">  } else {</a>
<a name="ln4692">    /* Check ++bad= argument.  Must be a single-byte character, &quot;keep&quot; or</a>
<a name="ln4693">     * &quot;drop&quot;. */</a>
<a name="ln4694">    if (get_bad_opt(eap-&gt;cmd + bad_char_idx, eap) == FAIL) {</a>
<a name="ln4695">      return FAIL;</a>
<a name="ln4696">    }</a>
<a name="ln4697">  }</a>
<a name="ln4698"> </a>
<a name="ln4699">  return OK;</a>
<a name="ln4700">}</a>
<a name="ln4701"> </a>
<a name="ln4702">/// Handle the argument for a tabpage related ex command.</a>
<a name="ln4703">/// Returns a tabpage number.</a>
<a name="ln4704">/// When an error is encountered then eap-&gt;errmsg is set.</a>
<a name="ln4705">static int get_tabpage_arg(exarg_T *eap)</a>
<a name="ln4706">{</a>
<a name="ln4707">  int tab_number = 0;</a>
<a name="ln4708">  int unaccept_arg0 = (eap-&gt;cmdidx == CMD_tabmove) ? 0 : 1;</a>
<a name="ln4709"> </a>
<a name="ln4710">  if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln4711">    char_u *p = eap-&gt;arg;</a>
<a name="ln4712">    char_u *p_save;</a>
<a name="ln4713">    int relative = 0; // argument +N/-N means: go to N places to the</a>
<a name="ln4714">                      // right/left relative to the current position.</a>
<a name="ln4715"> </a>
<a name="ln4716">    if (*p == '-') {</a>
<a name="ln4717">      relative = -1;</a>
<a name="ln4718">      p++;</a>
<a name="ln4719">    } else if (*p == '+') {</a>
<a name="ln4720">      relative = 1;</a>
<a name="ln4721">      p++;</a>
<a name="ln4722">    }</a>
<a name="ln4723"> </a>
<a name="ln4724">    p_save = p;</a>
<a name="ln4725">    tab_number = getdigits(&amp;p, false, tab_number);</a>
<a name="ln4726"> </a>
<a name="ln4727">    if (relative == 0) {</a>
<a name="ln4728">      if (STRCMP(p, &quot;$&quot;) == 0) {</a>
<a name="ln4729">        tab_number = LAST_TAB_NR;</a>
<a name="ln4730">      } else if (STRCMP(p, &quot;#&quot;) == 0) {</a>
<a name="ln4731">        tab_number = tabpage_index(lastused_tabpage);</a>
<a name="ln4732">      } else if (p == p_save || *p_save == '-' || *p != NUL</a>
<a name="ln4733">                 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4734">        // No numbers as argument.</a>
<a name="ln4735">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln4736">        goto theend;</a>
<a name="ln4737">      }</a>
<a name="ln4738">    } else {</a>
<a name="ln4739">      if (*p_save == NUL) {</a>
<a name="ln4740">        tab_number = 1;</a>
<a name="ln4741">      }</a>
<a name="ln4742">      else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {</a>
<a name="ln4743">        // No numbers as argument.</a>
<a name="ln4744">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln4745">        goto theend;</a>
<a name="ln4746">      }</a>
<a name="ln4747">      tab_number = tab_number * relative + tabpage_index(curtab);</a>
<a name="ln4748">      if (!unaccept_arg0 &amp;&amp; relative == -1) {</a>
<a name="ln4749">        --tab_number;</a>
<a name="ln4750">      }</a>
<a name="ln4751">    }</a>
<a name="ln4752">    if (tab_number &lt; unaccept_arg0 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4753">      eap-&gt;errmsg = e_invarg;</a>
<a name="ln4754">    }</a>
<a name="ln4755">  } else if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4756">    if (unaccept_arg0 &amp;&amp; eap-&gt;line2 == 0) {</a>
<a name="ln4757">      eap-&gt;errmsg = e_invrange;</a>
<a name="ln4758">      tab_number = 0;</a>
<a name="ln4759">    } else {</a>
<a name="ln4760">      tab_number = eap-&gt;line2;</a>
<a name="ln4761">      if (!unaccept_arg0 &amp;&amp; *skipwhite(*eap-&gt;cmdlinep) == '-') {</a>
<a name="ln4762">        tab_number--;</a>
<a name="ln4763">        if (tab_number &lt; unaccept_arg0) {</a>
<a name="ln4764">          eap-&gt;errmsg = e_invarg;</a>
<a name="ln4765">        }</a>
<a name="ln4766">      }</a>
<a name="ln4767">    }</a>
<a name="ln4768">  } else {</a>
<a name="ln4769">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4770">    case CMD_tabnext:</a>
<a name="ln4771">      tab_number = tabpage_index(curtab) + 1;</a>
<a name="ln4772">      if (tab_number &gt; LAST_TAB_NR)</a>
<a name="ln4773">        tab_number = 1;</a>
<a name="ln4774">      break;</a>
<a name="ln4775">    case CMD_tabmove:</a>
<a name="ln4776">      tab_number = LAST_TAB_NR;</a>
<a name="ln4777">      break;</a>
<a name="ln4778">    default:</a>
<a name="ln4779">      tab_number = tabpage_index(curtab);</a>
<a name="ln4780">    }</a>
<a name="ln4781">  }</a>
<a name="ln4782"> </a>
<a name="ln4783">theend:</a>
<a name="ln4784">  return tab_number;</a>
<a name="ln4785">}</a>
<a name="ln4786"> </a>
<a name="ln4787">/*</a>
<a name="ln4788"> * &quot;:abbreviate&quot; and friends.</a>
<a name="ln4789"> */</a>
<a name="ln4790">static void ex_abbreviate(exarg_T *eap)</a>
<a name="ln4791">{</a>
<a name="ln4792">  do_exmap(eap, TRUE);          /* almost the same as mapping */</a>
<a name="ln4793">}</a>
<a name="ln4794"> </a>
<a name="ln4795">/*</a>
<a name="ln4796"> * &quot;:map&quot; and friends.</a>
<a name="ln4797"> */</a>
<a name="ln4798">static void ex_map(exarg_T *eap)</a>
<a name="ln4799">{</a>
<a name="ln4800">  /*</a>
<a name="ln4801">   * If we are sourcing .exrc or .vimrc in current directory we</a>
<a name="ln4802">   * print the mappings for security reasons.</a>
<a name="ln4803">   */</a>
<a name="ln4804">  if (secure) {</a>
<a name="ln4805">    secure = 2;</a>
<a name="ln4806">    msg_outtrans(eap-&gt;cmd);</a>
<a name="ln4807">    msg_putchar('\n');</a>
<a name="ln4808">  }</a>
<a name="ln4809">  do_exmap(eap, FALSE);</a>
<a name="ln4810">}</a>
<a name="ln4811"> </a>
<a name="ln4812">/*</a>
<a name="ln4813"> * &quot;:unmap&quot; and friends.</a>
<a name="ln4814"> */</a>
<a name="ln4815">static void ex_unmap(exarg_T *eap)</a>
<a name="ln4816">{</a>
<a name="ln4817">  do_exmap(eap, FALSE);</a>
<a name="ln4818">}</a>
<a name="ln4819"> </a>
<a name="ln4820">/*</a>
<a name="ln4821"> * &quot;:mapclear&quot; and friends.</a>
<a name="ln4822"> */</a>
<a name="ln4823">static void ex_mapclear(exarg_T *eap)</a>
<a name="ln4824">{</a>
<a name="ln4825">  map_clear_mode(eap-&gt;cmd, eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln4826">}</a>
<a name="ln4827"> </a>
<a name="ln4828">/*</a>
<a name="ln4829"> * &quot;:abclear&quot; and friends.</a>
<a name="ln4830"> */</a>
<a name="ln4831">static void ex_abclear(exarg_T *eap)</a>
<a name="ln4832">{</a>
<a name="ln4833">  map_clear_mode(eap-&gt;cmd, eap-&gt;arg, true, true);</a>
<a name="ln4834">}</a>
<a name="ln4835"> </a>
<a name="ln4836">static void ex_autocmd(exarg_T *eap)</a>
<a name="ln4837">{</a>
<a name="ln4838">  // Disallow autocommands from .exrc and .vimrc in current</a>
<a name="ln4839">  // directory for security reasons.</a>
<a name="ln4840">  if (secure) {</a>
<a name="ln4841">    secure = 2;</a>
<a name="ln4842">    eap-&gt;errmsg = e_curdir;</a>
<a name="ln4843">  } else if (eap-&gt;cmdidx == CMD_autocmd)</a>
<a name="ln4844">    do_autocmd(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4845">  else</a>
<a name="ln4846">    do_augroup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4847">}</a>
<a name="ln4848"> </a>
<a name="ln4849">/*</a>
<a name="ln4850"> * &quot;:doautocmd&quot;: Apply the automatic commands to the current buffer.</a>
<a name="ln4851"> */</a>
<a name="ln4852">static void ex_doautocmd(exarg_T *eap)</a>
<a name="ln4853">{</a>
<a name="ln4854">  char_u *arg = eap-&gt;arg;</a>
<a name="ln4855">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln4856">  bool did_aucmd;</a>
<a name="ln4857"> </a>
<a name="ln4858">  (void)do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln4859">  // Only when there is no &lt;nomodeline&gt;.</a>
<a name="ln4860">  if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln4861">    do_modelines(0);</a>
<a name="ln4862">  }</a>
<a name="ln4863">}</a>
<a name="ln4864"> </a>
<a name="ln4865">/*</a>
<a name="ln4866"> * :[N]bunload[!] [N] [bufname] unload buffer</a>
<a name="ln4867"> * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list</a>
<a name="ln4868"> * :[N]bwipeout[!] [N] [bufname] delete buffer really</a>
<a name="ln4869"> */</a>
<a name="ln4870">static void ex_bunload(exarg_T *eap)</a>
<a name="ln4871">{</a>
<a name="ln4872">  eap-&gt;errmsg = do_bufdel(</a>
<a name="ln4873">      eap-&gt;cmdidx == CMD_bdelete ? DOBUF_DEL</a>
<a name="ln4874">      : eap-&gt;cmdidx == CMD_bwipeout ? DOBUF_WIPE</a>
<a name="ln4875">      : DOBUF_UNLOAD, eap-&gt;arg,</a>
<a name="ln4876">      eap-&gt;addr_count, (int)eap-&gt;line1, (int)eap-&gt;line2, eap-&gt;forceit);</a>
<a name="ln4877">}</a>
<a name="ln4878"> </a>
<a name="ln4879">/*</a>
<a name="ln4880"> * :[N]buffer [N]	to buffer N</a>
<a name="ln4881"> * :[N]sbuffer [N]	to buffer N</a>
<a name="ln4882"> */</a>
<a name="ln4883">static void ex_buffer(exarg_T *eap)</a>
<a name="ln4884">{</a>
<a name="ln4885">  if (*eap-&gt;arg) {</a>
<a name="ln4886">    eap-&gt;errmsg = e_trailing;</a>
<a name="ln4887">  } else {</a>
<a name="ln4888">    if (eap-&gt;addr_count == 0) {  // default is current buffer</a>
<a name="ln4889">      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);</a>
<a name="ln4890">    } else {</a>
<a name="ln4891">      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4892">    }</a>
<a name="ln4893">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4894">      do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4895">    }</a>
<a name="ln4896">  }</a>
<a name="ln4897">}</a>
<a name="ln4898"> </a>
<a name="ln4899">/*</a>
<a name="ln4900"> * :[N]bmodified [N]	to next mod. buffer</a>
<a name="ln4901"> * :[N]sbmodified [N]	to next mod. buffer</a>
<a name="ln4902"> */</a>
<a name="ln4903">static void ex_bmodified(exarg_T *eap)</a>
<a name="ln4904">{</a>
<a name="ln4905">  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4906">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4907">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4908">  }</a>
<a name="ln4909">}</a>
<a name="ln4910"> </a>
<a name="ln4911">/*</a>
<a name="ln4912"> * :[N]bnext [N]	to next buffer</a>
<a name="ln4913"> * :[N]sbnext [N]	split and to next buffer</a>
<a name="ln4914"> */</a>
<a name="ln4915">static void ex_bnext(exarg_T *eap)</a>
<a name="ln4916">{</a>
<a name="ln4917">  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4918">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4919">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4920">  }</a>
<a name="ln4921">}</a>
<a name="ln4922"> </a>
<a name="ln4923">/*</a>
<a name="ln4924"> * :[N]bNext [N]	to previous buffer</a>
<a name="ln4925"> * :[N]bprevious [N]	to previous buffer</a>
<a name="ln4926"> * :[N]sbNext [N]	split and to previous buffer</a>
<a name="ln4927"> * :[N]sbprevious [N]	split and to previous buffer</a>
<a name="ln4928"> */</a>
<a name="ln4929">static void ex_bprevious(exarg_T *eap)</a>
<a name="ln4930">{</a>
<a name="ln4931">  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap-&gt;line2);</a>
<a name="ln4932">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4933">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4934">  }</a>
<a name="ln4935">}</a>
<a name="ln4936"> </a>
<a name="ln4937">/*</a>
<a name="ln4938"> * :brewind		to first buffer</a>
<a name="ln4939"> * :bfirst		to first buffer</a>
<a name="ln4940"> * :sbrewind		split and to first buffer</a>
<a name="ln4941"> * :sbfirst		split and to first buffer</a>
<a name="ln4942"> */</a>
<a name="ln4943">static void ex_brewind(exarg_T *eap)</a>
<a name="ln4944">{</a>
<a name="ln4945">  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);</a>
<a name="ln4946">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4947">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4948">  }</a>
<a name="ln4949">}</a>
<a name="ln4950"> </a>
<a name="ln4951">/*</a>
<a name="ln4952"> * :blast		to last buffer</a>
<a name="ln4953"> * :sblast		split and to last buffer</a>
<a name="ln4954"> */</a>
<a name="ln4955">static void ex_blast(exarg_T *eap)</a>
<a name="ln4956">{</a>
<a name="ln4957">  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);</a>
<a name="ln4958">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4959">    do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln4960">  }</a>
<a name="ln4961">}</a>
<a name="ln4962"> </a>
<a name="ln4963">int ends_excmd(int c) FUNC_ATTR_CONST</a>
<a name="ln4964">{</a>
<a name="ln4965">  return c == NUL || c == '|' || c == '&quot;' || c == '\n';</a>
<a name="ln4966">}</a>
<a name="ln4967"> </a>
<a name="ln4968">/*</a>
<a name="ln4969"> * Return the next command, after the first '|' or '\n'.</a>
<a name="ln4970"> * Return NULL if not found.</a>
<a name="ln4971"> */</a>
<a name="ln4972">char_u *find_nextcmd(const char_u *p)</a>
<a name="ln4973">{</a>
<a name="ln4974">  while (*p != '|' &amp;&amp; *p != '\n') {</a>
<a name="ln4975">    if (*p == NUL) {</a>
<a name="ln4976">      return NULL;</a>
<a name="ln4977">    }</a>
<a name="ln4978">    p++;</a>
<a name="ln4979">  }</a>
<a name="ln4980">  return (char_u *)p + 1;</a>
<a name="ln4981">}</a>
<a name="ln4982"> </a>
<a name="ln4983">/// Check if *p is a separator between Ex commands, skipping over white space.</a>
<a name="ln4984">/// Return NULL if it isn't, the following character if it is.</a>
<a name="ln4985">char_u *check_nextcmd(char_u *p)</a>
<a name="ln4986">{</a>
<a name="ln4987">    char_u *s = skipwhite(p);</a>
<a name="ln4988"> </a>
<a name="ln4989">    if (*s == '|' || *s == '\n') {</a>
<a name="ln4990">        return (s + 1);</a>
<a name="ln4991">    } else {</a>
<a name="ln4992">        return NULL;</a>
<a name="ln4993">    }</a>
<a name="ln4994">}</a>
<a name="ln4995"> </a>
<a name="ln4996">/*</a>
<a name="ln4997"> * - if there are more files to edit</a>
<a name="ln4998"> * - and this is the last window</a>
<a name="ln4999"> * - and forceit not used</a>
<a name="ln5000"> * - and not repeated twice on a row</a>
<a name="ln5001"> *    return FAIL and give error message if 'message' TRUE</a>
<a name="ln5002"> * return OK otherwise</a>
<a name="ln5003"> */</a>
<a name="ln5004">static int</a>
<a name="ln5005">check_more(</a>
<a name="ln5006">    int message,                // when FALSE check only, no messages</a>
<a name="ln5007">    int forceit</a>
<a name="ln5008">)</a>
<a name="ln5009">{</a>
<a name="ln5010">  int n = ARGCOUNT - curwin-&gt;w_arg_idx - 1;</a>
<a name="ln5011"> </a>
<a name="ln5012">  if (!forceit &amp;&amp; only_one_window()</a>
<a name="ln5013">      &amp;&amp; ARGCOUNT &gt; 1 &amp;&amp; !arg_had_last &amp;&amp; n &gt; 0 &amp;&amp; quitmore == 0) {</a>
<a name="ln5014">    if (message) {</a>
<a name="ln5015">      if ((p_confirm || cmdmod.confirm) &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln5016">        char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln5017"> </a>
<a name="ln5018">        if (n == 1)</a>
<a name="ln5019">          STRLCPY(buff, _(&quot;1 more file to edit.  Quit anyway?&quot;),</a>
<a name="ln5020">              DIALOG_MSG_SIZE);</a>
<a name="ln5021">        else</a>
<a name="ln5022">          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,</a>
<a name="ln5023">              _(&quot;%d more files to edit.  Quit anyway?&quot;), n);</a>
<a name="ln5024">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)</a>
<a name="ln5025">          return OK;</a>
<a name="ln5026">        return FAIL;</a>
<a name="ln5027">      }</a>
<a name="ln5028">      if (n == 1)</a>
<a name="ln5029">        EMSG(_(&quot;E173: 1 more file to edit&quot;));</a>
<a name="ln5030">      else</a>
<a name="ln5031">        EMSGN(_(&quot;E173: %&quot; PRId64 &quot; more files to edit&quot;), n);</a>
<a name="ln5032">      quitmore = 2;                 /* next try to quit is allowed */</a>
<a name="ln5033">    }</a>
<a name="ln5034">    return FAIL;</a>
<a name="ln5035">  }</a>
<a name="ln5036">  return OK;</a>
<a name="ln5037">}</a>
<a name="ln5038"> </a>
<a name="ln5039">/*</a>
<a name="ln5040"> * Function given to ExpandGeneric() to obtain the list of command names.</a>
<a name="ln5041"> */</a>
<a name="ln5042">char_u *get_command_name(expand_T *xp, int idx)</a>
<a name="ln5043">{</a>
<a name="ln5044">  if (idx &gt;= (int)CMD_SIZE)</a>
<a name="ln5045">    return get_user_command_name(idx);</a>
<a name="ln5046">  return cmdnames[idx].cmd_name;</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">static int uc_add_command(char_u *name, size_t name_len, char_u *rep,</a>
<a name="ln5050">                          uint32_t argt, long def, int flags, int compl,</a>
<a name="ln5051">                          char_u *compl_arg, cmd_addr_T addr_type, bool force)</a>
<a name="ln5052">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln5053">{</a>
<a name="ln5054">  ucmd_T      *cmd = NULL;</a>
<a name="ln5055">  int i;</a>
<a name="ln5056">  int cmp = 1;</a>
<a name="ln5057">  char_u      *rep_buf = NULL;</a>
<a name="ln5058">  garray_T    *gap;</a>
<a name="ln5059"> </a>
<a name="ln5060">  replace_termcodes(rep, STRLEN(rep), &amp;rep_buf, false, false, true,</a>
<a name="ln5061">                    CPO_TO_CPO_FLAGS);</a>
<a name="ln5062">  if (rep_buf == NULL) {</a>
<a name="ln5063">    /* Can't replace termcodes - try using the string as is */</a>
<a name="ln5064">    rep_buf = vim_strsave(rep);</a>
<a name="ln5065">  }</a>
<a name="ln5066"> </a>
<a name="ln5067">  /* get address of growarray: global or in curbuf */</a>
<a name="ln5068">  if (flags &amp; UC_BUFFER) {</a>
<a name="ln5069">    gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5070">    if (gap-&gt;ga_itemsize == 0)</a>
<a name="ln5071">      ga_init(gap, (int)sizeof(ucmd_T), 4);</a>
<a name="ln5072">  } else</a>
<a name="ln5073">    gap = &amp;ucmds;</a>
<a name="ln5074"> </a>
<a name="ln5075">  /* Search for the command in the already defined commands. */</a>
<a name="ln5076">  for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5077">    size_t len;</a>
<a name="ln5078"> </a>
<a name="ln5079">    cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5080">    len = STRLEN(cmd-&gt;uc_name);</a>
<a name="ln5081">    cmp = STRNCMP(name, cmd-&gt;uc_name, name_len);</a>
<a name="ln5082">    if (cmp == 0) {</a>
<a name="ln5083">      if (name_len &lt; len)</a>
<a name="ln5084">        cmp = -1;</a>
<a name="ln5085">      else if (name_len &gt; len)</a>
<a name="ln5086">        cmp = 1;</a>
<a name="ln5087">    }</a>
<a name="ln5088"> </a>
<a name="ln5089">    if (cmp == 0) {</a>
<a name="ln5090">      // Command can be replaced with &quot;command!&quot; and when sourcing the</a>
<a name="ln5091">      // same script again, but only once.</a>
<a name="ln5092">      if (!force</a>
<a name="ln5093">          &amp;&amp; (cmd-&gt;uc_script_ctx.sc_sid != current_sctx.sc_sid</a>
<a name="ln5094">              || cmd-&gt;uc_script_ctx.sc_seq == current_sctx.sc_seq)) {</a>
<a name="ln5095">        EMSG2(_(&quot;E174: Command already exists: add ! to replace it: %s&quot;),</a>
<a name="ln5096">              name);</a>
<a name="ln5097">        goto fail;</a>
<a name="ln5098">      }</a>
<a name="ln5099"> </a>
<a name="ln5100">      XFREE_CLEAR(cmd-&gt;uc_rep);</a>
<a name="ln5101">      XFREE_CLEAR(cmd-&gt;uc_compl_arg);</a>
<a name="ln5102">      break;</a>
<a name="ln5103">    }</a>
<a name="ln5104"> </a>
<a name="ln5105">    /* Stop as soon as we pass the name to add */</a>
<a name="ln5106">    if (cmp &lt; 0)</a>
<a name="ln5107">      break;</a>
<a name="ln5108">  }</a>
<a name="ln5109"> </a>
<a name="ln5110">  /* Extend the array unless we're replacing an existing command */</a>
<a name="ln5111">  if (cmp != 0) {</a>
<a name="ln5112">    ga_grow(gap, 1);</a>
<a name="ln5113"> </a>
<a name="ln5114">    char_u *const p = vim_strnsave(name, name_len);</a>
<a name="ln5115"> </a>
<a name="ln5116">    cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5117">    memmove(cmd + 1, cmd, (gap-&gt;ga_len - i) * sizeof(ucmd_T));</a>
<a name="ln5118"> </a>
<a name="ln5119">    ++gap-&gt;ga_len;</a>
<a name="ln5120"> </a>
<a name="ln5121">    cmd-&gt;uc_name = p;</a>
<a name="ln5122">  }</a>
<a name="ln5123"> </a>
<a name="ln5124">  cmd-&gt;uc_rep = rep_buf;</a>
<a name="ln5125">  cmd-&gt;uc_argt = argt;</a>
<a name="ln5126">  cmd-&gt;uc_def = def;</a>
<a name="ln5127">  cmd-&gt;uc_compl = compl;</a>
<a name="ln5128">  cmd-&gt;uc_script_ctx = current_sctx;</a>
<a name="ln5129">  cmd-&gt;uc_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln5130">  cmd-&gt;uc_compl_arg = compl_arg;</a>
<a name="ln5131">  cmd-&gt;uc_addr_type = addr_type;</a>
<a name="ln5132"> </a>
<a name="ln5133">  return OK;</a>
<a name="ln5134"> </a>
<a name="ln5135">fail:</a>
<a name="ln5136">  xfree(rep_buf);</a>
<a name="ln5137">  xfree(compl_arg);</a>
<a name="ln5138">  return FAIL;</a>
<a name="ln5139">}</a>
<a name="ln5140"> </a>
<a name="ln5141"> </a>
<a name="ln5142">static struct {</a>
<a name="ln5143">  cmd_addr_T expand;</a>
<a name="ln5144">  char *name;</a>
<a name="ln5145">  char *shortname;</a>
<a name="ln5146">} addr_type_complete[] =</a>
<a name="ln5147">{</a>
<a name="ln5148">  { ADDR_ARGUMENTS, &quot;arguments&quot;, &quot;arg&quot; },</a>
<a name="ln5149">  { ADDR_LINES, &quot;lines&quot;, &quot;line&quot; },</a>
<a name="ln5150">  { ADDR_LOADED_BUFFERS, &quot;loaded_buffers&quot;, &quot;load&quot; },</a>
<a name="ln5151">  { ADDR_TABS, &quot;tabs&quot;, &quot;tab&quot; },</a>
<a name="ln5152">  { ADDR_BUFFERS, &quot;buffers&quot;, &quot;buf&quot; },</a>
<a name="ln5153">  { ADDR_WINDOWS, &quot;windows&quot;, &quot;win&quot; },</a>
<a name="ln5154">  { ADDR_QUICKFIX, &quot;quickfix&quot;, &quot;qf&quot; },</a>
<a name="ln5155">  { ADDR_OTHER, &quot;other&quot;, &quot;?&quot; },</a>
<a name="ln5156">  { ADDR_NONE, NULL, NULL }</a>
<a name="ln5157">};</a>
<a name="ln5158"> </a>
<a name="ln5159">/*</a>
<a name="ln5160"> * List of names for completion for &quot;:command&quot; with the EXPAND_ flag.</a>
<a name="ln5161"> * Must be alphabetical for completion.</a>
<a name="ln5162"> */</a>
<a name="ln5163">static const char *command_complete[] =</a>
<a name="ln5164">{</a>
<a name="ln5165">  [EXPAND_ARGLIST] = &quot;arglist&quot;,</a>
<a name="ln5166">  [EXPAND_AUGROUP] = &quot;augroup&quot;,</a>
<a name="ln5167">  [EXPAND_BEHAVE] = &quot;behave&quot;,</a>
<a name="ln5168">  [EXPAND_BUFFERS] = &quot;buffer&quot;,</a>
<a name="ln5169">  [EXPAND_CHECKHEALTH] = &quot;checkhealth&quot;,</a>
<a name="ln5170">  [EXPAND_COLORS] = &quot;color&quot;,</a>
<a name="ln5171">  [EXPAND_COMMANDS] = &quot;command&quot;,</a>
<a name="ln5172">  [EXPAND_COMPILER] = &quot;compiler&quot;,</a>
<a name="ln5173">  [EXPAND_CSCOPE] = &quot;cscope&quot;,</a>
<a name="ln5174">  [EXPAND_USER_DEFINED] = &quot;custom&quot;,</a>
<a name="ln5175">  [EXPAND_USER_LIST] = &quot;customlist&quot;,</a>
<a name="ln5176">  [EXPAND_DIRECTORIES] = &quot;dir&quot;,</a>
<a name="ln5177">  [EXPAND_ENV_VARS] = &quot;environment&quot;,</a>
<a name="ln5178">  [EXPAND_EVENTS] = &quot;event&quot;,</a>
<a name="ln5179">  [EXPAND_EXPRESSION] = &quot;expression&quot;,</a>
<a name="ln5180">  [EXPAND_FILES] = &quot;file&quot;,</a>
<a name="ln5181">  [EXPAND_FILES_IN_PATH] = &quot;file_in_path&quot;,</a>
<a name="ln5182">  [EXPAND_FILETYPE] = &quot;filetype&quot;,</a>
<a name="ln5183">  [EXPAND_FUNCTIONS] = &quot;function&quot;,</a>
<a name="ln5184">  [EXPAND_HELP] = &quot;help&quot;,</a>
<a name="ln5185">  [EXPAND_HIGHLIGHT] = &quot;highlight&quot;,</a>
<a name="ln5186">  [EXPAND_HISTORY] = &quot;history&quot;,</a>
<a name="ln5187">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln5188">  [EXPAND_LOCALES] = &quot;locale&quot;,</a>
<a name="ln5189">#endif</a>
<a name="ln5190">  [EXPAND_MAPCLEAR] = &quot;mapclear&quot;,</a>
<a name="ln5191">  [EXPAND_MAPPINGS] = &quot;mapping&quot;,</a>
<a name="ln5192">  [EXPAND_MENUS] = &quot;menu&quot;,</a>
<a name="ln5193">  [EXPAND_MESSAGES] = &quot;messages&quot;,</a>
<a name="ln5194">  [EXPAND_OWNSYNTAX] = &quot;syntax&quot;,</a>
<a name="ln5195">  [EXPAND_SYNTIME] = &quot;syntime&quot;,</a>
<a name="ln5196">  [EXPAND_SETTINGS] = &quot;option&quot;,</a>
<a name="ln5197">  [EXPAND_PACKADD] = &quot;packadd&quot;,</a>
<a name="ln5198">  [EXPAND_SHELLCMD] = &quot;shellcmd&quot;,</a>
<a name="ln5199">  [EXPAND_SIGN] = &quot;sign&quot;,</a>
<a name="ln5200">  [EXPAND_TAGS] = &quot;tag&quot;,</a>
<a name="ln5201">  [EXPAND_TAGS_LISTFILES] = &quot;tag_listfiles&quot;,</a>
<a name="ln5202">  [EXPAND_USER] = &quot;user&quot;,</a>
<a name="ln5203">  [EXPAND_USER_VARS] = &quot;var&quot;,</a>
<a name="ln5204">};</a>
<a name="ln5205"> </a>
<a name="ln5206">static char *get_command_complete(int arg)</a>
<a name="ln5207">{</a>
<a name="ln5208">  if (arg &gt;= (int)(ARRAY_SIZE(command_complete))) {</a>
<a name="ln5209">    return NULL;</a>
<a name="ln5210">  } else {</a>
<a name="ln5211">    return (char *)command_complete[arg];</a>
<a name="ln5212">  }</a>
<a name="ln5213">}</a>
<a name="ln5214"> </a>
<a name="ln5215">static void uc_list(char_u *name, size_t name_len)</a>
<a name="ln5216">{</a>
<a name="ln5217">  int i, j;</a>
<a name="ln5218">  bool found = false;</a>
<a name="ln5219">  ucmd_T      *cmd;</a>
<a name="ln5220">  uint32_t a;</a>
<a name="ln5221"> </a>
<a name="ln5222">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln5223">  garray_T *gap = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln5224">    ? &amp;prevwin-&gt;w_buffer-&gt;b_ucmds</a>
<a name="ln5225">    : &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5226">  for (;; ) {</a>
<a name="ln5227">    for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5228">      cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5229">      a = cmd-&gt;uc_argt;</a>
<a name="ln5230"> </a>
<a name="ln5231">      // Skip commands which don't match the requested prefix and</a>
<a name="ln5232">      // commands filtered out.</a>
<a name="ln5233">      if (STRNCMP(name, cmd-&gt;uc_name, name_len) != 0</a>
<a name="ln5234">          || message_filtered(cmd-&gt;uc_name)) {</a>
<a name="ln5235">        continue;</a>
<a name="ln5236">      }</a>
<a name="ln5237"> </a>
<a name="ln5238">      // Put out the title first time</a>
<a name="ln5239">      if (!found) {</a>
<a name="ln5240">        MSG_PUTS_TITLE(_(&quot;\n    Name              Args Address &quot;</a>
<a name="ln5241">                         &quot;Complete    Definition&quot;));</a>
<a name="ln5242">      }</a>
<a name="ln5243">      found = true;</a>
<a name="ln5244">      msg_putchar('\n');</a>
<a name="ln5245">      if (got_int)</a>
<a name="ln5246">        break;</a>
<a name="ln5247"> </a>
<a name="ln5248">      // Special cases</a>
<a name="ln5249">      int len = 4;</a>
<a name="ln5250">      if (a &amp; EX_BANG) {</a>
<a name="ln5251">        msg_putchar('!');</a>
<a name="ln5252">        len--;</a>
<a name="ln5253">      }</a>
<a name="ln5254">      if (a &amp; EX_REGSTR) {</a>
<a name="ln5255">        msg_putchar('&quot;');</a>
<a name="ln5256">        len--;</a>
<a name="ln5257">      }</a>
<a name="ln5258">      if (gap != &amp;ucmds) {</a>
<a name="ln5259">        msg_putchar('b');</a>
<a name="ln5260">        len--;</a>
<a name="ln5261">      }</a>
<a name="ln5262">      if (a &amp; EX_TRLBAR) {</a>
<a name="ln5263">        msg_putchar('|');</a>
<a name="ln5264">        len--;</a>
<a name="ln5265">      }</a>
<a name="ln5266">      while (len-- &gt; 0) {</a>
<a name="ln5267">        msg_putchar(' ');</a>
<a name="ln5268">      }</a>
<a name="ln5269"> </a>
<a name="ln5270">      msg_outtrans_attr(cmd-&gt;uc_name, HL_ATTR(HLF_D));</a>
<a name="ln5271">      len = (int)STRLEN(cmd-&gt;uc_name) + 4;</a>
<a name="ln5272"> </a>
<a name="ln5273">      do {</a>
<a name="ln5274">        msg_putchar(' ');</a>
<a name="ln5275">        len++;</a>
<a name="ln5276">      } while (len &lt; 22);</a>
<a name="ln5277"> </a>
<a name="ln5278">      // &quot;over&quot; is how much longer the name is than the column width for</a>
<a name="ln5279">      // the name, we'll try to align what comes after.</a>
<a name="ln5280">      const int over = len - 22;</a>
<a name="ln5281">      len = 0;</a>
<a name="ln5282"> </a>
<a name="ln5283">      // Arguments</a>
<a name="ln5284">      switch (a &amp; (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {</a>
<a name="ln5285">        case 0:</a>
<a name="ln5286">          IObuff[len++] = '0';</a>
<a name="ln5287">          break;</a>
<a name="ln5288">        case (EX_EXTRA):</a>
<a name="ln5289">          IObuff[len++] = '*';</a>
<a name="ln5290">          break;</a>
<a name="ln5291">        case (EX_EXTRA | EX_NOSPC):</a>
<a name="ln5292">          IObuff[len++] = '?';</a>
<a name="ln5293">          break;</a>
<a name="ln5294">        case (EX_EXTRA | EX_NEEDARG):</a>
<a name="ln5295">          IObuff[len++] = '+';</a>
<a name="ln5296">          break;</a>
<a name="ln5297">        case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):</a>
<a name="ln5298">          IObuff[len++] = '1';</a>
<a name="ln5299">          break;</a>
<a name="ln5300">      }</a>
<a name="ln5301"> </a>
<a name="ln5302">      do {</a>
<a name="ln5303">        IObuff[len++] = ' ';</a>
<a name="ln5304">      } while (len &lt; 5 - over);</a>
<a name="ln5305"> </a>
<a name="ln5306">      // Address / Range</a>
<a name="ln5307">      if (a &amp; (EX_RANGE | EX_COUNT)) {</a>
<a name="ln5308">        if (a &amp; EX_COUNT) {</a>
<a name="ln5309">          // -count=N</a>
<a name="ln5310">          snprintf((char *)IObuff + len, IOSIZE, &quot;%&quot; PRId64 &quot;c&quot;,</a>
<a name="ln5311">                   (int64_t)cmd-&gt;uc_def);</a>
<a name="ln5312">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5313">        } else if (a &amp; EX_DFLALL) {</a>
<a name="ln5314">          IObuff[len++] = '%';</a>
<a name="ln5315">        } else if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln5316">          // -range=N</a>
<a name="ln5317">          snprintf((char *)IObuff + len, IOSIZE, &quot;%&quot; PRId64 &quot;&quot;,</a>
<a name="ln5318">                   (int64_t)cmd-&gt;uc_def);</a>
<a name="ln5319">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5320">        } else {</a>
<a name="ln5321">          IObuff[len++] = '.';</a>
<a name="ln5322">        }</a>
<a name="ln5323">      }</a>
<a name="ln5324"> </a>
<a name="ln5325">      do {</a>
<a name="ln5326">        IObuff[len++] = ' ';</a>
<a name="ln5327">      } while (len &lt; 8 - over);</a>
<a name="ln5328"> </a>
<a name="ln5329">      // Address Type</a>
<a name="ln5330">      for (j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {</a>
<a name="ln5331">        if (addr_type_complete[j].expand != ADDR_LINES</a>
<a name="ln5332">            &amp;&amp; addr_type_complete[j].expand == cmd-&gt;uc_addr_type) {</a>
<a name="ln5333">          STRCPY(IObuff + len, addr_type_complete[j].shortname);</a>
<a name="ln5334">          len += (int)STRLEN(IObuff + len);</a>
<a name="ln5335">          break;</a>
<a name="ln5336">        }</a>
<a name="ln5337">      }</a>
<a name="ln5338"> </a>
<a name="ln5339">      do {</a>
<a name="ln5340">        IObuff[len++] = ' ';</a>
<a name="ln5341">      } while (len &lt; 13 - over);</a>
<a name="ln5342"> </a>
<a name="ln5343">      // Completion</a>
<a name="ln5344">      char *cmd_compl = get_command_complete(cmd-&gt;uc_compl);</a>
<a name="ln5345">      if (cmd_compl != NULL) {</a>
<a name="ln5346">        STRCPY(IObuff + len, get_command_complete(cmd-&gt;uc_compl));</a>
<a name="ln5347">        len += (int)STRLEN(IObuff + len);</a>
<a name="ln5348">      }</a>
<a name="ln5349"> </a>
<a name="ln5350">      do {</a>
<a name="ln5351">        IObuff[len++] = ' ';</a>
<a name="ln5352">      } while (len &lt; 25 - over);</a>
<a name="ln5353"> </a>
<a name="ln5354">      IObuff[len] = '\0';</a>
<a name="ln5355">      msg_outtrans(IObuff);</a>
<a name="ln5356"> </a>
<a name="ln5357">      msg_outtrans_special(cmd-&gt;uc_rep, false,</a>
<a name="ln5358">                           name_len == 0 ? Columns - 47 : 0);</a>
<a name="ln5359">      if (p_verbose &gt; 0) {</a>
<a name="ln5360">        last_set_msg(cmd-&gt;uc_script_ctx);</a>
<a name="ln5361">      }</a>
<a name="ln5362">      line_breakcheck();</a>
<a name="ln5363">      if (got_int) {</a>
<a name="ln5364">        break;</a>
<a name="ln5365">      }</a>
<a name="ln5366">    }</a>
<a name="ln5367">    if (gap == &amp;ucmds || i &lt; gap-&gt;ga_len)</a>
<a name="ln5368">      break;</a>
<a name="ln5369">    gap = &amp;ucmds;</a>
<a name="ln5370">  }</a>
<a name="ln5371"> </a>
<a name="ln5372">  if (!found)</a>
<a name="ln5373">    MSG(_(&quot;No user-defined commands found&quot;));</a>
<a name="ln5374">}</a>
<a name="ln5375"> </a>
<a name="ln5376">static int uc_scan_attr(char_u *attr, size_t len, uint32_t *argt, long *def,</a>
<a name="ln5377">                        int *flags, int *complp, char_u **compl_arg,</a>
<a name="ln5378">                        cmd_addr_T *addr_type_arg)</a>
<a name="ln5379">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5380">{</a>
<a name="ln5381">  char_u      *p;</a>
<a name="ln5382"> </a>
<a name="ln5383">  if (len == 0) {</a>
<a name="ln5384">    EMSG(_(&quot;E175: No attribute specified&quot;));</a>
<a name="ln5385">    return FAIL;</a>
<a name="ln5386">  }</a>
<a name="ln5387"> </a>
<a name="ln5388">  // First, try the simple attributes (no arguments)</a>
<a name="ln5389">  if (STRNICMP(attr, &quot;bang&quot;, len) == 0) {</a>
<a name="ln5390">    *argt |= EX_BANG;</a>
<a name="ln5391">  } else if (STRNICMP(attr, &quot;buffer&quot;, len) == 0) {</a>
<a name="ln5392">    *flags |= UC_BUFFER;</a>
<a name="ln5393">  } else if (STRNICMP(attr, &quot;register&quot;, len) == 0) {</a>
<a name="ln5394">    *argt |= EX_REGSTR;</a>
<a name="ln5395">  } else if (STRNICMP(attr, &quot;bar&quot;, len) == 0) {</a>
<a name="ln5396">    *argt |= EX_TRLBAR;</a>
<a name="ln5397">  } else {</a>
<a name="ln5398">    int i;</a>
<a name="ln5399">    char_u  *val = NULL;</a>
<a name="ln5400">    size_t vallen = 0;</a>
<a name="ln5401">    size_t attrlen = len;</a>
<a name="ln5402"> </a>
<a name="ln5403">    /* Look for the attribute name - which is the part before any '=' */</a>
<a name="ln5404">    for (i = 0; i &lt; (int)len; ++i) {</a>
<a name="ln5405">      if (attr[i] == '=') {</a>
<a name="ln5406">        val = &amp;attr[i + 1];</a>
<a name="ln5407">        vallen = len - i - 1;</a>
<a name="ln5408">        attrlen = i;</a>
<a name="ln5409">        break;</a>
<a name="ln5410">      }</a>
<a name="ln5411">    }</a>
<a name="ln5412"> </a>
<a name="ln5413">    if (STRNICMP(attr, &quot;nargs&quot;, attrlen) == 0) {</a>
<a name="ln5414">      if (vallen == 1) {</a>
<a name="ln5415">        if (*val == '0') {</a>
<a name="ln5416">          // Do nothing - this is the default;</a>
<a name="ln5417">        } else if (*val == '1') {</a>
<a name="ln5418">          *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);</a>
<a name="ln5419">        } else if (*val == '*') {</a>
<a name="ln5420">          *argt |= EX_EXTRA;</a>
<a name="ln5421">        } else if (*val == '?') {</a>
<a name="ln5422">          *argt |= (EX_EXTRA | EX_NOSPC);</a>
<a name="ln5423">        } else if (*val == '+') {</a>
<a name="ln5424">          *argt |= (EX_EXTRA | EX_NEEDARG);</a>
<a name="ln5425">        } else {</a>
<a name="ln5426">          goto wrong_nargs;</a>
<a name="ln5427">        }</a>
<a name="ln5428">      } else {</a>
<a name="ln5429">wrong_nargs:</a>
<a name="ln5430">        EMSG(_(&quot;E176: Invalid number of arguments&quot;));</a>
<a name="ln5431">        return FAIL;</a>
<a name="ln5432">      }</a>
<a name="ln5433">    } else if (STRNICMP(attr, &quot;range&quot;, attrlen) == 0) {</a>
<a name="ln5434">      *argt |= EX_RANGE;</a>
<a name="ln5435">      if (vallen == 1 &amp;&amp; *val == '%') {</a>
<a name="ln5436">        *argt |= EX_DFLALL;</a>
<a name="ln5437">      } else if (val != NULL) {</a>
<a name="ln5438">        p = val;</a>
<a name="ln5439">        if (*def &gt;= 0) {</a>
<a name="ln5440">two_count:</a>
<a name="ln5441">          EMSG(_(&quot;E177: Count cannot be specified twice&quot;));</a>
<a name="ln5442">          return FAIL;</a>
<a name="ln5443">        }</a>
<a name="ln5444"> </a>
<a name="ln5445">        *def = getdigits_long(&amp;p, true, 0);</a>
<a name="ln5446">        *argt |= EX_ZEROR;</a>
<a name="ln5447"> </a>
<a name="ln5448">        if (p != val + vallen || vallen == 0) {</a>
<a name="ln5449">invalid_count:</a>
<a name="ln5450">          EMSG(_(&quot;E178: Invalid default value for count&quot;));</a>
<a name="ln5451">          return FAIL;</a>
<a name="ln5452">        }</a>
<a name="ln5453">      }</a>
<a name="ln5454">      // default for -range is using buffer lines</a>
<a name="ln5455">      if (*addr_type_arg == ADDR_NONE) {</a>
<a name="ln5456">        *addr_type_arg = ADDR_LINES;</a>
<a name="ln5457">      }</a>
<a name="ln5458">    } else if (STRNICMP(attr, &quot;count&quot;, attrlen) == 0) {</a>
<a name="ln5459">      *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);</a>
<a name="ln5460">      // default for -count is using any number</a>
<a name="ln5461">      if (*addr_type_arg == ADDR_NONE) {</a>
<a name="ln5462">        *addr_type_arg = ADDR_OTHER;</a>
<a name="ln5463">      }</a>
<a name="ln5464"> </a>
<a name="ln5465">      if (val != NULL) {</a>
<a name="ln5466">        p = val;</a>
<a name="ln5467">        if (*def &gt;= 0)</a>
<a name="ln5468">          goto two_count;</a>
<a name="ln5469"> </a>
<a name="ln5470">        *def = getdigits_long(&amp;p, true, 0);</a>
<a name="ln5471"> </a>
<a name="ln5472">        if (p != val + vallen)</a>
<a name="ln5473">          goto invalid_count;</a>
<a name="ln5474">      }</a>
<a name="ln5475"> </a>
<a name="ln5476">      if (*def &lt; 0)</a>
<a name="ln5477">        *def = 0;</a>
<a name="ln5478">    } else if (STRNICMP(attr, &quot;complete&quot;, attrlen) == 0) {</a>
<a name="ln5479">      if (val == NULL) {</a>
<a name="ln5480">        EMSG(_(&quot;E179: argument required for -complete&quot;));</a>
<a name="ln5481">        return FAIL;</a>
<a name="ln5482">      }</a>
<a name="ln5483"> </a>
<a name="ln5484">      if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)</a>
<a name="ln5485">          == FAIL) {</a>
<a name="ln5486">        return FAIL;</a>
<a name="ln5487">      }</a>
<a name="ln5488">    } else if (STRNICMP(attr, &quot;addr&quot;, attrlen) == 0) {</a>
<a name="ln5489">      *argt |= EX_RANGE;</a>
<a name="ln5490">      if (val == NULL) {</a>
<a name="ln5491">        EMSG(_(&quot;E179: argument required for -addr&quot;));</a>
<a name="ln5492">        return FAIL;</a>
<a name="ln5493">      }</a>
<a name="ln5494">      if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL) {</a>
<a name="ln5495">        return FAIL;</a>
<a name="ln5496">      }</a>
<a name="ln5497">      if (*addr_type_arg != ADDR_LINES) {</a>
<a name="ln5498">        *argt |= EX_ZEROR;</a>
<a name="ln5499">      }</a>
<a name="ln5500">    } else {</a>
<a name="ln5501">      char_u ch = attr[len];</a>
<a name="ln5502">      attr[len] = '\0';</a>
<a name="ln5503">      EMSG2(_(&quot;E181: Invalid attribute: %s&quot;), attr);</a>
<a name="ln5504">      attr[len] = ch;</a>
<a name="ln5505">      return FAIL;</a>
<a name="ln5506">    }</a>
<a name="ln5507">  }</a>
<a name="ln5508"> </a>
<a name="ln5509">  return OK;</a>
<a name="ln5510">}</a>
<a name="ln5511"> </a>
<a name="ln5512">/*</a>
<a name="ln5513"> * &quot;:command ...&quot;</a>
<a name="ln5514"> */</a>
<a name="ln5515">static void ex_command(exarg_T *eap)</a>
<a name="ln5516">{</a>
<a name="ln5517">  char_u  *name;</a>
<a name="ln5518">  char_u  *end;</a>
<a name="ln5519">  char_u  *p;</a>
<a name="ln5520">  uint32_t argt = 0;</a>
<a name="ln5521">  long def = -1;</a>
<a name="ln5522">  int flags = 0;</a>
<a name="ln5523">  int     compl = EXPAND_NOTHING;</a>
<a name="ln5524">  char_u  *compl_arg = NULL;</a>
<a name="ln5525">  cmd_addr_T addr_type_arg = ADDR_NONE;</a>
<a name="ln5526">  int has_attr = (eap-&gt;arg[0] == '-');</a>
<a name="ln5527">  int name_len;</a>
<a name="ln5528"> </a>
<a name="ln5529">  p = eap-&gt;arg;</a>
<a name="ln5530"> </a>
<a name="ln5531">  /* Check for attributes */</a>
<a name="ln5532">  while (*p == '-') {</a>
<a name="ln5533">    ++p;</a>
<a name="ln5534">    end = skiptowhite(p);</a>
<a name="ln5535">    if (uc_scan_attr(p, end - p, &amp;argt, &amp;def, &amp;flags, &amp;compl, &amp;compl_arg,</a>
<a name="ln5536">                     &amp;addr_type_arg) == FAIL) {</a>
<a name="ln5537">      return;</a>
<a name="ln5538">    }</a>
<a name="ln5539">    p = skipwhite(end);</a>
<a name="ln5540">  }</a>
<a name="ln5541"> </a>
<a name="ln5542">  // Get the name (if any) and skip to the following argument.</a>
<a name="ln5543">  name = p;</a>
<a name="ln5544">  if (ASCII_ISALPHA(*p)) {</a>
<a name="ln5545">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln5546">      p++;</a>
<a name="ln5547">    }</a>
<a name="ln5548">  }</a>
<a name="ln5549">  if (!ends_excmd(*p) &amp;&amp; !ascii_iswhite(*p)) {</a>
<a name="ln5550">    EMSG(_(&quot;E182: Invalid command name&quot;));</a>
<a name="ln5551">    return;</a>
<a name="ln5552">  }</a>
<a name="ln5553">  end = p;</a>
<a name="ln5554">  name_len = (int)(end - name);</a>
<a name="ln5555"> </a>
<a name="ln5556">  // If there is nothing after the name, and no attributes were specified,</a>
<a name="ln5557">  // we are listing commands</a>
<a name="ln5558">  p = skipwhite(end);</a>
<a name="ln5559">  if (!has_attr &amp;&amp; ends_excmd(*p)) {</a>
<a name="ln5560">    uc_list(name, end - name);</a>
<a name="ln5561">  } else if (!ASCII_ISUPPER(*name)) {</a>
<a name="ln5562">    EMSG(_(&quot;E183: User defined commands must start with an uppercase letter&quot;));</a>
<a name="ln5563">    return;</a>
<a name="ln5564">  } else if (name_len &lt;= 4 &amp;&amp; STRNCMP(name, &quot;Next&quot;, name_len) == 0) {</a>
<a name="ln5565">    EMSG(_(&quot;E841: Reserved name, cannot be used for user defined command&quot;));</a>
<a name="ln5566">    return;</a>
<a name="ln5567">  } else {</a>
<a name="ln5568">    uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,</a>
<a name="ln5569">                   addr_type_arg, eap-&gt;forceit);</a>
<a name="ln5570">  }</a>
<a name="ln5571">}</a>
<a name="ln5572"> </a>
<a name="ln5573">/*</a>
<a name="ln5574"> * &quot;:comclear&quot;</a>
<a name="ln5575"> * Clear all user commands, global and for current buffer.</a>
<a name="ln5576"> */</a>
<a name="ln5577">void ex_comclear(exarg_T *eap)</a>
<a name="ln5578">{</a>
<a name="ln5579">  uc_clear(&amp;ucmds);</a>
<a name="ln5580">  uc_clear(&amp;curbuf-&gt;b_ucmds);</a>
<a name="ln5581">}</a>
<a name="ln5582"> </a>
<a name="ln5583">static void free_ucmd(ucmd_T* cmd) {</a>
<a name="ln5584">  xfree(cmd-&gt;uc_name);</a>
<a name="ln5585">  xfree(cmd-&gt;uc_rep);</a>
<a name="ln5586">  xfree(cmd-&gt;uc_compl_arg);</a>
<a name="ln5587">}</a>
<a name="ln5588"> </a>
<a name="ln5589">/*</a>
<a name="ln5590"> * Clear all user commands for &quot;gap&quot;.</a>
<a name="ln5591"> */</a>
<a name="ln5592">void uc_clear(garray_T *gap)</a>
<a name="ln5593">{</a>
<a name="ln5594">  GA_DEEP_CLEAR(gap, ucmd_T, free_ucmd);</a>
<a name="ln5595">}</a>
<a name="ln5596"> </a>
<a name="ln5597">static void ex_delcommand(exarg_T *eap)</a>
<a name="ln5598">{</a>
<a name="ln5599">  int i = 0;</a>
<a name="ln5600">  ucmd_T      *cmd = NULL;</a>
<a name="ln5601">  int cmp = -1;</a>
<a name="ln5602">  garray_T    *gap;</a>
<a name="ln5603"> </a>
<a name="ln5604">  gap = &amp;curbuf-&gt;b_ucmds;</a>
<a name="ln5605">  for (;; ) {</a>
<a name="ln5606">    for (i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln5607">      cmd = USER_CMD_GA(gap, i);</a>
<a name="ln5608">      cmp = STRCMP(eap-&gt;arg, cmd-&gt;uc_name);</a>
<a name="ln5609">      if (cmp &lt;= 0)</a>
<a name="ln5610">        break;</a>
<a name="ln5611">    }</a>
<a name="ln5612">    if (gap == &amp;ucmds || cmp == 0)</a>
<a name="ln5613">      break;</a>
<a name="ln5614">    gap = &amp;ucmds;</a>
<a name="ln5615">  }</a>
<a name="ln5616"> </a>
<a name="ln5617">  if (cmp != 0) {</a>
<a name="ln5618">    EMSG2(_(&quot;E184: No such user-defined command: %s&quot;), eap-&gt;arg);</a>
<a name="ln5619">    return;</a>
<a name="ln5620">  }</a>
<a name="ln5621"> </a>
<a name="ln5622">  xfree(cmd-&gt;uc_name);</a>
<a name="ln5623">  xfree(cmd-&gt;uc_rep);</a>
<a name="ln5624">  xfree(cmd-&gt;uc_compl_arg);</a>
<a name="ln5625"> </a>
<a name="ln5626">  --gap-&gt;ga_len;</a>
<a name="ln5627"> </a>
<a name="ln5628">  if (i &lt; gap-&gt;ga_len)</a>
<a name="ln5629">    memmove(cmd, cmd + 1, (gap-&gt;ga_len - i) * sizeof(ucmd_T));</a>
<a name="ln5630">}</a>
<a name="ln5631"> </a>
<a name="ln5632">/*</a>
<a name="ln5633"> * split and quote args for &lt;f-args&gt;</a>
<a name="ln5634"> */</a>
<a name="ln5635">static char_u *uc_split_args(char_u *arg, size_t *lenp)</a>
<a name="ln5636">{</a>
<a name="ln5637">  char_u *buf;</a>
<a name="ln5638">  char_u *p;</a>
<a name="ln5639">  char_u *q;</a>
<a name="ln5640">  int len;</a>
<a name="ln5641"> </a>
<a name="ln5642">  /* Precalculate length */</a>
<a name="ln5643">  p = arg;</a>
<a name="ln5644">  len = 2;   /* Initial and final quotes */</a>
<a name="ln5645"> </a>
<a name="ln5646">  while (*p) {</a>
<a name="ln5647">    if (p[0] == '\\' &amp;&amp; p[1] == '\\') {</a>
<a name="ln5648">      len += 2;</a>
<a name="ln5649">      p += 2;</a>
<a name="ln5650">    } else if (p[0] == '\\' &amp;&amp; ascii_iswhite(p[1])) {</a>
<a name="ln5651">      len += 1;</a>
<a name="ln5652">      p += 2;</a>
<a name="ln5653">    } else if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5654">      len += 2;</a>
<a name="ln5655">      p += 1;</a>
<a name="ln5656">    } else if (ascii_iswhite(*p)) {</a>
<a name="ln5657">      p = skipwhite(p);</a>
<a name="ln5658">      if (*p == NUL)</a>
<a name="ln5659">        break;</a>
<a name="ln5660">      len += 3;       /* &quot;,&quot; */</a>
<a name="ln5661">    } else {</a>
<a name="ln5662">      const int charlen = utfc_ptr2len(p);</a>
<a name="ln5663"> </a>
<a name="ln5664">      len += charlen;</a>
<a name="ln5665">      p += charlen;</a>
<a name="ln5666">    }</a>
<a name="ln5667">  }</a>
<a name="ln5668"> </a>
<a name="ln5669">  buf = xmalloc(len + 1);</a>
<a name="ln5670"> </a>
<a name="ln5671">  p = arg;</a>
<a name="ln5672">  q = buf;</a>
<a name="ln5673">  *q++ = '&quot;';</a>
<a name="ln5674">  while (*p) {</a>
<a name="ln5675">    if (p[0] == '\\' &amp;&amp; p[1] == '\\') {</a>
<a name="ln5676">      *q++ = '\\';</a>
<a name="ln5677">      *q++ = '\\';</a>
<a name="ln5678">      p += 2;</a>
<a name="ln5679">    } else if (p[0] == '\\' &amp;&amp; ascii_iswhite(p[1])) {</a>
<a name="ln5680">      *q++ = p[1];</a>
<a name="ln5681">      p += 2;</a>
<a name="ln5682">    } else if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5683">      *q++ = '\\';</a>
<a name="ln5684">      *q++ = *p++;</a>
<a name="ln5685">    } else if (ascii_iswhite(*p)) {</a>
<a name="ln5686">      p = skipwhite(p);</a>
<a name="ln5687">      if (*p == NUL)</a>
<a name="ln5688">        break;</a>
<a name="ln5689">      *q++ = '&quot;';</a>
<a name="ln5690">      *q++ = ',';</a>
<a name="ln5691">      *q++ = '&quot;';</a>
<a name="ln5692">    } else {</a>
<a name="ln5693">      MB_COPY_CHAR(p, q);</a>
<a name="ln5694">    }</a>
<a name="ln5695">  }</a>
<a name="ln5696">  *q++ = '&quot;';</a>
<a name="ln5697">  *q = 0;</a>
<a name="ln5698"> </a>
<a name="ln5699">  *lenp = len;</a>
<a name="ln5700">  return buf;</a>
<a name="ln5701">}</a>
<a name="ln5702"> </a>
<a name="ln5703">static size_t add_cmd_modifier(char_u *buf, char *mod_str, bool *multi_mods)</a>
<a name="ln5704">{</a>
<a name="ln5705">  size_t result = STRLEN(mod_str);</a>
<a name="ln5706">  if (*multi_mods) {</a>
<a name="ln5707">    result++;</a>
<a name="ln5708">  }</a>
<a name="ln5709"> </a>
<a name="ln5710">  if (buf != NULL) {</a>
<a name="ln5711">    if (*multi_mods) {</a>
<a name="ln5712">      STRCAT(buf, &quot; &quot;);</a>
<a name="ln5713">    }</a>
<a name="ln5714">    STRCAT(buf, mod_str);</a>
<a name="ln5715">  }</a>
<a name="ln5716"> </a>
<a name="ln5717">  *multi_mods = true;</a>
<a name="ln5718">  return result;</a>
<a name="ln5719">}</a>
<a name="ln5720"> </a>
<a name="ln5721">/*</a>
<a name="ln5722"> * Check for a &lt;&gt; code in a user command.</a>
<a name="ln5723"> * &quot;code&quot; points to the '&lt;'.  &quot;len&quot; the length of the &lt;&gt; (inclusive).</a>
<a name="ln5724"> * &quot;buf&quot; is where the result is to be added.</a>
<a name="ln5725"> * &quot;split_buf&quot; points to a buffer used for splitting, caller should free it.</a>
<a name="ln5726"> * &quot;split_len&quot; is the length of what &quot;split_buf&quot; contains.</a>
<a name="ln5727"> * Returns the length of the replacement, which has been added to &quot;buf&quot;.</a>
<a name="ln5728"> * Returns -1 if there was no match, and only the &quot;&lt;&quot; has been copied.</a>
<a name="ln5729"> */</a>
<a name="ln5730">static size_t</a>
<a name="ln5731">uc_check_code(</a>
<a name="ln5732">    char_u *code,</a>
<a name="ln5733">    size_t len,</a>
<a name="ln5734">    char_u *buf,</a>
<a name="ln5735">    ucmd_T *cmd,               /* the user command we're expanding */</a>
<a name="ln5736">    exarg_T *eap,               /* ex arguments */</a>
<a name="ln5737">    char_u **split_buf,</a>
<a name="ln5738">    size_t *split_len</a>
<a name="ln5739">)</a>
<a name="ln5740">{</a>
<a name="ln5741">  size_t result = 0;</a>
<a name="ln5742">  char_u      *p = code + 1;</a>
<a name="ln5743">  size_t l = len - 2;</a>
<a name="ln5744">  int quote = 0;</a>
<a name="ln5745">  enum {</a>
<a name="ln5746">    ct_ARGS,</a>
<a name="ln5747">    ct_BANG,</a>
<a name="ln5748">    ct_COUNT,</a>
<a name="ln5749">    ct_LINE1,</a>
<a name="ln5750">    ct_LINE2,</a>
<a name="ln5751">    ct_RANGE,</a>
<a name="ln5752">    ct_MODS,</a>
<a name="ln5753">    ct_REGISTER,</a>
<a name="ln5754">    ct_LT,</a>
<a name="ln5755">    ct_NONE</a>
<a name="ln5756">  } type = ct_NONE;</a>
<a name="ln5757"> </a>
<a name="ln5758">  if ((vim_strchr((char_u *)&quot;qQfF&quot;, *p) != NULL) &amp;&amp; p[1] == '-') {</a>
<a name="ln5759">    quote = (*p == 'q' || *p == 'Q') ? 1 : 2;</a>
<a name="ln5760">    p += 2;</a>
<a name="ln5761">    l -= 2;</a>
<a name="ln5762">  }</a>
<a name="ln5763"> </a>
<a name="ln5764">  l++;</a>
<a name="ln5765">  if (l &lt;= 1) {</a>
<a name="ln5766">    type = ct_NONE;</a>
<a name="ln5767">  } else if (STRNICMP(p, &quot;args&gt;&quot;, l) == 0) {</a>
<a name="ln5768">    type = ct_ARGS;</a>
<a name="ln5769">  } else if (STRNICMP(p, &quot;bang&gt;&quot;, l) == 0) {</a>
<a name="ln5770">    type = ct_BANG;</a>
<a name="ln5771">  } else if (STRNICMP(p, &quot;count&gt;&quot;, l) == 0) {</a>
<a name="ln5772">    type = ct_COUNT;</a>
<a name="ln5773">  } else if (STRNICMP(p, &quot;line1&gt;&quot;, l) == 0) {</a>
<a name="ln5774">    type = ct_LINE1;</a>
<a name="ln5775">  } else if (STRNICMP(p, &quot;line2&gt;&quot;, l) == 0) {</a>
<a name="ln5776">    type = ct_LINE2;</a>
<a name="ln5777">  } else if (STRNICMP(p, &quot;range&gt;&quot;, l) == 0) {</a>
<a name="ln5778">    type = ct_RANGE;</a>
<a name="ln5779">  } else if (STRNICMP(p, &quot;lt&gt;&quot;, l) == 0) {</a>
<a name="ln5780">    type = ct_LT;</a>
<a name="ln5781">  } else if (STRNICMP(p, &quot;reg&gt;&quot;, l) == 0 || STRNICMP(p, &quot;register&gt;&quot;, l) == 0) {</a>
<a name="ln5782">    type = ct_REGISTER;</a>
<a name="ln5783">  } else if (STRNICMP(p, &quot;mods&gt;&quot;, l) == 0) {</a>
<a name="ln5784">    type = ct_MODS;</a>
<a name="ln5785">  }</a>
<a name="ln5786"> </a>
<a name="ln5787">  switch (type) {</a>
<a name="ln5788">  case ct_ARGS:</a>
<a name="ln5789">    /* Simple case first */</a>
<a name="ln5790">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln5791">      if (quote == 1) {</a>
<a name="ln5792">        result = 2;</a>
<a name="ln5793">        if (buf != NULL)</a>
<a name="ln5794">          STRCPY(buf, &quot;''&quot;);</a>
<a name="ln5795">      } else</a>
<a name="ln5796">        result = 0;</a>
<a name="ln5797">      break;</a>
<a name="ln5798">    }</a>
<a name="ln5799"> </a>
<a name="ln5800">    /* When specified there is a single argument don't split it.</a>
<a name="ln5801">     * Works for &quot;:Cmd %&quot; when % is &quot;a b c&quot;. */</a>
<a name="ln5802">    if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; quote == 2) {</a>
<a name="ln5803">      quote = 1;</a>
<a name="ln5804">    }</a>
<a name="ln5805"> </a>
<a name="ln5806">    switch (quote) {</a>
<a name="ln5807">    case 0:     /* No quoting, no splitting */</a>
<a name="ln5808">      result = STRLEN(eap-&gt;arg);</a>
<a name="ln5809">      if (buf != NULL)</a>
<a name="ln5810">        STRCPY(buf, eap-&gt;arg);</a>
<a name="ln5811">      break;</a>
<a name="ln5812">    case 1:     /* Quote, but don't split */</a>
<a name="ln5813">      result = STRLEN(eap-&gt;arg) + 2;</a>
<a name="ln5814">      for (p = eap-&gt;arg; *p; p++) {</a>
<a name="ln5815">        if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5816">          result++;</a>
<a name="ln5817">        }</a>
<a name="ln5818">      }</a>
<a name="ln5819"> </a>
<a name="ln5820">      if (buf != NULL) {</a>
<a name="ln5821">        *buf++ = '&quot;';</a>
<a name="ln5822">        for (p = eap-&gt;arg; *p; p++) {</a>
<a name="ln5823">          if (*p == '\\' || *p == '&quot;') {</a>
<a name="ln5824">            *buf++ = '\\';</a>
<a name="ln5825">          }</a>
<a name="ln5826">          *buf++ = *p;</a>
<a name="ln5827">        }</a>
<a name="ln5828">        *buf = '&quot;';</a>
<a name="ln5829">      }</a>
<a name="ln5830"> </a>
<a name="ln5831">      break;</a>
<a name="ln5832">    case 2:     /* Quote and split (&lt;f-args&gt;) */</a>
<a name="ln5833">      /* This is hard, so only do it once, and cache the result */</a>
<a name="ln5834">      if (*split_buf == NULL)</a>
<a name="ln5835">        *split_buf = uc_split_args(eap-&gt;arg, split_len);</a>
<a name="ln5836"> </a>
<a name="ln5837">      result = *split_len;</a>
<a name="ln5838">      if (buf != NULL &amp;&amp; result != 0)</a>
<a name="ln5839">        STRCPY(buf, *split_buf);</a>
<a name="ln5840"> </a>
<a name="ln5841">      break;</a>
<a name="ln5842">    }</a>
<a name="ln5843">    break;</a>
<a name="ln5844"> </a>
<a name="ln5845">  case ct_BANG:</a>
<a name="ln5846">    result = eap-&gt;forceit ? 1 : 0;</a>
<a name="ln5847">    if (quote)</a>
<a name="ln5848">      result += 2;</a>
<a name="ln5849">    if (buf != NULL) {</a>
<a name="ln5850">      if (quote)</a>
<a name="ln5851">        *buf++ = '&quot;';</a>
<a name="ln5852">      if (eap-&gt;forceit)</a>
<a name="ln5853">        *buf++ = '!';</a>
<a name="ln5854">      if (quote)</a>
<a name="ln5855">        *buf = '&quot;';</a>
<a name="ln5856">    }</a>
<a name="ln5857">    break;</a>
<a name="ln5858"> </a>
<a name="ln5859">  case ct_LINE1:</a>
<a name="ln5860">  case ct_LINE2:</a>
<a name="ln5861">  case ct_RANGE:</a>
<a name="ln5862">  case ct_COUNT:</a>
<a name="ln5863">  {</a>
<a name="ln5864">    char num_buf[20];</a>
<a name="ln5865">    long num = (type == ct_LINE1) ? eap-&gt;line1 :</a>
<a name="ln5866">               (type == ct_LINE2) ? eap-&gt;line2 :</a>
<a name="ln5867">               (type == ct_RANGE) ? eap-&gt;addr_count :</a>
<a name="ln5868">               (eap-&gt;addr_count &gt; 0) ? eap-&gt;line2 : cmd-&gt;uc_def;</a>
<a name="ln5869">    size_t num_len;</a>
<a name="ln5870"> </a>
<a name="ln5871">    sprintf(num_buf, &quot;%&quot; PRId64, (int64_t)num);</a>
<a name="ln5872">    num_len = STRLEN(num_buf);</a>
<a name="ln5873">    result = num_len;</a>
<a name="ln5874"> </a>
<a name="ln5875">    if (quote)</a>
<a name="ln5876">      result += 2;</a>
<a name="ln5877"> </a>
<a name="ln5878">    if (buf != NULL) {</a>
<a name="ln5879">      if (quote)</a>
<a name="ln5880">        *buf++ = '&quot;';</a>
<a name="ln5881">      STRCPY(buf, num_buf);</a>
<a name="ln5882">      buf += num_len;</a>
<a name="ln5883">      if (quote)</a>
<a name="ln5884">        *buf = '&quot;';</a>
<a name="ln5885">    }</a>
<a name="ln5886"> </a>
<a name="ln5887">    break;</a>
<a name="ln5888">  }</a>
<a name="ln5889"> </a>
<a name="ln5890">  case ct_MODS:</a>
<a name="ln5891">  {</a>
<a name="ln5892">    result = quote ? 2 : 0;</a>
<a name="ln5893">    if (buf != NULL) {</a>
<a name="ln5894">      if (quote) {</a>
<a name="ln5895">        *buf++ = '&quot;';</a>
<a name="ln5896">      }</a>
<a name="ln5897">      *buf = '\0';</a>
<a name="ln5898">    }</a>
<a name="ln5899"> </a>
<a name="ln5900">    bool multi_mods = false;</a>
<a name="ln5901"> </a>
<a name="ln5902">    // :aboveleft and :leftabove</a>
<a name="ln5903">    if (cmdmod.split &amp; WSP_ABOVE) {</a>
<a name="ln5904">      result += add_cmd_modifier(buf, &quot;aboveleft&quot;, &amp;multi_mods);</a>
<a name="ln5905">    }</a>
<a name="ln5906">    // :belowright and :rightbelow</a>
<a name="ln5907">    if (cmdmod.split &amp; WSP_BELOW) {</a>
<a name="ln5908">      result += add_cmd_modifier(buf, &quot;belowright&quot;, &amp;multi_mods);</a>
<a name="ln5909">    }</a>
<a name="ln5910">    // :botright</a>
<a name="ln5911">    if (cmdmod.split &amp; WSP_BOT) {</a>
<a name="ln5912">      result += add_cmd_modifier(buf, &quot;botright&quot;, &amp;multi_mods);</a>
<a name="ln5913">    }</a>
<a name="ln5914"> </a>
<a name="ln5915">    typedef struct {</a>
<a name="ln5916">      bool *set;</a>
<a name="ln5917">      char *name;</a>
<a name="ln5918">    } mod_entry_T;</a>
<a name="ln5919">    static mod_entry_T mod_entries[] = {</a>
<a name="ln5920">      { &amp;cmdmod.browse, &quot;browse&quot; },</a>
<a name="ln5921">      { &amp;cmdmod.confirm, &quot;confirm&quot; },</a>
<a name="ln5922">      { &amp;cmdmod.hide, &quot;hide&quot; },</a>
<a name="ln5923">      { &amp;cmdmod.keepalt, &quot;keepalt&quot; },</a>
<a name="ln5924">      { &amp;cmdmod.keepjumps, &quot;keepjumps&quot; },</a>
<a name="ln5925">      { &amp;cmdmod.keepmarks, &quot;keepmarks&quot; },</a>
<a name="ln5926">      { &amp;cmdmod.keeppatterns, &quot;keeppatterns&quot; },</a>
<a name="ln5927">      { &amp;cmdmod.lockmarks, &quot;lockmarks&quot; },</a>
<a name="ln5928">      { &amp;cmdmod.noswapfile, &quot;noswapfile&quot; }</a>
<a name="ln5929">    };</a>
<a name="ln5930">    // the modifiers that are simple flags</a>
<a name="ln5931">    for (size_t i = 0; i &lt; ARRAY_SIZE(mod_entries); i++) {</a>
<a name="ln5932">      if (*mod_entries[i].set) {</a>
<a name="ln5933">        result += add_cmd_modifier(buf, mod_entries[i].name, &amp;multi_mods);</a>
<a name="ln5934">      }</a>
<a name="ln5935">    }</a>
<a name="ln5936"> </a>
<a name="ln5937">    // TODO(vim): How to support :noautocmd?</a>
<a name="ln5938">    // TODO(vim): How to support :sandbox?</a>
<a name="ln5939"> </a>
<a name="ln5940">    // :silent</a>
<a name="ln5941">    if (msg_silent &gt; 0) {</a>
<a name="ln5942">      result += add_cmd_modifier(buf, emsg_silent &gt; 0 ? &quot;silent!&quot; : &quot;silent&quot;,</a>
<a name="ln5943">                                 &amp;multi_mods);</a>
<a name="ln5944">    }</a>
<a name="ln5945">    // :tab</a>
<a name="ln5946">    if (cmdmod.tab &gt; 0) {</a>
<a name="ln5947">      result += add_cmd_modifier(buf, &quot;tab&quot;, &amp;multi_mods);</a>
<a name="ln5948">    }</a>
<a name="ln5949">    // :topleft</a>
<a name="ln5950">    if (cmdmod.split &amp; WSP_TOP) {</a>
<a name="ln5951">      result += add_cmd_modifier(buf, &quot;topleft&quot;, &amp;multi_mods);</a>
<a name="ln5952">    }</a>
<a name="ln5953"> </a>
<a name="ln5954">    // TODO(vim): How to support :unsilent?</a>
<a name="ln5955"> </a>
<a name="ln5956">    // :verbose</a>
<a name="ln5957">    if (p_verbose &gt; 0) {</a>
<a name="ln5958">      result += add_cmd_modifier(buf, &quot;verbose&quot;, &amp;multi_mods);</a>
<a name="ln5959">    }</a>
<a name="ln5960">    // :vertical</a>
<a name="ln5961">    if (cmdmod.split &amp; WSP_VERT) {</a>
<a name="ln5962">      result += add_cmd_modifier(buf, &quot;vertical&quot;, &amp;multi_mods);</a>
<a name="ln5963">    }</a>
<a name="ln5964">    if (quote &amp;&amp; buf != NULL) {</a>
<a name="ln5965">      buf += result - 2;</a>
<a name="ln5966">      *buf = '&quot;';</a>
<a name="ln5967">    }</a>
<a name="ln5968">    break;</a>
<a name="ln5969">  }</a>
<a name="ln5970"> </a>
<a name="ln5971">  case ct_REGISTER:</a>
<a name="ln5972">    result = eap-&gt;regname ? 1 : 0;</a>
<a name="ln5973">    if (quote)</a>
<a name="ln5974">      result += 2;</a>
<a name="ln5975">    if (buf != NULL) {</a>
<a name="ln5976">      if (quote)</a>
<a name="ln5977">        *buf++ = '\'';</a>
<a name="ln5978">      if (eap-&gt;regname)</a>
<a name="ln5979">        *buf++ = eap-&gt;regname;</a>
<a name="ln5980">      if (quote)</a>
<a name="ln5981">        *buf = '\'';</a>
<a name="ln5982">    }</a>
<a name="ln5983">    break;</a>
<a name="ln5984"> </a>
<a name="ln5985">  case ct_LT:</a>
<a name="ln5986">    result = 1;</a>
<a name="ln5987">    if (buf != NULL)</a>
<a name="ln5988">      *buf = '&lt;';</a>
<a name="ln5989">    break;</a>
<a name="ln5990"> </a>
<a name="ln5991">  default:</a>
<a name="ln5992">    /* Not recognized: just copy the '&lt;' and return -1. */</a>
<a name="ln5993">    result = (size_t)-1;</a>
<a name="ln5994">    if (buf != NULL)</a>
<a name="ln5995">      *buf = '&lt;';</a>
<a name="ln5996">    break;</a>
<a name="ln5997">  }</a>
<a name="ln5998"> </a>
<a name="ln5999">  return result;</a>
<a name="ln6000">}</a>
<a name="ln6001"> </a>
<a name="ln6002">static void do_ucmd(exarg_T *eap)</a>
<a name="ln6003">{</a>
<a name="ln6004">  char_u      *buf;</a>
<a name="ln6005">  char_u      *p;</a>
<a name="ln6006">  char_u      *q;</a>
<a name="ln6007"> </a>
<a name="ln6008">  char_u      *start;</a>
<a name="ln6009">  char_u      *end = NULL;</a>
<a name="ln6010">  char_u      *ksp;</a>
<a name="ln6011">  size_t len, totlen;</a>
<a name="ln6012"> </a>
<a name="ln6013">  size_t split_len = 0;</a>
<a name="ln6014">  char_u      *split_buf = NULL;</a>
<a name="ln6015">  ucmd_T      *cmd;</a>
<a name="ln6016">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln6017"> </a>
<a name="ln6018">  if (eap-&gt;cmdidx == CMD_USER)</a>
<a name="ln6019">    cmd = USER_CMD(eap-&gt;useridx);</a>
<a name="ln6020">  else</a>
<a name="ln6021">    cmd = USER_CMD_GA(&amp;curbuf-&gt;b_ucmds, eap-&gt;useridx);</a>
<a name="ln6022"> </a>
<a name="ln6023">  /*</a>
<a name="ln6024">   * Replace &lt;&gt; in the command by the arguments.</a>
<a name="ln6025">   * First round: &quot;buf&quot; is NULL, compute length, allocate &quot;buf&quot;.</a>
<a name="ln6026">   * Second round: copy result into &quot;buf&quot;.</a>
<a name="ln6027">   */</a>
<a name="ln6028">  buf = NULL;</a>
<a name="ln6029">  for (;; ) {</a>
<a name="ln6030">    p = cmd-&gt;uc_rep;        /* source */</a>
<a name="ln6031">    q = buf;                /* destination */</a>
<a name="ln6032">    totlen = 0;</a>
<a name="ln6033"> </a>
<a name="ln6034">    for (;; ) {</a>
<a name="ln6035">      start = vim_strchr(p, '&lt;');</a>
<a name="ln6036">      if (start != NULL)</a>
<a name="ln6037">        end = vim_strchr(start + 1, '&gt;');</a>
<a name="ln6038">      if (buf != NULL) {</a>
<a name="ln6039">        for (ksp = p; *ksp != NUL &amp;&amp; *ksp != K_SPECIAL; ksp++) {</a>
<a name="ln6040">        }</a>
<a name="ln6041">        if (*ksp == K_SPECIAL</a>
<a name="ln6042">            &amp;&amp; (start == NULL || ksp &lt; start || end == NULL)</a>
<a name="ln6043">            &amp;&amp; (ksp[1] == KS_SPECIAL &amp;&amp; ksp[2] == KE_FILLER)) {</a>
<a name="ln6044">          // K_SPECIAL has been put in the buffer as K_SPECIAL</a>
<a name="ln6045">          // KS_SPECIAL KE_FILLER, like for mappings, but</a>
<a name="ln6046">          // do_cmdline() doesn't handle that, so convert it back.</a>
<a name="ln6047">          // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.</a>
<a name="ln6048">          len = ksp - p;</a>
<a name="ln6049">          if (len &gt; 0) {</a>
<a name="ln6050">            memmove(q, p, len);</a>
<a name="ln6051">            q += len;</a>
<a name="ln6052">          }</a>
<a name="ln6053">          *q++ = K_SPECIAL;</a>
<a name="ln6054">          p = ksp + 3;</a>
<a name="ln6055">          continue;</a>
<a name="ln6056">        }</a>
<a name="ln6057">      }</a>
<a name="ln6058"> </a>
<a name="ln6059">      /* break if there no &lt;item&gt; is found */</a>
<a name="ln6060">      if (start == NULL || end == NULL)</a>
<a name="ln6061">        break;</a>
<a name="ln6062"> </a>
<a name="ln6063">      /* Include the '&gt;' */</a>
<a name="ln6064">      ++end;</a>
<a name="ln6065"> </a>
<a name="ln6066">      /* Take everything up to the '&lt;' */</a>
<a name="ln6067">      len = start - p;</a>
<a name="ln6068">      if (buf == NULL)</a>
<a name="ln6069">        totlen += len;</a>
<a name="ln6070">      else {</a>
<a name="ln6071">        memmove(q, p, len);</a>
<a name="ln6072">        q += len;</a>
<a name="ln6073">      }</a>
<a name="ln6074"> </a>
<a name="ln6075">      len = uc_check_code(start, end - start, q, cmd, eap,</a>
<a name="ln6076">          &amp;split_buf, &amp;split_len);</a>
<a name="ln6077">      if (len == (size_t)-1) {</a>
<a name="ln6078">        /* no match, continue after '&lt;' */</a>
<a name="ln6079">        p = start + 1;</a>
<a name="ln6080">        len = 1;</a>
<a name="ln6081">      } else</a>
<a name="ln6082">        p = end;</a>
<a name="ln6083">      if (buf == NULL)</a>
<a name="ln6084">        totlen += len;</a>
<a name="ln6085">      else</a>
<a name="ln6086">        q += len;</a>
<a name="ln6087">    }</a>
<a name="ln6088">    if (buf != NULL) {              /* second time here, finished */</a>
<a name="ln6089">      STRCPY(q, p);</a>
<a name="ln6090">      break;</a>
<a name="ln6091">    }</a>
<a name="ln6092"> </a>
<a name="ln6093">    totlen += STRLEN(p);            /* Add on the trailing characters */</a>
<a name="ln6094">    buf = xmalloc(totlen + 1);</a>
<a name="ln6095">  }</a>
<a name="ln6096"> </a>
<a name="ln6097">  current_sctx.sc_sid = cmd-&gt;uc_script_ctx.sc_sid;</a>
<a name="ln6098">  (void)do_cmdline(buf, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln6099">                   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln6100">  current_sctx = save_current_sctx;</a>
<a name="ln6101">  xfree(buf);</a>
<a name="ln6102">  xfree(split_buf);</a>
<a name="ln6103">}</a>
<a name="ln6104"> </a>
<a name="ln6105">static char_u *get_user_command_name(int idx)</a>
<a name="ln6106">{</a>
<a name="ln6107">  return get_user_commands(NULL, idx - (int)CMD_SIZE);</a>
<a name="ln6108">}</a>
<a name="ln6109">/*</a>
<a name="ln6110"> * Function given to ExpandGeneric() to obtain the list of user address type names.</a>
<a name="ln6111"> */</a>
<a name="ln6112">char_u *get_user_cmd_addr_type(expand_T *xp, int idx)</a>
<a name="ln6113">{</a>
<a name="ln6114">  return (char_u *)addr_type_complete[idx].name;</a>
<a name="ln6115">}</a>
<a name="ln6116"> </a>
<a name="ln6117">/*</a>
<a name="ln6118"> * Function given to ExpandGeneric() to obtain the list of user command names.</a>
<a name="ln6119"> */</a>
<a name="ln6120">char_u *get_user_commands(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln6121">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6122">{</a>
<a name="ln6123">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln6124">  const buf_T *const buf = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln6125">    ? prevwin-&gt;w_buffer</a>
<a name="ln6126">    : curbuf;</a>
<a name="ln6127"> </a>
<a name="ln6128">  if (idx &lt; buf-&gt;b_ucmds.ga_len) {</a>
<a name="ln6129">    return USER_CMD_GA(&amp;buf-&gt;b_ucmds, idx)-&gt;uc_name;</a>
<a name="ln6130">  }</a>
<a name="ln6131">  idx -= buf-&gt;b_ucmds.ga_len;</a>
<a name="ln6132">  if (idx &lt; ucmds.ga_len) {</a>
<a name="ln6133">    return USER_CMD(idx)-&gt;uc_name;</a>
<a name="ln6134">  }</a>
<a name="ln6135">  return NULL;</a>
<a name="ln6136">}</a>
<a name="ln6137"> </a>
<a name="ln6138">/*</a>
<a name="ln6139"> * Function given to ExpandGeneric() to obtain the list of user command</a>
<a name="ln6140"> * attributes.</a>
<a name="ln6141"> */</a>
<a name="ln6142">char_u *get_user_cmd_flags(expand_T *xp, int idx)</a>
<a name="ln6143">{</a>
<a name="ln6144">  static char *user_cmd_flags[] = {&quot;addr&quot;,   &quot;bang&quot;,     &quot;bar&quot;,</a>
<a name="ln6145">                                   &quot;buffer&quot;, &quot;complete&quot;, &quot;count&quot;,</a>
<a name="ln6146">                                   &quot;nargs&quot;,  &quot;range&quot;,    &quot;register&quot;};</a>
<a name="ln6147"> </a>
<a name="ln6148">  if (idx &gt;= (int)ARRAY_SIZE(user_cmd_flags))</a>
<a name="ln6149">    return NULL;</a>
<a name="ln6150">  return (char_u *)user_cmd_flags[idx];</a>
<a name="ln6151">}</a>
<a name="ln6152"> </a>
<a name="ln6153">/*</a>
<a name="ln6154"> * Function given to ExpandGeneric() to obtain the list of values for -nargs.</a>
<a name="ln6155"> */</a>
<a name="ln6156">char_u *get_user_cmd_nargs(expand_T *xp, int idx)</a>
<a name="ln6157">{</a>
<a name="ln6158">  static char *user_cmd_nargs[] = {&quot;0&quot;, &quot;1&quot;, &quot;*&quot;, &quot;?&quot;, &quot;+&quot;};</a>
<a name="ln6159"> </a>
<a name="ln6160">  if (idx &gt;= (int)ARRAY_SIZE(user_cmd_nargs))</a>
<a name="ln6161">    return NULL;</a>
<a name="ln6162">  return (char_u *)user_cmd_nargs[idx];</a>
<a name="ln6163">}</a>
<a name="ln6164"> </a>
<a name="ln6165">/*</a>
<a name="ln6166"> * Function given to ExpandGeneric() to obtain the list of values for -complete.</a>
<a name="ln6167"> */</a>
<a name="ln6168">char_u *get_user_cmd_complete(expand_T *xp, int idx)</a>
<a name="ln6169">{</a>
<a name="ln6170">  if (idx &gt;= (int)ARRAY_SIZE(command_complete)) {</a>
<a name="ln6171">    return NULL;</a>
<a name="ln6172">  }</a>
<a name="ln6173">  char *cmd_compl = get_command_complete(idx);</a>
<a name="ln6174">  if (cmd_compl == NULL) {</a>
<a name="ln6175">    return (char_u *)&quot;&quot;;</a>
<a name="ln6176">  } else {</a>
<a name="ln6177">    return (char_u *)cmd_compl;</a>
<a name="ln6178">  }</a>
<a name="ln6179">}</a>
<a name="ln6180"> </a>
<a name="ln6181">/*</a>
<a name="ln6182"> * Parse address type argument</a>
<a name="ln6183"> */</a>
<a name="ln6184">int parse_addr_type_arg(char_u *value, int vallen, cmd_addr_T *addr_type_arg)</a>
<a name="ln6185">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6186">{</a>
<a name="ln6187">  int i, a, b;</a>
<a name="ln6188"> </a>
<a name="ln6189">  for (i = 0; addr_type_complete[i].expand != ADDR_NONE; i++) {</a>
<a name="ln6190">    a = (int)STRLEN(addr_type_complete[i].name) == vallen;</a>
<a name="ln6191">    b = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;</a>
<a name="ln6192">    if (a &amp;&amp; b) {</a>
<a name="ln6193">      *addr_type_arg = addr_type_complete[i].expand;</a>
<a name="ln6194">      break;</a>
<a name="ln6195">    }</a>
<a name="ln6196">  }</a>
<a name="ln6197"> </a>
<a name="ln6198">  if (addr_type_complete[i].expand == ADDR_NONE) {</a>
<a name="ln6199">    char_u *err = value;</a>
<a name="ln6200"> </a>
<a name="ln6201">    for (i = 0; err[i] != NUL &amp;&amp; !ascii_iswhite(err[i]); i++) {}</a>
<a name="ln6202">    err[i] = NUL;</a>
<a name="ln6203">    EMSG2(_(&quot;E180: Invalid address type value: %s&quot;), err);</a>
<a name="ln6204">    return FAIL;</a>
<a name="ln6205">  }</a>
<a name="ln6206"> </a>
<a name="ln6207">  return OK;</a>
<a name="ln6208">}</a>
<a name="ln6209"> </a>
<a name="ln6210">/*</a>
<a name="ln6211"> * Parse a completion argument &quot;value[vallen]&quot;.</a>
<a name="ln6212"> * The detected completion goes in &quot;*complp&quot;, argument type in &quot;*argt&quot;.</a>
<a name="ln6213"> * When there is an argument, for function and user defined completion, it's</a>
<a name="ln6214"> * copied to allocated memory and stored in &quot;*compl_arg&quot;.</a>
<a name="ln6215"> * Returns FAIL if something is wrong.</a>
<a name="ln6216"> */</a>
<a name="ln6217">int parse_compl_arg(const char_u *value, int vallen, int *complp,</a>
<a name="ln6218">                    uint32_t *argt, char_u **compl_arg)</a>
<a name="ln6219">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6220">{</a>
<a name="ln6221">  const char_u *arg = NULL;</a>
<a name="ln6222">  size_t arglen = 0;</a>
<a name="ln6223">  int i;</a>
<a name="ln6224">  int valend = vallen;</a>
<a name="ln6225"> </a>
<a name="ln6226">  /* Look for any argument part - which is the part after any ',' */</a>
<a name="ln6227">  for (i = 0; i &lt; vallen; ++i) {</a>
<a name="ln6228">    if (value[i] == ',') {</a>
<a name="ln6229">      arg = &amp;value[i + 1];</a>
<a name="ln6230">      arglen = vallen - i - 1;</a>
<a name="ln6231">      valend = i;</a>
<a name="ln6232">      break;</a>
<a name="ln6233">    }</a>
<a name="ln6234">  }</a>
<a name="ln6235"> </a>
<a name="ln6236">  for (i = 0; i &lt; (int)ARRAY_SIZE(command_complete); i++) {</a>
<a name="ln6237">    if (get_command_complete(i) == NULL) {</a>
<a name="ln6238">      continue;</a>
<a name="ln6239">    }</a>
<a name="ln6240">    if ((int)STRLEN(command_complete[i]) == valend</a>
<a name="ln6241">        &amp;&amp; STRNCMP(value, command_complete[i], valend) == 0) {</a>
<a name="ln6242">      *complp = i;</a>
<a name="ln6243">      if (i == EXPAND_BUFFERS) {</a>
<a name="ln6244">        *argt |= EX_BUFNAME;</a>
<a name="ln6245">      } else if (i == EXPAND_DIRECTORIES || i == EXPAND_FILES) {</a>
<a name="ln6246">        *argt |= EX_XFILE;</a>
<a name="ln6247">      }</a>
<a name="ln6248">      break;</a>
<a name="ln6249">    }</a>
<a name="ln6250">  }</a>
<a name="ln6251"> </a>
<a name="ln6252">  if (i == (int)ARRAY_SIZE(command_complete)) {</a>
<a name="ln6253">    EMSG2(_(&quot;E180: Invalid complete value: %s&quot;), value);</a>
<a name="ln6254">    return FAIL;</a>
<a name="ln6255">  }</a>
<a name="ln6256"> </a>
<a name="ln6257">  if (*complp != EXPAND_USER_DEFINED &amp;&amp; *complp != EXPAND_USER_LIST</a>
<a name="ln6258">      &amp;&amp; arg != NULL) {</a>
<a name="ln6259">    EMSG(_(&quot;E468: Completion argument only allowed for custom completion&quot;));</a>
<a name="ln6260">    return FAIL;</a>
<a name="ln6261">  }</a>
<a name="ln6262"> </a>
<a name="ln6263">  if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)</a>
<a name="ln6264">      &amp;&amp; arg == NULL) {</a>
<a name="ln6265">    EMSG(_(&quot;E467: Custom completion requires a function argument&quot;));</a>
<a name="ln6266">    return FAIL;</a>
<a name="ln6267">  }</a>
<a name="ln6268"> </a>
<a name="ln6269">  if (arg != NULL) {</a>
<a name="ln6270">    *compl_arg = vim_strnsave(arg, arglen);</a>
<a name="ln6271">  }</a>
<a name="ln6272">  return OK;</a>
<a name="ln6273">}</a>
<a name="ln6274"> </a>
<a name="ln6275">int cmdcomplete_str_to_type(char_u *complete_str)</a>
<a name="ln6276">{</a>
<a name="ln6277">    for (int i = 0; i &lt; (int)(ARRAY_SIZE(command_complete)); i++) {</a>
<a name="ln6278">      char *cmd_compl = get_command_complete(i);</a>
<a name="ln6279">      if (cmd_compl == NULL) {</a>
<a name="ln6280">        continue;</a>
<a name="ln6281">      }</a>
<a name="ln6282">      if (STRCMP(complete_str, command_complete[i]) == 0) {</a>
<a name="ln6283">        return i;</a>
<a name="ln6284">      }</a>
<a name="ln6285">    }</a>
<a name="ln6286"> </a>
<a name="ln6287">    return EXPAND_NOTHING;</a>
<a name="ln6288">}</a>
<a name="ln6289"> </a>
<a name="ln6290">static void ex_colorscheme(exarg_T *eap)</a>
<a name="ln6291">{</a>
<a name="ln6292">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln6293">    char_u *expr = vim_strsave((char_u *)&quot;g:colors_name&quot;);</a>
<a name="ln6294">    char_u *p = NULL;</a>
<a name="ln6295"> </a>
<a name="ln6296">    ++emsg_off;</a>
<a name="ln6297">    p = eval_to_string(expr, NULL, FALSE);</a>
<a name="ln6298">    --emsg_off;</a>
<a name="ln6299">    xfree(expr);</a>
<a name="ln6300"> </a>
<a name="ln6301">    if (p != NULL) {</a>
<a name="ln6302">      MSG(p);</a>
<a name="ln6303">      xfree(p);</a>
<a name="ln6304">    } else</a>
<a name="ln6305">      MSG(&quot;default&quot;);</a>
<a name="ln6306">  } else if (load_colors(eap-&gt;arg) == FAIL)</a>
<a name="ln6307">    EMSG2(_(&quot;E185: Cannot find color scheme '%s'&quot;), eap-&gt;arg);</a>
<a name="ln6308">}</a>
<a name="ln6309"> </a>
<a name="ln6310">static void ex_highlight(exarg_T *eap)</a>
<a name="ln6311">{</a>
<a name="ln6312">  if (*eap-&gt;arg == NUL &amp;&amp; eap-&gt;cmd[2] == '!') {</a>
<a name="ln6313">    MSG(_(&quot;Greetings, Vim user!&quot;));</a>
<a name="ln6314">  }</a>
<a name="ln6315">  do_highlight((const char *)eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318"> </a>
<a name="ln6319">/*</a>
<a name="ln6320"> * Call this function if we thought we were going to exit, but we won't</a>
<a name="ln6321"> * (because of an error).  May need to restore the terminal mode.</a>
<a name="ln6322"> */</a>
<a name="ln6323">void not_exiting(void)</a>
<a name="ln6324">{</a>
<a name="ln6325">  exiting = false;</a>
<a name="ln6326">}</a>
<a name="ln6327"> </a>
<a name="ln6328">static bool before_quit_autocmds(win_T *wp, bool quit_all, int forceit)</a>
<a name="ln6329">{</a>
<a name="ln6330">  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp-&gt;w_buffer);</a>
<a name="ln6331"> </a>
<a name="ln6332">  // Bail out when autocommands closed the window.</a>
<a name="ln6333">  // Refuse to quit when the buffer in the last window is being closed (can</a>
<a name="ln6334">  // only happen in autocommands).</a>
<a name="ln6335">  if (!win_valid(wp)</a>
<a name="ln6336">      || curbuf_locked()</a>
<a name="ln6337">      || (wp-&gt;w_buffer-&gt;b_nwindows == 1 &amp;&amp; wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln6338">    return true;</a>
<a name="ln6339">  }</a>
<a name="ln6340"> </a>
<a name="ln6341">  if (quit_all</a>
<a name="ln6342">      || (check_more(false, forceit) == OK &amp;&amp; only_one_window())) {</a>
<a name="ln6343">    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);</a>
<a name="ln6344">    // Refuse to quit when locked or when the window was closed or the</a>
<a name="ln6345">    // buffer in the last window is being closed (can only happen in</a>
<a name="ln6346">    // autocommands).</a>
<a name="ln6347">    if (!win_valid(wp)</a>
<a name="ln6348">        || curbuf_locked()</a>
<a name="ln6349">        || (curbuf-&gt;b_nwindows == 1 &amp;&amp; curbuf-&gt;b_locked &gt; 0)) {</a>
<a name="ln6350">      return true;</a>
<a name="ln6351">    }</a>
<a name="ln6352">  }</a>
<a name="ln6353"> </a>
<a name="ln6354">  return false;</a>
<a name="ln6355">}</a>
<a name="ln6356"> </a>
<a name="ln6357">// &quot;:quit&quot;: quit current window, quit Vim if the last window is closed.</a>
<a name="ln6358">// &quot;:{nr}quit&quot;: quit window {nr}</a>
<a name="ln6359">static void ex_quit(exarg_T *eap)</a>
<a name="ln6360">{</a>
<a name="ln6361">  if (cmdwin_type != 0) {</a>
<a name="ln6362">    cmdwin_result = Ctrl_C;</a>
<a name="ln6363">    return;</a>
<a name="ln6364">  }</a>
<a name="ln6365">  /* Don't quit while editing the command line. */</a>
<a name="ln6366">  if (text_locked()) {</a>
<a name="ln6367">    text_locked_msg();</a>
<a name="ln6368">    return;</a>
<a name="ln6369">  }</a>
<a name="ln6370"> </a>
<a name="ln6371">  win_T *wp;</a>
<a name="ln6372"> </a>
<a name="ln6373">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln6374">    int wnr = eap-&gt;line2;</a>
<a name="ln6375"> </a>
<a name="ln6376">    for (wp = firstwin; wp-&gt;w_next != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln6377">      if (--wnr &lt;= 0)</a>
<a name="ln6378">        break;</a>
<a name="ln6379">    }</a>
<a name="ln6380">  } else {</a>
<a name="ln6381">    wp = curwin;</a>
<a name="ln6382">  }</a>
<a name="ln6383"> </a>
<a name="ln6384">  // Refuse to quit when locked.</a>
<a name="ln6385">  if (curbuf_locked()) {</a>
<a name="ln6386">    return;</a>
<a name="ln6387">  }</a>
<a name="ln6388"> </a>
<a name="ln6389">  // Trigger QuitPre and maybe ExitPre</a>
<a name="ln6390">  if (before_quit_autocmds(wp, false, eap-&gt;forceit)) {</a>
<a name="ln6391">    return;</a>
<a name="ln6392">  }</a>
<a name="ln6393"> </a>
<a name="ln6394">  // If there are more files or windows we won't exit.</a>
<a name="ln6395">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln6396">    exiting = true;</a>
<a name="ln6397">  }</a>
<a name="ln6398">  if ((!buf_hide(wp-&gt;w_buffer)</a>
<a name="ln6399">       &amp;&amp; check_changed(wp-&gt;w_buffer, (p_awa ? CCGD_AW : 0)</a>
<a name="ln6400">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln6401">                        | CCGD_EXCMD))</a>
<a name="ln6402">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln6403">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, true))) {</a>
<a name="ln6404">    not_exiting();</a>
<a name="ln6405">  } else {</a>
<a name="ln6406">    // quit last window</a>
<a name="ln6407">    // Note: only_one_window() returns true, even so a help window is</a>
<a name="ln6408">    // still open. In that case only quit, if no address has been</a>
<a name="ln6409">    // specified. Example:</a>
<a name="ln6410">    // :h|wincmd w|1q     - don't quit</a>
<a name="ln6411">    // :h|wincmd w|q      - quit</a>
<a name="ln6412">    if (only_one_window() &amp;&amp; (ONE_WINDOW || eap-&gt;addr_count == 0)) {</a>
<a name="ln6413">      getout(0);</a>
<a name="ln6414">    }</a>
<a name="ln6415">    not_exiting();</a>
<a name="ln6416">    // close window; may free buffer</a>
<a name="ln6417">    win_close(wp, !buf_hide(wp-&gt;w_buffer) || eap-&gt;forceit);</a>
<a name="ln6418">  }</a>
<a name="ln6419">}</a>
<a name="ln6420"> </a>
<a name="ln6421">/// &quot;:cquit&quot;.</a>
<a name="ln6422">static void ex_cquit(exarg_T *eap)</a>
<a name="ln6423">{</a>
<a name="ln6424">  // this does not always pass on the exit code to the Manx compiler. why?</a>
<a name="ln6425">  getout(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : EXIT_FAILURE);</a>
<a name="ln6426">}</a>
<a name="ln6427"> </a>
<a name="ln6428">/// &quot;:qall&quot;: try to quit all windows</a>
<a name="ln6429">static void ex_quit_all(exarg_T *eap)</a>
<a name="ln6430">{</a>
<a name="ln6431">  if (cmdwin_type != 0) {</a>
<a name="ln6432">    if (eap-&gt;forceit) {</a>
<a name="ln6433">      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this</a>
<a name="ln6434">    } else {</a>
<a name="ln6435">      cmdwin_result = K_XF2;</a>
<a name="ln6436">    }</a>
<a name="ln6437">    return;</a>
<a name="ln6438">  }</a>
<a name="ln6439"> </a>
<a name="ln6440">  /* Don't quit while editing the command line. */</a>
<a name="ln6441">  if (text_locked()) {</a>
<a name="ln6442">    text_locked_msg();</a>
<a name="ln6443">    return;</a>
<a name="ln6444">  }</a>
<a name="ln6445"> </a>
<a name="ln6446">  if (before_quit_autocmds(curwin, true, eap-&gt;forceit)) {</a>
<a name="ln6447">    return;</a>
<a name="ln6448">  }</a>
<a name="ln6449"> </a>
<a name="ln6450">  exiting = true;</a>
<a name="ln6451">  if (eap-&gt;forceit || !check_changed_any(false, false)) {</a>
<a name="ln6452">    getout(0);</a>
<a name="ln6453">  }</a>
<a name="ln6454">  not_exiting();</a>
<a name="ln6455">}</a>
<a name="ln6456"> </a>
<a name="ln6457">/*</a>
<a name="ln6458"> * &quot;:close&quot;: close current window, unless it is the last one</a>
<a name="ln6459"> */</a>
<a name="ln6460">static void ex_close(exarg_T *eap)</a>
<a name="ln6461">{</a>
<a name="ln6462">  win_T *win = NULL;</a>
<a name="ln6463">  int winnr = 0;</a>
<a name="ln6464">  if (cmdwin_type != 0) {</a>
<a name="ln6465">    cmdwin_result = Ctrl_C;</a>
<a name="ln6466">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln6467">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln6468">      ex_win_close(eap-&gt;forceit, curwin, NULL);</a>
<a name="ln6469">    } else {</a>
<a name="ln6470">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6471">        winnr++;</a>
<a name="ln6472">        if (winnr == eap-&gt;line2) {</a>
<a name="ln6473">          win = wp;</a>
<a name="ln6474">          break;</a>
<a name="ln6475">        }</a>
<a name="ln6476">      }</a>
<a name="ln6477">      if (win == NULL)</a>
<a name="ln6478">        win = lastwin;</a>
<a name="ln6479">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln6480">    }</a>
<a name="ln6481">  }</a>
<a name="ln6482">}</a>
<a name="ln6483"> </a>
<a name="ln6484">/*</a>
<a name="ln6485"> * &quot;:pclose&quot;: Close any preview window.</a>
<a name="ln6486"> */</a>
<a name="ln6487">static void ex_pclose(exarg_T *eap)</a>
<a name="ln6488">{</a>
<a name="ln6489">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln6490">    if (win-&gt;w_p_pvw) {</a>
<a name="ln6491">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln6492">      break;</a>
<a name="ln6493">    }</a>
<a name="ln6494">  }</a>
<a name="ln6495">}</a>
<a name="ln6496"> </a>
<a name="ln6497">/*</a>
<a name="ln6498"> * Close window &quot;win&quot; and take care of handling closing the last window for a</a>
<a name="ln6499"> * modified buffer.</a>
<a name="ln6500"> */</a>
<a name="ln6501">void</a>
<a name="ln6502">ex_win_close(</a>
<a name="ln6503">    int forceit,</a>
<a name="ln6504">    win_T *win,</a>
<a name="ln6505">    tabpage_T *tp                /* NULL or the tab page &quot;win&quot; is in */</a>
<a name="ln6506">)</a>
<a name="ln6507">{</a>
<a name="ln6508">  int need_hide;</a>
<a name="ln6509">  buf_T       *buf = win-&gt;w_buffer;</a>
<a name="ln6510"> </a>
<a name="ln6511">  need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln6512">  if (need_hide &amp;&amp; !buf_hide(buf) &amp;&amp; !forceit) {</a>
<a name="ln6513">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln6514">      bufref_T bufref;</a>
<a name="ln6515">      set_bufref(&amp;bufref, buf);</a>
<a name="ln6516">      dialog_changed(buf, false);</a>
<a name="ln6517">      if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln6518">        return;</a>
<a name="ln6519">      }</a>
<a name="ln6520">      need_hide = false;</a>
<a name="ln6521">    } else {</a>
<a name="ln6522">      no_write_message();</a>
<a name="ln6523">      return;</a>
<a name="ln6524">    }</a>
<a name="ln6525">  }</a>
<a name="ln6526"> </a>
<a name="ln6527"> </a>
<a name="ln6528">  // free buffer when not hiding it or when it's a scratch buffer</a>
<a name="ln6529">  if (tp == NULL) {</a>
<a name="ln6530">    win_close(win, !need_hide &amp;&amp; !buf_hide(buf));</a>
<a name="ln6531">  } else {</a>
<a name="ln6532">    win_close_othertab(win, !need_hide &amp;&amp; !buf_hide(buf), tp);</a>
<a name="ln6533">  }</a>
<a name="ln6534">}</a>
<a name="ln6535"> </a>
<a name="ln6536">/*</a>
<a name="ln6537"> * &quot;:tabclose&quot;: close current tab page, unless it is the last one.</a>
<a name="ln6538"> * &quot;:tabclose N&quot;: close tab page N.</a>
<a name="ln6539"> */</a>
<a name="ln6540">static void ex_tabclose(exarg_T *eap)</a>
<a name="ln6541">{</a>
<a name="ln6542">  tabpage_T   *tp;</a>
<a name="ln6543"> </a>
<a name="ln6544">  if (cmdwin_type != 0)</a>
<a name="ln6545">    cmdwin_result = K_IGNORE;</a>
<a name="ln6546">  else if (first_tabpage-&gt;tp_next == NULL)</a>
<a name="ln6547">    EMSG(_(&quot;E784: Cannot close last tab page&quot;));</a>
<a name="ln6548">  else {</a>
<a name="ln6549">    int tab_number = get_tabpage_arg(eap);</a>
<a name="ln6550">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln6551">      tp = find_tabpage(tab_number);</a>
<a name="ln6552">      if (tp == NULL) {</a>
<a name="ln6553">        beep_flush();</a>
<a name="ln6554">        return;</a>
<a name="ln6555">      }</a>
<a name="ln6556">      if (tp != curtab) {</a>
<a name="ln6557">        tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln6558">        return;</a>
<a name="ln6559">      } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln6560">        tabpage_close(eap-&gt;forceit);</a>
<a name="ln6561">      }</a>
<a name="ln6562">    }</a>
<a name="ln6563">  }</a>
<a name="ln6564">}</a>
<a name="ln6565"> </a>
<a name="ln6566">/// &quot;:tabonly&quot;: close all tab pages except the current one</a>
<a name="ln6567">static void ex_tabonly(exarg_T *eap)</a>
<a name="ln6568">{</a>
<a name="ln6569">  if (cmdwin_type != 0) {</a>
<a name="ln6570">    cmdwin_result = K_IGNORE;</a>
<a name="ln6571">  } else if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln6572">      MSG(_(&quot;Already only one tab page&quot;));</a>
<a name="ln6573">  } else {</a>
<a name="ln6574">    int tab_number = get_tabpage_arg(eap);</a>
<a name="ln6575">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln6576">      goto_tabpage(tab_number);</a>
<a name="ln6577">      // Repeat this up to a 1000 times, because autocommands may</a>
<a name="ln6578">      // mess up the lists.</a>
<a name="ln6579">      for (int done = 0; done &lt; 1000; done++) {</a>
<a name="ln6580">        FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6581">          assert(wp != aucmd_win);</a>
<a name="ln6582">        }</a>
<a name="ln6583">        FOR_ALL_TABS(tp) {</a>
<a name="ln6584">          if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln6585">            tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln6586">            // if we failed to close it quit</a>
<a name="ln6587">            if (valid_tabpage(tp)) {</a>
<a name="ln6588">              done = 1000;</a>
<a name="ln6589">            }</a>
<a name="ln6590">            // start over, &quot;tp&quot; is now invalid</a>
<a name="ln6591">            break;</a>
<a name="ln6592">          }</a>
<a name="ln6593">        }</a>
<a name="ln6594">        assert(first_tabpage);</a>
<a name="ln6595">        if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln6596">          break;</a>
<a name="ln6597">        }</a>
<a name="ln6598">      }</a>
<a name="ln6599">    }</a>
<a name="ln6600">  }</a>
<a name="ln6601">}</a>
<a name="ln6602"> </a>
<a name="ln6603">/*</a>
<a name="ln6604"> * Close the current tab page.</a>
<a name="ln6605"> */</a>
<a name="ln6606">void tabpage_close(int forceit)</a>
<a name="ln6607">{</a>
<a name="ln6608">  // First close all the windows but the current one.  If that worked then</a>
<a name="ln6609">  // close the last window in this tab, that will close it.</a>
<a name="ln6610">  while (curwin-&gt;w_floating) {</a>
<a name="ln6611">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln6612">  }</a>
<a name="ln6613">  if (!ONE_WINDOW) {</a>
<a name="ln6614">    close_others(true, forceit);</a>
<a name="ln6615">  }</a>
<a name="ln6616">  if (ONE_WINDOW) {</a>
<a name="ln6617">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln6618">  }</a>
<a name="ln6619">}</a>
<a name="ln6620"> </a>
<a name="ln6621">/*</a>
<a name="ln6622"> * Close tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln6623"> * Note that autocommands may make &quot;tp&quot; invalid.</a>
<a name="ln6624"> * Also takes care of the tab pages line disappearing when closing the</a>
<a name="ln6625"> * last-but-one tab page.</a>
<a name="ln6626"> */</a>
<a name="ln6627">void tabpage_close_other(tabpage_T *tp, int forceit)</a>
<a name="ln6628">{</a>
<a name="ln6629">  int done = 0;</a>
<a name="ln6630">  win_T       *wp;</a>
<a name="ln6631">  int h = tabline_height();</a>
<a name="ln6632">  char_u prev_idx[NUMBUFLEN];</a>
<a name="ln6633"> </a>
<a name="ln6634">  /* Limit to 1000 windows, autocommands may add a window while we close</a>
<a name="ln6635">   * one.  OK, so I'm paranoid... */</a>
<a name="ln6636">  while (++done &lt; 1000) {</a>
<a name="ln6637">    snprintf((char *)prev_idx, sizeof(prev_idx), &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln6638">    wp = tp-&gt;tp_lastwin;</a>
<a name="ln6639">    ex_win_close(forceit, wp, tp);</a>
<a name="ln6640"> </a>
<a name="ln6641">    /* Autocommands may delete the tab page under our fingers and we may</a>
<a name="ln6642">     * fail to close a window with a modified buffer. */</a>
<a name="ln6643">    if (!valid_tabpage(tp) || tp-&gt;tp_firstwin == wp)</a>
<a name="ln6644">      break;</a>
<a name="ln6645">  }</a>
<a name="ln6646"> </a>
<a name="ln6647">  redraw_tabline = TRUE;</a>
<a name="ln6648">  if (h != tabline_height())</a>
<a name="ln6649">    shell_new_rows();</a>
<a name="ln6650">}</a>
<a name="ln6651"> </a>
<a name="ln6652">/*</a>
<a name="ln6653"> * &quot;:only&quot;.</a>
<a name="ln6654"> */</a>
<a name="ln6655">static void ex_only(exarg_T *eap)</a>
<a name="ln6656">{</a>
<a name="ln6657">  win_T *wp;</a>
<a name="ln6658">  int wnr;</a>
<a name="ln6659"> </a>
<a name="ln6660">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln6661">    wnr = eap-&gt;line2;</a>
<a name="ln6662">    for (wp = firstwin; --wnr &gt; 0;) {</a>
<a name="ln6663">      if (wp-&gt;w_next == NULL)</a>
<a name="ln6664">        break;</a>
<a name="ln6665">      else</a>
<a name="ln6666">        wp = wp-&gt;w_next;</a>
<a name="ln6667">    }</a>
<a name="ln6668">  } else {</a>
<a name="ln6669">    wp = curwin;</a>
<a name="ln6670">  }</a>
<a name="ln6671">  if (wp != curwin) {</a>
<a name="ln6672">    win_goto(wp);</a>
<a name="ln6673">  }</a>
<a name="ln6674">  close_others(TRUE, eap-&gt;forceit);</a>
<a name="ln6675">}</a>
<a name="ln6676"> </a>
<a name="ln6677">/*</a>
<a name="ln6678"> * &quot;:all&quot; and &quot;:sall&quot;.</a>
<a name="ln6679"> * Also used for &quot;:tab drop file ...&quot; after setting the argument list.</a>
<a name="ln6680"> */</a>
<a name="ln6681">void ex_all(exarg_T *eap)</a>
<a name="ln6682">{</a>
<a name="ln6683">  if (eap-&gt;addr_count == 0)</a>
<a name="ln6684">    eap-&gt;line2 = 9999;</a>
<a name="ln6685">  do_arg_all((int)eap-&gt;line2, eap-&gt;forceit, eap-&gt;cmdidx == CMD_drop);</a>
<a name="ln6686">}</a>
<a name="ln6687"> </a>
<a name="ln6688">static void ex_hide(exarg_T *eap)</a>
<a name="ln6689">{</a>
<a name="ln6690">    // &quot;:hide&quot; or &quot;:hide | cmd&quot;: hide current window</a>
<a name="ln6691">    if (!eap-&gt;skip) {</a>
<a name="ln6692">        if (eap-&gt;addr_count == 0) {</a>
<a name="ln6693">            win_close(curwin, false);  // don't free buffer</a>
<a name="ln6694">        } else {</a>
<a name="ln6695">            int winnr = 0;</a>
<a name="ln6696">            win_T *win = NULL;</a>
<a name="ln6697"> </a>
<a name="ln6698">            FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6699">                winnr++;</a>
<a name="ln6700">                if (winnr == eap-&gt;line2) {</a>
<a name="ln6701">                    win = wp;</a>
<a name="ln6702">                    break;</a>
<a name="ln6703">                }</a>
<a name="ln6704">            }</a>
<a name="ln6705">            if (win == NULL) {</a>
<a name="ln6706">                win = lastwin;</a>
<a name="ln6707">            }</a>
<a name="ln6708">            win_close(win, false);</a>
<a name="ln6709">        }</a>
<a name="ln6710">    }</a>
<a name="ln6711">}</a>
<a name="ln6712"> </a>
<a name="ln6713">/// &quot;:stop&quot; and &quot;:suspend&quot;: Suspend Vim.</a>
<a name="ln6714">static void ex_stop(exarg_T *eap)</a>
<a name="ln6715">{</a>
<a name="ln6716">  if (!eap-&gt;forceit) {</a>
<a name="ln6717">    autowrite_all();</a>
<a name="ln6718">  }</a>
<a name="ln6719">  apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, false, NULL);</a>
<a name="ln6720"> </a>
<a name="ln6721">  // TODO(bfredl): the TUI should do this on suspend</a>
<a name="ln6722">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln6723">  ui_call_grid_scroll(1, 0, Rows, 0, Columns, 1, 0);</a>
<a name="ln6724">  ui_flush();</a>
<a name="ln6725">  ui_call_suspend();  // call machine specific function</a>
<a name="ln6726"> </a>
<a name="ln6727">  ui_flush();</a>
<a name="ln6728">  maketitle();</a>
<a name="ln6729">  resettitle();  // force updating the title</a>
<a name="ln6730">  ui_refresh();  // may have resized window</a>
<a name="ln6731">  apply_autocmds(EVENT_VIMRESUME, NULL, NULL, false, NULL);</a>
<a name="ln6732">}</a>
<a name="ln6733"> </a>
<a name="ln6734">// &quot;:exit&quot;, &quot;:xit&quot; and &quot;:wq&quot;: Write file and quite the current window.</a>
<a name="ln6735">static void ex_exit(exarg_T *eap)</a>
<a name="ln6736">{</a>
<a name="ln6737">  if (cmdwin_type != 0) {</a>
<a name="ln6738">    cmdwin_result = Ctrl_C;</a>
<a name="ln6739">    return;</a>
<a name="ln6740">  }</a>
<a name="ln6741">  /* Don't quit while editing the command line. */</a>
<a name="ln6742">  if (text_locked()) {</a>
<a name="ln6743">    text_locked_msg();</a>
<a name="ln6744">    return;</a>
<a name="ln6745">  }</a>
<a name="ln6746"> </a>
<a name="ln6747">  if (before_quit_autocmds(curwin, false, eap-&gt;forceit)) {</a>
<a name="ln6748">    return;</a>
<a name="ln6749">  }</a>
<a name="ln6750"> </a>
<a name="ln6751">  // if more files or windows we won't exit</a>
<a name="ln6752">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln6753">    exiting = true;</a>
<a name="ln6754">  }</a>
<a name="ln6755">  if (((eap-&gt;cmdidx == CMD_wq</a>
<a name="ln6756">        || curbufIsChanged())</a>
<a name="ln6757">       &amp;&amp; do_write(eap) == FAIL)</a>
<a name="ln6758">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln6759">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, false))) {</a>
<a name="ln6760">    not_exiting();</a>
<a name="ln6761">  } else {</a>
<a name="ln6762">    if (only_one_window()) {</a>
<a name="ln6763">      // quit last window, exit Vim</a>
<a name="ln6764">      getout(0);</a>
<a name="ln6765">    }</a>
<a name="ln6766">    not_exiting();</a>
<a name="ln6767">    // Quit current window, may free the buffer.</a>
<a name="ln6768">    win_close(curwin, !buf_hide(curwin-&gt;w_buffer));</a>
<a name="ln6769">  }</a>
<a name="ln6770">}</a>
<a name="ln6771"> </a>
<a name="ln6772">/*</a>
<a name="ln6773"> * &quot;:print&quot;, &quot;:list&quot;, &quot;:number&quot;.</a>
<a name="ln6774"> */</a>
<a name="ln6775">static void ex_print(exarg_T *eap)</a>
<a name="ln6776">{</a>
<a name="ln6777">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln6778">    EMSG(_(e_emptybuf));</a>
<a name="ln6779">  else {</a>
<a name="ln6780">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln6781">      print_line(eap-&gt;line1,</a>
<a name="ln6782">          (eap-&gt;cmdidx == CMD_number || eap-&gt;cmdidx == CMD_pound</a>
<a name="ln6783">           || (eap-&gt;flags &amp; EXFLAG_NR)),</a>
<a name="ln6784">          eap-&gt;cmdidx == CMD_list || (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln6785">      if (++eap-&gt;line1 &gt; eap-&gt;line2)</a>
<a name="ln6786">        break;</a>
<a name="ln6787">      ui_flush();                  /* show one line at a time */</a>
<a name="ln6788">    }</a>
<a name="ln6789">    setpcmark();</a>
<a name="ln6790">    /* put cursor at last line */</a>
<a name="ln6791">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln6792">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln6793">  }</a>
<a name="ln6794"> </a>
<a name="ln6795">  ex_no_reprint = TRUE;</a>
<a name="ln6796">}</a>
<a name="ln6797"> </a>
<a name="ln6798">static void ex_goto(exarg_T *eap)</a>
<a name="ln6799">{</a>
<a name="ln6800">  goto_byte(eap-&gt;line2);</a>
<a name="ln6801">}</a>
<a name="ln6802"> </a>
<a name="ln6803">/*</a>
<a name="ln6804"> * Clear an argument list: free all file names and reset it to zero entries.</a>
<a name="ln6805"> */</a>
<a name="ln6806">void alist_clear(alist_T *al)</a>
<a name="ln6807">{</a>
<a name="ln6808"># define FREE_AENTRY_FNAME(arg) xfree(arg-&gt;ae_fname)</a>
<a name="ln6809">  GA_DEEP_CLEAR(&amp;al-&gt;al_ga, aentry_T, FREE_AENTRY_FNAME);</a>
<a name="ln6810">}</a>
<a name="ln6811"> </a>
<a name="ln6812">/*</a>
<a name="ln6813"> * Init an argument list.</a>
<a name="ln6814"> */</a>
<a name="ln6815">void alist_init(alist_T *al)</a>
<a name="ln6816">{</a>
<a name="ln6817">  ga_init(&amp;al-&gt;al_ga, (int)sizeof(aentry_T), 5);</a>
<a name="ln6818">}</a>
<a name="ln6819"> </a>
<a name="ln6820"> </a>
<a name="ln6821">/*</a>
<a name="ln6822"> * Remove a reference from an argument list.</a>
<a name="ln6823"> * Ignored when the argument list is the global one.</a>
<a name="ln6824"> * If the argument list is no longer used by any window, free it.</a>
<a name="ln6825"> */</a>
<a name="ln6826">void alist_unlink(alist_T *al)</a>
<a name="ln6827">{</a>
<a name="ln6828">  if (al != &amp;global_alist &amp;&amp; --al-&gt;al_refcount &lt;= 0) {</a>
<a name="ln6829">    alist_clear(al);</a>
<a name="ln6830">    xfree(al);</a>
<a name="ln6831">  }</a>
<a name="ln6832">}</a>
<a name="ln6833"> </a>
<a name="ln6834">/*</a>
<a name="ln6835"> * Create a new argument list and use it for the current window.</a>
<a name="ln6836"> */</a>
<a name="ln6837">void alist_new(void)</a>
<a name="ln6838">{</a>
<a name="ln6839">  curwin-&gt;w_alist = xmalloc(sizeof(*curwin-&gt;w_alist));</a>
<a name="ln6840">  curwin-&gt;w_alist-&gt;al_refcount = 1;</a>
<a name="ln6841">  curwin-&gt;w_alist-&gt;id = ++max_alist_id;</a>
<a name="ln6842">  alist_init(curwin-&gt;w_alist);</a>
<a name="ln6843">}</a>
<a name="ln6844"> </a>
<a name="ln6845">#if !defined(UNIX)</a>
<a name="ln6846">/*</a>
<a name="ln6847"> * Expand the file names in the global argument list.</a>
<a name="ln6848"> * If &quot;fnum_list&quot; is not NULL, use &quot;fnum_list[fnum_len]&quot; as a list of buffer</a>
<a name="ln6849"> * numbers to be re-used.</a>
<a name="ln6850"> */</a>
<a name="ln6851">void alist_expand(int *fnum_list, int fnum_len)</a>
<a name="ln6852">{</a>
<a name="ln6853">  char_u      **old_arg_files;</a>
<a name="ln6854">  int old_arg_count;</a>
<a name="ln6855">  char_u      **new_arg_files;</a>
<a name="ln6856">  int new_arg_file_count;</a>
<a name="ln6857">  char_u      *save_p_su = p_su;</a>
<a name="ln6858">  int i;</a>
<a name="ln6859"> </a>
<a name="ln6860">  /* Don't use 'suffixes' here.  This should work like the shell did the</a>
<a name="ln6861">   * expansion.  Also, the vimrc file isn't read yet, thus the user</a>
<a name="ln6862">   * can't set the options. */</a>
<a name="ln6863">  p_su = empty_option;</a>
<a name="ln6864">  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);</a>
<a name="ln6865">  for (i = 0; i &lt; GARGCOUNT; ++i)</a>
<a name="ln6866">    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln6867">  old_arg_count = GARGCOUNT;</a>
<a name="ln6868">  if (expand_wildcards(old_arg_count, old_arg_files,</a>
<a name="ln6869">          &amp;new_arg_file_count, &amp;new_arg_files,</a>
<a name="ln6870">          EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK</a>
<a name="ln6871">      &amp;&amp; new_arg_file_count &gt; 0) {</a>
<a name="ln6872">    alist_set(&amp;global_alist, new_arg_file_count, new_arg_files,</a>
<a name="ln6873">        TRUE, fnum_list, fnum_len);</a>
<a name="ln6874">    FreeWild(old_arg_count, old_arg_files);</a>
<a name="ln6875">  }</a>
<a name="ln6876">  p_su = save_p_su;</a>
<a name="ln6877">}</a>
<a name="ln6878">#endif</a>
<a name="ln6879"> </a>
<a name="ln6880">/*</a>
<a name="ln6881"> * Set the argument list for the current window.</a>
<a name="ln6882"> * Takes over the allocated files[] and the allocated fnames in it.</a>
<a name="ln6883"> */</a>
<a name="ln6884">void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)</a>
<a name="ln6885">{</a>
<a name="ln6886">  int i;</a>
<a name="ln6887">  static int recursive = 0;</a>
<a name="ln6888"> </a>
<a name="ln6889">  if (recursive) {</a>
<a name="ln6890">    EMSG(_(e_au_recursive));</a>
<a name="ln6891">    return;</a>
<a name="ln6892">  }</a>
<a name="ln6893">  recursive++;</a>
<a name="ln6894"> </a>
<a name="ln6895">  alist_clear(al);</a>
<a name="ln6896">  ga_grow(&amp;al-&gt;al_ga, count);</a>
<a name="ln6897">  {</a>
<a name="ln6898">    for (i = 0; i &lt; count; ++i) {</a>
<a name="ln6899">      if (got_int) {</a>
<a name="ln6900">        /* When adding many buffers this can take a long time.  Allow</a>
<a name="ln6901">         * interrupting here. */</a>
<a name="ln6902">        while (i &lt; count)</a>
<a name="ln6903">          xfree(files[i++]);</a>
<a name="ln6904">        break;</a>
<a name="ln6905">      }</a>
<a name="ln6906"> </a>
<a name="ln6907">      /* May set buffer name of a buffer previously used for the</a>
<a name="ln6908">       * argument list, so that it's re-used by alist_add. */</a>
<a name="ln6909">      if (fnum_list != NULL &amp;&amp; i &lt; fnum_len)</a>
<a name="ln6910">        buf_set_name(fnum_list[i], files[i]);</a>
<a name="ln6911"> </a>
<a name="ln6912">      alist_add(al, files[i], use_curbuf ? 2 : 1);</a>
<a name="ln6913">      os_breakcheck();</a>
<a name="ln6914">    }</a>
<a name="ln6915">    xfree(files);</a>
<a name="ln6916">  }</a>
<a name="ln6917"> </a>
<a name="ln6918">  if (al == &amp;global_alist) {</a>
<a name="ln6919">    arg_had_last = false;</a>
<a name="ln6920">  }</a>
<a name="ln6921">  recursive--;</a>
<a name="ln6922">}</a>
<a name="ln6923"> </a>
<a name="ln6924">/*</a>
<a name="ln6925"> * Add file &quot;fname&quot; to argument list &quot;al&quot;.</a>
<a name="ln6926"> * &quot;fname&quot; must have been allocated and &quot;al&quot; must have been checked for room.</a>
<a name="ln6927"> */</a>
<a name="ln6928">void</a>
<a name="ln6929">alist_add(</a>
<a name="ln6930">    alist_T *al,</a>
<a name="ln6931">    char_u *fname,</a>
<a name="ln6932">    int set_fnum                   /* 1: set buffer number; 2: re-use curbuf */</a>
<a name="ln6933">)</a>
<a name="ln6934">{</a>
<a name="ln6935">  if (fname == NULL)            /* don't add NULL file names */</a>
<a name="ln6936">    return;</a>
<a name="ln6937">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6938">  slash_adjust(fname);</a>
<a name="ln6939">#endif</a>
<a name="ln6940">  AARGLIST(al)[al-&gt;al_ga.ga_len].ae_fname = fname;</a>
<a name="ln6941">  if (set_fnum &gt; 0)</a>
<a name="ln6942">    AARGLIST(al)[al-&gt;al_ga.ga_len].ae_fnum =</a>
<a name="ln6943">      buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));</a>
<a name="ln6944">  ++al-&gt;al_ga.ga_len;</a>
<a name="ln6945">}</a>
<a name="ln6946"> </a>
<a name="ln6947">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln6948">/*</a>
<a name="ln6949"> * Adjust slashes in file names.  Called after 'shellslash' was set.</a>
<a name="ln6950"> */</a>
<a name="ln6951">void alist_slash_adjust(void)</a>
<a name="ln6952">{</a>
<a name="ln6953">  for (int i = 0; i &lt; GARGCOUNT; ++i) {</a>
<a name="ln6954">    if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln6955">      slash_adjust(GARGLIST[i].ae_fname);</a>
<a name="ln6956">    }</a>
<a name="ln6957">  }</a>
<a name="ln6958"> </a>
<a name="ln6959">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6960">    if (wp-&gt;w_alist != &amp;global_alist) {</a>
<a name="ln6961">      for (int i = 0; i &lt; WARGCOUNT(wp); ++i) {</a>
<a name="ln6962">        if (WARGLIST(wp)[i].ae_fname != NULL) {</a>
<a name="ln6963">          slash_adjust(WARGLIST(wp)[i].ae_fname);</a>
<a name="ln6964">        }</a>
<a name="ln6965">      }</a>
<a name="ln6966">    }</a>
<a name="ln6967">  }</a>
<a name="ln6968">}</a>
<a name="ln6969"> </a>
<a name="ln6970">#endif</a>
<a name="ln6971"> </a>
<a name="ln6972">/// &quot;:preserve&quot;.</a>
<a name="ln6973">static void ex_preserve(exarg_T *eap)</a>
<a name="ln6974">{</a>
<a name="ln6975">  curbuf-&gt;b_flags |= BF_PRESERVED;</a>
<a name="ln6976">  ml_preserve(curbuf, true, true);</a>
<a name="ln6977">}</a>
<a name="ln6978"> </a>
<a name="ln6979">/// &quot;:recover&quot;.</a>
<a name="ln6980">static void ex_recover(exarg_T *eap)</a>
<a name="ln6981">{</a>
<a name="ln6982">  // Set recoverymode right away to avoid the ATTENTION prompt.</a>
<a name="ln6983">  recoverymode = true;</a>
<a name="ln6984">  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln6985">          | CCGD_MULTWIN</a>
<a name="ln6986">          | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln6987">          | CCGD_EXCMD)</a>
<a name="ln6988"> </a>
<a name="ln6989">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln6990">          || setfname(curbuf, eap-&gt;arg, NULL, true) == OK)) {</a>
<a name="ln6991">    ml_recover(true);</a>
<a name="ln6992">  }</a>
<a name="ln6993">  recoverymode = false;</a>
<a name="ln6994">}</a>
<a name="ln6995"> </a>
<a name="ln6996">/*</a>
<a name="ln6997"> * Command modifier used in a wrong way.</a>
<a name="ln6998"> */</a>
<a name="ln6999">static void ex_wrongmodifier(exarg_T *eap)</a>
<a name="ln7000">{</a>
<a name="ln7001">  eap-&gt;errmsg = e_invcmd;</a>
<a name="ln7002">}</a>
<a name="ln7003"> </a>
<a name="ln7004">/*</a>
<a name="ln7005"> * :sview [+command] file	split window with new file, read-only</a>
<a name="ln7006"> * :split [[+command] file]	split window with current or new file</a>
<a name="ln7007"> * :vsplit [[+command] file]	split window vertically with current or new file</a>
<a name="ln7008"> * :new [[+command] file]	split window with no or new file</a>
<a name="ln7009"> * :vnew [[+command] file]	split vertically window with no or new file</a>
<a name="ln7010"> * :sfind [+command] file	split window with file in 'path'</a>
<a name="ln7011"> *</a>
<a name="ln7012"> * :tabedit			open new Tab page with empty window</a>
<a name="ln7013"> * :tabedit [+command] file	open new Tab page and edit &quot;file&quot;</a>
<a name="ln7014"> * :tabnew [[+command] file]	just like :tabedit</a>
<a name="ln7015"> * :tabfind [+command] file	open new Tab page and find &quot;file&quot;</a>
<a name="ln7016"> */</a>
<a name="ln7017">void ex_splitview(exarg_T *eap)</a>
<a name="ln7018">{</a>
<a name="ln7019">  win_T       *old_curwin = curwin;</a>
<a name="ln7020">  char_u      *fname = NULL;</a>
<a name="ln7021">  const bool use_tab = eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln7022">    || eap-&gt;cmdidx == CMD_tabfind</a>
<a name="ln7023">    || eap-&gt;cmdidx == CMD_tabnew;</a>
<a name="ln7024"> </a>
<a name="ln7025">  /* A &quot;:split&quot; in the quickfix window works like &quot;:new&quot;.  Don't want two</a>
<a name="ln7026">   * quickfix windows.  But it's OK when doing &quot;:tab split&quot;. */</a>
<a name="ln7027">  if (bt_quickfix(curbuf) &amp;&amp; cmdmod.tab == 0) {</a>
<a name="ln7028">    if (eap-&gt;cmdidx == CMD_split)</a>
<a name="ln7029">      eap-&gt;cmdidx = CMD_new;</a>
<a name="ln7030">    if (eap-&gt;cmdidx == CMD_vsplit)</a>
<a name="ln7031">      eap-&gt;cmdidx = CMD_vnew;</a>
<a name="ln7032">  }</a>
<a name="ln7033"> </a>
<a name="ln7034">  if (eap-&gt;cmdidx == CMD_sfind || eap-&gt;cmdidx == CMD_tabfind) {</a>
<a name="ln7035">    fname = find_file_in_path(eap-&gt;arg, STRLEN(eap-&gt;arg),</a>
<a name="ln7036">                              FNAME_MESS, TRUE, curbuf-&gt;b_ffname);</a>
<a name="ln7037">    if (fname == NULL)</a>
<a name="ln7038">      goto theend;</a>
<a name="ln7039">    eap-&gt;arg = fname;</a>
<a name="ln7040">  }</a>
<a name="ln7041"> </a>
<a name="ln7042">  /*</a>
<a name="ln7043">   * Either open new tab page or split the window.</a>
<a name="ln7044">   */</a>
<a name="ln7045">  if (use_tab) {</a>
<a name="ln7046">    if (win_new_tabpage(cmdmod.tab != 0 ? cmdmod.tab : eap-&gt;addr_count == 0</a>
<a name="ln7047">                        ? 0 : (int)eap-&gt;line2 + 1, eap-&gt;arg) != FAIL) {</a>
<a name="ln7048">      do_exedit(eap, old_curwin);</a>
<a name="ln7049">      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, FALSE, curbuf);</a>
<a name="ln7050"> </a>
<a name="ln7051">      /* set the alternate buffer for the window we came from */</a>
<a name="ln7052">      if (curwin != old_curwin</a>
<a name="ln7053">          &amp;&amp; win_valid(old_curwin)</a>
<a name="ln7054">          &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln7055">          &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln7056">        old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln7057">    }</a>
<a name="ln7058">  } else if (win_split(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 0,</a>
<a name="ln7059">                 *eap-&gt;cmd == 'v' ? WSP_VERT : 0) != FAIL) {</a>
<a name="ln7060">    /* Reset 'scrollbind' when editing another file, but keep it when</a>
<a name="ln7061">     * doing &quot;:split&quot; without arguments. */</a>
<a name="ln7062">    if (*eap-&gt;arg != NUL</a>
<a name="ln7063">        ) {</a>
<a name="ln7064">      RESET_BINDING(curwin);</a>
<a name="ln7065">    } else {</a>
<a name="ln7066">      do_check_scrollbind(false);</a>
<a name="ln7067">    }</a>
<a name="ln7068">    do_exedit(eap, old_curwin);</a>
<a name="ln7069">  }</a>
<a name="ln7070"> </a>
<a name="ln7071"> </a>
<a name="ln7072">theend:</a>
<a name="ln7073">  xfree(fname);</a>
<a name="ln7074">}</a>
<a name="ln7075"> </a>
<a name="ln7076">/*</a>
<a name="ln7077"> * Open a new tab page.</a>
<a name="ln7078"> */</a>
<a name="ln7079">void tabpage_new(void)</a>
<a name="ln7080">{</a>
<a name="ln7081">  exarg_T ea;</a>
<a name="ln7082"> </a>
<a name="ln7083">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln7084">  ea.cmdidx = CMD_tabnew;</a>
<a name="ln7085">  ea.cmd = (char_u *)&quot;tabn&quot;;</a>
<a name="ln7086">  ea.arg = (char_u *)&quot;&quot;;</a>
<a name="ln7087">  ex_splitview(&amp;ea);</a>
<a name="ln7088">}</a>
<a name="ln7089"> </a>
<a name="ln7090">/*</a>
<a name="ln7091"> * :tabnext command</a>
<a name="ln7092"> */</a>
<a name="ln7093">static void ex_tabnext(exarg_T *eap)</a>
<a name="ln7094">{</a>
<a name="ln7095">  int tab_number;</a>
<a name="ln7096"> </a>
<a name="ln7097">  switch (eap-&gt;cmdidx) {</a>
<a name="ln7098">  case CMD_tabfirst:</a>
<a name="ln7099">  case CMD_tabrewind:</a>
<a name="ln7100">    goto_tabpage(1);</a>
<a name="ln7101">    break;</a>
<a name="ln7102">  case CMD_tablast:</a>
<a name="ln7103">    goto_tabpage(9999);</a>
<a name="ln7104">    break;</a>
<a name="ln7105">  case CMD_tabprevious:</a>
<a name="ln7106">  case CMD_tabNext:</a>
<a name="ln7107">    if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln7108">      char_u *p = eap-&gt;arg;</a>
<a name="ln7109">      char_u *p_save = p;</a>
<a name="ln7110">      tab_number = getdigits(&amp;p, false, 0);</a>
<a name="ln7111">      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL</a>
<a name="ln7112">          || tab_number == 0) {</a>
<a name="ln7113">        // No numbers as argument.</a>
<a name="ln7114">        eap-&gt;errmsg = e_invarg;</a>
<a name="ln7115">        return;</a>
<a name="ln7116">      }</a>
<a name="ln7117">    } else {</a>
<a name="ln7118">      if (eap-&gt;addr_count == 0) {</a>
<a name="ln7119">        tab_number = 1;</a>
<a name="ln7120">      } else {</a>
<a name="ln7121">        tab_number = eap-&gt;line2;</a>
<a name="ln7122">        if (tab_number &lt; 1) {</a>
<a name="ln7123">          eap-&gt;errmsg = e_invrange;</a>
<a name="ln7124">          return;</a>
<a name="ln7125">        }</a>
<a name="ln7126">      }</a>
<a name="ln7127">    }</a>
<a name="ln7128">    goto_tabpage(-tab_number);</a>
<a name="ln7129">    break;</a>
<a name="ln7130">  default:       // CMD_tabnext</a>
<a name="ln7131">    tab_number = get_tabpage_arg(eap);</a>
<a name="ln7132">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln7133">      goto_tabpage(tab_number);</a>
<a name="ln7134">    }</a>
<a name="ln7135">    break;</a>
<a name="ln7136">  }</a>
<a name="ln7137">}</a>
<a name="ln7138"> </a>
<a name="ln7139">/*</a>
<a name="ln7140"> * :tabmove command</a>
<a name="ln7141"> */</a>
<a name="ln7142">static void ex_tabmove(exarg_T *eap)</a>
<a name="ln7143">{</a>
<a name="ln7144">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln7145">  if (eap-&gt;errmsg == NULL) {</a>
<a name="ln7146">    tabpage_move(tab_number);</a>
<a name="ln7147">  }</a>
<a name="ln7148">}</a>
<a name="ln7149"> </a>
<a name="ln7150">/*</a>
<a name="ln7151"> * :tabs command: List tabs and their contents.</a>
<a name="ln7152"> */</a>
<a name="ln7153">static void ex_tabs(exarg_T *eap)</a>
<a name="ln7154">{</a>
<a name="ln7155">  int tabcount = 1;</a>
<a name="ln7156"> </a>
<a name="ln7157">  msg_start();</a>
<a name="ln7158">  msg_scroll = TRUE;</a>
<a name="ln7159"> </a>
<a name="ln7160">  win_T *lastused_win = valid_tabpage(lastused_tabpage)</a>
<a name="ln7161">    ? lastused_tabpage-&gt;tp_curwin</a>
<a name="ln7162">    : NULL;</a>
<a name="ln7163"> </a>
<a name="ln7164">  FOR_ALL_TABS(tp) {</a>
<a name="ln7165">    if (got_int) {</a>
<a name="ln7166">       break;</a>
<a name="ln7167">    }</a>
<a name="ln7168"> </a>
<a name="ln7169">    msg_putchar('\n');</a>
<a name="ln7170">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Tab page %d&quot;), tabcount++);</a>
<a name="ln7171">    msg_outtrans_attr(IObuff, HL_ATTR(HLF_T));</a>
<a name="ln7172">    ui_flush();            // output one line at a time</a>
<a name="ln7173">    os_breakcheck();</a>
<a name="ln7174"> </a>
<a name="ln7175">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln7176">      if (got_int) {</a>
<a name="ln7177">        break;</a>
<a name="ln7178">      }</a>
<a name="ln7179"> </a>
<a name="ln7180">      msg_putchar('\n');</a>
<a name="ln7181">      msg_putchar(wp == curwin ? '&gt;' : wp == lastused_win ? '#' : ' ');</a>
<a name="ln7182">      msg_putchar(' ');</a>
<a name="ln7183">      msg_putchar(bufIsChanged(wp-&gt;w_buffer) ? '+' : ' ');</a>
<a name="ln7184">      msg_putchar(' ');</a>
<a name="ln7185">      if (buf_spname(wp-&gt;w_buffer) != NULL)</a>
<a name="ln7186">        STRLCPY(IObuff, buf_spname(wp-&gt;w_buffer), IOSIZE);</a>
<a name="ln7187">      else</a>
<a name="ln7188">        home_replace(wp-&gt;w_buffer, wp-&gt;w_buffer-&gt;b_fname,</a>
<a name="ln7189">            IObuff, IOSIZE, TRUE);</a>
<a name="ln7190">      msg_outtrans(IObuff);</a>
<a name="ln7191">      ui_flush();                  /* output one line at a time */</a>
<a name="ln7192">      os_breakcheck();</a>
<a name="ln7193">    }</a>
<a name="ln7194">  }</a>
<a name="ln7195">}</a>
<a name="ln7196"> </a>
<a name="ln7197"> </a>
<a name="ln7198">/*</a>
<a name="ln7199"> * &quot;:mode&quot;:</a>
<a name="ln7200"> * If no argument given, get the screen size and redraw.</a>
<a name="ln7201"> */</a>
<a name="ln7202">static void ex_mode(exarg_T *eap)</a>
<a name="ln7203">{</a>
<a name="ln7204">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln7205">    must_redraw = CLEAR;</a>
<a name="ln7206">    ex_redraw(eap);</a>
<a name="ln7207">  } else {</a>
<a name="ln7208">    EMSG(_(e_screenmode));</a>
<a name="ln7209">  }</a>
<a name="ln7210">}</a>
<a name="ln7211"> </a>
<a name="ln7212">/*</a>
<a name="ln7213"> * &quot;:resize&quot;.</a>
<a name="ln7214"> * set, increment or decrement current window height</a>
<a name="ln7215"> */</a>
<a name="ln7216">static void ex_resize(exarg_T *eap)</a>
<a name="ln7217">{</a>
<a name="ln7218">  int n;</a>
<a name="ln7219">  win_T       *wp = curwin;</a>
<a name="ln7220"> </a>
<a name="ln7221">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln7222">    n = eap-&gt;line2;</a>
<a name="ln7223">    for (wp = firstwin; wp-&gt;w_next != NULL &amp;&amp; --n &gt; 0; wp = wp-&gt;w_next)</a>
<a name="ln7224">      ;</a>
<a name="ln7225">  }</a>
<a name="ln7226"> </a>
<a name="ln7227">  n = atol((char *)eap-&gt;arg);</a>
<a name="ln7228">  if (cmdmod.split &amp; WSP_VERT) {</a>
<a name="ln7229">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln7230">      n += wp-&gt;w_width;</a>
<a name="ln7231">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very wide</a>
<a name="ln7232">      n = Columns;</a>
<a name="ln7233">    }</a>
<a name="ln7234">    win_setwidth_win(n, wp);</a>
<a name="ln7235">  } else {</a>
<a name="ln7236">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln7237">      n += wp-&gt;w_height;</a>
<a name="ln7238">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very high</a>
<a name="ln7239">      n = Rows-1;</a>
<a name="ln7240">    }</a>
<a name="ln7241">    win_setheight_win(n, wp);</a>
<a name="ln7242">  }</a>
<a name="ln7243">}</a>
<a name="ln7244"> </a>
<a name="ln7245">/*</a>
<a name="ln7246"> * &quot;:find [+command] &lt;file&gt;&quot; command.</a>
<a name="ln7247"> */</a>
<a name="ln7248">static void ex_find(exarg_T *eap)</a>
<a name="ln7249">{</a>
<a name="ln7250">  char_u      *fname;</a>
<a name="ln7251">  int count;</a>
<a name="ln7252"> </a>
<a name="ln7253">  fname = find_file_in_path(eap-&gt;arg, STRLEN(eap-&gt;arg),</a>
<a name="ln7254">                            FNAME_MESS, TRUE, curbuf-&gt;b_ffname);</a>
<a name="ln7255">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln7256">    /* Repeat finding the file &quot;count&quot; times.  This matters when it</a>
<a name="ln7257">     * appears several times in the path. */</a>
<a name="ln7258">    count = eap-&gt;line2;</a>
<a name="ln7259">    while (fname != NULL &amp;&amp; --count &gt; 0) {</a>
<a name="ln7260">      xfree(fname);</a>
<a name="ln7261">      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf-&gt;b_ffname);</a>
<a name="ln7262">    }</a>
<a name="ln7263">  }</a>
<a name="ln7264"> </a>
<a name="ln7265">  if (fname != NULL) {</a>
<a name="ln7266">    eap-&gt;arg = fname;</a>
<a name="ln7267">    do_exedit(eap, NULL);</a>
<a name="ln7268">    xfree(fname);</a>
<a name="ln7269">  }</a>
<a name="ln7270">}</a>
<a name="ln7271"> </a>
<a name="ln7272">/*</a>
<a name="ln7273"> * &quot;:edit&quot;, &quot;:badd&quot;, &quot;:visual&quot;.</a>
<a name="ln7274"> */</a>
<a name="ln7275">static void ex_edit(exarg_T *eap)</a>
<a name="ln7276">{</a>
<a name="ln7277">  do_exedit(eap, NULL);</a>
<a name="ln7278">}</a>
<a name="ln7279"> </a>
<a name="ln7280">/*</a>
<a name="ln7281"> * &quot;:edit &lt;file&gt;&quot; command and alikes.</a>
<a name="ln7282"> */</a>
<a name="ln7283">void</a>
<a name="ln7284">do_exedit(</a>
<a name="ln7285">    exarg_T *eap,</a>
<a name="ln7286">    win_T *old_curwin            /* curwin before doing a split or NULL */</a>
<a name="ln7287">)</a>
<a name="ln7288">{</a>
<a name="ln7289">  int n;</a>
<a name="ln7290">  int need_hide;</a>
<a name="ln7291"> </a>
<a name="ln7292">  /*</a>
<a name="ln7293">   * &quot;:vi&quot; command ends Ex mode.</a>
<a name="ln7294">   */</a>
<a name="ln7295">  if (exmode_active &amp;&amp; (eap-&gt;cmdidx == CMD_visual</a>
<a name="ln7296">                        || eap-&gt;cmdidx == CMD_view)) {</a>
<a name="ln7297">    exmode_active = FALSE;</a>
<a name="ln7298">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln7299">      /* Special case:  &quot;:global/pat/visual\NLvi-commands&quot; */</a>
<a name="ln7300">      if (global_busy) {</a>
<a name="ln7301">        int rd = RedrawingDisabled;</a>
<a name="ln7302">        int nwr = no_wait_return;</a>
<a name="ln7303">        int ms = msg_scroll;</a>
<a name="ln7304"> </a>
<a name="ln7305">        if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln7306">          stuffReadbuff((const char *)eap-&gt;nextcmd);</a>
<a name="ln7307">          eap-&gt;nextcmd = NULL;</a>
<a name="ln7308">        }</a>
<a name="ln7309"> </a>
<a name="ln7310">        RedrawingDisabled = 0;</a>
<a name="ln7311">        no_wait_return = 0;</a>
<a name="ln7312">        need_wait_return = FALSE;</a>
<a name="ln7313">        msg_scroll = 0;</a>
<a name="ln7314">        redraw_all_later(NOT_VALID);</a>
<a name="ln7315"> </a>
<a name="ln7316">        normal_enter(false, true);</a>
<a name="ln7317"> </a>
<a name="ln7318">        RedrawingDisabled = rd;</a>
<a name="ln7319">        no_wait_return = nwr;</a>
<a name="ln7320">        msg_scroll = ms;</a>
<a name="ln7321">      }</a>
<a name="ln7322">      return;</a>
<a name="ln7323">    }</a>
<a name="ln7324">  }</a>
<a name="ln7325"> </a>
<a name="ln7326">  if ((eap-&gt;cmdidx == CMD_new</a>
<a name="ln7327">       || eap-&gt;cmdidx == CMD_tabnew</a>
<a name="ln7328">       || eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln7329">       || eap-&gt;cmdidx == CMD_vnew</a>
<a name="ln7330">       ) &amp;&amp; *eap-&gt;arg == NUL) {</a>
<a name="ln7331">    /* &quot;:new&quot; or &quot;:tabnew&quot; without argument: edit an new empty buffer */</a>
<a name="ln7332">    setpcmark();</a>
<a name="ln7333">    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,</a>
<a name="ln7334">        ECMD_HIDE + (eap-&gt;forceit ? ECMD_FORCEIT : 0),</a>
<a name="ln7335">        old_curwin == NULL ? curwin : NULL);</a>
<a name="ln7336">  } else if ((eap-&gt;cmdidx != CMD_split &amp;&amp; eap-&gt;cmdidx != CMD_vsplit)</a>
<a name="ln7337">             || *eap-&gt;arg != NUL) {</a>
<a name="ln7338">    /* Can't edit another file when &quot;curbuf_lock&quot; is set.  Only &quot;:edit&quot;</a>
<a name="ln7339">     * can bring us here, others are stopped earlier. */</a>
<a name="ln7340">    if (*eap-&gt;arg != NUL &amp;&amp; curbuf_locked())</a>
<a name="ln7341">      return;</a>
<a name="ln7342">    n = readonlymode;</a>
<a name="ln7343">    if (eap-&gt;cmdidx == CMD_view || eap-&gt;cmdidx == CMD_sview)</a>
<a name="ln7344">      readonlymode = TRUE;</a>
<a name="ln7345">    else if (eap-&gt;cmdidx == CMD_enew)</a>
<a name="ln7346">      readonlymode = FALSE;         /* 'readonly' doesn't make sense in an</a>
<a name="ln7347">                                       empty buffer */</a>
<a name="ln7348">    setpcmark();</a>
<a name="ln7349">    if (do_ecmd(0, (eap-&gt;cmdidx == CMD_enew ? NULL : eap-&gt;arg),</a>
<a name="ln7350">                NULL, eap, eap-&gt;do_ecmd_lnum,</a>
<a name="ln7351">                (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln7352">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0)</a>
<a name="ln7353">                // After a split we can use an existing buffer.</a>
<a name="ln7354">                + (old_curwin != NULL ? ECMD_OLDBUF : 0)</a>
<a name="ln7355">                + (eap-&gt;cmdidx == CMD_badd ? ECMD_ADDBUF : 0)</a>
<a name="ln7356">                , old_curwin == NULL ? curwin : NULL) == FAIL) {</a>
<a name="ln7357">      // Editing the file failed.  If the window was split, close it.</a>
<a name="ln7358">      if (old_curwin != NULL) {</a>
<a name="ln7359">        need_hide = (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln7360">        if (!need_hide || buf_hide(curbuf)) {</a>
<a name="ln7361">          cleanup_T cs;</a>
<a name="ln7362"> </a>
<a name="ln7363">          /* Reset the error/interrupt/exception state here so that</a>
<a name="ln7364">           * aborting() returns FALSE when closing a window. */</a>
<a name="ln7365">          enter_cleanup(&amp;cs);</a>
<a name="ln7366">          win_close(curwin, !need_hide &amp;&amp; !buf_hide(curbuf));</a>
<a name="ln7367"> </a>
<a name="ln7368">          /* Restore the error/interrupt/exception state if not</a>
<a name="ln7369">           * discarded by a new aborting error, interrupt, or</a>
<a name="ln7370">           * uncaught exception. */</a>
<a name="ln7371">          leave_cleanup(&amp;cs);</a>
<a name="ln7372">        }</a>
<a name="ln7373">      }</a>
<a name="ln7374">    } else if (readonlymode &amp;&amp; curbuf-&gt;b_nwindows == 1) {</a>
<a name="ln7375">      /* When editing an already visited buffer, 'readonly' won't be set</a>
<a name="ln7376">       * but the previous value is kept.  With &quot;:view&quot; and &quot;:sview&quot; we</a>
<a name="ln7377">       * want the  file to be readonly, except when another window is</a>
<a name="ln7378">       * editing the same buffer. */</a>
<a name="ln7379">      curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln7380">    }</a>
<a name="ln7381">    readonlymode = n;</a>
<a name="ln7382">  } else {</a>
<a name="ln7383">    if (eap-&gt;do_ecmd_cmd != NULL)</a>
<a name="ln7384">      do_cmdline_cmd((char *)eap-&gt;do_ecmd_cmd);</a>
<a name="ln7385">    n = curwin-&gt;w_arg_idx_invalid;</a>
<a name="ln7386">    check_arg_idx(curwin);</a>
<a name="ln7387">    if (n != curwin-&gt;w_arg_idx_invalid)</a>
<a name="ln7388">      maketitle();</a>
<a name="ln7389">  }</a>
<a name="ln7390"> </a>
<a name="ln7391">  /*</a>
<a name="ln7392">   * if &quot;:split file&quot; worked, set alternate file name in old window to new</a>
<a name="ln7393">   * file</a>
<a name="ln7394">   */</a>
<a name="ln7395">  if (old_curwin != NULL</a>
<a name="ln7396">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln7397">      &amp;&amp; curwin != old_curwin</a>
<a name="ln7398">      &amp;&amp; win_valid(old_curwin)</a>
<a name="ln7399">      &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln7400">      &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln7401">    old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln7402"> </a>
<a name="ln7403">  ex_no_reprint = TRUE;</a>
<a name="ln7404">}</a>
<a name="ln7405"> </a>
<a name="ln7406">/// &quot;:gui&quot; and &quot;:gvim&quot; when there is no GUI.</a>
<a name="ln7407">static void ex_nogui(exarg_T *eap)</a>
<a name="ln7408">{</a>
<a name="ln7409">  eap-&gt;errmsg = (char_u *)N_(&quot;E25: Nvim does not have a built-in GUI&quot;);</a>
<a name="ln7410">}</a>
<a name="ln7411"> </a>
<a name="ln7412"> </a>
<a name="ln7413"> </a>
<a name="ln7414">static void ex_swapname(exarg_T *eap)</a>
<a name="ln7415">{</a>
<a name="ln7416">  if (curbuf-&gt;b_ml.ml_mfp == NULL || curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL)</a>
<a name="ln7417">    MSG(_(&quot;No swap file&quot;));</a>
<a name="ln7418">  else</a>
<a name="ln7419">    msg(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln7420">}</a>
<a name="ln7421"> </a>
<a name="ln7422">/*</a>
<a name="ln7423"> * &quot;:syncbind&quot; forces all 'scrollbind' windows to have the same relative</a>
<a name="ln7424"> * offset.</a>
<a name="ln7425"> * (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln7426"> */</a>
<a name="ln7427">static void ex_syncbind(exarg_T *eap)</a>
<a name="ln7428">{</a>
<a name="ln7429">  win_T       *save_curwin = curwin;</a>
<a name="ln7430">  buf_T       *save_curbuf = curbuf;</a>
<a name="ln7431">  long topline;</a>
<a name="ln7432">  long y;</a>
<a name="ln7433">  linenr_T old_linenr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln7434"> </a>
<a name="ln7435">  setpcmark();</a>
<a name="ln7436"> </a>
<a name="ln7437">  /*</a>
<a name="ln7438">   * determine max topline</a>
<a name="ln7439">   */</a>
<a name="ln7440">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln7441">    topline = curwin-&gt;w_topline;</a>
<a name="ln7442">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7443">      if (wp-&gt;w_p_scb &amp;&amp; wp-&gt;w_buffer) {</a>
<a name="ln7444">        y = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - get_scrolloff_value(curwin);</a>
<a name="ln7445">        if (topline &gt; y) {</a>
<a name="ln7446">          topline = y;</a>
<a name="ln7447">        }</a>
<a name="ln7448">      }</a>
<a name="ln7449">    }</a>
<a name="ln7450">    if (topline &lt; 1) {</a>
<a name="ln7451">      topline = 1;</a>
<a name="ln7452">    }</a>
<a name="ln7453">  } else {</a>
<a name="ln7454">    topline = 1;</a>
<a name="ln7455">  }</a>
<a name="ln7456"> </a>
<a name="ln7457"> </a>
<a name="ln7458">  /*</a>
<a name="ln7459">   * Set all scrollbind windows to the same topline.</a>
<a name="ln7460">   */</a>
<a name="ln7461">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7462">    curwin = wp;</a>
<a name="ln7463">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln7464">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln7465">      y = topline - curwin-&gt;w_topline;</a>
<a name="ln7466">      if (y &gt; 0)</a>
<a name="ln7467">        scrollup(y, TRUE);</a>
<a name="ln7468">      else</a>
<a name="ln7469">        scrolldown(-y, TRUE);</a>
<a name="ln7470">      curwin-&gt;w_scbind_pos = topline;</a>
<a name="ln7471">      redraw_later(curwin, VALID);</a>
<a name="ln7472">      cursor_correct();</a>
<a name="ln7473">      curwin-&gt;w_redr_status = TRUE;</a>
<a name="ln7474">    }</a>
<a name="ln7475">  }</a>
<a name="ln7476">  curwin = save_curwin;</a>
<a name="ln7477">  curbuf = save_curbuf;</a>
<a name="ln7478">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln7479">    did_syncbind = TRUE;</a>
<a name="ln7480">    checkpcmark();</a>
<a name="ln7481">    if (old_linenr != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln7482">      char_u ctrl_o[2];</a>
<a name="ln7483"> </a>
<a name="ln7484">      ctrl_o[0] = Ctrl_O;</a>
<a name="ln7485">      ctrl_o[1] = 0;</a>
<a name="ln7486">      ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);</a>
<a name="ln7487">    }</a>
<a name="ln7488">  }</a>
<a name="ln7489">}</a>
<a name="ln7490"> </a>
<a name="ln7491"> </a>
<a name="ln7492">static void ex_read(exarg_T *eap)</a>
<a name="ln7493">{</a>
<a name="ln7494">  int i;</a>
<a name="ln7495">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln7496">  linenr_T lnum;</a>
<a name="ln7497"> </a>
<a name="ln7498">  if (eap-&gt;usefilter) {  // :r!cmd</a>
<a name="ln7499">    do_bang(1, eap, false, false, true);</a>
<a name="ln7500">  } else {</a>
<a name="ln7501">    if (u_save(eap-&gt;line2, (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln7502">      return;</a>
<a name="ln7503">    }</a>
<a name="ln7504"> </a>
<a name="ln7505">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln7506">      if (check_fname() == FAIL)        /* check for no file name */</a>
<a name="ln7507">        return;</a>
<a name="ln7508">      i = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln7509">          eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);</a>
<a name="ln7510">    } else {</a>
<a name="ln7511">      if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)</a>
<a name="ln7512">        (void)setaltfname(eap-&gt;arg, eap-&gt;arg, (linenr_T)1);</a>
<a name="ln7513">      i = readfile(eap-&gt;arg, NULL,</a>
<a name="ln7514">          eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);</a>
<a name="ln7515"> </a>
<a name="ln7516">    }</a>
<a name="ln7517">    if (i != OK) {</a>
<a name="ln7518">      if (!aborting()) {</a>
<a name="ln7519">        EMSG2(_(e_notopen), eap-&gt;arg);</a>
<a name="ln7520">      }</a>
<a name="ln7521">    } else {</a>
<a name="ln7522">      if (empty &amp;&amp; exmode_active) {</a>
<a name="ln7523">        /* Delete the empty line that remains.  Historically ex does</a>
<a name="ln7524">         * this but vi doesn't. */</a>
<a name="ln7525">        if (eap-&gt;line2 == 0)</a>
<a name="ln7526">          lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7527">        else</a>
<a name="ln7528">          lnum = 1;</a>
<a name="ln7529">        if (*ml_get(lnum) == NUL &amp;&amp; u_savedel(lnum, 1L) == OK) {</a>
<a name="ln7530">          ml_delete(lnum, false);</a>
<a name="ln7531">          if (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln7532">              &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= lnum) {</a>
<a name="ln7533">            curwin-&gt;w_cursor.lnum--;</a>
<a name="ln7534">          }</a>
<a name="ln7535">          deleted_lines_mark(lnum, 1L);</a>
<a name="ln7536">        }</a>
<a name="ln7537">      }</a>
<a name="ln7538">      redraw_curbuf_later(VALID);</a>
<a name="ln7539">    }</a>
<a name="ln7540">  }</a>
<a name="ln7541">}</a>
<a name="ln7542"> </a>
<a name="ln7543">static char_u   *prev_dir = NULL;</a>
<a name="ln7544"> </a>
<a name="ln7545">#if defined(EXITFREE)</a>
<a name="ln7546">void free_cd_dir(void)</a>
<a name="ln7547">{</a>
<a name="ln7548">  XFREE_CLEAR(prev_dir);</a>
<a name="ln7549">  XFREE_CLEAR(globaldir);</a>
<a name="ln7550">}</a>
<a name="ln7551"> </a>
<a name="ln7552">#endif</a>
<a name="ln7553"> </a>
<a name="ln7554">/// Deal with the side effects of changing the current directory.</a>
<a name="ln7555">///</a>
<a name="ln7556">/// @param scope  Scope of the function call (global, tab or window).</a>
<a name="ln7557">void post_chdir(CdScope scope, bool trigger_dirchanged)</a>
<a name="ln7558">{</a>
<a name="ln7559">  // Always overwrite the window-local CWD.</a>
<a name="ln7560">  XFREE_CLEAR(curwin-&gt;w_localdir);</a>
<a name="ln7561"> </a>
<a name="ln7562">  // Overwrite the tab-local CWD for :cd, :tcd.</a>
<a name="ln7563">  if (scope &gt;= kCdScopeTab) {</a>
<a name="ln7564">    XFREE_CLEAR(curtab-&gt;tp_localdir);</a>
<a name="ln7565">  }</a>
<a name="ln7566"> </a>
<a name="ln7567">  if (scope &lt; kCdScopeGlobal) {</a>
<a name="ln7568">    // If still in global directory, set CWD as the global directory.</a>
<a name="ln7569">    if (globaldir == NULL &amp;&amp; prev_dir != NULL) {</a>
<a name="ln7570">      globaldir = vim_strsave(prev_dir);</a>
<a name="ln7571">    }</a>
<a name="ln7572">  }</a>
<a name="ln7573"> </a>
<a name="ln7574">  char cwd[MAXPATHL];</a>
<a name="ln7575">  if (os_dirname((char_u *)cwd, MAXPATHL) != OK) {</a>
<a name="ln7576">    return;</a>
<a name="ln7577">  }</a>
<a name="ln7578">  switch (scope) {</a>
<a name="ln7579">  case kCdScopeGlobal:</a>
<a name="ln7580">    // We are now in the global directory, no need to remember its name.</a>
<a name="ln7581">    XFREE_CLEAR(globaldir);</a>
<a name="ln7582">    break;</a>
<a name="ln7583">  case kCdScopeTab:</a>
<a name="ln7584">    curtab-&gt;tp_localdir = (char_u *)xstrdup(cwd);</a>
<a name="ln7585">    break;</a>
<a name="ln7586">  case kCdScopeWindow:</a>
<a name="ln7587">    curwin-&gt;w_localdir = (char_u *)xstrdup(cwd);</a>
<a name="ln7588">    break;</a>
<a name="ln7589">  case kCdScopeInvalid:</a>
<a name="ln7590">    assert(false);</a>
<a name="ln7591">  }</a>
<a name="ln7592"> </a>
<a name="ln7593">  shorten_fnames(true);</a>
<a name="ln7594"> </a>
<a name="ln7595">  if (trigger_dirchanged) {</a>
<a name="ln7596">    do_autocmd_dirchanged(cwd, scope, false);</a>
<a name="ln7597">  }</a>
<a name="ln7598">}</a>
<a name="ln7599"> </a>
<a name="ln7600">/// `:cd`, `:tcd`, `:lcd`, `:chdir`, `:tchdir` and `:lchdir`.</a>
<a name="ln7601">void ex_cd(exarg_T *eap)</a>
<a name="ln7602">{</a>
<a name="ln7603">  char_u              *new_dir;</a>
<a name="ln7604">  char_u              *tofree;</a>
<a name="ln7605"> </a>
<a name="ln7606">  new_dir = eap-&gt;arg;</a>
<a name="ln7607">#if !defined(UNIX)</a>
<a name="ln7608">  /* for non-UNIX &quot;:cd&quot; means: print current directory */</a>
<a name="ln7609">  if (*new_dir == NUL)</a>
<a name="ln7610">    ex_pwd(NULL);</a>
<a name="ln7611">  else</a>
<a name="ln7612">#endif</a>
<a name="ln7613">  {</a>
<a name="ln7614">    if (allbuf_locked())</a>
<a name="ln7615">      return;</a>
<a name="ln7616"> </a>
<a name="ln7617">    /* &quot;:cd -&quot;: Change to previous directory */</a>
<a name="ln7618">    if (STRCMP(new_dir, &quot;-&quot;) == 0) {</a>
<a name="ln7619">      if (prev_dir == NULL) {</a>
<a name="ln7620">        EMSG(_(&quot;E186: No previous directory&quot;));</a>
<a name="ln7621">        return;</a>
<a name="ln7622">      }</a>
<a name="ln7623">      new_dir = prev_dir;</a>
<a name="ln7624">    }</a>
<a name="ln7625"> </a>
<a name="ln7626">    /* Save current directory for next &quot;:cd -&quot; */</a>
<a name="ln7627">    tofree = prev_dir;</a>
<a name="ln7628">    if (os_dirname(NameBuff, MAXPATHL) == OK)</a>
<a name="ln7629">      prev_dir = vim_strsave(NameBuff);</a>
<a name="ln7630">    else</a>
<a name="ln7631">      prev_dir = NULL;</a>
<a name="ln7632"> </a>
<a name="ln7633">#if defined(UNIX)</a>
<a name="ln7634">    // On Unix &quot;:cd&quot; means: go to home directory.</a>
<a name="ln7635">    if (*new_dir == NUL) {</a>
<a name="ln7636">      // Use NameBuff for home directory name.</a>
<a name="ln7637">      expand_env((char_u *)&quot;$HOME&quot;, NameBuff, MAXPATHL);</a>
<a name="ln7638">      new_dir = NameBuff;</a>
<a name="ln7639">    }</a>
<a name="ln7640">#endif</a>
<a name="ln7641">    CdScope scope = kCdScopeGlobal;  // Depends on command invoked</a>
<a name="ln7642"> </a>
<a name="ln7643">    switch (eap-&gt;cmdidx) {</a>
<a name="ln7644">    case CMD_tcd:</a>
<a name="ln7645">    case CMD_tchdir:</a>
<a name="ln7646">      scope = kCdScopeTab;</a>
<a name="ln7647">      break;</a>
<a name="ln7648">    case CMD_lcd:</a>
<a name="ln7649">    case CMD_lchdir:</a>
<a name="ln7650">      scope = kCdScopeWindow;</a>
<a name="ln7651">      break;</a>
<a name="ln7652">    default:</a>
<a name="ln7653">      break;</a>
<a name="ln7654">    }</a>
<a name="ln7655"> </a>
<a name="ln7656">    if (vim_chdir(new_dir)) {</a>
<a name="ln7657">      EMSG(_(e_failed));</a>
<a name="ln7658">    } else {</a>
<a name="ln7659">      post_chdir(scope, true);</a>
<a name="ln7660">      // Echo the new current directory if the command was typed.</a>
<a name="ln7661">      if (KeyTyped || p_verbose &gt;= 5) {</a>
<a name="ln7662">        ex_pwd(eap);</a>
<a name="ln7663">      }</a>
<a name="ln7664">    }</a>
<a name="ln7665"> </a>
<a name="ln7666">    xfree(tofree);</a>
<a name="ln7667">  }</a>
<a name="ln7668">}</a>
<a name="ln7669"> </a>
<a name="ln7670">/*</a>
<a name="ln7671"> * &quot;:pwd&quot;.</a>
<a name="ln7672"> */</a>
<a name="ln7673">static void ex_pwd(exarg_T *eap)</a>
<a name="ln7674">{</a>
<a name="ln7675">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln7676">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7677">    slash_adjust(NameBuff);</a>
<a name="ln7678">#endif</a>
<a name="ln7679">    msg(NameBuff);</a>
<a name="ln7680">  } else</a>
<a name="ln7681">    EMSG(_(&quot;E187: Unknown&quot;));</a>
<a name="ln7682">}</a>
<a name="ln7683"> </a>
<a name="ln7684">/*</a>
<a name="ln7685"> * &quot;:=&quot;.</a>
<a name="ln7686"> */</a>
<a name="ln7687">static void ex_equal(exarg_T *eap)</a>
<a name="ln7688">{</a>
<a name="ln7689">  smsg(&quot;%&quot; PRId64, (int64_t)eap-&gt;line2);</a>
<a name="ln7690">  ex_may_print(eap);</a>
<a name="ln7691">}</a>
<a name="ln7692"> </a>
<a name="ln7693">static void ex_sleep(exarg_T *eap)</a>
<a name="ln7694">{</a>
<a name="ln7695">  int n;</a>
<a name="ln7696">  long len;</a>
<a name="ln7697"> </a>
<a name="ln7698">  if (cursor_valid()) {</a>
<a name="ln7699">    n = curwin-&gt;w_winrow + curwin-&gt;w_wrow - msg_scrolled;</a>
<a name="ln7700">    if (n &gt;= 0)</a>
<a name="ln7701">      ui_cursor_goto(n, curwin-&gt;w_wincol + curwin-&gt;w_wcol);</a>
<a name="ln7702">  }</a>
<a name="ln7703"> </a>
<a name="ln7704">  len = eap-&gt;line2;</a>
<a name="ln7705">  switch (*eap-&gt;arg) {</a>
<a name="ln7706">  case 'm': break;</a>
<a name="ln7707">  case NUL: len *= 1000L; break;</a>
<a name="ln7708">  default: EMSG2(_(e_invarg2), eap-&gt;arg); return;</a>
<a name="ln7709">  }</a>
<a name="ln7710">  do_sleep(len);</a>
<a name="ln7711">}</a>
<a name="ln7712"> </a>
<a name="ln7713">/*</a>
<a name="ln7714"> * Sleep for &quot;msec&quot; milliseconds, but keep checking for a CTRL-C every second.</a>
<a name="ln7715"> */</a>
<a name="ln7716">void do_sleep(long msec)</a>
<a name="ln7717">{</a>
<a name="ln7718">  ui_flush();  // flush before waiting</a>
<a name="ln7719">  for (long left = msec; !got_int &amp;&amp; left &gt; 0; left -= 1000L) {</a>
<a name="ln7720">    int next = left &gt; 1000l ? 1000 : (int)left;</a>
<a name="ln7721">    LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, (int)next, got_int);</a>
<a name="ln7722">    os_breakcheck();</a>
<a name="ln7723">  }</a>
<a name="ln7724"> </a>
<a name="ln7725">  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the</a>
<a name="ln7726">  // input buffer, otherwise a following call to input() fails.</a>
<a name="ln7727">  if (got_int) {</a>
<a name="ln7728">    (void)vpeekc();</a>
<a name="ln7729">  }</a>
<a name="ln7730">}</a>
<a name="ln7731"> </a>
<a name="ln7732">static void do_exmap(exarg_T *eap, int isabbrev)</a>
<a name="ln7733">{</a>
<a name="ln7734">  int mode;</a>
<a name="ln7735">  char_u  *cmdp;</a>
<a name="ln7736"> </a>
<a name="ln7737">  cmdp = eap-&gt;cmd;</a>
<a name="ln7738">  mode = get_map_mode(&amp;cmdp, eap-&gt;forceit || isabbrev);</a>
<a name="ln7739"> </a>
<a name="ln7740">  switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),</a>
<a name="ln7741">              eap-&gt;arg, mode, isabbrev)) {</a>
<a name="ln7742">  case 1: EMSG(_(e_invarg));</a>
<a name="ln7743">    break;</a>
<a name="ln7744">  case 2: EMSG(isabbrev ? _(e_noabbr) : _(e_nomap));</a>
<a name="ln7745">    break;</a>
<a name="ln7746">  }</a>
<a name="ln7747">}</a>
<a name="ln7748"> </a>
<a name="ln7749">/*</a>
<a name="ln7750"> * &quot;:winsize&quot; command (obsolete).</a>
<a name="ln7751"> */</a>
<a name="ln7752">static void ex_winsize(exarg_T *eap)</a>
<a name="ln7753">{</a>
<a name="ln7754">  char_u *arg = eap-&gt;arg;</a>
<a name="ln7755">  int w = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln7756">  arg = skipwhite(arg);</a>
<a name="ln7757">  char_u *p = arg;</a>
<a name="ln7758">  int h = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln7759">  if (*p != NUL &amp;&amp; *arg == NUL) {</a>
<a name="ln7760">    screen_resize(w, h);</a>
<a name="ln7761">  } else {</a>
<a name="ln7762">    EMSG(_(&quot;E465: :winsize requires two number arguments&quot;));</a>
<a name="ln7763">  }</a>
<a name="ln7764">}</a>
<a name="ln7765"> </a>
<a name="ln7766">static void ex_wincmd(exarg_T *eap)</a>
<a name="ln7767">{</a>
<a name="ln7768">  int xchar = NUL;</a>
<a name="ln7769">  char_u      *p;</a>
<a name="ln7770"> </a>
<a name="ln7771">  if (*eap-&gt;arg == 'g' || *eap-&gt;arg == Ctrl_G) {</a>
<a name="ln7772">    /* CTRL-W g and CTRL-W CTRL-G  have an extra command character */</a>
<a name="ln7773">    if (eap-&gt;arg[1] == NUL) {</a>
<a name="ln7774">      EMSG(_(e_invarg));</a>
<a name="ln7775">      return;</a>
<a name="ln7776">    }</a>
<a name="ln7777">    xchar = eap-&gt;arg[1];</a>
<a name="ln7778">    p = eap-&gt;arg + 2;</a>
<a name="ln7779">  } else</a>
<a name="ln7780">    p = eap-&gt;arg + 1;</a>
<a name="ln7781"> </a>
<a name="ln7782">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln7783">  p = skipwhite(p);</a>
<a name="ln7784">  if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; eap-&gt;nextcmd == NULL)</a>
<a name="ln7785">    EMSG(_(e_invarg));</a>
<a name="ln7786">  else if (!eap-&gt;skip) {</a>
<a name="ln7787">    /* Pass flags on for &quot;:vertical wincmd ]&quot;. */</a>
<a name="ln7788">    postponed_split_flags = cmdmod.split;</a>
<a name="ln7789">    postponed_split_tab = cmdmod.tab;</a>
<a name="ln7790">    do_window(*eap-&gt;arg, eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0L, xchar);</a>
<a name="ln7791">    postponed_split_flags = 0;</a>
<a name="ln7792">    postponed_split_tab = 0;</a>
<a name="ln7793">  }</a>
<a name="ln7794">}</a>
<a name="ln7795"> </a>
<a name="ln7796">/*</a>
<a name="ln7797"> * Handle command that work like operators: &quot;:delete&quot;, &quot;:yank&quot;, &quot;:&gt;&quot; and &quot;:&lt;&quot;.</a>
<a name="ln7798"> */</a>
<a name="ln7799">static void ex_operators(exarg_T *eap)</a>
<a name="ln7800">{</a>
<a name="ln7801">  oparg_T oa;</a>
<a name="ln7802"> </a>
<a name="ln7803">  clear_oparg(&amp;oa);</a>
<a name="ln7804">  oa.regname = eap-&gt;regname;</a>
<a name="ln7805">  oa.start.lnum = eap-&gt;line1;</a>
<a name="ln7806">  oa.end.lnum = eap-&gt;line2;</a>
<a name="ln7807">  oa.line_count = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln7808">  oa.motion_type = kMTLineWise;</a>
<a name="ln7809">  virtual_op = kFalse;</a>
<a name="ln7810">  if (eap-&gt;cmdidx != CMD_yank) {  // position cursor for undo</a>
<a name="ln7811">    setpcmark();</a>
<a name="ln7812">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln7813">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln7814">  }</a>
<a name="ln7815"> </a>
<a name="ln7816">  if (VIsual_active)</a>
<a name="ln7817">    end_visual_mode();</a>
<a name="ln7818"> </a>
<a name="ln7819">  switch (eap-&gt;cmdidx) {</a>
<a name="ln7820">  case CMD_delete:</a>
<a name="ln7821">    oa.op_type = OP_DELETE;</a>
<a name="ln7822">    op_delete(&amp;oa);</a>
<a name="ln7823">    break;</a>
<a name="ln7824"> </a>
<a name="ln7825">  case CMD_yank:</a>
<a name="ln7826">    oa.op_type = OP_YANK;</a>
<a name="ln7827">    (void)op_yank(&amp;oa, true, false);</a>
<a name="ln7828">    break;</a>
<a name="ln7829"> </a>
<a name="ln7830">  default:          /* CMD_rshift or CMD_lshift */</a>
<a name="ln7831">    if (</a>
<a name="ln7832">      (eap-&gt;cmdidx == CMD_rshift) ^ curwin-&gt;w_p_rl</a>
<a name="ln7833">      )</a>
<a name="ln7834">      oa.op_type = OP_RSHIFT;</a>
<a name="ln7835">    else</a>
<a name="ln7836">      oa.op_type = OP_LSHIFT;</a>
<a name="ln7837">    op_shift(&amp;oa, FALSE, eap-&gt;amount);</a>
<a name="ln7838">    break;</a>
<a name="ln7839">  }</a>
<a name="ln7840">  virtual_op = kNone;</a>
<a name="ln7841">  ex_may_print(eap);</a>
<a name="ln7842">}</a>
<a name="ln7843"> </a>
<a name="ln7844">/*</a>
<a name="ln7845"> * &quot;:put&quot;.</a>
<a name="ln7846"> */</a>
<a name="ln7847">static void ex_put(exarg_T *eap)</a>
<a name="ln7848">{</a>
<a name="ln7849">  /* &quot;:0put&quot; works like &quot;:1put!&quot;. */</a>
<a name="ln7850">  if (eap-&gt;line2 == 0) {</a>
<a name="ln7851">    eap-&gt;line2 = 1;</a>
<a name="ln7852">    eap-&gt;forceit = TRUE;</a>
<a name="ln7853">  }</a>
<a name="ln7854">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln7855">  do_put(eap-&gt;regname, NULL, eap-&gt;forceit ? BACKWARD : FORWARD, 1,</a>
<a name="ln7856">         PUT_LINE|PUT_CURSLINE);</a>
<a name="ln7857">}</a>
<a name="ln7858"> </a>
<a name="ln7859">/*</a>
<a name="ln7860"> * Handle &quot;:copy&quot; and &quot;:move&quot;.</a>
<a name="ln7861"> */</a>
<a name="ln7862">static void ex_copymove(exarg_T *eap)</a>
<a name="ln7863">{</a>
<a name="ln7864">  long n = get_address(eap, &amp;eap-&gt;arg, eap-&gt;addr_type, false, false, false, 1);</a>
<a name="ln7865">  if (eap-&gt;arg == NULL) {  // error detected</a>
<a name="ln7866">    eap-&gt;nextcmd = NULL;</a>
<a name="ln7867">    return;</a>
<a name="ln7868">  }</a>
<a name="ln7869">  get_flags(eap);</a>
<a name="ln7870"> </a>
<a name="ln7871">  /*</a>
<a name="ln7872">   * move or copy lines from 'eap-&gt;line1'-'eap-&gt;line2' to below line 'n'</a>
<a name="ln7873">   */</a>
<a name="ln7874">  if (n == MAXLNUM || n &lt; 0 || n &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7875">    EMSG(_(e_invrange));</a>
<a name="ln7876">    return;</a>
<a name="ln7877">  }</a>
<a name="ln7878"> </a>
<a name="ln7879">  if (eap-&gt;cmdidx == CMD_move) {</a>
<a name="ln7880">    if (do_move(eap-&gt;line1, eap-&gt;line2, n) == FAIL)</a>
<a name="ln7881">      return;</a>
<a name="ln7882">  } else</a>
<a name="ln7883">    ex_copy(eap-&gt;line1, eap-&gt;line2, n);</a>
<a name="ln7884">  u_clearline();</a>
<a name="ln7885">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln7886">  ex_may_print(eap);</a>
<a name="ln7887">}</a>
<a name="ln7888"> </a>
<a name="ln7889">/*</a>
<a name="ln7890"> * Print the current line if flags were given to the Ex command.</a>
<a name="ln7891"> */</a>
<a name="ln7892">void ex_may_print(exarg_T *eap)</a>
<a name="ln7893">{</a>
<a name="ln7894">  if (eap-&gt;flags != 0) {</a>
<a name="ln7895">    print_line(curwin-&gt;w_cursor.lnum, (eap-&gt;flags &amp; EXFLAG_NR),</a>
<a name="ln7896">        (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln7897">    ex_no_reprint = TRUE;</a>
<a name="ln7898">  }</a>
<a name="ln7899">}</a>
<a name="ln7900"> </a>
<a name="ln7901">/// &quot;:smagic&quot; and &quot;:snomagic&quot;.</a>
<a name="ln7902">static void ex_submagic(exarg_T *eap)</a>
<a name="ln7903">{</a>
<a name="ln7904">  int magic_save = p_magic;</a>
<a name="ln7905"> </a>
<a name="ln7906">  p_magic = (eap-&gt;cmdidx == CMD_smagic);</a>
<a name="ln7907">  ex_substitute(eap);</a>
<a name="ln7908">  p_magic = magic_save;</a>
<a name="ln7909">}</a>
<a name="ln7910"> </a>
<a name="ln7911">/*</a>
<a name="ln7912"> * &quot;:join&quot;.</a>
<a name="ln7913"> */</a>
<a name="ln7914">static void ex_join(exarg_T *eap)</a>
<a name="ln7915">{</a>
<a name="ln7916">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln7917">  if (eap-&gt;line1 == eap-&gt;line2) {</a>
<a name="ln7918">    if (eap-&gt;addr_count &gt;= 2)       /* :2,2join does nothing */</a>
<a name="ln7919">      return;</a>
<a name="ln7920">    if (eap-&gt;line2 == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7921">      beep_flush();</a>
<a name="ln7922">      return;</a>
<a name="ln7923">    }</a>
<a name="ln7924">    ++eap-&gt;line2;</a>
<a name="ln7925">  }</a>
<a name="ln7926">  do_join(eap-&gt;line2 - eap-&gt;line1 + 1, !eap-&gt;forceit, TRUE, TRUE, true);</a>
<a name="ln7927">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln7928">  ex_may_print(eap);</a>
<a name="ln7929">}</a>
<a name="ln7930"> </a>
<a name="ln7931">/*</a>
<a name="ln7932"> * &quot;:[addr]@r&quot;: execute register</a>
<a name="ln7933"> */</a>
<a name="ln7934">static void ex_at(exarg_T *eap)</a>
<a name="ln7935">{</a>
<a name="ln7936">  int prev_len = typebuf.tb_len;</a>
<a name="ln7937"> </a>
<a name="ln7938">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln7939">  check_cursor_col();</a>
<a name="ln7940"> </a>
<a name="ln7941">  // Get the register name. No name means use the previous one.</a>
<a name="ln7942">  int c = *eap-&gt;arg;</a>
<a name="ln7943">  if (c == NUL) {</a>
<a name="ln7944">    c = '@';</a>
<a name="ln7945">  }</a>
<a name="ln7946"> </a>
<a name="ln7947">  /* Put the register in the typeahead buffer with the &quot;silent&quot; flag. */</a>
<a name="ln7948">  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)</a>
<a name="ln7949">      == FAIL) {</a>
<a name="ln7950">    beep_flush();</a>
<a name="ln7951">  } else {</a>
<a name="ln7952">    int save_efr = exec_from_reg;</a>
<a name="ln7953"> </a>
<a name="ln7954">    exec_from_reg = TRUE;</a>
<a name="ln7955"> </a>
<a name="ln7956">    /*</a>
<a name="ln7957">     * Execute from the typeahead buffer.</a>
<a name="ln7958">     * Continue until the stuff buffer is empty and all added characters</a>
<a name="ln7959">     * have been consumed.</a>
<a name="ln7960">     */</a>
<a name="ln7961">    while (!stuff_empty() || typebuf.tb_len &gt; prev_len)</a>
<a name="ln7962">      (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln7963"> </a>
<a name="ln7964">    exec_from_reg = save_efr;</a>
<a name="ln7965">  }</a>
<a name="ln7966">}</a>
<a name="ln7967"> </a>
<a name="ln7968">/*</a>
<a name="ln7969"> * &quot;:!&quot;.</a>
<a name="ln7970"> */</a>
<a name="ln7971">static void ex_bang(exarg_T *eap)</a>
<a name="ln7972">{</a>
<a name="ln7973">  do_bang(eap-&gt;addr_count, eap, eap-&gt;forceit, true, true);</a>
<a name="ln7974">}</a>
<a name="ln7975"> </a>
<a name="ln7976">/*</a>
<a name="ln7977"> * &quot;:undo&quot;.</a>
<a name="ln7978"> */</a>
<a name="ln7979">static void ex_undo(exarg_T *eap)</a>
<a name="ln7980">{</a>
<a name="ln7981">  if (eap-&gt;addr_count == 1) {       // :undo 123</a>
<a name="ln7982">    undo_time(eap-&gt;line2, false, false, true);</a>
<a name="ln7983">  } else {</a>
<a name="ln7984">    u_undo(1);</a>
<a name="ln7985">  }</a>
<a name="ln7986">}</a>
<a name="ln7987"> </a>
<a name="ln7988">static void ex_wundo(exarg_T *eap)</a>
<a name="ln7989">{</a>
<a name="ln7990">  char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln7991"> </a>
<a name="ln7992">  u_compute_hash(hash);</a>
<a name="ln7993">  u_write_undo((char *) eap-&gt;arg, eap-&gt;forceit, curbuf, hash);</a>
<a name="ln7994">}</a>
<a name="ln7995"> </a>
<a name="ln7996">static void ex_rundo(exarg_T *eap)</a>
<a name="ln7997">{</a>
<a name="ln7998">  char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln7999"> </a>
<a name="ln8000">  u_compute_hash(hash);</a>
<a name="ln8001">  u_read_undo((char *) eap-&gt;arg, hash, NULL);</a>
<a name="ln8002">}</a>
<a name="ln8003"> </a>
<a name="ln8004">/// &quot;:redo&quot;.</a>
<a name="ln8005">static void ex_redo(exarg_T *eap)</a>
<a name="ln8006">{</a>
<a name="ln8007">  u_redo(1);</a>
<a name="ln8008">}</a>
<a name="ln8009"> </a>
<a name="ln8010">/// &quot;:earlier&quot; and &quot;:later&quot;.</a>
<a name="ln8011">static void ex_later(exarg_T *eap)</a>
<a name="ln8012">{</a>
<a name="ln8013">  long count = 0;</a>
<a name="ln8014">  bool sec = false;</a>
<a name="ln8015">  bool file = false;</a>
<a name="ln8016">  char_u      *p = eap-&gt;arg;</a>
<a name="ln8017"> </a>
<a name="ln8018">  if (*p == NUL) {</a>
<a name="ln8019">    count = 1;</a>
<a name="ln8020">  } else if (isdigit(*p)) {</a>
<a name="ln8021">    count = getdigits_long(&amp;p, false, 0);</a>
<a name="ln8022">    switch (*p) {</a>
<a name="ln8023">    case 's': ++p; sec = true; break;</a>
<a name="ln8024">    case 'm': ++p; sec = true; count *= 60; break;</a>
<a name="ln8025">    case 'h': ++p; sec = true; count *= 60 * 60; break;</a>
<a name="ln8026">    case 'd': ++p; sec = true; count *= 24 * 60 * 60; break;</a>
<a name="ln8027">    case 'f': ++p; file = true; break;</a>
<a name="ln8028">    }</a>
<a name="ln8029">  }</a>
<a name="ln8030"> </a>
<a name="ln8031">  if (*p != NUL) {</a>
<a name="ln8032">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8033">  } else {</a>
<a name="ln8034">    undo_time(eap-&gt;cmdidx == CMD_earlier ? -count : count,</a>
<a name="ln8035">              sec, file, false);</a>
<a name="ln8036">  }</a>
<a name="ln8037">}</a>
<a name="ln8038"> </a>
<a name="ln8039">/*</a>
<a name="ln8040"> * &quot;:redir&quot;: start/stop redirection.</a>
<a name="ln8041"> */</a>
<a name="ln8042">static void ex_redir(exarg_T *eap)</a>
<a name="ln8043">{</a>
<a name="ln8044">  char        *mode;</a>
<a name="ln8045">  char_u      *fname;</a>
<a name="ln8046">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln8047"> </a>
<a name="ln8048">  if (STRICMP(eap-&gt;arg, &quot;END&quot;) == 0)</a>
<a name="ln8049">    close_redir();</a>
<a name="ln8050">  else {</a>
<a name="ln8051">    if (*arg == '&gt;') {</a>
<a name="ln8052">      ++arg;</a>
<a name="ln8053">      if (*arg == '&gt;') {</a>
<a name="ln8054">        ++arg;</a>
<a name="ln8055">        mode = &quot;a&quot;;</a>
<a name="ln8056">      } else</a>
<a name="ln8057">        mode = &quot;w&quot;;</a>
<a name="ln8058">      arg = skipwhite(arg);</a>
<a name="ln8059"> </a>
<a name="ln8060">      close_redir();</a>
<a name="ln8061"> </a>
<a name="ln8062">      /* Expand environment variables and &quot;~/&quot;. */</a>
<a name="ln8063">      fname = expand_env_save(arg);</a>
<a name="ln8064">      if (fname == NULL)</a>
<a name="ln8065">        return;</a>
<a name="ln8066"> </a>
<a name="ln8067">      redir_fd = open_exfile(fname, eap-&gt;forceit, mode);</a>
<a name="ln8068">      xfree(fname);</a>
<a name="ln8069">    } else if (*arg == '@') {</a>
<a name="ln8070">      /* redirect to a register a-z (resp. A-Z for appending) */</a>
<a name="ln8071">      close_redir();</a>
<a name="ln8072">      ++arg;</a>
<a name="ln8073">      if (valid_yank_reg(*arg, true) &amp;&amp; *arg != '_') {</a>
<a name="ln8074">        redir_reg = *arg++;</a>
<a name="ln8075">        if (*arg == '&gt;' &amp;&amp; arg[1] == '&gt;')          /* append */</a>
<a name="ln8076">          arg += 2;</a>
<a name="ln8077">        else {</a>
<a name="ln8078">          /* Can use both &quot;@a&quot; and &quot;@a&gt;&quot;. */</a>
<a name="ln8079">          if (*arg == '&gt;')</a>
<a name="ln8080">            arg++;</a>
<a name="ln8081">          // Make register empty when not using @A-@Z and the</a>
<a name="ln8082">          // command is valid.</a>
<a name="ln8083">          if (*arg == NUL &amp;&amp; !isupper(redir_reg)) {</a>
<a name="ln8084">            write_reg_contents(redir_reg, (char_u *)&quot;&quot;, 0, false);</a>
<a name="ln8085">          }</a>
<a name="ln8086">        }</a>
<a name="ln8087">      }</a>
<a name="ln8088">      if (*arg != NUL) {</a>
<a name="ln8089">        redir_reg = 0;</a>
<a name="ln8090">        EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8091">      }</a>
<a name="ln8092">    } else if (*arg == '=' &amp;&amp; arg[1] == '&gt;') {</a>
<a name="ln8093">      int append;</a>
<a name="ln8094"> </a>
<a name="ln8095">      /* redirect to a variable */</a>
<a name="ln8096">      close_redir();</a>
<a name="ln8097">      arg += 2;</a>
<a name="ln8098"> </a>
<a name="ln8099">      if (*arg == '&gt;') {</a>
<a name="ln8100">        ++arg;</a>
<a name="ln8101">        append = TRUE;</a>
<a name="ln8102">      } else</a>
<a name="ln8103">        append = FALSE;</a>
<a name="ln8104"> </a>
<a name="ln8105">      if (var_redir_start(skipwhite(arg), append) == OK)</a>
<a name="ln8106">        redir_vname = 1;</a>
<a name="ln8107">    }</a>
<a name="ln8108">    /* TODO: redirect to a buffer */</a>
<a name="ln8109">    else</a>
<a name="ln8110">      EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln8111">  }</a>
<a name="ln8112"> </a>
<a name="ln8113">  /* Make sure redirection is not off.  Can happen for cmdline completion</a>
<a name="ln8114">   * that indirectly invokes a command to catch its output. */</a>
<a name="ln8115">  if (redir_fd != NULL</a>
<a name="ln8116">      || redir_reg || redir_vname</a>
<a name="ln8117">      )</a>
<a name="ln8118">    redir_off = FALSE;</a>
<a name="ln8119">}</a>
<a name="ln8120"> </a>
<a name="ln8121">/// &quot;:redraw&quot;: force redraw</a>
<a name="ln8122">static void ex_redraw(exarg_T *eap)</a>
<a name="ln8123">{</a>
<a name="ln8124">  if (State &amp; CMDPREVIEW) {</a>
<a name="ln8125">    return;  // Ignore :redraw during 'inccommand' preview. #9777</a>
<a name="ln8126">  }</a>
<a name="ln8127">  int r = RedrawingDisabled;</a>
<a name="ln8128">  int p = p_lz;</a>
<a name="ln8129"> </a>
<a name="ln8130">  RedrawingDisabled = 0;</a>
<a name="ln8131">  p_lz = FALSE;</a>
<a name="ln8132">  validate_cursor();</a>
<a name="ln8133">  update_topline(curwin);</a>
<a name="ln8134">  if (eap-&gt;forceit) {</a>
<a name="ln8135">    redraw_all_later(NOT_VALID);</a>
<a name="ln8136">  }</a>
<a name="ln8137">  update_screen(eap-&gt;forceit ? NOT_VALID</a>
<a name="ln8138">                : VIsual_active ? INVERTED : 0);</a>
<a name="ln8139">  if (need_maketitle) {</a>
<a name="ln8140">    maketitle();</a>
<a name="ln8141">  }</a>
<a name="ln8142">  RedrawingDisabled = r;</a>
<a name="ln8143">  p_lz = p;</a>
<a name="ln8144"> </a>
<a name="ln8145">  /* Reset msg_didout, so that a message that's there is overwritten. */</a>
<a name="ln8146">  msg_didout = FALSE;</a>
<a name="ln8147">  msg_col = 0;</a>
<a name="ln8148"> </a>
<a name="ln8149">  /* No need to wait after an intentional redraw. */</a>
<a name="ln8150">  need_wait_return = FALSE;</a>
<a name="ln8151"> </a>
<a name="ln8152">  ui_flush();</a>
<a name="ln8153">}</a>
<a name="ln8154"> </a>
<a name="ln8155">/// &quot;:redrawstatus&quot;: force redraw of status line(s)</a>
<a name="ln8156">static void ex_redrawstatus(exarg_T *eap)</a>
<a name="ln8157">{</a>
<a name="ln8158">  if (State &amp; CMDPREVIEW) {</a>
<a name="ln8159">    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777</a>
<a name="ln8160">  }</a>
<a name="ln8161">  int r = RedrawingDisabled;</a>
<a name="ln8162">  int p = p_lz;</a>
<a name="ln8163"> </a>
<a name="ln8164">  RedrawingDisabled = 0;</a>
<a name="ln8165">  p_lz = FALSE;</a>
<a name="ln8166">  if (eap-&gt;forceit)</a>
<a name="ln8167">    status_redraw_all();</a>
<a name="ln8168">  else</a>
<a name="ln8169">    status_redraw_curbuf();</a>
<a name="ln8170">  update_screen(</a>
<a name="ln8171">      VIsual_active ? INVERTED :</a>
<a name="ln8172">      0);</a>
<a name="ln8173">  RedrawingDisabled = r;</a>
<a name="ln8174">  p_lz = p;</a>
<a name="ln8175">  ui_flush();</a>
<a name="ln8176">}</a>
<a name="ln8177"> </a>
<a name="ln8178">// &quot;:redrawtabline&quot;: force redraw of the tabline</a>
<a name="ln8179">static void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)</a>
<a name="ln8180">{</a>
<a name="ln8181">  const int r = RedrawingDisabled;</a>
<a name="ln8182">  const int p = p_lz;</a>
<a name="ln8183"> </a>
<a name="ln8184">  RedrawingDisabled = 0;</a>
<a name="ln8185">  p_lz = false;</a>
<a name="ln8186"> </a>
<a name="ln8187">  draw_tabline();</a>
<a name="ln8188"> </a>
<a name="ln8189">  RedrawingDisabled = r;</a>
<a name="ln8190">  p_lz = p;</a>
<a name="ln8191">  ui_flush();</a>
<a name="ln8192">}</a>
<a name="ln8193"> </a>
<a name="ln8194">static void close_redir(void)</a>
<a name="ln8195">{</a>
<a name="ln8196">  if (redir_fd != NULL) {</a>
<a name="ln8197">    fclose(redir_fd);</a>
<a name="ln8198">    redir_fd = NULL;</a>
<a name="ln8199">  }</a>
<a name="ln8200">  redir_reg = 0;</a>
<a name="ln8201">  if (redir_vname) {</a>
<a name="ln8202">    var_redir_stop();</a>
<a name="ln8203">    redir_vname = 0;</a>
<a name="ln8204">  }</a>
<a name="ln8205">}</a>
<a name="ln8206"> </a>
<a name="ln8207">/// Try creating a directory, give error message on failure</a>
<a name="ln8208">///</a>
<a name="ln8209">/// @param[in]  name  Directory to create.</a>
<a name="ln8210">/// @param[in]  prot  Directory permissions.</a>
<a name="ln8211">///</a>
<a name="ln8212">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln8213">int vim_mkdir_emsg(const char *const name, const int prot)</a>
<a name="ln8214">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8215">{</a>
<a name="ln8216">  int ret;</a>
<a name="ln8217">  if ((ret = os_mkdir(name, prot)) != 0) {</a>
<a name="ln8218">    EMSG3(_(e_mkdir), name, os_strerror(ret));</a>
<a name="ln8219">    return FAIL;</a>
<a name="ln8220">  }</a>
<a name="ln8221">  return OK;</a>
<a name="ln8222">}</a>
<a name="ln8223"> </a>
<a name="ln8224">/*</a>
<a name="ln8225"> * Open a file for writing for an Ex command, with some checks.</a>
<a name="ln8226"> * Return file descriptor, or NULL on failure.</a>
<a name="ln8227"> */</a>
<a name="ln8228">FILE *</a>
<a name="ln8229">open_exfile (</a>
<a name="ln8230">    char_u *fname,</a>
<a name="ln8231">    int forceit,</a>
<a name="ln8232">    char *mode          /* &quot;w&quot; for create new file or &quot;a&quot; for append */</a>
<a name="ln8233">)</a>
<a name="ln8234">{</a>
<a name="ln8235">  FILE        *fd;</a>
<a name="ln8236"> </a>
<a name="ln8237">#ifdef UNIX</a>
<a name="ln8238">  /* with Unix it is possible to open a directory */</a>
<a name="ln8239">  if (os_isdir(fname)) {</a>
<a name="ln8240">    EMSG2(_(e_isadir2), fname);</a>
<a name="ln8241">    return NULL;</a>
<a name="ln8242">  }</a>
<a name="ln8243">#endif</a>
<a name="ln8244">  if (!forceit &amp;&amp; *mode != 'a' &amp;&amp; os_path_exists(fname)) {</a>
<a name="ln8245">    EMSG2(_(&quot;E189: \&quot;%s\&quot; exists (add ! to override)&quot;), fname);</a>
<a name="ln8246">    return NULL;</a>
<a name="ln8247">  }</a>
<a name="ln8248"> </a>
<a name="ln8249">  if ((fd = os_fopen((char *)fname, mode)) == NULL) {</a>
<a name="ln8250">    EMSG2(_(&quot;E190: Cannot open \&quot;%s\&quot; for writing&quot;), fname);</a>
<a name="ln8251">  }</a>
<a name="ln8252"> </a>
<a name="ln8253">  return fd;</a>
<a name="ln8254">}</a>
<a name="ln8255"> </a>
<a name="ln8256">/*</a>
<a name="ln8257"> * &quot;:mark&quot; and &quot;:k&quot;.</a>
<a name="ln8258"> */</a>
<a name="ln8259">static void ex_mark(exarg_T *eap)</a>
<a name="ln8260">{</a>
<a name="ln8261">  pos_T pos;</a>
<a name="ln8262"> </a>
<a name="ln8263">  if (*eap-&gt;arg == NUL)                 /* No argument? */</a>
<a name="ln8264">    EMSG(_(e_argreq));</a>
<a name="ln8265">  else if (eap-&gt;arg[1] != NUL)          /* more than one character? */</a>
<a name="ln8266">    EMSG(_(e_trailing));</a>
<a name="ln8267">  else {</a>
<a name="ln8268">    pos = curwin-&gt;w_cursor;             /* save curwin-&gt;w_cursor */</a>
<a name="ln8269">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln8270">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln8271">    if (setmark(*eap-&gt;arg) == FAIL)     /* set mark */</a>
<a name="ln8272">      EMSG(_(&quot;E191: Argument must be a letter or forward/backward quote&quot;));</a>
<a name="ln8273">    curwin-&gt;w_cursor = pos;             /* restore curwin-&gt;w_cursor */</a>
<a name="ln8274">  }</a>
<a name="ln8275">}</a>
<a name="ln8276"> </a>
<a name="ln8277">/*</a>
<a name="ln8278"> * Update w_topline, w_leftcol and the cursor position.</a>
<a name="ln8279"> */</a>
<a name="ln8280">void update_topline_cursor(void)</a>
<a name="ln8281">{</a>
<a name="ln8282">  check_cursor();               // put cursor on valid line</a>
<a name="ln8283">  update_topline(curwin);</a>
<a name="ln8284">  if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln8285">    validate_cursor();</a>
<a name="ln8286">  }</a>
<a name="ln8287">  update_curswant();</a>
<a name="ln8288">}</a>
<a name="ln8289"> </a>
<a name="ln8290">// Save the current State and go to Normal mode.</a>
<a name="ln8291">// Return true if the typeahead could be saved.</a>
<a name="ln8292">bool save_current_state(save_state_T *sst)</a>
<a name="ln8293">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8294">{</a>
<a name="ln8295">  sst-&gt;save_msg_scroll = msg_scroll;</a>
<a name="ln8296">  sst-&gt;save_restart_edit = restart_edit;</a>
<a name="ln8297">  sst-&gt;save_msg_didout = msg_didout;</a>
<a name="ln8298">  sst-&gt;save_State = State;</a>
<a name="ln8299">  sst-&gt;save_insertmode = p_im;</a>
<a name="ln8300">  sst-&gt;save_finish_op = finish_op;</a>
<a name="ln8301">  sst-&gt;save_opcount = opcount;</a>
<a name="ln8302">  sst-&gt;save_reg_executing = reg_executing;</a>
<a name="ln8303"> </a>
<a name="ln8304">  msg_scroll = false;   // no msg scrolling in Normal mode</a>
<a name="ln8305">  restart_edit = 0;     // don't go to Insert mode</a>
<a name="ln8306">  p_im = false;         // don't use 'insertmode</a>
<a name="ln8307"> </a>
<a name="ln8308">  // Save the current typeahead.  This is required to allow using &quot;:normal&quot;</a>
<a name="ln8309">  // from an event handler and makes sure we don't hang when the argument</a>
<a name="ln8310">  // ends with half a command.</a>
<a name="ln8311">  save_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln8312">  return sst-&gt;tabuf.typebuf_valid;</a>
<a name="ln8313">}</a>
<a name="ln8314"> </a>
<a name="ln8315">void restore_current_state(save_state_T *sst)</a>
<a name="ln8316">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8317">{</a>
<a name="ln8318">  // Restore the previous typeahead.</a>
<a name="ln8319">  restore_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln8320"> </a>
<a name="ln8321">  msg_scroll = sst-&gt;save_msg_scroll;</a>
<a name="ln8322">  if (force_restart_edit) {</a>
<a name="ln8323">    force_restart_edit = false;</a>
<a name="ln8324">  } else {</a>
<a name="ln8325">    // Some function (terminal_enter()) was aware of ex_normal and decided to</a>
<a name="ln8326">    // override the value of restart_edit anyway.</a>
<a name="ln8327">    restart_edit = sst-&gt;save_restart_edit;</a>
<a name="ln8328">  }</a>
<a name="ln8329">  p_im = sst-&gt;save_insertmode;</a>
<a name="ln8330">  finish_op = sst-&gt;save_finish_op;</a>
<a name="ln8331">  opcount = sst-&gt;save_opcount;</a>
<a name="ln8332">  reg_executing = sst-&gt;save_reg_executing;</a>
<a name="ln8333">  msg_didout |= sst-&gt;save_msg_didout;  // don't reset msg_didout now</a>
<a name="ln8334"> </a>
<a name="ln8335">  // Restore the state (needed when called from a function executed for</a>
<a name="ln8336">  // 'indentexpr'). Update the mouse and cursor, they may have changed.</a>
<a name="ln8337">  State = sst-&gt;save_State;</a>
<a name="ln8338">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln8339">}</a>
<a name="ln8340"> </a>
<a name="ln8341">/*</a>
<a name="ln8342"> * &quot;:normal[!] {commands}&quot;: Execute normal mode commands.</a>
<a name="ln8343"> */</a>
<a name="ln8344">static void ex_normal(exarg_T *eap)</a>
<a name="ln8345">{</a>
<a name="ln8346">  if (curbuf-&gt;terminal &amp;&amp; State &amp; TERM_FOCUS) {</a>
<a name="ln8347">    EMSG(&quot;Can't re-enter normal mode from terminal mode&quot;);</a>
<a name="ln8348">    return;</a>
<a name="ln8349">  }</a>
<a name="ln8350">  save_state_T save_state;</a>
<a name="ln8351">  char_u      *arg = NULL;</a>
<a name="ln8352">  int l;</a>
<a name="ln8353">  char_u      *p;</a>
<a name="ln8354"> </a>
<a name="ln8355">  if (ex_normal_lock &gt; 0) {</a>
<a name="ln8356">    EMSG(_(e_secure));</a>
<a name="ln8357">    return;</a>
<a name="ln8358">  }</a>
<a name="ln8359">  if (ex_normal_busy &gt;= p_mmd) {</a>
<a name="ln8360">    EMSG(_(&quot;E192: Recursive use of :normal too deep&quot;));</a>
<a name="ln8361">    return;</a>
<a name="ln8362">  }</a>
<a name="ln8363"> </a>
<a name="ln8364">  // vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do</a>
<a name="ln8365">  // this for the K_SPECIAL leading byte, otherwise special keys will not</a>
<a name="ln8366">  // work.</a>
<a name="ln8367">  {</a>
<a name="ln8368">    int len = 0;</a>
<a name="ln8369"> </a>
<a name="ln8370">    /* Count the number of characters to be escaped. */</a>
<a name="ln8371">    for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln8372">      for (l = (*mb_ptr2len)(p) - 1; l &gt; 0; --l)</a>
<a name="ln8373">        if (*++p == K_SPECIAL             /* trailbyte K_SPECIAL or CSI */</a>
<a name="ln8374">            )</a>
<a name="ln8375">          len += 2;</a>
<a name="ln8376">    }</a>
<a name="ln8377">    if (len &gt; 0) {</a>
<a name="ln8378">      arg = xmalloc(STRLEN(eap-&gt;arg) + len + 1);</a>
<a name="ln8379">      len = 0;</a>
<a name="ln8380">      for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln8381">        arg[len++] = *p;</a>
<a name="ln8382">        for (l = (*mb_ptr2len)(p) - 1; l &gt; 0; --l) {</a>
<a name="ln8383">          arg[len++] = *++p;</a>
<a name="ln8384">          if (*p == K_SPECIAL) {</a>
<a name="ln8385">            arg[len++] = KS_SPECIAL;</a>
<a name="ln8386">            arg[len++] = KE_FILLER;</a>
<a name="ln8387">          }</a>
<a name="ln8388">        }</a>
<a name="ln8389">        arg[len] = NUL;</a>
<a name="ln8390">      }</a>
<a name="ln8391">    }</a>
<a name="ln8392">  }</a>
<a name="ln8393"> </a>
<a name="ln8394">  ex_normal_busy++;</a>
<a name="ln8395">  if (save_current_state(&amp;save_state)) {</a>
<a name="ln8396">    // Repeat the :normal command for each line in the range.  When no</a>
<a name="ln8397">    // range given, execute it just once, without positioning the cursor</a>
<a name="ln8398">    // first.</a>
<a name="ln8399">    do {</a>
<a name="ln8400">      if (eap-&gt;addr_count != 0) {</a>
<a name="ln8401">        curwin-&gt;w_cursor.lnum = eap-&gt;line1++;</a>
<a name="ln8402">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln8403">        check_cursor_moved(curwin);</a>
<a name="ln8404">      }</a>
<a name="ln8405"> </a>
<a name="ln8406">      exec_normal_cmd(arg != NULL ? arg : eap-&gt;arg,</a>
<a name="ln8407">                      eap-&gt;forceit ? REMAP_NONE : REMAP_YES, false);</a>
<a name="ln8408">    } while (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line1 &lt;= eap-&gt;line2 &amp;&amp; !got_int);</a>
<a name="ln8409">  }</a>
<a name="ln8410"> </a>
<a name="ln8411">  /* Might not return to the main loop when in an event handler. */</a>
<a name="ln8412">  update_topline_cursor();</a>
<a name="ln8413"> </a>
<a name="ln8414">  restore_current_state(&amp;save_state);</a>
<a name="ln8415"> </a>
<a name="ln8416">  ex_normal_busy--;</a>
<a name="ln8417"> </a>
<a name="ln8418">  setmouse();</a>
<a name="ln8419">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln8420">  xfree(arg);</a>
<a name="ln8421">}</a>
<a name="ln8422"> </a>
<a name="ln8423">/*</a>
<a name="ln8424"> * &quot;:startinsert&quot;, &quot;:startreplace&quot; and &quot;:startgreplace&quot;</a>
<a name="ln8425"> */</a>
<a name="ln8426">static void ex_startinsert(exarg_T *eap)</a>
<a name="ln8427">{</a>
<a name="ln8428">  if (eap-&gt;forceit) {</a>
<a name="ln8429">    // cursor line can be zero on startup</a>
<a name="ln8430">    if (!curwin-&gt;w_cursor.lnum) {</a>
<a name="ln8431">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln8432">    }</a>
<a name="ln8433">    set_cursor_for_append_to_line();</a>
<a name="ln8434">  }</a>
<a name="ln8435"> </a>
<a name="ln8436">  // Ignore the command when already in Insert mode.  Inserting an</a>
<a name="ln8437">  // expression register that invokes a function can do this.</a>
<a name="ln8438">  if (State &amp; INSERT) {</a>
<a name="ln8439">    return;</a>
<a name="ln8440">  }</a>
<a name="ln8441"> </a>
<a name="ln8442">  if (eap-&gt;cmdidx == CMD_startinsert)</a>
<a name="ln8443">    restart_edit = 'a';</a>
<a name="ln8444">  else if (eap-&gt;cmdidx == CMD_startreplace)</a>
<a name="ln8445">    restart_edit = 'R';</a>
<a name="ln8446">  else</a>
<a name="ln8447">    restart_edit = 'V';</a>
<a name="ln8448"> </a>
<a name="ln8449">  if (!eap-&gt;forceit) {</a>
<a name="ln8450">    if (eap-&gt;cmdidx == CMD_startinsert)</a>
<a name="ln8451">      restart_edit = 'i';</a>
<a name="ln8452">    curwin-&gt;w_curswant = 0;  // avoid MAXCOL</a>
<a name="ln8453">  }</a>
<a name="ln8454"> </a>
<a name="ln8455">  if (VIsual_active) {</a>
<a name="ln8456">    showmode();</a>
<a name="ln8457">  }</a>
<a name="ln8458">}</a>
<a name="ln8459"> </a>
<a name="ln8460">/*</a>
<a name="ln8461"> * &quot;:stopinsert&quot;</a>
<a name="ln8462"> */</a>
<a name="ln8463">static void ex_stopinsert(exarg_T *eap)</a>
<a name="ln8464">{</a>
<a name="ln8465">  restart_edit = 0;</a>
<a name="ln8466">  stop_insert_mode = true;</a>
<a name="ln8467">  clearmode();</a>
<a name="ln8468">}</a>
<a name="ln8469"> </a>
<a name="ln8470">/*</a>
<a name="ln8471"> * Execute normal mode command &quot;cmd&quot;.</a>
<a name="ln8472"> * &quot;remap&quot; can be REMAP_NONE or REMAP_YES.</a>
<a name="ln8473"> */</a>
<a name="ln8474">void exec_normal_cmd(char_u *cmd, int remap, bool silent)</a>
<a name="ln8475">{</a>
<a name="ln8476">  // Stuff the argument into the typeahead buffer.</a>
<a name="ln8477">  ins_typebuf(cmd, remap, 0, true, silent);</a>
<a name="ln8478">  exec_normal(false);</a>
<a name="ln8479">}</a>
<a name="ln8480"> </a>
<a name="ln8481">/// Execute normal_cmd() until there is no typeahead left.</a>
<a name="ln8482">///</a>
<a name="ln8483">/// @param was_typed whether or not something was typed</a>
<a name="ln8484">void exec_normal(bool was_typed)</a>
<a name="ln8485">{</a>
<a name="ln8486">  oparg_T oa;</a>
<a name="ln8487"> </a>
<a name="ln8488">  clear_oparg(&amp;oa);</a>
<a name="ln8489">  finish_op = false;</a>
<a name="ln8490">  while ((!stuff_empty()</a>
<a name="ln8491">          || ((was_typed || !typebuf_typed())</a>
<a name="ln8492">              &amp;&amp; typebuf.tb_len &gt; 0))</a>
<a name="ln8493">         &amp;&amp; !got_int) {</a>
<a name="ln8494">    update_topline_cursor();</a>
<a name="ln8495">    normal_cmd(&amp;oa, true);      // execute a Normal mode cmd</a>
<a name="ln8496">  }</a>
<a name="ln8497">}</a>
<a name="ln8498"> </a>
<a name="ln8499">static void ex_checkpath(exarg_T *eap)</a>
<a name="ln8500">{</a>
<a name="ln8501">  find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,</a>
<a name="ln8502">                       eap-&gt;forceit ? ACTION_SHOW_ALL : ACTION_SHOW,</a>
<a name="ln8503">                       (linenr_T)1, (linenr_T)MAXLNUM);</a>
<a name="ln8504">}</a>
<a name="ln8505"> </a>
<a name="ln8506">/*</a>
<a name="ln8507"> * &quot;:psearch&quot;</a>
<a name="ln8508"> */</a>
<a name="ln8509">static void ex_psearch(exarg_T *eap)</a>
<a name="ln8510">{</a>
<a name="ln8511">  g_do_tagpreview = p_pvh;</a>
<a name="ln8512">  ex_findpat(eap);</a>
<a name="ln8513">  g_do_tagpreview = 0;</a>
<a name="ln8514">}</a>
<a name="ln8515"> </a>
<a name="ln8516">static void ex_findpat(exarg_T *eap)</a>
<a name="ln8517">{</a>
<a name="ln8518">  int whole = TRUE;</a>
<a name="ln8519">  long n;</a>
<a name="ln8520">  char_u      *p;</a>
<a name="ln8521">  int action;</a>
<a name="ln8522"> </a>
<a name="ln8523">  switch (cmdnames[eap-&gt;cmdidx].cmd_name[2]) {</a>
<a name="ln8524">  case 'e':             /* &quot;:psearch&quot;, &quot;:isearch&quot; and &quot;:dsearch&quot; */</a>
<a name="ln8525">    if (cmdnames[eap-&gt;cmdidx].cmd_name[0] == 'p')</a>
<a name="ln8526">      action = ACTION_GOTO;</a>
<a name="ln8527">    else</a>
<a name="ln8528">      action = ACTION_SHOW;</a>
<a name="ln8529">    break;</a>
<a name="ln8530">  case 'i':             /* &quot;:ilist&quot; and &quot;:dlist&quot; */</a>
<a name="ln8531">    action = ACTION_SHOW_ALL;</a>
<a name="ln8532">    break;</a>
<a name="ln8533">  case 'u':             /* &quot;:ijump&quot; and &quot;:djump&quot; */</a>
<a name="ln8534">    action = ACTION_GOTO;</a>
<a name="ln8535">    break;</a>
<a name="ln8536">  default:              /* &quot;:isplit&quot; and &quot;:dsplit&quot; */</a>
<a name="ln8537">    action = ACTION_SPLIT;</a>
<a name="ln8538">    break;</a>
<a name="ln8539">  }</a>
<a name="ln8540"> </a>
<a name="ln8541">  n = 1;</a>
<a name="ln8542">  if (ascii_isdigit(*eap-&gt;arg)) {  // get count</a>
<a name="ln8543">    n = getdigits_long(&amp;eap-&gt;arg, false, 0);</a>
<a name="ln8544">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln8545">  }</a>
<a name="ln8546">  if (*eap-&gt;arg == '/') {   // Match regexp, not just whole words</a>
<a name="ln8547">    whole = false;</a>
<a name="ln8548">    eap-&gt;arg++;</a>
<a name="ln8549">    p = skip_regexp(eap-&gt;arg, '/', p_magic, NULL);</a>
<a name="ln8550">    if (*p) {</a>
<a name="ln8551">      *p++ = NUL;</a>
<a name="ln8552">      p = skipwhite(p);</a>
<a name="ln8553"> </a>
<a name="ln8554">      // Check for trailing illegal characters.</a>
<a name="ln8555">      if (!ends_excmd(*p)) {</a>
<a name="ln8556">        eap-&gt;errmsg = e_trailing;</a>
<a name="ln8557">      } else {</a>
<a name="ln8558">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln8559">      }</a>
<a name="ln8560">    }</a>
<a name="ln8561">  }</a>
<a name="ln8562">  if (!eap-&gt;skip)</a>
<a name="ln8563">    find_pattern_in_path(eap-&gt;arg, 0, STRLEN(eap-&gt;arg), whole, !eap-&gt;forceit,</a>
<a name="ln8564">                         *eap-&gt;cmd == 'd' ?  FIND_DEFINE : FIND_ANY,</a>
<a name="ln8565">                         n, action, eap-&gt;line1, eap-&gt;line2);</a>
<a name="ln8566">}</a>
<a name="ln8567"> </a>
<a name="ln8568"> </a>
<a name="ln8569">/*</a>
<a name="ln8570"> * &quot;:ptag&quot;, &quot;:ptselect&quot;, &quot;:ptjump&quot;, &quot;:ptnext&quot;, etc.</a>
<a name="ln8571"> */</a>
<a name="ln8572">static void ex_ptag(exarg_T *eap)</a>
<a name="ln8573">{</a>
<a name="ln8574">  g_do_tagpreview = p_pvh;    /* will be reset to 0 in ex_tag_cmd() */</a>
<a name="ln8575">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln8576">}</a>
<a name="ln8577"> </a>
<a name="ln8578">/*</a>
<a name="ln8579"> * &quot;:pedit&quot;</a>
<a name="ln8580"> */</a>
<a name="ln8581">static void ex_pedit(exarg_T *eap)</a>
<a name="ln8582">{</a>
<a name="ln8583">  win_T       *curwin_save = curwin;</a>
<a name="ln8584"> </a>
<a name="ln8585">  // Open the preview window or popup and make it the current window.</a>
<a name="ln8586">  g_do_tagpreview = p_pvh;</a>
<a name="ln8587">  prepare_tagpreview(true);</a>
<a name="ln8588"> </a>
<a name="ln8589">  // Edit the file.</a>
<a name="ln8590">  do_exedit(eap, NULL);</a>
<a name="ln8591"> </a>
<a name="ln8592">  if (curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln8593">    // Return cursor to where we were</a>
<a name="ln8594">    validate_cursor();</a>
<a name="ln8595">    redraw_later(curwin, VALID);</a>
<a name="ln8596">    win_enter(curwin_save, true);</a>
<a name="ln8597">  }</a>
<a name="ln8598">  g_do_tagpreview = 0;</a>
<a name="ln8599">}</a>
<a name="ln8600"> </a>
<a name="ln8601">/*</a>
<a name="ln8602"> * &quot;:stag&quot;, &quot;:stselect&quot; and &quot;:stjump&quot;.</a>
<a name="ln8603"> */</a>
<a name="ln8604">static void ex_stag(exarg_T *eap)</a>
<a name="ln8605">{</a>
<a name="ln8606">  postponed_split = -1;</a>
<a name="ln8607">  postponed_split_flags = cmdmod.split;</a>
<a name="ln8608">  postponed_split_tab = cmdmod.tab;</a>
<a name="ln8609">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln8610">  postponed_split_flags = 0;</a>
<a name="ln8611">  postponed_split_tab = 0;</a>
<a name="ln8612">}</a>
<a name="ln8613"> </a>
<a name="ln8614">/*</a>
<a name="ln8615"> * &quot;:tag&quot;, &quot;:tselect&quot;, &quot;:tjump&quot;, &quot;:tnext&quot;, etc.</a>
<a name="ln8616"> */</a>
<a name="ln8617">static void ex_tag(exarg_T *eap)</a>
<a name="ln8618">{</a>
<a name="ln8619">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name);</a>
<a name="ln8620">}</a>
<a name="ln8621"> </a>
<a name="ln8622">static void ex_tag_cmd(exarg_T *eap, char_u *name)</a>
<a name="ln8623">{</a>
<a name="ln8624">  int cmd;</a>
<a name="ln8625"> </a>
<a name="ln8626">  switch (name[1]) {</a>
<a name="ln8627">  case 'j': cmd = DT_JUMP;              // &quot;:tjump&quot;</a>
<a name="ln8628">    break;</a>
<a name="ln8629">  case 's': cmd = DT_SELECT;            // &quot;:tselect&quot;</a>
<a name="ln8630">    break;</a>
<a name="ln8631">  case 'p':                             // &quot;:tprevious&quot;</a>
<a name="ln8632">  case 'N': cmd = DT_PREV;              // &quot;:tNext&quot;</a>
<a name="ln8633">    break;</a>
<a name="ln8634">  case 'n': cmd = DT_NEXT;              // &quot;:tnext&quot;</a>
<a name="ln8635">    break;</a>
<a name="ln8636">  case 'o': cmd = DT_POP;               // &quot;:pop&quot;</a>
<a name="ln8637">    break;</a>
<a name="ln8638">  case 'f':                             // &quot;:tfirst&quot;</a>
<a name="ln8639">  case 'r': cmd = DT_FIRST;             // &quot;:trewind&quot;</a>
<a name="ln8640">    break;</a>
<a name="ln8641">  case 'l': cmd = DT_LAST;              // &quot;:tlast&quot;</a>
<a name="ln8642">    break;</a>
<a name="ln8643">  default:                              // &quot;:tag&quot;</a>
<a name="ln8644">    if (p_cst &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln8645">      ex_cstag(eap);</a>
<a name="ln8646">      return;</a>
<a name="ln8647">    }</a>
<a name="ln8648">    cmd = DT_TAG;</a>
<a name="ln8649">    break;</a>
<a name="ln8650">  }</a>
<a name="ln8651"> </a>
<a name="ln8652">  if (name[0] == 'l') {</a>
<a name="ln8653">    cmd = DT_LTAG;</a>
<a name="ln8654">  }</a>
<a name="ln8655"> </a>
<a name="ln8656">  do_tag(eap-&gt;arg, cmd, eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 1,</a>
<a name="ln8657">      eap-&gt;forceit, TRUE);</a>
<a name="ln8658">}</a>
<a name="ln8659"> </a>
<a name="ln8660">enum {</a>
<a name="ln8661">  SPEC_PERC = 0,</a>
<a name="ln8662">  SPEC_HASH,</a>
<a name="ln8663">  SPEC_CWORD,</a>
<a name="ln8664">  SPEC_CCWORD,</a>
<a name="ln8665">  SPEC_CEXPR,</a>
<a name="ln8666">  SPEC_CFILE,</a>
<a name="ln8667">  SPEC_SFILE,</a>
<a name="ln8668">  SPEC_SLNUM,</a>
<a name="ln8669">  SPEC_STACK,</a>
<a name="ln8670">  SPEC_AFILE,</a>
<a name="ln8671">  SPEC_ABUF,</a>
<a name="ln8672">  SPEC_AMATCH,</a>
<a name="ln8673">  SPEC_SFLNUM,</a>
<a name="ln8674">  SPEC_SID,</a>
<a name="ln8675">  // SPEC_CLIENT,</a>
<a name="ln8676">};</a>
<a name="ln8677"> </a>
<a name="ln8678">/*</a>
<a name="ln8679"> * Check &quot;str&quot; for starting with a special cmdline variable.</a>
<a name="ln8680"> * If found return one of the SPEC_ values and set &quot;*usedlen&quot; to the length of</a>
<a name="ln8681"> * the variable.  Otherwise return -1 and &quot;*usedlen&quot; is unchanged.</a>
<a name="ln8682"> */</a>
<a name="ln8683">ssize_t find_cmdline_var(const char_u *src, size_t *usedlen)</a>
<a name="ln8684">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8685">{</a>
<a name="ln8686">  size_t len;</a>
<a name="ln8687">  static char *(spec_str[]) = {</a>
<a name="ln8688">    [SPEC_PERC] = &quot;%&quot;,</a>
<a name="ln8689">    [SPEC_HASH] = &quot;#&quot;,</a>
<a name="ln8690">    [SPEC_CWORD] = &quot;&lt;cword&gt;&quot;,           // cursor word</a>
<a name="ln8691">    [SPEC_CCWORD] = &quot;&lt;cWORD&gt;&quot;,          // cursor WORD</a>
<a name="ln8692">    [SPEC_CEXPR] = &quot;&lt;cexpr&gt;&quot;,           // expr under cursor</a>
<a name="ln8693">    [SPEC_CFILE] = &quot;&lt;cfile&gt;&quot;,           // cursor path name</a>
<a name="ln8694">    [SPEC_SFILE] = &quot;&lt;sfile&gt;&quot;,           // &quot;:so&quot; file name</a>
<a name="ln8695">    [SPEC_SLNUM] = &quot;&lt;slnum&gt;&quot;,           // &quot;:so&quot; file line number</a>
<a name="ln8696">    [SPEC_STACK] = &quot;&lt;stack&gt;&quot;,           // call stack</a>
<a name="ln8697">    [SPEC_AFILE] = &quot;&lt;afile&gt;&quot;,           // autocommand file name</a>
<a name="ln8698">    [SPEC_ABUF] = &quot;&lt;abuf&gt;&quot;,             // autocommand buffer number</a>
<a name="ln8699">    [SPEC_AMATCH] = &quot;&lt;amatch&gt;&quot;,         // autocommand match name</a>
<a name="ln8700">    [SPEC_SFLNUM] = &quot;&lt;sflnum&gt;&quot;,         // script file line number</a>
<a name="ln8701">    [SPEC_SID] = &quot;&lt;SID&gt;&quot;,               // script ID: &lt;SNR&gt;123_</a>
<a name="ln8702">    // [SPEC_CLIENT] = &quot;&lt;client&gt;&quot;,</a>
<a name="ln8703">  };</a>
<a name="ln8704"> </a>
<a name="ln8705">  for (size_t i = 0; i &lt; ARRAY_SIZE(spec_str); ++i) {</a>
<a name="ln8706">    len = STRLEN(spec_str[i]);</a>
<a name="ln8707">    if (STRNCMP(src, spec_str[i], len) == 0) {</a>
<a name="ln8708">      *usedlen = len;</a>
<a name="ln8709">      assert(i &lt;= SSIZE_MAX);</a>
<a name="ln8710">      return (ssize_t)i;</a>
<a name="ln8711">    }</a>
<a name="ln8712">  }</a>
<a name="ln8713">  return -1;</a>
<a name="ln8714">}</a>
<a name="ln8715"> </a>
<a name="ln8716">/*</a>
<a name="ln8717"> * Evaluate cmdline variables.</a>
<a name="ln8718"> *</a>
<a name="ln8719"> * change '%'	    to curbuf-&gt;b_ffname</a>
<a name="ln8720"> *	  '#'	    to curwin-&gt;w_altfile</a>
<a name="ln8721"> *	  '&lt;cword&gt;' to word under the cursor</a>
<a name="ln8722"> *	  '&lt;cWORD&gt;' to WORD under the cursor</a>
<a name="ln8723"> *	  '&lt;cexpr&gt;' to C-expression under the cursor</a>
<a name="ln8724"> *	  '&lt;cfile&gt;' to path name under the cursor</a>
<a name="ln8725"> *	  '&lt;sfile&gt;' to sourced file name</a>
<a name="ln8726"> *	  '&lt;slnum&gt;' to sourced file line number</a>
<a name="ln8727"> *	  '&lt;afile&gt;' to file name for autocommand</a>
<a name="ln8728"> *	  '&lt;abuf&gt;'  to buffer number for autocommand</a>
<a name="ln8729"> *	  '&lt;amatch&gt;' to matching name for autocommand</a>
<a name="ln8730"> *</a>
<a name="ln8731"> * When an error is detected, &quot;errormsg&quot; is set to a non-NULL pointer (may be</a>
<a name="ln8732"> * &quot;&quot; for error without a message) and NULL is returned.</a>
<a name="ln8733"> * Returns an allocated string if a valid match was found.</a>
<a name="ln8734"> * Returns NULL if no match was found.	&quot;usedlen&quot; then still contains the</a>
<a name="ln8735"> * number of characters to skip.</a>
<a name="ln8736"> */</a>
<a name="ln8737">char_u *</a>
<a name="ln8738">eval_vars (</a>
<a name="ln8739">    char_u *src,               /* pointer into commandline */</a>
<a name="ln8740">    char_u *srcstart,          /* beginning of valid memory for src */</a>
<a name="ln8741">    size_t *usedlen,           /* characters after src that are used */</a>
<a name="ln8742">    linenr_T *lnump,             /* line number for :e command, or NULL */</a>
<a name="ln8743">    char_u **errormsg,         /* pointer to error message */</a>
<a name="ln8744">    int *escaped           /* return value has escaped white space (can</a>
<a name="ln8745">                                 * be NULL) */</a>
<a name="ln8746">)</a>
<a name="ln8747">{</a>
<a name="ln8748">  int i;</a>
<a name="ln8749">  char_u      *s;</a>
<a name="ln8750">  char_u      *result;</a>
<a name="ln8751">  char_u      *resultbuf = NULL;</a>
<a name="ln8752">  size_t resultlen;</a>
<a name="ln8753">  buf_T       *buf;</a>
<a name="ln8754">  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.</a>
<a name="ln8755">  bool tilde_file = false;</a>
<a name="ln8756">  int skip_mod = false;</a>
<a name="ln8757">  char strbuf[30];</a>
<a name="ln8758"> </a>
<a name="ln8759">  *errormsg = NULL;</a>
<a name="ln8760">  if (escaped != NULL)</a>
<a name="ln8761">    *escaped = FALSE;</a>
<a name="ln8762"> </a>
<a name="ln8763">  /*</a>
<a name="ln8764">   * Check if there is something to do.</a>
<a name="ln8765">   */</a>
<a name="ln8766">  ssize_t spec_idx = find_cmdline_var(src, usedlen);</a>
<a name="ln8767">  if (spec_idx &lt; 0) {   /* no match */</a>
<a name="ln8768">    *usedlen = 1;</a>
<a name="ln8769">    return NULL;</a>
<a name="ln8770">  }</a>
<a name="ln8771"> </a>
<a name="ln8772">  /*</a>
<a name="ln8773">   * Skip when preceded with a backslash &quot;\%&quot; and &quot;\#&quot;.</a>
<a name="ln8774">   * Note: In &quot;\\%&quot; the % is also not recognized!</a>
<a name="ln8775">   */</a>
<a name="ln8776">  if (src &gt; srcstart &amp;&amp; src[-1] == '\\') {</a>
<a name="ln8777">    *usedlen = 0;</a>
<a name="ln8778">    STRMOVE(src - 1, src);      /* remove backslash */</a>
<a name="ln8779">    return NULL;</a>
<a name="ln8780">  }</a>
<a name="ln8781"> </a>
<a name="ln8782">  /*</a>
<a name="ln8783">   * word or WORD under cursor</a>
<a name="ln8784">   */</a>
<a name="ln8785">  if (spec_idx == SPEC_CWORD</a>
<a name="ln8786">      || spec_idx == SPEC_CCWORD</a>
<a name="ln8787">      || spec_idx == SPEC_CEXPR) {</a>
<a name="ln8788">    resultlen = find_ident_under_cursor(</a>
<a name="ln8789">        &amp;result,</a>
<a name="ln8790">        spec_idx == SPEC_CWORD</a>
<a name="ln8791">        ? (FIND_IDENT | FIND_STRING)</a>
<a name="ln8792">        : (spec_idx == SPEC_CEXPR</a>
<a name="ln8793">           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)</a>
<a name="ln8794">           : FIND_STRING));</a>
<a name="ln8795">    if (resultlen == 0) {</a>
<a name="ln8796">      *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8797">      return NULL;</a>
<a name="ln8798">    }</a>
<a name="ln8799">  //</a>
<a name="ln8800">  // '#': Alternate file name</a>
<a name="ln8801">  // '%': Current file name</a>
<a name="ln8802">  //        File name under the cursor</a>
<a name="ln8803">  //        File name for autocommand</a>
<a name="ln8804">  //    and following modifiers</a>
<a name="ln8805">  //</a>
<a name="ln8806">  } else {</a>
<a name="ln8807">    switch (spec_idx) {</a>
<a name="ln8808">    case SPEC_PERC:             // '%': current file</a>
<a name="ln8809">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln8810">        result = (char_u *)&quot;&quot;;</a>
<a name="ln8811">        valid = 0;                  // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln8812">      } else {</a>
<a name="ln8813">        result = curbuf-&gt;b_fname;</a>
<a name="ln8814">        tilde_file = STRCMP(result, &quot;~&quot;) == 0;</a>
<a name="ln8815">      }</a>
<a name="ln8816">      break;</a>
<a name="ln8817"> </a>
<a name="ln8818">    case SPEC_HASH:             /* '#' or &quot;#99&quot;: alternate file */</a>
<a name="ln8819">      if (src[1] == '#') {          /* &quot;##&quot;: the argument list */</a>
<a name="ln8820">        result = arg_all();</a>
<a name="ln8821">        resultbuf = result;</a>
<a name="ln8822">        *usedlen = 2;</a>
<a name="ln8823">        if (escaped != NULL)</a>
<a name="ln8824">          *escaped = TRUE;</a>
<a name="ln8825">        skip_mod = TRUE;</a>
<a name="ln8826">        break;</a>
<a name="ln8827">      }</a>
<a name="ln8828">      s = src + 1;</a>
<a name="ln8829">      if (*s == '&lt;') {                  // &quot;#&lt;99&quot; uses v:oldfiles.</a>
<a name="ln8830">        s++;</a>
<a name="ln8831">      }</a>
<a name="ln8832">      i = getdigits_int(&amp;s, false, 0);</a>
<a name="ln8833">      if (s == src + 2 &amp;&amp; src[1] == '-') {</a>
<a name="ln8834">        // just a minus sign, don't skip over it</a>
<a name="ln8835">        s--;</a>
<a name="ln8836">      }</a>
<a name="ln8837">      *usedlen = (size_t)(s - src);           // length of what we expand</a>
<a name="ln8838"> </a>
<a name="ln8839">      if (src[1] == '&lt;' &amp;&amp; i != 0) {</a>
<a name="ln8840">        if (*usedlen &lt; 2) {</a>
<a name="ln8841">          /* Should we give an error message for #&lt;text? */</a>
<a name="ln8842">          *usedlen = 1;</a>
<a name="ln8843">          return NULL;</a>
<a name="ln8844">        }</a>
<a name="ln8845">        result = (char_u *)tv_list_find_str(get_vim_var_list(VV_OLDFILES),</a>
<a name="ln8846">                                            i - 1);</a>
<a name="ln8847">        if (result == NULL) {</a>
<a name="ln8848">          *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8849">          return NULL;</a>
<a name="ln8850">        }</a>
<a name="ln8851">      } else {</a>
<a name="ln8852">        if (i == 0 &amp;&amp; src[1] == '&lt;' &amp;&amp; *usedlen &gt; 1) {</a>
<a name="ln8853">          *usedlen = 1;</a>
<a name="ln8854">        }</a>
<a name="ln8855">        buf = buflist_findnr(i);</a>
<a name="ln8856">        if (buf == NULL) {</a>
<a name="ln8857">          *errormsg = (char_u *)_(</a>
<a name="ln8858">              &quot;E194: No alternate file name to substitute for '#'&quot;);</a>
<a name="ln8859">          return NULL;</a>
<a name="ln8860">        }</a>
<a name="ln8861">        if (lnump != NULL)</a>
<a name="ln8862">          *lnump = ECMD_LAST;</a>
<a name="ln8863">        if (buf-&gt;b_fname == NULL) {</a>
<a name="ln8864">          result = (char_u *)&quot;&quot;;</a>
<a name="ln8865">          valid = 0;                        // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln8866">        } else {</a>
<a name="ln8867">          result = buf-&gt;b_fname;</a>
<a name="ln8868">          tilde_file = STRCMP(result, &quot;~&quot;) == 0;</a>
<a name="ln8869">        }</a>
<a name="ln8870">      }</a>
<a name="ln8871">      break;</a>
<a name="ln8872"> </a>
<a name="ln8873">    case SPEC_CFILE:            /* file name under cursor */</a>
<a name="ln8874">      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);</a>
<a name="ln8875">      if (result == NULL) {</a>
<a name="ln8876">        *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8877">        return NULL;</a>
<a name="ln8878">      }</a>
<a name="ln8879">      resultbuf = result;                   /* remember allocated string */</a>
<a name="ln8880">      break;</a>
<a name="ln8881"> </a>
<a name="ln8882">    case SPEC_AFILE:  // file name for autocommand</a>
<a name="ln8883">      if (autocmd_fname != NULL</a>
<a name="ln8884">          &amp;&amp; !path_is_absolute(autocmd_fname)</a>
<a name="ln8885">          // For CmdlineEnter and related events, &lt;afile&gt; is not a path! #9348</a>
<a name="ln8886">          &amp;&amp; !strequal(&quot;/&quot;, (char *)autocmd_fname)) {</a>
<a name="ln8887">        // Still need to turn the fname into a full path.  It was</a>
<a name="ln8888">        // postponed to avoid a delay when &lt;afile&gt; is not used.</a>
<a name="ln8889">        result = (char_u *)FullName_save((char *)autocmd_fname, false);</a>
<a name="ln8890">        // Copy into `autocmd_fname`, don't reassign it. #8165</a>
<a name="ln8891">        xstrlcpy((char *)autocmd_fname, (char *)result, MAXPATHL);</a>
<a name="ln8892">        xfree(result);</a>
<a name="ln8893">      }</a>
<a name="ln8894">      result = autocmd_fname;</a>
<a name="ln8895">      if (result == NULL) {</a>
<a name="ln8896">        *errormsg = (char_u *)_(</a>
<a name="ln8897">            &quot;E495: no autocommand file name to substitute for \&quot;&lt;afile&gt;\&quot;&quot;);</a>
<a name="ln8898">        return NULL;</a>
<a name="ln8899">      }</a>
<a name="ln8900">      result = path_try_shorten_fname(result);</a>
<a name="ln8901">      break;</a>
<a name="ln8902"> </a>
<a name="ln8903">    case SPEC_ABUF:             /* buffer number for autocommand */</a>
<a name="ln8904">      if (autocmd_bufnr &lt;= 0) {</a>
<a name="ln8905">        *errormsg = (char_u *)_(</a>
<a name="ln8906">            &quot;E496: no autocommand buffer number to substitute for \&quot;&lt;abuf&gt;\&quot;&quot;);</a>
<a name="ln8907">        return NULL;</a>
<a name="ln8908">      }</a>
<a name="ln8909">      snprintf(strbuf, sizeof(strbuf), &quot;%d&quot;, autocmd_bufnr);</a>
<a name="ln8910">      result = (char_u *)strbuf;</a>
<a name="ln8911">      break;</a>
<a name="ln8912"> </a>
<a name="ln8913">    case SPEC_AMATCH:           /* match name for autocommand */</a>
<a name="ln8914">      result = autocmd_match;</a>
<a name="ln8915">      if (result == NULL) {</a>
<a name="ln8916">        *errormsg = (char_u *)_(</a>
<a name="ln8917">            &quot;E497: no autocommand match name to substitute for \&quot;&lt;amatch&gt;\&quot;&quot;);</a>
<a name="ln8918">        return NULL;</a>
<a name="ln8919">      }</a>
<a name="ln8920">      break;</a>
<a name="ln8921"> </a>
<a name="ln8922">    case SPEC_SFILE:            /* file name for &quot;:so&quot; command */</a>
<a name="ln8923">      result = sourcing_name;</a>
<a name="ln8924">      if (result == NULL) {</a>
<a name="ln8925">        *errormsg = (char_u *)_(</a>
<a name="ln8926">            &quot;E498: no :source file name to substitute for \&quot;&lt;sfile&gt;\&quot;&quot;);</a>
<a name="ln8927">        return NULL;</a>
<a name="ln8928">      }</a>
<a name="ln8929">      break;</a>
<a name="ln8930"> </a>
<a name="ln8931">    case SPEC_SLNUM:            // line in file for &quot;:so&quot; command</a>
<a name="ln8932">      if (sourcing_name == NULL || sourcing_lnum == 0) {</a>
<a name="ln8933">        *errormsg = (char_u *)_(&quot;E842: no line number to use for \&quot;&lt;slnum&gt;\&quot;&quot;);</a>
<a name="ln8934">        return NULL;</a>
<a name="ln8935">      }</a>
<a name="ln8936">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR, sourcing_lnum);</a>
<a name="ln8937">      result = (char_u *)strbuf;</a>
<a name="ln8938">      break;</a>
<a name="ln8939"> </a>
<a name="ln8940">    case SPEC_SFLNUM:  // line in script file</a>
<a name="ln8941">      if (current_sctx.sc_lnum + sourcing_lnum == 0) {</a>
<a name="ln8942">        *errormsg = (char_u *)_(&quot;E961: no line number to use for \&quot;&lt;sflnum&gt;\&quot;&quot;);</a>
<a name="ln8943">        return NULL;</a>
<a name="ln8944">      }</a>
<a name="ln8945">      snprintf((char *)strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR,</a>
<a name="ln8946">               current_sctx.sc_lnum + sourcing_lnum);</a>
<a name="ln8947">      result = (char_u *)strbuf;</a>
<a name="ln8948">      break;</a>
<a name="ln8949"> </a>
<a name="ln8950">    case SPEC_SID:</a>
<a name="ln8951">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln8952">        *errormsg = (char_u *)_(e_usingsid);</a>
<a name="ln8953">        return NULL;</a>
<a name="ln8954">      }</a>
<a name="ln8955">      snprintf(strbuf, sizeof(strbuf), &quot;&lt;SNR&gt;%&quot; PRIdSCID &quot;_&quot;,</a>
<a name="ln8956">               current_sctx.sc_sid);</a>
<a name="ln8957">      result = (char_u *)strbuf;</a>
<a name="ln8958">      break;</a>
<a name="ln8959"> </a>
<a name="ln8960">    default:</a>
<a name="ln8961">      // should not happen</a>
<a name="ln8962">      *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8963">      result = (char_u *)&quot;&quot;;    // avoid gcc warning</a>
<a name="ln8964">      break;</a>
<a name="ln8965">    }</a>
<a name="ln8966"> </a>
<a name="ln8967">    // Length of new string.</a>
<a name="ln8968">    resultlen = STRLEN(result);</a>
<a name="ln8969">    // Remove the file name extension.</a>
<a name="ln8970">    if (src[*usedlen] == '&lt;') {</a>
<a name="ln8971">      (*usedlen)++;</a>
<a name="ln8972">      if ((s = STRRCHR(result, '.')) != NULL &amp;&amp; s &gt;= path_tail(result)) {</a>
<a name="ln8973">        resultlen = (size_t)(s - result);</a>
<a name="ln8974">      }</a>
<a name="ln8975">    } else if (!skip_mod) {</a>
<a name="ln8976">      valid |= modify_fname(src, tilde_file, usedlen, &amp;result,</a>
<a name="ln8977">                            &amp;resultbuf, &amp;resultlen);</a>
<a name="ln8978">      if (result == NULL) {</a>
<a name="ln8979">        *errormsg = (char_u *)&quot;&quot;;</a>
<a name="ln8980">        return NULL;</a>
<a name="ln8981">      }</a>
<a name="ln8982">    }</a>
<a name="ln8983">  }</a>
<a name="ln8984"> </a>
<a name="ln8985">  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln8986">    if (valid != VALID_HEAD + VALID_PATH)</a>
<a name="ln8987">      /* xgettext:no-c-format */</a>
<a name="ln8988">      *errormsg = (char_u *)_(</a>
<a name="ln8989">          &quot;E499: Empty file name for '%' or '#', only works with \&quot;:p:h\&quot;&quot;);</a>
<a name="ln8990">    else</a>
<a name="ln8991">      *errormsg = (char_u *)_(&quot;E500: Evaluates to an empty string&quot;);</a>
<a name="ln8992">    result = NULL;</a>
<a name="ln8993">  } else</a>
<a name="ln8994">    result = vim_strnsave(result, resultlen);</a>
<a name="ln8995">  xfree(resultbuf);</a>
<a name="ln8996">  return result;</a>
<a name="ln8997">}</a>
<a name="ln8998"> </a>
<a name="ln8999">/*</a>
<a name="ln9000"> * Concatenate all files in the argument list, separated by spaces, and return</a>
<a name="ln9001"> * it in one allocated string.</a>
<a name="ln9002"> * Spaces and backslashes in the file names are escaped with a backslash.</a>
<a name="ln9003"> */</a>
<a name="ln9004">static char_u *arg_all(void)</a>
<a name="ln9005">{</a>
<a name="ln9006">  int len;</a>
<a name="ln9007">  int idx;</a>
<a name="ln9008">  char_u      *retval = NULL;</a>
<a name="ln9009">  char_u      *p;</a>
<a name="ln9010"> </a>
<a name="ln9011">  /*</a>
<a name="ln9012">   * Do this loop two times:</a>
<a name="ln9013">   * first time: compute the total length</a>
<a name="ln9014">   * second time: concatenate the names</a>
<a name="ln9015">   */</a>
<a name="ln9016">  for (;; ) {</a>
<a name="ln9017">    len = 0;</a>
<a name="ln9018">    for (idx = 0; idx &lt; ARGCOUNT; ++idx) {</a>
<a name="ln9019">      p = alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln9020">      if (p == NULL) {</a>
<a name="ln9021">        continue;</a>
<a name="ln9022">      }</a>
<a name="ln9023">      if (len &gt; 0) {</a>
<a name="ln9024">        /* insert a space in between names */</a>
<a name="ln9025">        if (retval != NULL)</a>
<a name="ln9026">          retval[len] = ' ';</a>
<a name="ln9027">        ++len;</a>
<a name="ln9028">      }</a>
<a name="ln9029">      for (; *p != NUL; p++) {</a>
<a name="ln9030">        if (*p == ' '</a>
<a name="ln9031">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln9032">            || *p == '\\'</a>
<a name="ln9033">#endif</a>
<a name="ln9034">            || *p == '`') {</a>
<a name="ln9035">          // insert a backslash</a>
<a name="ln9036">          if (retval != NULL) {</a>
<a name="ln9037">            retval[len] = '\\';</a>
<a name="ln9038">          }</a>
<a name="ln9039">          len++;</a>
<a name="ln9040">        }</a>
<a name="ln9041">        if (retval != NULL) {</a>
<a name="ln9042">          retval[len] = *p;</a>
<a name="ln9043">        }</a>
<a name="ln9044">        len++;</a>
<a name="ln9045">      }</a>
<a name="ln9046">    }</a>
<a name="ln9047"> </a>
<a name="ln9048">    /* second time: break here */</a>
<a name="ln9049">    if (retval != NULL) {</a>
<a name="ln9050">      retval[len] = NUL;</a>
<a name="ln9051">      break;</a>
<a name="ln9052">    }</a>
<a name="ln9053"> </a>
<a name="ln9054">    /* allocate memory */</a>
<a name="ln9055">    retval = xmalloc(len + 1);</a>
<a name="ln9056">  }</a>
<a name="ln9057"> </a>
<a name="ln9058">  return retval;</a>
<a name="ln9059">}</a>
<a name="ln9060"> </a>
<a name="ln9061">/*</a>
<a name="ln9062"> * Expand the &lt;sfile&gt; string in &quot;arg&quot;.</a>
<a name="ln9063"> *</a>
<a name="ln9064"> * Returns an allocated string, or NULL for any error.</a>
<a name="ln9065"> */</a>
<a name="ln9066">char_u *expand_sfile(char_u *arg)</a>
<a name="ln9067">{</a>
<a name="ln9068">  char_u      *errormsg;</a>
<a name="ln9069">  size_t len;</a>
<a name="ln9070">  char_u      *result;</a>
<a name="ln9071">  char_u      *newres;</a>
<a name="ln9072">  char_u      *repl;</a>
<a name="ln9073">  size_t srclen;</a>
<a name="ln9074">  char_u      *p;</a>
<a name="ln9075"> </a>
<a name="ln9076">  result = vim_strsave(arg);</a>
<a name="ln9077"> </a>
<a name="ln9078">  for (p = result; *p; ) {</a>
<a name="ln9079">    if (STRNCMP(p, &quot;&lt;sfile&gt;&quot;, 7) != 0)</a>
<a name="ln9080">      ++p;</a>
<a name="ln9081">    else {</a>
<a name="ln9082">      /* replace &quot;&lt;sfile&gt;&quot; with the sourced file name, and do &quot;:&quot; stuff */</a>
<a name="ln9083">      repl = eval_vars(p, result, &amp;srclen, NULL, &amp;errormsg, NULL);</a>
<a name="ln9084">      if (errormsg != NULL) {</a>
<a name="ln9085">        if (*errormsg)</a>
<a name="ln9086">          emsg(errormsg);</a>
<a name="ln9087">        xfree(result);</a>
<a name="ln9088">        return NULL;</a>
<a name="ln9089">      }</a>
<a name="ln9090">      if (repl == NULL) {               /* no match (cannot happen) */</a>
<a name="ln9091">        p += srclen;</a>
<a name="ln9092">        continue;</a>
<a name="ln9093">      }</a>
<a name="ln9094">      len = STRLEN(result) - srclen + STRLEN(repl) + 1;</a>
<a name="ln9095">      newres = xmalloc(len);</a>
<a name="ln9096">      memmove(newres, result, (size_t)(p - result));</a>
<a name="ln9097">      STRCPY(newres + (p - result), repl);</a>
<a name="ln9098">      len = STRLEN(newres);</a>
<a name="ln9099">      STRCAT(newres, p + srclen);</a>
<a name="ln9100">      xfree(repl);</a>
<a name="ln9101">      xfree(result);</a>
<a name="ln9102">      result = newres;</a>
<a name="ln9103">      p = newres + len;                 /* continue after the match */</a>
<a name="ln9104">    }</a>
<a name="ln9105">  }</a>
<a name="ln9106"> </a>
<a name="ln9107">  return result;</a>
<a name="ln9108">}</a>
<a name="ln9109"> </a>
<a name="ln9110">/*</a>
<a name="ln9111"> * &quot;:rshada&quot; and &quot;:wshada&quot;.</a>
<a name="ln9112"> */</a>
<a name="ln9113">static void ex_shada(exarg_T *eap)</a>
<a name="ln9114">{</a>
<a name="ln9115">  char_u      *save_shada;</a>
<a name="ln9116"> </a>
<a name="ln9117">  save_shada = p_shada;</a>
<a name="ln9118">  if (*p_shada == NUL)</a>
<a name="ln9119">    p_shada = (char_u *)&quot;'100&quot;;</a>
<a name="ln9120">  if (eap-&gt;cmdidx == CMD_rviminfo || eap-&gt;cmdidx == CMD_rshada) {</a>
<a name="ln9121">    (void) shada_read_everything((char *) eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln9122">  } else {</a>
<a name="ln9123">    shada_write_file((char *) eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln9124">  }</a>
<a name="ln9125">  p_shada = save_shada;</a>
<a name="ln9126">}</a>
<a name="ln9127"> </a>
<a name="ln9128">/*</a>
<a name="ln9129"> * Make a dialog message in &quot;buff[DIALOG_MSG_SIZE]&quot;.</a>
<a name="ln9130"> * &quot;format&quot; must contain &quot;%s&quot;.</a>
<a name="ln9131"> */</a>
<a name="ln9132">void dialog_msg(char_u *buff, char *format, char_u *fname)</a>
<a name="ln9133">{</a>
<a name="ln9134">  if (fname == NULL)</a>
<a name="ln9135">    fname = (char_u *)_(&quot;Untitled&quot;);</a>
<a name="ln9136">  vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);</a>
<a name="ln9137">}</a>
<a name="ln9138"> </a>
<a name="ln9139">/*</a>
<a name="ln9140"> * &quot;:behave {mswin,xterm}&quot;</a>
<a name="ln9141"> */</a>
<a name="ln9142">static void ex_behave(exarg_T *eap)</a>
<a name="ln9143">{</a>
<a name="ln9144">  if (STRCMP(eap-&gt;arg, &quot;mswin&quot;) == 0) {</a>
<a name="ln9145">    set_option_value(&quot;selection&quot;, 0L, &quot;exclusive&quot;, 0);</a>
<a name="ln9146">    set_option_value(&quot;selectmode&quot;, 0L, &quot;mouse,key&quot;, 0);</a>
<a name="ln9147">    set_option_value(&quot;mousemodel&quot;, 0L, &quot;popup&quot;, 0);</a>
<a name="ln9148">    set_option_value(&quot;keymodel&quot;, 0L, &quot;startsel,stopsel&quot;, 0);</a>
<a name="ln9149">  } else if (STRCMP(eap-&gt;arg, &quot;xterm&quot;) == 0) {</a>
<a name="ln9150">    set_option_value(&quot;selection&quot;, 0L, &quot;inclusive&quot;, 0);</a>
<a name="ln9151">    set_option_value(&quot;selectmode&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln9152">    set_option_value(&quot;mousemodel&quot;, 0L, &quot;extend&quot;, 0);</a>
<a name="ln9153">    set_option_value(&quot;keymodel&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln9154">  } else {</a>
<a name="ln9155">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln9156">  }</a>
<a name="ln9157">}</a>
<a name="ln9158"> </a>
<a name="ln9159">/*</a>
<a name="ln9160"> * Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln9161"> * &quot;:behave {mswin,xterm}&quot; command.</a>
<a name="ln9162"> */</a>
<a name="ln9163">char_u *get_behave_arg(expand_T *xp, int idx)</a>
<a name="ln9164">{</a>
<a name="ln9165">  if (idx == 0)</a>
<a name="ln9166">    return (char_u *)&quot;mswin&quot;;</a>
<a name="ln9167">  if (idx == 1)</a>
<a name="ln9168">    return (char_u *)&quot;xterm&quot;;</a>
<a name="ln9169">  return NULL;</a>
<a name="ln9170">}</a>
<a name="ln9171"> </a>
<a name="ln9172">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln9173">// &quot;:messages {clear}&quot; command.</a>
<a name="ln9174">char_u *get_messages_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln9175">{</a>
<a name="ln9176">  if (idx == 0) {</a>
<a name="ln9177">    return (char_u *)&quot;clear&quot;;</a>
<a name="ln9178">  }</a>
<a name="ln9179">  return NULL;</a>
<a name="ln9180">}</a>
<a name="ln9181"> </a>
<a name="ln9182">char_u *get_mapclear_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln9183">{</a>
<a name="ln9184">  if (idx == 0) {</a>
<a name="ln9185">    return (char_u *)&quot;&lt;buffer&gt;&quot;;</a>
<a name="ln9186">  }</a>
<a name="ln9187">  return NULL;</a>
<a name="ln9188">}</a>
<a name="ln9189"> </a>
<a name="ln9190">static TriState filetype_detect = kNone;</a>
<a name="ln9191">static TriState filetype_plugin = kNone;</a>
<a name="ln9192">static TriState filetype_indent = kNone;</a>
<a name="ln9193"> </a>
<a name="ln9194">/*</a>
<a name="ln9195"> * &quot;:filetype [plugin] [indent] {on,off,detect}&quot;</a>
<a name="ln9196"> * on: Load the filetype.vim file to install autocommands for file types.</a>
<a name="ln9197"> * off: Load the ftoff.vim file to remove all autocommands for file types.</a>
<a name="ln9198"> * plugin on: load filetype.vim and ftplugin.vim</a>
<a name="ln9199"> * plugin off: load ftplugof.vim</a>
<a name="ln9200"> * indent on: load filetype.vim and indent.vim</a>
<a name="ln9201"> * indent off: load indoff.vim</a>
<a name="ln9202"> */</a>
<a name="ln9203">static void ex_filetype(exarg_T *eap)</a>
<a name="ln9204">{</a>
<a name="ln9205">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln9206">  bool plugin = false;</a>
<a name="ln9207">  bool indent = false;</a>
<a name="ln9208"> </a>
<a name="ln9209">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln9210">    /* Print current status. */</a>
<a name="ln9211">    smsg(&quot;filetype detection:%s  plugin:%s  indent:%s&quot;,</a>
<a name="ln9212">         filetype_detect == kTrue ? &quot;ON&quot; : &quot;OFF&quot;,</a>
<a name="ln9213">         filetype_plugin == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;,   // NOLINT(whitespace/line_length)</a>
<a name="ln9214">         filetype_indent == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;);  // NOLINT(whitespace/line_length)</a>
<a name="ln9215">    return;</a>
<a name="ln9216">  }</a>
<a name="ln9217"> </a>
<a name="ln9218">  /* Accept &quot;plugin&quot; and &quot;indent&quot; in any order. */</a>
<a name="ln9219">  for (;; ) {</a>
<a name="ln9220">    if (STRNCMP(arg, &quot;plugin&quot;, 6) == 0) {</a>
<a name="ln9221">      plugin = true;</a>
<a name="ln9222">      arg = skipwhite(arg + 6);</a>
<a name="ln9223">      continue;</a>
<a name="ln9224">    }</a>
<a name="ln9225">    if (STRNCMP(arg, &quot;indent&quot;, 6) == 0) {</a>
<a name="ln9226">      indent = true;</a>
<a name="ln9227">      arg = skipwhite(arg + 6);</a>
<a name="ln9228">      continue;</a>
<a name="ln9229">    }</a>
<a name="ln9230">    break;</a>
<a name="ln9231">  }</a>
<a name="ln9232">  if (STRCMP(arg, &quot;on&quot;) == 0 || STRCMP(arg, &quot;detect&quot;) == 0) {</a>
<a name="ln9233">    if (*arg == 'o' || !filetype_detect) {</a>
<a name="ln9234">      source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);</a>
<a name="ln9235">      filetype_detect = kTrue;</a>
<a name="ln9236">      if (plugin) {</a>
<a name="ln9237">        source_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln9238">        filetype_plugin = kTrue;</a>
<a name="ln9239">      }</a>
<a name="ln9240">      if (indent) {</a>
<a name="ln9241">        source_runtime((char_u *)INDENT_FILE, DIP_ALL);</a>
<a name="ln9242">        filetype_indent = kTrue;</a>
<a name="ln9243">      }</a>
<a name="ln9244">    }</a>
<a name="ln9245">    if (*arg == 'd') {</a>
<a name="ln9246">      (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln9247">      do_modelines(0);</a>
<a name="ln9248">    }</a>
<a name="ln9249">  } else if (STRCMP(arg, &quot;off&quot;) == 0) {</a>
<a name="ln9250">    if (plugin || indent) {</a>
<a name="ln9251">      if (plugin) {</a>
<a name="ln9252">        source_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);</a>
<a name="ln9253">        filetype_plugin = kFalse;</a>
<a name="ln9254">      }</a>
<a name="ln9255">      if (indent) {</a>
<a name="ln9256">        source_runtime((char_u *)INDOFF_FILE, DIP_ALL);</a>
<a name="ln9257">        filetype_indent = kFalse;</a>
<a name="ln9258">      }</a>
<a name="ln9259">    } else {</a>
<a name="ln9260">      source_runtime((char_u *)FTOFF_FILE, DIP_ALL);</a>
<a name="ln9261">      filetype_detect = kFalse;</a>
<a name="ln9262">    }</a>
<a name="ln9263">  } else</a>
<a name="ln9264">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln9265">}</a>
<a name="ln9266"> </a>
<a name="ln9267">/// Set all :filetype options ON if user did not explicitly set any to OFF.</a>
<a name="ln9268">void filetype_maybe_enable(void)</a>
<a name="ln9269">{</a>
<a name="ln9270">  if (filetype_detect == kNone) {</a>
<a name="ln9271">    source_runtime((char_u *)FILETYPE_FILE, true);</a>
<a name="ln9272">    filetype_detect = kTrue;</a>
<a name="ln9273">  }</a>
<a name="ln9274">  if (filetype_plugin == kNone) {</a>
<a name="ln9275">    source_runtime((char_u *)FTPLUGIN_FILE, true);</a>
<a name="ln9276">    filetype_plugin = kTrue;</a>
<a name="ln9277">  }</a>
<a name="ln9278">  if (filetype_indent == kNone) {</a>
<a name="ln9279">    source_runtime((char_u *)INDENT_FILE, true);</a>
<a name="ln9280">    filetype_indent = kTrue;</a>
<a name="ln9281">  }</a>
<a name="ln9282">}</a>
<a name="ln9283"> </a>
<a name="ln9284">/// &quot;:setfiletype [FALLBACK] {name}&quot;</a>
<a name="ln9285">static void ex_setfiletype(exarg_T *eap)</a>
<a name="ln9286">{</a>
<a name="ln9287">  if (!did_filetype) {</a>
<a name="ln9288">    char_u *arg = eap-&gt;arg;</a>
<a name="ln9289"> </a>
<a name="ln9290">    if (STRNCMP(arg, &quot;FALLBACK &quot;, 9) == 0) {</a>
<a name="ln9291">      arg += 9;</a>
<a name="ln9292">    }</a>
<a name="ln9293"> </a>
<a name="ln9294">    set_option_value(&quot;filetype&quot;, 0L, (char *)arg, OPT_LOCAL);</a>
<a name="ln9295">    if (arg != eap-&gt;arg) {</a>
<a name="ln9296">      did_filetype = false;</a>
<a name="ln9297">    }</a>
<a name="ln9298">  }</a>
<a name="ln9299">}</a>
<a name="ln9300"> </a>
<a name="ln9301">static void ex_digraphs(exarg_T *eap)</a>
<a name="ln9302">{</a>
<a name="ln9303">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln9304">    putdigraph(eap-&gt;arg);</a>
<a name="ln9305">  } else {</a>
<a name="ln9306">    listdigraphs(eap-&gt;forceit);</a>
<a name="ln9307">  }</a>
<a name="ln9308">}</a>
<a name="ln9309"> </a>
<a name="ln9310">static void ex_set(exarg_T *eap)</a>
<a name="ln9311">{</a>
<a name="ln9312">  int flags = 0;</a>
<a name="ln9313"> </a>
<a name="ln9314">  if (eap-&gt;cmdidx == CMD_setlocal)</a>
<a name="ln9315">    flags = OPT_LOCAL;</a>
<a name="ln9316">  else if (eap-&gt;cmdidx == CMD_setglobal)</a>
<a name="ln9317">    flags = OPT_GLOBAL;</a>
<a name="ln9318">  (void)do_set(eap-&gt;arg, flags);</a>
<a name="ln9319">}</a>
<a name="ln9320"> </a>
<a name="ln9321">void set_no_hlsearch(bool flag)</a>
<a name="ln9322">{</a>
<a name="ln9323">  no_hlsearch = flag;</a>
<a name="ln9324">  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch &amp;&amp; p_hls);</a>
<a name="ln9325">}</a>
<a name="ln9326"> </a>
<a name="ln9327">/*</a>
<a name="ln9328"> * &quot;:nohlsearch&quot;</a>
<a name="ln9329"> */</a>
<a name="ln9330">static void ex_nohlsearch(exarg_T *eap)</a>
<a name="ln9331">{</a>
<a name="ln9332">  set_no_hlsearch(true);</a>
<a name="ln9333">  redraw_all_later(SOME_VALID);</a>
<a name="ln9334">}</a>
<a name="ln9335"> </a>
<a name="ln9336">// &quot;:[N]match {group} {pattern}&quot;</a>
<a name="ln9337">// Sets nextcmd to the start of the next command, if any.  Also called when</a>
<a name="ln9338">// skipping commands to find the next command.</a>
<a name="ln9339">static void ex_match(exarg_T *eap)</a>
<a name="ln9340">{</a>
<a name="ln9341">  char_u *p;</a>
<a name="ln9342">  char_u *g = NULL;</a>
<a name="ln9343">  char_u *end;</a>
<a name="ln9344">  int c;</a>
<a name="ln9345">  int id;</a>
<a name="ln9346"> </a>
<a name="ln9347">  if (eap-&gt;line2 &lt;= 3) {</a>
<a name="ln9348">    id = eap-&gt;line2;</a>
<a name="ln9349">  } else {</a>
<a name="ln9350">    EMSG(e_invcmd);</a>
<a name="ln9351">    return;</a>
<a name="ln9352">  }</a>
<a name="ln9353"> </a>
<a name="ln9354">  // First clear any old pattern.</a>
<a name="ln9355">  if (!eap-&gt;skip) {</a>
<a name="ln9356">    match_delete(curwin, id, false);</a>
<a name="ln9357">  }</a>
<a name="ln9358"> </a>
<a name="ln9359">  if (ends_excmd(*eap-&gt;arg)) {</a>
<a name="ln9360">    end = eap-&gt;arg;</a>
<a name="ln9361">  } else if ((STRNICMP(eap-&gt;arg, &quot;none&quot;, 4) == 0</a>
<a name="ln9362">              &amp;&amp; (ascii_iswhite(eap-&gt;arg[4]) || ends_excmd(eap-&gt;arg[4])))) {</a>
<a name="ln9363">    end = eap-&gt;arg + 4;</a>
<a name="ln9364">  } else {</a>
<a name="ln9365">    p = skiptowhite(eap-&gt;arg);</a>
<a name="ln9366">    if (!eap-&gt;skip) {</a>
<a name="ln9367">      g = vim_strnsave(eap-&gt;arg, p - eap-&gt;arg);</a>
<a name="ln9368">    }</a>
<a name="ln9369">    p = skipwhite(p);</a>
<a name="ln9370">    if (*p == NUL) {</a>
<a name="ln9371">      // There must be two arguments.</a>
<a name="ln9372">      xfree(g);</a>
<a name="ln9373">      EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln9374">      return;</a>
<a name="ln9375">    }</a>
<a name="ln9376">    end = skip_regexp(p + 1, *p, true, NULL);</a>
<a name="ln9377">    if (!eap-&gt;skip) {</a>
<a name="ln9378">      if (*end != NUL &amp;&amp; !ends_excmd(*skipwhite(end + 1))) {</a>
<a name="ln9379">        xfree(g);</a>
<a name="ln9380">        eap-&gt;errmsg = e_trailing;</a>
<a name="ln9381">        return;</a>
<a name="ln9382">      }</a>
<a name="ln9383">      if (*end != *p) {</a>
<a name="ln9384">        xfree(g);</a>
<a name="ln9385">        EMSG2(_(e_invarg2), p);</a>
<a name="ln9386">        return;</a>
<a name="ln9387">      }</a>
<a name="ln9388"> </a>
<a name="ln9389">      c = *end;</a>
<a name="ln9390">      *end = NUL;</a>
<a name="ln9391">      match_add(curwin, (const char *)g, (const char *)p + 1, 10, id,</a>
<a name="ln9392">                NULL, NULL);</a>
<a name="ln9393">      xfree(g);</a>
<a name="ln9394">      *end = c;</a>
<a name="ln9395">    }</a>
<a name="ln9396">  }</a>
<a name="ln9397">  eap-&gt;nextcmd = find_nextcmd(end);</a>
<a name="ln9398">}</a>
<a name="ln9399"> </a>
<a name="ln9400">static void ex_fold(exarg_T *eap)</a>
<a name="ln9401">{</a>
<a name="ln9402">  if (foldManualAllowed(true)) {</a>
<a name="ln9403">    pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln9404">    pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln9405">    foldCreate(curwin, start, end);</a>
<a name="ln9406">  }</a>
<a name="ln9407">}</a>
<a name="ln9408"> </a>
<a name="ln9409">static void ex_foldopen(exarg_T *eap)</a>
<a name="ln9410">{</a>
<a name="ln9411">  pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln9412">  pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln9413">  opFoldRange(start, end, eap-&gt;cmdidx == CMD_foldopen, eap-&gt;forceit, false);</a>
<a name="ln9414">}</a>
<a name="ln9415"> </a>
<a name="ln9416">static void ex_folddo(exarg_T *eap)</a>
<a name="ln9417">{</a>
<a name="ln9418">  // First set the marks for all lines closed/open.</a>
<a name="ln9419">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; ++lnum) {</a>
<a name="ln9420">    if (hasFolding(lnum, NULL, NULL) == (eap-&gt;cmdidx == CMD_folddoclosed)) {</a>
<a name="ln9421">      ml_setmarked(lnum);</a>
<a name="ln9422">    }</a>
<a name="ln9423">  }</a>
<a name="ln9424"> </a>
<a name="ln9425">  global_exe(eap-&gt;arg);  // Execute the command on the marked lines.</a>
<a name="ln9426">  ml_clearmarked();      // clear rest of the marks</a>
<a name="ln9427">}</a>
<a name="ln9428"> </a>
<a name="ln9429">// Returns true if the supplied Ex cmdidx is for a location list command</a>
<a name="ln9430">// instead of a quickfix command.</a>
<a name="ln9431">bool is_loclist_cmd(int cmdidx)</a>
<a name="ln9432">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9433">{</a>
<a name="ln9434">  if (cmdidx &lt; 0 || cmdidx &gt;= CMD_SIZE) {</a>
<a name="ln9435">    return false;</a>
<a name="ln9436">  }</a>
<a name="ln9437">  return cmdnames[cmdidx].cmd_name[0] == 'l';</a>
<a name="ln9438">}</a>
<a name="ln9439"> </a>
<a name="ln9440">bool get_pressedreturn(void)</a>
<a name="ln9441">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9442">{</a>
<a name="ln9443">  return ex_pressedreturn;</a>
<a name="ln9444">}</a>
<a name="ln9445"> </a>
<a name="ln9446">void set_pressedreturn(bool val)</a>
<a name="ln9447">{</a>
<a name="ln9448">  ex_pressedreturn = val;</a>
<a name="ln9449">}</a>
<a name="ln9450"> </a>
<a name="ln9451">static void ex_terminal(exarg_T *eap)</a>
<a name="ln9452">{</a>
<a name="ln9453">  char ex_cmd[1024];</a>
<a name="ln9454"> </a>
<a name="ln9455">  if (*eap-&gt;arg != NUL) {  // Run {cmd} in 'shell'.</a>
<a name="ln9456">    char *name = (char *)vim_strsave_escaped(eap-&gt;arg, (char_u *)&quot;\&quot;\\&quot;);</a>
<a name="ln9457">    snprintf(ex_cmd, sizeof(ex_cmd),</a>
<a name="ln9458">             &quot;:enew%s | call termopen(\&quot;%s\&quot;)&quot;,</a>
<a name="ln9459">             eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;, name);</a>
<a name="ln9460">    xfree(name);</a>
<a name="ln9461">  } else {  // No {cmd}: run the job with tokenized 'shell'.</a>
<a name="ln9462">    if (*p_sh == NUL) {</a>
<a name="ln9463">      EMSG(_(e_shellempty));</a>
<a name="ln9464">      return;</a>
<a name="ln9465">    }</a>
<a name="ln9466"> </a>
<a name="ln9467">    char **argv = shell_build_argv(NULL, NULL);</a>
<a name="ln9468">    char **p = argv;</a>
<a name="ln9469">    char tempstring[512];</a>
<a name="ln9470">    char shell_argv[512] = { 0 };</a>
<a name="ln9471"> </a>
<a name="ln9472">    while (*p != NULL) {</a>
<a name="ln9473">      snprintf(tempstring, sizeof(tempstring), &quot;,\&quot;%s\&quot;&quot;, *p);</a>
<a name="ln9474">      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));</a>
<a name="ln9475">      p++;</a>
<a name="ln9476">    }</a>
<a name="ln9477">    shell_free_argv(argv);</a>
<a name="ln9478"> </a>
<a name="ln9479">    snprintf(ex_cmd, sizeof(ex_cmd),</a>
<a name="ln9480">             &quot;:enew%s | call termopen([%s])&quot;,</a>
<a name="ln9481">             eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;, shell_argv + 1);</a>
<a name="ln9482">  }</a>
<a name="ln9483"> </a>
<a name="ln9484">  do_cmdline_cmd(ex_cmd);</a>
<a name="ln9485">}</a>
<a name="ln9486"> </a>
<a name="ln9487">/// Checks if `cmd` is &quot;previewable&quot; (i.e. supported by 'inccommand').</a>
<a name="ln9488">///</a>
<a name="ln9489">/// @param[in] cmd Commandline to check. May start with a range or modifier.</a>
<a name="ln9490">///</a>
<a name="ln9491">/// @return true if `cmd` is previewable</a>
<a name="ln9492">bool cmd_can_preview(char_u *cmd)</a>
<a name="ln9493">{</a>
<a name="ln9494">  if (cmd == NULL) {</a>
<a name="ln9495">    return false;</a>
<a name="ln9496">  }</a>
<a name="ln9497"> </a>
<a name="ln9498">  // Ignore additional colons at the start...</a>
<a name="ln9499">  cmd = skip_colon_white(cmd, true);</a>
<a name="ln9500"> </a>
<a name="ln9501">  // Ignore any leading modifiers (:keeppatterns, :verbose, etc.)</a>
<a name="ln9502">  for (int len = modifier_len(cmd); len != 0; len = modifier_len(cmd)) {</a>
<a name="ln9503">    cmd += len;</a>
<a name="ln9504">    cmd = skip_colon_white(cmd, true);</a>
<a name="ln9505">  }</a>
<a name="ln9506"> </a>
<a name="ln9507">  exarg_T ea;</a>
<a name="ln9508">  memset(&amp;ea, 0, sizeof(ea));</a>
<a name="ln9509">  // parse the command line</a>
<a name="ln9510">  ea.cmd = skip_range(cmd, NULL);</a>
<a name="ln9511">  if (*ea.cmd == '*') {</a>
<a name="ln9512">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln9513">  }</a>
<a name="ln9514">  char_u *end = find_command(&amp;ea, NULL);</a>
<a name="ln9515"> </a>
<a name="ln9516">  switch (ea.cmdidx) {</a>
<a name="ln9517">    case CMD_substitute:</a>
<a name="ln9518">    case CMD_smagic:</a>
<a name="ln9519">    case CMD_snomagic:</a>
<a name="ln9520">      // Only preview once the pattern delimiter has been typed</a>
<a name="ln9521">      if (*end &amp;&amp; !ASCII_ISALNUM(*end)) {</a>
<a name="ln9522">        return true;</a>
<a name="ln9523">      }</a>
<a name="ln9524">      break;</a>
<a name="ln9525">    default:</a>
<a name="ln9526">      break;</a>
<a name="ln9527">  }</a>
<a name="ln9528"> </a>
<a name="ln9529">  return false;</a>
<a name="ln9530">}</a>
<a name="ln9531"> </a>
<a name="ln9532">/// Gets a map of maps describing user-commands defined for buffer `buf` or</a>
<a name="ln9533">/// defined globally if `buf` is NULL.</a>
<a name="ln9534">///</a>
<a name="ln9535">/// @param buf  Buffer to inspect, or NULL to get global commands.</a>
<a name="ln9536">///</a>
<a name="ln9537">/// @return Map of maps describing commands</a>
<a name="ln9538">Dictionary commands_array(buf_T *buf)</a>
<a name="ln9539">{</a>
<a name="ln9540">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln9541">  char str[20];</a>
<a name="ln9542">  garray_T *gap = (buf == NULL) ? &amp;ucmds : &amp;buf-&gt;b_ucmds;</a>
<a name="ln9543"> </a>
<a name="ln9544">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln9545">    char arg[2] = { 0, 0 };</a>
<a name="ln9546">    Dictionary d = ARRAY_DICT_INIT;</a>
<a name="ln9547">    ucmd_T *cmd = USER_CMD_GA(gap, i);</a>
<a name="ln9548"> </a>
<a name="ln9549">    PUT(d, &quot;name&quot;, STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_name)));</a>
<a name="ln9550">    PUT(d, &quot;definition&quot;, STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_rep)));</a>
<a name="ln9551">    PUT(d, &quot;script_id&quot;, INTEGER_OBJ(cmd-&gt;uc_script_ctx.sc_sid));</a>
<a name="ln9552">    PUT(d, &quot;bang&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_BANG)));</a>
<a name="ln9553">    PUT(d, &quot;bar&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_TRLBAR)));</a>
<a name="ln9554">    PUT(d, &quot;register&quot;, BOOLEAN_OBJ(!!(cmd-&gt;uc_argt &amp; EX_REGSTR)));</a>
<a name="ln9555"> </a>
<a name="ln9556">    switch (cmd-&gt;uc_argt &amp; (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {</a>
<a name="ln9557">      case 0:                                 arg[0] = '0'; break;</a>
<a name="ln9558">      case(EX_EXTRA):                         arg[0] = '*'; break;</a>
<a name="ln9559">      case(EX_EXTRA | EX_NOSPC):              arg[0] = '?'; break;</a>
<a name="ln9560">      case(EX_EXTRA | EX_NEEDARG):            arg[0] = '+'; break;</a>
<a name="ln9561">      case(EX_EXTRA | EX_NOSPC | EX_NEEDARG): arg[0] = '1'; break;</a>
<a name="ln9562">    }</a>
<a name="ln9563">    PUT(d, &quot;nargs&quot;, STRING_OBJ(cstr_to_string(arg)));</a>
<a name="ln9564"> </a>
<a name="ln9565">    char *cmd_compl = get_command_complete(cmd-&gt;uc_compl);</a>
<a name="ln9566">    PUT(d, &quot;complete&quot;, (cmd_compl == NULL</a>
<a name="ln9567">                        ? NIL : STRING_OBJ(cstr_to_string(cmd_compl))));</a>
<a name="ln9568">    PUT(d, &quot;complete_arg&quot;, cmd-&gt;uc_compl_arg == NULL</a>
<a name="ln9569">        ? NIL : STRING_OBJ(cstr_to_string((char *)cmd-&gt;uc_compl_arg)));</a>
<a name="ln9570"> </a>
<a name="ln9571">    Object obj = NIL;</a>
<a name="ln9572">    if (cmd-&gt;uc_argt &amp; EX_COUNT) {</a>
<a name="ln9573">      if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln9574">        snprintf(str, sizeof(str), &quot;%&quot; PRId64, (int64_t)cmd-&gt;uc_def);</a>
<a name="ln9575">        obj = STRING_OBJ(cstr_to_string(str));    // -count=N</a>
<a name="ln9576">      } else {</a>
<a name="ln9577">        obj = STRING_OBJ(cstr_to_string(&quot;0&quot;));    // -count</a>
<a name="ln9578">      }</a>
<a name="ln9579">    }</a>
<a name="ln9580">    PUT(d, &quot;count&quot;, obj);</a>
<a name="ln9581"> </a>
<a name="ln9582">    obj = NIL;</a>
<a name="ln9583">    if (cmd-&gt;uc_argt &amp; EX_RANGE) {</a>
<a name="ln9584">      if (cmd-&gt;uc_argt &amp; EX_DFLALL) {</a>
<a name="ln9585">        obj = STRING_OBJ(cstr_to_string(&quot;%&quot;));    // -range=%</a>
<a name="ln9586">      } else if (cmd-&gt;uc_def &gt;= 0) {</a>
<a name="ln9587">        snprintf(str, sizeof(str), &quot;%&quot; PRId64, (int64_t)cmd-&gt;uc_def);</a>
<a name="ln9588">        obj = STRING_OBJ(cstr_to_string(str));    // -range=N</a>
<a name="ln9589">      } else {</a>
<a name="ln9590">        obj = STRING_OBJ(cstr_to_string(&quot;.&quot;));    // -range</a>
<a name="ln9591">      }</a>
<a name="ln9592">    }</a>
<a name="ln9593">    PUT(d, &quot;range&quot;, obj);</a>
<a name="ln9594"> </a>
<a name="ln9595">    obj = NIL;</a>
<a name="ln9596">    for (int j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {</a>
<a name="ln9597">      if (addr_type_complete[j].expand != ADDR_LINES</a>
<a name="ln9598">          &amp;&amp; addr_type_complete[j].expand == cmd-&gt;uc_addr_type) {</a>
<a name="ln9599">        obj = STRING_OBJ(cstr_to_string(addr_type_complete[j].name));</a>
<a name="ln9600">        break;</a>
<a name="ln9601">      }</a>
<a name="ln9602">    }</a>
<a name="ln9603">    PUT(d, &quot;addr&quot;, obj);</a>
<a name="ln9604"> </a>
<a name="ln9605">    PUT(rv, (char *)cmd-&gt;uc_name, DICTIONARY_OBJ(d));</a>
<a name="ln9606">  }</a>
<a name="ln9607">  return rv;</a>
<a name="ln9608">}</a>

</code></pre>
<div class="balloon" rel="4174"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'eap->line2 < 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

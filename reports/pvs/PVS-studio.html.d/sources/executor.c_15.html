
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>executor.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;lua.h&gt;</a>
<a name="ln5">#include &lt;lualib.h&gt;</a>
<a name="ln6">#include &lt;lauxlib.h&gt;</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln9">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln10">#include &quot;nvim/garray.h&quot;</a>
<a name="ln11">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln12">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln13">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln14">#include &quot;nvim/api/private/handle.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln17">#include &quot;nvim/vim.h&quot;</a>
<a name="ln18">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln19">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln20">#include &quot;nvim/message.h&quot;</a>
<a name="ln21">#include &quot;nvim/memline.h&quot;</a>
<a name="ln22">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln23">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln24">#include &quot;nvim/macros.h&quot;</a>
<a name="ln25">#include &quot;nvim/screen.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/undo.h&quot;</a>
<a name="ln28">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln29">#include &quot;nvim/change.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln31">#include &quot;nvim/event/time.h&quot;</a>
<a name="ln32">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#ifdef WIN32</a>
<a name="ln35">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;nvim/lua/converter.h&quot;</a>
<a name="ln39">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln40">#include &quot;nvim/lua/treesitter.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;luv/luv.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">static int in_fast_callback = 0;</a>
<a name="ln45"> </a>
<a name="ln46">typedef struct {</a>
<a name="ln47">  Error err;</a>
<a name="ln48">  String lua_err_str;</a>
<a name="ln49">} LuaError;</a>
<a name="ln50"> </a>
<a name="ln51">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln52"># include &quot;lua/vim_module.generated.h&quot;</a>
<a name="ln53"># include &quot;lua/executor.c.generated.h&quot;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#define PUSH_ALL_TYPVALS(lstate, args, argcount, special) \</a>
<a name="ln57">  for (int i = 0; i &lt; argcount; i++) { \</a>
<a name="ln58">    if (args[i].v_type == VAR_UNKNOWN) { \</a>
<a name="ln59">      lua_pushnil(lstate); \</a>
<a name="ln60">    } else { \</a>
<a name="ln61">      nlua_push_typval(lstate, &amp;args[i], special); \</a>
<a name="ln62">    } \</a>
<a name="ln63">  }</a>
<a name="ln64"> </a>
<a name="ln65">/// Convert lua error into a Vim error message</a>
<a name="ln66">///</a>
<a name="ln67">/// @param  lstate  Lua interpreter state.</a>
<a name="ln68">/// @param[in]  msg  Message base, must contain one `%s`.</a>
<a name="ln69">static void nlua_error(lua_State *const lstate, const char *const msg)</a>
<a name="ln70">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln71">{</a>
<a name="ln72">  size_t len;</a>
<a name="ln73">  const char *const str = lua_tolstring(lstate, -1, &amp;len);</a>
<a name="ln74"> </a>
<a name="ln75">  msg_ext_set_kind(&quot;lua_error&quot;);</a>
<a name="ln76">  emsgf_multiline(msg, (int)len, str);</a>
<a name="ln77"> </a>
<a name="ln78">  lua_pop(lstate, 1);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">/// Compare two strings, ignoring case</a>
<a name="ln82">///</a>
<a name="ln83">/// Expects two values on the stack: compared strings. Returns one of the</a>
<a name="ln84">/// following numbers: 0, -1 or 1.</a>
<a name="ln85">///</a>
<a name="ln86">/// Does no error handling: never call it with non-string or with some arguments</a>
<a name="ln87">/// omitted.</a>
<a name="ln88">static int nlua_stricmp(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln89">{</a>
<a name="ln90">  size_t s1_len;</a>
<a name="ln91">  size_t s2_len;</a>
<a name="ln92">  const char *s1 = luaL_checklstring(lstate, 1, &amp;s1_len);</a>
<a name="ln93">  const char *s2 = luaL_checklstring(lstate, 2, &amp;s2_len);</a>
<a name="ln94">  char *nul1;</a>
<a name="ln95">  char *nul2;</a>
<a name="ln96">  int ret = 0;</a>
<a name="ln97">  assert(s1[s1_len] == NUL);</a>
<a name="ln98">  assert(s2[s2_len] == NUL);</a>
<a name="ln99">  do {</a>
<a name="ln100">    nul1 = memchr(s1, NUL, s1_len);</a>
<a name="ln101">    nul2 = memchr(s2, NUL, s2_len);</a>
<a name="ln102">    ret = STRICMP(s1, s2);</a>
<a name="ln103">    if (ret == 0) {</a>
<a name="ln104">      // Compare &quot;a\0&quot; greater then &quot;a&quot;.</a>
<a name="ln105">      if ((nul1 == NULL) != (nul2 == NULL)) {</a>
<a name="ln106">        ret = ((nul1 != NULL) - (nul2 != NULL));</a>
<a name="ln107">        break;</a>
<a name="ln108">      }</a>
<a name="ln109">      if (nul1 != NULL) {</a>
<a name="ln110">        assert(nul2 != NULL);</a>
<a name="ln111">        // Can't shift both strings by the same amount of bytes: lowercase</a>
<a name="ln112">        // letter may have different byte-length than uppercase.</a>
<a name="ln113">        s1_len -= (size_t)(nul1 - s1) + 1;</a>
<a name="ln114">        s2_len -= (size_t)(nul2 - s2) + 1;</a>
<a name="ln115">        s1 = nul1 + 1;</a>
<a name="ln116">        s2 = nul2 + 1;</a>
<a name="ln117">      } else {</a>
<a name="ln118">        break;</a>
<a name="ln119">      }</a>
<a name="ln120">    } else {</a>
<a name="ln121">      break;</a>
<a name="ln122">    }</a>
<a name="ln123">  } while (true);</a>
<a name="ln124">  lua_pop(lstate, 2);</a>
<a name="ln125">  lua_pushnumber(lstate, (lua_Number)((ret &gt; 0) - (ret &lt; 0)));</a>
<a name="ln126">  return 1;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/// convert byte index to UTF-32 and UTF-16 indicies</a>
<a name="ln130">///</a>
<a name="ln131">/// Expects a string and an optional index. If no index is supplied, the length</a>
<a name="ln132">/// of the string is returned.</a>
<a name="ln133">///</a>
<a name="ln134">/// Returns two values: the UTF-32 and UTF-16 indicies.</a>
<a name="ln135">static int nlua_str_utfindex(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln136">{</a>
<a name="ln137">  size_t s1_len;</a>
<a name="ln138">  const char *s1 = luaL_checklstring(lstate, 1, &amp;s1_len);</a>
<a name="ln139">  intptr_t idx;</a>
<a name="ln140">  if (lua_gettop(lstate) &gt;= 2) {</a>
<a name="ln141">    idx = luaL_checkinteger(lstate, 2);</a>
<a name="ln142">    if (idx &lt; 0 || idx &gt; (intptr_t)s1_len) {</a>
<a name="ln143">      return luaL_error(lstate, &quot;index out of range&quot;);</a>
<a name="ln144">    }</a>
<a name="ln145">  } else {</a>
<a name="ln146">    idx = (intptr_t)s1_len;</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  size_t codepoints = 0, codeunits = 0;</a>
<a name="ln150">  mb_utflen((const char_u *)s1, (size_t)idx, &amp;codepoints, &amp;codeunits);</a>
<a name="ln151"> </a>
<a name="ln152">  lua_pushinteger(lstate, (long)codepoints);</a>
<a name="ln153">  lua_pushinteger(lstate, (long)codeunits);</a>
<a name="ln154"> </a>
<a name="ln155">  return 2;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">/// convert UTF-32 or UTF-16 indicies to byte index.</a>
<a name="ln159">///</a>
<a name="ln160">/// Expects up to three args: string, index and use_utf16.</a>
<a name="ln161">/// If use_utf16 is not supplied it defaults to false (use UTF-32)</a>
<a name="ln162">///</a>
<a name="ln163">/// Returns the byte index.</a>
<a name="ln164">static int nlua_str_byteindex(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln165">{</a>
<a name="ln166">  size_t s1_len;</a>
<a name="ln167">  const char *s1 = luaL_checklstring(lstate, 1, &amp;s1_len);</a>
<a name="ln168">  intptr_t idx = luaL_checkinteger(lstate, 2);</a>
<a name="ln169">  if (idx &lt; 0) {</a>
<a name="ln170">    return luaL_error(lstate, &quot;index out of range&quot;);</a>
<a name="ln171">  }</a>
<a name="ln172">  bool use_utf16 = false;</a>
<a name="ln173">  if (lua_gettop(lstate) &gt;= 3) {</a>
<a name="ln174">    use_utf16 = lua_toboolean(lstate, 3);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  ssize_t byteidx = mb_utf_index_to_bytes((const char_u *)s1, s1_len,</a>
<a name="ln178">                                          (size_t)idx, use_utf16);</a>
<a name="ln179">  if (byteidx == -1) {</a>
<a name="ln180">    return luaL_error(lstate, &quot;index out of range&quot;);</a>
<a name="ln181">  }</a>
<a name="ln182"> </a>
<a name="ln183">  lua_pushinteger(lstate, (long)byteidx);</a>
<a name="ln184"> </a>
<a name="ln185">  return 1;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static void nlua_luv_error_event(void **argv)</a>
<a name="ln189">{</a>
<a name="ln190">  char *error = (char *)argv[0];</a>
<a name="ln191">  msg_ext_set_kind(&quot;lua_error&quot;);</a>
<a name="ln192">  emsgf_multiline(&quot;Error executing luv callback:\n%s&quot;, error);</a>
<a name="ln193">  xfree(error);</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">static int nlua_luv_cfpcall(lua_State *lstate, int nargs, int nresult,</a>
<a name="ln197">                            int flags)</a>
<a name="ln198">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln199">{</a>
<a name="ln200">  int retval;</a>
<a name="ln201"> </a>
<a name="ln202">  // luv callbacks might be executed at any os_breakcheck/line_breakcheck</a>
<a name="ln203">  // call, so using the API directly here is not safe.</a>
<a name="ln204">  in_fast_callback++;</a>
<a name="ln205"> </a>
<a name="ln206">  int top = lua_gettop(lstate);</a>
<a name="ln207">  int status = lua_pcall(lstate, nargs, nresult, 0);</a>
<a name="ln208">  if (status) {</a>
<a name="ln209">    if (status == LUA_ERRMEM &amp;&amp; !(flags &amp; LUVF_CALLBACK_NOEXIT)) {</a>
<a name="ln210">      // consider out of memory errors unrecoverable, just like xmalloc()</a>
<a name="ln211">      mch_errmsg(e_outofmem);</a>
<a name="ln212">      mch_errmsg(&quot;\n&quot;);</a>
<a name="ln213">      preserve_exit();</a>
<a name="ln214">    }</a>
<a name="ln215">    const char *error = lua_tostring(lstate, -1);</a>
<a name="ln216"> </a>
<a name="ln217">    multiqueue_put(main_loop.events, nlua_luv_error_event,</a>
<a name="ln218">                   1, xstrdup(error));</a>
<a name="ln219">    lua_pop(lstate, 1);  // error mesage</a>
<a name="ln220">    retval = -status;</a>
<a name="ln221">  } else {  // LUA_OK</a>
<a name="ln222">    if (nresult == LUA_MULTRET) {</a>
<a name="ln223">      nresult = lua_gettop(lstate) - top + nargs + 1;</a>
<a name="ln224">    }</a>
<a name="ln225">    retval = nresult;</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  in_fast_callback--;</a>
<a name="ln229">  return retval;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static void nlua_schedule_event(void **argv)</a>
<a name="ln233">{</a>
<a name="ln234">  LuaRef cb = (LuaRef)(ptrdiff_t)argv[0];</a>
<a name="ln235">  lua_State *const lstate = nlua_enter();</a>
<a name="ln236">  nlua_pushref(lstate, cb);</a>
<a name="ln237">  nlua_unref(lstate, cb);</a>
<a name="ln238">  if (lua_pcall(lstate, 0, 0, 0)) {</a>
<a name="ln239">    nlua_error(lstate, _(&quot;Error executing vim.schedule lua callback: %.*s&quot;));</a>
<a name="ln240">  }</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">/// Schedule Lua callback on main loop's event queue</a>
<a name="ln244">///</a>
<a name="ln245">/// @param  lstate  Lua interpreter state.</a>
<a name="ln246">static int nlua_schedule(lua_State *const lstate)</a>
<a name="ln247">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln248">{</a>
<a name="ln249">  if (lua_type(lstate, 1) != LUA_TFUNCTION) {</a>
<a name="ln250">    lua_pushliteral(lstate, &quot;vim.schedule: expected function&quot;);</a>
<a name="ln251">    return lua_error(lstate);</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  LuaRef cb = nlua_ref(lstate, 1);</a>
<a name="ln255"> </a>
<a name="ln256">  multiqueue_put(main_loop.events, nlua_schedule_event,</a>
<a name="ln257">                 1, (void *)(ptrdiff_t)cb);</a>
<a name="ln258">  return 0;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">static struct luaL_Reg regex_meta[] = {</a>
<a name="ln262">  { &quot;__gc&quot;, regex_gc },</a>
<a name="ln263">  { &quot;__tostring&quot;, regex_tostring },</a>
<a name="ln264">  { &quot;match_str&quot;, regex_match_str },</a>
<a name="ln265">  { &quot;match_line&quot;, regex_match_line },</a>
<a name="ln266">  { NULL, NULL }</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">// Dummy timer callback. Used by f_wait().</a>
<a name="ln270">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln271">{</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln275">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln276">{</a>
<a name="ln277">  xfree(tw);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">static bool nlua_wait_condition(lua_State *lstate, int *status,</a>
<a name="ln281">                                bool *callback_result)</a>
<a name="ln282">{</a>
<a name="ln283">  lua_pushvalue(lstate, 2);</a>
<a name="ln284">  *status = lua_pcall(lstate, 0, 1, 0);</a>
<a name="ln285">  if (*status) {</a>
<a name="ln286">    return true;  // break on error, but keep error on stack</a>
<a name="ln287">  }</a>
<a name="ln288">  *callback_result = lua_toboolean(lstate, -1);</a>
<a name="ln289">  lua_pop(lstate, 1);</a>
<a name="ln290">  return *callback_result;  // break if true</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">/// &quot;vim.wait(timeout, condition[, interval])&quot; function</a>
<a name="ln294">static int nlua_wait(lua_State *lstate)</a>
<a name="ln295">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln296">{</a>
<a name="ln297">  intptr_t timeout = luaL_checkinteger(lstate, 1);</a>
<a name="ln298">  if (timeout &lt; 0) {</a>
<a name="ln299">    return luaL_error(lstate, &quot;timeout must be &gt; 0&quot;);</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  int lua_top = lua_gettop(lstate);</a>
<a name="ln303"> </a>
<a name="ln304">  // Check if condition can be called.</a>
<a name="ln305">  bool is_function = false;</a>
<a name="ln306">  if (lua_top &gt;= 2 &amp;&amp; !lua_isnil(lstate, 2)) {</a>
<a name="ln307">    is_function = (lua_type(lstate, 2) == LUA_TFUNCTION);</a>
<a name="ln308"> </a>
<a name="ln309">    // Check if condition is callable table</a>
<a name="ln310">    if (!is_function &amp;&amp; luaL_getmetafield(lstate, 2, &quot;__call&quot;) != 0) {</a>
<a name="ln311">      is_function = (lua_type(lstate, -1) == LUA_TFUNCTION);</a>
<a name="ln312">      lua_pop(lstate, 1);</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">    if (!is_function) {</a>
<a name="ln316">      lua_pushliteral(</a>
<a name="ln317">          lstate,</a>
<a name="ln318">          &quot;vim.wait: if passed, condition must be a function&quot;);</a>
<a name="ln319">      return lua_error(lstate);</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  intptr_t interval = 200;</a>
<a name="ln324">  if (lua_top &gt;= 3 &amp;&amp; !lua_isnil(lstate, 3)) {</a>
<a name="ln325">    interval = luaL_checkinteger(lstate, 3);</a>
<a name="ln326">    if (interval &lt; 0) {</a>
<a name="ln327">      return luaL_error(lstate, &quot;interval must be &gt; 0&quot;);</a>
<a name="ln328">    }</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  bool fast_only = false;</a>
<a name="ln332">  if (lua_top &gt;= 4) {</a>
<a name="ln333">    fast_only =  lua_toboolean(lstate, 4);</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  MultiQueue *loop_events = fast_only || in_fast_callback &gt; 0</a>
<a name="ln337">    ? main_loop.fast_events : main_loop.events;</a>
<a name="ln338"> </a>
<a name="ln339">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln340"> </a>
<a name="ln341">  // Start dummy timer.</a>
<a name="ln342">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln343">  tw-&gt;events = loop_events;</a>
<a name="ln344">  tw-&gt;blockable = true;</a>
<a name="ln345">  time_watcher_start(</a>
<a name="ln346">      tw,</a>
<a name="ln347">      dummy_timer_due_cb,</a>
<a name="ln348">      (uint64_t)interval,</a>
<a name="ln349">      (uint64_t)interval);</a>
<a name="ln350"> </a>
<a name="ln351">  int pcall_status = 0;</a>
<a name="ln352">  bool callback_result = false;</a>
<a name="ln353"> </a>
<a name="ln354">  LOOP_PROCESS_EVENTS_UNTIL(</a>
<a name="ln355">      &amp;main_loop,</a>
<a name="ln356">      loop_events,</a>
<a name="ln357">      (int)timeout,</a>
<a name="ln358">      is_function ? nlua_wait_condition(</a>
<a name="ln359">          lstate,</a>
<a name="ln360">          &amp;pcall_status,</a>
<a name="ln361">          &amp;callback_result) : false || got_int);</a>
<a name="ln362"> </a>
<a name="ln363">  // Stop dummy timer</a>
<a name="ln364">  time_watcher_stop(tw);</a>
<a name="ln365">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln366"> </a>
<a name="ln367">  if (pcall_status) {</a>
<a name="ln368">    return lua_error(lstate);</a>
<a name="ln369">  } else if (callback_result) {</a>
<a name="ln370">    lua_pushboolean(lstate, 1);</a>
<a name="ln371">    lua_pushnil(lstate);</a>
<a name="ln372">  } else if (got_int) {</a>
<a name="ln373">    got_int = false;</a>
<a name="ln374">    vgetc();</a>
<a name="ln375">    lua_pushboolean(lstate, 0);</a>
<a name="ln376">    lua_pushinteger(lstate, -2);</a>
<a name="ln377">  } else {</a>
<a name="ln378">    lua_pushboolean(lstate, 0);</a>
<a name="ln379">    lua_pushinteger(lstate, -1);</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  return 2;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">/// Initialize lua interpreter state</a>
<a name="ln386">///</a>
<a name="ln387">/// Called by lua interpreter itself to initialize state.</a>
<a name="ln388">static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln389">{</a>
<a name="ln390">  // print</a>
<a name="ln391">  lua_pushcfunction(lstate, &amp;nlua_print);</a>
<a name="ln392">  lua_setglobal(lstate, &quot;print&quot;);</a>
<a name="ln393"> </a>
<a name="ln394">  // debug.debug</a>
<a name="ln395">  lua_getglobal(lstate, &quot;debug&quot;);</a>
<a name="ln396">  lua_pushcfunction(lstate, &amp;nlua_debug);</a>
<a name="ln397">  lua_setfield(lstate, -2, &quot;debug&quot;);</a>
<a name="ln398">  lua_pop(lstate, 1);</a>
<a name="ln399"> </a>
<a name="ln400">#ifdef WIN32</a>
<a name="ln401">  // os.getenv</a>
<a name="ln402">  lua_getglobal(lstate, &quot;os&quot;);</a>
<a name="ln403">  lua_pushcfunction(lstate, &amp;nlua_getenv);</a>
<a name="ln404">  lua_setfield(lstate, -2, &quot;getenv&quot;);</a>
<a name="ln405">  lua_pop(lstate, 1);</a>
<a name="ln406">#endif</a>
<a name="ln407"> </a>
<a name="ln408">  // vim</a>
<a name="ln409">  lua_newtable(lstate);</a>
<a name="ln410">  // vim.api</a>
<a name="ln411">  nlua_add_api_functions(lstate);</a>
<a name="ln412">  // vim.types, vim.type_idx, vim.val_idx</a>
<a name="ln413">  nlua_init_types(lstate);</a>
<a name="ln414">  // stricmp</a>
<a name="ln415">  lua_pushcfunction(lstate, &amp;nlua_stricmp);</a>
<a name="ln416">  lua_setfield(lstate, -2, &quot;stricmp&quot;);</a>
<a name="ln417">  // str_utfindex</a>
<a name="ln418">  lua_pushcfunction(lstate, &amp;nlua_str_utfindex);</a>
<a name="ln419">  lua_setfield(lstate, -2, &quot;str_utfindex&quot;);</a>
<a name="ln420">  // str_byteindex</a>
<a name="ln421">  lua_pushcfunction(lstate, &amp;nlua_str_byteindex);</a>
<a name="ln422">  lua_setfield(lstate, -2, &quot;str_byteindex&quot;);</a>
<a name="ln423">  // schedule</a>
<a name="ln424">  lua_pushcfunction(lstate, &amp;nlua_schedule);</a>
<a name="ln425">  lua_setfield(lstate, -2, &quot;schedule&quot;);</a>
<a name="ln426">  // in_fast_event</a>
<a name="ln427">  lua_pushcfunction(lstate, &amp;nlua_in_fast_event);</a>
<a name="ln428">  lua_setfield(lstate, -2, &quot;in_fast_event&quot;);</a>
<a name="ln429">  // call</a>
<a name="ln430">  lua_pushcfunction(lstate, &amp;nlua_call);</a>
<a name="ln431">  lua_setfield(lstate, -2, &quot;call&quot;);</a>
<a name="ln432">  // regex</a>
<a name="ln433">  lua_pushcfunction(lstate, &amp;nlua_regex);</a>
<a name="ln434">  lua_setfield(lstate, -2, &quot;regex&quot;);</a>
<a name="ln435">  luaL_newmetatable(lstate, &quot;nvim_regex&quot;);</a>
<a name="ln436">  luaL_register(lstate, NULL, regex_meta);</a>
<a name="ln437">  lua_pushvalue(lstate, -1);  // [meta, meta]</a>
<a name="ln438">  lua_setfield(lstate, -2, &quot;__index&quot;);  // [meta]</a>
<a name="ln439">  lua_pop(lstate, 1);  // don't use metatable now</a>
<a name="ln440"> </a>
<a name="ln441">  // rpcrequest</a>
<a name="ln442">  lua_pushcfunction(lstate, &amp;nlua_rpcrequest);</a>
<a name="ln443">  lua_setfield(lstate, -2, &quot;rpcrequest&quot;);</a>
<a name="ln444"> </a>
<a name="ln445">  // rpcnotify</a>
<a name="ln446">  lua_pushcfunction(lstate, &amp;nlua_rpcnotify);</a>
<a name="ln447">  lua_setfield(lstate, -2, &quot;rpcnotify&quot;);</a>
<a name="ln448"> </a>
<a name="ln449">  // wait</a>
<a name="ln450">  lua_pushcfunction(lstate, &amp;nlua_wait);</a>
<a name="ln451">  lua_setfield(lstate, -2, &quot;wait&quot;);</a>
<a name="ln452"> </a>
<a name="ln453">  // vim.loop</a>
<a name="ln454">  luv_set_loop(lstate, &amp;main_loop.uv);</a>
<a name="ln455">  luv_set_callback(lstate, nlua_luv_cfpcall);</a>
<a name="ln456">  luaopen_luv(lstate);</a>
<a name="ln457">  lua_pushvalue(lstate, -1);</a>
<a name="ln458">  lua_setfield(lstate, -3, &quot;loop&quot;);</a>
<a name="ln459"> </a>
<a name="ln460">  // package.loaded.luv = vim.loop</a>
<a name="ln461">  // otherwise luv will be reinitialized when require'luv'</a>
<a name="ln462">  lua_getglobal(lstate, &quot;package&quot;);</a>
<a name="ln463">  lua_getfield(lstate, -1, &quot;loaded&quot;);</a>
<a name="ln464">  lua_pushvalue(lstate, -3);</a>
<a name="ln465">  lua_setfield(lstate, -2, &quot;luv&quot;);</a>
<a name="ln466">  lua_pop(lstate, 3);</a>
<a name="ln467"> </a>
<a name="ln468">  // vim.NIL</a>
<a name="ln469">  lua_newuserdata(lstate, 0);</a>
<a name="ln470">  lua_createtable(lstate, 0, 0);</a>
<a name="ln471">  lua_pushcfunction(lstate, &amp;nlua_nil_tostring);</a>
<a name="ln472">  lua_setfield(lstate, -2, &quot;__tostring&quot;);</a>
<a name="ln473">  lua_setmetatable(lstate, -2);</a>
<a name="ln474">  nlua_nil_ref = nlua_ref(lstate, -1);</a>
<a name="ln475">  lua_setfield(lstate, -2, &quot;NIL&quot;);</a>
<a name="ln476"> </a>
<a name="ln477">  // vim._empty_dict_mt</a>
<a name="ln478">  lua_createtable(lstate, 0, 0);</a>
<a name="ln479">  lua_pushcfunction(lstate, &amp;nlua_empty_dict_tostring);</a>
<a name="ln480">  lua_setfield(lstate, -2, &quot;__tostring&quot;);</a>
<a name="ln481">  nlua_empty_dict_ref = nlua_ref(lstate, -1);</a>
<a name="ln482">  lua_setfield(lstate, -2, &quot;_empty_dict_mt&quot;);</a>
<a name="ln483"> </a>
<a name="ln484">  // internal vim._treesitter... API</a>
<a name="ln485">  nlua_add_treesitter(lstate);</a>
<a name="ln486"> </a>
<a name="ln487">  lua_setglobal(lstate, &quot;vim&quot;);</a>
<a name="ln488"> </a>
<a name="ln489">  {</a>
<a name="ln490">    const char *code = (char *)&amp;shared_module[0];</a>
<a name="ln491">    if (luaL_loadbuffer(lstate, code, strlen(code), &quot;@vim/shared.lua&quot;)</a>
<a name="ln492">        || lua_pcall(lstate, 0, 0, 0)) {</a>
<a name="ln493">      nlua_error(lstate, _(&quot;E5106: Error while creating shared module: %.*s&quot;));</a>
<a name="ln494">      return 1;</a>
<a name="ln495">    }</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  {</a>
<a name="ln499">    lua_getglobal(lstate, &quot;package&quot;);  // [package]</a>
<a name="ln500">    lua_getfield(lstate, -1, &quot;loaded&quot;);  // [package, loaded]</a>
<a name="ln501"> </a>
<a name="ln502">    const char *code = (char *)&amp;inspect_module[0];</a>
<a name="ln503">    if (luaL_loadbuffer(lstate, code, strlen(code), &quot;@vim/inspect.lua&quot;)</a>
<a name="ln504">        || lua_pcall(lstate, 0, 1, 0)) {</a>
<a name="ln505">      nlua_error(lstate, _(&quot;E5106: Error while creating inspect module: %.*s&quot;));</a>
<a name="ln506">      return 1;</a>
<a name="ln507">    }</a>
<a name="ln508">    // [package, loaded, inspect]</a>
<a name="ln509"> </a>
<a name="ln510">    lua_setfield(lstate, -2, &quot;vim.inspect&quot;);  // [package, loaded]</a>
<a name="ln511">    lua_pop(lstate, 2);  // []</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  {</a>
<a name="ln515">    const char *code = (char *)&amp;vim_module[0];</a>
<a name="ln516">    if (luaL_loadbuffer(lstate, code, strlen(code), &quot;@vim.lua&quot;)</a>
<a name="ln517">        || lua_pcall(lstate, 0, 0, 0)) {</a>
<a name="ln518">      nlua_error(lstate, _(&quot;E5106: Error while creating vim module: %.*s&quot;));</a>
<a name="ln519">      return 1;</a>
<a name="ln520">    }</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  return 0;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">/// Initialize lua interpreter</a>
<a name="ln527">///</a>
<a name="ln528">/// Crashes Nvim if initialization fails. Should be called once per lua</a>
<a name="ln529">/// interpreter instance.</a>
<a name="ln530">///</a>
<a name="ln531">/// @return New lua interpreter instance.</a>
<a name="ln532">static lua_State *nlua_init(void)</a>
<a name="ln533">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln534">{</a>
<a name="ln535">  lua_State *lstate = luaL_newstate();</a>
<a name="ln536">  if (lstate == NULL) {</a>
<a name="ln537">    EMSG(_(&quot;E970: Failed to initialize lua interpreter&quot;));</a>
<a name="ln538">    preserve_exit();</a>
<a name="ln539">  }</a>
<a name="ln540">  luaL_openlibs(lstate);</a>
<a name="ln541">  nlua_state_init(lstate);</a>
<a name="ln542">  return lstate;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/// Enter lua interpreter</a>
<a name="ln546">///</a>
<a name="ln547">/// Calls nlua_init() if needed. Is responsible for pre-lua call initalization</a>
<a name="ln548">/// like updating `package.[c]path` with directories derived from &amp;runtimepath.</a>
<a name="ln549">///</a>
<a name="ln550">/// @return Interpreter instance to use. Will either be initialized now or</a>
<a name="ln551">///         taken from previous initialization.</a>
<a name="ln552">static lua_State *nlua_enter(void)</a>
<a name="ln553">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln554">{</a>
<a name="ln555">  static lua_State *global_lstate = NULL;</a>
<a name="ln556">  if (global_lstate == NULL) {</a>
<a name="ln557">    global_lstate = nlua_init();</a>
<a name="ln558">  }</a>
<a name="ln559">  lua_State *const lstate = global_lstate;</a>
<a name="ln560">  // Last used p_rtp value. Must not be dereferenced because value pointed to</a>
<a name="ln561">  // may already be freed. Used to check whether &amp;runtimepath option value</a>
<a name="ln562">  // changed.</a>
<a name="ln563">  static const void *last_p_rtp = NULL;</a>
<a name="ln564">  if (last_p_rtp != (const void *)p_rtp) {</a>
<a name="ln565">    // stack: (empty)</a>
<a name="ln566">    lua_getglobal(lstate, &quot;vim&quot;);</a>
<a name="ln567">    // stack: vim</a>
<a name="ln568">    lua_pop(lstate, 1);</a>
<a name="ln569">    // stack: (empty)</a>
<a name="ln570">    last_p_rtp = (const void *)p_rtp;</a>
<a name="ln571">  }</a>
<a name="ln572">  return lstate;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static void nlua_print_event(void **argv)</a>
<a name="ln576">{</a>
<a name="ln577">  char *str = argv[0];</a>
<a name="ln578">  const size_t len = (size_t)(intptr_t)argv[1]-1;  // exclude final NUL</a>
<a name="ln579"> </a>
<a name="ln580">  for (size_t i = 0; i &lt; len;) {</a>
<a name="ln581">    const size_t start = i;</a>
<a name="ln582">    while (i &lt; len) {</a>
<a name="ln583">      switch (str[i]) {</a>
<a name="ln584">        case NUL: {</a>
<a name="ln585">          str[i] = NL;</a>
<a name="ln586">          i++;</a>
<a name="ln587">          continue;</a>
<a name="ln588">        }</a>
<a name="ln589">        case NL: {</a>
<a name="ln590">          // TODO(bfredl): use proper multiline msg? Probably should implement</a>
<a name="ln591">          // print() in lua in terms of nvim_message(), when it is available.</a>
<a name="ln592">          str[i] = NUL;</a>
<a name="ln593">          i++;</a>
<a name="ln594">          break;</a>
<a name="ln595">        }</a>
<a name="ln596">        default: {</a>
<a name="ln597">          i++;</a>
<a name="ln598">          continue;</a>
<a name="ln599">        }</a>
<a name="ln600">      }</a>
<a name="ln601">      break;</a>
<a name="ln602">    }</a>
<a name="ln603">    msg((char_u *)str + start);</a>
<a name="ln604">  }</a>
<a name="ln605">  if (len &amp;&amp; str[len - 1] == NUL) {  // Last was newline</a>
<a name="ln606">    msg((char_u *)&quot;&quot;);</a>
<a name="ln607">  }</a>
<a name="ln608">  xfree(str);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/// Print as a Vim message</a>
<a name="ln612">///</a>
<a name="ln613">/// @param  lstate  Lua interpreter state.</a>
<a name="ln614">static int nlua_print(lua_State *const lstate)</a>
<a name="ln615">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln616">{</a>
<a name="ln617">#define PRINT_ERROR(msg) \</a>
<a name="ln618">  do { \</a>
<a name="ln619">    errmsg = msg; \</a>
<a name="ln620">    errmsg_len = sizeof(msg) - 1; \</a>
<a name="ln621">    goto nlua_print_error; \</a>
<a name="ln622">  } while (0)</a>
<a name="ln623">  const int nargs = lua_gettop(lstate);</a>
<a name="ln624">  lua_getglobal(lstate, &quot;tostring&quot;);</a>
<a name="ln625">  const char *errmsg = NULL;</a>
<a name="ln626">  size_t errmsg_len = 0;</a>
<a name="ln627">  garray_T msg_ga;</a>
<a name="ln628">  ga_init(&amp;msg_ga, 1, 80);</a>
<a name="ln629">  int curargidx = 1;</a>
<a name="ln630">  for (; curargidx &lt;= nargs; curargidx++) {</a>
<a name="ln631">    lua_pushvalue(lstate, -1);  // tostring</a>
<a name="ln632">    lua_pushvalue(lstate, curargidx);  // arg</a>
<a name="ln633">    if (lua_pcall(lstate, 1, 1, 0)) {</a>
<a name="ln634">      errmsg = lua_tolstring(lstate, -1, &amp;errmsg_len);</a>
<a name="ln635">      goto nlua_print_error;</a>
<a name="ln636">    }</a>
<a name="ln637">    size_t len;</a>
<a name="ln638">    const char *const s = lua_tolstring(lstate, -1, &amp;len);</a>
<a name="ln639">    if (s == NULL) {</a>
<a name="ln640">      PRINT_ERROR(</a>
<a name="ln641">          &quot;&lt;Unknown error: lua_tolstring returned NULL for tostring result&gt;&quot;);</a>
<a name="ln642">    }</a>
<a name="ln643">    ga_concat_len(&amp;msg_ga, s, len);</a>
<a name="ln644">    if (curargidx &lt; nargs) {</a>
<a name="ln645">      ga_append(&amp;msg_ga, ' ');</a>
<a name="ln646">    }</a>
<a name="ln647">    lua_pop(lstate, 1);</a>
<a name="ln648">  }</a>
<a name="ln649">#undef PRINT_ERROR</a>
<a name="ln650">  ga_append(&amp;msg_ga, NUL);</a>
<a name="ln651"> </a>
<a name="ln652">  if (in_fast_callback) {</a>
<a name="ln653">    multiqueue_put(main_loop.events, nlua_print_event,</a>
<a name="ln654">                   2, msg_ga.ga_data, msg_ga.ga_len);</a>
<a name="ln655">  } else {</a>
<a name="ln656">    nlua_print_event((void *[]){ msg_ga.ga_data,</a>
<a name="ln657">                                 (void *)(intptr_t)msg_ga.ga_len });</a>
<a name="ln658">  }</a>
<a name="ln659">  return 0;</a>
<a name="ln660"> </a>
<a name="ln661">nlua_print_error:</a>
<a name="ln662">  ga_clear(&amp;msg_ga);</a>
<a name="ln663">  const char *fmt = _(&quot;E5114: Error while converting print argument #%i: %.*s&quot;);</a>
<a name="ln664">  size_t len = (size_t)vim_snprintf((char *)IObuff, IOSIZE, fmt, curargidx,</a>
<a name="ln665">                                    (int)errmsg_len, errmsg);</a>
<a name="ln666">  lua_pushlstring(lstate, (char *)IObuff, len);</a>
<a name="ln667">  return lua_error(lstate);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">/// debug.debug: interaction with user while debugging.</a>
<a name="ln671">///</a>
<a name="ln672">/// @param  lstate  Lua interpreter state.</a>
<a name="ln673">int nlua_debug(lua_State *lstate)</a>
<a name="ln674">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln675">{</a>
<a name="ln676">  const typval_T input_args[] = {</a>
<a name="ln677">    {</a>
<a name="ln678">      .v_lock = VAR_FIXED,</a>
<a name="ln679">      .v_type = VAR_STRING,</a>
<a name="ln680">      .vval.v_string = (char_u *)&quot;lua_debug&gt; &quot;,</a>
<a name="ln681">    },</a>
<a name="ln682">    {</a>
<a name="ln683">      .v_type = VAR_UNKNOWN,</a>
<a name="ln684">    },</a>
<a name="ln685">  };</a>
<a name="ln686">  for (;;) {</a>
<a name="ln687">    lua_settop(lstate, 0);</a>
<a name="ln688">    typval_T input;</a>
<a name="ln689">    get_user_input(input_args, &amp;input, false, false);</a>
<a name="ln690">    msg_putchar('\n');  // Avoid outputting on input line.</a>
<a name="ln691">    if (input.v_type != VAR_STRING</a>
<a name="ln692">        || input.vval.v_string == NULL</a>
<a name="ln693">        || *input.vval.v_string == NUL</a>
<a name="ln694">        || STRCMP(input.vval.v_string, &quot;cont&quot;) == 0) {</a>
<a name="ln695">      tv_clear(&amp;input);</a>
<a name="ln696">      return 0;</a>
<a name="ln697">    }</a>
<a name="ln698">    if (luaL_loadbuffer(lstate, (const char *)input.vval.v_string,</a>
<a name="ln699">                        STRLEN(input.vval.v_string), &quot;=(debug command)&quot;)) {</a>
<a name="ln700">      nlua_error(lstate, _(&quot;E5115: Error while loading debug string: %.*s&quot;));</a>
<a name="ln701">    } else if (lua_pcall(lstate, 0, 0, 0)) {</a>
<a name="ln702">      nlua_error(lstate, _(&quot;E5116: Error while calling debug string: %.*s&quot;));</a>
<a name="ln703">    }</a>
<a name="ln704">    tv_clear(&amp;input);</a>
<a name="ln705">  }</a>
<a name="ln706">  return 0;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">int nlua_in_fast_event(lua_State *lstate)</a>
<a name="ln710">{</a>
<a name="ln711">  lua_pushboolean(lstate, in_fast_callback &gt; 0);</a>
<a name="ln712">  return 1;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">int nlua_call(lua_State *lstate)</a>
<a name="ln716">{</a>
<a name="ln717">  Error err = ERROR_INIT;</a>
<a name="ln718">  size_t name_len;</a>
<a name="ln719">  const char_u *name = (const char_u *)luaL_checklstring(lstate, 1, &amp;name_len);</a>
<a name="ln720">  if (!nlua_is_deferred_safe(lstate)) {</a>
<a name="ln721">    return luaL_error(lstate, e_luv_api_disabled, &quot;vimL function&quot;);</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  int nargs = lua_gettop(lstate)-1;</a>
<a name="ln725">  if (nargs &gt; MAX_FUNC_ARGS) {</a>
<a name="ln726">    return luaL_error(lstate, &quot;Function called with too many arguments&quot;);</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  typval_T vim_args[MAX_FUNC_ARGS + 1];</a>
<a name="ln730">  int i = 0;  // also used for freeing the variables</a>
<a name="ln731">  for (; i &lt; nargs; i++) {</a>
<a name="ln732">    lua_pushvalue(lstate, (int)i+2);</a>
<a name="ln733">    if (!nlua_pop_typval(lstate, &amp;vim_args[i])) {</a>
<a name="ln734">      api_set_error(&amp;err, kErrorTypeException,</a>
<a name="ln735">                    &quot;error converting argument %d&quot;, i+1);</a>
<a name="ln736">      goto free_vim_args;</a>
<a name="ln737">    }</a>
<a name="ln738">  }</a>
<a name="ln739"> </a>
<a name="ln740">  TRY_WRAP({</a>
<a name="ln741">    // TODO(bfredl): this should be simplified in error handling refactor</a>
<a name="ln742">    force_abort = false;</a>
<a name="ln743">    suppress_errthrow = false;</a>
<a name="ln744">    current_exception = NULL;</a>
<a name="ln745">    did_emsg = false;</a>
<a name="ln746"> </a>
<a name="ln747">    try_start();</a>
<a name="ln748">    typval_T rettv;</a>
<a name="ln749">    int dummy;</a>
<a name="ln750">    // call_func() retval is deceptive, ignore it.  Instead we set `msg_list`</a>
<a name="ln751">    // (TRY_WRAP) to capture abort-causing non-exception errors.</a>
<a name="ln752">    (void)call_func(name, (int)name_len, &amp;rettv, nargs,</a>
<a name="ln753">                    vim_args, NULL,</a>
<a name="ln754">                    curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln755">                    &amp;dummy, true, NULL, NULL);</a>
<a name="ln756">    if (!try_end(&amp;err)) {</a>
<a name="ln757">      nlua_push_typval(lstate, &amp;rettv, false);</a>
<a name="ln758">    }</a>
<a name="ln759">    tv_clear(&amp;rettv);</a>
<a name="ln760">  });</a>
<a name="ln761"> </a>
<a name="ln762">free_vim_args:</a>
<a name="ln763">  while (i &gt; 0) {</a>
<a name="ln764">    tv_clear(&amp;vim_args[--i]);</a>
<a name="ln765">  }</a>
<a name="ln766">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln767">    lua_pushstring(lstate, err.msg);</a>
<a name="ln768">    api_clear_error(&amp;err);</a>
<a name="ln769">    return lua_error(lstate);</a>
<a name="ln770">  }</a>
<a name="ln771">  return 1;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">static int nlua_rpcrequest(lua_State *lstate)</a>
<a name="ln775">{</a>
<a name="ln776">  if (!nlua_is_deferred_safe(lstate)) {</a>
<a name="ln777">    return luaL_error(lstate, e_luv_api_disabled, &quot;rpcrequest&quot;);</a>
<a name="ln778">  }</a>
<a name="ln779">  return nlua_rpc(lstate, true);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">static int nlua_rpcnotify(lua_State *lstate)</a>
<a name="ln783">{</a>
<a name="ln784">  return nlua_rpc(lstate, false);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static int nlua_rpc(lua_State *lstate, bool request)</a>
<a name="ln788">{</a>
<a name="ln789">  size_t name_len;</a>
<a name="ln790">  uint64_t chan_id = (uint64_t)luaL_checkinteger(lstate, 1);</a>
<a name="ln791">  const char *name = luaL_checklstring(lstate, 2, &amp;name_len);</a>
<a name="ln792">  int nargs = lua_gettop(lstate)-2;</a>
<a name="ln793">  Error err = ERROR_INIT;</a>
<a name="ln794">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln795"> </a>
<a name="ln796">  for (int i = 0; i &lt; nargs; i++) {</a>
<a name="ln797">    lua_pushvalue(lstate, (int)i+3);</a>
<a name="ln798">    ADD(args, nlua_pop_Object(lstate, false, &amp;err));</a>
<a name="ln799">    if (ERROR_SET(&amp;err)) {</a>
<a name="ln800">      api_free_array(args);</a>
<a name="ln801">      goto check_err;</a>
<a name="ln802">    }</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  if (request) {</a>
<a name="ln806">    Object result = rpc_send_call(chan_id, name, args, &amp;err);</a>
<a name="ln807">    if (!ERROR_SET(&amp;err)) {</a>
<a name="ln808">      nlua_push_Object(lstate, result, false);</a>
<a name="ln809">      api_free_object(result);</a>
<a name="ln810">    }</a>
<a name="ln811">  } else {</a>
<a name="ln812">    if (!rpc_send_event(chan_id, name, args)) {</a>
<a name="ln813">      api_set_error(&amp;err, kErrorTypeValidation,</a>
<a name="ln814">                    &quot;Invalid channel: %&quot;PRIu64, chan_id);</a>
<a name="ln815">    }</a>
<a name="ln816">  }</a>
<a name="ln817"> </a>
<a name="ln818">check_err:</a>
<a name="ln819">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln820">    lua_pushstring(lstate, err.msg);</a>
<a name="ln821">    api_clear_error(&amp;err);</a>
<a name="ln822">    return lua_error(lstate);</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  return request ? 1 : 0;</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">static int nlua_nil_tostring(lua_State *lstate)</a>
<a name="ln829">{</a>
<a name="ln830">  lua_pushstring(lstate, &quot;vim.NIL&quot;);</a>
<a name="ln831">  return 1;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">static int nlua_empty_dict_tostring(lua_State *lstate)</a>
<a name="ln835">{</a>
<a name="ln836">  lua_pushstring(lstate, &quot;vim.empty_dict()&quot;);</a>
<a name="ln837">  return 1;</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840"> </a>
<a name="ln841">#ifdef WIN32</a>
<a name="ln842">/// os.getenv: override os.getenv to maintain coherency. #9681</a>
<a name="ln843">///</a>
<a name="ln844">/// uv_os_setenv uses SetEnvironmentVariableW which does not update _environ.</a>
<a name="ln845">///</a>
<a name="ln846">/// @param  lstate  Lua interpreter state.</a>
<a name="ln847">static int nlua_getenv(lua_State *lstate)</a>
<a name="ln848">{</a>
<a name="ln849">  lua_pushstring(lstate, os_getenv(luaL_checkstring(lstate, 1)));</a>
<a name="ln850">  return 1;</a>
<a name="ln851">}</a>
<a name="ln852">#endif</a>
<a name="ln853"> </a>
<a name="ln854">/// add the value to the registry</a>
<a name="ln855">LuaRef nlua_ref(lua_State *lstate, int index)</a>
<a name="ln856">{</a>
<a name="ln857">  lua_pushvalue(lstate, index);</a>
<a name="ln858">  return luaL_ref(lstate, LUA_REGISTRYINDEX);</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">/// remove the value from the registry</a>
<a name="ln862">void nlua_unref(lua_State *lstate, LuaRef ref)</a>
<a name="ln863">{</a>
<a name="ln864">  if (ref &gt; 0) {</a>
<a name="ln865">    luaL_unref(lstate, LUA_REGISTRYINDEX, ref);</a>
<a name="ln866">  }</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">void api_free_luaref(LuaRef ref)</a>
<a name="ln870">{</a>
<a name="ln871">  lua_State *const lstate = nlua_enter();</a>
<a name="ln872">  nlua_unref(lstate, ref);</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">/// push a value referenced in the registry</a>
<a name="ln876">void nlua_pushref(lua_State *lstate, LuaRef ref)</a>
<a name="ln877">{</a>
<a name="ln878">  lua_rawgeti(lstate, LUA_REGISTRYINDEX, ref);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">/// Gets a new reference to an object stored at original_ref</a>
<a name="ln882">///</a>
<a name="ln883">/// NOTE: It does not copy the value, it creates a new ref to the lua object.</a>
<a name="ln884">///       Leaves the stack unchanged.</a>
<a name="ln885">LuaRef nlua_newref(lua_State *lstate, LuaRef original_ref)</a>
<a name="ln886">{</a>
<a name="ln887">  nlua_pushref(lstate, original_ref);</a>
<a name="ln888">  LuaRef new_ref = nlua_ref(lstate, -1);</a>
<a name="ln889">  lua_pop(lstate, 1);</a>
<a name="ln890"> </a>
<a name="ln891">  return new_ref;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">LuaRef api_new_luaref(LuaRef original_ref)</a>
<a name="ln895">{</a>
<a name="ln896">  if (original_ref == LUA_NOREF) {</a>
<a name="ln897">    return LUA_NOREF;</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  lua_State *const lstate = nlua_enter();</a>
<a name="ln901">  return nlua_newref(lstate, original_ref);</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">/// Evaluate lua string</a>
<a name="ln906">///</a>
<a name="ln907">/// Used for luaeval().</a>
<a name="ln908">///</a>
<a name="ln909">/// @param[in]  str  String to execute.</a>
<a name="ln910">/// @param[in]  arg  Second argument to `luaeval()`.</a>
<a name="ln911">/// @param[out]  ret_tv  Location where result will be saved.</a>
<a name="ln912">///</a>
<a name="ln913">/// @return Result of the execution.</a>
<a name="ln914">void nlua_typval_eval(const String str, typval_T *const arg,</a>
<a name="ln915">                      typval_T *const ret_tv)</a>
<a name="ln916">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln917">{</a>
<a name="ln918">#define EVALHEADER &quot;local _A=select(1,...) return (&quot;</a>
<a name="ln919">  const size_t lcmd_len = sizeof(EVALHEADER) - 1 + str.size + 1;</a>
<a name="ln920">  char *lcmd;</a>
<a name="ln921">  if (lcmd_len &lt; IOSIZE) {</a>
<a name="ln922">    lcmd = (char *)IObuff;</a>
<a name="ln923">  } else {</a>
<a name="ln924">    lcmd = xmalloc(lcmd_len);</a>
<a name="ln925">  }</a>
<a name="ln926">  memcpy(lcmd, EVALHEADER, sizeof(EVALHEADER) - 1);</a>
<a name="ln927">  memcpy(lcmd + sizeof(EVALHEADER) - 1, str.data, str.size);</a>
<a name="ln928">  lcmd[lcmd_len - 1] = ')';</a>
<a name="ln929">#undef EVALHEADER</a>
<a name="ln930">  typval_exec_lua(lcmd, lcmd_len, &quot;luaeval()&quot;, arg, 1, true, ret_tv);</a>
<a name="ln931"> </a>
<a name="ln932">  if (lcmd != (char *)IObuff) {</a>
<a name="ln933">    xfree(lcmd);</a>
<a name="ln934">  }</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">void nlua_typval_call(const char *str, size_t len, typval_T *const args,</a>
<a name="ln938">                      int argcount, typval_T *ret_tv)</a>
<a name="ln939">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln940">{</a>
<a name="ln941">#define CALLHEADER &quot;return &quot;</a>
<a name="ln942">#define CALLSUFFIX &quot;(...)&quot;</a>
<a name="ln943">  const size_t lcmd_len = sizeof(CALLHEADER) - 1 + len + sizeof(CALLSUFFIX) - 1;</a>
<a name="ln944">  char *lcmd;</a>
<a name="ln945">  if (lcmd_len &lt; IOSIZE) {</a>
<a name="ln946">    lcmd = (char *)IObuff;</a>
<a name="ln947">  } else {</a>
<a name="ln948">    lcmd = xmalloc(lcmd_len);</a>
<a name="ln949">  }</a>
<a name="ln950">  memcpy(lcmd, CALLHEADER, sizeof(CALLHEADER) - 1);</a>
<a name="ln951">  memcpy(lcmd + sizeof(CALLHEADER) - 1, str, len);</a>
<a name="ln952">  memcpy(lcmd + sizeof(CALLHEADER) - 1 + len, CALLSUFFIX,</a>
<a name="ln953">         sizeof(CALLSUFFIX) - 1);</a>
<a name="ln954">#undef CALLHEADER</a>
<a name="ln955">#undef CALLSUFFIX</a>
<a name="ln956"> </a>
<a name="ln957">  typval_exec_lua(lcmd, lcmd_len, &quot;v:lua&quot;, args, argcount, false, ret_tv);</a>
<a name="ln958"> </a>
<a name="ln959">  if (lcmd != (char *)IObuff) {</a>
<a name="ln960">    xfree(lcmd);</a>
<a name="ln961">  }</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">static void typval_exec_lua(const char *lcmd, size_t lcmd_len, const char *name,</a>
<a name="ln965">                            typval_T *const args, int argcount, bool special,</a>
<a name="ln966">                            typval_T *ret_tv)</a>
<a name="ln967">{</a>
<a name="ln968">  if (check_restricted() || check_secure()) {</a>
<a name="ln969">    if (ret_tv) {</a>
<a name="ln970">      ret_tv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln971">      ret_tv-&gt;vval.v_number = 0;</a>
<a name="ln972">    }</a>
<a name="ln973">    return;</a>
<a name="ln974">  }</a>
<a name="ln975"> </a>
<a name="ln976">  lua_State *const lstate = nlua_enter();</a>
<a name="ln977">  if (luaL_loadbuffer(lstate, lcmd, lcmd_len, name)) {</a>
<a name="ln978">    nlua_error(lstate, _(&quot;E5107: Error loading lua %.*s&quot;));</a>
<a name="ln979">    return;</a>
<a name="ln980">  }</a>
<a name="ln981"> </a>
<a name="ln982">  PUSH_ALL_TYPVALS(lstate, args, argcount, special);</a>
<a name="ln983"> </a>
<a name="ln984">  if (lua_pcall(lstate, argcount, ret_tv ? 1 : 0, 0)) {</a>
<a name="ln985">    nlua_error(lstate, _(&quot;E5108: Error executing lua %.*s&quot;));</a>
<a name="ln986">    return;</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">  if (ret_tv) {</a>
<a name="ln990">    nlua_pop_typval(lstate, ret_tv);</a>
<a name="ln991">  }</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">/// Call a LuaCallable given some typvals</a>
<a name="ln995">///</a>
<a name="ln996">/// Used to call any lua callable passed from Lua into VimL</a>
<a name="ln997">///</a>
<a name="ln998">/// @param[in]  lstate Lua State</a>
<a name="ln999">/// @param[in]  lua_cb Lua Callable</a>
<a name="ln1000">/// @param[in]  argcount Count of typval arguments</a>
<a name="ln1001">/// @param[in]  argvars Typval Arguments</a>
<a name="ln1002">/// @param[out] rettv The return value from the called function.</a>
<a name="ln1003">int typval_exec_lua_callable(</a>
<a name="ln1004">    lua_State *lstate,</a>
<a name="ln1005">    LuaCallable lua_cb,</a>
<a name="ln1006">    int argcount,</a>
<a name="ln1007">    typval_T *argvars,</a>
<a name="ln1008">    typval_T *rettv</a>
<a name="ln1009">)</a>
<a name="ln1010">{</a>
<a name="ln1011">  int offset = 0;</a>
<a name="ln1012">  LuaRef cb = lua_cb.func_ref;</a>
<a name="ln1013"> </a>
<a name="ln1014">  if (cb == LUA_NOREF) {</a>
<a name="ln1015">    // This shouldn't happen.</a>
<a name="ln1016">    luaL_error(lstate, &quot;Invalid function passed to VimL&quot;);</a>
<a name="ln1017">    return ERROR_OTHER;</a>
<a name="ln1018">  }</a>
<a name="ln1019"> </a>
<a name="ln1020">  nlua_pushref(lstate, cb);</a>
<a name="ln1021"> </a>
<a name="ln1022">  if (lua_cb.table_ref != LUA_NOREF) {</a>
<a name="ln1023">    offset += 1;</a>
<a name="ln1024">    nlua_pushref(lstate, lua_cb.table_ref);</a>
<a name="ln1025">  }</a>
<a name="ln1026"> </a>
<a name="ln1027">  PUSH_ALL_TYPVALS(lstate, argvars, argcount, false);</a>
<a name="ln1028"> </a>
<a name="ln1029">  if (lua_pcall(lstate, argcount + offset, 1, 0)) {</a>
<a name="ln1030">    nlua_print(lstate);</a>
<a name="ln1031">    return ERROR_OTHER;</a>
<a name="ln1032">  }</a>
<a name="ln1033"> </a>
<a name="ln1034">  nlua_pop_typval(lstate, rettv);</a>
<a name="ln1035"> </a>
<a name="ln1036">  return ERROR_NONE;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">/// Execute Lua string</a>
<a name="ln1040">///</a>
<a name="ln1041">/// Used for nvim_exec_lua() and internally to execute a lua string.</a>
<a name="ln1042">///</a>
<a name="ln1043">/// @param[in]  str  String to execute.</a>
<a name="ln1044">/// @param[in]  args array of ... args</a>
<a name="ln1045">/// @param[out]  err  Location where error will be saved.</a>
<a name="ln1046">///</a>
<a name="ln1047">/// @return Return value of the execution.</a>
<a name="ln1048">Object nlua_exec(const String str, const Array args, Error *err)</a>
<a name="ln1049">{</a>
<a name="ln1050">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1051"> </a>
<a name="ln1052">  if (luaL_loadbuffer(lstate, str.data, str.size, &quot;&lt;nvim&gt;&quot;)) {</a>
<a name="ln1053">    size_t len;</a>
<a name="ln1054">    const char *errstr = lua_tolstring(lstate, -1, &amp;len);</a>
<a name="ln1055">    api_set_error(err, kErrorTypeValidation,</a>
<a name="ln1056">                  &quot;Error loading lua: %.*s&quot;, (int)len, errstr);</a>
<a name="ln1057">    return NIL;</a>
<a name="ln1058">  }</a>
<a name="ln1059"> </a>
<a name="ln1060">  for (size_t i = 0; i &lt; args.size; i++) {</a>
<a name="ln1061">    nlua_push_Object(lstate, args.items[i], false);</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  if (lua_pcall(lstate, (int)args.size, 1, 0)) {</a>
<a name="ln1065">    size_t len;</a>
<a name="ln1066">    const char *errstr = lua_tolstring(lstate, -1, &amp;len);</a>
<a name="ln1067">    api_set_error(err, kErrorTypeException,</a>
<a name="ln1068">                  &quot;Error executing lua: %.*s&quot;, (int)len, errstr);</a>
<a name="ln1069">    return NIL;</a>
<a name="ln1070">  }</a>
<a name="ln1071"> </a>
<a name="ln1072">  return nlua_pop_Object(lstate, false, err);</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">/// call a LuaRef as a function (or table with __call metamethod)</a>
<a name="ln1076">///</a>
<a name="ln1077">/// @param ref     the reference to call (not consumed)</a>
<a name="ln1078">/// @param name    if non-NULL, sent to callback as first arg</a>
<a name="ln1079">///                if NULL, only args are used</a>
<a name="ln1080">/// @param retval  if true, convert return value to Object</a>
<a name="ln1081">///                if false, discard return value</a>
<a name="ln1082">/// @param err     Error details, if any (if NULL, errors are echoed)</a>
<a name="ln1083">/// @return        Return value of function, if retval was set. Otherwise NIL.</a>
<a name="ln1084">Object nlua_call_ref(LuaRef ref, const char *name, Array args,</a>
<a name="ln1085">                     bool retval, Error *err)</a>
<a name="ln1086">{</a>
<a name="ln1087">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1088">  nlua_pushref(lstate, ref);</a>
<a name="ln1089">  int nargs = (int)args.size;</a>
<a name="ln1090">  if (name != NULL) {</a>
<a name="ln1091">    lua_pushstring(lstate, name);</a>
<a name="ln1092">    nargs++;</a>
<a name="ln1093">  }</a>
<a name="ln1094">  for (size_t i = 0; i &lt; args.size; i++) {</a>
<a name="ln1095">    nlua_push_Object(lstate, args.items[i], false);</a>
<a name="ln1096">  }</a>
<a name="ln1097"> </a>
<a name="ln1098">  if (lua_pcall(lstate, nargs, retval ? 1 : 0, 0)) {</a>
<a name="ln1099">    // if err is passed, the caller will deal with the error.</a>
<a name="ln1100">    if (err) {</a>
<a name="ln1101">      size_t len;</a>
<a name="ln1102">      const char *errstr = lua_tolstring(lstate, -1, &amp;len);</a>
<a name="ln1103">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1104">                    &quot;Error executing lua: %.*s&quot;, (int)len, errstr);</a>
<a name="ln1105">    } else {</a>
<a name="ln1106">      nlua_error(lstate, _(&quot;Error executing lua callback: %.*s&quot;));</a>
<a name="ln1107">    }</a>
<a name="ln1108">    return NIL;</a>
<a name="ln1109">  }</a>
<a name="ln1110"> </a>
<a name="ln1111">  if (retval) {</a>
<a name="ln1112">    Error dummy = ERROR_INIT;</a>
<a name="ln1113">    if (err == NULL) {</a>
<a name="ln1114">      err = &amp;dummy;</a>
<a name="ln1115">    }</a>
<a name="ln1116">    return nlua_pop_Object(lstate, false, err);</a>
<a name="ln1117">  } else {</a>
<a name="ln1118">    return NIL;</a>
<a name="ln1119">  }</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/// check if the current execution context is safe for calling deferred API</a>
<a name="ln1123">/// methods. Luv callbacks are unsafe as they are called inside the uv loop.</a>
<a name="ln1124">bool nlua_is_deferred_safe(lua_State *lstate)</a>
<a name="ln1125">{</a>
<a name="ln1126">  return in_fast_callback == 0;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">/// Run lua string</a>
<a name="ln1130">///</a>
<a name="ln1131">/// Used for :lua.</a>
<a name="ln1132">///</a>
<a name="ln1133">/// @param  eap  VimL command being run.</a>
<a name="ln1134">void ex_lua(exarg_T *const eap)</a>
<a name="ln1135">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1136">{</a>
<a name="ln1137">  size_t len;</a>
<a name="ln1138">  char *const code = script_get(eap, &amp;len);</a>
<a name="ln1139">  if (eap-&gt;skip) {</a>
<a name="ln1140">    xfree(code);</a>
<a name="ln1141">    return;</a>
<a name="ln1142">  }</a>
<a name="ln1143">  typval_exec_lua(code, len, &quot;:lua&quot;, NULL, 0, false, NULL);</a>
<a name="ln1144"> </a>
<a name="ln1145">  xfree(code);</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">/// Run lua string for each line in range</a>
<a name="ln1149">///</a>
<a name="ln1150">/// Used for :luado.</a>
<a name="ln1151">///</a>
<a name="ln1152">/// @param  eap  VimL command being run.</a>
<a name="ln1153">void ex_luado(exarg_T *const eap)</a>
<a name="ln1154">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1155">{</a>
<a name="ln1156">  if (u_save(eap-&gt;line1 - 1, eap-&gt;line2 + 1) == FAIL) {</a>
<a name="ln1157">    EMSG(_(&quot;cannot save undo information&quot;));</a>
<a name="ln1158">    return;</a>
<a name="ln1159">  }</a>
<a name="ln1160">  const char *const cmd = (const char *)eap-&gt;arg;</a>
<a name="ln1161">  const size_t cmd_len = strlen(cmd);</a>
<a name="ln1162"> </a>
<a name="ln1163">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1164"> </a>
<a name="ln1165">#define DOSTART &quot;return function(line, linenr) &quot;</a>
<a name="ln1166">#define DOEND &quot; end&quot;</a>
<a name="ln1167">  const size_t lcmd_len = (cmd_len</a>
<a name="ln1168">                           + (sizeof(DOSTART) - 1)</a>
<a name="ln1169">                           + (sizeof(DOEND) - 1));</a>
<a name="ln1170">  char *lcmd;</a>
<a name="ln1171">  if (lcmd_len &lt; IOSIZE) {</a>
<a name="ln1172">    lcmd = (char *)IObuff;</a>
<a name="ln1173">  } else {</a>
<a name="ln1174">    lcmd = xmalloc(lcmd_len + 1);</a>
<a name="ln1175">  }</a>
<a name="ln1176">  memcpy(lcmd, DOSTART, sizeof(DOSTART) - 1);</a>
<a name="ln1177">  memcpy(lcmd + sizeof(DOSTART) - 1, cmd, cmd_len);</a>
<a name="ln1178">  memcpy(lcmd + sizeof(DOSTART) - 1 + cmd_len, DOEND, sizeof(DOEND) - 1);</a>
<a name="ln1179">#undef DOSTART</a>
<a name="ln1180">#undef DOEND</a>
<a name="ln1181"> </a>
<a name="ln1182">  if (luaL_loadbuffer(lstate, lcmd, lcmd_len, &quot;:luado&quot;)) {</a>
<a name="ln1183">    nlua_error(lstate, _(&quot;E5109: Error loading lua: %.*s&quot;));</a>
<a name="ln1184">    if (lcmd_len &gt;= IOSIZE) {</a>
<a name="ln1185">      xfree(lcmd);</a>
<a name="ln1186">    }</a>
<a name="ln1187">    return;</a>
<a name="ln1188">  }</a>
<a name="ln1189">  if (lcmd_len &gt;= IOSIZE) {</a>
<a name="ln1190">    xfree(lcmd);</a>
<a name="ln1191">  }</a>
<a name="ln1192">  if (lua_pcall(lstate, 0, 1, 0)) {</a>
<a name="ln1193">    nlua_error(lstate, _(&quot;E5110: Error executing lua: %.*s&quot;));</a>
<a name="ln1194">    return;</a>
<a name="ln1195">  }</a>
<a name="ln1196">  for (linenr_T l = eap-&gt;line1; l &lt;= eap-&gt;line2; l++) {</a>
<a name="ln1197">    if (l &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1198">      break;</a>
<a name="ln1199">    }</a>
<a name="ln1200">    lua_pushvalue(lstate, -1);</a>
<a name="ln1201">    lua_pushstring(lstate, (const char *)ml_get_buf(curbuf, l, false));</a>
<a name="ln1202">    lua_pushnumber(lstate, (lua_Number)l);</a>
<a name="ln1203">    if (lua_pcall(lstate, 2, 1, 0)) {</a>
<a name="ln1204">      nlua_error(lstate, _(&quot;E5111: Error calling lua: %.*s&quot;));</a>
<a name="ln1205">      break;</a>
<a name="ln1206">    }</a>
<a name="ln1207">    if (lua_isstring(lstate, -1)) {</a>
<a name="ln1208">      size_t new_line_len;</a>
<a name="ln1209">      const char *const new_line = lua_tolstring(lstate, -1, &amp;new_line_len);</a>
<a name="ln1210">      char *const new_line_transformed = xmemdupz(new_line, new_line_len);</a>
<a name="ln1211">      for (size_t i = 0; i &lt; new_line_len; i++) {</a>
<a name="ln1212">        if (new_line_transformed[i] == NUL) {</a>
<a name="ln1213">          new_line_transformed[i] = '\n';</a>
<a name="ln1214">        }</a>
<a name="ln1215">      }</a>
<a name="ln1216">      ml_replace(l, (char_u *)new_line_transformed, false);</a>
<a name="ln1217">      changed_bytes(l, 0);</a>
<a name="ln1218">    }</a>
<a name="ln1219">    lua_pop(lstate, 1);</a>
<a name="ln1220">  }</a>
<a name="ln1221">  lua_pop(lstate, 1);</a>
<a name="ln1222">  check_cursor();</a>
<a name="ln1223">  update_screen(NOT_VALID);</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">/// Run lua file</a>
<a name="ln1227">///</a>
<a name="ln1228">/// Used for :luafile.</a>
<a name="ln1229">///</a>
<a name="ln1230">/// @param  eap  VimL command being run.</a>
<a name="ln1231">void ex_luafile(exarg_T *const eap)</a>
<a name="ln1232">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1233">{</a>
<a name="ln1234">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1235"> </a>
<a name="ln1236">  if (luaL_loadfile(lstate, (const char *)eap-&gt;arg)) {</a>
<a name="ln1237">    nlua_error(lstate, _(&quot;E5112: Error while creating lua chunk: %.*s&quot;));</a>
<a name="ln1238">    return;</a>
<a name="ln1239">  }</a>
<a name="ln1240"> </a>
<a name="ln1241">  if (lua_pcall(lstate, 0, 0, 0)) {</a>
<a name="ln1242">    nlua_error(lstate, _(&quot;E5113: Error while calling lua chunk: %.*s&quot;));</a>
<a name="ln1243">    return;</a>
<a name="ln1244">  }</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247">static void nlua_add_treesitter(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1248">{</a>
<a name="ln1249">  tslua_init(lstate);</a>
<a name="ln1250"> </a>
<a name="ln1251">  lua_pushcfunction(lstate, tslua_push_parser);</a>
<a name="ln1252">  lua_setfield(lstate, -2, &quot;_create_ts_parser&quot;);</a>
<a name="ln1253"> </a>
<a name="ln1254">  lua_pushcfunction(lstate, tslua_add_language);</a>
<a name="ln1255">  lua_setfield(lstate, -2, &quot;_ts_add_language&quot;);</a>
<a name="ln1256"> </a>
<a name="ln1257">  lua_pushcfunction(lstate, tslua_has_language);</a>
<a name="ln1258">  lua_setfield(lstate, -2, &quot;_ts_has_language&quot;);</a>
<a name="ln1259"> </a>
<a name="ln1260">  lua_pushcfunction(lstate, tslua_inspect_lang);</a>
<a name="ln1261">  lua_setfield(lstate, -2, &quot;_ts_inspect_language&quot;);</a>
<a name="ln1262"> </a>
<a name="ln1263">  lua_pushcfunction(lstate, ts_lua_parse_query);</a>
<a name="ln1264">  lua_setfield(lstate, -2, &quot;_ts_parse_query&quot;);</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">static int nlua_regex(lua_State *lstate)</a>
<a name="ln1268">{</a>
<a name="ln1269">  Error err = ERROR_INIT;</a>
<a name="ln1270">  const char *text = luaL_checkstring(lstate, 1);</a>
<a name="ln1271">  regprog_T *prog = NULL;</a>
<a name="ln1272"> </a>
<a name="ln1273">  TRY_WRAP({</a>
<a name="ln1274">    try_start();</a>
<a name="ln1275">    prog = vim_regcomp((char_u *)text, RE_AUTO | RE_MAGIC | RE_STRICT);</a>
<a name="ln1276">    try_end(&amp;err);</a>
<a name="ln1277">  });</a>
<a name="ln1278"> </a>
<a name="ln1279">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1280">    return luaL_error(lstate, &quot;couldn't parse regex: %s&quot;, err.msg);</a>
<a name="ln1281">  }</a>
<a name="ln1282">  assert(prog);</a>
<a name="ln1283"> </a>
<a name="ln1284">  regprog_T **p = lua_newuserdata(lstate, sizeof(regprog_T *));</a>
<a name="ln1285">  *p = prog;</a>
<a name="ln1286"> </a>
<a name="ln1287">  lua_getfield(lstate, LUA_REGISTRYINDEX, &quot;nvim_regex&quot;);  // [udata, meta]</a>
<a name="ln1288">  lua_setmetatable(lstate, -2);  // [udata]</a>
<a name="ln1289">  return 1;</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">static regprog_T **regex_check(lua_State *L)</a>
<a name="ln1293">{</a>
<a name="ln1294">  return luaL_checkudata(L, 1, &quot;nvim_regex&quot;);</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297"> </a>
<a name="ln1298">static int regex_gc(lua_State *lstate)</a>
<a name="ln1299">{</a>
<a name="ln1300">  regprog_T **prog = regex_check(lstate);</a>
<a name="ln1301">  vim_regfree(*prog);</a>
<a name="ln1302">  return 0;</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">static int regex_tostring(lua_State *lstate)</a>
<a name="ln1306">{</a>
<a name="ln1307">  lua_pushstring(lstate, &quot;&lt;regex&gt;&quot;);</a>
<a name="ln1308">  return 1;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">static int regex_match(lua_State *lstate, regprog_T **prog, char_u *str)</a>
<a name="ln1312">{</a>
<a name="ln1313">  regmatch_T rm;</a>
<a name="ln1314">  rm.regprog = *prog;</a>
<a name="ln1315">  rm.rm_ic = false;</a>
<a name="ln1316">  bool match = vim_regexec(&amp;rm, str, 0);</a>
<a name="ln1317">  *prog = rm.regprog;</a>
<a name="ln1318"> </a>
<a name="ln1319">  if (match) {</a>
<a name="ln1320">    lua_pushinteger(lstate, (lua_Integer)(rm.startp[0]-str));</a>
<a name="ln1321">    lua_pushinteger(lstate, (lua_Integer)(rm.endp[0]-str));</a>
<a name="ln1322">    return 2;</a>
<a name="ln1323">  }</a>
<a name="ln1324">  return 0;</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">static int regex_match_str(lua_State *lstate)</a>
<a name="ln1328">{</a>
<a name="ln1329">  regprog_T **prog = regex_check(lstate);</a>
<a name="ln1330">  const char *str = luaL_checkstring(lstate, 2);</a>
<a name="ln1331">  int nret = regex_match(lstate, prog, (char_u *)str);</a>
<a name="ln1332"> </a>
<a name="ln1333">  if (!*prog) {</a>
<a name="ln1334">    return luaL_error(lstate, &quot;regex: internal error&quot;);</a>
<a name="ln1335">  }</a>
<a name="ln1336"> </a>
<a name="ln1337">  return nret;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">static int regex_match_line(lua_State *lstate)</a>
<a name="ln1341">{</a>
<a name="ln1342">  regprog_T **prog = regex_check(lstate);</a>
<a name="ln1343"> </a>
<a name="ln1344">  int narg = lua_gettop(lstate);</a>
<a name="ln1345">  if (narg &lt; 3) {</a>
<a name="ln1346">    return luaL_error(lstate, &quot;not enough args&quot;);</a>
<a name="ln1347">  }</a>
<a name="ln1348"> </a>
<a name="ln1349">  long bufnr = luaL_checkinteger(lstate, 2);</a>
<a name="ln1350">  long rownr = luaL_checkinteger(lstate, 3);</a>
<a name="ln1351">  long start = 0, end = -1;</a>
<a name="ln1352">  if (narg &gt;= 4) {</a>
<a name="ln1353">    start = luaL_checkinteger(lstate, 4);</a>
<a name="ln1354">  }</a>
<a name="ln1355">  if (narg &gt;= 5) {</a>
<a name="ln1356">    end = luaL_checkinteger(lstate, 5);</a>
<a name="ln1357">    if (end &lt; 0) {</a>
<a name="ln1358">      return luaL_error(lstate, &quot;invalid end&quot;);</a>
<a name="ln1359">    }</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  buf_T *buf = bufnr ? handle_get_buffer((int)bufnr) : curbuf;</a>
<a name="ln1363">  if (!buf || buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1364">    return luaL_error(lstate, &quot;invalid buffer&quot;);</a>
<a name="ln1365">  }</a>
<a name="ln1366"> </a>
<a name="ln1367">  if (rownr &gt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1368">    return luaL_error(lstate, &quot;invalid row&quot;);</a>
<a name="ln1369">  }</a>
<a name="ln1370"> </a>
<a name="ln1371">  char_u *line = ml_get_buf(buf, rownr+1, false);</a>
<a name="ln1372">  size_t len = STRLEN(line);</a>
<a name="ln1373"> </a>
<a name="ln1374">  if (start &lt; 0 || (size_t)start &gt; len) {</a>
<a name="ln1375">    return luaL_error(lstate, &quot;invalid start&quot;);</a>
<a name="ln1376">  }</a>
<a name="ln1377"> </a>
<a name="ln1378">  char_u save = NUL;</a>
<a name="ln1379">  if (end &gt;= 0) {</a>
<a name="ln1380">    if ((size_t)end &gt; len || end &lt; start) {</a>
<a name="ln1381">      return luaL_error(lstate, &quot;invalid end&quot;);</a>
<a name="ln1382">    }</a>
<a name="ln1383">    save = line[end];</a>
<a name="ln1384">    line[end] = NUL;</a>
<a name="ln1385">  }</a>
<a name="ln1386"> </a>
<a name="ln1387">  int nret = regex_match(lstate, prog, line+start);</a>
<a name="ln1388"> </a>
<a name="ln1389">  if (end &gt;= 0) {</a>
<a name="ln1390">    line[end] = save;</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  if (!*prog) {</a>
<a name="ln1394">    return luaL_error(lstate, &quot;regex: internal error&quot;);</a>
<a name="ln1395">  }</a>
<a name="ln1396"> </a>
<a name="ln1397">  return nret;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">int nlua_CFunction_func_call(</a>
<a name="ln1401">    int argcount,</a>
<a name="ln1402">    typval_T *argvars,</a>
<a name="ln1403">    typval_T *rettv,</a>
<a name="ln1404">    void *state)</a>
<a name="ln1405">{</a>
<a name="ln1406">    lua_State *const lstate = nlua_enter();</a>
<a name="ln1407">    LuaCFunctionState *funcstate = (LuaCFunctionState *)state;</a>
<a name="ln1408"> </a>
<a name="ln1409">    return typval_exec_lua_callable(</a>
<a name="ln1410">        lstate,</a>
<a name="ln1411">        funcstate-&gt;lua_callable,</a>
<a name="ln1412">        argcount,</a>
<a name="ln1413">        argvars,</a>
<a name="ln1414">        rettv);</a>
<a name="ln1415">}</a>
<a name="ln1416">/// Required functions for lua c functions as VimL callbacks</a>
<a name="ln1417">void nlua_CFunction_func_free(void *state)</a>
<a name="ln1418">{</a>
<a name="ln1419">    lua_State *const lstate = nlua_enter();</a>
<a name="ln1420">    LuaCFunctionState *funcstate = (LuaCFunctionState *)state;</a>
<a name="ln1421"> </a>
<a name="ln1422">    nlua_unref(lstate, funcstate-&gt;lua_callable.func_ref);</a>
<a name="ln1423">    nlua_unref(lstate, funcstate-&gt;lua_callable.table_ref);</a>
<a name="ln1424">    xfree(funcstate);</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">bool nlua_is_table_from_lua(typval_T *const arg)</a>
<a name="ln1428">{</a>
<a name="ln1429">  if (arg-&gt;v_type != VAR_DICT &amp;&amp; arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln1430">    return false;</a>
<a name="ln1431">  }</a>
<a name="ln1432"> </a>
<a name="ln1433">  if (arg-&gt;v_type == VAR_DICT) {</a>
<a name="ln1434">    return arg-&gt;vval.v_dict-&gt;lua_table_ref &gt; 0</a>
<a name="ln1435">      &amp;&amp; arg-&gt;vval.v_dict-&gt;lua_table_ref != LUA_NOREF;</a>
<a name="ln1436">  } else if (arg-&gt;v_type == VAR_LIST) {</a>
<a name="ln1437">    return arg-&gt;vval.v_list-&gt;lua_table_ref &gt; 0</a>
<a name="ln1438">      &amp;&amp; arg-&gt;vval.v_list-&gt;lua_table_ref != LUA_NOREF;</a>
<a name="ln1439">  }</a>
<a name="ln1440"> </a>
<a name="ln1441">  return false;</a>
<a name="ln1442">}</a>
<a name="ln1443"> </a>
<a name="ln1444">char_u *nlua_register_table_as_callable(typval_T *const arg)</a>
<a name="ln1445">{</a>
<a name="ln1446">  if (!nlua_is_table_from_lua(arg)) {</a>
<a name="ln1447">    return NULL;</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  LuaRef table_ref;</a>
<a name="ln1451">  if (arg-&gt;v_type == VAR_DICT) {</a>
<a name="ln1452">    table_ref = arg-&gt;vval.v_dict-&gt;lua_table_ref;</a>
<a name="ln1453">  } else if (arg-&gt;v_type == VAR_LIST) {</a>
<a name="ln1454">    table_ref = arg-&gt;vval.v_list-&gt;lua_table_ref;</a>
<a name="ln1455">  } else {</a>
<a name="ln1456">    return NULL;</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1460"> </a>
<a name="ln1461">#ifndef NDEBUG</a>
<a name="ln1462">  int top = lua_gettop(lstate);</a>
<a name="ln1463">#endif</a>
<a name="ln1464"> </a>
<a name="ln1465">  nlua_pushref(lstate, table_ref);</a>
<a name="ln1466">  if (!lua_getmetatable(lstate, -1)) {</a>
<a name="ln1467">    return NULL;</a>
<a name="ln1468">  }</a>
<a name="ln1469"> </a>
<a name="ln1470">  lua_getfield(lstate, -1, &quot;__call&quot;);</a>
<a name="ln1471">  if (!lua_isfunction(lstate, -1)) {</a>
<a name="ln1472">    return NULL;</a>
<a name="ln1473">  }</a>
<a name="ln1474"> </a>
<a name="ln1475">  LuaRef new_table_ref = nlua_newref(lstate, table_ref);</a>
<a name="ln1476"> </a>
<a name="ln1477">  LuaCFunctionState *state = xmalloc(sizeof(LuaCFunctionState));</a>
<a name="ln1478">  state-&gt;lua_callable.func_ref = nlua_ref(lstate, -1);</a>
<a name="ln1479">  state-&gt;lua_callable.table_ref = new_table_ref;</a>
<a name="ln1480"> </a>
<a name="ln1481">  char_u *name = register_cfunc(</a>
<a name="ln1482">      &amp;nlua_CFunction_func_call,</a>
<a name="ln1483">      &amp;nlua_CFunction_func_free,</a>
<a name="ln1484">      state);</a>
<a name="ln1485"> </a>
<a name="ln1486"> </a>
<a name="ln1487">  lua_pop(lstate, 3);</a>
<a name="ln1488">  assert(top == lua_gettop(lstate));</a>
<a name="ln1489"> </a>
<a name="ln1490">  return name;</a>
<a name="ln1491">}</a>
<a name="ln1492"> </a>
<a name="ln1493">/// Helper function to free a list_T</a>
<a name="ln1494">void nlua_free_typval_list(list_T *const l)</a>
<a name="ln1495">{</a>
<a name="ln1496">  if (l-&gt;lua_table_ref != LUA_NOREF &amp;&amp; l-&gt;lua_table_ref &gt; 0) {</a>
<a name="ln1497">    lua_State *const lstate = nlua_enter();</a>
<a name="ln1498">    nlua_unref(lstate, l-&gt;lua_table_ref);</a>
<a name="ln1499">    l-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln1500">  }</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503"> </a>
<a name="ln1504">/// Helper function to free a dict_T</a>
<a name="ln1505">void nlua_free_typval_dict(dict_T *const d)</a>
<a name="ln1506">{</a>
<a name="ln1507">  if (d-&gt;lua_table_ref != LUA_NOREF &amp;&amp; d-&gt;lua_table_ref &gt; 0) {</a>
<a name="ln1508">    lua_State *const lstate = nlua_enter();</a>
<a name="ln1509">    nlua_unref(lstate, d-&gt;lua_table_ref);</a>
<a name="ln1510">    d-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln1511">  }</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514">void nlua_execute_log_keystroke(int c)</a>
<a name="ln1515">{</a>
<a name="ln1516">  char_u buf[NUMBUFLEN];</a>
<a name="ln1517">  size_t buf_len = special_to_buf(c, mod_mask, false, buf);</a>
<a name="ln1518"> </a>
<a name="ln1519">  lua_State *const lstate = nlua_enter();</a>
<a name="ln1520"> </a>
<a name="ln1521">#ifndef NDEBUG</a>
<a name="ln1522">  int top = lua_gettop(lstate);</a>
<a name="ln1523">#endif</a>
<a name="ln1524"> </a>
<a name="ln1525">  // [ vim ]</a>
<a name="ln1526">  lua_getglobal(lstate, &quot;vim&quot;);</a>
<a name="ln1527"> </a>
<a name="ln1528">  // [ vim, vim._log_keystroke ]</a>
<a name="ln1529">  lua_getfield(lstate, -1, &quot;_log_keystroke&quot;);</a>
<a name="ln1530">  luaL_checktype(lstate, -1, LUA_TFUNCTION);</a>
<a name="ln1531"> </a>
<a name="ln1532">  // [ vim, vim._log_keystroke, buf ]</a>
<a name="ln1533">  lua_pushlstring(lstate, (const char *)buf, buf_len);</a>
<a name="ln1534"> </a>
<a name="ln1535">  if (lua_pcall(lstate, 1, 0, 0)) {</a>
<a name="ln1536">    nlua_error(</a>
<a name="ln1537">        lstate,</a>
<a name="ln1538">        _(&quot;Error executing vim.log_keystroke lua callback: %.*s&quot;));</a>
<a name="ln1539">  }</a>
<a name="ln1540"> </a>
<a name="ln1541">  // [ vim ]</a>
<a name="ln1542">  lua_pop(lstate, 1);</a>
<a name="ln1543"> </a>
<a name="ln1544">#ifndef NDEBUG</a>
<a name="ln1545">  // [ ]</a>
<a name="ln1546">  assert(top == lua_gettop(lstate));</a>
<a name="ln1547">#endif</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>

</code></pre>
<div class="balloon" rel="1435"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: arg->vval.v_dict->lua_table_ref != (- 2).</p></div>
<div class="balloon" rel="1438"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: arg->vval.v_list->lua_table_ref != (- 2).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

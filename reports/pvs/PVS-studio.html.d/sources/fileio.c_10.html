
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;fcntl.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;nvim/vim.h&quot;</a>
<a name="ln14">#include &quot;nvim/api/private/handle.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln21">#include &quot;nvim/diff.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/fold.h&quot;</a>
<a name="ln28">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln29">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln30">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln31">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln34">#include &quot;nvim/memline.h&quot;</a>
<a name="ln35">#include &quot;nvim/memory.h&quot;</a>
<a name="ln36">#include &quot;nvim/message.h&quot;</a>
<a name="ln37">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln38">#include &quot;nvim/garray.h&quot;</a>
<a name="ln39">#include &quot;nvim/move.h&quot;</a>
<a name="ln40">#include &quot;nvim/normal.h&quot;</a>
<a name="ln41">#include &quot;nvim/option.h&quot;</a>
<a name="ln42">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln43">#include &quot;nvim/path.h&quot;</a>
<a name="ln44">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln45">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln46">#include &quot;nvim/screen.h&quot;</a>
<a name="ln47">#include &quot;nvim/search.h&quot;</a>
<a name="ln48">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln49">#include &quot;nvim/state.h&quot;</a>
<a name="ln50">#include &quot;nvim/strings.h&quot;</a>
<a name="ln51">#include &quot;nvim/ui.h&quot;</a>
<a name="ln52">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln53">#include &quot;nvim/types.h&quot;</a>
<a name="ln54">#include &quot;nvim/undo.h&quot;</a>
<a name="ln55">#include &quot;nvim/window.h&quot;</a>
<a name="ln56">#include &quot;nvim/shada.h&quot;</a>
<a name="ln57">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln58">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln59">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln60">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">#define BUFSIZE         8192    /* size of normal write buffer */</a>
<a name="ln63">#define SMBUFSIZE       256     /* size of emergency write buffer */</a>
<a name="ln64"> </a>
<a name="ln65">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln66">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln67">#define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln68">#endif</a>
<a name="ln69"> </a>
<a name="ln70">//</a>
<a name="ln71">// The autocommands are stored in a list for each event.</a>
<a name="ln72">// Autocommands for the same pattern, that are consecutive, are joined</a>
<a name="ln73">// together, to avoid having to match the pattern too often.</a>
<a name="ln74">// The result is an array of Autopat lists, which point to AutoCmd lists:</a>
<a name="ln75">//</a>
<a name="ln76">// last_autopat[0]  -----------------------------+</a>
<a name="ln77">//                                               V</a>
<a name="ln78">// first_autopat[0] --&gt; Autopat.next  --&gt;  Autopat.next --&gt;  NULL</a>
<a name="ln79">//                      Autopat.cmds       Autopat.cmds</a>
<a name="ln80">//                          |                    |</a>
<a name="ln81">//                          V                    V</a>
<a name="ln82">//                      AutoCmd.next       AutoCmd.next</a>
<a name="ln83">//                          |                    |</a>
<a name="ln84">//                          V                    V</a>
<a name="ln85">//                      AutoCmd.next            NULL</a>
<a name="ln86">//                          |</a>
<a name="ln87">//                          V</a>
<a name="ln88">//                         NULL</a>
<a name="ln89">//</a>
<a name="ln90">// last_autopat[1]  --------+</a>
<a name="ln91">//                          V</a>
<a name="ln92">// first_autopat[1] --&gt; Autopat.next  --&gt;  NULL</a>
<a name="ln93">//                      Autopat.cmds</a>
<a name="ln94">//                          |</a>
<a name="ln95">//                          V</a>
<a name="ln96">//                      AutoCmd.next</a>
<a name="ln97">//                          |</a>
<a name="ln98">//                          V</a>
<a name="ln99">//                         NULL</a>
<a name="ln100">//   etc.</a>
<a name="ln101">//</a>
<a name="ln102">//   The order of AutoCmds is important, this is the order in which they were</a>
<a name="ln103">//   defined and will have to be executed.</a>
<a name="ln104">//</a>
<a name="ln105">typedef struct AutoCmd {</a>
<a name="ln106">  char_u          *cmd;                 // Command to be executed (NULL when</a>
<a name="ln107">                                        // command has been removed)</a>
<a name="ln108">  bool once;                            // &quot;One shot&quot;: removed after execution</a>
<a name="ln109">  char nested;                          // If autocommands nest here</a>
<a name="ln110">  char last;                            // last command in list</a>
<a name="ln111">  sctx_T script_ctx;                    // script context where defined</a>
<a name="ln112">  struct AutoCmd  *next;                // Next AutoCmd in list</a>
<a name="ln113">} AutoCmd;</a>
<a name="ln114"> </a>
<a name="ln115">typedef struct AutoPat {</a>
<a name="ln116">  struct AutoPat  *next;                // next AutoPat in AutoPat list; MUST</a>
<a name="ln117">                                        // be the first entry</a>
<a name="ln118">  char_u          *pat;                 // pattern as typed (NULL when pattern</a>
<a name="ln119">                                        // has been removed)</a>
<a name="ln120">  regprog_T       *reg_prog;            // compiled regprog for pattern</a>
<a name="ln121">  AutoCmd         *cmds;                // list of commands to do</a>
<a name="ln122">  int group;                            // group ID</a>
<a name="ln123">  int patlen;                           // strlen() of pat</a>
<a name="ln124">  int buflocal_nr;                      // !=0 for buffer-local AutoPat</a>
<a name="ln125">  char allow_dirs;                      // Pattern may match whole path</a>
<a name="ln126">  char last;                            // last pattern for apply_autocmds()</a>
<a name="ln127">} AutoPat;</a>
<a name="ln128"> </a>
<a name="ln129">///</a>
<a name="ln130">/// Struct used to keep status while executing autocommands for an event.</a>
<a name="ln131">///</a>
<a name="ln132">typedef struct AutoPatCmd {</a>
<a name="ln133">  AutoPat     *curpat;          // next AutoPat to examine</a>
<a name="ln134">  AutoCmd     *nextcmd;         // next AutoCmd to execute</a>
<a name="ln135">  int group;                    // group being used</a>
<a name="ln136">  char_u      *fname;           // fname to match with</a>
<a name="ln137">  char_u      *sfname;          // sfname to match with</a>
<a name="ln138">  char_u      *tail;            // tail of fname</a>
<a name="ln139">  event_T event;                // current event</a>
<a name="ln140">  int arg_bufnr;                // initially equal to &lt;abuf&gt;, set to zero when</a>
<a name="ln141">                                // buf is deleted</a>
<a name="ln142">  struct AutoPatCmd   *next;    // chain of active apc-s for auto-invalidation</a>
<a name="ln143">} AutoPatCmd;</a>
<a name="ln144"> </a>
<a name="ln145">#define AUGROUP_DEFAULT    -1      /* default autocmd group */</a>
<a name="ln146">#define AUGROUP_ERROR      -2      /* erroneous autocmd group */</a>
<a name="ln147">#define AUGROUP_ALL        -3      /* all autocmd groups */</a>
<a name="ln148"> </a>
<a name="ln149">#define HAS_BW_FLAGS</a>
<a name="ln150">#define FIO_LATIN1     0x01    /* convert Latin1 */</a>
<a name="ln151">#define FIO_UTF8       0x02    /* convert UTF-8 */</a>
<a name="ln152">#define FIO_UCS2       0x04    /* convert UCS-2 */</a>
<a name="ln153">#define FIO_UCS4       0x08    /* convert UCS-4 */</a>
<a name="ln154">#define FIO_UTF16      0x10    /* convert UTF-16 */</a>
<a name="ln155">#define FIO_ENDIAN_L   0x80    /* little endian */</a>
<a name="ln156">#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */</a>
<a name="ln157">#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */</a>
<a name="ln158">#define FIO_ALL        -1      /* allow all formats */</a>
<a name="ln159"> </a>
<a name="ln160">/* When converting, a read() or write() may leave some bytes to be converted</a>
<a name="ln161"> * for the next call.  The value is guessed... */</a>
<a name="ln162">#define CONV_RESTLEN 30</a>
<a name="ln163"> </a>
<a name="ln164">/* We have to guess how much a sequence of bytes may expand when converting</a>
<a name="ln165"> * with iconv() to be able to allocate a buffer. */</a>
<a name="ln166">#define ICONV_MULT 8</a>
<a name="ln167"> </a>
<a name="ln168">/*</a>
<a name="ln169"> * Structure to pass arguments from buf_write() to buf_write_bytes().</a>
<a name="ln170"> */</a>
<a name="ln171">struct bw_info {</a>
<a name="ln172">  int bw_fd;                     // file descriptor</a>
<a name="ln173">  char_u      *bw_buf;           // buffer with data to be written</a>
<a name="ln174">  int bw_len;                    // length of data</a>
<a name="ln175">#ifdef HAS_BW_FLAGS</a>
<a name="ln176">  int bw_flags;                  // FIO_ flags</a>
<a name="ln177">#endif</a>
<a name="ln178">  char_u bw_rest[CONV_RESTLEN];  // not converted bytes</a>
<a name="ln179">  int bw_restlen;                // nr of bytes in bw_rest[]</a>
<a name="ln180">  int bw_first;                  // first write call</a>
<a name="ln181">  char_u      *bw_conv_buf;      // buffer for writing converted chars</a>
<a name="ln182">  int bw_conv_buflen;            // size of bw_conv_buf</a>
<a name="ln183">  int bw_conv_error;             // set for conversion error</a>
<a name="ln184">  linenr_T bw_conv_error_lnum;   // first line with error or zero</a>
<a name="ln185">  linenr_T bw_start_lnum;        // line number at start of buffer</a>
<a name="ln186"># ifdef HAVE_ICONV</a>
<a name="ln187">  iconv_t bw_iconv_fd;           // descriptor for iconv() or -1</a>
<a name="ln188"># endif</a>
<a name="ln189">};</a>
<a name="ln190"> </a>
<a name="ln191">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln192"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln193">#endif</a>
<a name="ln194"> </a>
<a name="ln195">static char *e_auchangedbuf = N_(</a>
<a name="ln196">    &quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln197"> </a>
<a name="ln198">// Set by the apply_autocmds_group function if the given event is equal to</a>
<a name="ln199">// EVENT_FILETYPE. Used by the readfile function in order to determine if</a>
<a name="ln200">// EVENT_BUFREADPOST triggered the EVENT_FILETYPE.</a>
<a name="ln201">//</a>
<a name="ln202">// Relying on this value requires one to reset it prior calling</a>
<a name="ln203">// apply_autocmds_group.</a>
<a name="ln204">static bool au_did_filetype INIT(= false);</a>
<a name="ln205"> </a>
<a name="ln206">void filemess(buf_T *buf, char_u *name, char_u *s, int attr)</a>
<a name="ln207">{</a>
<a name="ln208">  int msg_scroll_save;</a>
<a name="ln209"> </a>
<a name="ln210">  if (msg_silent != 0) {</a>
<a name="ln211">    return;</a>
<a name="ln212">  }</a>
<a name="ln213">  add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)name);</a>
<a name="ln214">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln215">  xstrlcat((char *)IObuff, (const char *)s, IOSIZE);</a>
<a name="ln216">  // For the first message may have to start a new line.</a>
<a name="ln217">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln218">  // calling filemess().</a>
<a name="ln219">  msg_scroll_save = msg_scroll;</a>
<a name="ln220">  if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0)</a>
<a name="ln221">    msg_scroll = FALSE;</a>
<a name="ln222">  if (!msg_scroll)      /* wait a bit when overwriting an error msg */</a>
<a name="ln223">    check_for_delay(FALSE);</a>
<a name="ln224">  msg_start();</a>
<a name="ln225">  msg_scroll = msg_scroll_save;</a>
<a name="ln226">  msg_scrolled_ign = TRUE;</a>
<a name="ln227">  /* may truncate the message to avoid a hit-return prompt */</a>
<a name="ln228">  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);</a>
<a name="ln229">  msg_clr_eos();</a>
<a name="ln230">  ui_flush();</a>
<a name="ln231">  msg_scrolled_ign = FALSE;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">static AutoPat *last_autopat[NUM_EVENTS] = {</a>
<a name="ln235">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,</a>
<a name="ln236">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,</a>
<a name="ln237">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,</a>
<a name="ln238">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,</a>
<a name="ln239">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,</a>
<a name="ln240">  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL</a>
<a name="ln241">};</a>
<a name="ln242"> </a>
<a name="ln243">/*</a>
<a name="ln244"> * Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln245"> *</a>
<a name="ln246"> * 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln247"> * 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln248"> * 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln249"> *</a>
<a name="ln250"> * (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln251"> *</a>
<a name="ln252"> * &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln253"> * &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln254"> * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln255"> *</a>
<a name="ln256"> * flags:</a>
<a name="ln257"> * READ_NEW	starting to edit a new buffer</a>
<a name="ln258"> * READ_FILTER	reading filter output</a>
<a name="ln259"> * READ_STDIN	read from stdin instead of a file</a>
<a name="ln260"> * READ_BUFFER	read from curbuf instead of a file (converting after reading</a>
<a name="ln261"> *		stdin)</a>
<a name="ln262"> * READ_DUMMY	read into a dummy buffer (to check if file contents changed)</a>
<a name="ln263"> * READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln264"> * READ_FIFO	read from fifo/socket instead of a file</a>
<a name="ln265"> *</a>
<a name="ln266"> * return FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln267"> */</a>
<a name="ln268">int</a>
<a name="ln269">readfile(</a>
<a name="ln270">    char_u *fname,</a>
<a name="ln271">    char_u *sfname,</a>
<a name="ln272">    linenr_T from,</a>
<a name="ln273">    linenr_T lines_to_skip,</a>
<a name="ln274">    linenr_T lines_to_read,</a>
<a name="ln275">    exarg_T *eap,                       // can be NULL!</a>
<a name="ln276">    int flags</a>
<a name="ln277">)</a>
<a name="ln278">{</a>
<a name="ln279">  int fd = 0;</a>
<a name="ln280">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln281">  int check_readonly;</a>
<a name="ln282">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln283">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln284">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln285">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln286">  int set_options = newfile || read_buffer</a>
<a name="ln287">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln288">  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */</a>
<a name="ln289">  colnr_T read_buf_col = 0;             /* next char to read from this line */</a>
<a name="ln290">  char_u c;</a>
<a name="ln291">  linenr_T lnum = from;</a>
<a name="ln292">  char_u      *ptr = NULL;              /* pointer into read buffer */</a>
<a name="ln293">  char_u      *buffer = NULL;           /* read buffer */</a>
<a name="ln294">  char_u      *new_buffer = NULL;       /* init to shut up gcc */</a>
<a name="ln295">  char_u      *line_start = NULL;       /* init to shut up gcc */</a>
<a name="ln296">  int wasempty;                         /* buffer was empty before reading */</a>
<a name="ln297">  colnr_T len;</a>
<a name="ln298">  long size = 0;</a>
<a name="ln299">  uint8_t *p = NULL;</a>
<a name="ln300">  off_T filesize = 0;</a>
<a name="ln301">  int skip_read = false;</a>
<a name="ln302">  context_sha256_T sha_ctx;</a>
<a name="ln303">  int read_undo_file = false;</a>
<a name="ln304">  int split = 0;  // number of split lines</a>
<a name="ln305">  linenr_T linecnt;</a>
<a name="ln306">  int error = FALSE;                    /* errors encountered */</a>
<a name="ln307">  int ff_error = EOL_UNKNOWN;           /* file format with errors */</a>
<a name="ln308">  long linerest = 0;                    /* remaining chars in line */</a>
<a name="ln309">  int perm = 0;</a>
<a name="ln310">#ifdef UNIX</a>
<a name="ln311">  int swap_mode = -1;                   /* protection bits for swap file */</a>
<a name="ln312">#endif</a>
<a name="ln313">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln314">  bool keep_fileformat = false;</a>
<a name="ln315">  FileInfo file_info;</a>
<a name="ln316">  int file_readonly;</a>
<a name="ln317">  linenr_T skip_count = 0;</a>
<a name="ln318">  linenr_T read_count = 0;</a>
<a name="ln319">  int msg_save = msg_scroll;</a>
<a name="ln320">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln321">                                        // last read was missing the eol</a>
<a name="ln322">  bool file_rewind = false;</a>
<a name="ln323">  int can_retry;</a>
<a name="ln324">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln325">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln326">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln327">                                        // in destination encoding</a>
<a name="ln328">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln329">  /* BAD_KEEP, BAD_DROP or character to</a>
<a name="ln330">   * replace with */</a>
<a name="ln331">  char_u      *tmpname = NULL;          /* name of 'charconvert' output file */</a>
<a name="ln332">  int fio_flags = 0;</a>
<a name="ln333">  char_u      *fenc;                    // fileencoding to use</a>
<a name="ln334">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln335">  char_u      *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln336">  bool advance_fenc = false;</a>
<a name="ln337">  long real_size = 0;</a>
<a name="ln338"># ifdef HAVE_ICONV</a>
<a name="ln339">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln340">  int did_iconv = false;                // TRUE when iconv() failed and trying</a>
<a name="ln341">                                        // 'charconvert' next</a>
<a name="ln342"># endif</a>
<a name="ln343">  int converted = FALSE;                /* TRUE if conversion done */</a>
<a name="ln344">  int notconverted = FALSE;             /* TRUE if conversion wanted but it</a>
<a name="ln345">                                           wasn't possible */</a>
<a name="ln346">  char_u conv_rest[CONV_RESTLEN];</a>
<a name="ln347">  int conv_restlen = 0;                 /* nr of bytes in conv_rest[] */</a>
<a name="ln348">  buf_T       *old_curbuf;</a>
<a name="ln349">  char_u      *old_b_ffname;</a>
<a name="ln350">  char_u      *old_b_fname;</a>
<a name="ln351">  int using_b_ffname;</a>
<a name="ln352">  int using_b_fname;</a>
<a name="ln353">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln354"> </a>
<a name="ln355">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln356"> </a>
<a name="ln357">  curbuf-&gt;b_no_eol_lnum = 0;    /* in case it was set by the previous read */</a>
<a name="ln358"> </a>
<a name="ln359">  /*</a>
<a name="ln360">   * If there is no file name yet, use the one for the read file.</a>
<a name="ln361">   * BF_NOTEDITED is set to reflect this.</a>
<a name="ln362">   * Don't do this for a read from a filter.</a>
<a name="ln363">   * Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln364">   */</a>
<a name="ln365">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln366">      &amp;&amp; !filtering</a>
<a name="ln367">      &amp;&amp; fname != NULL</a>
<a name="ln368">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln369">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln370">    if (set_rw_fname(fname, sfname) == FAIL)</a>
<a name="ln371">      return FAIL;</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  /* Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln375">   * curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln376">   * executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln377">   * point to one of these values. */</a>
<a name="ln378">  old_curbuf = curbuf;</a>
<a name="ln379">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln380">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln381">  using_b_ffname = (fname == curbuf-&gt;b_ffname)</a>
<a name="ln382">                   || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln383">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln384"> </a>
<a name="ln385">  /* After reading a file the cursor line changes but we don't want to</a>
<a name="ln386">   * display the line. */</a>
<a name="ln387">  ex_no_reprint = TRUE;</a>
<a name="ln388"> </a>
<a name="ln389">  /* don't display the file info for another buffer now */</a>
<a name="ln390">  need_fileinfo = FALSE;</a>
<a name="ln391"> </a>
<a name="ln392">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln393">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln394">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln395">  // another directory, which we don't detect.</a>
<a name="ln396">  if (sfname == NULL) {</a>
<a name="ln397">    sfname = fname;</a>
<a name="ln398">  }</a>
<a name="ln399">#if defined(UNIX)</a>
<a name="ln400">  fname = sfname;</a>
<a name="ln401">#endif</a>
<a name="ln402"> </a>
<a name="ln403">  /*</a>
<a name="ln404">   * The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln405">   * executing the associated commands instead.</a>
<a name="ln406">   */</a>
<a name="ln407">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln408">    pos_T pos;</a>
<a name="ln409"> </a>
<a name="ln410">    pos = curbuf-&gt;b_op_start;</a>
<a name="ln411"> </a>
<a name="ln412">    /* Set '[ mark to the line above where the lines go (line 1 if zero). */</a>
<a name="ln413">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln414">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln415"> </a>
<a name="ln416">    if (newfile) {</a>
<a name="ln417">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln418">                               false, curbuf, eap)) {</a>
<a name="ln419">        int status = OK;</a>
<a name="ln420"> </a>
<a name="ln421">        if (aborting()) {</a>
<a name="ln422">          status = FAIL;</a>
<a name="ln423">        }</a>
<a name="ln424"> </a>
<a name="ln425">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln426">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln427">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln428">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln429">        // same file.</a>
<a name="ln430">        if (status == OK) {</a>
<a name="ln431">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln432">        }</a>
<a name="ln433">        return status;</a>
<a name="ln434">      }</a>
<a name="ln435">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln436">                                    false, NULL, eap)) {</a>
<a name="ln437">      return aborting() ? FAIL : OK;</a>
<a name="ln438">    }</a>
<a name="ln439"> </a>
<a name="ln440">    curbuf-&gt;b_op_start = pos;</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  if ((shortmess(SHM_OVER) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0)</a>
<a name="ln444">    msg_scroll = FALSE;         /* overwrite previous file message */</a>
<a name="ln445">  else</a>
<a name="ln446">    msg_scroll = TRUE;          /* don't overwrite previous file message */</a>
<a name="ln447"> </a>
<a name="ln448">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln449">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln450">    size_t namelen = STRLEN(fname);</a>
<a name="ln451"> </a>
<a name="ln452">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln453">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln454">      filemess(curbuf, fname, (char_u *)_(&quot;Illegal file name&quot;), 0);</a>
<a name="ln455">      msg_end();</a>
<a name="ln456">      msg_scroll = msg_save;</a>
<a name="ln457">      return FAIL;</a>
<a name="ln458">    }</a>
<a name="ln459"> </a>
<a name="ln460">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln461">    // because reading the file may actually work, but then creating the</a>
<a name="ln462">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln463">    if (after_pathsep((const char *)fname, (const char *)(fname + namelen))) {</a>
<a name="ln464">      filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);</a>
<a name="ln465">      msg_end();</a>
<a name="ln466">      msg_scroll = msg_save;</a>
<a name="ln467">      return FAIL;</a>
<a name="ln468">    }</a>
<a name="ln469">  }</a>
<a name="ln470"> </a>
<a name="ln471">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln472">    perm = os_getperm((const char *)fname);</a>
<a name="ln473">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln474">    // check for it before os_open().</a>
<a name="ln475">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln476">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln477">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln478"># ifdef OPEN_CHR_FILES</a>
<a name="ln479">        &amp;&amp; !(S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname))</a>
<a name="ln480">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln481"># endif</a>
<a name="ln482">        ) {</a>
<a name="ln483">      if (S_ISDIR(perm)) {</a>
<a name="ln484">        filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);</a>
<a name="ln485">      } else {</a>
<a name="ln486">        filemess(curbuf, fname, (char_u *)_(&quot;is not a file&quot;), 0);</a>
<a name="ln487">      }</a>
<a name="ln488">      msg_end();</a>
<a name="ln489">      msg_scroll = msg_save;</a>
<a name="ln490">      return S_ISDIR(perm) ? NOTDONE : FAIL;</a>
<a name="ln491">    }</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  /* Set default or forced 'fileformat' and 'binary'. */</a>
<a name="ln495">  set_file_options(set_options, eap);</a>
<a name="ln496"> </a>
<a name="ln497">  /*</a>
<a name="ln498">   * When opening a new file we take the readonly flag from the file.</a>
<a name="ln499">   * Default is r/w, can be set to r/o below.</a>
<a name="ln500">   * Don't reset it when in readonly mode</a>
<a name="ln501">   * Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln502">   */</a>
<a name="ln503">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln504">  if (check_readonly &amp;&amp; !readonlymode)</a>
<a name="ln505">    curbuf-&gt;b_p_ro = FALSE;</a>
<a name="ln506"> </a>
<a name="ln507">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln508">    // Remember time of file.</a>
<a name="ln509">    if (os_fileinfo((char *)fname, &amp;file_info)) {</a>
<a name="ln510">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln511">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln512">#ifdef UNIX</a>
<a name="ln513">      /*</a>
<a name="ln514">       * Use the protection bits of the original file for the swap file.</a>
<a name="ln515">       * This makes it possible for others to read the name of the</a>
<a name="ln516">       * edited file from the swapfile, but only if they can read the</a>
<a name="ln517">       * edited file.</a>
<a name="ln518">       * Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln519">       * (they must not write the swapfile).</a>
<a name="ln520">       * Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln521">       * not be able to write to the file ourselves.</a>
<a name="ln522">       * Setting the bits is done below, after creating the swap file.</a>
<a name="ln523">       */</a>
<a name="ln524">      swap_mode = (file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln525">#endif</a>
<a name="ln526">    } else {</a>
<a name="ln527">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln528">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln529">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln530">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln531">    }</a>
<a name="ln532"> </a>
<a name="ln533">    /* Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln534">     * file doesn't exist. */</a>
<a name="ln535">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  // Check readonly.</a>
<a name="ln539">  file_readonly = false;</a>
<a name="ln540">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln541">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln542">        || !os_file_is_writable((char *)fname)) {</a>
<a name="ln543">      file_readonly = true;</a>
<a name="ln544">    }</a>
<a name="ln545">    fd = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln549">    msg_scroll = msg_save;</a>
<a name="ln550">    if (!newfile) {</a>
<a name="ln551">      return FAIL;</a>
<a name="ln552">    }</a>
<a name="ln553">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln554">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln555">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln556">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln557"> </a>
<a name="ln558">      /* Create a swap file now, so that other Vims are warned</a>
<a name="ln559">       * that we are editing this file.  Don't do this for a</a>
<a name="ln560">       * &quot;nofile&quot; or &quot;nowrite&quot; buffer type. */</a>
<a name="ln561">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln562">        check_need_swap(newfile);</a>
<a name="ln563">        /* SwapExists autocommand may mess things up */</a>
<a name="ln564">        if (curbuf != old_curbuf</a>
<a name="ln565">            || (using_b_ffname</a>
<a name="ln566">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln567">            || (using_b_fname</a>
<a name="ln568">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln569">          EMSG(_(e_auchangedbuf));</a>
<a name="ln570">          return FAIL;</a>
<a name="ln571">        }</a>
<a name="ln572">      }</a>
<a name="ln573">      if (dir_of_file_exists(fname)) {</a>
<a name="ln574">        filemess(curbuf, sfname, (char_u *)new_file_message(), 0);</a>
<a name="ln575">      } else {</a>
<a name="ln576">        filemess(curbuf, sfname, (char_u *)_(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln577">      }</a>
<a name="ln578">      // Even though this is a new file, it might have been</a>
<a name="ln579">      // edited before and deleted.  Get the old marks.</a>
<a name="ln580">      check_marks_read();</a>
<a name="ln581">      // Set forced 'fileencoding'.</a>
<a name="ln582">      if (eap != NULL) {</a>
<a name="ln583">        set_forced_fenc(eap);</a>
<a name="ln584">      }</a>
<a name="ln585">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln586">                           false, curbuf, eap);</a>
<a name="ln587">      // remember the current fileformat</a>
<a name="ln588">      save_file_ff(curbuf);</a>
<a name="ln589"> </a>
<a name="ln590">      if (aborting())               /* autocmds may abort script processing */</a>
<a name="ln591">        return FAIL;</a>
<a name="ln592">      return OK;                  /* a new file is not an error */</a>
<a name="ln593">    } else {</a>
<a name="ln594">      filemess(curbuf, sfname, (char_u *)(</a>
<a name="ln595">            (fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln596"># if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln597">            // libuv only returns -errno in Unix and in Windows open() does not</a>
<a name="ln598">            // set EOVERFLOW</a>
<a name="ln599">            (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln600"># endif</a>
<a name="ln601">            _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln602">      curbuf-&gt;b_p_ro = TRUE;                  /* must use &quot;w!&quot; now */</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    return FAIL;</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  /*</a>
<a name="ln609">   * Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln610">   * loaded.	Help files always get readonly mode</a>
<a name="ln611">   */</a>
<a name="ln612">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help)</a>
<a name="ln613">    curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln614"> </a>
<a name="ln615">  if (set_options) {</a>
<a name="ln616">    /* Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln617">     * correctly set when reading stdin. */</a>
<a name="ln618">    if (!read_buffer) {</a>
<a name="ln619">      curbuf-&gt;b_p_eol = TRUE;</a>
<a name="ln620">      curbuf-&gt;b_start_eol = TRUE;</a>
<a name="ln621">    }</a>
<a name="ln622">    curbuf-&gt;b_p_bomb = FALSE;</a>
<a name="ln623">    curbuf-&gt;b_start_bomb = FALSE;</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  /* Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln627">   * editing this file.</a>
<a name="ln628">   * Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type. */</a>
<a name="ln629">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln630">    check_need_swap(newfile);</a>
<a name="ln631">    if (!read_stdin</a>
<a name="ln632">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln633">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln634">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln635">      EMSG(_(e_auchangedbuf));</a>
<a name="ln636">      if (!read_buffer) {</a>
<a name="ln637">        close(fd);</a>
<a name="ln638">      }</a>
<a name="ln639">      return FAIL;</a>
<a name="ln640">    }</a>
<a name="ln641">#ifdef UNIX</a>
<a name="ln642">    // Set swap file protection bits after creating it.</a>
<a name="ln643">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln644">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln645">      const char *swap_fname = (const char *)curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln646"> </a>
<a name="ln647">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln648">      // the group must be equal to the group of the original file.  If</a>
<a name="ln649">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln650">      // avoids making the swap file readable to more users when the</a>
<a name="ln651">      // primary group of the user is too permissive.</a>
<a name="ln652">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln653">        FileInfo swap_info;</a>
<a name="ln654"> </a>
<a name="ln655">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln656">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln657">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, -1, file_info.stat.st_gid)</a>
<a name="ln658">            == -1) {</a>
<a name="ln659">          swap_mode &amp;= 0600;</a>
<a name="ln660">        }</a>
<a name="ln661">      }</a>
<a name="ln662"> </a>
<a name="ln663">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln664">    }</a>
<a name="ln665">#endif</a>
<a name="ln666">  }</a>
<a name="ln667"> </a>
<a name="ln668">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln669">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln670">    if (!read_buffer &amp;&amp; !read_stdin)</a>
<a name="ln671">      close(fd);</a>
<a name="ln672">    return FAIL;</a>
<a name="ln673">  }</a>
<a name="ln674"> </a>
<a name="ln675">  ++no_wait_return;         /* don't wait for return yet */</a>
<a name="ln676"> </a>
<a name="ln677">  /*</a>
<a name="ln678">   * Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln679">   */</a>
<a name="ln680">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln681">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln682"> </a>
<a name="ln683">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln684">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln685">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln686"> </a>
<a name="ln687">  if (!read_buffer) {</a>
<a name="ln688">    int m = msg_scroll;</a>
<a name="ln689">    int n = msg_scrolled;</a>
<a name="ln690"> </a>
<a name="ln691">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln692">    // the file before reading it.</a>
<a name="ln693">    if (!read_stdin) {</a>
<a name="ln694">      close(fd);                // ignore errors</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln698">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln699">    // output was done.</a>
<a name="ln700">    msg_scroll = true;</a>
<a name="ln701">    if (filtering) {</a>
<a name="ln702">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln703">                           false, curbuf, eap);</a>
<a name="ln704">    } else if (read_stdin) {</a>
<a name="ln705">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln706">                           false, curbuf, eap);</a>
<a name="ln707">    } else if (newfile) {</a>
<a name="ln708">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln709">                           false, curbuf, eap);</a>
<a name="ln710">    } else {</a>
<a name="ln711">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln712">                           false, NULL, eap);</a>
<a name="ln713">    }</a>
<a name="ln714"> </a>
<a name="ln715">    // autocommands may have changed it</a>
<a name="ln716">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln717">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln718">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln719"> </a>
<a name="ln720">    if (msg_scrolled == n) {</a>
<a name="ln721">      msg_scroll = m;</a>
<a name="ln722">    }</a>
<a name="ln723"> </a>
<a name="ln724">    if (aborting()) {       /* autocmds may abort script processing */</a>
<a name="ln725">      --no_wait_return;</a>
<a name="ln726">      msg_scroll = msg_save;</a>
<a name="ln727">      curbuf-&gt;b_p_ro = TRUE;            /* must use &quot;w!&quot; now */</a>
<a name="ln728">      return FAIL;</a>
<a name="ln729">    }</a>
<a name="ln730">    /*</a>
<a name="ln731">     * Don't allow the autocommands to change the current buffer.</a>
<a name="ln732">     * Try to re-open the file.</a>
<a name="ln733">     *</a>
<a name="ln734">     * Don't allow the autocommands to change the buffer name either</a>
<a name="ln735">     * (cd for example) if it invalidates fname or sfname.</a>
<a name="ln736">     */</a>
<a name="ln737">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln738">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln739">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln740">                        || (fd = os_open((char *)fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln741">      --no_wait_return;</a>
<a name="ln742">      msg_scroll = msg_save;</a>
<a name="ln743">      if (fd &lt; 0)</a>
<a name="ln744">        EMSG(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln745">      else</a>
<a name="ln746">        EMSG(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln747">      curbuf-&gt;b_p_ro = TRUE;            /* must use &quot;w!&quot; now */</a>
<a name="ln748">      return FAIL;</a>
<a name="ln749">    }</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  /* Autocommands may add lines to the file, need to check if it is empty */</a>
<a name="ln753">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln754"> </a>
<a name="ln755">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln756">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln757">      filemess(curbuf, sfname, (char_u *)&quot;&quot;, 0);</a>
<a name="ln758">    }</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  msg_scroll = FALSE;                   /* overwrite the file message */</a>
<a name="ln762"> </a>
<a name="ln763">  /*</a>
<a name="ln764">   * Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln765">   * fileformat, and after the autocommands, which may change them.</a>
<a name="ln766">   */</a>
<a name="ln767">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln768"> </a>
<a name="ln769">  /* &quot;++bad=&quot; argument. */</a>
<a name="ln770">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln771">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln772">    if (set_options)</a>
<a name="ln773">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln774">  } else</a>
<a name="ln775">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln776"> </a>
<a name="ln777">  /*</a>
<a name="ln778">   * Decide which 'encoding' to use or use first.</a>
<a name="ln779">   */</a>
<a name="ln780">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln781">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln782">    fenc_alloced = true;</a>
<a name="ln783">    keep_dest_enc = true;</a>
<a name="ln784">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln785">    fenc = (char_u *)&quot;&quot;;                // binary: don't convert</a>
<a name="ln786">    fenc_alloced = false;</a>
<a name="ln787">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln788">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln789">    // fails it must be latin1.</a>
<a name="ln790">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln791">    // That is only in *.??x files.</a>
<a name="ln792">    fenc_next = (char_u *)&quot;latin1&quot;;</a>
<a name="ln793">    fenc = (char_u *)&quot;utf-8&quot;;</a>
<a name="ln794"> </a>
<a name="ln795">    fenc_alloced = false;</a>
<a name="ln796">  } else if (*p_fencs == NUL) {</a>
<a name="ln797">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln798">    fenc_alloced = false;</a>
<a name="ln799">  } else {</a>
<a name="ln800">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln801">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  /*</a>
<a name="ln805">   * Jump back here to retry reading the file in different ways.</a>
<a name="ln806">   * Reasons to retry:</a>
<a name="ln807">   * - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln808">   * - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln809">   * - &quot;fileformat&quot; check failed: try another</a>
<a name="ln810">   *</a>
<a name="ln811">   * Variables set for special retry actions:</a>
<a name="ln812">   * &quot;file_rewind&quot;	Rewind the file to start reading it again.</a>
<a name="ln813">   * &quot;advance_fenc&quot;	Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln814">   * &quot;skip_read&quot;	Re-use already read bytes (BOM detected).</a>
<a name="ln815">   * &quot;did_iconv&quot;	iconv() conversion failed, try 'charconvert'.</a>
<a name="ln816">   * &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln817">   *</a>
<a name="ln818">   * Other status indicators:</a>
<a name="ln819">   * &quot;tmpname&quot;	When != NULL did conversion with 'charconvert'.</a>
<a name="ln820">   *			Output file has to be deleted afterwards.</a>
<a name="ln821">   * &quot;iconv_fd&quot;	When != -1 did conversion with iconv().</a>
<a name="ln822">   */</a>
<a name="ln823">retry:</a>
<a name="ln824"> </a>
<a name="ln825">  if (file_rewind) {</a>
<a name="ln826">    if (read_buffer) {</a>
<a name="ln827">      read_buf_lnum = 1;</a>
<a name="ln828">      read_buf_col = 0;</a>
<a name="ln829">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln830">      // Can't rewind the file, give up.</a>
<a name="ln831">      error = true;</a>
<a name="ln832">      goto failed;</a>
<a name="ln833">    }</a>
<a name="ln834">    // Delete the previously read lines.</a>
<a name="ln835">    while (lnum &gt; from) {</a>
<a name="ln836">      ml_delete(lnum--, false);</a>
<a name="ln837">    }</a>
<a name="ln838">    file_rewind = false;</a>
<a name="ln839">    if (set_options) {</a>
<a name="ln840">      curbuf-&gt;b_p_bomb = FALSE;</a>
<a name="ln841">      curbuf-&gt;b_start_bomb = FALSE;</a>
<a name="ln842">    }</a>
<a name="ln843">    conv_error = 0;</a>
<a name="ln844">  }</a>
<a name="ln845"> </a>
<a name="ln846">  /*</a>
<a name="ln847">   * When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln848">   * will be reset.</a>
<a name="ln849">   */</a>
<a name="ln850">  if (keep_fileformat) {</a>
<a name="ln851">    keep_fileformat = false;</a>
<a name="ln852">  } else {</a>
<a name="ln853">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln854">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln855">      try_unix = try_dos = try_mac = FALSE;</a>
<a name="ln856">    } else if (curbuf-&gt;b_p_bin)</a>
<a name="ln857">      fileformat = EOL_UNIX;                    /* binary: use Unix format */</a>
<a name="ln858">    else if (*p_ffs == NUL)</a>
<a name="ln859">      fileformat = get_fileformat(curbuf);      /* use format from buffer */</a>
<a name="ln860">    else</a>
<a name="ln861">      fileformat = EOL_UNKNOWN;                 /* detect from file */</a>
<a name="ln862">  }</a>
<a name="ln863"> </a>
<a name="ln864"># ifdef HAVE_ICONV</a>
<a name="ln865">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln866">    /* aborted conversion with iconv(), close the descriptor */</a>
<a name="ln867">    iconv_close(iconv_fd);</a>
<a name="ln868">    iconv_fd = (iconv_t)-1;</a>
<a name="ln869">  }</a>
<a name="ln870"># endif</a>
<a name="ln871"> </a>
<a name="ln872">  if (advance_fenc) {</a>
<a name="ln873">    /*</a>
<a name="ln874">     * Try the next entry in 'fileencodings'.</a>
<a name="ln875">     */</a>
<a name="ln876">    advance_fenc = false;</a>
<a name="ln877"> </a>
<a name="ln878">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln879">      /* Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln880">       * without conversion. */</a>
<a name="ln881">      notconverted = TRUE;</a>
<a name="ln882">      conv_error = 0;</a>
<a name="ln883">      if (fenc_alloced)</a>
<a name="ln884">        xfree(fenc);</a>
<a name="ln885">      fenc = (char_u *)&quot;&quot;;</a>
<a name="ln886">      fenc_alloced = false;</a>
<a name="ln887">    } else {</a>
<a name="ln888">      if (fenc_alloced)</a>
<a name="ln889">        xfree(fenc);</a>
<a name="ln890">      if (fenc_next != NULL) {</a>
<a name="ln891">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln892">      } else {</a>
<a name="ln893">        fenc = (char_u *)&quot;&quot;;</a>
<a name="ln894">        fenc_alloced = false;</a>
<a name="ln895">      }</a>
<a name="ln896">    }</a>
<a name="ln897">    if (tmpname != NULL) {</a>
<a name="ln898">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln899">      XFREE_CLEAR(tmpname);</a>
<a name="ln900">    }</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  /*</a>
<a name="ln904">   * Conversion may be required when the encoding of the file is different</a>
<a name="ln905">   * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln906">   */</a>
<a name="ln907">  fio_flags = 0;</a>
<a name="ln908">  converted = need_conversion(fenc);</a>
<a name="ln909">  if (converted) {</a>
<a name="ln910"> </a>
<a name="ln911">    /* &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln912">     * for a BOM. */</a>
<a name="ln913">    if (STRCMP(fenc, ENC_UCSBOM) == 0)</a>
<a name="ln914">      fio_flags = FIO_UCSBOM;</a>
<a name="ln915"> </a>
<a name="ln916">    /*</a>
<a name="ln917">     * Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln918">     * done.  This is handled below after read().  Prepare the</a>
<a name="ln919">     * fio_flags to avoid having to parse the string each time.</a>
<a name="ln920">     * Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln921">     * appears not to handle this correctly.  This works just like</a>
<a name="ln922">     * conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln923">     * the buffer.</a>
<a name="ln924">     */</a>
<a name="ln925">    else if (enc_utf8 || STRCMP(p_enc, &quot;latin1&quot;) == 0)</a>
<a name="ln926">      fio_flags = get_fio_flags(fenc);</a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930"># ifdef HAVE_ICONV</a>
<a name="ln931">    // Try using iconv() if we can't convert internally.</a>
<a name="ln932">    if (fio_flags == 0</a>
<a name="ln933">        &amp;&amp; !did_iconv</a>
<a name="ln934">        ) {</a>
<a name="ln935">      iconv_fd = (iconv_t)my_iconv_open(</a>
<a name="ln936">          enc_utf8 ? (char_u *)&quot;utf-8&quot; : p_enc, fenc);</a>
<a name="ln937">    }</a>
<a name="ln938"># endif</a>
<a name="ln939"> </a>
<a name="ln940">    /*</a>
<a name="ln941">     * Use the 'charconvert' expression when conversion is required</a>
<a name="ln942">     * and we can't do it internally or with iconv().</a>
<a name="ln943">     */</a>
<a name="ln944">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln945">        &amp;&amp; !read_fifo</a>
<a name="ln946">#  ifdef HAVE_ICONV</a>
<a name="ln947">        &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln948">#  endif</a>
<a name="ln949">        ) {</a>
<a name="ln950">#  ifdef HAVE_ICONV</a>
<a name="ln951">      did_iconv = false;</a>
<a name="ln952">#  endif</a>
<a name="ln953">      /* Skip conversion when it's already done (retry for wrong</a>
<a name="ln954">       * &quot;fileformat&quot;). */</a>
<a name="ln955">      if (tmpname == NULL) {</a>
<a name="ln956">        tmpname = readfile_charconvert(fname, fenc, &amp;fd);</a>
<a name="ln957">        if (tmpname == NULL) {</a>
<a name="ln958">          // Conversion failed.  Try another one.</a>
<a name="ln959">          advance_fenc = true;</a>
<a name="ln960">          if (fd &lt; 0) {</a>
<a name="ln961">            /* Re-opening the original file failed! */</a>
<a name="ln962">            EMSG(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln963">            error = TRUE;</a>
<a name="ln964">            goto failed;</a>
<a name="ln965">          }</a>
<a name="ln966">          goto retry;</a>
<a name="ln967">        }</a>
<a name="ln968">      }</a>
<a name="ln969">    } else {</a>
<a name="ln970">      if (fio_flags == 0</a>
<a name="ln971"># ifdef HAVE_ICONV</a>
<a name="ln972">          &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln973"># endif</a>
<a name="ln974">          ) {</a>
<a name="ln975">        /* Conversion wanted but we can't.</a>
<a name="ln976">         * Try the next conversion in 'fileencodings' */</a>
<a name="ln977">        advance_fenc = true;</a>
<a name="ln978">        goto retry;</a>
<a name="ln979">      }</a>
<a name="ln980">    }</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  /* Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln984">   * another &quot;fenc&quot; value.  It's FALSE when no other &quot;fenc&quot; to try, reading</a>
<a name="ln985">   * stdin or fixed at a specific encoding. */</a>
<a name="ln986">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln987"> </a>
<a name="ln988">  if (!skip_read) {</a>
<a name="ln989">    linerest = 0;</a>
<a name="ln990">    filesize = 0;</a>
<a name="ln991">    skip_count = lines_to_skip;</a>
<a name="ln992">    read_count = lines_to_read;</a>
<a name="ln993">    conv_restlen = 0;</a>
<a name="ln994">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln995">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln996">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln997">                      &amp;&amp; !filtering</a>
<a name="ln998">                      &amp;&amp; !read_fifo</a>
<a name="ln999">                      &amp;&amp; !read_stdin</a>
<a name="ln1000">                      &amp;&amp; !read_buffer);</a>
<a name="ln1001">    if (read_undo_file)</a>
<a name="ln1002">      sha256_start(&amp;sha_ctx);</a>
<a name="ln1003">  }</a>
<a name="ln1004"> </a>
<a name="ln1005">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln1006">    /*</a>
<a name="ln1007">     * We allocate as much space for the file as we can get, plus</a>
<a name="ln1008">     * space for the old line plus room for one terminating NUL.</a>
<a name="ln1009">     * The amount is limited by the fact that read() only can read</a>
<a name="ln1010">     * up to max_unsigned characters (and other things).</a>
<a name="ln1011">     */</a>
<a name="ln1012">    {</a>
<a name="ln1013">      if (!skip_read) {</a>
<a name="ln1014">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln1015">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln1016">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln1017">        size = 0x10000L + linerest;</a>
<a name="ln1018">        if (size &gt; 0x100000L) {</a>
<a name="ln1019">          size = 0x100000L;</a>
<a name="ln1020">        }</a>
<a name="ln1021">      }</a>
<a name="ln1022"> </a>
<a name="ln1023">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln1024">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln1025">        split++;</a>
<a name="ln1026">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln1027">        size = 1;</a>
<a name="ln1028">      } else if (!skip_read) {</a>
<a name="ln1029">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln1030">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln1031">          if (new_buffer) {</a>
<a name="ln1032">            break;</a>
<a name="ln1033">          }</a>
<a name="ln1034">        }</a>
<a name="ln1035">        if (new_buffer == NULL) {</a>
<a name="ln1036">          error = TRUE;</a>
<a name="ln1037">          break;</a>
<a name="ln1038">        }</a>
<a name="ln1039">        if (linerest)           /* copy characters from the previous buffer */</a>
<a name="ln1040">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln1041">        xfree(buffer);</a>
<a name="ln1042">        buffer = new_buffer;</a>
<a name="ln1043">        ptr = buffer + linerest;</a>
<a name="ln1044">        line_start = buffer;</a>
<a name="ln1045"> </a>
<a name="ln1046">        /* May need room to translate into.</a>
<a name="ln1047">         * For iconv() we don't really know the required space, use a</a>
<a name="ln1048">         * factor ICONV_MULT.</a>
<a name="ln1049">         * latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln1050">         * utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln1051">         * become up to 4 bytes, size must be multiple of 2</a>
<a name="ln1052">         * ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln1053">         * multiple of 2</a>
<a name="ln1054">         * ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln1055">         * multiple of 4 */</a>
<a name="ln1056">        real_size = (int)size;</a>
<a name="ln1057"># ifdef HAVE_ICONV</a>
<a name="ln1058">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1059">          size = size / ICONV_MULT;</a>
<a name="ln1060">        } else {</a>
<a name="ln1061"># endif</a>
<a name="ln1062">        if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln1063">          size = size / 2;</a>
<a name="ln1064">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1065">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln1066">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1067">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln1068">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1069">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln1070">        }</a>
<a name="ln1071"># ifdef HAVE_ICONV</a>
<a name="ln1072">        }</a>
<a name="ln1073"># endif</a>
<a name="ln1074">        if (conv_restlen &gt; 0) {</a>
<a name="ln1075">          // Insert unconverted bytes from previous line.</a>
<a name="ln1076">          memmove(ptr, conv_rest, conv_restlen);  // -V614</a>
<a name="ln1077">          ptr += conv_restlen;</a>
<a name="ln1078">          size -= conv_restlen;</a>
<a name="ln1079">        }</a>
<a name="ln1080"> </a>
<a name="ln1081">        if (read_buffer) {</a>
<a name="ln1082">          /*</a>
<a name="ln1083">           * Read bytes from curbuf.  Used for converting text read</a>
<a name="ln1084">           * from stdin.</a>
<a name="ln1085">           */</a>
<a name="ln1086">          if (read_buf_lnum &gt; from)</a>
<a name="ln1087">            size = 0;</a>
<a name="ln1088">          else {</a>
<a name="ln1089">            int n, ni;</a>
<a name="ln1090">            long tlen;</a>
<a name="ln1091"> </a>
<a name="ln1092">            tlen = 0;</a>
<a name="ln1093">            for (;; ) {</a>
<a name="ln1094">              p = ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln1095">              n = (int)STRLEN(p);</a>
<a name="ln1096">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln1097">                /* Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln1098">                 * Change NL to NUL to reverse the effect done</a>
<a name="ln1099">                 * below. */</a>
<a name="ln1100">                n = (int)(size - tlen);</a>
<a name="ln1101">                for (ni = 0; ni &lt; n; ++ni) {</a>
<a name="ln1102">                  if (p[ni] == NL)</a>
<a name="ln1103">                    ptr[tlen++] = NUL;</a>
<a name="ln1104">                  else</a>
<a name="ln1105">                    ptr[tlen++] = p[ni];</a>
<a name="ln1106">                }</a>
<a name="ln1107">                read_buf_col += n;</a>
<a name="ln1108">                break;</a>
<a name="ln1109">              } else {</a>
<a name="ln1110">                /* Append whole line and new-line.  Change NL</a>
<a name="ln1111">                * to NUL to reverse the effect done below. */</a>
<a name="ln1112">                for (ni = 0; ni &lt; n; ++ni) {</a>
<a name="ln1113">                  if (p[ni] == NL)</a>
<a name="ln1114">                    ptr[tlen++] = NUL;</a>
<a name="ln1115">                  else</a>
<a name="ln1116">                    ptr[tlen++] = p[ni];</a>
<a name="ln1117">                }</a>
<a name="ln1118">                ptr[tlen++] = NL;</a>
<a name="ln1119">                read_buf_col = 0;</a>
<a name="ln1120">                if (++read_buf_lnum &gt; from) {</a>
<a name="ln1121">                  /* When the last line didn't have an</a>
<a name="ln1122">                   * end-of-line don't add it now either. */</a>
<a name="ln1123">                  if (!curbuf-&gt;b_p_eol)</a>
<a name="ln1124">                    --tlen;</a>
<a name="ln1125">                  size = tlen;</a>
<a name="ln1126">                  break;</a>
<a name="ln1127">                }</a>
<a name="ln1128">              }</a>
<a name="ln1129">            }</a>
<a name="ln1130">          }</a>
<a name="ln1131">        } else {</a>
<a name="ln1132">          /*</a>
<a name="ln1133">           * Read bytes from the file.</a>
<a name="ln1134">           */</a>
<a name="ln1135">          size = read_eintr(fd, ptr, size);</a>
<a name="ln1136">        }</a>
<a name="ln1137"> </a>
<a name="ln1138">        if (size &lt;= 0) {</a>
<a name="ln1139">          if (size &lt; 0)                             /* read error */</a>
<a name="ln1140">            error = TRUE;</a>
<a name="ln1141">          else if (conv_restlen &gt; 0) {</a>
<a name="ln1142">            /*</a>
<a name="ln1143">             * Reached end-of-file but some trailing bytes could</a>
<a name="ln1144">             * not be converted.  Truncated file?</a>
<a name="ln1145">             */</a>
<a name="ln1146"> </a>
<a name="ln1147">            /* When we did a conversion report an error. */</a>
<a name="ln1148">            if (fio_flags != 0</a>
<a name="ln1149"># ifdef HAVE_ICONV</a>
<a name="ln1150">                || iconv_fd != (iconv_t)-1</a>
<a name="ln1151"># endif</a>
<a name="ln1152">                ) {</a>
<a name="ln1153">              if (can_retry)</a>
<a name="ln1154">                goto rewind_retry;</a>
<a name="ln1155">              if (conv_error == 0)</a>
<a name="ln1156">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1157">                             - linecnt + 1;</a>
<a name="ln1158">            }</a>
<a name="ln1159">            /* Remember the first linenr with an illegal byte */</a>
<a name="ln1160">            else if (illegal_byte == 0)</a>
<a name="ln1161">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1162">                             - linecnt + 1;</a>
<a name="ln1163">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1164">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1165">              conv_restlen = 0;</a>
<a name="ln1166">            } else {</a>
<a name="ln1167">              /* Replace the trailing bytes with the replacement</a>
<a name="ln1168">               * character if we were converting; if we weren't,</a>
<a name="ln1169">               * leave the UTF8 checking code to do it, as it</a>
<a name="ln1170">               * works slightly differently. */</a>
<a name="ln1171">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0</a>
<a name="ln1172"># ifdef HAVE_ICONV</a>
<a name="ln1173">                                                    || iconv_fd != (iconv_t)-1</a>
<a name="ln1174"># endif</a>
<a name="ln1175">                                                    )) {</a>
<a name="ln1176">                while (conv_restlen &gt; 0) {</a>
<a name="ln1177">                  *(--ptr) = bad_char_behavior;</a>
<a name="ln1178">                  --conv_restlen;</a>
<a name="ln1179">                }</a>
<a name="ln1180">              }</a>
<a name="ln1181">              fio_flags = 0;  // don't convert this</a>
<a name="ln1182"># ifdef HAVE_ICONV</a>
<a name="ln1183">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1184">                iconv_close(iconv_fd);</a>
<a name="ln1185">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1186">              }</a>
<a name="ln1187"># endif</a>
<a name="ln1188">            }</a>
<a name="ln1189">          }</a>
<a name="ln1190">        }</a>
<a name="ln1191">      }</a>
<a name="ln1192"> </a>
<a name="ln1193">      skip_read = FALSE;</a>
<a name="ln1194"> </a>
<a name="ln1195">      /*</a>
<a name="ln1196">       * At start of file: Check for BOM.</a>
<a name="ln1197">       * Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1198">       * converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1199">       * found.</a>
<a name="ln1200">       */</a>
<a name="ln1201">      if ((filesize == 0)</a>
<a name="ln1202">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1203">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1204">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1205">                  &amp;&amp; (*fenc == 'u' || (*fenc == NUL &amp;&amp; enc_utf8))))) {</a>
<a name="ln1206">        char_u  *ccname;</a>
<a name="ln1207">        int blen;</a>
<a name="ln1208"> </a>
<a name="ln1209">        /* no BOM detection in a short file or in binary mode */</a>
<a name="ln1210">        if (size &lt; 2 || curbuf-&gt;b_p_bin)</a>
<a name="ln1211">          ccname = NULL;</a>
<a name="ln1212">        else</a>
<a name="ln1213">          ccname = check_for_bom(ptr, size, &amp;blen,</a>
<a name="ln1214">              fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));</a>
<a name="ln1215">        if (ccname != NULL) {</a>
<a name="ln1216">          /* Remove BOM from the text */</a>
<a name="ln1217">          filesize += blen;</a>
<a name="ln1218">          size -= blen;</a>
<a name="ln1219">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1220">          if (set_options) {</a>
<a name="ln1221">            curbuf-&gt;b_p_bomb = TRUE;</a>
<a name="ln1222">            curbuf-&gt;b_start_bomb = TRUE;</a>
<a name="ln1223">          }</a>
<a name="ln1224">        }</a>
<a name="ln1225"> </a>
<a name="ln1226">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1227">          if (ccname == NULL) {</a>
<a name="ln1228">            // No BOM detected: retry with next encoding.</a>
<a name="ln1229">            advance_fenc = true;</a>
<a name="ln1230">          } else {</a>
<a name="ln1231">            /* BOM detected: set &quot;fenc&quot; and jump back */</a>
<a name="ln1232">            if (fenc_alloced)</a>
<a name="ln1233">              xfree(fenc);</a>
<a name="ln1234">            fenc = ccname;</a>
<a name="ln1235">            fenc_alloced = false;</a>
<a name="ln1236">          }</a>
<a name="ln1237">          /* retry reading without getting new bytes or rewinding */</a>
<a name="ln1238">          skip_read = TRUE;</a>
<a name="ln1239">          goto retry;</a>
<a name="ln1240">        }</a>
<a name="ln1241">      }</a>
<a name="ln1242"> </a>
<a name="ln1243">      /* Include not converted bytes. */</a>
<a name="ln1244">      ptr -= conv_restlen;</a>
<a name="ln1245">      size += conv_restlen;</a>
<a name="ln1246">      conv_restlen = 0;</a>
<a name="ln1247">      /*</a>
<a name="ln1248">       * Break here for a read error or end-of-file.</a>
<a name="ln1249">       */</a>
<a name="ln1250">      if (size &lt;= 0)</a>
<a name="ln1251">        break;</a>
<a name="ln1252"> </a>
<a name="ln1253"># ifdef HAVE_ICONV</a>
<a name="ln1254">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1255">        /*</a>
<a name="ln1256">         * Attempt conversion of the read bytes to 'encoding' using</a>
<a name="ln1257">         * iconv().</a>
<a name="ln1258">         */</a>
<a name="ln1259">        const char      *fromp;</a>
<a name="ln1260">        char            *top;</a>
<a name="ln1261">        size_t from_size;</a>
<a name="ln1262">        size_t to_size;</a>
<a name="ln1263"> </a>
<a name="ln1264">        fromp = (char *)ptr;</a>
<a name="ln1265">        from_size = size;</a>
<a name="ln1266">        ptr += size;</a>
<a name="ln1267">        top = (char *)ptr;</a>
<a name="ln1268">        to_size = real_size - size;</a>
<a name="ln1269"> </a>
<a name="ln1270">        /*</a>
<a name="ln1271">         * If there is conversion error or not enough room try using</a>
<a name="ln1272">         * another conversion.  Except for when there is no</a>
<a name="ln1273">         * alternative (help files).</a>
<a name="ln1274">         */</a>
<a name="ln1275">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1276">                    &amp;top, &amp;to_size)</a>
<a name="ln1277">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1278">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1279">          if (can_retry)</a>
<a name="ln1280">            goto rewind_retry;</a>
<a name="ln1281">          if (conv_error == 0)</a>
<a name="ln1282">            conv_error = readfile_linenr(linecnt,</a>
<a name="ln1283">                ptr, (char_u *)top);</a>
<a name="ln1284"> </a>
<a name="ln1285">          /* Deal with a bad byte and continue with the next. */</a>
<a name="ln1286">          ++fromp;</a>
<a name="ln1287">          --from_size;</a>
<a name="ln1288">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1289">            *top++ = *(fromp - 1);</a>
<a name="ln1290">            --to_size;</a>
<a name="ln1291">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1292">            *top++ = bad_char_behavior;</a>
<a name="ln1293">            --to_size;</a>
<a name="ln1294">          }</a>
<a name="ln1295">        }</a>
<a name="ln1296"> </a>
<a name="ln1297">        if (from_size &gt; 0) {</a>
<a name="ln1298">          /* Some remaining characters, keep them for the next</a>
<a name="ln1299">           * round. */</a>
<a name="ln1300">          memmove(conv_rest, (char_u *)fromp, from_size);</a>
<a name="ln1301">          conv_restlen = (int)from_size;</a>
<a name="ln1302">        }</a>
<a name="ln1303"> </a>
<a name="ln1304">        /* move the linerest to before the converted characters */</a>
<a name="ln1305">        line_start = ptr - linerest;</a>
<a name="ln1306">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1307">        size = (long)((char_u *)top - ptr);</a>
<a name="ln1308">      }</a>
<a name="ln1309"># endif</a>
<a name="ln1310"> </a>
<a name="ln1311">      if (fio_flags != 0) {</a>
<a name="ln1312">        unsigned int u8c;</a>
<a name="ln1313">        char_u  *dest;</a>
<a name="ln1314">        char_u  *tail = NULL;</a>
<a name="ln1315"> </a>
<a name="ln1316">        /*</a>
<a name="ln1317">         * &quot;enc_utf8&quot; set: Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1318">         * &quot;enc_utf8&quot; not set: Convert Unicode to Latin1.</a>
<a name="ln1319">         * Go from end to start through the buffer, because the number</a>
<a name="ln1320">         * of bytes may increase.</a>
<a name="ln1321">         * &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1322">         * to after the next character to convert.</a>
<a name="ln1323">         */</a>
<a name="ln1324">        dest = ptr + real_size;</a>
<a name="ln1325">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1326">          p = ptr + size;</a>
<a name="ln1327">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1328">            /* Check for a trailing incomplete UTF-8 sequence */</a>
<a name="ln1329">            tail = ptr + size - 1;</a>
<a name="ln1330">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80)</a>
<a name="ln1331">              --tail;</a>
<a name="ln1332">            if (tail + utf_byte2len(*tail) &lt;= ptr + size)</a>
<a name="ln1333">              tail = NULL;</a>
<a name="ln1334">            else</a>
<a name="ln1335">              p = tail;</a>
<a name="ln1336">          }</a>
<a name="ln1337">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1338">          /* Check for a trailing byte */</a>
<a name="ln1339">          p = ptr + (size &amp; ~1);</a>
<a name="ln1340">          if (size &amp; 1)</a>
<a name="ln1341">            tail = p;</a>
<a name="ln1342">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; ptr) {</a>
<a name="ln1343">            /* Check for a trailing leading word */</a>
<a name="ln1344">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1345">              u8c = (*--p &lt;&lt; 8);</a>
<a name="ln1346">              u8c += *--p;</a>
<a name="ln1347">            } else {</a>
<a name="ln1348">              u8c = *--p;</a>
<a name="ln1349">              u8c += (*--p &lt;&lt; 8);</a>
<a name="ln1350">            }</a>
<a name="ln1351">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff)</a>
<a name="ln1352">              tail = p;</a>
<a name="ln1353">            else</a>
<a name="ln1354">              p += 2;</a>
<a name="ln1355">          }</a>
<a name="ln1356">        } else {   /*  FIO_UCS4 */</a>
<a name="ln1357">                     /* Check for trailing 1, 2 or 3 bytes */</a>
<a name="ln1358">          p = ptr + (size &amp; ~3);</a>
<a name="ln1359">          if (size &amp; 3)</a>
<a name="ln1360">            tail = p;</a>
<a name="ln1361">        }</a>
<a name="ln1362"> </a>
<a name="ln1363">        /* If there is a trailing incomplete sequence move it to</a>
<a name="ln1364">         * conv_rest[]. */</a>
<a name="ln1365">        if (tail != NULL) {</a>
<a name="ln1366">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1367">          memmove(conv_rest, tail, conv_restlen);</a>
<a name="ln1368">          size -= conv_restlen;</a>
<a name="ln1369">        }</a>
<a name="ln1370"> </a>
<a name="ln1371"> </a>
<a name="ln1372">        while (p &gt; ptr) {</a>
<a name="ln1373">          if (fio_flags &amp; FIO_LATIN1)</a>
<a name="ln1374">            u8c = *--p;</a>
<a name="ln1375">          else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1376">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1377">              u8c = (*--p &lt;&lt; 8);</a>
<a name="ln1378">              u8c += *--p;</a>
<a name="ln1379">            } else {</a>
<a name="ln1380">              u8c = *--p;</a>
<a name="ln1381">              u8c += (*--p &lt;&lt; 8);</a>
<a name="ln1382">            }</a>
<a name="ln1383">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1384">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1385">              int u16c;</a>
<a name="ln1386"> </a>
<a name="ln1387">              if (p == ptr) {</a>
<a name="ln1388">                /* Missing leading word. */</a>
<a name="ln1389">                if (can_retry)</a>
<a name="ln1390">                  goto rewind_retry;</a>
<a name="ln1391">                if (conv_error == 0)</a>
<a name="ln1392">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1393">                      ptr, p);</a>
<a name="ln1394">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1395">                  continue;</a>
<a name="ln1396">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1397">                  u8c = bad_char_behavior;</a>
<a name="ln1398">              }</a>
<a name="ln1399"> </a>
<a name="ln1400">              /* found second word of double-word, get the first</a>
<a name="ln1401">               * word and compute the resulting character */</a>
<a name="ln1402">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1403">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1404">                u16c += *--p;</a>
<a name="ln1405">              } else {</a>
<a name="ln1406">                u16c = *--p;</a>
<a name="ln1407">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1408">              }</a>
<a name="ln1409">              u8c = 0x10000 + ((u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1410">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1411"> </a>
<a name="ln1412">              /* Check if the word is indeed a leading word. */</a>
<a name="ln1413">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1414">                if (can_retry)</a>
<a name="ln1415">                  goto rewind_retry;</a>
<a name="ln1416">                if (conv_error == 0)</a>
<a name="ln1417">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1418">                      ptr, p);</a>
<a name="ln1419">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1420">                  continue;</a>
<a name="ln1421">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1422">                  u8c = bad_char_behavior;</a>
<a name="ln1423">              }</a>
<a name="ln1424">            }</a>
<a name="ln1425">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1426">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1427">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1428">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1429">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1430">              u8c += *--p;</a>
<a name="ln1431">            } else {          /* big endian */</a>
<a name="ln1432">              u8c = *--p;</a>
<a name="ln1433">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1434">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1435">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1436">            }</a>
<a name="ln1437">          } else {        /* UTF-8 */</a>
<a name="ln1438">            if (*--p &lt; 0x80)</a>
<a name="ln1439">              u8c = *p;</a>
<a name="ln1440">            else {</a>
<a name="ln1441">              len = utf_head_off(ptr, p);</a>
<a name="ln1442">              p -= len;</a>
<a name="ln1443">              u8c = utf_ptr2char(p);</a>
<a name="ln1444">              if (len == 0) {</a>
<a name="ln1445">                /* Not a valid UTF-8 character, retry with</a>
<a name="ln1446">                 * another fenc when possible, otherwise just</a>
<a name="ln1447">                 * report the error. */</a>
<a name="ln1448">                if (can_retry)</a>
<a name="ln1449">                  goto rewind_retry;</a>
<a name="ln1450">                if (conv_error == 0)</a>
<a name="ln1451">                  conv_error = readfile_linenr(linecnt,</a>
<a name="ln1452">                      ptr, p);</a>
<a name="ln1453">                if (bad_char_behavior == BAD_DROP)</a>
<a name="ln1454">                  continue;</a>
<a name="ln1455">                if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1456">                  u8c = bad_char_behavior;</a>
<a name="ln1457">              }</a>
<a name="ln1458">            }</a>
<a name="ln1459">          }</a>
<a name="ln1460">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1461">          // produce UTF-8</a>
<a name="ln1462">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1463">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1464">        }</a>
<a name="ln1465"> </a>
<a name="ln1466">        // move the linerest to before the converted characters</a>
<a name="ln1467">        line_start = dest - linerest;</a>
<a name="ln1468">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1469">        size = (long)((ptr + real_size) - dest);</a>
<a name="ln1470">        ptr = dest;</a>
<a name="ln1471">      } else if (enc_utf8 &amp;&amp; !curbuf-&gt;b_p_bin) {</a>
<a name="ln1472">        int incomplete_tail = FALSE;</a>
<a name="ln1473"> </a>
<a name="ln1474">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1475">        for (p = ptr;; p++) {</a>
<a name="ln1476">          int todo = (int)((ptr + size) - p);</a>
<a name="ln1477">          int l;</a>
<a name="ln1478"> </a>
<a name="ln1479">          if (todo &lt;= 0) {</a>
<a name="ln1480">            break;</a>
<a name="ln1481">          }</a>
<a name="ln1482">          if (*p &gt;= 0x80) {</a>
<a name="ln1483">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1484">            // an incomplete character at the end though, the next</a>
<a name="ln1485">            // read() will get the next bytes, we'll check it</a>
<a name="ln1486">            // then.</a>
<a name="ln1487">            l = utf_ptr2len_len(p, todo);</a>
<a name="ln1488">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1489">              /* Avoid retrying with a different encoding when</a>
<a name="ln1490">               * a truncated file is more likely, or attempting</a>
<a name="ln1491">               * to read the rest of an incomplete sequence when</a>
<a name="ln1492">               * we have already done so. */</a>
<a name="ln1493">              if (p &gt; ptr || filesize &gt; 0)</a>
<a name="ln1494">                incomplete_tail = TRUE;</a>
<a name="ln1495">              /* Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1496">               * and try to read the rest of it, unless we've</a>
<a name="ln1497">               * already done so. */</a>
<a name="ln1498">              if (p &gt; ptr) {</a>
<a name="ln1499">                conv_restlen = todo;</a>
<a name="ln1500">                memmove(conv_rest, p, conv_restlen);</a>
<a name="ln1501">                size -= conv_restlen;</a>
<a name="ln1502">                break;</a>
<a name="ln1503">              }</a>
<a name="ln1504">            }</a>
<a name="ln1505">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1506">              /* Illegal byte.  If we can try another encoding</a>
<a name="ln1507">               * do that, unless at EOF where a truncated</a>
<a name="ln1508">               * file is more likely than a conversion error. */</a>
<a name="ln1509">              if (can_retry &amp;&amp; !incomplete_tail)</a>
<a name="ln1510">                break;</a>
<a name="ln1511"># ifdef HAVE_ICONV</a>
<a name="ln1512">              // When we did a conversion report an error.</a>
<a name="ln1513">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1514">                conv_error = readfile_linenr(linecnt, ptr, p);</a>
<a name="ln1515">              }</a>
<a name="ln1516"># endif</a>
<a name="ln1517">              /* Remember the first linenr with an illegal byte */</a>
<a name="ln1518">              if (conv_error == 0 &amp;&amp; illegal_byte == 0)</a>
<a name="ln1519">                illegal_byte = readfile_linenr(linecnt, ptr, p);</a>
<a name="ln1520"> </a>
<a name="ln1521">              /* Drop, keep or replace the bad byte. */</a>
<a name="ln1522">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1523">                memmove(p, p + 1, todo - 1);</a>
<a name="ln1524">                --p;</a>
<a name="ln1525">                --size;</a>
<a name="ln1526">              } else if (bad_char_behavior != BAD_KEEP)</a>
<a name="ln1527">                *p = bad_char_behavior;</a>
<a name="ln1528">            } else</a>
<a name="ln1529">              p += l - 1;</a>
<a name="ln1530">          }</a>
<a name="ln1531">        }</a>
<a name="ln1532">        if (p &lt; ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1533">          /* Detected a UTF-8 error. */</a>
<a name="ln1534">rewind_retry:</a>
<a name="ln1535">          // Retry reading with another conversion.</a>
<a name="ln1536"># ifdef HAVE_ICONV</a>
<a name="ln1537">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1538">            // iconv() failed, try 'charconvert'</a>
<a name="ln1539">            did_iconv = true;</a>
<a name="ln1540">          } else {</a>
<a name="ln1541"># endif</a>
<a name="ln1542">          // use next item from 'fileencodings'</a>
<a name="ln1543">          advance_fenc = true;</a>
<a name="ln1544"># ifdef HAVE_ICONV</a>
<a name="ln1545">          }</a>
<a name="ln1546"># endif</a>
<a name="ln1547">          file_rewind = true;</a>
<a name="ln1548">          goto retry;</a>
<a name="ln1549">        }</a>
<a name="ln1550">      }</a>
<a name="ln1551"> </a>
<a name="ln1552">      /* count the number of characters (after conversion!) */</a>
<a name="ln1553">      filesize += size;</a>
<a name="ln1554"> </a>
<a name="ln1555">      /*</a>
<a name="ln1556">       * when reading the first part of a file: guess EOL type</a>
<a name="ln1557">       */</a>
<a name="ln1558">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1559">        /* First try finding a NL, for Dos and Unix */</a>
<a name="ln1560">        if (try_dos || try_unix) {</a>
<a name="ln1561">          // Reset the carriage return counter.</a>
<a name="ln1562">          if (try_mac) {</a>
<a name="ln1563">            try_mac = 1;</a>
<a name="ln1564">          }</a>
<a name="ln1565"> </a>
<a name="ln1566">          for (p = ptr; p &lt; ptr + size; ++p) {</a>
<a name="ln1567">            if (*p == NL) {</a>
<a name="ln1568">              if (!try_unix</a>
<a name="ln1569">                  || (try_dos &amp;&amp; p &gt; ptr &amp;&amp; p[-1] == CAR))</a>
<a name="ln1570">                fileformat = EOL_DOS;</a>
<a name="ln1571">              else</a>
<a name="ln1572">                fileformat = EOL_UNIX;</a>
<a name="ln1573">              break;</a>
<a name="ln1574">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1575">              try_mac++;</a>
<a name="ln1576">            }</a>
<a name="ln1577">          }</a>
<a name="ln1578"> </a>
<a name="ln1579">          /* Don't give in to EOL_UNIX if EOL_MAC is more likely */</a>
<a name="ln1580">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1581">            /* Need to reset the counters when retrying fenc. */</a>
<a name="ln1582">            try_mac = 1;</a>
<a name="ln1583">            try_unix = 1;</a>
<a name="ln1584">            for (; p &gt;= ptr &amp;&amp; *p != CAR; p--)</a>
<a name="ln1585">              ;</a>
<a name="ln1586">            if (p &gt;= ptr) {</a>
<a name="ln1587">              for (p = ptr; p &lt; ptr + size; ++p) {</a>
<a name="ln1588">                if (*p == NL)</a>
<a name="ln1589">                  try_unix++;</a>
<a name="ln1590">                else if (*p == CAR)</a>
<a name="ln1591">                  try_mac++;</a>
<a name="ln1592">              }</a>
<a name="ln1593">              if (try_mac &gt; try_unix)</a>
<a name="ln1594">                fileformat = EOL_MAC;</a>
<a name="ln1595">            }</a>
<a name="ln1596">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1597">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1598">            // use the default format.</a>
<a name="ln1599">            fileformat = default_fileformat();</a>
<a name="ln1600">          }</a>
<a name="ln1601">        }</a>
<a name="ln1602"> </a>
<a name="ln1603">        /* No NL found: may use Mac format */</a>
<a name="ln1604">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac)</a>
<a name="ln1605">          fileformat = EOL_MAC;</a>
<a name="ln1606"> </a>
<a name="ln1607">        /* Still nothing found?  Use first format in 'ffs' */</a>
<a name="ln1608">        if (fileformat == EOL_UNKNOWN)</a>
<a name="ln1609">          fileformat = default_fileformat();</a>
<a name="ln1610"> </a>
<a name="ln1611">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1612">        if (set_options) {</a>
<a name="ln1613">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1614">        }</a>
<a name="ln1615">      }</a>
<a name="ln1616">    }</a>
<a name="ln1617"> </a>
<a name="ln1618">    /*</a>
<a name="ln1619">     * This loop is executed once for every character read.</a>
<a name="ln1620">     * Keep it fast!</a>
<a name="ln1621">     */</a>
<a name="ln1622">    if (fileformat == EOL_MAC) {</a>
<a name="ln1623">      --ptr;</a>
<a name="ln1624">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1625">        /* catch most common case first */</a>
<a name="ln1626">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL)</a>
<a name="ln1627">          continue;</a>
<a name="ln1628">        if (c == NUL)</a>
<a name="ln1629">          *ptr = NL;            /* NULs are replaced by newlines! */</a>
<a name="ln1630">        else if (c == NL)</a>
<a name="ln1631">          *ptr = CAR;           /* NLs are replaced by CRs! */</a>
<a name="ln1632">        else {</a>
<a name="ln1633">          if (skip_count == 0) {</a>
<a name="ln1634">            *ptr = NUL;                     /* end of line */</a>
<a name="ln1635">            len = (colnr_T) (ptr - line_start + 1);</a>
<a name="ln1636">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1637">              error = TRUE;</a>
<a name="ln1638">              break;</a>
<a name="ln1639">            }</a>
<a name="ln1640">            if (read_undo_file)</a>
<a name="ln1641">              sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1642">            ++lnum;</a>
<a name="ln1643">            if (--read_count == 0) {</a>
<a name="ln1644">              error = TRUE;                     /* break loop */</a>
<a name="ln1645">              line_start = ptr;                 /* nothing left to write */</a>
<a name="ln1646">              break;</a>
<a name="ln1647">            }</a>
<a name="ln1648">          } else</a>
<a name="ln1649">            --skip_count;</a>
<a name="ln1650">          line_start = ptr + 1;</a>
<a name="ln1651">        }</a>
<a name="ln1652">      }</a>
<a name="ln1653">    } else {</a>
<a name="ln1654">      --ptr;</a>
<a name="ln1655">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1656">        if ((c = *ptr) != NUL &amp;&amp; c != NL)          /* catch most common case */</a>
<a name="ln1657">          continue;</a>
<a name="ln1658">        if (c == NUL)</a>
<a name="ln1659">          *ptr = NL;            /* NULs are replaced by newlines! */</a>
<a name="ln1660">        else {</a>
<a name="ln1661">          if (skip_count == 0) {</a>
<a name="ln1662">            *ptr = NUL;                         /* end of line */</a>
<a name="ln1663">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1664">            if (fileformat == EOL_DOS) {</a>
<a name="ln1665">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1666">                // remove CR before NL</a>
<a name="ln1667">                ptr[-1] = NUL;</a>
<a name="ln1668">                len--;</a>
<a name="ln1669">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1670">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1671">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1672">                // the lines read so far and start all over again.</a>
<a name="ln1673">                // Otherwise give an error message later.</a>
<a name="ln1674">                if (try_unix</a>
<a name="ln1675">                    &amp;&amp; !read_stdin</a>
<a name="ln1676">                    &amp;&amp; (read_buffer</a>
<a name="ln1677">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1678">                  fileformat = EOL_UNIX;</a>
<a name="ln1679">                  if (set_options)</a>
<a name="ln1680">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1681">                  file_rewind = true;</a>
<a name="ln1682">                  keep_fileformat = true;</a>
<a name="ln1683">                  goto retry;</a>
<a name="ln1684">                }</a>
<a name="ln1685">                ff_error = EOL_DOS;</a>
<a name="ln1686">              }</a>
<a name="ln1687">            }</a>
<a name="ln1688">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1689">              error = TRUE;</a>
<a name="ln1690">              break;</a>
<a name="ln1691">            }</a>
<a name="ln1692">            if (read_undo_file)</a>
<a name="ln1693">              sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1694">            ++lnum;</a>
<a name="ln1695">            if (--read_count == 0) {</a>
<a name="ln1696">              error = TRUE;                         /* break loop */</a>
<a name="ln1697">              line_start = ptr;                 /* nothing left to write */</a>
<a name="ln1698">              break;</a>
<a name="ln1699">            }</a>
<a name="ln1700">          } else</a>
<a name="ln1701">            --skip_count;</a>
<a name="ln1702">          line_start = ptr + 1;</a>
<a name="ln1703">        }</a>
<a name="ln1704">      }</a>
<a name="ln1705">    }</a>
<a name="ln1706">    linerest = (long)(ptr - line_start);</a>
<a name="ln1707">    os_breakcheck();</a>
<a name="ln1708">  }</a>
<a name="ln1709"> </a>
<a name="ln1710">failed:</a>
<a name="ln1711">  /* not an error, max. number of lines reached */</a>
<a name="ln1712">  if (error &amp;&amp; read_count == 0)</a>
<a name="ln1713">    error = FALSE;</a>
<a name="ln1714"> </a>
<a name="ln1715">  /*</a>
<a name="ln1716">   * If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1717">   * complete the line ourselves.</a>
<a name="ln1718">   * In Dos format ignore a trailing CTRL-Z, unless 'binary' set.</a>
<a name="ln1719">   */</a>
<a name="ln1720">  if (!error</a>
<a name="ln1721">      &amp;&amp; !got_int</a>
<a name="ln1722">      &amp;&amp; linerest != 0</a>
<a name="ln1723">      &amp;&amp; !(!curbuf-&gt;b_p_bin</a>
<a name="ln1724">           &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1725">           &amp;&amp; *line_start == Ctrl_Z</a>
<a name="ln1726">           &amp;&amp; ptr == line_start + 1)) {</a>
<a name="ln1727">    /* remember for when writing */</a>
<a name="ln1728">    if (set_options)</a>
<a name="ln1729">      curbuf-&gt;b_p_eol = FALSE;</a>
<a name="ln1730">    *ptr = NUL;</a>
<a name="ln1731">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1732">    if (ml_append(lnum, line_start, len, newfile) == FAIL)</a>
<a name="ln1733">      error = TRUE;</a>
<a name="ln1734">    else {</a>
<a name="ln1735">      if (read_undo_file)</a>
<a name="ln1736">        sha256_update(&amp;sha_ctx, line_start, len);</a>
<a name="ln1737">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1738">    }</a>
<a name="ln1739">  }</a>
<a name="ln1740"> </a>
<a name="ln1741">  if (set_options) {</a>
<a name="ln1742">    // Remember the current file format.</a>
<a name="ln1743">    save_file_ff(curbuf);</a>
<a name="ln1744">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1745">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1746">    set_string_option_direct((char_u *)&quot;fenc&quot;, -1, fenc,</a>
<a name="ln1747">        OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1748">  }</a>
<a name="ln1749">  if (fenc_alloced)</a>
<a name="ln1750">    xfree(fenc);</a>
<a name="ln1751"># ifdef HAVE_ICONV</a>
<a name="ln1752">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1753">    iconv_close(iconv_fd);</a>
<a name="ln1754">#  ifndef __clang_analyzer__</a>
<a name="ln1755">    iconv_fd = (iconv_t)-1;</a>
<a name="ln1756">#  endif</a>
<a name="ln1757">  }</a>
<a name="ln1758"># endif</a>
<a name="ln1759"> </a>
<a name="ln1760">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1761">    close(fd);  // errors are ignored</a>
<a name="ln1762">  } else {</a>
<a name="ln1763">    (void)os_set_cloexec(fd);</a>
<a name="ln1764">  }</a>
<a name="ln1765">  xfree(buffer);</a>
<a name="ln1766"> </a>
<a name="ln1767">  if (read_stdin) {</a>
<a name="ln1768">    close(0);</a>
<a name="ln1769">#ifndef WIN32</a>
<a name="ln1770">    // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1771">    vim_ignored = dup(2);</a>
<a name="ln1772">#else</a>
<a name="ln1773">    // On Windows, use the console input handle for stdin.</a>
<a name="ln1774">    HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1775">                              FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1776">                              OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1777">    vim_ignored = _open_osfhandle(conin, _O_RDONLY);</a>
<a name="ln1778">#endif</a>
<a name="ln1779">  }</a>
<a name="ln1780"> </a>
<a name="ln1781">  if (tmpname != NULL) {</a>
<a name="ln1782">    os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln1783">    xfree(tmpname);</a>
<a name="ln1784">  }</a>
<a name="ln1785">  --no_wait_return;                     /* may wait for return now */</a>
<a name="ln1786"> </a>
<a name="ln1787">  /*</a>
<a name="ln1788">   * In recovery mode everything but autocommands is skipped.</a>
<a name="ln1789">   */</a>
<a name="ln1790">  if (!recoverymode) {</a>
<a name="ln1791">    /* need to delete the last line, which comes from the empty buffer */</a>
<a name="ln1792">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1793">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1794">      linecnt--;</a>
<a name="ln1795">    }</a>
<a name="ln1796">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1797">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1798">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1799">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1800">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1801">    if (filesize == 0)</a>
<a name="ln1802">      linecnt = 0;</a>
<a name="ln1803">    if (newfile || read_buffer) {</a>
<a name="ln1804">      redraw_curbuf_later(NOT_VALID);</a>
<a name="ln1805">      /* After reading the text into the buffer the diff info needs to</a>
<a name="ln1806">       * be updated. */</a>
<a name="ln1807">      diff_invalidate(curbuf);</a>
<a name="ln1808">      /* All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1809">       * before triggering autocommands. */</a>
<a name="ln1810">      foldUpdateAll(curwin);</a>
<a name="ln1811">    } else if (linecnt)                 /* appended at least one line */</a>
<a name="ln1812">      appended_lines_mark(from, linecnt);</a>
<a name="ln1813"> </a>
<a name="ln1814">    /*</a>
<a name="ln1815">     * If we were reading from the same terminal as where messages go,</a>
<a name="ln1816">     * the screen will have been messed up.</a>
<a name="ln1817">     * Switch on raw mode now and clear the screen.</a>
<a name="ln1818">     */</a>
<a name="ln1819">    if (read_stdin) {</a>
<a name="ln1820">      screenclear();</a>
<a name="ln1821">    }</a>
<a name="ln1822"> </a>
<a name="ln1823">    if (got_int) {</a>
<a name="ln1824">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1825">        filemess(curbuf, sfname, (char_u *)_(e_interr), 0);</a>
<a name="ln1826">        if (newfile)</a>
<a name="ln1827">          curbuf-&gt;b_p_ro = TRUE;                /* must use &quot;w!&quot; now */</a>
<a name="ln1828">      }</a>
<a name="ln1829">      msg_scroll = msg_save;</a>
<a name="ln1830">      check_marks_read();</a>
<a name="ln1831">      return OK;                /* an interrupt isn't really an error */</a>
<a name="ln1832">    }</a>
<a name="ln1833"> </a>
<a name="ln1834">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln1835">      add_quoted_fname((char *)IObuff, IOSIZE, curbuf, (const char *)sfname);</a>
<a name="ln1836">      c = false;</a>
<a name="ln1837"> </a>
<a name="ln1838">#ifdef UNIX</a>
<a name="ln1839">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1840">        STRCAT(IObuff, _(&quot;[fifo]&quot;));</a>
<a name="ln1841">        c = TRUE;</a>
<a name="ln1842">      }</a>
<a name="ln1843">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1844">        STRCAT(IObuff, _(&quot;[socket]&quot;));</a>
<a name="ln1845">        c = TRUE;</a>
<a name="ln1846">      }</a>
<a name="ln1847"># ifdef OPEN_CHR_FILES</a>
<a name="ln1848">      if (S_ISCHR(perm)) {                          /* or character special */</a>
<a name="ln1849">        STRCAT(IObuff, _(&quot;[character special]&quot;));</a>
<a name="ln1850">        c = TRUE;</a>
<a name="ln1851">      }</a>
<a name="ln1852"># endif</a>
<a name="ln1853">#endif</a>
<a name="ln1854">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1855">        STRCAT(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;));</a>
<a name="ln1856">        c = TRUE;</a>
<a name="ln1857">      }</a>
<a name="ln1858">      if (read_no_eol_lnum) {</a>
<a name="ln1859">        msg_add_eol();</a>
<a name="ln1860">        c = TRUE;</a>
<a name="ln1861">      }</a>
<a name="ln1862">      if (ff_error == EOL_DOS) {</a>
<a name="ln1863">        STRCAT(IObuff, _(&quot;[CR missing]&quot;));</a>
<a name="ln1864">        c = TRUE;</a>
<a name="ln1865">      }</a>
<a name="ln1866">      if (split) {</a>
<a name="ln1867">        STRCAT(IObuff, _(&quot;[long lines split]&quot;));</a>
<a name="ln1868">        c = true;</a>
<a name="ln1869">      }</a>
<a name="ln1870">      if (notconverted) {</a>
<a name="ln1871">        STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln1872">        c = TRUE;</a>
<a name="ln1873">      } else if (converted) {</a>
<a name="ln1874">        STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln1875">        c = TRUE;</a>
<a name="ln1876">      }</a>
<a name="ln1877">      if (conv_error != 0) {</a>
<a name="ln1878">        sprintf((char *)IObuff + STRLEN(IObuff),</a>
<a name="ln1879">            _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1880">        c = TRUE;</a>
<a name="ln1881">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1882">        sprintf((char *)IObuff + STRLEN(IObuff),</a>
<a name="ln1883">            _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1884">        c = TRUE;</a>
<a name="ln1885">      } else if (error)  {</a>
<a name="ln1886">        STRCAT(IObuff, _(&quot;[READ ERRORS]&quot;));</a>
<a name="ln1887">        c = TRUE;</a>
<a name="ln1888">      }</a>
<a name="ln1889">      if (msg_add_fileformat(fileformat))</a>
<a name="ln1890">        c = TRUE;</a>
<a name="ln1891"> </a>
<a name="ln1892">      msg_add_lines(c, (long)linecnt, filesize);</a>
<a name="ln1893"> </a>
<a name="ln1894">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1895">      p = NULL;</a>
<a name="ln1896">      msg_scrolled_ign = TRUE;</a>
<a name="ln1897"> </a>
<a name="ln1898">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1899">        p = msg_trunc_attr(IObuff, FALSE, 0);</a>
<a name="ln1900">      }</a>
<a name="ln1901"> </a>
<a name="ln1902">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1903">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1904">        // Need to repeat the message after redrawing when:</a>
<a name="ln1905">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1906">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1907">        //   redrawing).</a>
<a name="ln1908">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1909">        set_keep_msg(p, 0);</a>
<a name="ln1910">      }</a>
<a name="ln1911">      msg_scrolled_ign = FALSE;</a>
<a name="ln1912">    }</a>
<a name="ln1913"> </a>
<a name="ln1914">    /* with errors writing the file requires &quot;:w!&quot; */</a>
<a name="ln1915">    if (newfile &amp;&amp; (error</a>
<a name="ln1916">                    || conv_error != 0</a>
<a name="ln1917">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP)</a>
<a name="ln1918">                    ))</a>
<a name="ln1919">      curbuf-&gt;b_p_ro = TRUE;</a>
<a name="ln1920"> </a>
<a name="ln1921">    u_clearline();          /* cannot use &quot;U&quot; command after adding lines */</a>
<a name="ln1922"> </a>
<a name="ln1923">    /*</a>
<a name="ln1924">     * In Ex mode: cursor at last new line.</a>
<a name="ln1925">     * Otherwise: cursor at first new line.</a>
<a name="ln1926">     */</a>
<a name="ln1927">    if (exmode_active)</a>
<a name="ln1928">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1929">    else</a>
<a name="ln1930">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1931">    check_cursor_lnum();</a>
<a name="ln1932">    beginline(BL_WHITE | BL_FIX);           /* on first non-blank */</a>
<a name="ln1933"> </a>
<a name="ln1934">    /*</a>
<a name="ln1935">     * Set '[ and '] marks to the newly read lines.</a>
<a name="ln1936">     */</a>
<a name="ln1937">    curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1938">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1939">    curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1940">    curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1941"> </a>
<a name="ln1942">  }</a>
<a name="ln1943">  msg_scroll = msg_save;</a>
<a name="ln1944"> </a>
<a name="ln1945">  /*</a>
<a name="ln1946">   * Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1947">   */</a>
<a name="ln1948">  check_marks_read();</a>
<a name="ln1949"> </a>
<a name="ln1950">  /*</a>
<a name="ln1951">   * We remember if the last line of the read didn't have</a>
<a name="ln1952">   * an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1953">   * or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1954">   * for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1955">   */</a>
<a name="ln1956">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1957"> </a>
<a name="ln1958">  /* When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1959">   * different. */</a>
<a name="ln1960">  if (flags &amp; READ_KEEP_UNDO)</a>
<a name="ln1961">    u_find_first_changed();</a>
<a name="ln1962"> </a>
<a name="ln1963">  /*</a>
<a name="ln1964">   * When opening a new file locate undo info and read it.</a>
<a name="ln1965">   */</a>
<a name="ln1966">  if (read_undo_file) {</a>
<a name="ln1967">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln1968"> </a>
<a name="ln1969">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1970">    u_read_undo(NULL, hash, fname);</a>
<a name="ln1971">  }</a>
<a name="ln1972"> </a>
<a name="ln1973">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1974">    int m = msg_scroll;</a>
<a name="ln1975">    int n = msg_scrolled;</a>
<a name="ln1976"> </a>
<a name="ln1977">    /* Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1978">     * modified if the format/encoding was automatically detected. */</a>
<a name="ln1979">    if (set_options)</a>
<a name="ln1980">      save_file_ff(curbuf);</a>
<a name="ln1981"> </a>
<a name="ln1982">    /*</a>
<a name="ln1983">     * The output from the autocommands should not overwrite anything and</a>
<a name="ln1984">     * should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1985">     * output was done.</a>
<a name="ln1986">     */</a>
<a name="ln1987">    msg_scroll = true;</a>
<a name="ln1988">    if (filtering) {</a>
<a name="ln1989">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1990">                           false, curbuf, eap);</a>
<a name="ln1991">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1992">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1993">                           false, curbuf, eap);</a>
<a name="ln1994">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1995">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1996">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1997">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname,</a>
<a name="ln1998">                       true, curbuf);</a>
<a name="ln1999">      }</a>
<a name="ln2000">    } else {</a>
<a name="ln2001">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln2002">                           false, NULL, eap);</a>
<a name="ln2003">    }</a>
<a name="ln2004">    if (msg_scrolled == n) {</a>
<a name="ln2005">      msg_scroll = m;</a>
<a name="ln2006">    }</a>
<a name="ln2007">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln2008">      return FAIL;</a>
<a name="ln2009">    }</a>
<a name="ln2010">  }</a>
<a name="ln2011"> </a>
<a name="ln2012">  if (recoverymode &amp;&amp; error)</a>
<a name="ln2013">    return FAIL;</a>
<a name="ln2014">  return OK;</a>
<a name="ln2015">}</a>
<a name="ln2016"> </a>
<a name="ln2017">#ifdef OPEN_CHR_FILES</a>
<a name="ln2018">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln2019">/// which is the name of files used for process substitution output by</a>
<a name="ln2020">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln2021">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln2022">///</a>
<a name="ln2023">/// @param fname file name to check</a>
<a name="ln2024">bool is_dev_fd_file(char_u *fname)</a>
<a name="ln2025">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2026">{</a>
<a name="ln2027">  return STRNCMP(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln2028">         &amp;&amp; ascii_isdigit(fname[8])</a>
<a name="ln2029">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln2030">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln2031">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln2032">}</a>
<a name="ln2033">#endif</a>
<a name="ln2034"> </a>
<a name="ln2035"> </a>
<a name="ln2036">/*</a>
<a name="ln2037"> * From the current line count and characters read after that, estimate the</a>
<a name="ln2038"> * line number where we are now.</a>
<a name="ln2039"> * Used for error messages that include a line number.</a>
<a name="ln2040"> */</a>
<a name="ln2041">static linenr_T</a>
<a name="ln2042">readfile_linenr(</a>
<a name="ln2043">    linenr_T linecnt,         // line count before reading more bytes</a>
<a name="ln2044">    char_u *p,                // start of more bytes read</a>
<a name="ln2045">    char_u *endp              // end of more bytes read</a>
<a name="ln2046">)</a>
<a name="ln2047">{</a>
<a name="ln2048">  char_u      *s;</a>
<a name="ln2049">  linenr_T lnum;</a>
<a name="ln2050"> </a>
<a name="ln2051">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln2052">  for (s = p; s &lt; endp; ++s)</a>
<a name="ln2053">    if (*s == '\n')</a>
<a name="ln2054">      ++lnum;</a>
<a name="ln2055">  return lnum;</a>
<a name="ln2056">}</a>
<a name="ln2057"> </a>
<a name="ln2058">/*</a>
<a name="ln2059"> * Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary to be</a>
<a name="ln2060"> * equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln2061"> */</a>
<a name="ln2062">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln2063">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2064">{</a>
<a name="ln2065">  const size_t cmd_len = 15 + STRLEN(buf-&gt;b_p_fenc);</a>
<a name="ln2066">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln2067"> </a>
<a name="ln2068">  snprintf((char *)eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln2069">  eap-&gt;force_enc = 8;</a>
<a name="ln2070">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln2071">  eap-&gt;force_ff = *buf-&gt;b_p_ff;</a>
<a name="ln2072"> </a>
<a name="ln2073">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln2074">  eap-&gt;read_edit = FALSE;</a>
<a name="ln2075">  eap-&gt;forceit = FALSE;</a>
<a name="ln2076">}</a>
<a name="ln2077"> </a>
<a name="ln2078">/*</a>
<a name="ln2079"> * Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln2080"> */</a>
<a name="ln2081">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln2082">{</a>
<a name="ln2083">  /* set default 'fileformat' */</a>
<a name="ln2084">  if (set_options) {</a>
<a name="ln2085">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0)</a>
<a name="ln2086">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln2087">    else if (*p_ffs != NUL)</a>
<a name="ln2088">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln2089">  }</a>
<a name="ln2090"> </a>
<a name="ln2091">  /* set or reset 'binary' */</a>
<a name="ln2092">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln2093">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln2094"> </a>
<a name="ln2095">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln2096">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln2097">  }</a>
<a name="ln2098">}</a>
<a name="ln2099"> </a>
<a name="ln2100">/*</a>
<a name="ln2101"> * Set forced 'fileencoding'.</a>
<a name="ln2102"> */</a>
<a name="ln2103">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln2104">{</a>
<a name="ln2105">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln2106">    char_u *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln2107">    set_string_option_direct((char_u *)&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln2108">    xfree(fenc);</a>
<a name="ln2109">  }</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln2113">// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln2114">// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln2115">// NULL.</a>
<a name="ln2116">// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln2117">// is set to true.</a>
<a name="ln2118">static char_u *next_fenc(char_u **pp, bool *alloced)</a>
<a name="ln2119">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2120">{</a>
<a name="ln2121">  char_u      *p;</a>
<a name="ln2122">  char_u      *r;</a>
<a name="ln2123"> </a>
<a name="ln2124">  *alloced = false;</a>
<a name="ln2125">  if (**pp == NUL) {</a>
<a name="ln2126">    *pp = NULL;</a>
<a name="ln2127">    return (char_u *)&quot;&quot;;</a>
<a name="ln2128">  }</a>
<a name="ln2129">  p = vim_strchr(*pp, ',');</a>
<a name="ln2130">  if (p == NULL) {</a>
<a name="ln2131">    r = enc_canonize(*pp);</a>
<a name="ln2132">    *pp += STRLEN(*pp);</a>
<a name="ln2133">  } else {</a>
<a name="ln2134">    r = vim_strnsave(*pp, (int)(p - *pp));</a>
<a name="ln2135">    *pp = p + 1;</a>
<a name="ln2136">    p = enc_canonize(r);</a>
<a name="ln2137">    xfree(r);</a>
<a name="ln2138">    r = p;</a>
<a name="ln2139">  }</a>
<a name="ln2140">  *alloced = true;</a>
<a name="ln2141">  return r;</a>
<a name="ln2142">}</a>
<a name="ln2143"> </a>
<a name="ln2144">/*</a>
<a name="ln2145"> * Convert a file with the 'charconvert' expression.</a>
<a name="ln2146"> * This closes the file which is to be read, converts it and opens the</a>
<a name="ln2147"> * resulting file for reading.</a>
<a name="ln2148"> * Returns name of the resulting converted file (the caller should delete it</a>
<a name="ln2149"> * after reading it).</a>
<a name="ln2150"> * Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2151"> */</a>
<a name="ln2152">static char_u *</a>
<a name="ln2153">readfile_charconvert (</a>
<a name="ln2154">    char_u *fname,             /* name of input file */</a>
<a name="ln2155">    char_u *fenc,              /* converted from */</a>
<a name="ln2156">    int *fdp               /* in/out: file descriptor of file */</a>
<a name="ln2157">)</a>
<a name="ln2158">{</a>
<a name="ln2159">  char_u      *tmpname;</a>
<a name="ln2160">  char_u      *errmsg = NULL;</a>
<a name="ln2161"> </a>
<a name="ln2162">  tmpname = vim_tempname();</a>
<a name="ln2163">  if (tmpname == NULL)</a>
<a name="ln2164">    errmsg = (char_u *)_(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2165">  else {</a>
<a name="ln2166">    close(*fdp);                /* close the input file, ignore errors */</a>
<a name="ln2167">    *fdp = -1;</a>
<a name="ln2168">    if (eval_charconvert((char *) fenc, enc_utf8 ? &quot;utf-8&quot; : (char *) p_enc,</a>
<a name="ln2169">                         (char *) fname, (char *) tmpname) == FAIL) {</a>
<a name="ln2170">      errmsg = (char_u *)_(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2171">    }</a>
<a name="ln2172">    if (errmsg == NULL &amp;&amp; (*fdp = os_open((char *)tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2173">      errmsg = (char_u *)_(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2174">    }</a>
<a name="ln2175">  }</a>
<a name="ln2176"> </a>
<a name="ln2177">  if (errmsg != NULL) {</a>
<a name="ln2178">    /* Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2179">     * another type of conversion might still work. */</a>
<a name="ln2180">    MSG(errmsg);</a>
<a name="ln2181">    if (tmpname != NULL) {</a>
<a name="ln2182">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln2183">      XFREE_CLEAR(tmpname);</a>
<a name="ln2184">    }</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  /* If the input file is closed, open it (caller should check for error). */</a>
<a name="ln2188">  if (*fdp &lt; 0) {</a>
<a name="ln2189">    *fdp = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln2190">  }</a>
<a name="ln2191"> </a>
<a name="ln2192">  return tmpname;</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195"> </a>
<a name="ln2196">/*</a>
<a name="ln2197"> * Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2198"> * buffer marks and the buffer has a name.</a>
<a name="ln2199"> */</a>
<a name="ln2200">static void check_marks_read(void)</a>
<a name="ln2201">{</a>
<a name="ln2202">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2203">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2204">    shada_read_marks();</a>
<a name="ln2205">  }</a>
<a name="ln2206"> </a>
<a name="ln2207">  /* Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2208">   * the ' parameter after opening a buffer. */</a>
<a name="ln2209">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">char *new_file_message(void)</a>
<a name="ln2213">{</a>
<a name="ln2214">  return shortmess(SHM_NEW) ? _(&quot;[New]&quot;) : _(&quot;[New File]&quot;);</a>
<a name="ln2215">}</a>
<a name="ln2216"> </a>
<a name="ln2217">/*</a>
<a name="ln2218"> * buf_write() - write to file &quot;fname&quot; lines &quot;start&quot; through &quot;end&quot;</a>
<a name="ln2219"> *</a>
<a name="ln2220"> * We do our own buffering here because fwrite() is so slow.</a>
<a name="ln2221"> *</a>
<a name="ln2222"> * If &quot;forceit&quot; is true, we don't care for errors when attempting backups.</a>
<a name="ln2223"> * In case of an error everything possible is done to restore the original</a>
<a name="ln2224"> * file.  But when &quot;forceit&quot; is TRUE, we risk losing it.</a>
<a name="ln2225"> *</a>
<a name="ln2226"> * When &quot;reset_changed&quot; is TRUE and &quot;append&quot; == FALSE and &quot;start&quot; == 1 and</a>
<a name="ln2227"> * &quot;end&quot; == curbuf-&gt;b_ml.ml_line_count, reset curbuf-&gt;b_changed.</a>
<a name="ln2228"> *</a>
<a name="ln2229"> * This function must NOT use NameBuff (because it's called by autowrite()).</a>
<a name="ln2230"> *</a>
<a name="ln2231"> * return FAIL for failure, OK otherwise</a>
<a name="ln2232"> */</a>
<a name="ln2233">int</a>
<a name="ln2234">buf_write(</a>
<a name="ln2235">    buf_T *buf,</a>
<a name="ln2236">    char_u *fname,</a>
<a name="ln2237">    char_u *sfname,</a>
<a name="ln2238">    linenr_T start,</a>
<a name="ln2239">    linenr_T end,</a>
<a name="ln2240">    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be</a>
<a name="ln2241">                                           NULL! */</a>
<a name="ln2242">    int append,                             /* append to the file */</a>
<a name="ln2243">    int forceit,</a>
<a name="ln2244">    int reset_changed,</a>
<a name="ln2245">    int filtering</a>
<a name="ln2246">)</a>
<a name="ln2247">{</a>
<a name="ln2248">  int fd;</a>
<a name="ln2249">  char_u          *backup = NULL;</a>
<a name="ln2250">  int backup_copy = FALSE;               /* copy the original file? */</a>
<a name="ln2251">  int dobackup;</a>
<a name="ln2252">  char_u          *ffname;</a>
<a name="ln2253">  char_u          *wfname = NULL;       /* name of file to write to */</a>
<a name="ln2254">  char_u          *s;</a>
<a name="ln2255">  char_u          *ptr;</a>
<a name="ln2256">  char_u c;</a>
<a name="ln2257">  int len;</a>
<a name="ln2258">  linenr_T lnum;</a>
<a name="ln2259">  long nchars;</a>
<a name="ln2260">#define SET_ERRMSG_NUM(num, msg) \</a>
<a name="ln2261">  errnum = num, errmsg = msg, errmsgarg = 0</a>
<a name="ln2262">#define SET_ERRMSG_ARG(msg, error) \</a>
<a name="ln2263">  errnum = NULL, errmsg = msg, errmsgarg = error</a>
<a name="ln2264">#define SET_ERRMSG(msg) \</a>
<a name="ln2265">  errnum = NULL, errmsg = msg, errmsgarg = 0</a>
<a name="ln2266">  const char *errnum = NULL;</a>
<a name="ln2267">  char *errmsg = NULL;</a>
<a name="ln2268">  int errmsgarg = 0;</a>
<a name="ln2269">  bool errmsg_allocated = false;</a>
<a name="ln2270">  char_u          *buffer;</a>
<a name="ln2271">  char_u smallbuf[SMBUFSIZE];</a>
<a name="ln2272">  char_u          *backup_ext;</a>
<a name="ln2273">  int bufsize;</a>
<a name="ln2274">  long perm;                                // file permissions</a>
<a name="ln2275">  int retval = OK;</a>
<a name="ln2276">  int newfile = false;                      // TRUE if file doesn't exist yet</a>
<a name="ln2277">  int msg_save = msg_scroll;</a>
<a name="ln2278">  int overwriting;                          // TRUE if writing over original</a>
<a name="ln2279">  int no_eol = false;                       // no end-of-line written</a>
<a name="ln2280">  int device = false;                       // writing to a device</a>
<a name="ln2281">  int prev_got_int = got_int;</a>
<a name="ln2282">  int checking_conversion;</a>
<a name="ln2283">  bool file_readonly = false;               // overwritten file is read-only</a>
<a name="ln2284">  static char     *err_readonly =</a>
<a name="ln2285">    &quot;is read-only (cannot override: \&quot;W\&quot; in 'cpoptions')&quot;;</a>
<a name="ln2286">#if defined(UNIX)</a>
<a name="ln2287">  int made_writable = FALSE;                /* 'w' bit has been set */</a>
<a name="ln2288">#endif</a>
<a name="ln2289">  /* writing everything */</a>
<a name="ln2290">  int whole = (start == 1 &amp;&amp; end == buf-&gt;b_ml.ml_line_count);</a>
<a name="ln2291">  linenr_T old_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2292">  int fileformat;</a>
<a name="ln2293">  int write_bin;</a>
<a name="ln2294">  struct bw_info write_info;            /* info for buf_write_bytes() */</a>
<a name="ln2295">  int converted = FALSE;</a>
<a name="ln2296">  int notconverted = FALSE;</a>
<a name="ln2297">  char_u          *fenc;                /* effective 'fileencoding' */</a>
<a name="ln2298">  char_u          *fenc_tofree = NULL;   /* allocated &quot;fenc&quot; */</a>
<a name="ln2299">#ifdef HAS_BW_FLAGS</a>
<a name="ln2300">  int wb_flags = 0;</a>
<a name="ln2301">#endif</a>
<a name="ln2302">#ifdef HAVE_ACL</a>
<a name="ln2303">  vim_acl_T acl = NULL;                 /* ACL copied from original file to</a>
<a name="ln2304">                                           backup or new file */</a>
<a name="ln2305">#endif</a>
<a name="ln2306">  int write_undo_file = FALSE;</a>
<a name="ln2307">  context_sha256_T sha_ctx;</a>
<a name="ln2308">  unsigned int bkc = get_bkc_value(buf);</a>
<a name="ln2309"> </a>
<a name="ln2310">  if (fname == NULL || *fname == NUL)   /* safety check */</a>
<a name="ln2311">    return FAIL;</a>
<a name="ln2312">  if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2313">    /* This can happen during startup when there is a stray &quot;w&quot; in the</a>
<a name="ln2314">     * vimrc file. */</a>
<a name="ln2315">    EMSG(_(e_emptybuf));</a>
<a name="ln2316">    return FAIL;</a>
<a name="ln2317">  }</a>
<a name="ln2318"> </a>
<a name="ln2319">  /*</a>
<a name="ln2320">   * Disallow writing from .exrc and .vimrc in current directory for</a>
<a name="ln2321">   * security reasons.</a>
<a name="ln2322">   */</a>
<a name="ln2323">  if (check_secure())</a>
<a name="ln2324">    return FAIL;</a>
<a name="ln2325"> </a>
<a name="ln2326">  /* Avoid a crash for a long name. */</a>
<a name="ln2327">  if (STRLEN(fname) &gt;= MAXPATHL) {</a>
<a name="ln2328">    EMSG(_(e_longname));</a>
<a name="ln2329">    return FAIL;</a>
<a name="ln2330">  }</a>
<a name="ln2331"> </a>
<a name="ln2332">  /* must init bw_conv_buf and bw_iconv_fd before jumping to &quot;fail&quot; */</a>
<a name="ln2333">  write_info.bw_conv_buf = NULL;</a>
<a name="ln2334">  write_info.bw_conv_error = FALSE;</a>
<a name="ln2335">  write_info.bw_conv_error_lnum = 0;</a>
<a name="ln2336">  write_info.bw_restlen = 0;</a>
<a name="ln2337"># ifdef HAVE_ICONV</a>
<a name="ln2338">  write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln2339"># endif</a>
<a name="ln2340"> </a>
<a name="ln2341">  /* After writing a file changedtick changes but we don't want to display</a>
<a name="ln2342">   * the line. */</a>
<a name="ln2343">  ex_no_reprint = TRUE;</a>
<a name="ln2344"> </a>
<a name="ln2345">  /*</a>
<a name="ln2346">   * If there is no file name yet, use the one for the written file.</a>
<a name="ln2347">   * BF_NOTEDITED is set to reflect this (in case the write fails).</a>
<a name="ln2348">   * Don't do this when the write is for a filter command.</a>
<a name="ln2349">   * Don't do this when appending.</a>
<a name="ln2350">   * Only do this when 'cpoptions' contains the 'F' flag.</a>
<a name="ln2351">   */</a>
<a name="ln2352">  if (buf-&gt;b_ffname == NULL</a>
<a name="ln2353">      &amp;&amp; reset_changed</a>
<a name="ln2354">      &amp;&amp; whole</a>
<a name="ln2355">      &amp;&amp; buf == curbuf</a>
<a name="ln2356">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln2357">      &amp;&amp; !filtering</a>
<a name="ln2358">      &amp;&amp; (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)</a>
<a name="ln2359">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {</a>
<a name="ln2360">    if (set_rw_fname(fname, sfname) == FAIL)</a>
<a name="ln2361">      return FAIL;</a>
<a name="ln2362">    buf = curbuf;           /* just in case autocmds made &quot;buf&quot; invalid */</a>
<a name="ln2363">  }</a>
<a name="ln2364"> </a>
<a name="ln2365">  if (sfname == NULL)</a>
<a name="ln2366">    sfname = fname;</a>
<a name="ln2367"> </a>
<a name="ln2368">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln2369">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln2370">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln2371">  // another directory, which we don't detect.</a>
<a name="ln2372">  ffname = fname;                           // remember full fname</a>
<a name="ln2373">#ifdef UNIX</a>
<a name="ln2374">  fname = sfname;</a>
<a name="ln2375">#endif</a>
<a name="ln2376"> </a>
<a name="ln2377">  if (buf-&gt;b_ffname != NULL &amp;&amp; fnamecmp(ffname, buf-&gt;b_ffname) == 0)</a>
<a name="ln2378">    overwriting = TRUE;</a>
<a name="ln2379">  else</a>
<a name="ln2380">    overwriting = FALSE;</a>
<a name="ln2381"> </a>
<a name="ln2382">  ++no_wait_return;                 /* don't wait for return yet */</a>
<a name="ln2383"> </a>
<a name="ln2384">  /*</a>
<a name="ln2385">   * Set '[ and '] marks to the lines to be written.</a>
<a name="ln2386">   */</a>
<a name="ln2387">  buf-&gt;b_op_start.lnum = start;</a>
<a name="ln2388">  buf-&gt;b_op_start.col = 0;</a>
<a name="ln2389">  buf-&gt;b_op_end.lnum = end;</a>
<a name="ln2390">  buf-&gt;b_op_end.col = 0;</a>
<a name="ln2391"> </a>
<a name="ln2392">  {</a>
<a name="ln2393">    aco_save_T aco;</a>
<a name="ln2394">    int buf_ffname = FALSE;</a>
<a name="ln2395">    int buf_sfname = FALSE;</a>
<a name="ln2396">    int buf_fname_f = FALSE;</a>
<a name="ln2397">    int buf_fname_s = FALSE;</a>
<a name="ln2398">    int did_cmd = FALSE;</a>
<a name="ln2399">    int nofile_err = FALSE;</a>
<a name="ln2400">    int empty_memline = (buf-&gt;b_ml.ml_mfp == NULL);</a>
<a name="ln2401">    bufref_T bufref;</a>
<a name="ln2402"> </a>
<a name="ln2403">    /*</a>
<a name="ln2404">     * Apply PRE autocommands.</a>
<a name="ln2405">     * Set curbuf to the buffer to be written.</a>
<a name="ln2406">     * Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln2407">     */</a>
<a name="ln2408">    if (ffname == buf-&gt;b_ffname)</a>
<a name="ln2409">      buf_ffname = TRUE;</a>
<a name="ln2410">    if (sfname == buf-&gt;b_sfname)</a>
<a name="ln2411">      buf_sfname = TRUE;</a>
<a name="ln2412">    if (fname == buf-&gt;b_ffname)</a>
<a name="ln2413">      buf_fname_f = TRUE;</a>
<a name="ln2414">    if (fname == buf-&gt;b_sfname)</a>
<a name="ln2415">      buf_fname_s = TRUE;</a>
<a name="ln2416"> </a>
<a name="ln2417">    // Set curwin/curbuf to buf and save a few things.</a>
<a name="ln2418">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2419">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2420"> </a>
<a name="ln2421">    if (append) {</a>
<a name="ln2422">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,</a>
<a name="ln2423">                sfname, sfname, FALSE, curbuf, eap))) {</a>
<a name="ln2424">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2425">          nofile_err = TRUE;</a>
<a name="ln2426">        else</a>
<a name="ln2427">          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,</a>
<a name="ln2428">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2429">      }</a>
<a name="ln2430">    } else if (filtering) {</a>
<a name="ln2431">      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,</a>
<a name="ln2432">          NULL, sfname, FALSE, curbuf, eap);</a>
<a name="ln2433">    } else if (reset_changed &amp;&amp; whole)   {</a>
<a name="ln2434">      int was_changed = curbufIsChanged();</a>
<a name="ln2435"> </a>
<a name="ln2436">      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,</a>
<a name="ln2437">          sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2438">      if (did_cmd) {</a>
<a name="ln2439">        if (was_changed &amp;&amp; !curbufIsChanged()) {</a>
<a name="ln2440">          /* Written everything correctly and BufWriteCmd has reset</a>
<a name="ln2441">           * 'modified': Correct the undo information so that an</a>
<a name="ln2442">           * undo now sets 'modified'. */</a>
<a name="ln2443">          u_unchanged(curbuf);</a>
<a name="ln2444">          u_update_save_nr(curbuf);</a>
<a name="ln2445">        }</a>
<a name="ln2446">      } else {</a>
<a name="ln2447">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2448">          nofile_err = TRUE;</a>
<a name="ln2449">        else</a>
<a name="ln2450">          apply_autocmds_exarg(EVENT_BUFWRITEPRE,</a>
<a name="ln2451">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2452">      }</a>
<a name="ln2453">    } else {</a>
<a name="ln2454">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,</a>
<a name="ln2455">                sfname, sfname, FALSE, curbuf, eap))) {</a>
<a name="ln2456">        if (overwriting &amp;&amp; bt_nofile(curbuf))</a>
<a name="ln2457">          nofile_err = TRUE;</a>
<a name="ln2458">        else</a>
<a name="ln2459">          apply_autocmds_exarg(EVENT_FILEWRITEPRE,</a>
<a name="ln2460">              sfname, sfname, FALSE, curbuf, eap);</a>
<a name="ln2461">      }</a>
<a name="ln2462">    }</a>
<a name="ln2463"> </a>
<a name="ln2464">    /* restore curwin/curbuf and a few other things */</a>
<a name="ln2465">    aucmd_restbuf(&amp;aco);</a>
<a name="ln2466"> </a>
<a name="ln2467">    // In three situations we return here and don't write the file:</a>
<a name="ln2468">    // 1. the autocommands deleted or unloaded the buffer.</a>
<a name="ln2469">    // 2. The autocommands abort script processing.</a>
<a name="ln2470">    // 3. If one of the &quot;Cmd&quot; autocommands was executed.</a>
<a name="ln2471">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2472">      buf = NULL;</a>
<a name="ln2473">    }</a>
<a name="ln2474">    if (buf == NULL || (buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; !empty_memline)</a>
<a name="ln2475">        || did_cmd || nofile_err</a>
<a name="ln2476">        || aborting()</a>
<a name="ln2477">        ) {</a>
<a name="ln2478">      --no_wait_return;</a>
<a name="ln2479">      msg_scroll = msg_save;</a>
<a name="ln2480">      if (nofile_err)</a>
<a name="ln2481">        EMSG(_(&quot;E676: No matching autocommands for acwrite buffer&quot;));</a>
<a name="ln2482"> </a>
<a name="ln2483">      if (nofile_err</a>
<a name="ln2484">          || aborting()</a>
<a name="ln2485">          )</a>
<a name="ln2486">        /* An aborting error, interrupt or exception in the</a>
<a name="ln2487">         * autocommands. */</a>
<a name="ln2488">        return FAIL;</a>
<a name="ln2489">      if (did_cmd) {</a>
<a name="ln2490">        if (buf == NULL)</a>
<a name="ln2491">          /* The buffer was deleted.  We assume it was written</a>
<a name="ln2492">           * (can't retry anyway). */</a>
<a name="ln2493">          return OK;</a>
<a name="ln2494">        if (overwriting) {</a>
<a name="ln2495">          /* Assume the buffer was written, update the timestamp. */</a>
<a name="ln2496">          ml_timestamp(buf);</a>
<a name="ln2497">          if (append)</a>
<a name="ln2498">            buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln2499">          else</a>
<a name="ln2500">            buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln2501">        }</a>
<a name="ln2502">        if (reset_changed &amp;&amp; buf-&gt;b_changed &amp;&amp; !append</a>
<a name="ln2503">            &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))</a>
<a name="ln2504">          /* Buffer still changed, the autocommands didn't work</a>
<a name="ln2505">           * properly. */</a>
<a name="ln2506">          return FAIL;</a>
<a name="ln2507">        return OK;</a>
<a name="ln2508">      }</a>
<a name="ln2509">      if (!aborting())</a>
<a name="ln2510">        EMSG(_(&quot;E203: Autocommands deleted or unloaded buffer to be written&quot;));</a>
<a name="ln2511">      return FAIL;</a>
<a name="ln2512">    }</a>
<a name="ln2513"> </a>
<a name="ln2514">    /*</a>
<a name="ln2515">     * The autocommands may have changed the number of lines in the file.</a>
<a name="ln2516">     * When writing the whole file, adjust the end.</a>
<a name="ln2517">     * When writing part of the file, assume that the autocommands only</a>
<a name="ln2518">     * changed the number of lines that are to be written (tricky!).</a>
<a name="ln2519">     */</a>
<a name="ln2520">    if (buf-&gt;b_ml.ml_line_count != old_line_count) {</a>
<a name="ln2521">      if (whole)                                                /* write all */</a>
<a name="ln2522">        end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2523">      else if (buf-&gt;b_ml.ml_line_count &gt; old_line_count)        /* more lines */</a>
<a name="ln2524">        end += buf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln2525">      else {                                                    /* less lines */</a>
<a name="ln2526">        end -= old_line_count - buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2527">        if (end &lt; start) {</a>
<a name="ln2528">          --no_wait_return;</a>
<a name="ln2529">          msg_scroll = msg_save;</a>
<a name="ln2530">          EMSG(_(&quot;E204: Autocommand changed number of lines in unexpected way&quot;));</a>
<a name="ln2531">          return FAIL;</a>
<a name="ln2532">        }</a>
<a name="ln2533">      }</a>
<a name="ln2534">    }</a>
<a name="ln2535"> </a>
<a name="ln2536">    /*</a>
<a name="ln2537">     * The autocommands may have changed the name of the buffer, which may</a>
<a name="ln2538">     * be kept in fname, ffname and sfname.</a>
<a name="ln2539">     */</a>
<a name="ln2540">    if (buf_ffname)</a>
<a name="ln2541">      ffname = buf-&gt;b_ffname;</a>
<a name="ln2542">    if (buf_sfname)</a>
<a name="ln2543">      sfname = buf-&gt;b_sfname;</a>
<a name="ln2544">    if (buf_fname_f)</a>
<a name="ln2545">      fname = buf-&gt;b_ffname;</a>
<a name="ln2546">    if (buf_fname_s)</a>
<a name="ln2547">      fname = buf-&gt;b_sfname;</a>
<a name="ln2548">  }</a>
<a name="ln2549"> </a>
<a name="ln2550"> </a>
<a name="ln2551">  if (shortmess(SHM_OVER) &amp;&amp; !exiting)</a>
<a name="ln2552">    msg_scroll = FALSE;             /* overwrite previous file message */</a>
<a name="ln2553">  else</a>
<a name="ln2554">    msg_scroll = TRUE;              /* don't overwrite previous file message */</a>
<a name="ln2555">  if (!filtering)</a>
<a name="ln2556">    filemess(buf,</a>
<a name="ln2557">#ifndef UNIX</a>
<a name="ln2558">        sfname,</a>
<a name="ln2559">#else</a>
<a name="ln2560">        fname,</a>
<a name="ln2561">#endif</a>
<a name="ln2562">        (char_u *)&quot;&quot;, 0);               /* show that we are busy */</a>
<a name="ln2563">  msg_scroll = FALSE;               /* always overwrite the file message now */</a>
<a name="ln2564"> </a>
<a name="ln2565">  buffer = verbose_try_malloc(BUFSIZE);</a>
<a name="ln2566">  // can't allocate big buffer, use small one (to be able to write when out of</a>
<a name="ln2567">  // memory)</a>
<a name="ln2568">  if (buffer == NULL) {</a>
<a name="ln2569">    buffer = smallbuf;</a>
<a name="ln2570">    bufsize = SMBUFSIZE;</a>
<a name="ln2571">  } else</a>
<a name="ln2572">    bufsize = BUFSIZE;</a>
<a name="ln2573"> </a>
<a name="ln2574">  /*</a>
<a name="ln2575">   * Get information about original file (if there is one).</a>
<a name="ln2576">   */</a>
<a name="ln2577">  FileInfo file_info_old;</a>
<a name="ln2578">#if defined(UNIX)</a>
<a name="ln2579">  perm = -1;</a>
<a name="ln2580">  if (!os_fileinfo((char *)fname, &amp;file_info_old)) {</a>
<a name="ln2581">    newfile = TRUE;</a>
<a name="ln2582">  } else {</a>
<a name="ln2583">    perm = file_info_old.stat.st_mode;</a>
<a name="ln2584">    if (!S_ISREG(file_info_old.stat.st_mode)) {             /* not a file */</a>
<a name="ln2585">      if (S_ISDIR(file_info_old.stat.st_mode)) {</a>
<a name="ln2586">        SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2587">        goto fail;</a>
<a name="ln2588">      }</a>
<a name="ln2589">      if (os_nodetype((char *)fname) != NODE_WRITABLE) {</a>
<a name="ln2590">        SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2591">        goto fail;</a>
<a name="ln2592">      }</a>
<a name="ln2593">      /* It's a device of some kind (or a fifo) which we can write to</a>
<a name="ln2594">       * but for which we can't make a backup. */</a>
<a name="ln2595">      device = TRUE;</a>
<a name="ln2596">      newfile = TRUE;</a>
<a name="ln2597">      perm = -1;</a>
<a name="ln2598">    }</a>
<a name="ln2599">  }</a>
<a name="ln2600">#else  // win32</a>
<a name="ln2601">  // Check for a writable device name.</a>
<a name="ln2602">  c = fname == NULL ? NODE_OTHER : os_nodetype((char *)fname);</a>
<a name="ln2603">  if (c == NODE_OTHER) {</a>
<a name="ln2604">    SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2605">    goto fail;</a>
<a name="ln2606">  }</a>
<a name="ln2607">  if (c == NODE_WRITABLE) {</a>
<a name="ln2608">    device = TRUE;</a>
<a name="ln2609">    newfile = TRUE;</a>
<a name="ln2610">    perm = -1;</a>
<a name="ln2611">  } else {</a>
<a name="ln2612">    perm = os_getperm((const char *)fname);</a>
<a name="ln2613">    if (perm &lt; 0) {</a>
<a name="ln2614">      newfile = true;</a>
<a name="ln2615">    } else if (os_isdir(fname)) {</a>
<a name="ln2616">      SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2617">      goto fail;</a>
<a name="ln2618">    }</a>
<a name="ln2619">    if (overwriting) {</a>
<a name="ln2620">      os_fileinfo((char *)fname, &amp;file_info_old);</a>
<a name="ln2621">    }</a>
<a name="ln2622">  }</a>
<a name="ln2623">#endif  // !UNIX</a>
<a name="ln2624"> </a>
<a name="ln2625">  if (!device &amp;&amp; !newfile) {</a>
<a name="ln2626">    /*</a>
<a name="ln2627">     * Check if the file is really writable (when renaming the file to</a>
<a name="ln2628">     * make a backup we won't discover it later).</a>
<a name="ln2629">     */</a>
<a name="ln2630">    file_readonly = !os_file_is_writable((char *)fname);</a>
<a name="ln2631"> </a>
<a name="ln2632">    if (!forceit &amp;&amp; file_readonly) {</a>
<a name="ln2633">      if (vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2634">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2635">      } else {</a>
<a name="ln2636">        SET_ERRMSG_NUM(&quot;E505&quot;, _(&quot;is read-only (add ! to override)&quot;));</a>
<a name="ln2637">      }</a>
<a name="ln2638">      goto fail;</a>
<a name="ln2639">    }</a>
<a name="ln2640"> </a>
<a name="ln2641">    /*</a>
<a name="ln2642">     * Check if the timestamp hasn't changed since reading the file.</a>
<a name="ln2643">     */</a>
<a name="ln2644">    if (overwriting) {</a>
<a name="ln2645">      retval = check_mtime(buf, &amp;file_info_old);</a>
<a name="ln2646">      if (retval == FAIL)</a>
<a name="ln2647">        goto fail;</a>
<a name="ln2648">    }</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">#ifdef HAVE_ACL</a>
<a name="ln2652">  /*</a>
<a name="ln2653">   * For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2654">   */</a>
<a name="ln2655">  if (!newfile)</a>
<a name="ln2656">    acl = mch_get_acl(fname);</a>
<a name="ln2657">#endif</a>
<a name="ln2658"> </a>
<a name="ln2659">  /*</a>
<a name="ln2660">   * If 'backupskip' is not empty, don't make a backup for some files.</a>
<a name="ln2661">   */</a>
<a name="ln2662">  dobackup = (p_wb || p_bk || *p_pm != NUL);</a>
<a name="ln2663">  if (dobackup &amp;&amp; *p_bsk != NUL &amp;&amp; match_file_list(p_bsk, sfname, ffname))</a>
<a name="ln2664">    dobackup = FALSE;</a>
<a name="ln2665"> </a>
<a name="ln2666">  /*</a>
<a name="ln2667">   * Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln2668">   * interruption cancel writing, only hitting CTRL-C while writing should</a>
<a name="ln2669">   * abort it.</a>
<a name="ln2670">   */</a>
<a name="ln2671">  prev_got_int = got_int;</a>
<a name="ln2672">  got_int = FALSE;</a>
<a name="ln2673"> </a>
<a name="ln2674">  /* Mark the buffer as 'being saved' to prevent changed buffer warnings */</a>
<a name="ln2675">  buf-&gt;b_saving = true;</a>
<a name="ln2676"> </a>
<a name="ln2677">  /*</a>
<a name="ln2678">   * If we are not appending or filtering, the file exists, and the</a>
<a name="ln2679">   * 'writebackup', 'backup' or 'patchmode' option is set, need a backup.</a>
<a name="ln2680">   * When 'patchmode' is set also make a backup when appending.</a>
<a name="ln2681">   *</a>
<a name="ln2682">   * Do not make any backup, if 'writebackup' and 'backup' are both switched</a>
<a name="ln2683">   * off.  This helps when editing large files on almost-full disks.</a>
<a name="ln2684">   */</a>
<a name="ln2685">  if (!(append &amp;&amp; *p_pm == NUL) &amp;&amp; !filtering &amp;&amp; perm &gt;= 0 &amp;&amp; dobackup) {</a>
<a name="ln2686">    FileInfo file_info;</a>
<a name="ln2687">    const bool no_prepend_dot = false;</a>
<a name="ln2688"> </a>
<a name="ln2689">    if ((bkc &amp; BKC_YES) || append) {       /* &quot;yes&quot; */</a>
<a name="ln2690">      backup_copy = TRUE;</a>
<a name="ln2691">    } else if ((bkc &amp; BKC_AUTO)) {          /* &quot;auto&quot; */</a>
<a name="ln2692">      int i;</a>
<a name="ln2693"> </a>
<a name="ln2694">      /*</a>
<a name="ln2695">       * Don't rename the file when:</a>
<a name="ln2696">       * - it's a hard link</a>
<a name="ln2697">       * - it's a symbolic link</a>
<a name="ln2698">       * - we don't have write permission in the directory</a>
<a name="ln2699">       */</a>
<a name="ln2700">      if (os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2701">          || !os_fileinfo_link((char *)fname, &amp;file_info)</a>
<a name="ln2702">          || !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2703">        backup_copy = TRUE;</a>
<a name="ln2704">      } else {</a>
<a name="ln2705">        /*</a>
<a name="ln2706">         * Check if we can create a file and set the owner/group to</a>
<a name="ln2707">         * the ones from the original file.</a>
<a name="ln2708">         * First find a file name that doesn't exist yet (use some</a>
<a name="ln2709">         * arbitrary numbers).</a>
<a name="ln2710">         */</a>
<a name="ln2711">        STRCPY(IObuff, fname);</a>
<a name="ln2712">        for (i = 4913;; i += 123) {</a>
<a name="ln2713">          sprintf((char *)path_tail(IObuff), &quot;%d&quot;, i);</a>
<a name="ln2714">          if (!os_fileinfo_link((char *)IObuff, &amp;file_info)) {</a>
<a name="ln2715">            break;</a>
<a name="ln2716">          }</a>
<a name="ln2717">        }</a>
<a name="ln2718">        fd = os_open((char *)IObuff,</a>
<a name="ln2719">            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);</a>
<a name="ln2720">        if (fd &lt; 0)             /* can't write in directory */</a>
<a name="ln2721">          backup_copy = TRUE;</a>
<a name="ln2722">        else {</a>
<a name="ln2723"># ifdef UNIX</a>
<a name="ln2724">          os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);</a>
<a name="ln2725">          if (!os_fileinfo((char *)IObuff, &amp;file_info)</a>
<a name="ln2726">              || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln2727">              || file_info.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2728">              || (long)file_info.stat.st_mode != perm) {</a>
<a name="ln2729">            backup_copy = TRUE;</a>
<a name="ln2730">          }</a>
<a name="ln2731"># endif</a>
<a name="ln2732">          /* Close the file before removing it, on MS-Windows we</a>
<a name="ln2733">           * can't delete an open file. */</a>
<a name="ln2734">          close(fd);</a>
<a name="ln2735">          os_remove((char *)IObuff);</a>
<a name="ln2736">        }</a>
<a name="ln2737">      }</a>
<a name="ln2738">    }</a>
<a name="ln2739"> </a>
<a name="ln2740">    /*</a>
<a name="ln2741">     * Break symlinks and/or hardlinks if we've been asked to.</a>
<a name="ln2742">     */</a>
<a name="ln2743">    if ((bkc &amp; BKC_BREAKSYMLINK) || (bkc &amp; BKC_BREAKHARDLINK)) {</a>
<a name="ln2744"># ifdef UNIX</a>
<a name="ln2745">      bool file_info_link_ok = os_fileinfo_link((char *)fname, &amp;file_info);</a>
<a name="ln2746"> </a>
<a name="ln2747">      /* Symlinks. */</a>
<a name="ln2748">      if ((bkc &amp; BKC_BREAKSYMLINK)</a>
<a name="ln2749">          &amp;&amp; file_info_link_ok</a>
<a name="ln2750">          &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2751">        backup_copy = FALSE;</a>
<a name="ln2752">      }</a>
<a name="ln2753"> </a>
<a name="ln2754">      /* Hardlinks. */</a>
<a name="ln2755">      if ((bkc &amp; BKC_BREAKHARDLINK)</a>
<a name="ln2756">          &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2757">          &amp;&amp; (!file_info_link_ok</a>
<a name="ln2758">              || os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln2759">        backup_copy = FALSE;</a>
<a name="ln2760">      }</a>
<a name="ln2761"># endif</a>
<a name="ln2762">    }</a>
<a name="ln2763"> </a>
<a name="ln2764">    /* make sure we have a valid backup extension to use */</a>
<a name="ln2765">    if (*p_bex == NUL)</a>
<a name="ln2766">      backup_ext = (char_u *)&quot;.bak&quot;;</a>
<a name="ln2767">    else</a>
<a name="ln2768">      backup_ext = p_bex;</a>
<a name="ln2769"> </a>
<a name="ln2770">    if (backup_copy) {</a>
<a name="ln2771">      char_u *wp;</a>
<a name="ln2772">      int some_error = false;</a>
<a name="ln2773">      char_u      *dirp;</a>
<a name="ln2774">      char_u      *rootname;</a>
<a name="ln2775">      char_u      *p;</a>
<a name="ln2776"> </a>
<a name="ln2777">      /*</a>
<a name="ln2778">       * Try to make the backup in each directory in the 'bdir' option.</a>
<a name="ln2779">       *</a>
<a name="ln2780">       * Unix semantics has it, that we may have a writable file,</a>
<a name="ln2781">       * that cannot be recreated with a simple open(..., O_CREAT, ) e.g:</a>
<a name="ln2782">       *  - the directory is not writable,</a>
<a name="ln2783">       *  - the file may be a symbolic link,</a>
<a name="ln2784">       *  - the file may belong to another user/group, etc.</a>
<a name="ln2785">       *</a>
<a name="ln2786">       * For these reasons, the existing writable file must be truncated</a>
<a name="ln2787">       * and reused. Creation of a backup COPY will be attempted.</a>
<a name="ln2788">       */</a>
<a name="ln2789">      dirp = p_bdir;</a>
<a name="ln2790">      while (*dirp) {</a>
<a name="ln2791">        /*</a>
<a name="ln2792">         * Isolate one directory name, using an entry in 'bdir'.</a>
<a name="ln2793">         */</a>
<a name="ln2794">        (void)copy_option_part(&amp;dirp, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2795">        p = IObuff + STRLEN(IObuff);</a>
<a name="ln2796">        if (after_pathsep((char *)IObuff, (char *)p) &amp;&amp; p[-1] == p[-2]) {</a>
<a name="ln2797">          // Ends with '//', Use Full path</a>
<a name="ln2798">          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))</a>
<a name="ln2799">              != NULL) {</a>
<a name="ln2800">            backup = (char_u *)modname((char *)p, (char *)backup_ext,</a>
<a name="ln2801">                                       no_prepend_dot);</a>
<a name="ln2802">            xfree(p);</a>
<a name="ln2803">          }</a>
<a name="ln2804">        }</a>
<a name="ln2805"> </a>
<a name="ln2806">        rootname = get_file_in_dir(fname, IObuff);</a>
<a name="ln2807">        if (rootname == NULL) {</a>
<a name="ln2808">          some_error = TRUE;                /* out of memory */</a>
<a name="ln2809">          goto nobackup;</a>
<a name="ln2810">        }</a>
<a name="ln2811"> </a>
<a name="ln2812">        FileInfo file_info_new;</a>
<a name="ln2813">        {</a>
<a name="ln2814">          //</a>
<a name="ln2815">          // Make the backup file name.</a>
<a name="ln2816">          //</a>
<a name="ln2817">          if (backup == NULL) {</a>
<a name="ln2818">            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,</a>
<a name="ln2819">                                       no_prepend_dot);</a>
<a name="ln2820">          }</a>
<a name="ln2821"> </a>
<a name="ln2822">          if (backup == NULL) {</a>
<a name="ln2823">            xfree(rootname);</a>
<a name="ln2824">            some_error = TRUE;                          /* out of memory */</a>
<a name="ln2825">            goto nobackup;</a>
<a name="ln2826">          }</a>
<a name="ln2827"> </a>
<a name="ln2828">          /*</a>
<a name="ln2829">           * Check if backup file already exists.</a>
<a name="ln2830">           */</a>
<a name="ln2831">          if (os_fileinfo((char *)backup, &amp;file_info_new)) {</a>
<a name="ln2832">            if (os_fileinfo_id_equal(&amp;file_info_new, &amp;file_info_old)) {</a>
<a name="ln2833">              //</a>
<a name="ln2834">              // Backup file is same as original file.</a>
<a name="ln2835">              // May happen when modname() gave the same file back (e.g. silly</a>
<a name="ln2836">              // link). If we don't check here, we either ruin the file when</a>
<a name="ln2837">              // copying or erase it after writing.</a>
<a name="ln2838">              //</a>
<a name="ln2839">              XFREE_CLEAR(backup);              // no backup file to delete</a>
<a name="ln2840">            } else if (!p_bk) {</a>
<a name="ln2841">              // We are not going to keep the backup file, so don't</a>
<a name="ln2842">              // delete an existing one, and try to use another name instead.</a>
<a name="ln2843">              // Change one character, just before the extension.</a>
<a name="ln2844">              //</a>
<a name="ln2845">              wp = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);</a>
<a name="ln2846">              if (wp &lt; backup) {                // empty file name ???</a>
<a name="ln2847">                wp = backup;</a>
<a name="ln2848">              }</a>
<a name="ln2849">              *wp = 'z';</a>
<a name="ln2850">              while (*wp &gt; 'a'</a>
<a name="ln2851">                     &amp;&amp; os_fileinfo((char *)backup, &amp;file_info_new)) {</a>
<a name="ln2852">                --*wp;</a>
<a name="ln2853">              }</a>
<a name="ln2854">              // They all exist??? Must be something wrong.</a>
<a name="ln2855">              if (*wp == 'a') {</a>
<a name="ln2856">                XFREE_CLEAR(backup);</a>
<a name="ln2857">              }</a>
<a name="ln2858">            }</a>
<a name="ln2859">          }</a>
<a name="ln2860">        }</a>
<a name="ln2861">        xfree(rootname);</a>
<a name="ln2862"> </a>
<a name="ln2863">        /*</a>
<a name="ln2864">         * Try to create the backup file</a>
<a name="ln2865">         */</a>
<a name="ln2866">        if (backup != NULL) {</a>
<a name="ln2867">          /* remove old backup, if present */</a>
<a name="ln2868">          os_remove((char *)backup);</a>
<a name="ln2869"> </a>
<a name="ln2870">          // set file protection same as original file, but</a>
<a name="ln2871">          // strip s-bit.</a>
<a name="ln2872">          (void)os_setperm((const char *)backup, perm &amp; 0777);</a>
<a name="ln2873"> </a>
<a name="ln2874">#ifdef UNIX</a>
<a name="ln2875">          //</a>
<a name="ln2876">          // Try to set the group of the backup same as the original file. If</a>
<a name="ln2877">          // this fails, set the protection bits for the group same as the</a>
<a name="ln2878">          // protection bits for others.</a>
<a name="ln2879">          //</a>
<a name="ln2880">          if (file_info_new.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2881">              &amp;&amp; os_chown((char *)backup, -1, file_info_old.stat.st_gid) != 0) {</a>
<a name="ln2882">            os_setperm((const char *)backup,</a>
<a name="ln2883">                       (perm &amp; 0707) | ((perm &amp; 07) &lt;&lt; 3));</a>
<a name="ln2884">          }</a>
<a name="ln2885">#endif</a>
<a name="ln2886"> </a>
<a name="ln2887">          // copy the file</a>
<a name="ln2888">          if (os_copy((char *)fname, (char *)backup, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln2889">              != 0) {</a>
<a name="ln2890">            SET_ERRMSG(_(&quot;E506: Can't write to backup file &quot;</a>
<a name="ln2891">                         &quot;(add ! to override)&quot;));</a>
<a name="ln2892">          }</a>
<a name="ln2893"> </a>
<a name="ln2894">#ifdef UNIX</a>
<a name="ln2895">          os_file_settime((char *)backup,</a>
<a name="ln2896">                          file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln2897">                          file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln2898">#endif</a>
<a name="ln2899">#ifdef HAVE_ACL</a>
<a name="ln2900">          mch_set_acl(backup, acl);</a>
<a name="ln2901">#endif</a>
<a name="ln2902">          break;</a>
<a name="ln2903">        }</a>
<a name="ln2904">      }</a>
<a name="ln2905"> </a>
<a name="ln2906">nobackup:</a>
<a name="ln2907">      if (backup == NULL &amp;&amp; errmsg == NULL) {</a>
<a name="ln2908">        SET_ERRMSG(_(</a>
<a name="ln2909">            &quot;E509: Cannot create backup file (add ! to override)&quot;));</a>
<a name="ln2910">      }</a>
<a name="ln2911">      // Ignore errors when forceit is TRUE.</a>
<a name="ln2912">      if ((some_error || errmsg != NULL) &amp;&amp; !forceit) {</a>
<a name="ln2913">        retval = FAIL;</a>
<a name="ln2914">        goto fail;</a>
<a name="ln2915">      }</a>
<a name="ln2916">      SET_ERRMSG(NULL);</a>
<a name="ln2917">    } else {</a>
<a name="ln2918">      char_u      *dirp;</a>
<a name="ln2919">      char_u      *p;</a>
<a name="ln2920">      char_u      *rootname;</a>
<a name="ln2921"> </a>
<a name="ln2922">      /*</a>
<a name="ln2923">       * Make a backup by renaming the original file.</a>
<a name="ln2924">       */</a>
<a name="ln2925">      /*</a>
<a name="ln2926">       * If 'cpoptions' includes the &quot;W&quot; flag, we don't want to</a>
<a name="ln2927">       * overwrite a read-only file.  But rename may be possible</a>
<a name="ln2928">       * anyway, thus we need an extra check here.</a>
<a name="ln2929">       */</a>
<a name="ln2930">      if (file_readonly &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2931">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2932">        goto fail;</a>
<a name="ln2933">      }</a>
<a name="ln2934"> </a>
<a name="ln2935">      /*</a>
<a name="ln2936">       *</a>
<a name="ln2937">       * Form the backup file name - change path/fo.o.h to</a>
<a name="ln2938">       * path/fo.o.h.bak Try all directories in 'backupdir', first one</a>
<a name="ln2939">       * that works is used.</a>
<a name="ln2940">       */</a>
<a name="ln2941">      dirp = p_bdir;</a>
<a name="ln2942">      while (*dirp) {</a>
<a name="ln2943">        /*</a>
<a name="ln2944">         * Isolate one directory name and make the backup file name.</a>
<a name="ln2945">         */</a>
<a name="ln2946">        (void)copy_option_part(&amp;dirp, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2947">        p = IObuff + STRLEN(IObuff);</a>
<a name="ln2948">        if (after_pathsep((char *)IObuff, (char *)p) &amp;&amp; p[-1] == p[-2]) {</a>
<a name="ln2949">          // path ends with '//', use full path</a>
<a name="ln2950">          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))</a>
<a name="ln2951">              != NULL) {</a>
<a name="ln2952">            backup = (char_u *)modname((char *)p, (char *)backup_ext,</a>
<a name="ln2953">                                       no_prepend_dot);</a>
<a name="ln2954">            xfree(p);</a>
<a name="ln2955">          }</a>
<a name="ln2956">        }</a>
<a name="ln2957"> </a>
<a name="ln2958">        if (backup == NULL) {</a>
<a name="ln2959">          rootname = get_file_in_dir(fname, IObuff);</a>
<a name="ln2960">          if (rootname == NULL) {</a>
<a name="ln2961">            backup = NULL;</a>
<a name="ln2962">          } else {</a>
<a name="ln2963">            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,</a>
<a name="ln2964">                                       no_prepend_dot);</a>
<a name="ln2965">            xfree(rootname);</a>
<a name="ln2966">          }</a>
<a name="ln2967">        }</a>
<a name="ln2968"> </a>
<a name="ln2969">        if (backup != NULL) {</a>
<a name="ln2970">          /*</a>
<a name="ln2971">           * If we are not going to keep the backup file, don't</a>
<a name="ln2972">           * delete an existing one, try to use another name.</a>
<a name="ln2973">           * Change one character, just before the extension.</a>
<a name="ln2974">           */</a>
<a name="ln2975">          if (!p_bk &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2976">            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);</a>
<a name="ln2977">            if (p &lt; backup)             /* empty file name ??? */</a>
<a name="ln2978">              p = backup;</a>
<a name="ln2979">            *p = 'z';</a>
<a name="ln2980">            while (*p &gt; 'a' &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2981">              (*p)--;</a>
<a name="ln2982">            }</a>
<a name="ln2983">            // They all exist??? Must be something wrong!</a>
<a name="ln2984">            if (*p == 'a') {</a>
<a name="ln2985">              XFREE_CLEAR(backup);</a>
<a name="ln2986">            }</a>
<a name="ln2987">          }</a>
<a name="ln2988">        }</a>
<a name="ln2989">        if (backup != NULL) {</a>
<a name="ln2990">          // Delete any existing backup and move the current version</a>
<a name="ln2991">          // to the backup. For safety, we don't remove the backup</a>
<a name="ln2992">          // until the write has finished successfully. And if the</a>
<a name="ln2993">          // 'backup' option is set, leave it around.</a>
<a name="ln2994"> </a>
<a name="ln2995">          // If the renaming of the original file to the backup file</a>
<a name="ln2996">          // works, quit here.</a>
<a name="ln2997">          ///</a>
<a name="ln2998">          if (vim_rename(fname, backup) == 0) {</a>
<a name="ln2999">            break;</a>
<a name="ln3000">          }</a>
<a name="ln3001"> </a>
<a name="ln3002">          XFREE_CLEAR(backup);             // don't do the rename below</a>
<a name="ln3003">        }</a>
<a name="ln3004">      }</a>
<a name="ln3005">      if (backup == NULL &amp;&amp; !forceit) {</a>
<a name="ln3006">        SET_ERRMSG(_(&quot;E510: Can't make backup file (add ! to override)&quot;));</a>
<a name="ln3007">        goto fail;</a>
<a name="ln3008">      }</a>
<a name="ln3009">    }</a>
<a name="ln3010">  }</a>
<a name="ln3011"> </a>
<a name="ln3012">#if defined(UNIX)</a>
<a name="ln3013">  // When using &quot;:w!&quot; and the file was read-only: make it writable</a>
<a name="ln3014">  if (forceit &amp;&amp; perm &gt;= 0 &amp;&amp; !(perm &amp; 0200)</a>
<a name="ln3015">      &amp;&amp; file_info_old.stat.st_uid == getuid()</a>
<a name="ln3016">      &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL) {</a>
<a name="ln3017">    perm |= 0200;</a>
<a name="ln3018">    (void)os_setperm((const char *)fname, perm);</a>
<a name="ln3019">    made_writable = true;</a>
<a name="ln3020">  }</a>
<a name="ln3021">#endif</a>
<a name="ln3022"> </a>
<a name="ln3023">  // When using &quot;:w!&quot; and writing to the current file, 'readonly' makes no</a>
<a name="ln3024">  // sense, reset it, unless 'Z' appears in 'cpoptions'.</a>
<a name="ln3025">  if (forceit &amp;&amp; overwriting &amp;&amp; vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {</a>
<a name="ln3026">    buf-&gt;b_p_ro = false;</a>
<a name="ln3027">    need_maketitle = true;          // set window title later</a>
<a name="ln3028">    status_redraw_all();            // redraw status lines later</a>
<a name="ln3029">  }</a>
<a name="ln3030"> </a>
<a name="ln3031">  if (end &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln3032">    end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln3033">  if (buf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln3034">    start = end + 1;</a>
<a name="ln3035"> </a>
<a name="ln3036">  // If the original file is being overwritten, there is a small chance that</a>
<a name="ln3037">  // we crash in the middle of writing. Therefore the file is preserved now.</a>
<a name="ln3038">  // This makes all block numbers positive so that recovery does not need</a>
<a name="ln3039">  // the original file.</a>
<a name="ln3040">  // Don't do this if there is a backup file and we are exiting.</a>
<a name="ln3041">  if (reset_changed &amp;&amp; !newfile &amp;&amp; overwriting</a>
<a name="ln3042">      &amp;&amp; !(exiting &amp;&amp; backup != NULL)) {</a>
<a name="ln3043">    ml_preserve(buf, false, !!p_fs);</a>
<a name="ln3044">    if (got_int) {</a>
<a name="ln3045">      SET_ERRMSG(_(e_interr));</a>
<a name="ln3046">      goto restore_backup;</a>
<a name="ln3047">    }</a>
<a name="ln3048">  }</a>
<a name="ln3049"> </a>
<a name="ln3050"> </a>
<a name="ln3051">  // Default: write the file directly.  May write to a temp file for</a>
<a name="ln3052">  // multi-byte conversion.</a>
<a name="ln3053">  wfname = fname;</a>
<a name="ln3054"> </a>
<a name="ln3055">  // Check for forced 'fileencoding' from &quot;++opt=val&quot; argument.</a>
<a name="ln3056">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln3057">    fenc = eap-&gt;cmd + eap-&gt;force_enc;</a>
<a name="ln3058">    fenc = enc_canonize(fenc);</a>
<a name="ln3059">    fenc_tofree = fenc;</a>
<a name="ln3060">  } else {</a>
<a name="ln3061">    fenc = buf-&gt;b_p_fenc;</a>
<a name="ln3062">  }</a>
<a name="ln3063"> </a>
<a name="ln3064">  // Check if the file needs to be converted.</a>
<a name="ln3065">  converted = need_conversion(fenc);</a>
<a name="ln3066"> </a>
<a name="ln3067">  // Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or</a>
<a name="ln3068">  // Latin1 to Unicode conversion.  This is handled in buf_write_bytes().</a>
<a name="ln3069">  // Prepare the flags for it and allocate bw_conv_buf when needed.</a>
<a name="ln3070">  if (converted &amp;&amp; (enc_utf8 || STRCMP(p_enc, &quot;latin1&quot;) == 0)) {</a>
<a name="ln3071">    wb_flags = get_fio_flags(fenc);</a>
<a name="ln3072">    if (wb_flags &amp; (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln3073">      // Need to allocate a buffer to translate into.</a>
<a name="ln3074">      if (wb_flags &amp; (FIO_UCS2 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln3075">        write_info.bw_conv_buflen = bufsize * 2;</a>
<a name="ln3076">      } else {       // FIO_UCS4</a>
<a name="ln3077">        write_info.bw_conv_buflen = bufsize * 4;</a>
<a name="ln3078">      }</a>
<a name="ln3079">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln3080">      if (!write_info.bw_conv_buf) {</a>
<a name="ln3081">        end = 0;</a>
<a name="ln3082">      }</a>
<a name="ln3083">    }</a>
<a name="ln3084">  }</a>
<a name="ln3085"> </a>
<a name="ln3086"> </a>
<a name="ln3087"> </a>
<a name="ln3088">  if (converted &amp;&amp; wb_flags == 0) {</a>
<a name="ln3089">#  ifdef HAVE_ICONV</a>
<a name="ln3090">    // Use iconv() conversion when conversion is needed and it's not done</a>
<a name="ln3091">    // internally.</a>
<a name="ln3092">    write_info.bw_iconv_fd = (iconv_t)my_iconv_open(fenc,</a>
<a name="ln3093">        enc_utf8 ? (char_u *)&quot;utf-8&quot; : p_enc);</a>
<a name="ln3094">    if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3095">      /* We're going to use iconv(), allocate a buffer to convert in. */</a>
<a name="ln3096">      write_info.bw_conv_buflen = bufsize * ICONV_MULT;</a>
<a name="ln3097">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln3098">      if (!write_info.bw_conv_buf) {</a>
<a name="ln3099">        end = 0;</a>
<a name="ln3100">      }</a>
<a name="ln3101">      write_info.bw_first = TRUE;</a>
<a name="ln3102">    } else</a>
<a name="ln3103">#  endif</a>
<a name="ln3104"> </a>
<a name="ln3105">    /*</a>
<a name="ln3106">     * When the file needs to be converted with 'charconvert' after</a>
<a name="ln3107">     * writing, write to a temp file instead and let the conversion</a>
<a name="ln3108">     * overwrite the original file.</a>
<a name="ln3109">     */</a>
<a name="ln3110">    if (*p_ccv != NUL) {</a>
<a name="ln3111">      wfname = vim_tempname();</a>
<a name="ln3112">      if (wfname == NULL) {  // Can't write without a tempfile!</a>
<a name="ln3113">        SET_ERRMSG(_(&quot;E214: Can't find temp file for writing&quot;));</a>
<a name="ln3114">        goto restore_backup;</a>
<a name="ln3115">      }</a>
<a name="ln3116">    }</a>
<a name="ln3117">  }</a>
<a name="ln3118">  if (converted &amp;&amp; wb_flags == 0</a>
<a name="ln3119">#  ifdef HAVE_ICONV</a>
<a name="ln3120">      &amp;&amp; write_info.bw_iconv_fd == (iconv_t)-1</a>
<a name="ln3121">#  endif</a>
<a name="ln3122">      &amp;&amp; wfname == fname</a>
<a name="ln3123">      ) {</a>
<a name="ln3124">    if (!forceit) {</a>
<a name="ln3125">      SET_ERRMSG(_(</a>
<a name="ln3126">          &quot;E213: Cannot convert (add ! to write without conversion)&quot;));</a>
<a name="ln3127">      goto restore_backup;</a>
<a name="ln3128">    }</a>
<a name="ln3129">    notconverted = TRUE;</a>
<a name="ln3130">  }</a>
<a name="ln3131"> </a>
<a name="ln3132">  // If conversion is taking place, we may first pretend to write and check</a>
<a name="ln3133">  // for conversion errors.  Then loop again to write for real.</a>
<a name="ln3134">  // When not doing conversion this writes for real right away.</a>
<a name="ln3135">  for (checking_conversion = true; ; checking_conversion = false) {</a>
<a name="ln3136">    // There is no need to check conversion when:</a>
<a name="ln3137">    // - there is no conversion</a>
<a name="ln3138">    // - we make a backup file, that can be restored in case of conversion</a>
<a name="ln3139">    // failure.</a>
<a name="ln3140">    if (!converted || dobackup) {</a>
<a name="ln3141">      checking_conversion = false;</a>
<a name="ln3142">    }</a>
<a name="ln3143"> </a>
<a name="ln3144">    if (checking_conversion) {</a>
<a name="ln3145">      // Make sure we don't write anything.</a>
<a name="ln3146">      fd = -1;</a>
<a name="ln3147">      write_info.bw_fd = fd;</a>
<a name="ln3148">    } else {</a>
<a name="ln3149">      // Open the file &quot;wfname&quot; for writing.</a>
<a name="ln3150">      // We may try to open the file twice: If we can't write to the file</a>
<a name="ln3151">      // and forceit is TRUE we delete the existing file and try to</a>
<a name="ln3152">      // create a new one. If this still fails we may have lost the</a>
<a name="ln3153">      // original file!  (this may happen when the user reached his</a>
<a name="ln3154">      // quotum for number of files).</a>
<a name="ln3155">      // Appending will fail if the file does not exist and forceit is</a>
<a name="ln3156">      // FALSE.</a>
<a name="ln3157">      while ((fd = os_open((char *)wfname,</a>
<a name="ln3158">                           O_WRONLY |</a>
<a name="ln3159">                           (append ?</a>
<a name="ln3160">                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)</a>
<a name="ln3161">                            : (O_CREAT | O_TRUNC))</a>
<a name="ln3162">                           , perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3163">        // A forced write will try to create a new file if the old one</a>
<a name="ln3164">        // is still readonly. This may also happen when the directory</a>
<a name="ln3165">        // is read-only. In that case the mch_remove() will fail.</a>
<a name="ln3166">        if (errmsg == NULL) {</a>
<a name="ln3167">#ifdef UNIX</a>
<a name="ln3168">          FileInfo file_info;</a>
<a name="ln3169"> </a>
<a name="ln3170">          // Don't delete the file when it's a hard or symbolic link.</a>
<a name="ln3171">          if ((!newfile &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1)</a>
<a name="ln3172">              || (os_fileinfo_link((char *)fname, &amp;file_info)</a>
<a name="ln3173">                  &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln3174">            SET_ERRMSG(_(&quot;E166: Can't open linked file for writing&quot;));</a>
<a name="ln3175">          } else {</a>
<a name="ln3176">#endif</a>
<a name="ln3177">            SET_ERRMSG_ARG(_(&quot;E212: Can't open file for writing: %s&quot;), fd);</a>
<a name="ln3178">            if (forceit &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL</a>
<a name="ln3179">                &amp;&amp; perm &gt;= 0) {</a>
<a name="ln3180">#ifdef UNIX</a>
<a name="ln3181">              // we write to the file, thus it should be marked</a>
<a name="ln3182">              // writable after all</a>
<a name="ln3183">              if (!(perm &amp; 0200)) {</a>
<a name="ln3184">                made_writable = true;</a>
<a name="ln3185">              }</a>
<a name="ln3186">              perm |= 0200;</a>
<a name="ln3187">              if (file_info_old.stat.st_uid != getuid()</a>
<a name="ln3188">                  || file_info_old.stat.st_gid != getgid()) {</a>
<a name="ln3189">                perm &amp;= 0777;</a>
<a name="ln3190">              }</a>
<a name="ln3191">#endif</a>
<a name="ln3192">              if (!append) {                    // don't remove when appending</a>
<a name="ln3193">                os_remove((char *)wfname);</a>
<a name="ln3194">              }</a>
<a name="ln3195">              continue;</a>
<a name="ln3196">            }</a>
<a name="ln3197">#ifdef UNIX</a>
<a name="ln3198">          }</a>
<a name="ln3199">#endif</a>
<a name="ln3200">        }</a>
<a name="ln3201"> </a>
<a name="ln3202">restore_backup:</a>
<a name="ln3203">        {</a>
<a name="ln3204">          // If we failed to open the file, we don't need a backup. Throw it</a>
<a name="ln3205">          // away.  If we moved or removed the original file try to put the</a>
<a name="ln3206">          // backup in its place.</a>
<a name="ln3207">          if (backup != NULL &amp;&amp; wfname == fname) {</a>
<a name="ln3208">            if (backup_copy) {</a>
<a name="ln3209">              // There is a small chance that we removed the original,</a>
<a name="ln3210">              // try to move the copy in its place.</a>
<a name="ln3211">              // This may not work if the vim_rename() fails.</a>
<a name="ln3212">              // In that case we leave the copy around.</a>
<a name="ln3213">              // If file does not exist, put the copy in its place</a>
<a name="ln3214">              if (!os_path_exists(fname)) {</a>
<a name="ln3215">                vim_rename(backup, fname);</a>
<a name="ln3216">              }</a>
<a name="ln3217">              // if original file does exist throw away the copy</a>
<a name="ln3218">              if (os_path_exists(fname)) {</a>
<a name="ln3219">                os_remove((char *)backup);</a>
<a name="ln3220">              }</a>
<a name="ln3221">            } else {</a>
<a name="ln3222">              // try to put the original file back</a>
<a name="ln3223">              vim_rename(backup, fname);</a>
<a name="ln3224">            }</a>
<a name="ln3225">          }</a>
<a name="ln3226"> </a>
<a name="ln3227">          // if original file no longer exists give an extra warning</a>
<a name="ln3228">          if (!newfile &amp;&amp; !os_path_exists(fname)) {</a>
<a name="ln3229">            end = 0;</a>
<a name="ln3230">          }</a>
<a name="ln3231">        }</a>
<a name="ln3232"> </a>
<a name="ln3233">        if (wfname != fname) {</a>
<a name="ln3234">          xfree(wfname);</a>
<a name="ln3235">        }</a>
<a name="ln3236">        goto fail;</a>
<a name="ln3237">      }</a>
<a name="ln3238">      write_info.bw_fd = fd;</a>
<a name="ln3239">    }</a>
<a name="ln3240">    SET_ERRMSG(NULL);</a>
<a name="ln3241"> </a>
<a name="ln3242">    write_info.bw_buf = buffer;</a>
<a name="ln3243">    nchars = 0;</a>
<a name="ln3244"> </a>
<a name="ln3245">    // use &quot;++bin&quot;, &quot;++nobin&quot; or 'binary'</a>
<a name="ln3246">    if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln3247">      write_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln3248">    } else {</a>
<a name="ln3249">      write_bin = buf-&gt;b_p_bin;</a>
<a name="ln3250">    }</a>
<a name="ln3251"> </a>
<a name="ln3252">    // Skip the BOM when appending and the file already existed, the BOM</a>
<a name="ln3253">    // only makes sense at the start of the file.</a>
<a name="ln3254">    if (buf-&gt;b_p_bomb &amp;&amp; !write_bin &amp;&amp; (!append || perm &lt; 0)) {</a>
<a name="ln3255">      write_info.bw_len = make_bom(buffer, fenc);</a>
<a name="ln3256">      if (write_info.bw_len &gt; 0) {</a>
<a name="ln3257">        // don't convert</a>
<a name="ln3258">        write_info.bw_flags = FIO_NOCONVERT | wb_flags;</a>
<a name="ln3259">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3260">          end = 0;</a>
<a name="ln3261">        } else {</a>
<a name="ln3262">          nchars += write_info.bw_len;</a>
<a name="ln3263">        }</a>
<a name="ln3264">      }</a>
<a name="ln3265">    }</a>
<a name="ln3266">    write_info.bw_start_lnum = start;</a>
<a name="ln3267"> </a>
<a name="ln3268">    write_undo_file = (buf-&gt;b_p_udf &amp;&amp; overwriting &amp;&amp; !append</a>
<a name="ln3269">                       &amp;&amp; !filtering &amp;&amp; reset_changed &amp;&amp; !checking_conversion);</a>
<a name="ln3270">    if (write_undo_file) {</a>
<a name="ln3271">      // Prepare for computing the hash value of the text.</a>
<a name="ln3272">      sha256_start(&amp;sha_ctx);</a>
<a name="ln3273">    }</a>
<a name="ln3274"> </a>
<a name="ln3275">    write_info.bw_len = bufsize;</a>
<a name="ln3276">#ifdef HAS_BW_FLAGS</a>
<a name="ln3277">    write_info.bw_flags = wb_flags;</a>
<a name="ln3278">#endif</a>
<a name="ln3279">    fileformat = get_fileformat_force(buf, eap);</a>
<a name="ln3280">    s = buffer;</a>
<a name="ln3281">    len = 0;</a>
<a name="ln3282">    for (lnum = start; lnum &lt;= end; lnum++) {</a>
<a name="ln3283">      // The next while loop is done once for each character written.</a>
<a name="ln3284">      // Keep it fast!</a>
<a name="ln3285">      ptr = ml_get_buf(buf, lnum, false) - 1;</a>
<a name="ln3286">      if (write_undo_file) {</a>
<a name="ln3287">        sha256_update(&amp;sha_ctx, ptr + 1, (uint32_t)(STRLEN(ptr + 1) + 1));</a>
<a name="ln3288">      }</a>
<a name="ln3289">      while ((c = *++ptr) != NUL) {</a>
<a name="ln3290">        if (c == NL) {</a>
<a name="ln3291">          *s = NUL;                       // replace newlines with NULs</a>
<a name="ln3292">        } else if (c == CAR &amp;&amp; fileformat == EOL_MAC) {</a>
<a name="ln3293">          *s = NL;                        // Mac: replace CRs with NLs</a>
<a name="ln3294">        } else {</a>
<a name="ln3295">          *s = c;</a>
<a name="ln3296">        }</a>
<a name="ln3297">        s++;</a>
<a name="ln3298">        if (++len != bufsize) {</a>
<a name="ln3299">          continue;</a>
<a name="ln3300">        }</a>
<a name="ln3301">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3302">          end = 0;                        // write error: break loop</a>
<a name="ln3303">          break;</a>
<a name="ln3304">        }</a>
<a name="ln3305">        nchars += bufsize;</a>
<a name="ln3306">        s = buffer;</a>
<a name="ln3307">        len = 0;</a>
<a name="ln3308">        write_info.bw_start_lnum = lnum;</a>
<a name="ln3309">      }</a>
<a name="ln3310">      // write failed or last line has no EOL: stop here</a>
<a name="ln3311">      if (end == 0</a>
<a name="ln3312">          || (lnum == end</a>
<a name="ln3313">              &amp;&amp; (write_bin || !buf-&gt;b_p_fixeol)</a>
<a name="ln3314">              &amp;&amp; (lnum == buf-&gt;b_no_eol_lnum</a>
<a name="ln3315">                  || (lnum == buf-&gt;b_ml.ml_line_count &amp;&amp; !buf-&gt;b_p_eol)))) {</a>
<a name="ln3316">        lnum++;                           // written the line, count it</a>
<a name="ln3317">        no_eol = true;</a>
<a name="ln3318">        break;</a>
<a name="ln3319">      }</a>
<a name="ln3320">      if (fileformat == EOL_UNIX) {</a>
<a name="ln3321">        *s++ = NL;</a>
<a name="ln3322">      } else {</a>
<a name="ln3323">        *s++ = CAR;                       // EOL_MAC or EOL_DOS: write CR</a>
<a name="ln3324">        if (fileformat == EOL_DOS) {      // write CR-NL</a>
<a name="ln3325">          if (++len == bufsize) {</a>
<a name="ln3326">            if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3327">              end = 0;                    // write error: break loop</a>
<a name="ln3328">              break;</a>
<a name="ln3329">            }</a>
<a name="ln3330">            nchars += bufsize;</a>
<a name="ln3331">            s = buffer;</a>
<a name="ln3332">            len = 0;</a>
<a name="ln3333">          }</a>
<a name="ln3334">          *s++ = NL;</a>
<a name="ln3335">        }</a>
<a name="ln3336">      }</a>
<a name="ln3337">      if (++len == bufsize) {</a>
<a name="ln3338">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3339">          end = 0;  // Write error: break loop.</a>
<a name="ln3340">          break;</a>
<a name="ln3341">        }</a>
<a name="ln3342">        nchars += bufsize;</a>
<a name="ln3343">        s = buffer;</a>
<a name="ln3344">        len = 0;</a>
<a name="ln3345"> </a>
<a name="ln3346">        os_breakcheck();</a>
<a name="ln3347">        if (got_int) {</a>
<a name="ln3348">          end = 0;  // Interrupted, break loop.</a>
<a name="ln3349">          break;</a>
<a name="ln3350">        }</a>
<a name="ln3351">      }</a>
<a name="ln3352">    }</a>
<a name="ln3353">    if (len &gt; 0 &amp;&amp; end &gt; 0) {</a>
<a name="ln3354">      write_info.bw_len = len;</a>
<a name="ln3355">      if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3356">        end = 0;                      // write error</a>
<a name="ln3357">      }</a>
<a name="ln3358">      nchars += len;</a>
<a name="ln3359">    }</a>
<a name="ln3360"> </a>
<a name="ln3361">    // Stop when writing done or an error was encountered.</a>
<a name="ln3362">    if (!checking_conversion || end == 0) {</a>
<a name="ln3363">        break;</a>
<a name="ln3364">    }</a>
<a name="ln3365"> </a>
<a name="ln3366">    // If no error happened until now, writing should be ok, so loop to</a>
<a name="ln3367">    // really write the buffer.</a>
<a name="ln3368">  }</a>
<a name="ln3369"> </a>
<a name="ln3370">  // If we started writing, finish writing. Also when an error was</a>
<a name="ln3371">  // encountered.</a>
<a name="ln3372">  if (!checking_conversion) {</a>
<a name="ln3373">    // On many journalling file systems there is a bug that causes both the</a>
<a name="ln3374">    // original and the backup file to be lost when halting the system right</a>
<a name="ln3375">    // after writing the file.  That's because only the meta-data is</a>
<a name="ln3376">    // journalled.  Syncing the file slows down the system, but assures it has</a>
<a name="ln3377">    // been written to disk and we don't lose it.</a>
<a name="ln3378">    // For a device do try the fsync() but don't complain if it does not work</a>
<a name="ln3379">    // (could be a pipe).</a>
<a name="ln3380">    // If the 'fsync' option is FALSE, don't fsync().  Useful for laptops.</a>
<a name="ln3381">    int error;</a>
<a name="ln3382">    if (p_fs &amp;&amp; (error = os_fsync(fd)) != 0 &amp;&amp; !device</a>
<a name="ln3383">        // fsync not supported on this storage.</a>
<a name="ln3384">        &amp;&amp; error != UV_ENOTSUP) {</a>
<a name="ln3385">      SET_ERRMSG_ARG(e_fsync, error);</a>
<a name="ln3386">      end = 0;</a>
<a name="ln3387">    }</a>
<a name="ln3388"> </a>
<a name="ln3389">#ifdef UNIX</a>
<a name="ln3390">    // When creating a new file, set its owner/group to that of the original</a>
<a name="ln3391">    // file.  Get the new device and inode number.</a>
<a name="ln3392">    if (backup != NULL &amp;&amp; !backup_copy) {</a>
<a name="ln3393">      // don't change the owner when it's already OK, some systems remove</a>
<a name="ln3394">      // permission or ACL stuff</a>
<a name="ln3395">      FileInfo file_info;</a>
<a name="ln3396">      if (!os_fileinfo((char *)wfname, &amp;file_info)</a>
<a name="ln3397">          || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln3398">          || file_info.stat.st_gid != file_info_old.stat.st_gid) {</a>
<a name="ln3399">        os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);</a>
<a name="ln3400">        if (perm &gt;= 0) {  // Set permission again, may have changed.</a>
<a name="ln3401">          (void)os_setperm((const char *)wfname, perm);</a>
<a name="ln3402">        }</a>
<a name="ln3403">      }</a>
<a name="ln3404">      buf_set_file_id(buf);</a>
<a name="ln3405">    } else if (!buf-&gt;file_id_valid) {</a>
<a name="ln3406">      // Set the file_id when creating a new file.</a>
<a name="ln3407">      buf_set_file_id(buf);</a>
<a name="ln3408">    }</a>
<a name="ln3409">#endif</a>
<a name="ln3410"> </a>
<a name="ln3411">    if ((error = os_close(fd)) != 0) {</a>
<a name="ln3412">      SET_ERRMSG_ARG(_(&quot;E512: Close failed: %s&quot;), error);</a>
<a name="ln3413">      end = 0;</a>
<a name="ln3414">    }</a>
<a name="ln3415"> </a>
<a name="ln3416">#ifdef UNIX</a>
<a name="ln3417">    if (made_writable) {</a>
<a name="ln3418">      perm &amp;= ~0200;              // reset 'w' bit for security reasons</a>
<a name="ln3419">    }</a>
<a name="ln3420">#endif</a>
<a name="ln3421">    if (perm &gt;= 0) {  // Set perm. of new file same as old file.</a>
<a name="ln3422">      (void)os_setperm((const char *)wfname, perm);</a>
<a name="ln3423">    }</a>
<a name="ln3424">#ifdef HAVE_ACL</a>
<a name="ln3425">    // Probably need to set the ACL before changing the user (can't set the</a>
<a name="ln3426">    // ACL on a file the user doesn't own).</a>
<a name="ln3427">    if (!backup_copy) {</a>
<a name="ln3428">      mch_set_acl(wfname, acl);</a>
<a name="ln3429">    }</a>
<a name="ln3430">#endif</a>
<a name="ln3431"> </a>
<a name="ln3432">    if (wfname != fname) {</a>
<a name="ln3433">      // The file was written to a temp file, now it needs to be converted</a>
<a name="ln3434">      // with 'charconvert' to (overwrite) the output file.</a>
<a name="ln3435">      if (end != 0) {</a>
<a name="ln3436">        if (eval_charconvert(enc_utf8 ? &quot;utf-8&quot; : (char *)p_enc, (char *)fenc,</a>
<a name="ln3437">                             (char *)wfname, (char *)fname) == FAIL) {</a>
<a name="ln3438">          write_info.bw_conv_error = true;</a>
<a name="ln3439">          end = 0;</a>
<a name="ln3440">        }</a>
<a name="ln3441">      }</a>
<a name="ln3442">      os_remove((char *)wfname);</a>
<a name="ln3443">      xfree(wfname);</a>
<a name="ln3444">    }</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  if (end == 0) {</a>
<a name="ln3448">    // Error encountered.</a>
<a name="ln3449">    if (errmsg == NULL) {</a>
<a name="ln3450">      if (write_info.bw_conv_error) {</a>
<a name="ln3451">        if (write_info.bw_conv_error_lnum == 0) {</a>
<a name="ln3452">          SET_ERRMSG(_(</a>
<a name="ln3453">              &quot;E513: write error, conversion failed &quot;</a>
<a name="ln3454">              &quot;(make 'fenc' empty to override)&quot;));</a>
<a name="ln3455">        } else {</a>
<a name="ln3456">          errmsg_allocated = true;</a>
<a name="ln3457">          SET_ERRMSG(xmalloc(300));</a>
<a name="ln3458">          vim_snprintf(</a>
<a name="ln3459">              errmsg, 300,</a>
<a name="ln3460">              _(&quot;E513: write error, conversion failed in line %&quot; PRIdLINENR</a>
<a name="ln3461">                &quot; (make 'fenc' empty to override)&quot;),</a>
<a name="ln3462">              write_info.bw_conv_error_lnum);</a>
<a name="ln3463">        }</a>
<a name="ln3464">      } else if (got_int) {</a>
<a name="ln3465">        SET_ERRMSG(_(e_interr));</a>
<a name="ln3466">      } else {</a>
<a name="ln3467">        SET_ERRMSG(_(&quot;E514: write error (file system full?)&quot;));</a>
<a name="ln3468">      }</a>
<a name="ln3469">    }</a>
<a name="ln3470"> </a>
<a name="ln3471">    // If we have a backup file, try to put it in place of the new file,</a>
<a name="ln3472">    // because the new file is probably corrupt.  This avoids losing the</a>
<a name="ln3473">    // original file when trying to make a backup when writing the file a</a>
<a name="ln3474">    // second time.</a>
<a name="ln3475">    // When &quot;backup_copy&quot; is set we need to copy the backup over the new</a>
<a name="ln3476">    // file.  Otherwise rename the backup file.</a>
<a name="ln3477">    // If this is OK, don't give the extra warning message.</a>
<a name="ln3478">    if (backup != NULL) {</a>
<a name="ln3479">      if (backup_copy) {</a>
<a name="ln3480">        // This may take a while, if we were interrupted let the user</a>
<a name="ln3481">        // know we got the message.</a>
<a name="ln3482">        if (got_int) {</a>
<a name="ln3483">          MSG(_(e_interr));</a>
<a name="ln3484">          ui_flush();</a>
<a name="ln3485">        }</a>
<a name="ln3486"> </a>
<a name="ln3487">        // copy the file.</a>
<a name="ln3488">        if (os_copy((char *)backup, (char *)fname, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln3489">            == 0) {</a>
<a name="ln3490">          end = 1;  // success</a>
<a name="ln3491">        }</a>
<a name="ln3492">      } else {</a>
<a name="ln3493">        if (vim_rename(backup, fname) == 0) {</a>
<a name="ln3494">          end = 1;</a>
<a name="ln3495">        }</a>
<a name="ln3496">      }</a>
<a name="ln3497">    }</a>
<a name="ln3498">    goto fail;</a>
<a name="ln3499">  }</a>
<a name="ln3500"> </a>
<a name="ln3501">  lnum -= start;            /* compute number of written lines */</a>
<a name="ln3502">  --no_wait_return;         /* may wait for return now */</a>
<a name="ln3503"> </a>
<a name="ln3504">#if !defined(UNIX)</a>
<a name="ln3505">  fname = sfname;           /* use shortname now, for the messages */</a>
<a name="ln3506">#endif</a>
<a name="ln3507">  if (!filtering) {</a>
<a name="ln3508">    add_quoted_fname((char *)IObuff, IOSIZE, buf, (const char *)fname);</a>
<a name="ln3509">    c = false;</a>
<a name="ln3510">    if (write_info.bw_conv_error) {</a>
<a name="ln3511">      STRCAT(IObuff, _(&quot; CONVERSION ERROR&quot;));</a>
<a name="ln3512">      c = TRUE;</a>
<a name="ln3513">      if (write_info.bw_conv_error_lnum != 0)</a>
<a name="ln3514">        vim_snprintf_add((char *)IObuff, IOSIZE, _(&quot; in line %&quot; PRId64 &quot;;&quot;),</a>
<a name="ln3515">            (int64_t)write_info.bw_conv_error_lnum);</a>
<a name="ln3516">    } else if (notconverted) {</a>
<a name="ln3517">      STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln3518">      c = TRUE;</a>
<a name="ln3519">    } else if (converted) {</a>
<a name="ln3520">      STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln3521">      c = TRUE;</a>
<a name="ln3522">    }</a>
<a name="ln3523">    if (device) {</a>
<a name="ln3524">      STRCAT(IObuff, _(&quot;[Device]&quot;));</a>
<a name="ln3525">      c = TRUE;</a>
<a name="ln3526">    } else if (newfile) {</a>
<a name="ln3527">      STRCAT(IObuff, new_file_message());</a>
<a name="ln3528">      c = true;</a>
<a name="ln3529">    }</a>
<a name="ln3530">    if (no_eol) {</a>
<a name="ln3531">      msg_add_eol();</a>
<a name="ln3532">      c = TRUE;</a>
<a name="ln3533">    }</a>
<a name="ln3534">    /* may add [unix/dos/mac] */</a>
<a name="ln3535">    if (msg_add_fileformat(fileformat))</a>
<a name="ln3536">      c = TRUE;</a>
<a name="ln3537">    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */</a>
<a name="ln3538">    if (!shortmess(SHM_WRITE)) {</a>
<a name="ln3539">      if (append)</a>
<a name="ln3540">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [a]&quot;) : _(&quot; appended&quot;));</a>
<a name="ln3541">      else</a>
<a name="ln3542">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [w]&quot;) : _(&quot; written&quot;));</a>
<a name="ln3543">    }</a>
<a name="ln3544"> </a>
<a name="ln3545">    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);</a>
<a name="ln3546">  }</a>
<a name="ln3547"> </a>
<a name="ln3548">  /* When written everything correctly: reset 'modified'.  Unless not</a>
<a name="ln3549">   * writing to the original file and '+' is not in 'cpoptions'. */</a>
<a name="ln3550">  if (reset_changed &amp;&amp; whole &amp;&amp; !append</a>
<a name="ln3551">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3552">      &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln3553">    unchanged(buf, true, false);</a>
<a name="ln3554">    const varnumber_T changedtick = buf_get_changedtick(buf);</a>
<a name="ln3555">    if (buf-&gt;b_last_changedtick + 1 == changedtick) {</a>
<a name="ln3556">      // b:changedtick may be incremented in unchanged() but that</a>
<a name="ln3557">      // should not trigger a TextChanged event.</a>
<a name="ln3558">      buf-&gt;b_last_changedtick = changedtick;</a>
<a name="ln3559">    }</a>
<a name="ln3560">    u_unchanged(buf);</a>
<a name="ln3561">    u_update_save_nr(buf);</a>
<a name="ln3562">  }</a>
<a name="ln3563"> </a>
<a name="ln3564">  /*</a>
<a name="ln3565">   * If written to the current file, update the timestamp of the swap file</a>
<a name="ln3566">   * and reset the BF_WRITE_MASK flags. Also sets buf-&gt;b_mtime.</a>
<a name="ln3567">   */</a>
<a name="ln3568">  if (overwriting) {</a>
<a name="ln3569">    ml_timestamp(buf);</a>
<a name="ln3570">    if (append)</a>
<a name="ln3571">      buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln3572">    else</a>
<a name="ln3573">      buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln3574">  }</a>
<a name="ln3575"> </a>
<a name="ln3576">  /*</a>
<a name="ln3577">   * If we kept a backup until now, and we are in patch mode, then we make</a>
<a name="ln3578">   * the backup file our 'original' file.</a>
<a name="ln3579">   */</a>
<a name="ln3580">  if (*p_pm &amp;&amp; dobackup) {</a>
<a name="ln3581">    char *const org = modname((char *)fname, (char *)p_pm, false);</a>
<a name="ln3582"> </a>
<a name="ln3583">    if (backup != NULL) {</a>
<a name="ln3584">      /*</a>
<a name="ln3585">       * If the original file does not exist yet</a>
<a name="ln3586">       * the current backup file becomes the original file</a>
<a name="ln3587">       */</a>
<a name="ln3588">      if (org == NULL) {</a>
<a name="ln3589">        EMSG(_(&quot;E205: Patchmode: can't save original file&quot;));</a>
<a name="ln3590">      } else if (!os_path_exists((char_u *)org)) {</a>
<a name="ln3591">        vim_rename(backup, (char_u *)org);</a>
<a name="ln3592">        XFREE_CLEAR(backup);                   // don't delete the file</a>
<a name="ln3593">#ifdef UNIX</a>
<a name="ln3594">        os_file_settime(org,</a>
<a name="ln3595">                        file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln3596">                        file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln3597">#endif</a>
<a name="ln3598">      }</a>
<a name="ln3599">    }</a>
<a name="ln3600">    /*</a>
<a name="ln3601">     * If there is no backup file, remember that a (new) file was</a>
<a name="ln3602">     * created.</a>
<a name="ln3603">     */</a>
<a name="ln3604">    else {</a>
<a name="ln3605">      int empty_fd;</a>
<a name="ln3606"> </a>
<a name="ln3607">      if (org == NULL</a>
<a name="ln3608">          || (empty_fd = os_open(org,</a>
<a name="ln3609">                  O_CREAT | O_EXCL | O_NOFOLLOW,</a>
<a name="ln3610">                  perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0)</a>
<a name="ln3611">        EMSG(_(&quot;E206: patchmode: can't touch empty original file&quot;));</a>
<a name="ln3612">      else</a>
<a name="ln3613">        close(empty_fd);</a>
<a name="ln3614">    }</a>
<a name="ln3615">    if (org != NULL) {</a>
<a name="ln3616">      os_setperm(org, os_getperm((const char *)fname) &amp; 0777);</a>
<a name="ln3617">      xfree(org);</a>
<a name="ln3618">    }</a>
<a name="ln3619">  }</a>
<a name="ln3620"> </a>
<a name="ln3621">  /*</a>
<a name="ln3622">   * Remove the backup unless 'backup' option is set</a>
<a name="ln3623">   */</a>
<a name="ln3624">  if (!p_bk &amp;&amp; backup != NULL</a>
<a name="ln3625">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3626">      &amp;&amp; os_remove((char *)backup) != 0) {</a>
<a name="ln3627">    EMSG(_(&quot;E207: Can't delete backup file&quot;));</a>
<a name="ln3628">  }</a>
<a name="ln3629"> </a>
<a name="ln3630">  goto nofail;</a>
<a name="ln3631"> </a>
<a name="ln3632">  /*</a>
<a name="ln3633">   * Finish up.  We get here either after failure or success.</a>
<a name="ln3634">   */</a>
<a name="ln3635">fail:</a>
<a name="ln3636">  --no_wait_return;             /* may wait for return now */</a>
<a name="ln3637">nofail:</a>
<a name="ln3638"> </a>
<a name="ln3639">  /* Done saving, we accept changed buffer warnings again */</a>
<a name="ln3640">  buf-&gt;b_saving = false;</a>
<a name="ln3641"> </a>
<a name="ln3642">  xfree(backup);</a>
<a name="ln3643">  if (buffer != smallbuf)</a>
<a name="ln3644">    xfree(buffer);</a>
<a name="ln3645">  xfree(fenc_tofree);</a>
<a name="ln3646">  xfree(write_info.bw_conv_buf);</a>
<a name="ln3647"># ifdef HAVE_ICONV</a>
<a name="ln3648">  if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3649">    iconv_close(write_info.bw_iconv_fd);</a>
<a name="ln3650">    write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln3651">  }</a>
<a name="ln3652"># endif</a>
<a name="ln3653">#ifdef HAVE_ACL</a>
<a name="ln3654">  mch_free_acl(acl);</a>
<a name="ln3655">#endif</a>
<a name="ln3656"> </a>
<a name="ln3657">  if (errmsg != NULL) {</a>
<a name="ln3658">    // - 100 to save some space for further error message</a>
<a name="ln3659">#ifndef UNIX</a>
<a name="ln3660">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)sfname);</a>
<a name="ln3661">#else</a>
<a name="ln3662">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)fname);</a>
<a name="ln3663">#endif</a>
<a name="ln3664">    if (errnum != NULL) {</a>
<a name="ln3665">      if (errmsgarg != 0) {</a>
<a name="ln3666">        emsgf(&quot;%s: %s%s: %s&quot;, errnum, IObuff, errmsg, os_strerror(errmsgarg));</a>
<a name="ln3667">      } else {</a>
<a name="ln3668">        emsgf(&quot;%s: %s%s&quot;, errnum, IObuff, errmsg);</a>
<a name="ln3669">      }</a>
<a name="ln3670">    } else if (errmsgarg != 0) {</a>
<a name="ln3671">      emsgf(errmsg, os_strerror(errmsgarg));</a>
<a name="ln3672">    } else {</a>
<a name="ln3673">      EMSG(errmsg);</a>
<a name="ln3674">    }</a>
<a name="ln3675">    if (errmsg_allocated) {</a>
<a name="ln3676">      xfree(errmsg);</a>
<a name="ln3677">    }</a>
<a name="ln3678"> </a>
<a name="ln3679">    retval = FAIL;</a>
<a name="ln3680">    if (end == 0) {</a>
<a name="ln3681">      const int attr = HL_ATTR(HLF_E);  // Set highlight for error messages.</a>
<a name="ln3682">      MSG_PUTS_ATTR(_(&quot;\nWARNING: Original file may be lost or damaged\n&quot;),</a>
<a name="ln3683">                    attr | MSG_HIST);</a>
<a name="ln3684">      MSG_PUTS_ATTR(_(</a>
<a name="ln3685">              &quot;don't quit the editor until the file is successfully written!&quot;),</a>
<a name="ln3686">          attr | MSG_HIST);</a>
<a name="ln3687"> </a>
<a name="ln3688">      /* Update the timestamp to avoid an &quot;overwrite changed file&quot;</a>
<a name="ln3689">       * prompt when writing again. */</a>
<a name="ln3690">      if (os_fileinfo((char *)fname, &amp;file_info_old)) {</a>
<a name="ln3691">        buf_store_file_info(buf, &amp;file_info_old);</a>
<a name="ln3692">        buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln3693">      }</a>
<a name="ln3694">    }</a>
<a name="ln3695">  }</a>
<a name="ln3696">  msg_scroll = msg_save;</a>
<a name="ln3697"> </a>
<a name="ln3698">  /*</a>
<a name="ln3699">   * When writing the whole file and 'undofile' is set, also write the undo</a>
<a name="ln3700">   * file.</a>
<a name="ln3701">   */</a>
<a name="ln3702">  if (retval == OK &amp;&amp; write_undo_file) {</a>
<a name="ln3703">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln3704"> </a>
<a name="ln3705">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln3706">    u_write_undo(NULL, FALSE, buf, hash);</a>
<a name="ln3707">  }</a>
<a name="ln3708"> </a>
<a name="ln3709">  if (!should_abort(retval)) {</a>
<a name="ln3710">    aco_save_T aco;</a>
<a name="ln3711"> </a>
<a name="ln3712">    curbuf-&gt;b_no_eol_lnum = 0;      /* in case it was set by the previous read */</a>
<a name="ln3713"> </a>
<a name="ln3714">    /*</a>
<a name="ln3715">     * Apply POST autocommands.</a>
<a name="ln3716">     * Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln3717">     */</a>
<a name="ln3718">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3719"> </a>
<a name="ln3720">    if (append)</a>
<a name="ln3721">      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,</a>
<a name="ln3722">          FALSE, curbuf, eap);</a>
<a name="ln3723">    else if (filtering)</a>
<a name="ln3724">      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,</a>
<a name="ln3725">          FALSE, curbuf, eap);</a>
<a name="ln3726">    else if (reset_changed &amp;&amp; whole)</a>
<a name="ln3727">      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,</a>
<a name="ln3728">          FALSE, curbuf, eap);</a>
<a name="ln3729">    else</a>
<a name="ln3730">      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,</a>
<a name="ln3731">          FALSE, curbuf, eap);</a>
<a name="ln3732"> </a>
<a name="ln3733">    /* restore curwin/curbuf and a few other things */</a>
<a name="ln3734">    aucmd_restbuf(&amp;aco);</a>
<a name="ln3735"> </a>
<a name="ln3736">    if (aborting())         /* autocmds may abort script processing */</a>
<a name="ln3737">      retval = FALSE;</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  got_int |= prev_got_int;</a>
<a name="ln3741"> </a>
<a name="ln3742">  return retval;</a>
<a name="ln3743">#undef SET_ERRMSG</a>
<a name="ln3744">#undef SET_ERRMSG_ARG</a>
<a name="ln3745">#undef SET_ERRMSG_NUM</a>
<a name="ln3746">}</a>
<a name="ln3747"> </a>
<a name="ln3748">/*</a>
<a name="ln3749"> * Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln3750"> * name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln3751"> */</a>
<a name="ln3752">static int set_rw_fname(char_u *fname, char_u *sfname)</a>
<a name="ln3753">{</a>
<a name="ln3754">  buf_T       *buf = curbuf;</a>
<a name="ln3755"> </a>
<a name="ln3756">  /* It's like the unnamed buffer is deleted.... */</a>
<a name="ln3757">  if (curbuf-&gt;b_p_bl)</a>
<a name="ln3758">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3759">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3760">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln3761">    return FAIL;</a>
<a name="ln3762">  if (curbuf != buf) {</a>
<a name="ln3763">    /* We are in another buffer now, don't do the renaming. */</a>
<a name="ln3764">    EMSG(_(e_auchangedbuf));</a>
<a name="ln3765">    return FAIL;</a>
<a name="ln3766">  }</a>
<a name="ln3767"> </a>
<a name="ln3768">  if (setfname(curbuf, fname, sfname, false) == OK) {</a>
<a name="ln3769">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln3770">  }</a>
<a name="ln3771"> </a>
<a name="ln3772">  /* ....and a new named one is created */</a>
<a name="ln3773">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3774">  if (curbuf-&gt;b_p_bl)</a>
<a name="ln3775">    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);</a>
<a name="ln3776">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln3777">    return FAIL;</a>
<a name="ln3778"> </a>
<a name="ln3779">  /* Do filetype detection now if 'filetype' is empty. */</a>
<a name="ln3780">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln3781">    if (au_has_group((char_u *)&quot;filetypedetect&quot;)) {</a>
<a name="ln3782">      (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln3783">    }</a>
<a name="ln3784">    do_modelines(0);</a>
<a name="ln3785">  }</a>
<a name="ln3786"> </a>
<a name="ln3787">  return OK;</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">/// Put file name into the specified buffer with quotes</a>
<a name="ln3791">///</a>
<a name="ln3792">/// Replaces home directory at the start with `~`.</a>
<a name="ln3793">///</a>
<a name="ln3794">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln3795">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln3796">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln3797">/// @param[in]  fname  File name to write.</a>
<a name="ln3798">static void add_quoted_fname(char *const ret_buf, const size_t buf_len,</a>
<a name="ln3799">                             const buf_T *const buf, const char *fname)</a>
<a name="ln3800">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3801">{</a>
<a name="ln3802">  if (fname == NULL) {</a>
<a name="ln3803">    fname = &quot;-stdin-&quot;;</a>
<a name="ln3804">  }</a>
<a name="ln3805">  ret_buf[0] = '&quot;';</a>
<a name="ln3806">  home_replace(buf, (const char_u *)fname, (char_u *)ret_buf + 1,</a>
<a name="ln3807">               (int)buf_len - 4, true);</a>
<a name="ln3808">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln3809">}</a>
<a name="ln3810"> </a>
<a name="ln3811">/// Append message for text mode to IObuff.</a>
<a name="ln3812">///</a>
<a name="ln3813">/// @param eol_type line ending type</a>
<a name="ln3814">///</a>
<a name="ln3815">/// @return true if something was appended.</a>
<a name="ln3816">static bool msg_add_fileformat(int eol_type)</a>
<a name="ln3817">{</a>
<a name="ln3818">#ifndef USE_CRNL</a>
<a name="ln3819">  if (eol_type == EOL_DOS) {</a>
<a name="ln3820">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[dos]&quot;) : _(&quot;[dos format]&quot;));</a>
<a name="ln3821">    return true;</a>
<a name="ln3822">  }</a>
<a name="ln3823">#endif</a>
<a name="ln3824">  if (eol_type == EOL_MAC) {</a>
<a name="ln3825">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[mac]&quot;) : _(&quot;[mac format]&quot;));</a>
<a name="ln3826">    return true;</a>
<a name="ln3827">  }</a>
<a name="ln3828">#ifdef USE_CRNL</a>
<a name="ln3829">  if (eol_type == EOL_UNIX) {</a>
<a name="ln3830">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[unix]&quot;) : _(&quot;[unix format]&quot;));</a>
<a name="ln3831">    return true;</a>
<a name="ln3832">  }</a>
<a name="ln3833">#endif</a>
<a name="ln3834">  return false;</a>
<a name="ln3835">}</a>
<a name="ln3836"> </a>
<a name="ln3837">/*</a>
<a name="ln3838"> * Append line and character count to IObuff.</a>
<a name="ln3839"> */</a>
<a name="ln3840">void msg_add_lines(int insert_space, long lnum, off_T nchars)</a>
<a name="ln3841">{</a>
<a name="ln3842">  char_u  *p;</a>
<a name="ln3843"> </a>
<a name="ln3844">  p = IObuff + STRLEN(IObuff);</a>
<a name="ln3845"> </a>
<a name="ln3846">  if (insert_space)</a>
<a name="ln3847">    *p++ = ' ';</a>
<a name="ln3848">  if (shortmess(SHM_LINES)) {</a>
<a name="ln3849">     sprintf((char *)p, &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;C&quot;,</a>
<a name="ln3850">             (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln3851">  }</a>
<a name="ln3852">  else {</a>
<a name="ln3853">    if (lnum == 1)</a>
<a name="ln3854">      STRCPY(p, _(&quot;1 line, &quot;));</a>
<a name="ln3855">    else</a>
<a name="ln3856">      sprintf((char *)p, _(&quot;%&quot; PRId64 &quot; lines, &quot;), (int64_t)lnum);</a>
<a name="ln3857">    p += STRLEN(p);</a>
<a name="ln3858">    if (nchars == 1)</a>
<a name="ln3859">      STRCPY(p, _(&quot;1 character&quot;));</a>
<a name="ln3860">    else {</a>
<a name="ln3861">      sprintf((char *)p, _(&quot;%&quot; PRId64 &quot; characters&quot;), (int64_t)nchars);</a>
<a name="ln3862">    }</a>
<a name="ln3863">  }</a>
<a name="ln3864">}</a>
<a name="ln3865"> </a>
<a name="ln3866">/*</a>
<a name="ln3867"> * Append message for missing line separator to IObuff.</a>
<a name="ln3868"> */</a>
<a name="ln3869">static void msg_add_eol(void)</a>
<a name="ln3870">{</a>
<a name="ln3871">  STRCAT(IObuff,</a>
<a name="ln3872">      shortmess(SHM_LAST) ? _(&quot;[noeol]&quot;) : _(&quot;[Incomplete last line]&quot;));</a>
<a name="ln3873">}</a>
<a name="ln3874"> </a>
<a name="ln3875">/*</a>
<a name="ln3876"> * Check modification time of file, before writing to it.</a>
<a name="ln3877"> * The size isn't checked, because using a tool like &quot;gzip&quot; takes care of</a>
<a name="ln3878"> * using the same timestamp but can't set the size.</a>
<a name="ln3879"> */</a>
<a name="ln3880">static int check_mtime(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3881">{</a>
<a name="ln3882">  if (buf-&gt;b_mtime_read != 0</a>
<a name="ln3883">      &amp;&amp; time_differs(file_info-&gt;stat.st_mtim.tv_sec,</a>
<a name="ln3884">                      buf-&gt;b_mtime_read)) {</a>
<a name="ln3885">    msg_scroll = true;  // Don't overwrite messages here.</a>
<a name="ln3886">    msg_silent = 0;     // Must give this prompt.</a>
<a name="ln3887">    // Don't use emsg() here, don't want to flush the buffers.</a>
<a name="ln3888">    msg_attr(_(&quot;WARNING: The file has been changed since reading it!!!&quot;),</a>
<a name="ln3889">             HL_ATTR(HLF_E));</a>
<a name="ln3890">    if (ask_yesno(_(&quot;Do you really want to write to it&quot;), true) == 'n') {</a>
<a name="ln3891">      return FAIL;</a>
<a name="ln3892">    }</a>
<a name="ln3893">    msg_scroll = false;  // Always overwrite the file message now.</a>
<a name="ln3894">  }</a>
<a name="ln3895">  return OK;</a>
<a name="ln3896">}</a>
<a name="ln3897"> </a>
<a name="ln3898">/// Return true if the times differ</a>
<a name="ln3899">///</a>
<a name="ln3900">/// @param t1 first time</a>
<a name="ln3901">/// @param t2 second time</a>
<a name="ln3902">static bool time_differs(long t1, long t2) FUNC_ATTR_CONST</a>
<a name="ln3903">{</a>
<a name="ln3904">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln3905">  /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln3906">   * the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln3907">   * time may change unexpectedly by one second!!! */</a>
<a name="ln3908">  return t1 - t2 &gt; 1 || t2 - t1 &gt; 1;</a>
<a name="ln3909">#else</a>
<a name="ln3910">  return t1 != t2;</a>
<a name="ln3911">#endif</a>
<a name="ln3912">}</a>
<a name="ln3913"> </a>
<a name="ln3914">/*</a>
<a name="ln3915"> * Call write() to write a number of bytes to the file.</a>
<a name="ln3916"> * Handles 'encoding' conversion.</a>
<a name="ln3917"> *</a>
<a name="ln3918"> * Return FAIL for failure, OK otherwise.</a>
<a name="ln3919"> */</a>
<a name="ln3920">static int buf_write_bytes(struct bw_info *ip)</a>
<a name="ln3921">{</a>
<a name="ln3922">  int wlen;</a>
<a name="ln3923">  char_u      *buf = ip-&gt;bw_buf;        /* data to write */</a>
<a name="ln3924">  int len = ip-&gt;bw_len;                 /* length of data */</a>
<a name="ln3925">#ifdef HAS_BW_FLAGS</a>
<a name="ln3926">  int flags = ip-&gt;bw_flags;             /* extra flags */</a>
<a name="ln3927">#endif</a>
<a name="ln3928"> </a>
<a name="ln3929">  /*</a>
<a name="ln3930">   * Skip conversion when writing the BOM.</a>
<a name="ln3931">   */</a>
<a name="ln3932">  if (!(flags &amp; FIO_NOCONVERT)) {</a>
<a name="ln3933">    char_u          *p;</a>
<a name="ln3934">    unsigned c;</a>
<a name="ln3935">    int n;</a>
<a name="ln3936"> </a>
<a name="ln3937">    if (flags &amp; FIO_UTF8) {</a>
<a name="ln3938">      /*</a>
<a name="ln3939">       * Convert latin1 in the buffer to UTF-8 in the file.</a>
<a name="ln3940">       */</a>
<a name="ln3941">      p = ip-&gt;bw_conv_buf;              /* translate to buffer */</a>
<a name="ln3942">      for (wlen = 0; wlen &lt; len; ++wlen)</a>
<a name="ln3943">        p += utf_char2bytes(buf[wlen], p);</a>
<a name="ln3944">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3945">      len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3946">    } else if (flags &amp; (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {</a>
<a name="ln3947">      /*</a>
<a name="ln3948">       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or</a>
<a name="ln3949">       * Latin1 chars in the file.</a>
<a name="ln3950">       */</a>
<a name="ln3951">      if (flags &amp; FIO_LATIN1)</a>
<a name="ln3952">        p = buf;                /* translate in-place (can only get shorter) */</a>
<a name="ln3953">      else</a>
<a name="ln3954">        p = ip-&gt;bw_conv_buf;            /* translate to buffer */</a>
<a name="ln3955">      for (wlen = 0; wlen &lt; len; wlen += n) {</a>
<a name="ln3956">        if (wlen == 0 &amp;&amp; ip-&gt;bw_restlen != 0) {</a>
<a name="ln3957">          int l;</a>
<a name="ln3958"> </a>
<a name="ln3959">          /* Use remainder of previous call.  Append the start of</a>
<a name="ln3960">           * buf[] to get a full sequence.  Might still be too</a>
<a name="ln3961">           * short! */</a>
<a name="ln3962">          l = CONV_RESTLEN - ip-&gt;bw_restlen;</a>
<a name="ln3963">          if (l &gt; len)</a>
<a name="ln3964">            l = len;</a>
<a name="ln3965">          memmove(ip-&gt;bw_rest + ip-&gt;bw_restlen, buf, (size_t)l);</a>
<a name="ln3966">          n = utf_ptr2len_len(ip-&gt;bw_rest, ip-&gt;bw_restlen + l);</a>
<a name="ln3967">          if (n &gt; ip-&gt;bw_restlen + len) {</a>
<a name="ln3968">            /* We have an incomplete byte sequence at the end to</a>
<a name="ln3969">             * be written.  We can't convert it without the</a>
<a name="ln3970">             * remaining bytes.  Keep them for the next call. */</a>
<a name="ln3971">            if (ip-&gt;bw_restlen + len &gt; CONV_RESTLEN)</a>
<a name="ln3972">              return FAIL;</a>
<a name="ln3973">            ip-&gt;bw_restlen += len;</a>
<a name="ln3974">            break;</a>
<a name="ln3975">          }</a>
<a name="ln3976">          if (n &gt; 1)</a>
<a name="ln3977">            c = utf_ptr2char(ip-&gt;bw_rest);</a>
<a name="ln3978">          else</a>
<a name="ln3979">            c = ip-&gt;bw_rest[0];</a>
<a name="ln3980">          if (n &gt;= ip-&gt;bw_restlen) {</a>
<a name="ln3981">            n -= ip-&gt;bw_restlen;</a>
<a name="ln3982">            ip-&gt;bw_restlen = 0;</a>
<a name="ln3983">          } else {</a>
<a name="ln3984">            ip-&gt;bw_restlen -= n;</a>
<a name="ln3985">            memmove(ip-&gt;bw_rest, ip-&gt;bw_rest + n,</a>
<a name="ln3986">                (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3987">            n = 0;</a>
<a name="ln3988">          }</a>
<a name="ln3989">        } else {</a>
<a name="ln3990">          n = utf_ptr2len_len(buf + wlen, len - wlen);</a>
<a name="ln3991">          if (n &gt; len - wlen) {</a>
<a name="ln3992">            /* We have an incomplete byte sequence at the end to</a>
<a name="ln3993">             * be written.  We can't convert it without the</a>
<a name="ln3994">             * remaining bytes.  Keep them for the next call. */</a>
<a name="ln3995">            if (len - wlen &gt; CONV_RESTLEN)</a>
<a name="ln3996">              return FAIL;</a>
<a name="ln3997">            ip-&gt;bw_restlen = len - wlen;</a>
<a name="ln3998">            memmove(ip-&gt;bw_rest, buf + wlen,</a>
<a name="ln3999">                (size_t)ip-&gt;bw_restlen);</a>
<a name="ln4000">            break;</a>
<a name="ln4001">          }</a>
<a name="ln4002">          if (n &gt; 1)</a>
<a name="ln4003">            c = utf_ptr2char(buf + wlen);</a>
<a name="ln4004">          else</a>
<a name="ln4005">            c = buf[wlen];</a>
<a name="ln4006">        }</a>
<a name="ln4007"> </a>
<a name="ln4008">        if (ucs2bytes(c, &amp;p, flags) &amp;&amp; !ip-&gt;bw_conv_error) {</a>
<a name="ln4009">          ip-&gt;bw_conv_error = TRUE;</a>
<a name="ln4010">          ip-&gt;bw_conv_error_lnum = ip-&gt;bw_start_lnum;</a>
<a name="ln4011">        }</a>
<a name="ln4012">        if (c == NL)</a>
<a name="ln4013">          ++ip-&gt;bw_start_lnum;</a>
<a name="ln4014">      }</a>
<a name="ln4015">      if (flags &amp; FIO_LATIN1)</a>
<a name="ln4016">        len = (int)(p - buf);</a>
<a name="ln4017">      else {</a>
<a name="ln4018">        buf = ip-&gt;bw_conv_buf;</a>
<a name="ln4019">        len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln4020">      }</a>
<a name="ln4021">    }</a>
<a name="ln4022"> </a>
<a name="ln4023"># ifdef HAVE_ICONV</a>
<a name="ln4024">    if (ip-&gt;bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln4025">      const char  *from;</a>
<a name="ln4026">      size_t fromlen;</a>
<a name="ln4027">      char        *to;</a>
<a name="ln4028">      size_t tolen;</a>
<a name="ln4029"> </a>
<a name="ln4030">      /* Convert with iconv(). */</a>
<a name="ln4031">      if (ip-&gt;bw_restlen &gt; 0) {</a>
<a name="ln4032">        char *fp;</a>
<a name="ln4033"> </a>
<a name="ln4034">        /* Need to concatenate the remainder of the previous call and</a>
<a name="ln4035">         * the bytes of the current call.  Use the end of the</a>
<a name="ln4036">         * conversion buffer for this. */</a>
<a name="ln4037">        fromlen = len + ip-&gt;bw_restlen;</a>
<a name="ln4038">        fp = (char *)ip-&gt;bw_conv_buf + ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln4039">        memmove(fp, ip-&gt;bw_rest, (size_t)ip-&gt;bw_restlen);</a>
<a name="ln4040">        memmove(fp + ip-&gt;bw_restlen, buf, (size_t)len);</a>
<a name="ln4041">        from = fp;</a>
<a name="ln4042">        tolen = ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln4043">      } else {</a>
<a name="ln4044">        from = (const char *)buf;</a>
<a name="ln4045">        fromlen = len;</a>
<a name="ln4046">        tolen = ip-&gt;bw_conv_buflen;</a>
<a name="ln4047">      }</a>
<a name="ln4048">      to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln4049"> </a>
<a name="ln4050">      if (ip-&gt;bw_first) {</a>
<a name="ln4051">        size_t save_len = tolen;</a>
<a name="ln4052"> </a>
<a name="ln4053">        /* output the initial shift state sequence */</a>
<a name="ln4054">        (void)iconv(ip-&gt;bw_iconv_fd, NULL, NULL, &amp;to, &amp;tolen);</a>
<a name="ln4055"> </a>
<a name="ln4056">        /* There is a bug in iconv() on Linux (which appears to be</a>
<a name="ln4057">         * wide-spread) which sets &quot;to&quot; to NULL and messes up &quot;tolen&quot;.</a>
<a name="ln4058">         */</a>
<a name="ln4059">        if (to == NULL) {</a>
<a name="ln4060">          to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln4061">          tolen = save_len;</a>
<a name="ln4062">        }</a>
<a name="ln4063">        ip-&gt;bw_first = FALSE;</a>
<a name="ln4064">      }</a>
<a name="ln4065"> </a>
<a name="ln4066">      /*</a>
<a name="ln4067">       * If iconv() has an error or there is not enough room, fail.</a>
<a name="ln4068">       */</a>
<a name="ln4069">      if ((iconv(ip-&gt;bw_iconv_fd, (void *)&amp;from, &amp;fromlen, &amp;to, &amp;tolen)</a>
<a name="ln4070">           == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln4071">          || fromlen &gt; CONV_RESTLEN) {</a>
<a name="ln4072">        ip-&gt;bw_conv_error = TRUE;</a>
<a name="ln4073">        return FAIL;</a>
<a name="ln4074">      }</a>
<a name="ln4075"> </a>
<a name="ln4076">      /* copy remainder to ip-&gt;bw_rest[] to be used for the next call. */</a>
<a name="ln4077">      if (fromlen &gt; 0)</a>
<a name="ln4078">        memmove(ip-&gt;bw_rest, (void *)from, fromlen);</a>
<a name="ln4079">      ip-&gt;bw_restlen = (int)fromlen;</a>
<a name="ln4080"> </a>
<a name="ln4081">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln4082">      len = (int)((char_u *)to - ip-&gt;bw_conv_buf);</a>
<a name="ln4083">    }</a>
<a name="ln4084"># endif</a>
<a name="ln4085">  }</a>
<a name="ln4086"> </a>
<a name="ln4087">  if (ip-&gt;bw_fd &lt; 0) {</a>
<a name="ln4088">    // Only checking conversion, which is OK if we get here.</a>
<a name="ln4089">    return OK;</a>
<a name="ln4090">  }</a>
<a name="ln4091">  wlen = write_eintr(ip-&gt;bw_fd, buf, len);</a>
<a name="ln4092">  return (wlen &lt; len) ? FAIL : OK;</a>
<a name="ln4093">}</a>
<a name="ln4094"> </a>
<a name="ln4095">/// Convert a Unicode character to bytes.</a>
<a name="ln4096">///</a>
<a name="ln4097">/// @param c character to convert</a>
<a name="ln4098">/// @param[in,out] pp pointer to store the result at</a>
<a name="ln4099">/// @param flags FIO_ flags that specify which encoding to use</a>
<a name="ln4100">///</a>
<a name="ln4101">/// @return true for an error, false when it's OK.</a>
<a name="ln4102">static bool ucs2bytes(unsigned c, char_u **pp, int flags) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4103">{</a>
<a name="ln4104">  char_u      *p = *pp;</a>
<a name="ln4105">  bool error = false;</a>
<a name="ln4106">  int cc;</a>
<a name="ln4107"> </a>
<a name="ln4108"> </a>
<a name="ln4109">  if (flags &amp; FIO_UCS4) {</a>
<a name="ln4110">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4111">      *p++ = c;</a>
<a name="ln4112">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4113">      *p++ = (c &gt;&gt; 16);</a>
<a name="ln4114">      *p++ = (c &gt;&gt; 24);</a>
<a name="ln4115">    } else {</a>
<a name="ln4116">      *p++ = (c &gt;&gt; 24);</a>
<a name="ln4117">      *p++ = (c &gt;&gt; 16);</a>
<a name="ln4118">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4119">      *p++ = c;</a>
<a name="ln4120">    }</a>
<a name="ln4121">  } else if (flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln4122">    if (c &gt;= 0x10000) {</a>
<a name="ln4123">      if (flags &amp; FIO_UTF16) {</a>
<a name="ln4124">        /* Make two words, ten bits of the character in each.  First</a>
<a name="ln4125">         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */</a>
<a name="ln4126">        c -= 0x10000;</a>
<a name="ln4127">        if (c &gt;= 0x100000) {</a>
<a name="ln4128">          error = true;</a>
<a name="ln4129">        }</a>
<a name="ln4130">        cc = ((c &gt;&gt; 10) &amp; 0x3ff) + 0xd800;</a>
<a name="ln4131">        if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4132">          *p++ = cc;</a>
<a name="ln4133">          *p++ = ((unsigned)cc &gt;&gt; 8);</a>
<a name="ln4134">        } else {</a>
<a name="ln4135">          *p++ = ((unsigned)cc &gt;&gt; 8);</a>
<a name="ln4136">          *p++ = cc;</a>
<a name="ln4137">        }</a>
<a name="ln4138">        c = (c &amp; 0x3ff) + 0xdc00;</a>
<a name="ln4139">      } else {</a>
<a name="ln4140">        error = true;</a>
<a name="ln4141">      }</a>
<a name="ln4142">    }</a>
<a name="ln4143">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4144">      *p++ = c;</a>
<a name="ln4145">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4146">    } else {</a>
<a name="ln4147">      *p++ = (c &gt;&gt; 8);</a>
<a name="ln4148">      *p++ = c;</a>
<a name="ln4149">    }</a>
<a name="ln4150">  } else { /* Latin1 */</a>
<a name="ln4151">    if (c &gt;= 0x100) {</a>
<a name="ln4152">      error = true;</a>
<a name="ln4153">      *p++ = 0xBF;</a>
<a name="ln4154">    } else</a>
<a name="ln4155">      *p++ = c;</a>
<a name="ln4156">  }</a>
<a name="ln4157"> </a>
<a name="ln4158">  *pp = p;</a>
<a name="ln4159">  return error;</a>
<a name="ln4160">}</a>
<a name="ln4161"> </a>
<a name="ln4162">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln4163">/// 'encoding'.</a>
<a name="ln4164">///</a>
<a name="ln4165">/// @param fenc file encoding to check</a>
<a name="ln4166">///</a>
<a name="ln4167">/// @return true if conversion is required</a>
<a name="ln4168">static bool need_conversion(const char_u *fenc)</a>
<a name="ln4169">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4170">{</a>
<a name="ln4171">  int same_encoding;</a>
<a name="ln4172">  int enc_flags;</a>
<a name="ln4173">  int fenc_flags;</a>
<a name="ln4174"> </a>
<a name="ln4175">  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {</a>
<a name="ln4176">    same_encoding = TRUE;</a>
<a name="ln4177">    fenc_flags = 0;</a>
<a name="ln4178">  } else {</a>
<a name="ln4179">    /* Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln4180">     * &quot;ucs-4be&quot;, etc. */</a>
<a name="ln4181">    enc_flags = get_fio_flags(p_enc);</a>
<a name="ln4182">    fenc_flags = get_fio_flags(fenc);</a>
<a name="ln4183">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln4184">  }</a>
<a name="ln4185">  if (same_encoding) {</a>
<a name="ln4186">    // Specified file encoding matches UTF-8.</a>
<a name="ln4187">    return false;</a>
<a name="ln4188">  }</a>
<a name="ln4189"> </a>
<a name="ln4190">  /* Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln4191">   * Unicode encoding and the file is UTF-8. */</a>
<a name="ln4192">  return !(enc_utf8 &amp;&amp; fenc_flags == FIO_UTF8);</a>
<a name="ln4193">}</a>
<a name="ln4194"> </a>
<a name="ln4195">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln4196">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln4197">/// use 'encoding'.</a>
<a name="ln4198">///</a>
<a name="ln4199">/// @param name string to check for encoding</a>
<a name="ln4200">static int get_fio_flags(const char_u *name)</a>
<a name="ln4201">{</a>
<a name="ln4202">  int prop;</a>
<a name="ln4203"> </a>
<a name="ln4204">  if (*name == NUL) {</a>
<a name="ln4205">    name = p_enc;</a>
<a name="ln4206">  }</a>
<a name="ln4207">  prop = enc_canon_props(name);</a>
<a name="ln4208">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln4209">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln4210">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4211">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln4212">      return FIO_UCS2;</a>
<a name="ln4213">    }</a>
<a name="ln4214">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln4215">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4216">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln4217">      return FIO_UCS4;</a>
<a name="ln4218">    }</a>
<a name="ln4219">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln4220">      if (prop &amp; ENC_ENDIAN_L)</a>
<a name="ln4221">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln4222">      return FIO_UTF16;</a>
<a name="ln4223">    }</a>
<a name="ln4224">    return FIO_UTF8;</a>
<a name="ln4225">  }</a>
<a name="ln4226">  if (prop &amp; ENC_LATIN1)</a>
<a name="ln4227">    return FIO_LATIN1;</a>
<a name="ln4228">  /* must be ENC_DBCS, requires iconv() */</a>
<a name="ln4229">  return 0;</a>
<a name="ln4230">}</a>
<a name="ln4231"> </a>
<a name="ln4232"> </a>
<a name="ln4233"> </a>
<a name="ln4234">/*</a>
<a name="ln4235"> * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln4236"> * &quot;size&quot; must be at least 2.</a>
<a name="ln4237"> * Return the name of the encoding and set &quot;*lenp&quot; to the length.</a>
<a name="ln4238"> * Returns NULL when no BOM found.</a>
<a name="ln4239"> */</a>
<a name="ln4240">static char_u *check_for_bom(char_u *p, long size, int *lenp, int flags)</a>
<a name="ln4241">{</a>
<a name="ln4242">  char        *name = NULL;</a>
<a name="ln4243">  int len = 2;</a>
<a name="ln4244"> </a>
<a name="ln4245">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln4246">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln4247">    name = &quot;utf-8&quot;;             /* EF BB BF */</a>
<a name="ln4248">    len = 3;</a>
<a name="ln4249">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln4250">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln4251">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln4252">      name = &quot;ucs-4le&quot;;         /* FF FE 00 00 */</a>
<a name="ln4253">      len = 4;</a>
<a name="ln4254">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))</a>
<a name="ln4255">      name = &quot;ucs-2le&quot;;         /* FF FE */</a>
<a name="ln4256">    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))</a>
<a name="ln4257">      /* utf-16le is preferred, it also works for ucs-2le text */</a>
<a name="ln4258">      name = &quot;utf-16le&quot;;        /* FF FE */</a>
<a name="ln4259">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln4260">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln4261">                 FIO_UTF16)) {</a>
<a name="ln4262">    /* Default to utf-16, it works also for ucs-2 text. */</a>
<a name="ln4263">    if (flags == FIO_UCS2)</a>
<a name="ln4264">      name = &quot;ucs-2&quot;;           /* FE FF */</a>
<a name="ln4265">    else</a>
<a name="ln4266">      name = &quot;utf-16&quot;;          /* FE FF */</a>
<a name="ln4267">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln4268">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln4269">    name = &quot;ucs-4&quot;;             /* 00 00 FE FF */</a>
<a name="ln4270">    len = 4;</a>
<a name="ln4271">  }</a>
<a name="ln4272"> </a>
<a name="ln4273">  *lenp = len;</a>
<a name="ln4274">  return (char_u *)name;</a>
<a name="ln4275">}</a>
<a name="ln4276"> </a>
<a name="ln4277">/*</a>
<a name="ln4278"> * Generate a BOM in &quot;buf[4]&quot; for encoding &quot;name&quot;.</a>
<a name="ln4279"> * Return the length of the BOM (zero when no BOM).</a>
<a name="ln4280"> */</a>
<a name="ln4281">static int make_bom(char_u *buf, char_u *name)</a>
<a name="ln4282">{</a>
<a name="ln4283">  int flags;</a>
<a name="ln4284">  char_u      *p;</a>
<a name="ln4285"> </a>
<a name="ln4286">  flags = get_fio_flags(name);</a>
<a name="ln4287"> </a>
<a name="ln4288">  /* Can't put a BOM in a non-Unicode file. */</a>
<a name="ln4289">  if (flags == FIO_LATIN1 || flags == 0)</a>
<a name="ln4290">    return 0;</a>
<a name="ln4291"> </a>
<a name="ln4292">  if (flags == FIO_UTF8) {      /* UTF-8 */</a>
<a name="ln4293">    buf[0] = 0xef;</a>
<a name="ln4294">    buf[1] = 0xbb;</a>
<a name="ln4295">    buf[2] = 0xbf;</a>
<a name="ln4296">    return 3;</a>
<a name="ln4297">  }</a>
<a name="ln4298">  p = buf;</a>
<a name="ln4299">  (void)ucs2bytes(0xfeff, &amp;p, flags);</a>
<a name="ln4300">  return (int)(p - buf);</a>
<a name="ln4301">}</a>
<a name="ln4302"> </a>
<a name="ln4303">/// Shorten filename of a buffer.</a>
<a name="ln4304">/// When &quot;force&quot; is TRUE: Use full path from now on for files currently being</a>
<a name="ln4305">/// edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln4306">/// names a bit, if safe to do so.</a>
<a name="ln4307">/// When &quot;force&quot; is FALSE: Only try to shorten absolute file names.</a>
<a name="ln4308">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln4309">/// name.</a>
<a name="ln4310">void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)</a>
<a name="ln4311">{</a>
<a name="ln4312">  char_u      *p;</a>
<a name="ln4313"> </a>
<a name="ln4314">  if (buf-&gt;b_fname != NULL</a>
<a name="ln4315">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln4316">      &amp;&amp; !path_with_url((char *)buf-&gt;b_fname)</a>
<a name="ln4317">      &amp;&amp; (force</a>
<a name="ln4318">          || buf-&gt;b_sfname == NULL</a>
<a name="ln4319">          || path_is_absolute(buf-&gt;b_sfname))) {</a>
<a name="ln4320">    XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln4321">    p = path_shorten_fname(buf-&gt;b_ffname, dirname);</a>
<a name="ln4322">    if (p != NULL) {</a>
<a name="ln4323">      buf-&gt;b_sfname = vim_strsave(p);</a>
<a name="ln4324">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln4325">    }</a>
<a name="ln4326">    if (p == NULL) {</a>
<a name="ln4327">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln4328">    }</a>
<a name="ln4329">  }</a>
<a name="ln4330">}</a>
<a name="ln4331"> </a>
<a name="ln4332">/// Shorten filenames for all buffers.</a>
<a name="ln4333">void shorten_fnames(int force)</a>
<a name="ln4334">{</a>
<a name="ln4335">  char_u dirname[MAXPATHL];</a>
<a name="ln4336"> </a>
<a name="ln4337">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln4338">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4339">      shorten_buf_fname(buf, dirname, force);</a>
<a name="ln4340"> </a>
<a name="ln4341">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln4342">    // also have a swap file.</a>
<a name="ln4343">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln4344">  }</a>
<a name="ln4345">  status_redraw_all();</a>
<a name="ln4346">  redraw_tabline = TRUE;</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">/// Get new filename ended by given extension.</a>
<a name="ln4350">///</a>
<a name="ln4351">/// @param fname        The original filename.</a>
<a name="ln4352">///                     If NULL, use current directory name and ext to</a>
<a name="ln4353">///                     compute new filename.</a>
<a name="ln4354">/// @param ext          The extension to add to the filename.</a>
<a name="ln4355">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln4356">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln4357">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln4358">///                     if fname is NULL.</a>
<a name="ln4359">///</a>
<a name="ln4360">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln4361">///                       * fname + ext, if fname not NULL.</a>
<a name="ln4362">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln4363">///                       Result is guaranteed to:</a>
<a name="ln4364">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln4365">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln4366">///                         original basename is truncated if necessary.</a>
<a name="ln4367">///                       * be different than original: basename chars are</a>
<a name="ln4368">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln4369">///                         because truncated value of original filename was</a>
<a name="ln4370">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln4371">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln4372">///                       to get current directory.</a>
<a name="ln4373">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln4374">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln4375">{</a>
<a name="ln4376">  char *retval;</a>
<a name="ln4377">  size_t fnamelen;</a>
<a name="ln4378">  size_t extlen = strlen(ext);</a>
<a name="ln4379"> </a>
<a name="ln4380">  // If there is no file name we must get the name of the current directory</a>
<a name="ln4381">  // (we need the full path in case :cd is used).</a>
<a name="ln4382">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln4383">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln4384">    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL</a>
<a name="ln4385">        || (fnamelen = strlen(retval)) == 0) {</a>
<a name="ln4386">      xfree(retval);</a>
<a name="ln4387">      return NULL;</a>
<a name="ln4388">    }</a>
<a name="ln4389">    add_pathsep(retval);</a>
<a name="ln4390">    fnamelen = strlen(retval);</a>
<a name="ln4391">    prepend_dot = FALSE;  // nothing to prepend a dot to</a>
<a name="ln4392">  } else {</a>
<a name="ln4393">    fnamelen = strlen(fname);</a>
<a name="ln4394">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln4395">    strcpy(retval, fname);</a>
<a name="ln4396">  }</a>
<a name="ln4397"> </a>
<a name="ln4398">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln4399">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln4400">  char *ptr = NULL;</a>
<a name="ln4401">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln4402">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln4403">      ptr++;</a>
<a name="ln4404">      break;</a>
<a name="ln4405">    }</a>
<a name="ln4406">  }</a>
<a name="ln4407"> </a>
<a name="ln4408">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln4409">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln4410">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln4411">  }</a>
<a name="ln4412"> </a>
<a name="ln4413">  char *s;</a>
<a name="ln4414">  s = ptr + strlen(ptr);</a>
<a name="ln4415"> </a>
<a name="ln4416">  // Append the extension.</a>
<a name="ln4417">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln4418">  strcpy(s, ext);</a>
<a name="ln4419"> </a>
<a name="ln4420">  char *e;</a>
<a name="ln4421">  // Prepend the dot if needed.</a>
<a name="ln4422">  if (prepend_dot &amp;&amp; *(e = (char *)path_tail((char_u *)retval)) != '.') {</a>
<a name="ln4423">    STRMOVE(e + 1, e);</a>
<a name="ln4424">    *e = '.';</a>
<a name="ln4425">  }</a>
<a name="ln4426"> </a>
<a name="ln4427">  // Check that, after appending the extension, the file name is really</a>
<a name="ln4428">  // different.</a>
<a name="ln4429">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln4430">    // we search for a character that can be replaced by '_'</a>
<a name="ln4431">    while (--s &gt;= ptr) {</a>
<a name="ln4432">      if (*s != '_') {</a>
<a name="ln4433">        *s = '_';</a>
<a name="ln4434">        break;</a>
<a name="ln4435">      }</a>
<a name="ln4436">    }</a>
<a name="ln4437">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln4438">      *ptr = 'v';</a>
<a name="ln4439">    }</a>
<a name="ln4440">  }</a>
<a name="ln4441">  return retval;</a>
<a name="ln4442">}</a>
<a name="ln4443"> </a>
<a name="ln4444">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln4445">/// rest of the line is thrown away.</a>
<a name="ln4446">///</a>
<a name="ln4447">/// @param[out] buf buffer to fill</a>
<a name="ln4448">/// @param size size of the buffer</a>
<a name="ln4449">/// @param fp file to read from</a>
<a name="ln4450">///</a>
<a name="ln4451">/// @return true for EOF or error</a>
<a name="ln4452">bool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4453">{</a>
<a name="ln4454">  char *retval;</a>
<a name="ln4455"> </a>
<a name="ln4456">  assert(size &gt; 0);</a>
<a name="ln4457">  buf[size - 2] = NUL;</a>
<a name="ln4458"> </a>
<a name="ln4459">  do {</a>
<a name="ln4460">    errno = 0;</a>
<a name="ln4461">    retval = fgets((char *)buf, size, fp);</a>
<a name="ln4462">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln4463"> </a>
<a name="ln4464">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln4465">    char tbuf[200];</a>
<a name="ln4466"> </a>
<a name="ln4467">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln4468"> </a>
<a name="ln4469">    // Now throw away the rest of the line:</a>
<a name="ln4470">    do {</a>
<a name="ln4471">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln4472">      errno = 0;</a>
<a name="ln4473">      retval = fgets((char *)tbuf, sizeof(tbuf), fp);</a>
<a name="ln4474">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln4475">        break;</a>
<a name="ln4476">      }</a>
<a name="ln4477">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln4478">  }</a>
<a name="ln4479">  return retval == NULL;</a>
<a name="ln4480">}</a>
<a name="ln4481"> </a>
<a name="ln4482">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4483">/// Returns -1 when encountering EOF.</a>
<a name="ln4484">int get2c(FILE *fd)</a>
<a name="ln4485">{</a>
<a name="ln4486">  const int n = getc(fd);</a>
<a name="ln4487">  if (n == EOF) {</a>
<a name="ln4488">    return -1;</a>
<a name="ln4489">  }</a>
<a name="ln4490">  const int c = getc(fd);</a>
<a name="ln4491">  if (c == EOF) {</a>
<a name="ln4492">    return -1;</a>
<a name="ln4493">  }</a>
<a name="ln4494">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4495">}</a>
<a name="ln4496"> </a>
<a name="ln4497">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4498">/// Returns -1 when encountering EOF.</a>
<a name="ln4499">int get3c(FILE *fd)</a>
<a name="ln4500">{</a>
<a name="ln4501">  int n = getc(fd);</a>
<a name="ln4502">  if (n == EOF) {</a>
<a name="ln4503">    return -1;</a>
<a name="ln4504">  }</a>
<a name="ln4505">  int c = getc(fd);</a>
<a name="ln4506">  if (c == EOF) {</a>
<a name="ln4507">    return -1;</a>
<a name="ln4508">  }</a>
<a name="ln4509">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln4510">  c = getc(fd);</a>
<a name="ln4511">  if (c == EOF) {</a>
<a name="ln4512">    return -1;</a>
<a name="ln4513">  }</a>
<a name="ln4514">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4515">}</a>
<a name="ln4516"> </a>
<a name="ln4517">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4518">/// Returns -1 when encountering EOF.</a>
<a name="ln4519">int get4c(FILE *fd)</a>
<a name="ln4520">{</a>
<a name="ln4521">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln4522">  // when left-shift sets the MSB.</a>
<a name="ln4523">  unsigned n;</a>
<a name="ln4524"> </a>
<a name="ln4525">  int c = getc(fd);</a>
<a name="ln4526">  if (c == EOF) {</a>
<a name="ln4527">    return -1;</a>
<a name="ln4528">  }</a>
<a name="ln4529">  n = (unsigned)c;</a>
<a name="ln4530">  c = getc(fd);</a>
<a name="ln4531">  if (c == EOF) {</a>
<a name="ln4532">    return -1;</a>
<a name="ln4533">  }</a>
<a name="ln4534">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4535">  c = getc(fd);</a>
<a name="ln4536">  if (c == EOF) {</a>
<a name="ln4537">    return -1;</a>
<a name="ln4538">  }</a>
<a name="ln4539">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4540">  c = getc(fd);</a>
<a name="ln4541">  if (c == EOF) {</a>
<a name="ln4542">    return -1;</a>
<a name="ln4543">  }</a>
<a name="ln4544">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4545">  return (int)n;</a>
<a name="ln4546">}</a>
<a name="ln4547"> </a>
<a name="ln4548">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln4549">/// Returns -1 when encountering EOF.</a>
<a name="ln4550">time_t get8ctime(FILE *fd)</a>
<a name="ln4551">{</a>
<a name="ln4552">  time_t n = 0;</a>
<a name="ln4553"> </a>
<a name="ln4554">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln4555">    const int c = getc(fd);</a>
<a name="ln4556">    if (c == EOF) {</a>
<a name="ln4557">      return -1;</a>
<a name="ln4558">    }</a>
<a name="ln4559">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln4560">  }</a>
<a name="ln4561">  return n;</a>
<a name="ln4562">}</a>
<a name="ln4563"> </a>
<a name="ln4564">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln4565">/// @return pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln4566">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln4567">{</a>
<a name="ln4568">  char *str = xmallocz(cnt);</a>
<a name="ln4569">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln4570">    int c = getc(fd);</a>
<a name="ln4571">    if (c == EOF) {</a>
<a name="ln4572">      xfree(str);</a>
<a name="ln4573">      return NULL;</a>
<a name="ln4574">    }</a>
<a name="ln4575">    str[i] = (char)c;</a>
<a name="ln4576">  }</a>
<a name="ln4577">  return str;</a>
<a name="ln4578">}</a>
<a name="ln4579"> </a>
<a name="ln4580">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln4581">/// @returns false in case of an error.</a>
<a name="ln4582">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln4583">{</a>
<a name="ln4584">  assert(len &gt; 0);</a>
<a name="ln4585">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln4586">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln4587">      return false;</a>
<a name="ln4588">    }</a>
<a name="ln4589">  }</a>
<a name="ln4590">  return true;</a>
<a name="ln4591">}</a>
<a name="ln4592"> </a>
<a name="ln4593">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln4594">/// @returns FAIL when the write failed.</a>
<a name="ln4595">int put_time(FILE *fd, time_t time_)</a>
<a name="ln4596">{</a>
<a name="ln4597">  uint8_t buf[8];</a>
<a name="ln4598">  time_to_bytes(time_, buf);</a>
<a name="ln4599">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln4600">}</a>
<a name="ln4601"> </a>
<a name="ln4602">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln4603">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln4604">///</a>
<a name="ln4605">/// @return -1 for failure, 0 for success</a>
<a name="ln4606">int vim_rename(const char_u *from, const char_u *to)</a>
<a name="ln4607">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4608">{</a>
<a name="ln4609">  int fd_in;</a>
<a name="ln4610">  int fd_out;</a>
<a name="ln4611">  int n;</a>
<a name="ln4612">  char        *errmsg = NULL;</a>
<a name="ln4613">  char        *buffer;</a>
<a name="ln4614">  long perm;</a>
<a name="ln4615">#ifdef HAVE_ACL</a>
<a name="ln4616">  vim_acl_T acl;                /* ACL from original file */</a>
<a name="ln4617">#endif</a>
<a name="ln4618">  bool use_tmp_file = false;</a>
<a name="ln4619"> </a>
<a name="ln4620">  /*</a>
<a name="ln4621">   * When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln4622">   * to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln4623">   * the file name differs we need to go through a temp file.</a>
<a name="ln4624">   */</a>
<a name="ln4625">  if (fnamecmp(from, to) == 0) {</a>
<a name="ln4626">    if (p_fic &amp;&amp; (STRCMP(path_tail((char_u *)from), path_tail((char_u *)to))</a>
<a name="ln4627">                  != 0)) {</a>
<a name="ln4628">      use_tmp_file = true;</a>
<a name="ln4629">    } else {</a>
<a name="ln4630">      return 0;</a>
<a name="ln4631">    }</a>
<a name="ln4632">  }</a>
<a name="ln4633"> </a>
<a name="ln4634">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln4635">  FileInfo from_info;</a>
<a name="ln4636">  if (!os_fileinfo((char *)from, &amp;from_info)) {</a>
<a name="ln4637">    return -1;</a>
<a name="ln4638">  }</a>
<a name="ln4639"> </a>
<a name="ln4640">  // It's possible for the source and destination to be the same file.</a>
<a name="ln4641">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln4642">  // filesystem. In that case go through a temp file name.</a>
<a name="ln4643">  FileInfo to_info;</a>
<a name="ln4644">  if (os_fileinfo((char *)to, &amp;to_info)</a>
<a name="ln4645">      &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln4646">    use_tmp_file = true;</a>
<a name="ln4647">  }</a>
<a name="ln4648"> </a>
<a name="ln4649">  if (use_tmp_file) {</a>
<a name="ln4650">    char_u tempname[MAXPATHL + 1];</a>
<a name="ln4651"> </a>
<a name="ln4652">    /*</a>
<a name="ln4653">     * Find a name that doesn't exist and is in the same directory.</a>
<a name="ln4654">     * Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln4655">     */</a>
<a name="ln4656">    if (STRLEN(from) &gt;= MAXPATHL - 5)</a>
<a name="ln4657">      return -1;</a>
<a name="ln4658">    STRCPY(tempname, from);</a>
<a name="ln4659">    for (n = 123; n &lt; 99999; n++) {</a>
<a name="ln4660">      char * tail = (char *)path_tail(tempname);</a>
<a name="ln4661">      snprintf(tail, (MAXPATHL + 1) - (tail - (char *)tempname - 1), &quot;%d&quot;, n);</a>
<a name="ln4662"> </a>
<a name="ln4663">      if (!os_path_exists(tempname)) {</a>
<a name="ln4664">        if (os_rename(from, tempname) == OK) {</a>
<a name="ln4665">          if (os_rename(tempname, to) == OK)</a>
<a name="ln4666">            return 0;</a>
<a name="ln4667">          /* Strange, the second step failed.  Try moving the</a>
<a name="ln4668">           * file back and return failure. */</a>
<a name="ln4669">          os_rename(tempname, from);</a>
<a name="ln4670">          return -1;</a>
<a name="ln4671">        }</a>
<a name="ln4672">        /* If it fails for one temp name it will most likely fail</a>
<a name="ln4673">         * for any temp name, give up. */</a>
<a name="ln4674">        return -1;</a>
<a name="ln4675">      }</a>
<a name="ln4676">    }</a>
<a name="ln4677">    return -1;</a>
<a name="ln4678">  }</a>
<a name="ln4679"> </a>
<a name="ln4680">  /*</a>
<a name="ln4681">   * Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln4682">   * os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln4683">   * two files when the os_rename() fails.</a>
<a name="ln4684">   */</a>
<a name="ln4685"> </a>
<a name="ln4686">  os_remove((char *)to);</a>
<a name="ln4687"> </a>
<a name="ln4688">  /*</a>
<a name="ln4689">   * First try a normal rename, return if it works.</a>
<a name="ln4690">   */</a>
<a name="ln4691">  if (os_rename(from, to) == OK)</a>
<a name="ln4692">    return 0;</a>
<a name="ln4693"> </a>
<a name="ln4694">  /*</a>
<a name="ln4695">   * Rename() failed, try copying the file.</a>
<a name="ln4696">   */</a>
<a name="ln4697">  perm = os_getperm((const char *)from);</a>
<a name="ln4698">#ifdef HAVE_ACL</a>
<a name="ln4699">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln4700">  acl = mch_get_acl(from);</a>
<a name="ln4701">#endif</a>
<a name="ln4702">  fd_in = os_open((char *)from, O_RDONLY, 0);</a>
<a name="ln4703">  if (fd_in &lt; 0) {</a>
<a name="ln4704">#ifdef HAVE_ACL</a>
<a name="ln4705">    mch_free_acl(acl);</a>
<a name="ln4706">#endif</a>
<a name="ln4707">    return -1;</a>
<a name="ln4708">  }</a>
<a name="ln4709"> </a>
<a name="ln4710">  /* Create the new file with same permissions as the original. */</a>
<a name="ln4711">  fd_out = os_open((char *)to,</a>
<a name="ln4712">      O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);</a>
<a name="ln4713">  if (fd_out &lt; 0) {</a>
<a name="ln4714">    close(fd_in);</a>
<a name="ln4715">#ifdef HAVE_ACL</a>
<a name="ln4716">    mch_free_acl(acl);</a>
<a name="ln4717">#endif</a>
<a name="ln4718">    return -1;</a>
<a name="ln4719">  }</a>
<a name="ln4720"> </a>
<a name="ln4721">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln4722">  // is `preserve_exit()`ing.</a>
<a name="ln4723">  buffer = try_malloc(BUFSIZE);</a>
<a name="ln4724">  if (buffer == NULL) {</a>
<a name="ln4725">    close(fd_out);</a>
<a name="ln4726">    close(fd_in);</a>
<a name="ln4727">#ifdef HAVE_ACL</a>
<a name="ln4728">    mch_free_acl(acl);</a>
<a name="ln4729">#endif</a>
<a name="ln4730">    return -1;</a>
<a name="ln4731">  }</a>
<a name="ln4732"> </a>
<a name="ln4733">  while ((n = read_eintr(fd_in, buffer, BUFSIZE)) &gt; 0)</a>
<a name="ln4734">    if (write_eintr(fd_out, buffer, n) != n) {</a>
<a name="ln4735">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln4736">      break;</a>
<a name="ln4737">    }</a>
<a name="ln4738"> </a>
<a name="ln4739">  xfree(buffer);</a>
<a name="ln4740">  close(fd_in);</a>
<a name="ln4741">  if (close(fd_out) &lt; 0)</a>
<a name="ln4742">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln4743">  if (n &lt; 0) {</a>
<a name="ln4744">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln4745">    to = from;</a>
<a name="ln4746">  }</a>
<a name="ln4747">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln4748">  os_setperm((const char *)to, perm);</a>
<a name="ln4749">#endif</a>
<a name="ln4750">#ifdef HAVE_ACL</a>
<a name="ln4751">  mch_set_acl(to, acl);</a>
<a name="ln4752">  mch_free_acl(acl);</a>
<a name="ln4753">#endif</a>
<a name="ln4754">  if (errmsg != NULL) {</a>
<a name="ln4755">    EMSG2(errmsg, to);</a>
<a name="ln4756">    return -1;</a>
<a name="ln4757">  }</a>
<a name="ln4758">  os_remove((char *)from);</a>
<a name="ln4759">  return 0;</a>
<a name="ln4760">}</a>
<a name="ln4761"> </a>
<a name="ln4762">static int already_warned = FALSE;</a>
<a name="ln4763"> </a>
<a name="ln4764">// Check if any not hidden buffer has been changed.</a>
<a name="ln4765">// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln4766">// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln4767">// busy.</a>
<a name="ln4768">// Returns TRUE if some message was written (screen should be redrawn and</a>
<a name="ln4769">// cursor positioned).</a>
<a name="ln4770">int</a>
<a name="ln4771">check_timestamps(</a>
<a name="ln4772">    int focus                      // called for GUI focus event</a>
<a name="ln4773">)</a>
<a name="ln4774">{</a>
<a name="ln4775">  int didit = 0;</a>
<a name="ln4776">  int n;</a>
<a name="ln4777"> </a>
<a name="ln4778">  /* Don't check timestamps while system() or another low-level function may</a>
<a name="ln4779">   * cause us to lose and gain focus. */</a>
<a name="ln4780">  if (no_check_timestamps &gt; 0)</a>
<a name="ln4781">    return FALSE;</a>
<a name="ln4782"> </a>
<a name="ln4783">  /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln4784">   * event and we would keep on checking if the file is steadily growing.</a>
<a name="ln4785">   * Do check again after typing something. */</a>
<a name="ln4786">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln4787">    need_check_timestamps = TRUE;</a>
<a name="ln4788">    return FALSE;</a>
<a name="ln4789">  }</a>
<a name="ln4790"> </a>
<a name="ln4791">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln4792">      || autocmd_busy || curbuf_lock &gt; 0 || allbuf_lock &gt; 0</a>
<a name="ln4793">      ) {</a>
<a name="ln4794">    need_check_timestamps = true;               // check later</a>
<a name="ln4795">  } else {</a>
<a name="ln4796">    no_wait_return++;</a>
<a name="ln4797">    did_check_timestamps = true;</a>
<a name="ln4798">    already_warned = false;</a>
<a name="ln4799">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4800">      // Only check buffers in a window.</a>
<a name="ln4801">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4802">        bufref_T bufref;</a>
<a name="ln4803">        set_bufref(&amp;bufref, buf);</a>
<a name="ln4804">        n = buf_check_timestamp(buf, focus);</a>
<a name="ln4805">        if (didit &lt; n) {</a>
<a name="ln4806">          didit = n;</a>
<a name="ln4807">        }</a>
<a name="ln4808">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln4809">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln4810">          buf = firstbuf;</a>
<a name="ln4811">          continue;</a>
<a name="ln4812">        }</a>
<a name="ln4813">      }</a>
<a name="ln4814">    }</a>
<a name="ln4815">    --no_wait_return;</a>
<a name="ln4816">    need_check_timestamps = FALSE;</a>
<a name="ln4817">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln4818">      // make sure msg isn't overwritten</a>
<a name="ln4819">      msg_puts(&quot;\n&quot;);</a>
<a name="ln4820">      ui_flush();</a>
<a name="ln4821">    }</a>
<a name="ln4822">  }</a>
<a name="ln4823">  return didit;</a>
<a name="ln4824">}</a>
<a name="ln4825"> </a>
<a name="ln4826">/*</a>
<a name="ln4827"> * Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln4828"> * Return OK or FAIL.  When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not</a>
<a name="ln4829"> * empty.</a>
<a name="ln4830"> */</a>
<a name="ln4831">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln4832">{</a>
<a name="ln4833">  buf_T       *tbuf = curbuf;</a>
<a name="ln4834">  int retval = OK;</a>
<a name="ln4835">  linenr_T lnum;</a>
<a name="ln4836">  char_u      *p;</a>
<a name="ln4837"> </a>
<a name="ln4838">  /* Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;. */</a>
<a name="ln4839">  curbuf = tobuf;</a>
<a name="ln4840">  for (lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln4841">    p = vim_strsave(ml_get_buf(frombuf, lnum, false));</a>
<a name="ln4842">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln4843">      xfree(p);</a>
<a name="ln4844">      retval = FAIL;</a>
<a name="ln4845">      break;</a>
<a name="ln4846">    }</a>
<a name="ln4847">    xfree(p);</a>
<a name="ln4848">  }</a>
<a name="ln4849"> </a>
<a name="ln4850">  /* Delete all the lines in &quot;frombuf&quot;. */</a>
<a name="ln4851">  if (retval != FAIL) {</a>
<a name="ln4852">    curbuf = frombuf;</a>
<a name="ln4853">    for (lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln4854">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln4855">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln4856">        // might fail again...</a>
<a name="ln4857">        retval = FAIL;</a>
<a name="ln4858">        break;</a>
<a name="ln4859">      }</a>
<a name="ln4860">    }</a>
<a name="ln4861">  }</a>
<a name="ln4862"> </a>
<a name="ln4863">  curbuf = tbuf;</a>
<a name="ln4864">  return retval;</a>
<a name="ln4865">}</a>
<a name="ln4866"> </a>
<a name="ln4867">/*</a>
<a name="ln4868"> * Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln4869"> * Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln4870"> * return 1 if a changed buffer was found.</a>
<a name="ln4871"> * return 2 if a message has been displayed.</a>
<a name="ln4872"> * return 0 otherwise.</a>
<a name="ln4873"> */</a>
<a name="ln4874">int</a>
<a name="ln4875">buf_check_timestamp(</a>
<a name="ln4876">    buf_T *buf,</a>
<a name="ln4877">    int focus               /* called for GUI focus event */</a>
<a name="ln4878">)</a>
<a name="ln4879">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4880">{</a>
<a name="ln4881">  int retval = 0;</a>
<a name="ln4882">  char_u      *path;</a>
<a name="ln4883">  char        *mesg = NULL;</a>
<a name="ln4884">  char        *mesg2 = &quot;&quot;;</a>
<a name="ln4885">  bool helpmesg = false;</a>
<a name="ln4886">  bool reload = false;</a>
<a name="ln4887">  bool can_reload = false;</a>
<a name="ln4888">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln4889">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln4890">  static bool busy = false;</a>
<a name="ln4891">  char_u      *s;</a>
<a name="ln4892">  char        *reason;</a>
<a name="ln4893"> </a>
<a name="ln4894">  bufref_T bufref;</a>
<a name="ln4895">  set_bufref(&amp;bufref, buf);</a>
<a name="ln4896"> </a>
<a name="ln4897">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln4898">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln4899">  // recursively: ignore this buffer.</a>
<a name="ln4900">  if (buf-&gt;terminal</a>
<a name="ln4901">      || buf-&gt;b_ffname == NULL</a>
<a name="ln4902">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln4903">      || !bt_normal(buf)</a>
<a name="ln4904">      || buf-&gt;b_saving</a>
<a name="ln4905">      || busy</a>
<a name="ln4906">      )</a>
<a name="ln4907">    return 0;</a>
<a name="ln4908"> </a>
<a name="ln4909">  FileInfo file_info;</a>
<a name="ln4910">  bool file_info_ok;</a>
<a name="ln4911">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln4912">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln4913">      &amp;&amp; (!(file_info_ok = os_fileinfo((char *)buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln4914">          || time_differs(file_info.stat.st_mtim.tv_sec, buf-&gt;b_mtime)</a>
<a name="ln4915">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln4916">    const long prev_b_mtime = buf-&gt;b_mtime;</a>
<a name="ln4917"> </a>
<a name="ln4918">    retval = 1;</a>
<a name="ln4919"> </a>
<a name="ln4920">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln4921">    // FileChangedShell autocmd)</a>
<a name="ln4922">    if (!file_info_ok) {</a>
<a name="ln4923">      // Check the file again later to see if it re-appears.</a>
<a name="ln4924">      buf-&gt;b_mtime = -1;</a>
<a name="ln4925">      buf-&gt;b_orig_size = 0;</a>
<a name="ln4926">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln4927">    } else {</a>
<a name="ln4928">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln4929">    }</a>
<a name="ln4930"> </a>
<a name="ln4931">    /* Don't do anything for a directory.  Might contain the file</a>
<a name="ln4932">     * explorer. */</a>
<a name="ln4933">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln4934">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln4935">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln4936">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln4937">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln4938">      // was set, the global option value otherwise.</a>
<a name="ln4939">      reload = true;</a>
<a name="ln4940">    } else {</a>
<a name="ln4941">      if (!file_info_ok) {</a>
<a name="ln4942">        reason = &quot;deleted&quot;;</a>
<a name="ln4943">      } else if (bufIsChanged(buf)) {</a>
<a name="ln4944">        reason = &quot;conflict&quot;;</a>
<a name="ln4945">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln4946">        reason = &quot;changed&quot;;</a>
<a name="ln4947">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln4948">        reason = &quot;mode&quot;;</a>
<a name="ln4949">      } else {</a>
<a name="ln4950">        reason = &quot;time&quot;;</a>
<a name="ln4951">      }</a>
<a name="ln4952"> </a>
<a name="ln4953">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln4954">      // autocommands.</a>
<a name="ln4955">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln4956">      busy = true;</a>
<a name="ln4957">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln4958">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln4959">      allbuf_lock++;</a>
<a name="ln4960">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL,</a>
<a name="ln4961">                              buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4962">      allbuf_lock--;</a>
<a name="ln4963">      busy = false;</a>
<a name="ln4964">      if (n) {</a>
<a name="ln4965">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln4966">          EMSG(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln4967">        }</a>
<a name="ln4968">        s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln4969">        if (STRCMP(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln4970">          reload = true;</a>
<a name="ln4971">        } else if (STRCMP(s, &quot;ask&quot;) == 0) {</a>
<a name="ln4972">          n = false;</a>
<a name="ln4973">        } else {</a>
<a name="ln4974">          return 2;</a>
<a name="ln4975">        }</a>
<a name="ln4976">      }</a>
<a name="ln4977">      if (!n) {</a>
<a name="ln4978">        if (*reason == 'd') {</a>
<a name="ln4979">          // Only give the message once.</a>
<a name="ln4980">          if (prev_b_mtime != -1) {</a>
<a name="ln4981">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln4982">          }</a>
<a name="ln4983">        } else {</a>
<a name="ln4984">          helpmesg = true;</a>
<a name="ln4985">          can_reload = true;</a>
<a name="ln4986"> </a>
<a name="ln4987">          // Check if the file contents really changed to avoid</a>
<a name="ln4988">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln4989">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln4990">          // changed.</a>
<a name="ln4991">          if (reason[2] == 'n') {</a>
<a name="ln4992">            mesg = _(</a>
<a name="ln4993">                &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln4994">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln4995">          } else if (reason[1] == 'h') {</a>
<a name="ln4996">            mesg = _(</a>
<a name="ln4997">                &quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4998">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln4999">          } else if (*reason == 'm') {</a>
<a name="ln5000">            mesg = _(</a>
<a name="ln5001">                &quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln5002">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln5003">          } else</a>
<a name="ln5004">            /* Only timestamp changed, store it to avoid a warning</a>
<a name="ln5005">             * in check_mtime() later. */</a>
<a name="ln5006">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln5007">        }</a>
<a name="ln5008">      }</a>
<a name="ln5009">    }</a>
<a name="ln5010"> </a>
<a name="ln5011">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln5012">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln5013">    retval = 1;</a>
<a name="ln5014">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln5015">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln5016">    can_reload = true;</a>
<a name="ln5017">  }</a>
<a name="ln5018"> </a>
<a name="ln5019">  if (mesg != NULL) {</a>
<a name="ln5020">    path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln5021">    if (!helpmesg) {</a>
<a name="ln5022">      mesg2 = &quot;&quot;;</a>
<a name="ln5023">    }</a>
<a name="ln5024">    const size_t tbuf_len = STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2;</a>
<a name="ln5025">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln5026">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln5027">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln5028">    // mesg2 has been appended.</a>
<a name="ln5029">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln5030">    if (can_reload) {</a>
<a name="ln5031">      if (*mesg2 != NUL) {</a>
<a name="ln5032">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln5033">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln5034">      }</a>
<a name="ln5035">      if (do_dialog(VIM_WARNING, (char_u *) _(&quot;Warning&quot;), (char_u *) tbuf,</a>
<a name="ln5036">                    (char_u *) _(&quot;&amp;OK\n&amp;Load File&quot;), 1, NULL, true) == 2) {</a>
<a name="ln5037">        reload = true;</a>
<a name="ln5038">      }</a>
<a name="ln5039">    } else if (State &gt; NORMAL_BUSY || (State &amp; CMDLINE) || already_warned) {</a>
<a name="ln5040">      if (*mesg2 != NUL) {</a>
<a name="ln5041">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln5042">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln5043">      }</a>
<a name="ln5044">      EMSG(tbuf);</a>
<a name="ln5045">      retval = 2;</a>
<a name="ln5046">    } else {</a>
<a name="ln5047">      if (!autocmd_busy) {</a>
<a name="ln5048">        msg_start();</a>
<a name="ln5049">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln5050">        if (*mesg2 != NUL) {</a>
<a name="ln5051">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln5052">        }</a>
<a name="ln5053">        msg_clr_eos();</a>
<a name="ln5054">        (void)msg_end();</a>
<a name="ln5055">        if (emsg_silent == 0) {</a>
<a name="ln5056">          ui_flush();</a>
<a name="ln5057">          /* give the user some time to think about it */</a>
<a name="ln5058">          os_delay(1000L, true);</a>
<a name="ln5059"> </a>
<a name="ln5060">          /* don't redraw and erase the message */</a>
<a name="ln5061">          redraw_cmdline = FALSE;</a>
<a name="ln5062">        }</a>
<a name="ln5063">      }</a>
<a name="ln5064">      already_warned = TRUE;</a>
<a name="ln5065">    }</a>
<a name="ln5066"> </a>
<a name="ln5067">    xfree(path);</a>
<a name="ln5068">    xfree(tbuf);</a>
<a name="ln5069">  }</a>
<a name="ln5070"> </a>
<a name="ln5071">  if (reload) {</a>
<a name="ln5072">    /* Reload the buffer. */</a>
<a name="ln5073">    buf_reload(buf, orig_mode);</a>
<a name="ln5074">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln5075">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln5076">      buf_T           *save_curbuf = curbuf;</a>
<a name="ln5077"> </a>
<a name="ln5078">      /* Any existing undo file is unusable, write it now. */</a>
<a name="ln5079">      curbuf = buf;</a>
<a name="ln5080">      u_compute_hash(hash);</a>
<a name="ln5081">      u_write_undo(NULL, FALSE, buf, hash);</a>
<a name="ln5082">      curbuf = save_curbuf;</a>
<a name="ln5083">    }</a>
<a name="ln5084">  }</a>
<a name="ln5085"> </a>
<a name="ln5086">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln5087">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln5088">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname,</a>
<a name="ln5089">                         false, buf);</a>
<a name="ln5090">  }</a>
<a name="ln5091">  return retval;</a>
<a name="ln5092">}</a>
<a name="ln5093"> </a>
<a name="ln5094">/*</a>
<a name="ln5095"> * Reload a buffer that is already loaded.</a>
<a name="ln5096"> * Used when the file was changed outside of Vim.</a>
<a name="ln5097"> * &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln5098"> * buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln5099"> */</a>
<a name="ln5100">void buf_reload(buf_T *buf, int orig_mode)</a>
<a name="ln5101">{</a>
<a name="ln5102">  exarg_T ea;</a>
<a name="ln5103">  pos_T old_cursor;</a>
<a name="ln5104">  linenr_T old_topline;</a>
<a name="ln5105">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln5106">  buf_T       *savebuf;</a>
<a name="ln5107">  bufref_T bufref;</a>
<a name="ln5108">  int saved = OK;</a>
<a name="ln5109">  aco_save_T aco;</a>
<a name="ln5110">  int flags = READ_NEW;</a>
<a name="ln5111"> </a>
<a name="ln5112">  /* set curwin/curbuf for &quot;buf&quot; and save some things */</a>
<a name="ln5113">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln5114"> </a>
<a name="ln5115">  // We only want to read the text from the file, not reset the syntax</a>
<a name="ln5116">  // highlighting, clear marks, diff status, etc.  Force the fileformat and</a>
<a name="ln5117">  // encoding to be the same.</a>
<a name="ln5118"> </a>
<a name="ln5119">  prep_exarg(&amp;ea, buf);</a>
<a name="ln5120">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5121">  old_topline = curwin-&gt;w_topline;</a>
<a name="ln5122"> </a>
<a name="ln5123">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln5124">    /* Save all the text, so that the reload can be undone.</a>
<a name="ln5125">     * Sync first so that this is a separate undo-able action. */</a>
<a name="ln5126">    u_sync(FALSE);</a>
<a name="ln5127">    saved = u_savecommon(0, curbuf-&gt;b_ml.ml_line_count + 1, 0, TRUE);</a>
<a name="ln5128">    flags |= READ_KEEP_UNDO;</a>
<a name="ln5129">  }</a>
<a name="ln5130"> </a>
<a name="ln5131">  // To behave like when a new file is edited (matters for</a>
<a name="ln5132">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln5133">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln5134">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln5135">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln5136">  if (BUFEMPTY() || saved == FAIL) {</a>
<a name="ln5137">    savebuf = NULL;</a>
<a name="ln5138">  } else {</a>
<a name="ln5139">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5140">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln5141">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln5142">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln5143">      /* Open the memline. */</a>
<a name="ln5144">      curbuf = savebuf;</a>
<a name="ln5145">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln5146">      saved = ml_open(curbuf);</a>
<a name="ln5147">      curbuf = buf;</a>
<a name="ln5148">      curwin-&gt;w_buffer = buf;</a>
<a name="ln5149">    }</a>
<a name="ln5150">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln5151">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln5152">      EMSG2(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln5153">          buf-&gt;b_fname);</a>
<a name="ln5154">      saved = FAIL;</a>
<a name="ln5155">    }</a>
<a name="ln5156">  }</a>
<a name="ln5157"> </a>
<a name="ln5158">  if (saved == OK) {</a>
<a name="ln5159">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln5160">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln5161">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln5162">                 (linenr_T)MAXLNUM, &amp;ea, flags) != OK) {</a>
<a name="ln5163">      if (!aborting()) {</a>
<a name="ln5164">        EMSG2(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln5165">      }</a>
<a name="ln5166">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln5167">        // Put the text back from the save buffer.  First</a>
<a name="ln5168">        // delete any lines that readfile() added.</a>
<a name="ln5169">        while (!BUFEMPTY()) {</a>
<a name="ln5170">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln5171">            break;</a>
<a name="ln5172">          }</a>
<a name="ln5173">        }</a>
<a name="ln5174">        (void)move_lines(savebuf, buf);</a>
<a name="ln5175">      }</a>
<a name="ln5176">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln5177">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln5178">      unchanged(buf, true, true);</a>
<a name="ln5179">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln5180">        u_blockfree(buf);</a>
<a name="ln5181">        u_clearall(buf);</a>
<a name="ln5182">      } else {</a>
<a name="ln5183">        // Mark all undo states as changed.</a>
<a name="ln5184">        u_unchanged(curbuf);</a>
<a name="ln5185">      }</a>
<a name="ln5186">    }</a>
<a name="ln5187">  }</a>
<a name="ln5188">  xfree(ea.cmd);</a>
<a name="ln5189"> </a>
<a name="ln5190">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln5191">    wipe_buffer(savebuf, false);</a>
<a name="ln5192">  }</a>
<a name="ln5193"> </a>
<a name="ln5194">  /* Invalidate diff info if necessary. */</a>
<a name="ln5195">  diff_invalidate(curbuf);</a>
<a name="ln5196"> </a>
<a name="ln5197">  /* Restore the topline and cursor position and check it (lines may</a>
<a name="ln5198">   * have been removed). */</a>
<a name="ln5199">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5200">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5201">  else</a>
<a name="ln5202">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln5203">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln5204">  check_cursor();</a>
<a name="ln5205">  update_topline();</a>
<a name="ln5206">  keep_filetype = FALSE;</a>
<a name="ln5207"> </a>
<a name="ln5208">  /* Update folds unless they are defined manually. */</a>
<a name="ln5209">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln5210">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln5211">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln5212">      foldUpdateAll(wp);</a>
<a name="ln5213">    }</a>
<a name="ln5214">  }</a>
<a name="ln5215"> </a>
<a name="ln5216">  /* If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln5217">   * value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln5218">   * reset it, might have had a read error. */</a>
<a name="ln5219">  if (orig_mode == curbuf-&gt;b_orig_mode)</a>
<a name="ln5220">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln5221"> </a>
<a name="ln5222">  /* Modelines must override settings done by autocommands. */</a>
<a name="ln5223">  do_modelines(0);</a>
<a name="ln5224"> </a>
<a name="ln5225">  /* restore curwin/curbuf and a few other things */</a>
<a name="ln5226">  aucmd_restbuf(&amp;aco);</a>
<a name="ln5227">  /* Careful: autocommands may have made &quot;buf&quot; invalid! */</a>
<a name="ln5228">}</a>
<a name="ln5229"> </a>
<a name="ln5230">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln5231">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5232">{</a>
<a name="ln5233">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln5234">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln5235">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln5236">}</a>
<a name="ln5237"> </a>
<a name="ln5238">/*</a>
<a name="ln5239"> * Adjust the line with missing eol, used for the next write.</a>
<a name="ln5240"> * Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln5241"> */</a>
<a name="ln5242">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln5243">{</a>
<a name="ln5244">  if (curbuf-&gt;b_no_eol_lnum != 0)       /* only if there is a missing eol */</a>
<a name="ln5245">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln5246">}</a>
<a name="ln5247"> </a>
<a name="ln5248">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln5249">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln5250">/// unless when it looks like a URL.</a>
<a name="ln5251">void forward_slash(char_u *fname)</a>
<a name="ln5252">{</a>
<a name="ln5253">  char_u      *p;</a>
<a name="ln5254"> </a>
<a name="ln5255">  if (path_with_url((const char *)fname)) {</a>
<a name="ln5256">    return;</a>
<a name="ln5257">  }</a>
<a name="ln5258">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln5259">    // The Big5 encoding can have '\' in the trail byte.</a>
<a name="ln5260">    if (*p == '\\') {</a>
<a name="ln5261">      *p = '/';</a>
<a name="ln5262">    }</a>
<a name="ln5263">  }</a>
<a name="ln5264">}</a>
<a name="ln5265">#endif</a>
<a name="ln5266"> </a>
<a name="ln5267">/// Name of Vim's own temp dir. Ends in a slash.</a>
<a name="ln5268">static char_u *vim_tempdir = NULL;</a>
<a name="ln5269"> </a>
<a name="ln5270">/// Create a directory for private use by this instance of Neovim.</a>
<a name="ln5271">/// This is done once, and the same directory is used for all temp files.</a>
<a name="ln5272">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln5273">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln5274">/// file when creating the directory and not for each temp file.</a>
<a name="ln5275">static void vim_maketempdir(void)</a>
<a name="ln5276">{</a>
<a name="ln5277">  static const char *temp_dirs[] = TEMP_DIR_NAMES;</a>
<a name="ln5278">  // Try the entries in `TEMP_DIR_NAMES` to create the temp directory.</a>
<a name="ln5279">  char_u template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5280">  char_u path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5281"> </a>
<a name="ln5282">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln5283">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln5284">  mode_t umask_save = umask(0077);</a>
<a name="ln5285">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln5286">    // Expand environment variables, leave room for &quot;/nvimXXXXXX/999999999&quot;</a>
<a name="ln5287">    expand_env((char_u *)temp_dirs[i], template, TEMP_FILE_PATH_MAXLEN - 22);</a>
<a name="ln5288">    if (!os_isdir(template)) {  // directory doesn't exist</a>
<a name="ln5289">      continue;</a>
<a name="ln5290">    }</a>
<a name="ln5291"> </a>
<a name="ln5292">    add_pathsep((char *)template);</a>
<a name="ln5293">    // Concatenate with temporary directory name pattern</a>
<a name="ln5294">    STRCAT(template, &quot;nvimXXXXXX&quot;);</a>
<a name="ln5295"> </a>
<a name="ln5296">    if (os_mkdtemp((const char *)template, (char *)path) != 0) {</a>
<a name="ln5297">      continue;</a>
<a name="ln5298">    }</a>
<a name="ln5299"> </a>
<a name="ln5300">    if (vim_settempdir((char *)path)) {</a>
<a name="ln5301">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln5302">      break;</a>
<a name="ln5303">    } else {</a>
<a name="ln5304">      // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln5305">      os_rmdir((char *)path);</a>
<a name="ln5306">    }</a>
<a name="ln5307">  }</a>
<a name="ln5308">  (void)umask(umask_save);</a>
<a name="ln5309">}</a>
<a name="ln5310"> </a>
<a name="ln5311">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln5312">/// @param name The path which should be deleted.</a>
<a name="ln5313">/// @return 0 for success, -1 if some file was not deleted.</a>
<a name="ln5314">int delete_recursive(const char *name)</a>
<a name="ln5315">{</a>
<a name="ln5316">  int result = 0;</a>
<a name="ln5317"> </a>
<a name="ln5318">  if (os_isrealdir(name)) {</a>
<a name="ln5319">    snprintf((char *)NameBuff, MAXPATHL, &quot;%s/*&quot;, name);  // NOLINT</a>
<a name="ln5320"> </a>
<a name="ln5321">    char_u **files;</a>
<a name="ln5322">    int file_count;</a>
<a name="ln5323">    char_u *exp = vim_strsave(NameBuff);</a>
<a name="ln5324">    if (gen_expand_wildcards(1, &amp;exp, &amp;file_count, &amp;files,</a>
<a name="ln5325">                             EW_DIR | EW_FILE | EW_SILENT | EW_ALLLINKS</a>
<a name="ln5326">                             | EW_DODOT | EW_EMPTYOK) == OK) {</a>
<a name="ln5327">      for (int i = 0; i &lt; file_count; i++) {</a>
<a name="ln5328">        if (delete_recursive((const char *)files[i]) != 0) {</a>
<a name="ln5329">          result = -1;</a>
<a name="ln5330">        }</a>
<a name="ln5331">      }</a>
<a name="ln5332">      FreeWild(file_count, files);</a>
<a name="ln5333">    } else {</a>
<a name="ln5334">      result = -1;</a>
<a name="ln5335">    }</a>
<a name="ln5336"> </a>
<a name="ln5337">    xfree(exp);</a>
<a name="ln5338">    os_rmdir(name);</a>
<a name="ln5339">  } else {</a>
<a name="ln5340">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln5341">  }</a>
<a name="ln5342"> </a>
<a name="ln5343">  return result;</a>
<a name="ln5344">}</a>
<a name="ln5345"> </a>
<a name="ln5346">/// Delete the temp directory and all files it contains.</a>
<a name="ln5347">void vim_deltempdir(void)</a>
<a name="ln5348">{</a>
<a name="ln5349">  if (vim_tempdir != NULL) {</a>
<a name="ln5350">    // remove the trailing path separator</a>
<a name="ln5351">    path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln5352">    delete_recursive((const char *)vim_tempdir);</a>
<a name="ln5353">    XFREE_CLEAR(vim_tempdir);</a>
<a name="ln5354">  }</a>
<a name="ln5355">}</a>
<a name="ln5356"> </a>
<a name="ln5357">/// Get the name of temp directory. This directory would be created on the first</a>
<a name="ln5358">/// call to this function.</a>
<a name="ln5359">char_u *vim_gettempdir(void)</a>
<a name="ln5360">{</a>
<a name="ln5361">  if (vim_tempdir == NULL) {</a>
<a name="ln5362">    vim_maketempdir();</a>
<a name="ln5363">  }</a>
<a name="ln5364"> </a>
<a name="ln5365">  return vim_tempdir;</a>
<a name="ln5366">}</a>
<a name="ln5367"> </a>
<a name="ln5368">/// Set Neovim own temporary directory name to `tempdir`. This directory should</a>
<a name="ln5369">/// be already created. Expand this name to a full path and put it in</a>
<a name="ln5370">/// `vim_tempdir`. This avoids that using `:cd` would confuse us.</a>
<a name="ln5371">///</a>
<a name="ln5372">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln5373">///</a>
<a name="ln5374">/// @return false if we run out of memory.</a>
<a name="ln5375">static bool vim_settempdir(char *tempdir)</a>
<a name="ln5376">{</a>
<a name="ln5377">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln5378">  if (!buf) {</a>
<a name="ln5379">    return false;</a>
<a name="ln5380">  }</a>
<a name="ln5381">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln5382">  add_pathsep(buf);</a>
<a name="ln5383">  vim_tempdir = (char_u *)xstrdup(buf);</a>
<a name="ln5384">  xfree(buf);</a>
<a name="ln5385">  return true;</a>
<a name="ln5386">}</a>
<a name="ln5387"> </a>
<a name="ln5388">/// Return a unique name that can be used for a temp file.</a>
<a name="ln5389">///</a>
<a name="ln5390">/// @note The temp file is NOT created.</a>
<a name="ln5391">///</a>
<a name="ln5392">/// @return pointer to the temp file name or NULL if Neovim can't create</a>
<a name="ln5393">///         temporary directory for its own temporary files.</a>
<a name="ln5394">char_u *vim_tempname(void)</a>
<a name="ln5395">{</a>
<a name="ln5396">  // Temp filename counter.</a>
<a name="ln5397">  static uint64_t temp_count;</a>
<a name="ln5398"> </a>
<a name="ln5399">  char_u *tempdir = vim_gettempdir();</a>
<a name="ln5400">  if (!tempdir) {</a>
<a name="ln5401">    return NULL;</a>
<a name="ln5402">  }</a>
<a name="ln5403"> </a>
<a name="ln5404">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln5405">  // and nobody else creates a file in it.</a>
<a name="ln5406">  char_u template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5407">  snprintf((char *)template, TEMP_FILE_PATH_MAXLEN,</a>
<a name="ln5408">           &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln5409">  return vim_strsave(template);</a>
<a name="ln5410">}</a>
<a name="ln5411"> </a>
<a name="ln5412"> </a>
<a name="ln5413">/*</a>
<a name="ln5414"> * Code for automatic commands.</a>
<a name="ln5415"> */</a>
<a name="ln5416">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln5417"># include &quot;auevents_name_map.generated.h&quot;</a>
<a name="ln5418">#endif</a>
<a name="ln5419"> </a>
<a name="ln5420">static AutoPatCmd *active_apc_list = NULL; /* stack of active autocommands */</a>
<a name="ln5421"> </a>
<a name="ln5422">/// List of autocmd group names</a>
<a name="ln5423">static garray_T augroups = { 0, 0, sizeof(char_u *), 10, NULL };</a>
<a name="ln5424">#define AUGROUP_NAME(i) (((char **)augroups.ga_data)[i])</a>
<a name="ln5425"> </a>
<a name="ln5426">/*</a>
<a name="ln5427"> * The ID of the current group.  Group 0 is the default one.</a>
<a name="ln5428"> */</a>
<a name="ln5429">static int current_augroup = AUGROUP_DEFAULT;</a>
<a name="ln5430"> </a>
<a name="ln5431">static int au_need_clean = FALSE;   /* need to delete marked patterns */</a>
<a name="ln5432"> </a>
<a name="ln5433"> </a>
<a name="ln5434"> </a>
<a name="ln5435">static event_T last_event;</a>
<a name="ln5436">static int last_group;</a>
<a name="ln5437">static int autocmd_blocked = 0;         /* block all autocmds */</a>
<a name="ln5438"> </a>
<a name="ln5439">// use get_deleted_augroup() to get this</a>
<a name="ln5440">static const char *deleted_augroup = NULL;</a>
<a name="ln5441"> </a>
<a name="ln5442">static inline const char *get_deleted_augroup(void)</a>
<a name="ln5443">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln5444">{</a>
<a name="ln5445">    if (deleted_augroup == NULL) {</a>
<a name="ln5446">      deleted_augroup = _(&quot;--Deleted--&quot;);</a>
<a name="ln5447">    }</a>
<a name="ln5448">    return deleted_augroup;</a>
<a name="ln5449">}</a>
<a name="ln5450"> </a>
<a name="ln5451">/*</a>
<a name="ln5452"> * Show the autocommands for one AutoPat.</a>
<a name="ln5453"> */</a>
<a name="ln5454">static void show_autocmd(AutoPat *ap, event_T event)</a>
<a name="ln5455">{</a>
<a name="ln5456">  AutoCmd *ac;</a>
<a name="ln5457"> </a>
<a name="ln5458">  /* Check for &quot;got_int&quot; (here and at various places below), which is set</a>
<a name="ln5459">   * when &quot;q&quot; has been hit for the &quot;--more--&quot; prompt */</a>
<a name="ln5460">  if (got_int)</a>
<a name="ln5461">    return;</a>
<a name="ln5462">  if (ap-&gt;pat == NULL)                  /* pattern has been removed */</a>
<a name="ln5463">    return;</a>
<a name="ln5464"> </a>
<a name="ln5465">  msg_putchar('\n');</a>
<a name="ln5466">  if (got_int)</a>
<a name="ln5467">    return;</a>
<a name="ln5468">  if (event != last_event || ap-&gt;group != last_group) {</a>
<a name="ln5469">    if (ap-&gt;group != AUGROUP_DEFAULT) {</a>
<a name="ln5470">      if (AUGROUP_NAME(ap-&gt;group) == NULL) {</a>
<a name="ln5471">        msg_puts_attr(get_deleted_augroup(), HL_ATTR(HLF_E));</a>
<a name="ln5472">      } else {</a>
<a name="ln5473">        msg_puts_attr(AUGROUP_NAME(ap-&gt;group), HL_ATTR(HLF_T));</a>
<a name="ln5474">      }</a>
<a name="ln5475">      msg_puts(&quot;  &quot;);</a>
<a name="ln5476">    }</a>
<a name="ln5477">    msg_puts_attr(event_nr2name(event), HL_ATTR(HLF_T));</a>
<a name="ln5478">    last_event = event;</a>
<a name="ln5479">    last_group = ap-&gt;group;</a>
<a name="ln5480">    msg_putchar('\n');</a>
<a name="ln5481">    if (got_int)</a>
<a name="ln5482">      return;</a>
<a name="ln5483">  }</a>
<a name="ln5484">  msg_col = 4;</a>
<a name="ln5485">  msg_outtrans(ap-&gt;pat);</a>
<a name="ln5486"> </a>
<a name="ln5487">  for (ac = ap-&gt;cmds; ac != NULL; ac = ac-&gt;next) {</a>
<a name="ln5488">    if (ac-&gt;cmd == NULL) {              /* skip removed commands */</a>
<a name="ln5489">      continue;</a>
<a name="ln5490">    }</a>
<a name="ln5491">    if (msg_col &gt;= 14) {</a>
<a name="ln5492">      msg_putchar('\n');</a>
<a name="ln5493">    }</a>
<a name="ln5494">    msg_col = 14;</a>
<a name="ln5495">    if (got_int) {</a>
<a name="ln5496">      return;</a>
<a name="ln5497">    }</a>
<a name="ln5498">    msg_outtrans(ac-&gt;cmd);</a>
<a name="ln5499">    if (p_verbose &gt; 0) {</a>
<a name="ln5500">      last_set_msg(ac-&gt;script_ctx);</a>
<a name="ln5501">    }</a>
<a name="ln5502">    if (got_int) {</a>
<a name="ln5503">      return;</a>
<a name="ln5504">    }</a>
<a name="ln5505">    if (ac-&gt;next != NULL) {</a>
<a name="ln5506">      msg_putchar('\n');</a>
<a name="ln5507">      if (got_int) {</a>
<a name="ln5508">        return;</a>
<a name="ln5509">      }</a>
<a name="ln5510">    }</a>
<a name="ln5511">  }</a>
<a name="ln5512">}</a>
<a name="ln5513"> </a>
<a name="ln5514">// Mark an autocommand handler for deletion.</a>
<a name="ln5515">static void au_remove_pat(AutoPat *ap)</a>
<a name="ln5516">{</a>
<a name="ln5517">  XFREE_CLEAR(ap-&gt;pat);</a>
<a name="ln5518">  ap-&gt;buflocal_nr = -1;</a>
<a name="ln5519">  au_need_clean = true;</a>
<a name="ln5520">}</a>
<a name="ln5521"> </a>
<a name="ln5522">// Mark all commands for a pattern for deletion.</a>
<a name="ln5523">static void au_remove_cmds(AutoPat *ap)</a>
<a name="ln5524">{</a>
<a name="ln5525">  for (AutoCmd *ac = ap-&gt;cmds; ac != NULL; ac = ac-&gt;next) {</a>
<a name="ln5526">    XFREE_CLEAR(ac-&gt;cmd);</a>
<a name="ln5527">  }</a>
<a name="ln5528">  au_need_clean = true;</a>
<a name="ln5529">}</a>
<a name="ln5530"> </a>
<a name="ln5531">// Delete one command from an autocmd pattern.</a>
<a name="ln5532">static void au_del_cmd(AutoCmd *ac)</a>
<a name="ln5533">{</a>
<a name="ln5534">  XFREE_CLEAR(ac-&gt;cmd);</a>
<a name="ln5535">  au_need_clean = true;</a>
<a name="ln5536">}</a>
<a name="ln5537"> </a>
<a name="ln5538">/// Cleanup autocommands and patterns that have been deleted.</a>
<a name="ln5539">/// This is only done when not executing autocommands.</a>
<a name="ln5540">static void au_cleanup(void)</a>
<a name="ln5541">{</a>
<a name="ln5542">  AutoPat     *ap, **prev_ap;</a>
<a name="ln5543">  event_T event;</a>
<a name="ln5544"> </a>
<a name="ln5545">  if (autocmd_busy || !au_need_clean) {</a>
<a name="ln5546">    return;</a>
<a name="ln5547">  }</a>
<a name="ln5548"> </a>
<a name="ln5549">  // Loop over all events.</a>
<a name="ln5550">  for (event = (event_T)0; (int)event &lt; (int)NUM_EVENTS;</a>
<a name="ln5551">       event = (event_T)((int)event + 1)) {</a>
<a name="ln5552">    // Loop over all autocommand patterns.</a>
<a name="ln5553">    prev_ap = &amp;(first_autopat[(int)event]);</a>
<a name="ln5554">    for (ap = *prev_ap; ap != NULL; ap = *prev_ap) {</a>
<a name="ln5555">      bool has_cmd = false;</a>
<a name="ln5556"> </a>
<a name="ln5557">      // Loop over all commands for this pattern.</a>
<a name="ln5558">      AutoCmd **prev_ac = &amp;(ap-&gt;cmds);</a>
<a name="ln5559">      for (AutoCmd *ac = *prev_ac; ac != NULL; ac = *prev_ac) {</a>
<a name="ln5560">        // Remove the command if the pattern is to be deleted or when</a>
<a name="ln5561">        // the command has been marked for deletion.</a>
<a name="ln5562">        if (ap-&gt;pat == NULL || ac-&gt;cmd == NULL) {</a>
<a name="ln5563">          *prev_ac = ac-&gt;next;</a>
<a name="ln5564">          xfree(ac-&gt;cmd);</a>
<a name="ln5565">          xfree(ac);</a>
<a name="ln5566">        } else {</a>
<a name="ln5567">          has_cmd = true;</a>
<a name="ln5568">          prev_ac = &amp;(ac-&gt;next);</a>
<a name="ln5569">        }</a>
<a name="ln5570">      }</a>
<a name="ln5571"> </a>
<a name="ln5572">      if (ap-&gt;pat != NULL &amp;&amp; !has_cmd) {</a>
<a name="ln5573">        // Pattern was not marked for deletion, but all of its commands were.</a>
<a name="ln5574">        // So mark the pattern for deletion.</a>
<a name="ln5575">        au_remove_pat(ap);</a>
<a name="ln5576">      }</a>
<a name="ln5577"> </a>
<a name="ln5578">      // Remove the pattern if it has been marked for deletion.</a>
<a name="ln5579">      if (ap-&gt;pat == NULL) {</a>
<a name="ln5580">        if (ap-&gt;next == NULL) {</a>
<a name="ln5581">          if (prev_ap == &amp;(first_autopat[(int)event])) {</a>
<a name="ln5582">            last_autopat[(int)event] = NULL;</a>
<a name="ln5583">          } else {</a>
<a name="ln5584">            // this depends on the &quot;next&quot; field being the first in</a>
<a name="ln5585">            // the struct</a>
<a name="ln5586">            last_autopat[(int)event] = (AutoPat *)prev_ap;</a>
<a name="ln5587">          }</a>
<a name="ln5588">        }</a>
<a name="ln5589">        *prev_ap = ap-&gt;next;</a>
<a name="ln5590">        vim_regfree(ap-&gt;reg_prog);</a>
<a name="ln5591">        xfree(ap);</a>
<a name="ln5592">      } else {</a>
<a name="ln5593">        prev_ap = &amp;(ap-&gt;next);</a>
<a name="ln5594">      }</a>
<a name="ln5595">    }</a>
<a name="ln5596">  }</a>
<a name="ln5597"> </a>
<a name="ln5598">  au_need_clean = false;</a>
<a name="ln5599">}</a>
<a name="ln5600"> </a>
<a name="ln5601">/*</a>
<a name="ln5602"> * Called when buffer is freed, to remove/invalidate related buffer-local</a>
<a name="ln5603"> * autocmds.</a>
<a name="ln5604"> */</a>
<a name="ln5605">void aubuflocal_remove(buf_T *buf)</a>
<a name="ln5606">{</a>
<a name="ln5607">  AutoPat     *ap;</a>
<a name="ln5608">  event_T event;</a>
<a name="ln5609">  AutoPatCmd  *apc;</a>
<a name="ln5610"> </a>
<a name="ln5611">  /* invalidate currently executing autocommands */</a>
<a name="ln5612">  for (apc = active_apc_list; apc; apc = apc-&gt;next)</a>
<a name="ln5613">    if (buf-&gt;b_fnum == apc-&gt;arg_bufnr)</a>
<a name="ln5614">      apc-&gt;arg_bufnr = 0;</a>
<a name="ln5615"> </a>
<a name="ln5616">  /* invalidate buflocals looping through events */</a>
<a name="ln5617">  for (event = (event_T)0; (int)event &lt; (int)NUM_EVENTS;</a>
<a name="ln5618">       event = (event_T)((int)event + 1))</a>
<a name="ln5619">    /* loop over all autocommand patterns */</a>
<a name="ln5620">    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap-&gt;next)</a>
<a name="ln5621">      if (ap-&gt;buflocal_nr == buf-&gt;b_fnum) {</a>
<a name="ln5622">        au_remove_pat(ap);</a>
<a name="ln5623">        if (p_verbose &gt;= 6) {</a>
<a name="ln5624">          verbose_enter();</a>
<a name="ln5625">          smsg(_(&quot;auto-removing autocommand: %s &lt;buffer=%d&gt;&quot;),</a>
<a name="ln5626">               event_nr2name(event), buf-&gt;b_fnum);</a>
<a name="ln5627">          verbose_leave();</a>
<a name="ln5628">        }</a>
<a name="ln5629">      }</a>
<a name="ln5630">  au_cleanup();</a>
<a name="ln5631">}</a>
<a name="ln5632"> </a>
<a name="ln5633">// Add an autocmd group name.</a>
<a name="ln5634">// Return its ID.  Returns AUGROUP_ERROR (&lt; 0) for error.</a>
<a name="ln5635">static int au_new_group(char_u *name)</a>
<a name="ln5636">{</a>
<a name="ln5637">  int i = au_find_group(name);</a>
<a name="ln5638">  if (i == AUGROUP_ERROR) {     // the group doesn't exist yet, add it.</a>
<a name="ln5639">    // First try using a free entry.</a>
<a name="ln5640">    for (i = 0; i &lt; augroups.ga_len; i++) {</a>
<a name="ln5641">      if (AUGROUP_NAME(i) == NULL) {</a>
<a name="ln5642">        break;</a>
<a name="ln5643">      }</a>
<a name="ln5644">    }</a>
<a name="ln5645">    if (i == augroups.ga_len) {</a>
<a name="ln5646">      ga_grow(&amp;augroups, 1);</a>
<a name="ln5647">    }</a>
<a name="ln5648"> </a>
<a name="ln5649">    AUGROUP_NAME(i) = xstrdup((char *)name);</a>
<a name="ln5650">    if (i == augroups.ga_len) {</a>
<a name="ln5651">      augroups.ga_len++;</a>
<a name="ln5652">    }</a>
<a name="ln5653">  }</a>
<a name="ln5654"> </a>
<a name="ln5655">  return i;</a>
<a name="ln5656">}</a>
<a name="ln5657"> </a>
<a name="ln5658">static void au_del_group(char_u *name)</a>
<a name="ln5659">{</a>
<a name="ln5660">  int i = au_find_group(name);</a>
<a name="ln5661">  if (i == AUGROUP_ERROR) {      // the group doesn't exist</a>
<a name="ln5662">    EMSG2(_(&quot;E367: No such group: \&quot;%s\&quot;&quot;), name);</a>
<a name="ln5663">  } else if (i == current_augroup) {</a>
<a name="ln5664">    EMSG(_(&quot;E936: Cannot delete the current group&quot;));</a>
<a name="ln5665">  } else {</a>
<a name="ln5666">    event_T event;</a>
<a name="ln5667">    AutoPat *ap;</a>
<a name="ln5668">    int in_use = false;</a>
<a name="ln5669"> </a>
<a name="ln5670">    for (event = (event_T)0; (int)event &lt; (int)NUM_EVENTS;</a>
<a name="ln5671">         event = (event_T)((int)event + 1)) {</a>
<a name="ln5672">      for (ap = first_autopat[(int)event]; ap != NULL; ap = ap-&gt;next) {</a>
<a name="ln5673">        if (ap-&gt;group == i &amp;&amp; ap-&gt;pat != NULL) {</a>
<a name="ln5674">          give_warning((char_u *)</a>
<a name="ln5675">                       _(&quot;W19: Deleting augroup that is still in use&quot;), true);</a>
<a name="ln5676">          in_use = true;</a>
<a name="ln5677">          event = NUM_EVENTS;</a>
<a name="ln5678">          break;</a>
<a name="ln5679">        }</a>
<a name="ln5680">      }</a>
<a name="ln5681">    }</a>
<a name="ln5682">    xfree(AUGROUP_NAME(i));</a>
<a name="ln5683">    if (in_use) {</a>
<a name="ln5684">      AUGROUP_NAME(i) = (char *)get_deleted_augroup();</a>
<a name="ln5685">    } else {</a>
<a name="ln5686">      AUGROUP_NAME(i) = NULL;</a>
<a name="ln5687">    }</a>
<a name="ln5688">  }</a>
<a name="ln5689">}</a>
<a name="ln5690"> </a>
<a name="ln5691">/// Find the ID of an autocmd group name.</a>
<a name="ln5692">///</a>
<a name="ln5693">/// @param name augroup name</a>
<a name="ln5694">///</a>
<a name="ln5695">/// @return the ID or AUGROUP_ERROR (&lt; 0) for error.</a>
<a name="ln5696">static int au_find_group(const char_u *name)</a>
<a name="ln5697">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5698">{</a>
<a name="ln5699">  for (int i = 0; i &lt; augroups.ga_len; i++) {</a>
<a name="ln5700">    if (AUGROUP_NAME(i) != NULL &amp;&amp; AUGROUP_NAME(i) != get_deleted_augroup()</a>
<a name="ln5701">        &amp;&amp; STRCMP(AUGROUP_NAME(i), name) == 0) {</a>
<a name="ln5702">      return i;</a>
<a name="ln5703">    }</a>
<a name="ln5704">  }</a>
<a name="ln5705">  return AUGROUP_ERROR;</a>
<a name="ln5706">}</a>
<a name="ln5707"> </a>
<a name="ln5708">/// Return true if augroup &quot;name&quot; exists.</a>
<a name="ln5709">///</a>
<a name="ln5710">/// @param name augroup name</a>
<a name="ln5711">bool au_has_group(const char_u *name)</a>
<a name="ln5712">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5713">{</a>
<a name="ln5714">  return au_find_group(name) != AUGROUP_ERROR;</a>
<a name="ln5715">}</a>
<a name="ln5716"> </a>
<a name="ln5717">/// &quot;:augroup {name}&quot;.</a>
<a name="ln5718">void do_augroup(char_u *arg, int del_group)</a>
<a name="ln5719">{</a>
<a name="ln5720">  if (del_group) {</a>
<a name="ln5721">    if (*arg == NUL) {</a>
<a name="ln5722">      EMSG(_(e_argreq));</a>
<a name="ln5723">    } else {</a>
<a name="ln5724">      au_del_group(arg);</a>
<a name="ln5725">    }</a>
<a name="ln5726">  } else if (STRICMP(arg, &quot;end&quot;) == 0) {  // &quot;:aug end&quot;: back to group 0</a>
<a name="ln5727">    current_augroup = AUGROUP_DEFAULT;</a>
<a name="ln5728">  } else if (*arg) {  // &quot;:aug xxx&quot;: switch to group xxx</a>
<a name="ln5729">    int i = au_new_group(arg);</a>
<a name="ln5730">    if (i != AUGROUP_ERROR)</a>
<a name="ln5731">      current_augroup = i;</a>
<a name="ln5732">  } else {  // &quot;:aug&quot;: list the group names</a>
<a name="ln5733">    msg_start();</a>
<a name="ln5734">    for (int i = 0; i &lt; augroups.ga_len; ++i) {</a>
<a name="ln5735">      if (AUGROUP_NAME(i) != NULL) {</a>
<a name="ln5736">        msg_puts(AUGROUP_NAME(i));</a>
<a name="ln5737">        msg_puts(&quot;  &quot;);</a>
<a name="ln5738">      }</a>
<a name="ln5739">    }</a>
<a name="ln5740">    msg_clr_eos();</a>
<a name="ln5741">    msg_end();</a>
<a name="ln5742">  }</a>
<a name="ln5743">}</a>
<a name="ln5744"> </a>
<a name="ln5745">#if defined(EXITFREE)</a>
<a name="ln5746">void free_all_autocmds(void)</a>
<a name="ln5747">{</a>
<a name="ln5748">  for (current_augroup = -1; current_augroup &lt; augroups.ga_len;</a>
<a name="ln5749">       current_augroup++) {</a>
<a name="ln5750">    do_autocmd((char_u *)&quot;&quot;, true);</a>
<a name="ln5751">  }</a>
<a name="ln5752"> </a>
<a name="ln5753">  for (int i = 0; i &lt; augroups.ga_len; i++) {</a>
<a name="ln5754">    char *const s = ((char **)(augroups.ga_data))[i];</a>
<a name="ln5755">    if ((const char *)s != get_deleted_augroup()) {</a>
<a name="ln5756">      xfree(s);</a>
<a name="ln5757">    }</a>
<a name="ln5758">  }</a>
<a name="ln5759">  ga_clear(&amp;augroups);</a>
<a name="ln5760">}</a>
<a name="ln5761">#endif</a>
<a name="ln5762"> </a>
<a name="ln5763">/*</a>
<a name="ln5764"> * Return the event number for event name &quot;start&quot;.</a>
<a name="ln5765"> * Return NUM_EVENTS if the event name was not found.</a>
<a name="ln5766"> * Return a pointer to the next event name in &quot;end&quot;.</a>
<a name="ln5767"> */</a>
<a name="ln5768">static event_T event_name2nr(const char_u *start, char_u **end)</a>
<a name="ln5769">{</a>
<a name="ln5770">  const char_u *p;</a>
<a name="ln5771">  int i;</a>
<a name="ln5772">  int len;</a>
<a name="ln5773"> </a>
<a name="ln5774">  // the event name ends with end of line, '|', a blank or a comma</a>
<a name="ln5775">  for (p = start; *p &amp;&amp; !ascii_iswhite(*p) &amp;&amp; *p != ',' &amp;&amp; *p != '|'; p++) {</a>
<a name="ln5776">  }</a>
<a name="ln5777">  for (i = 0; event_names[i].name != NULL; i++) {</a>
<a name="ln5778">    len = (int)event_names[i].len;</a>
<a name="ln5779">    if (len == p - start &amp;&amp; STRNICMP(event_names[i].name, start, len) == 0) {</a>
<a name="ln5780">      break;</a>
<a name="ln5781">    }</a>
<a name="ln5782">  }</a>
<a name="ln5783">  if (*p == ',') {</a>
<a name="ln5784">    p++;</a>
<a name="ln5785">  }</a>
<a name="ln5786">  *end = (char_u *)p;</a>
<a name="ln5787">  if (event_names[i].name == NULL) {</a>
<a name="ln5788">    return NUM_EVENTS;</a>
<a name="ln5789">  }</a>
<a name="ln5790">  return event_names[i].event;</a>
<a name="ln5791">}</a>
<a name="ln5792"> </a>
<a name="ln5793">/// Return the name for event</a>
<a name="ln5794">///</a>
<a name="ln5795">/// @param[in]  event  Event to return name for.</a>
<a name="ln5796">///</a>
<a name="ln5797">/// @return Event name, static string. Returns &quot;Unknown&quot; for unknown events.</a>
<a name="ln5798">static const char *event_nr2name(event_T event)</a>
<a name="ln5799">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_CONST</a>
<a name="ln5800">{</a>
<a name="ln5801">  int i;</a>
<a name="ln5802"> </a>
<a name="ln5803">  for (i = 0; event_names[i].name != NULL; i++) {</a>
<a name="ln5804">    if (event_names[i].event == event) {</a>
<a name="ln5805">      return event_names[i].name;</a>
<a name="ln5806">    }</a>
<a name="ln5807">  }</a>
<a name="ln5808">  return &quot;Unknown&quot;;</a>
<a name="ln5809">}</a>
<a name="ln5810"> </a>
<a name="ln5811">/*</a>
<a name="ln5812"> * Scan over the events.  &quot;*&quot; stands for all events.</a>
<a name="ln5813"> */</a>
<a name="ln5814">static char_u *</a>
<a name="ln5815">find_end_event (</a>
<a name="ln5816">    char_u *arg,</a>
<a name="ln5817">    int have_group             /* TRUE when group name was found */</a>
<a name="ln5818">)</a>
<a name="ln5819">{</a>
<a name="ln5820">  char_u  *pat;</a>
<a name="ln5821">  char_u  *p;</a>
<a name="ln5822"> </a>
<a name="ln5823">  if (*arg == '*') {</a>
<a name="ln5824">    if (arg[1] &amp;&amp; !ascii_iswhite(arg[1])) {</a>
<a name="ln5825">      EMSG2(_(&quot;E215: Illegal character after *: %s&quot;), arg);</a>
<a name="ln5826">      return NULL;</a>
<a name="ln5827">    }</a>
<a name="ln5828">    pat = arg + 1;</a>
<a name="ln5829">  } else {</a>
<a name="ln5830">    for (pat = arg; *pat &amp;&amp; *pat != '|' &amp;&amp; !ascii_iswhite(*pat); pat = p) {</a>
<a name="ln5831">      if ((int)event_name2nr(pat, &amp;p) &gt;= (int)NUM_EVENTS) {</a>
<a name="ln5832">        if (have_group)</a>
<a name="ln5833">          EMSG2(_(&quot;E216: No such event: %s&quot;), pat);</a>
<a name="ln5834">        else</a>
<a name="ln5835">          EMSG2(_(&quot;E216: No such group or event: %s&quot;), pat);</a>
<a name="ln5836">        return NULL;</a>
<a name="ln5837">      }</a>
<a name="ln5838">    }</a>
<a name="ln5839">  }</a>
<a name="ln5840">  return pat;</a>
<a name="ln5841">}</a>
<a name="ln5842"> </a>
<a name="ln5843">/// Return true if &quot;event&quot; is included in 'eventignore'.</a>
<a name="ln5844">///</a>
<a name="ln5845">/// @param event event to check</a>
<a name="ln5846">static bool event_ignored(event_T event)</a>
<a name="ln5847">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5848">{</a>
<a name="ln5849">  char_u *p = p_ei;</a>
<a name="ln5850"> </a>
<a name="ln5851">  while (*p != NUL) {</a>
<a name="ln5852">    if (STRNICMP(p, &quot;all&quot;, 3) == 0 &amp;&amp; (p[3] == NUL || p[3] == ',')) {</a>
<a name="ln5853">      return true;</a>
<a name="ln5854">    }</a>
<a name="ln5855">    if (event_name2nr(p, &amp;p) == event) {</a>
<a name="ln5856">      return true;</a>
<a name="ln5857">    }</a>
<a name="ln5858">  }</a>
<a name="ln5859"> </a>
<a name="ln5860">  return false;</a>
<a name="ln5861">}</a>
<a name="ln5862"> </a>
<a name="ln5863">/*</a>
<a name="ln5864"> * Return OK when the contents of p_ei is valid, FAIL otherwise.</a>
<a name="ln5865"> */</a>
<a name="ln5866">int check_ei(void)</a>
<a name="ln5867">{</a>
<a name="ln5868">  char_u      *p = p_ei;</a>
<a name="ln5869"> </a>
<a name="ln5870">  while (*p) {</a>
<a name="ln5871">    if (STRNICMP(p, &quot;all&quot;, 3) == 0 &amp;&amp; (p[3] == NUL || p[3] == ',')) {</a>
<a name="ln5872">      p += 3;</a>
<a name="ln5873">      if (*p == ',')</a>
<a name="ln5874">        ++p;</a>
<a name="ln5875">    } else if (event_name2nr(p, &amp;p) == NUM_EVENTS)</a>
<a name="ln5876">      return FAIL;</a>
<a name="ln5877">  }</a>
<a name="ln5878"> </a>
<a name="ln5879">  return OK;</a>
<a name="ln5880">}</a>
<a name="ln5881"> </a>
<a name="ln5882">/*</a>
<a name="ln5883"> * Add &quot;what&quot; to 'eventignore' to skip loading syntax highlighting for every</a>
<a name="ln5884"> * buffer loaded into the window.  &quot;what&quot; must start with a comma.</a>
<a name="ln5885"> * Returns the old value of 'eventignore' in allocated memory.</a>
<a name="ln5886"> */</a>
<a name="ln5887">char_u *au_event_disable(char *what)</a>
<a name="ln5888">{</a>
<a name="ln5889">  char_u      *new_ei;</a>
<a name="ln5890">  char_u      *save_ei;</a>
<a name="ln5891"> </a>
<a name="ln5892">  save_ei = vim_strsave(p_ei);</a>
<a name="ln5893">  new_ei = vim_strnsave(p_ei, (int)(STRLEN(p_ei) + STRLEN(what)));</a>
<a name="ln5894">  if (*what == ',' &amp;&amp; *p_ei == NUL)</a>
<a name="ln5895">    STRCPY(new_ei, what + 1);</a>
<a name="ln5896">  else</a>
<a name="ln5897">    STRCAT(new_ei, what);</a>
<a name="ln5898">  set_string_option_direct((char_u *)&quot;ei&quot;, -1, new_ei, OPT_FREE, SID_NONE);</a>
<a name="ln5899">  xfree(new_ei);</a>
<a name="ln5900"> </a>
<a name="ln5901">  return save_ei;</a>
<a name="ln5902">}</a>
<a name="ln5903"> </a>
<a name="ln5904">void au_event_restore(char_u *old_ei)</a>
<a name="ln5905">{</a>
<a name="ln5906">  if (old_ei != NULL) {</a>
<a name="ln5907">    set_string_option_direct((char_u *)&quot;ei&quot;, -1, old_ei,</a>
<a name="ln5908">        OPT_FREE, SID_NONE);</a>
<a name="ln5909">    xfree(old_ei);</a>
<a name="ln5910">  }</a>
<a name="ln5911">}</a>
<a name="ln5912"> </a>
<a name="ln5913">// Implements :autocmd.</a>
<a name="ln5914">// Defines an autocmd (does not execute; cf. apply_autocmds_group).</a>
<a name="ln5915">//</a>
<a name="ln5916">// Can be used in the following ways:</a>
<a name="ln5917">//</a>
<a name="ln5918">// :autocmd &lt;event&gt; &lt;pat&gt; &lt;cmd&gt;     Add &lt;cmd&gt; to the list of commands that</a>
<a name="ln5919">//                                  will be automatically executed for &lt;event&gt;</a>
<a name="ln5920">//                                  when editing a file matching &lt;pat&gt;, in</a>
<a name="ln5921">//                                  the current group.</a>
<a name="ln5922">// :autocmd &lt;event&gt; &lt;pat&gt;           Show the autocommands associated with</a>
<a name="ln5923">//                                  &lt;event&gt; and &lt;pat&gt;.</a>
<a name="ln5924">// :autocmd &lt;event&gt;                 Show the autocommands associated with</a>
<a name="ln5925">//                                  &lt;event&gt;.</a>
<a name="ln5926">// :autocmd                         Show all autocommands.</a>
<a name="ln5927">// :autocmd! &lt;event&gt; &lt;pat&gt; &lt;cmd&gt;    Remove all autocommands associated with</a>
<a name="ln5928">//                                  &lt;event&gt; and &lt;pat&gt;, and add the command</a>
<a name="ln5929">//                                  &lt;cmd&gt;, for the current group.</a>
<a name="ln5930">// :autocmd! &lt;event&gt; &lt;pat&gt;          Remove all autocommands associated with</a>
<a name="ln5931">//                                  &lt;event&gt; and &lt;pat&gt; for the current group.</a>
<a name="ln5932">// :autocmd! &lt;event&gt;                Remove all autocommands associated with</a>
<a name="ln5933">//                                  &lt;event&gt; for the current group.</a>
<a name="ln5934">// :autocmd!                        Remove ALL autocommands for the current</a>
<a name="ln5935">//                                  group.</a>
<a name="ln5936">//</a>
<a name="ln5937">//  Multiple events and patterns may be given separated by commas.  Here are</a>
<a name="ln5938">//  some examples:</a>
<a name="ln5939">// :autocmd bufread,bufenter *.c,*.h    set tw=0 smartindent noic</a>
<a name="ln5940">// :autocmd bufleave         *          set tw=79 nosmartindent ic infercase</a>
<a name="ln5941">//</a>
<a name="ln5942">// :autocmd * *.c               show all autocommands for *.c files.</a>
<a name="ln5943">//</a>
<a name="ln5944">// Mostly a {group} argument can optionally appear before &lt;event&gt;.</a>
<a name="ln5945">void do_autocmd(char_u *arg_in, int forceit)</a>
<a name="ln5946">{</a>
<a name="ln5947">  char_u      *arg = arg_in;</a>
<a name="ln5948">  char_u      *pat;</a>
<a name="ln5949">  char_u      *envpat = NULL;</a>
<a name="ln5950">  char_u      *cmd;</a>
<a name="ln5951">  int need_free = false;</a>
<a name="ln5952">  int nested = false;</a>
<a name="ln5953">  bool once = false;</a>
<a name="ln5954">  int group;</a>
<a name="ln5955"> </a>
<a name="ln5956">  if (*arg == '|') {</a>
<a name="ln5957">    arg = (char_u *)&quot;&quot;;</a>
<a name="ln5958">    group = AUGROUP_ALL;  // no argument, use all groups</a>
<a name="ln5959">  } else {</a>
<a name="ln5960">    // Check for a legal group name.  If not, use AUGROUP_ALL.</a>
<a name="ln5961">    group = au_get_grouparg(&amp;arg);</a>
<a name="ln5962">  }</a>
<a name="ln5963"> </a>
<a name="ln5964">  /*</a>
<a name="ln5965">   * Scan over the events.</a>
<a name="ln5966">   * If we find an illegal name, return here, don't do anything.</a>
<a name="ln5967">   */</a>
<a name="ln5968">  pat = find_end_event(arg, group != AUGROUP_ALL);</a>
<a name="ln5969">  if (pat == NULL)</a>
<a name="ln5970">    return;</a>
<a name="ln5971"> </a>
<a name="ln5972">  pat = skipwhite(pat);</a>
<a name="ln5973">  if (*pat == '|') {</a>
<a name="ln5974">    pat = (char_u *)&quot;&quot;;</a>
<a name="ln5975">    cmd = (char_u *)&quot;&quot;;</a>
<a name="ln5976">  } else {</a>
<a name="ln5977">    // Scan over the pattern.  Put a NUL at the end.</a>
<a name="ln5978">    cmd = pat;</a>
<a name="ln5979">    while (*cmd &amp;&amp; (!ascii_iswhite(*cmd) || cmd[-1] == '\\')) {</a>
<a name="ln5980">        cmd++;</a>
<a name="ln5981">    }</a>
<a name="ln5982">    if (*cmd) {</a>
<a name="ln5983">      *cmd++ = NUL;</a>
<a name="ln5984">    }</a>
<a name="ln5985"> </a>
<a name="ln5986">    // Expand environment variables in the pattern.  Set 'shellslash', we want</a>
<a name="ln5987">    // forward slashes here.</a>
<a name="ln5988">    if (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL) {</a>
<a name="ln5989">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5990">      int p_ssl_save = p_ssl;</a>
<a name="ln5991"> </a>
<a name="ln5992">      p_ssl = true;</a>
<a name="ln5993">#endif</a>
<a name="ln5994">      envpat = expand_env_save(pat);</a>
<a name="ln5995">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5996">      p_ssl = p_ssl_save;</a>
<a name="ln5997">#endif</a>
<a name="ln5998">      if (envpat != NULL) {</a>
<a name="ln5999">        pat = envpat;</a>
<a name="ln6000">      }</a>
<a name="ln6001">    }</a>
<a name="ln6002"> </a>
<a name="ln6003">    cmd = skipwhite(cmd);</a>
<a name="ln6004">    for (size_t i = 0; i &lt; 2; i++) {</a>
<a name="ln6005">      if (*cmd != NUL) {</a>
<a name="ln6006">        // Check for &quot;++once&quot; flag.</a>
<a name="ln6007">        if (STRNCMP(cmd, &quot;++once&quot;, 6) == 0 &amp;&amp; ascii_iswhite(cmd[6])) {</a>
<a name="ln6008">          if (once) {</a>
<a name="ln6009">            EMSG2(_(e_duparg2), &quot;++once&quot;);</a>
<a name="ln6010">          }</a>
<a name="ln6011">          once = true;</a>
<a name="ln6012">          cmd = skipwhite(cmd + 6);</a>
<a name="ln6013">        }</a>
<a name="ln6014"> </a>
<a name="ln6015">        // Check for &quot;++nested&quot; flag.</a>
<a name="ln6016">        if ((STRNCMP(cmd, &quot;++nested&quot;, 8) == 0 &amp;&amp; ascii_iswhite(cmd[8]))) {</a>
<a name="ln6017">          if (nested) {</a>
<a name="ln6018">            EMSG2(_(e_duparg2), &quot;++nested&quot;);</a>
<a name="ln6019">          }</a>
<a name="ln6020">          nested = true;</a>
<a name="ln6021">          cmd = skipwhite(cmd + 8);</a>
<a name="ln6022">        }</a>
<a name="ln6023"> </a>
<a name="ln6024">        // Check for the old (deprecated) &quot;nested&quot; flag.</a>
<a name="ln6025">        if (STRNCMP(cmd, &quot;nested&quot;, 6) == 0 &amp;&amp; ascii_iswhite(cmd[6])) {</a>
<a name="ln6026">          if (nested) {</a>
<a name="ln6027">            EMSG2(_(e_duparg2), &quot;nested&quot;);</a>
<a name="ln6028">          }</a>
<a name="ln6029">          nested = true;</a>
<a name="ln6030">          cmd = skipwhite(cmd + 6);</a>
<a name="ln6031">        }</a>
<a name="ln6032">      }</a>
<a name="ln6033">    }</a>
<a name="ln6034"> </a>
<a name="ln6035">    // Find the start of the commands.</a>
<a name="ln6036">    // Expand &lt;sfile&gt; in it.</a>
<a name="ln6037">    if (*cmd != NUL) {</a>
<a name="ln6038">      cmd = expand_sfile(cmd);</a>
<a name="ln6039">      if (cmd == NULL) {                // some error</a>
<a name="ln6040">        return;</a>
<a name="ln6041">      }</a>
<a name="ln6042">      need_free = true;</a>
<a name="ln6043">    }</a>
<a name="ln6044">  }</a>
<a name="ln6045"> </a>
<a name="ln6046">  /*</a>
<a name="ln6047">   * Print header when showing autocommands.</a>
<a name="ln6048">   */</a>
<a name="ln6049">  if (!forceit &amp;&amp; *cmd == NUL) {</a>
<a name="ln6050">    // Highlight title</a>
<a name="ln6051">    MSG_PUTS_TITLE(_(&quot;\n--- Autocommands ---&quot;));</a>
<a name="ln6052">  }</a>
<a name="ln6053"> </a>
<a name="ln6054">  /*</a>
<a name="ln6055">   * Loop over the events.</a>
<a name="ln6056">   */</a>
<a name="ln6057">  last_event = (event_T)-1;             // for listing the event name</a>
<a name="ln6058">  last_group = AUGROUP_ERROR;           // for listing the group name</a>
<a name="ln6059">  if (*arg == '*' || *arg == NUL || *arg == '|') {</a>
<a name="ln6060">    for (event_T event = (event_T)0; (int)event &lt; (int)NUM_EVENTS;</a>
<a name="ln6061">         event = (event_T)((int)event + 1)) {</a>
<a name="ln6062">      if (do_autocmd_event(event, pat, once, nested, cmd, forceit, group)</a>
<a name="ln6063">          == FAIL) {</a>
<a name="ln6064">        break;</a>
<a name="ln6065">      }</a>
<a name="ln6066">    }</a>
<a name="ln6067">  } else {</a>
<a name="ln6068">    while (*arg &amp;&amp; *arg != '|' &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln6069">      event_T event = event_name2nr(arg, &amp;arg);</a>
<a name="ln6070">      assert(event &lt; NUM_EVENTS);</a>
<a name="ln6071">      if (do_autocmd_event(event, pat, once, nested, cmd, forceit, group)</a>
<a name="ln6072">          == FAIL) {</a>
<a name="ln6073">        break;</a>
<a name="ln6074">      }</a>
<a name="ln6075">    }</a>
<a name="ln6076">  }</a>
<a name="ln6077"> </a>
<a name="ln6078">  if (need_free)</a>
<a name="ln6079">    xfree(cmd);</a>
<a name="ln6080">  xfree(envpat);</a>
<a name="ln6081">}</a>
<a name="ln6082"> </a>
<a name="ln6083">/*</a>
<a name="ln6084"> * Find the group ID in a &quot;:autocmd&quot; or &quot;:doautocmd&quot; argument.</a>
<a name="ln6085"> * The &quot;argp&quot; argument is advanced to the following argument.</a>
<a name="ln6086"> *</a>
<a name="ln6087"> * Returns the group ID or AUGROUP_ALL.</a>
<a name="ln6088"> */</a>
<a name="ln6089">static int au_get_grouparg(char_u **argp)</a>
<a name="ln6090">{</a>
<a name="ln6091">  char_u      *group_name;</a>
<a name="ln6092">  char_u      *p;</a>
<a name="ln6093">  char_u      *arg = *argp;</a>
<a name="ln6094">  int group = AUGROUP_ALL;</a>
<a name="ln6095"> </a>
<a name="ln6096">  for (p = arg; *p &amp;&amp; !ascii_iswhite(*p) &amp;&amp; *p != '|'; p++) {</a>
<a name="ln6097">  }</a>
<a name="ln6098">  if (p &gt; arg) {</a>
<a name="ln6099">    group_name = vim_strnsave(arg, (int)(p - arg));</a>
<a name="ln6100">    group = au_find_group(group_name);</a>
<a name="ln6101">    if (group == AUGROUP_ERROR)</a>
<a name="ln6102">      group = AUGROUP_ALL;              /* no match, use all groups */</a>
<a name="ln6103">    else</a>
<a name="ln6104">      *argp = skipwhite(p);             /* match, skip over group name */</a>
<a name="ln6105">    xfree(group_name);</a>
<a name="ln6106">  }</a>
<a name="ln6107">  return group;</a>
<a name="ln6108">}</a>
<a name="ln6109"> </a>
<a name="ln6110">// do_autocmd() for one event.</a>
<a name="ln6111">// Defines an autocmd (does not execute; cf. apply_autocmds_group).</a>
<a name="ln6112">//</a>
<a name="ln6113">// If *pat == NUL: do for all patterns.</a>
<a name="ln6114">// If *cmd == NUL: show entries.</a>
<a name="ln6115">// If forceit == TRUE: delete entries.</a>
<a name="ln6116">// If group is not AUGROUP_ALL: only use this group.</a>
<a name="ln6117">static int do_autocmd_event(event_T event, char_u *pat, bool once, int nested,</a>
<a name="ln6118">                            char_u *cmd, int forceit, int group)</a>
<a name="ln6119">{</a>
<a name="ln6120">  AutoPat     *ap;</a>
<a name="ln6121">  AutoPat     **prev_ap;</a>
<a name="ln6122">  AutoCmd     *ac;</a>
<a name="ln6123">  AutoCmd     **prev_ac;</a>
<a name="ln6124">  int brace_level;</a>
<a name="ln6125">  char_u      *endpat;</a>
<a name="ln6126">  int findgroup;</a>
<a name="ln6127">  int allgroups;</a>
<a name="ln6128">  int patlen;</a>
<a name="ln6129">  int is_buflocal;</a>
<a name="ln6130">  int buflocal_nr;</a>
<a name="ln6131">  char_u buflocal_pat[25];              /* for &quot;&lt;buffer=X&gt;&quot; */</a>
<a name="ln6132"> </a>
<a name="ln6133">  if (group == AUGROUP_ALL)</a>
<a name="ln6134">    findgroup = current_augroup;</a>
<a name="ln6135">  else</a>
<a name="ln6136">    findgroup = group;</a>
<a name="ln6137">  allgroups = (group == AUGROUP_ALL &amp;&amp; !forceit &amp;&amp; *cmd == NUL);</a>
<a name="ln6138"> </a>
<a name="ln6139">  /*</a>
<a name="ln6140">   * Show or delete all patterns for an event.</a>
<a name="ln6141">   */</a>
<a name="ln6142">  if (*pat == NUL) {</a>
<a name="ln6143">    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap-&gt;next) {</a>
<a name="ln6144">      if (forceit) {      /* delete the AutoPat, if it's in the current group */</a>
<a name="ln6145">        if (ap-&gt;group == findgroup)</a>
<a name="ln6146">          au_remove_pat(ap);</a>
<a name="ln6147">      } else if (group == AUGROUP_ALL || ap-&gt;group == group)</a>
<a name="ln6148">        show_autocmd(ap, event);</a>
<a name="ln6149">    }</a>
<a name="ln6150">  }</a>
<a name="ln6151"> </a>
<a name="ln6152">  /*</a>
<a name="ln6153">   * Loop through all the specified patterns.</a>
<a name="ln6154">   */</a>
<a name="ln6155">  for (; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat)) {</a>
<a name="ln6156">    /*</a>
<a name="ln6157">     * Find end of the pattern.</a>
<a name="ln6158">     * Watch out for a comma in braces, like &quot;*.\{obj,o\}&quot;.</a>
<a name="ln6159">     */</a>
<a name="ln6160">    endpat = pat;</a>
<a name="ln6161">    // ignore single comma</a>
<a name="ln6162">    if (*endpat == ',') {</a>
<a name="ln6163">      continue;</a>
<a name="ln6164">    }</a>
<a name="ln6165">    brace_level = 0;</a>
<a name="ln6166">    for (; *endpat &amp;&amp; (*endpat != ',' || brace_level || endpat[-1] == '\\');</a>
<a name="ln6167">         ++endpat) {</a>
<a name="ln6168">      if (*endpat == '{')</a>
<a name="ln6169">        brace_level++;</a>
<a name="ln6170">      else if (*endpat == '}')</a>
<a name="ln6171">        brace_level--;</a>
<a name="ln6172">    }</a>
<a name="ln6173">    patlen = (int)(endpat - pat);</a>
<a name="ln6174"> </a>
<a name="ln6175">    /*</a>
<a name="ln6176">     * detect special &lt;buflocal[=X]&gt; buffer-local patterns</a>
<a name="ln6177">     */</a>
<a name="ln6178">    is_buflocal = FALSE;</a>
<a name="ln6179">    buflocal_nr = 0;</a>
<a name="ln6180"> </a>
<a name="ln6181">    if (patlen &gt;= 8 &amp;&amp; STRNCMP(pat, &quot;&lt;buffer&quot;, 7) == 0</a>
<a name="ln6182">        &amp;&amp; pat[patlen - 1] == '&gt;') {</a>
<a name="ln6183">      /* &quot;&lt;buffer...&gt;&quot;: Error will be printed only for addition.</a>
<a name="ln6184">       * printing and removing will proceed silently. */</a>
<a name="ln6185">      is_buflocal = TRUE;</a>
<a name="ln6186">      if (patlen == 8)</a>
<a name="ln6187">        /* &quot;&lt;buffer&gt;&quot; */</a>
<a name="ln6188">        buflocal_nr = curbuf-&gt;b_fnum;</a>
<a name="ln6189">      else if (patlen &gt; 9 &amp;&amp; pat[7] == '=') {</a>
<a name="ln6190">        if (patlen == 13 &amp;&amp; STRNICMP(pat, &quot;&lt;buffer=abuf&gt;&quot;, 13) == 0)</a>
<a name="ln6191">          /* &quot;&lt;buffer=abuf&gt;&quot; */</a>
<a name="ln6192">          buflocal_nr = autocmd_bufnr;</a>
<a name="ln6193">        else if (skipdigits(pat + 8) == pat + patlen - 1)</a>
<a name="ln6194">          /* &quot;&lt;buffer=123&gt;&quot; */</a>
<a name="ln6195">          buflocal_nr = atoi((char *)pat + 8);</a>
<a name="ln6196">      }</a>
<a name="ln6197">    }</a>
<a name="ln6198"> </a>
<a name="ln6199">    if (is_buflocal) {</a>
<a name="ln6200">      /* normalize pat into standard &quot;&lt;buffer&gt;#N&quot; form */</a>
<a name="ln6201">      sprintf((char *)buflocal_pat, &quot;&lt;buffer=%d&gt;&quot;, buflocal_nr);</a>
<a name="ln6202">      pat = buflocal_pat;                       /* can modify pat and patlen */</a>
<a name="ln6203">      patlen = (int)STRLEN(buflocal_pat);       /*   but not endpat */</a>
<a name="ln6204">    }</a>
<a name="ln6205"> </a>
<a name="ln6206">    // Find AutoPat entries with this pattern.  When adding a command it</a>
<a name="ln6207">    // always goes at or after the last one, so start at the end.</a>
<a name="ln6208">    if (!forceit &amp;&amp; *cmd != NUL &amp;&amp; last_autopat[(int)event] != NULL) {</a>
<a name="ln6209">      prev_ap = &amp;last_autopat[(int)event];</a>
<a name="ln6210">    } else {</a>
<a name="ln6211">      prev_ap = &amp;first_autopat[(int)event];</a>
<a name="ln6212">    }</a>
<a name="ln6213">    while ((ap = *prev_ap) != NULL) {</a>
<a name="ln6214">      if (ap-&gt;pat != NULL) {</a>
<a name="ln6215">        /* Accept a pattern when:</a>
<a name="ln6216">         * - a group was specified and it's that group, or a group was</a>
<a name="ln6217">         *   not specified and it's the current group, or a group was</a>
<a name="ln6218">         *   not specified and we are listing</a>
<a name="ln6219">         * - the length of the pattern matches</a>
<a name="ln6220">         * - the pattern matches.</a>
<a name="ln6221">         * For &lt;buffer[=X]&gt;, this condition works because we normalize</a>
<a name="ln6222">         * all buffer-local patterns.</a>
<a name="ln6223">         */</a>
<a name="ln6224">        if ((allgroups || ap-&gt;group == findgroup)</a>
<a name="ln6225">            &amp;&amp; ap-&gt;patlen == patlen</a>
<a name="ln6226">            &amp;&amp; STRNCMP(pat, ap-&gt;pat, patlen) == 0) {</a>
<a name="ln6227">          /*</a>
<a name="ln6228">           * Remove existing autocommands.</a>
<a name="ln6229">           * If adding any new autocmd's for this AutoPat, don't</a>
<a name="ln6230">           * delete the pattern from the autopat list, append to</a>
<a name="ln6231">           * this list.</a>
<a name="ln6232">           */</a>
<a name="ln6233">          if (forceit) {</a>
<a name="ln6234">            if (*cmd != NUL &amp;&amp; ap-&gt;next == NULL) {</a>
<a name="ln6235">              au_remove_cmds(ap);</a>
<a name="ln6236">              break;</a>
<a name="ln6237">            }</a>
<a name="ln6238">            au_remove_pat(ap);</a>
<a name="ln6239">          }</a>
<a name="ln6240">          /*</a>
<a name="ln6241">           * Show autocmd's for this autopat, or buflocals &lt;buffer=X&gt;</a>
<a name="ln6242">           */</a>
<a name="ln6243">          else if (*cmd == NUL)</a>
<a name="ln6244">            show_autocmd(ap, event);</a>
<a name="ln6245"> </a>
<a name="ln6246">          /*</a>
<a name="ln6247">           * Add autocmd to this autopat, if it's the last one.</a>
<a name="ln6248">           */</a>
<a name="ln6249">          else if (ap-&gt;next == NULL)</a>
<a name="ln6250">            break;</a>
<a name="ln6251">        }</a>
<a name="ln6252">      }</a>
<a name="ln6253">      prev_ap = &amp;ap-&gt;next;</a>
<a name="ln6254">    }</a>
<a name="ln6255"> </a>
<a name="ln6256">    /*</a>
<a name="ln6257">     * Add a new command.</a>
<a name="ln6258">     */</a>
<a name="ln6259">    if (*cmd != NUL) {</a>
<a name="ln6260">      /*</a>
<a name="ln6261">       * If the pattern we want to add a command to does appear at the</a>
<a name="ln6262">       * end of the list (or not is not in the list at all), add the</a>
<a name="ln6263">       * pattern at the end of the list.</a>
<a name="ln6264">       */</a>
<a name="ln6265">      if (ap == NULL) {</a>
<a name="ln6266">        /* refuse to add buffer-local ap if buffer number is invalid */</a>
<a name="ln6267">        if (is_buflocal &amp;&amp; (buflocal_nr == 0</a>
<a name="ln6268">                            || buflist_findnr(buflocal_nr) == NULL)) {</a>
<a name="ln6269">          emsgf(_(&quot;E680: &lt;buffer=%d&gt;: invalid buffer number &quot;),</a>
<a name="ln6270">                buflocal_nr);</a>
<a name="ln6271">          return FAIL;</a>
<a name="ln6272">        }</a>
<a name="ln6273"> </a>
<a name="ln6274">        ap = xmalloc(sizeof(AutoPat));</a>
<a name="ln6275">        ap-&gt;pat = vim_strnsave(pat, patlen);</a>
<a name="ln6276">        ap-&gt;patlen = patlen;</a>
<a name="ln6277"> </a>
<a name="ln6278">        if (is_buflocal) {</a>
<a name="ln6279">          ap-&gt;buflocal_nr = buflocal_nr;</a>
<a name="ln6280">          ap-&gt;reg_prog = NULL;</a>
<a name="ln6281">        } else {</a>
<a name="ln6282">          char_u      *reg_pat;</a>
<a name="ln6283"> </a>
<a name="ln6284">          ap-&gt;buflocal_nr = 0;</a>
<a name="ln6285">          reg_pat = file_pat_to_reg_pat(pat, endpat,</a>
<a name="ln6286">              &amp;ap-&gt;allow_dirs, TRUE);</a>
<a name="ln6287">          if (reg_pat != NULL)</a>
<a name="ln6288">            ap-&gt;reg_prog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln6289">          xfree(reg_pat);</a>
<a name="ln6290">          if (reg_pat == NULL || ap-&gt;reg_prog == NULL) {</a>
<a name="ln6291">            xfree(ap-&gt;pat);</a>
<a name="ln6292">            xfree(ap);</a>
<a name="ln6293">            return FAIL;</a>
<a name="ln6294">          }</a>
<a name="ln6295">        }</a>
<a name="ln6296">        ap-&gt;cmds = NULL;</a>
<a name="ln6297">        *prev_ap = ap;</a>
<a name="ln6298">        last_autopat[(int)event] = ap;</a>
<a name="ln6299">        ap-&gt;next = NULL;</a>
<a name="ln6300">        if (group == AUGROUP_ALL)</a>
<a name="ln6301">          ap-&gt;group = current_augroup;</a>
<a name="ln6302">        else</a>
<a name="ln6303">          ap-&gt;group = group;</a>
<a name="ln6304">      }</a>
<a name="ln6305"> </a>
<a name="ln6306">      /*</a>
<a name="ln6307">       * Add the autocmd at the end of the AutoCmd list.</a>
<a name="ln6308">       */</a>
<a name="ln6309">      prev_ac = &amp;(ap-&gt;cmds);</a>
<a name="ln6310">      while ((ac = *prev_ac) != NULL)</a>
<a name="ln6311">        prev_ac = &amp;ac-&gt;next;</a>
<a name="ln6312">      ac = xmalloc(sizeof(AutoCmd));</a>
<a name="ln6313">      ac-&gt;cmd = vim_strsave(cmd);</a>
<a name="ln6314">      ac-&gt;script_ctx = current_sctx;</a>
<a name="ln6315">      ac-&gt;script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln6316">      ac-&gt;next = NULL;</a>
<a name="ln6317">      *prev_ac = ac;</a>
<a name="ln6318">      ac-&gt;once = once;</a>
<a name="ln6319">      ac-&gt;nested = nested;</a>
<a name="ln6320">    }</a>
<a name="ln6321">  }</a>
<a name="ln6322"> </a>
<a name="ln6323">  au_cleanup();         /* may really delete removed patterns/commands now */</a>
<a name="ln6324">  return OK;</a>
<a name="ln6325">}</a>
<a name="ln6326"> </a>
<a name="ln6327">// Implementation of &quot;:doautocmd [group] event [fname]&quot;.</a>
<a name="ln6328">// Return OK for success, FAIL for failure;</a>
<a name="ln6329">int</a>
<a name="ln6330">do_doautocmd(</a>
<a name="ln6331">    char_u *arg,</a>
<a name="ln6332">    int do_msg,  // give message for no matching autocmds?</a>
<a name="ln6333">    bool *did_something</a>
<a name="ln6334">)</a>
<a name="ln6335">{</a>
<a name="ln6336">  char_u      *fname;</a>
<a name="ln6337">  int nothing_done = TRUE;</a>
<a name="ln6338">  int group;</a>
<a name="ln6339"> </a>
<a name="ln6340">  if (did_something != NULL) {</a>
<a name="ln6341">    *did_something = false;</a>
<a name="ln6342">  }</a>
<a name="ln6343"> </a>
<a name="ln6344">  /*</a>
<a name="ln6345">   * Check for a legal group name.  If not, use AUGROUP_ALL.</a>
<a name="ln6346">   */</a>
<a name="ln6347">  group = au_get_grouparg(&amp;arg);</a>
<a name="ln6348"> </a>
<a name="ln6349">  if (*arg == '*') {</a>
<a name="ln6350">    EMSG(_(&quot;E217: Can't execute autocommands for ALL events&quot;));</a>
<a name="ln6351">    return FAIL;</a>
<a name="ln6352">  }</a>
<a name="ln6353"> </a>
<a name="ln6354">  /*</a>
<a name="ln6355">   * Scan over the events.</a>
<a name="ln6356">   * If we find an illegal name, return here, don't do anything.</a>
<a name="ln6357">   */</a>
<a name="ln6358">  fname = find_end_event(arg, group != AUGROUP_ALL);</a>
<a name="ln6359">  if (fname == NULL)</a>
<a name="ln6360">    return FAIL;</a>
<a name="ln6361"> </a>
<a name="ln6362">  fname = skipwhite(fname);</a>
<a name="ln6363"> </a>
<a name="ln6364">  // Loop over the events.</a>
<a name="ln6365">  while (*arg &amp;&amp; !ends_excmd(*arg) &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln6366">    if (apply_autocmds_group(event_name2nr(arg, &amp;arg), fname, NULL, true,</a>
<a name="ln6367">                             group, curbuf, NULL)) {</a>
<a name="ln6368">      nothing_done = false;</a>
<a name="ln6369">    }</a>
<a name="ln6370">  }</a>
<a name="ln6371"> </a>
<a name="ln6372">  if (nothing_done &amp;&amp; do_msg) {</a>
<a name="ln6373">    MSG(_(&quot;No matching autocommands&quot;));</a>
<a name="ln6374">  }</a>
<a name="ln6375">  if (did_something != NULL) {</a>
<a name="ln6376">    *did_something = !nothing_done;</a>
<a name="ln6377">  }</a>
<a name="ln6378"> </a>
<a name="ln6379">  return aborting() ? FAIL : OK;</a>
<a name="ln6380">}</a>
<a name="ln6381"> </a>
<a name="ln6382">/*</a>
<a name="ln6383"> * &quot;:doautoall&quot;: execute autocommands for each loaded buffer.</a>
<a name="ln6384"> */</a>
<a name="ln6385">void ex_doautoall(exarg_T *eap)</a>
<a name="ln6386">{</a>
<a name="ln6387">  int retval;</a>
<a name="ln6388">  aco_save_T aco;</a>
<a name="ln6389">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln6390">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln6391">  bufref_T bufref;</a>
<a name="ln6392"> </a>
<a name="ln6393">  /*</a>
<a name="ln6394">   * This is a bit tricky: For some commands curwin-&gt;w_buffer needs to be</a>
<a name="ln6395">   * equal to curbuf, but for some buffers there may not be a window.</a>
<a name="ln6396">   * So we change the buffer for the current window for a moment.  This</a>
<a name="ln6397">   * gives problems when the autocommands make changes to the list of</a>
<a name="ln6398">   * buffers or windows...</a>
<a name="ln6399">   */</a>
<a name="ln6400">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6401">    if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln6402">      continue;</a>
<a name="ln6403">    }</a>
<a name="ln6404">    // Find a window for this buffer and save some values.</a>
<a name="ln6405">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln6406">    set_bufref(&amp;bufref, buf);</a>
<a name="ln6407"> </a>
<a name="ln6408">    bool did_aucmd;</a>
<a name="ln6409">    // execute the autocommands for this buffer</a>
<a name="ln6410">    retval = do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln6411"> </a>
<a name="ln6412">    if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln6413">      // Execute the modeline settings, but don't set window-local</a>
<a name="ln6414">      // options if we are using the current window for another</a>
<a name="ln6415">      // buffer.</a>
<a name="ln6416">      do_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);</a>
<a name="ln6417">    }</a>
<a name="ln6418"> </a>
<a name="ln6419">    /* restore the current window */</a>
<a name="ln6420">    aucmd_restbuf(&amp;aco);</a>
<a name="ln6421"> </a>
<a name="ln6422">    // Stop if there is some error or buffer was deleted.</a>
<a name="ln6423">    if (retval == FAIL || !bufref_valid(&amp;bufref)) {</a>
<a name="ln6424">      break;</a>
<a name="ln6425">    }</a>
<a name="ln6426">  }</a>
<a name="ln6427"> </a>
<a name="ln6428">  check_cursor();           /* just in case lines got deleted */</a>
<a name="ln6429">}</a>
<a name="ln6430"> </a>
<a name="ln6431">/// Check *argp for &lt;nomodeline&gt;.  When it is present return false, otherwise</a>
<a name="ln6432">/// return true and advance *argp to after it. Thus do_modelines() should be</a>
<a name="ln6433">/// called when true is returned.</a>
<a name="ln6434">///</a>
<a name="ln6435">/// @param[in,out] argp argument string</a>
<a name="ln6436">bool check_nomodeline(char_u **argp)</a>
<a name="ln6437">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6438">{</a>
<a name="ln6439">  if (STRNCMP(*argp, &quot;&lt;nomodeline&gt;&quot;, 12) == 0) {</a>
<a name="ln6440">    *argp = skipwhite(*argp + 12);</a>
<a name="ln6441">    return false;</a>
<a name="ln6442">  }</a>
<a name="ln6443">  return true;</a>
<a name="ln6444">}</a>
<a name="ln6445"> </a>
<a name="ln6446">/// Prepare for executing autocommands for (hidden) buffer `buf`.</a>
<a name="ln6447">/// If the current buffer is not in any visible window, put it in a temporary</a>
<a name="ln6448">/// floating window `aucmd_win`.</a>
<a name="ln6449">/// Set `curbuf` and `curwin` to match `buf`.</a>
<a name="ln6450">///</a>
<a name="ln6451">/// @param aco  structure to save values in</a>
<a name="ln6452">/// @param buf  new curbuf</a>
<a name="ln6453">void aucmd_prepbuf(aco_save_T *aco, buf_T *buf)</a>
<a name="ln6454">{</a>
<a name="ln6455">  win_T *win;</a>
<a name="ln6456">  bool need_append = true;  // Append `aucmd_win` to the window list.</a>
<a name="ln6457"> </a>
<a name="ln6458">  /* Find a window that is for the new buffer */</a>
<a name="ln6459">  if (buf == curbuf) {          /* be quick when buf is curbuf */</a>
<a name="ln6460">    win = curwin;</a>
<a name="ln6461">  } else {</a>
<a name="ln6462">    win = NULL;</a>
<a name="ln6463">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6464">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln6465">        win = wp;</a>
<a name="ln6466">        break;</a>
<a name="ln6467">      }</a>
<a name="ln6468">    }</a>
<a name="ln6469">  }</a>
<a name="ln6470"> </a>
<a name="ln6471">  // Allocate the `aucmd_win` dummy floating window.</a>
<a name="ln6472">  if (win == NULL &amp;&amp; aucmd_win == NULL) {</a>
<a name="ln6473">    win_alloc_aucmd_win();</a>
<a name="ln6474">    need_append = false;</a>
<a name="ln6475">  }</a>
<a name="ln6476">  if (win == NULL &amp;&amp; aucmd_win_used)</a>
<a name="ln6477">    /* Strange recursive autocommand, fall back to using the current</a>
<a name="ln6478">     * window.  Expect a few side effects... */</a>
<a name="ln6479">    win = curwin;</a>
<a name="ln6480"> </a>
<a name="ln6481">  aco-&gt;save_curwin = curwin;</a>
<a name="ln6482">  aco-&gt;save_prevwin = prevwin;</a>
<a name="ln6483">  aco-&gt;save_curbuf = curbuf;</a>
<a name="ln6484">  if (win != NULL) {</a>
<a name="ln6485">    /* There is a window for &quot;buf&quot; in the current tab page, make it the</a>
<a name="ln6486">     * curwin.  This is preferred, it has the least side effects (esp. if</a>
<a name="ln6487">     * &quot;buf&quot; is curbuf). */</a>
<a name="ln6488">    aco-&gt;use_aucmd_win = FALSE;</a>
<a name="ln6489">    curwin = win;</a>
<a name="ln6490">  } else {</a>
<a name="ln6491">    /* There is no window for &quot;buf&quot;, use &quot;aucmd_win&quot;.  To minimize the side</a>
<a name="ln6492">     * effects, insert it in the current tab page.</a>
<a name="ln6493">     * Anything related to a window (e.g., setting folds) may have</a>
<a name="ln6494">     * unexpected results. */</a>
<a name="ln6495">    aco-&gt;use_aucmd_win = TRUE;</a>
<a name="ln6496">    aucmd_win_used = TRUE;</a>
<a name="ln6497">    aucmd_win-&gt;w_buffer = buf;</a>
<a name="ln6498">    aucmd_win-&gt;w_s = &amp;buf-&gt;b_s;</a>
<a name="ln6499">    ++buf-&gt;b_nwindows;</a>
<a name="ln6500">    win_init_empty(aucmd_win);     /* set cursor and topline to safe values */</a>
<a name="ln6501"> </a>
<a name="ln6502">    /* Make sure w_localdir and globaldir are NULL to avoid a chdir() in</a>
<a name="ln6503">     * win_enter_ext(). */</a>
<a name="ln6504">    XFREE_CLEAR(aucmd_win-&gt;w_localdir);</a>
<a name="ln6505">    aco-&gt;globaldir = globaldir;</a>
<a name="ln6506">    globaldir = NULL;</a>
<a name="ln6507"> </a>
<a name="ln6508">    block_autocmds();  // We don't want BufEnter/WinEnter autocommands.</a>
<a name="ln6509">    if (need_append) {</a>
<a name="ln6510">      win_append(lastwin, aucmd_win);</a>
<a name="ln6511">      handle_register_window(aucmd_win);</a>
<a name="ln6512">      win_config_float(aucmd_win, aucmd_win-&gt;w_float_config);</a>
<a name="ln6513">    }</a>
<a name="ln6514">    // Prevent chdir() call in win_enter_ext(), through do_autochdir()</a>
<a name="ln6515">    int save_acd = p_acd;</a>
<a name="ln6516">    p_acd = false;</a>
<a name="ln6517">    win_enter(aucmd_win, false);</a>
<a name="ln6518">    p_acd = save_acd;</a>
<a name="ln6519">    unblock_autocmds();</a>
<a name="ln6520">    curwin = aucmd_win;</a>
<a name="ln6521">  }</a>
<a name="ln6522">  curbuf = buf;</a>
<a name="ln6523">  aco-&gt;new_curwin = curwin;</a>
<a name="ln6524">  set_bufref(&amp;aco-&gt;new_curbuf, curbuf);</a>
<a name="ln6525">}</a>
<a name="ln6526"> </a>
<a name="ln6527">/// Cleanup after executing autocommands for a (hidden) buffer.</a>
<a name="ln6528">/// Restore the window as it was (if possible).</a>
<a name="ln6529">///</a>
<a name="ln6530">/// @param aco  structure holding saved values</a>
<a name="ln6531">void aucmd_restbuf(aco_save_T *aco)</a>
<a name="ln6532">{</a>
<a name="ln6533">  if (aco-&gt;use_aucmd_win) {</a>
<a name="ln6534">    curbuf-&gt;b_nwindows--;</a>
<a name="ln6535">    // Find &quot;aucmd_win&quot;, it can't be closed, but it may be in another tab page.</a>
<a name="ln6536">    // Do not trigger autocommands here.</a>
<a name="ln6537">    block_autocmds();</a>
<a name="ln6538">    if (curwin != aucmd_win) {</a>
<a name="ln6539">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6540">        if (wp == aucmd_win) {</a>
<a name="ln6541">          if (tp != curtab) {</a>
<a name="ln6542">            goto_tabpage_tp(tp, true, true);</a>
<a name="ln6543">          }</a>
<a name="ln6544">          win_goto(aucmd_win);</a>
<a name="ln6545">          goto win_found;</a>
<a name="ln6546">        }</a>
<a name="ln6547">      }</a>
<a name="ln6548">    }</a>
<a name="ln6549">win_found:</a>
<a name="ln6550"> </a>
<a name="ln6551">    win_remove(curwin, NULL);</a>
<a name="ln6552">    handle_unregister_window(curwin);</a>
<a name="ln6553">    if (curwin-&gt;w_grid.chars != NULL) {</a>
<a name="ln6554">      ui_comp_remove_grid(&amp;curwin-&gt;w_grid);</a>
<a name="ln6555">      ui_call_win_hide(curwin-&gt;w_grid.handle);</a>
<a name="ln6556">      grid_free(&amp;curwin-&gt;w_grid);</a>
<a name="ln6557">    }</a>
<a name="ln6558"> </a>
<a name="ln6559">    aucmd_win_used = false;</a>
<a name="ln6560">    last_status(false);         // may need to remove last status line</a>
<a name="ln6561"> </a>
<a name="ln6562">    if (!valid_tabpage_win(curtab)) {</a>
<a name="ln6563">      // no valid window in current tabpage</a>
<a name="ln6564">      close_tabpage(curtab);</a>
<a name="ln6565">    }</a>
<a name="ln6566"> </a>
<a name="ln6567">    unblock_autocmds();</a>
<a name="ln6568"> </a>
<a name="ln6569">    if (win_valid(aco-&gt;save_curwin)) {</a>
<a name="ln6570">      curwin = aco-&gt;save_curwin;</a>
<a name="ln6571">    } else {</a>
<a name="ln6572">      // Hmm, original window disappeared.  Just use the first one.</a>
<a name="ln6573">      curwin = firstwin;</a>
<a name="ln6574">    }</a>
<a name="ln6575">    prevwin = win_valid(aco-&gt;save_prevwin) ? aco-&gt;save_prevwin</a>
<a name="ln6576">              : firstwin;  // window disappeared?</a>
<a name="ln6577">    vars_clear(&amp;aucmd_win-&gt;w_vars-&gt;dv_hashtab);      // free all w: variables</a>
<a name="ln6578">    hash_init(&amp;aucmd_win-&gt;w_vars-&gt;dv_hashtab);       // re-use the hashtab</a>
<a name="ln6579">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln6580"> </a>
<a name="ln6581">    xfree(globaldir);</a>
<a name="ln6582">    globaldir = aco-&gt;globaldir;</a>
<a name="ln6583"> </a>
<a name="ln6584">    // the buffer contents may have changed</a>
<a name="ln6585">    check_cursor();</a>
<a name="ln6586">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6587">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln6588">      curwin-&gt;w_topfill = 0;</a>
<a name="ln6589">    }</a>
<a name="ln6590">  } else {</a>
<a name="ln6591">    // restore curwin</a>
<a name="ln6592">    if (win_valid(aco-&gt;save_curwin)) {</a>
<a name="ln6593">      // Restore the buffer which was previously edited by curwin, if it was</a>
<a name="ln6594">      // changed, we are still the same window and the buffer is valid.</a>
<a name="ln6595">      if (curwin == aco-&gt;new_curwin</a>
<a name="ln6596">          &amp;&amp; curbuf != aco-&gt;new_curbuf.br_buf</a>
<a name="ln6597">          &amp;&amp; bufref_valid(&amp;aco-&gt;new_curbuf)</a>
<a name="ln6598">          &amp;&amp; aco-&gt;new_curbuf.br_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln6599">        if (curwin-&gt;w_s == &amp;curbuf-&gt;b_s) {</a>
<a name="ln6600">          curwin-&gt;w_s = &amp;aco-&gt;new_curbuf.br_buf-&gt;b_s;</a>
<a name="ln6601">        }</a>
<a name="ln6602">        curbuf-&gt;b_nwindows--;</a>
<a name="ln6603">        curbuf = aco-&gt;new_curbuf.br_buf;</a>
<a name="ln6604">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln6605">        curbuf-&gt;b_nwindows++;</a>
<a name="ln6606">      }</a>
<a name="ln6607"> </a>
<a name="ln6608">      curwin = aco-&gt;save_curwin;</a>
<a name="ln6609">      prevwin = win_valid(aco-&gt;save_prevwin) ? aco-&gt;save_prevwin</a>
<a name="ln6610">                : firstwin;  // window disappeared?</a>
<a name="ln6611">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln6612">      // In case the autocommand moves the cursor to a position that does not</a>
<a name="ln6613">      // exist in curbuf</a>
<a name="ln6614">      check_cursor();</a>
<a name="ln6615">    }</a>
<a name="ln6616">  }</a>
<a name="ln6617">}</a>
<a name="ln6618"> </a>
<a name="ln6619">static int autocmd_nested = FALSE;</a>
<a name="ln6620"> </a>
<a name="ln6621">/// Execute autocommands for &quot;event&quot; and file name &quot;fname&quot;.</a>
<a name="ln6622">///</a>
<a name="ln6623">/// @param event event that occurred</a>
<a name="ln6624">/// @param fname filename, NULL or empty means use actual file name</a>
<a name="ln6625">/// @param fname_io filename to use for &lt;afile&gt; on cmdline</a>
<a name="ln6626">/// @param force When true, ignore autocmd_busy</a>
<a name="ln6627">/// @param buf Buffer for &lt;abuf&gt;</a>
<a name="ln6628">///</a>
<a name="ln6629">/// @return true if some commands were executed.</a>
<a name="ln6630">bool apply_autocmds(event_T event, char_u *fname, char_u *fname_io, bool force,</a>
<a name="ln6631">                    buf_T *buf)</a>
<a name="ln6632">{</a>
<a name="ln6633">  return apply_autocmds_group(event, fname, fname_io, force,</a>
<a name="ln6634">      AUGROUP_ALL, buf, NULL);</a>
<a name="ln6635">}</a>
<a name="ln6636"> </a>
<a name="ln6637">/// Like apply_autocmds(), but with extra &quot;eap&quot; argument.  This takes care of</a>
<a name="ln6638">/// setting v:filearg.</a>
<a name="ln6639">///</a>
<a name="ln6640">/// @param event event that occurred</a>
<a name="ln6641">/// @param fname NULL or empty means use actual file name</a>
<a name="ln6642">/// @param fname_io fname to use for &lt;afile&gt; on cmdline</a>
<a name="ln6643">/// @param force When true, ignore autocmd_busy</a>
<a name="ln6644">/// @param buf Buffer for &lt;abuf&gt;</a>
<a name="ln6645">/// @param exarg Ex command arguments</a>
<a name="ln6646">///</a>
<a name="ln6647">/// @return true if some commands were executed.</a>
<a name="ln6648">static bool apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io,</a>
<a name="ln6649">                                 bool force, buf_T *buf, exarg_T *eap)</a>
<a name="ln6650">{</a>
<a name="ln6651">  return apply_autocmds_group(event, fname, fname_io, force,</a>
<a name="ln6652">      AUGROUP_ALL, buf, eap);</a>
<a name="ln6653">}</a>
<a name="ln6654"> </a>
<a name="ln6655">/// Like apply_autocmds(), but handles the caller's retval.  If the script</a>
<a name="ln6656">/// processing is being aborted or if retval is FAIL when inside a try</a>
<a name="ln6657">/// conditional, no autocommands are executed.  If otherwise the autocommands</a>
<a name="ln6658">/// cause the script to be aborted, retval is set to FAIL.</a>
<a name="ln6659">///</a>
<a name="ln6660">/// @param event event that occurred</a>
<a name="ln6661">/// @param fname NULL or empty means use actual file name</a>
<a name="ln6662">/// @param fname_io fname to use for &lt;afile&gt; on cmdline</a>
<a name="ln6663">/// @param force When true, ignore autocmd_busy</a>
<a name="ln6664">/// @param buf Buffer for &lt;abuf&gt;</a>
<a name="ln6665">/// @param[in,out] retval caller's retval</a>
<a name="ln6666">///</a>
<a name="ln6667">/// @return true if some autocommands were executed</a>
<a name="ln6668">bool apply_autocmds_retval(event_T event, char_u *fname, char_u *fname_io,</a>
<a name="ln6669">                           bool force, buf_T *buf, int *retval)</a>
<a name="ln6670">{</a>
<a name="ln6671">  if (should_abort(*retval)) {</a>
<a name="ln6672">    return false;</a>
<a name="ln6673">  }</a>
<a name="ln6674"> </a>
<a name="ln6675">  bool did_cmd = apply_autocmds_group(event, fname, fname_io, force,</a>
<a name="ln6676">                                      AUGROUP_ALL, buf, NULL);</a>
<a name="ln6677">  if (did_cmd &amp;&amp; aborting()) {</a>
<a name="ln6678">    *retval = FAIL;</a>
<a name="ln6679">  }</a>
<a name="ln6680">  return did_cmd;</a>
<a name="ln6681">}</a>
<a name="ln6682"> </a>
<a name="ln6683">/// Return true when there is a CursorHold/CursorHoldI autocommand defined for</a>
<a name="ln6684">/// the current mode.</a>
<a name="ln6685">bool has_cursorhold(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6686">{</a>
<a name="ln6687">  return first_autopat[(int)(get_real_state() == NORMAL_BUSY</a>
<a name="ln6688">                             ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL;</a>
<a name="ln6689">}</a>
<a name="ln6690"> </a>
<a name="ln6691">/// Return true if the CursorHold/CursorHoldI event can be triggered.</a>
<a name="ln6692">bool trigger_cursorhold(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6693">{</a>
<a name="ln6694">  int state;</a>
<a name="ln6695"> </a>
<a name="ln6696">  if (!did_cursorhold</a>
<a name="ln6697">      &amp;&amp; has_cursorhold()</a>
<a name="ln6698">      &amp;&amp; reg_recording == 0</a>
<a name="ln6699">      &amp;&amp; typebuf.tb_len == 0</a>
<a name="ln6700">      &amp;&amp; !ins_compl_active()</a>
<a name="ln6701">      ) {</a>
<a name="ln6702">    state = get_real_state();</a>
<a name="ln6703">    if (state == NORMAL_BUSY || (state &amp; INSERT) != 0) {</a>
<a name="ln6704">      return true;</a>
<a name="ln6705">    }</a>
<a name="ln6706">  }</a>
<a name="ln6707">  return false;</a>
<a name="ln6708">}</a>
<a name="ln6709"> </a>
<a name="ln6710">/// Return true if &quot;event&quot; autocommand is defined.</a>
<a name="ln6711">///</a>
<a name="ln6712">/// @param event the autocommand to check</a>
<a name="ln6713">bool has_event(event_T event) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6714">{</a>
<a name="ln6715">  return first_autopat[event] != NULL;</a>
<a name="ln6716">}</a>
<a name="ln6717"> </a>
<a name="ln6718">/// Execute autocommands for &quot;event&quot; and file name &quot;fname&quot;.</a>
<a name="ln6719">///</a>
<a name="ln6720">/// @param event event that occurred</a>
<a name="ln6721">/// @param fname filename, NULL or empty means use actual file name</a>
<a name="ln6722">/// @param fname_io filename to use for &lt;afile&gt; on cmdline,</a>
<a name="ln6723">///                 NULL means use `fname`.</a>
<a name="ln6724">/// @param force When true, ignore autocmd_busy</a>
<a name="ln6725">/// @param group autocmd group ID or AUGROUP_ALL</a>
<a name="ln6726">/// @param buf Buffer for &lt;abuf&gt;</a>
<a name="ln6727">/// @param eap Ex command arguments</a>
<a name="ln6728">///</a>
<a name="ln6729">/// @return true if some commands were executed.</a>
<a name="ln6730">static bool apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io,</a>
<a name="ln6731">                                 bool force, int group, buf_T *buf,</a>
<a name="ln6732">                                 exarg_T *eap)</a>
<a name="ln6733">{</a>
<a name="ln6734">  char_u      *sfname = NULL;   /* short file name */</a>
<a name="ln6735">  char_u      *tail;</a>
<a name="ln6736">  bool save_changed;</a>
<a name="ln6737">  buf_T       *old_curbuf;</a>
<a name="ln6738">  bool retval = false;</a>
<a name="ln6739">  char_u      *save_sourcing_name;</a>
<a name="ln6740">  linenr_T save_sourcing_lnum;</a>
<a name="ln6741">  char_u      *save_autocmd_fname;</a>
<a name="ln6742">  int save_autocmd_bufnr;</a>
<a name="ln6743">  char_u      *save_autocmd_match;</a>
<a name="ln6744">  int save_autocmd_busy;</a>
<a name="ln6745">  int save_autocmd_nested;</a>
<a name="ln6746">  static int nesting = 0;</a>
<a name="ln6747">  AutoPatCmd patcmd;</a>
<a name="ln6748">  AutoPat     *ap;</a>
<a name="ln6749">  char_u      *save_cmdarg;</a>
<a name="ln6750">  long save_cmdbang;</a>
<a name="ln6751">  static int filechangeshell_busy = FALSE;</a>
<a name="ln6752">  proftime_T wait_time;</a>
<a name="ln6753">  bool did_save_redobuff = false;</a>
<a name="ln6754">  save_redo_T save_redo;</a>
<a name="ln6755">  const bool save_KeyTyped = KeyTyped;</a>
<a name="ln6756"> </a>
<a name="ln6757">  // Quickly return if there are no autocommands for this event or</a>
<a name="ln6758">  // autocommands are blocked.</a>
<a name="ln6759">  if (event == NUM_EVENTS || first_autopat[(int)event] == NULL</a>
<a name="ln6760">      || autocmd_blocked &gt; 0) {</a>
<a name="ln6761">    goto BYPASS_AU;</a>
<a name="ln6762">  }</a>
<a name="ln6763"> </a>
<a name="ln6764">  /*</a>
<a name="ln6765">   * When autocommands are busy, new autocommands are only executed when</a>
<a name="ln6766">   * explicitly enabled with the &quot;nested&quot; flag.</a>
<a name="ln6767">   */</a>
<a name="ln6768">  if (autocmd_busy &amp;&amp; !(force || autocmd_nested))</a>
<a name="ln6769">    goto BYPASS_AU;</a>
<a name="ln6770"> </a>
<a name="ln6771">  /*</a>
<a name="ln6772">   * Quickly return when immediately aborting on error, or when an interrupt</a>
<a name="ln6773">   * occurred or an exception was thrown but not caught.</a>
<a name="ln6774">   */</a>
<a name="ln6775">  if (aborting())</a>
<a name="ln6776">    goto BYPASS_AU;</a>
<a name="ln6777"> </a>
<a name="ln6778">  /*</a>
<a name="ln6779">   * FileChangedShell never nests, because it can create an endless loop.</a>
<a name="ln6780">   */</a>
<a name="ln6781">  if (filechangeshell_busy &amp;&amp; (event == EVENT_FILECHANGEDSHELL</a>
<a name="ln6782">                               || event == EVENT_FILECHANGEDSHELLPOST))</a>
<a name="ln6783">    goto BYPASS_AU;</a>
<a name="ln6784"> </a>
<a name="ln6785">  /*</a>
<a name="ln6786">   * Ignore events in 'eventignore'.</a>
<a name="ln6787">   */</a>
<a name="ln6788">  if (event_ignored(event))</a>
<a name="ln6789">    goto BYPASS_AU;</a>
<a name="ln6790"> </a>
<a name="ln6791">  /*</a>
<a name="ln6792">   * Allow nesting of autocommands, but restrict the depth, because it's</a>
<a name="ln6793">   * possible to create an endless loop.</a>
<a name="ln6794">   */</a>
<a name="ln6795">  if (nesting == 10) {</a>
<a name="ln6796">    EMSG(_(&quot;E218: autocommand nesting too deep&quot;));</a>
<a name="ln6797">    goto BYPASS_AU;</a>
<a name="ln6798">  }</a>
<a name="ln6799"> </a>
<a name="ln6800">  /*</a>
<a name="ln6801">   * Check if these autocommands are disabled.  Used when doing &quot;:all&quot; or</a>
<a name="ln6802">   * &quot;:ball&quot;.</a>
<a name="ln6803">   */</a>
<a name="ln6804">  if (       (autocmd_no_enter</a>
<a name="ln6805">              &amp;&amp; (event == EVENT_WINENTER || event == EVENT_BUFENTER))</a>
<a name="ln6806">             || (autocmd_no_leave</a>
<a name="ln6807">                 &amp;&amp; (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))</a>
<a name="ln6808">    goto BYPASS_AU;</a>
<a name="ln6809"> </a>
<a name="ln6810">  /*</a>
<a name="ln6811">   * Save the autocmd_* variables and info about the current buffer.</a>
<a name="ln6812">   */</a>
<a name="ln6813">  save_autocmd_fname = autocmd_fname;</a>
<a name="ln6814">  save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln6815">  save_autocmd_match = autocmd_match;</a>
<a name="ln6816">  save_autocmd_busy = autocmd_busy;</a>
<a name="ln6817">  save_autocmd_nested = autocmd_nested;</a>
<a name="ln6818">  save_changed = curbuf-&gt;b_changed;</a>
<a name="ln6819">  old_curbuf = curbuf;</a>
<a name="ln6820"> </a>
<a name="ln6821">  /*</a>
<a name="ln6822">   * Set the file name to be used for &lt;afile&gt;.</a>
<a name="ln6823">   * Make a copy to avoid that changing a buffer name or directory makes it</a>
<a name="ln6824">   * invalid.</a>
<a name="ln6825">   */</a>
<a name="ln6826">  if (fname_io == NULL) {</a>
<a name="ln6827">    if (event == EVENT_COLORSCHEME</a>
<a name="ln6828">        || event == EVENT_COLORSCHEMEPRE</a>
<a name="ln6829">        || event == EVENT_OPTIONSET) {</a>
<a name="ln6830">      autocmd_fname = NULL;</a>
<a name="ln6831">    } else if (fname != NULL &amp;&amp; !ends_excmd(*fname)) {</a>
<a name="ln6832">      autocmd_fname = fname;</a>
<a name="ln6833">    } else if (buf != NULL) {</a>
<a name="ln6834">      autocmd_fname = buf-&gt;b_ffname;</a>
<a name="ln6835">    } else {</a>
<a name="ln6836">      autocmd_fname = NULL;</a>
<a name="ln6837">    }</a>
<a name="ln6838">  } else {</a>
<a name="ln6839">    autocmd_fname = fname_io;</a>
<a name="ln6840">  }</a>
<a name="ln6841">  if (autocmd_fname != NULL) {</a>
<a name="ln6842">    // Allocate MAXPATHL for when eval_vars() resolves the fullpath.</a>
<a name="ln6843">    autocmd_fname = vim_strnsave(autocmd_fname, MAXPATHL);</a>
<a name="ln6844">  }</a>
<a name="ln6845"> </a>
<a name="ln6846">  /*</a>
<a name="ln6847">   * Set the buffer number to be used for &lt;abuf&gt;.</a>
<a name="ln6848">   */</a>
<a name="ln6849">  if (buf == NULL)</a>
<a name="ln6850">    autocmd_bufnr = 0;</a>
<a name="ln6851">  else</a>
<a name="ln6852">    autocmd_bufnr = buf-&gt;b_fnum;</a>
<a name="ln6853"> </a>
<a name="ln6854">  /*</a>
<a name="ln6855">   * When the file name is NULL or empty, use the file name of buffer &quot;buf&quot;.</a>
<a name="ln6856">   * Always use the full path of the file name to match with, in case</a>
<a name="ln6857">   * &quot;allow_dirs&quot; is set.</a>
<a name="ln6858">   */</a>
<a name="ln6859">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln6860">    if (buf == NULL)</a>
<a name="ln6861">      fname = NULL;</a>
<a name="ln6862">    else {</a>
<a name="ln6863">      if (event == EVENT_SYNTAX)</a>
<a name="ln6864">        fname = buf-&gt;b_p_syn;</a>
<a name="ln6865">      else if (event == EVENT_FILETYPE)</a>
<a name="ln6866">        fname = buf-&gt;b_p_ft;</a>
<a name="ln6867">      else {</a>
<a name="ln6868">        if (buf-&gt;b_sfname != NULL)</a>
<a name="ln6869">          sfname = vim_strsave(buf-&gt;b_sfname);</a>
<a name="ln6870">        fname = buf-&gt;b_ffname;</a>
<a name="ln6871">      }</a>
<a name="ln6872">    }</a>
<a name="ln6873">    if (fname == NULL)</a>
<a name="ln6874">      fname = (char_u *)&quot;&quot;;</a>
<a name="ln6875">    fname = vim_strsave(fname);         /* make a copy, so we can change it */</a>
<a name="ln6876">  } else {</a>
<a name="ln6877">    sfname = vim_strsave(fname);</a>
<a name="ln6878">    // Don't try expanding the following events.</a>
<a name="ln6879">    if (event == EVENT_CMDLINECHANGED</a>
<a name="ln6880">        || event == EVENT_CMDLINEENTER</a>
<a name="ln6881">        || event == EVENT_CMDLINELEAVE</a>
<a name="ln6882">        || event == EVENT_CMDWINENTER</a>
<a name="ln6883">        || event == EVENT_CMDWINLEAVE</a>
<a name="ln6884">        || event == EVENT_CMDUNDEFINED</a>
<a name="ln6885">        || event == EVENT_COLORSCHEME</a>
<a name="ln6886">        || event == EVENT_COLORSCHEMEPRE</a>
<a name="ln6887">        || event == EVENT_DIRCHANGED</a>
<a name="ln6888">        || event == EVENT_FILETYPE</a>
<a name="ln6889">        || event == EVENT_FUNCUNDEFINED</a>
<a name="ln6890">        || event == EVENT_OPTIONSET</a>
<a name="ln6891">        || event == EVENT_QUICKFIXCMDPOST</a>
<a name="ln6892">        || event == EVENT_QUICKFIXCMDPRE</a>
<a name="ln6893">        || event == EVENT_REMOTEREPLY</a>
<a name="ln6894">        || event == EVENT_SPELLFILEMISSING</a>
<a name="ln6895">        || event == EVENT_SYNTAX</a>
<a name="ln6896">        || event == EVENT_SIGNAL</a>
<a name="ln6897">        || event == EVENT_TABCLOSED</a>
<a name="ln6898">        || event == EVENT_WINCLOSED) {</a>
<a name="ln6899">      fname = vim_strsave(fname);</a>
<a name="ln6900">    } else {</a>
<a name="ln6901">      fname = (char_u *)FullName_save((char *)fname, false);</a>
<a name="ln6902">    }</a>
<a name="ln6903">  }</a>
<a name="ln6904">  if (fname == NULL) {      /* out of memory */</a>
<a name="ln6905">    xfree(sfname);</a>
<a name="ln6906">    retval = false;</a>
<a name="ln6907">    goto BYPASS_AU;</a>
<a name="ln6908">  }</a>
<a name="ln6909"> </a>
<a name="ln6910">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6911">  // Replace all backslashes with forward slashes. This makes the</a>
<a name="ln6912">  // autocommand patterns portable between Unix and Windows.</a>
<a name="ln6913">  if (sfname != NULL) {</a>
<a name="ln6914">    forward_slash(sfname);</a>
<a name="ln6915">  }</a>
<a name="ln6916">  forward_slash(fname);</a>
<a name="ln6917">#endif</a>
<a name="ln6918"> </a>
<a name="ln6919"> </a>
<a name="ln6920">  /*</a>
<a name="ln6921">   * Set the name to be used for &lt;amatch&gt;.</a>
<a name="ln6922">   */</a>
<a name="ln6923">  autocmd_match = fname;</a>
<a name="ln6924"> </a>
<a name="ln6925"> </a>
<a name="ln6926">  // Don't redraw while doing autocommands.</a>
<a name="ln6927">  RedrawingDisabled++;</a>
<a name="ln6928">  save_sourcing_name = sourcing_name;</a>
<a name="ln6929">  sourcing_name = NULL;         /* don't free this one */</a>
<a name="ln6930">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln6931">  sourcing_lnum = 0;            /* no line number here */</a>
<a name="ln6932"> </a>
<a name="ln6933">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln6934"> </a>
<a name="ln6935">  if (do_profiling == PROF_YES)</a>
<a name="ln6936">    prof_child_enter(&amp;wait_time);     /* doesn't count for the caller itself */</a>
<a name="ln6937"> </a>
<a name="ln6938">  // Don't use local function variables, if called from a function.</a>
<a name="ln6939">  funccal_entry_T funccal_entry;</a>
<a name="ln6940">  save_funccal(&amp;funccal_entry);</a>
<a name="ln6941"> </a>
<a name="ln6942">  /*</a>
<a name="ln6943">   * When starting to execute autocommands, save the search patterns.</a>
<a name="ln6944">   */</a>
<a name="ln6945">  if (!autocmd_busy) {</a>
<a name="ln6946">    save_search_patterns();</a>
<a name="ln6947">    if (!ins_compl_active()) {</a>
<a name="ln6948">      saveRedobuff(&amp;save_redo);</a>
<a name="ln6949">      did_save_redobuff = true;</a>
<a name="ln6950">    }</a>
<a name="ln6951">    did_filetype = keep_filetype;</a>
<a name="ln6952">  }</a>
<a name="ln6953"> </a>
<a name="ln6954">  /*</a>
<a name="ln6955">   * Note that we are applying autocmds.  Some commands need to know.</a>
<a name="ln6956">   */</a>
<a name="ln6957">  autocmd_busy = TRUE;</a>
<a name="ln6958">  filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);</a>
<a name="ln6959">  ++nesting;            /* see matching decrement below */</a>
<a name="ln6960"> </a>
<a name="ln6961">  /* Remember that FileType was triggered.  Used for did_filetype(). */</a>
<a name="ln6962">  if (event == EVENT_FILETYPE)</a>
<a name="ln6963">    did_filetype = TRUE;</a>
<a name="ln6964"> </a>
<a name="ln6965">  tail = path_tail(fname);</a>
<a name="ln6966"> </a>
<a name="ln6967">  /* Find first autocommand that matches */</a>
<a name="ln6968">  patcmd.curpat = first_autopat[(int)event];</a>
<a name="ln6969">  patcmd.nextcmd = NULL;</a>
<a name="ln6970">  patcmd.group = group;</a>
<a name="ln6971">  patcmd.fname = fname;</a>
<a name="ln6972">  patcmd.sfname = sfname;</a>
<a name="ln6973">  patcmd.tail = tail;</a>
<a name="ln6974">  patcmd.event = event;</a>
<a name="ln6975">  patcmd.arg_bufnr = autocmd_bufnr;</a>
<a name="ln6976">  patcmd.next = NULL;</a>
<a name="ln6977">  auto_next_pat(&amp;patcmd, false);</a>
<a name="ln6978"> </a>
<a name="ln6979">  /* found one, start executing the autocommands */</a>
<a name="ln6980">  if (patcmd.curpat != NULL) {</a>
<a name="ln6981">    /* add to active_apc_list */</a>
<a name="ln6982">    patcmd.next = active_apc_list;</a>
<a name="ln6983">    active_apc_list = &amp;patcmd;</a>
<a name="ln6984"> </a>
<a name="ln6985">    // set v:cmdarg (only when there is a matching pattern)</a>
<a name="ln6986">    save_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);</a>
<a name="ln6987">    if (eap != NULL) {</a>
<a name="ln6988">      save_cmdarg = set_cmdarg(eap, NULL);</a>
<a name="ln6989">      set_vim_var_nr(VV_CMDBANG, (long)eap-&gt;forceit);</a>
<a name="ln6990">    } else {</a>
<a name="ln6991">      save_cmdarg = NULL;  // avoid gcc warning</a>
<a name="ln6992">    }</a>
<a name="ln6993">    retval = true;</a>
<a name="ln6994">    // mark the last pattern, to avoid an endless loop when more patterns</a>
<a name="ln6995">    // are added when executing autocommands</a>
<a name="ln6996">    for (ap = patcmd.curpat; ap-&gt;next != NULL; ap = ap-&gt;next) {</a>
<a name="ln6997">      ap-&gt;last = false;</a>
<a name="ln6998">    }</a>
<a name="ln6999">    ap-&gt;last = true;</a>
<a name="ln7000">    check_lnums(true);  // make sure cursor and topline are valid</a>
<a name="ln7001"> </a>
<a name="ln7002">    // Execute the autocmd. The `getnextac` callback handles iteration.</a>
<a name="ln7003">    do_cmdline(NULL, getnextac, (void *)&amp;patcmd,</a>
<a name="ln7004">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);</a>
<a name="ln7005"> </a>
<a name="ln7006">    reset_lnums();  // restore cursor and topline, unless they were changed</a>
<a name="ln7007"> </a>
<a name="ln7008">    if (eap != NULL) {</a>
<a name="ln7009">      (void)set_cmdarg(NULL, save_cmdarg);</a>
<a name="ln7010">      set_vim_var_nr(VV_CMDBANG, save_cmdbang);</a>
<a name="ln7011">    }</a>
<a name="ln7012">    /* delete from active_apc_list */</a>
<a name="ln7013">    if (active_apc_list == &amp;patcmd)         /* just in case */</a>
<a name="ln7014">      active_apc_list = patcmd.next;</a>
<a name="ln7015">  }</a>
<a name="ln7016"> </a>
<a name="ln7017">  --RedrawingDisabled;</a>
<a name="ln7018">  autocmd_busy = save_autocmd_busy;</a>
<a name="ln7019">  filechangeshell_busy = FALSE;</a>
<a name="ln7020">  autocmd_nested = save_autocmd_nested;</a>
<a name="ln7021">  xfree(sourcing_name);</a>
<a name="ln7022">  sourcing_name = save_sourcing_name;</a>
<a name="ln7023">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7024">  xfree(autocmd_fname);</a>
<a name="ln7025">  autocmd_fname = save_autocmd_fname;</a>
<a name="ln7026">  autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7027">  autocmd_match = save_autocmd_match;</a>
<a name="ln7028">  current_sctx = save_current_sctx;</a>
<a name="ln7029">  restore_funccal();</a>
<a name="ln7030">  if (do_profiling == PROF_YES) {</a>
<a name="ln7031">    prof_child_exit(&amp;wait_time);</a>
<a name="ln7032">  }</a>
<a name="ln7033">  KeyTyped = save_KeyTyped;</a>
<a name="ln7034">  xfree(fname);</a>
<a name="ln7035">  xfree(sfname);</a>
<a name="ln7036">  --nesting;            /* see matching increment above */</a>
<a name="ln7037"> </a>
<a name="ln7038">  // When stopping to execute autocommands, restore the search patterns and</a>
<a name="ln7039">  // the redo buffer. Free any buffers in the au_pending_free_buf list and</a>
<a name="ln7040">  // free any windows in the au_pending_free_win list.</a>
<a name="ln7041">  if (!autocmd_busy) {</a>
<a name="ln7042">    restore_search_patterns();</a>
<a name="ln7043">    if (did_save_redobuff) {</a>
<a name="ln7044">      restoreRedobuff(&amp;save_redo);</a>
<a name="ln7045">    }</a>
<a name="ln7046">    did_filetype = FALSE;</a>
<a name="ln7047">    while (au_pending_free_buf != NULL) {</a>
<a name="ln7048">      buf_T *b = au_pending_free_buf-&gt;b_next;</a>
<a name="ln7049">      xfree(au_pending_free_buf);</a>
<a name="ln7050">      au_pending_free_buf = b;</a>
<a name="ln7051">    }</a>
<a name="ln7052">    while (au_pending_free_win != NULL) {</a>
<a name="ln7053">      win_T *w = au_pending_free_win-&gt;w_next;</a>
<a name="ln7054">      xfree(au_pending_free_win);</a>
<a name="ln7055">      au_pending_free_win = w;</a>
<a name="ln7056">    }</a>
<a name="ln7057">  }</a>
<a name="ln7058"> </a>
<a name="ln7059">  /*</a>
<a name="ln7060">   * Some events don't set or reset the Changed flag.</a>
<a name="ln7061">   * Check if still in the same buffer!</a>
<a name="ln7062">   */</a>
<a name="ln7063">  if (curbuf == old_curbuf</a>
<a name="ln7064">      &amp;&amp; (event == EVENT_BUFREADPOST</a>
<a name="ln7065">          || event == EVENT_BUFWRITEPOST</a>
<a name="ln7066">          || event == EVENT_FILEAPPENDPOST</a>
<a name="ln7067">          || event == EVENT_VIMLEAVE</a>
<a name="ln7068">          || event == EVENT_VIMLEAVEPRE)) {</a>
<a name="ln7069">    if (curbuf-&gt;b_changed != save_changed)</a>
<a name="ln7070">      need_maketitle = TRUE;</a>
<a name="ln7071">    curbuf-&gt;b_changed = save_changed;</a>
<a name="ln7072">  }</a>
<a name="ln7073"> </a>
<a name="ln7074">  au_cleanup();         /* may really delete removed patterns/commands now */</a>
<a name="ln7075"> </a>
<a name="ln7076">BYPASS_AU:</a>
<a name="ln7077">  /* When wiping out a buffer make sure all its buffer-local autocommands</a>
<a name="ln7078">   * are deleted. */</a>
<a name="ln7079">  if (event == EVENT_BUFWIPEOUT &amp;&amp; buf != NULL)</a>
<a name="ln7080">    aubuflocal_remove(buf);</a>
<a name="ln7081"> </a>
<a name="ln7082">  if (retval == OK &amp;&amp; event == EVENT_FILETYPE) {</a>
<a name="ln7083">    au_did_filetype = true;</a>
<a name="ln7084">  }</a>
<a name="ln7085"> </a>
<a name="ln7086">  return retval;</a>
<a name="ln7087">}</a>
<a name="ln7088"> </a>
<a name="ln7089">static char_u   *old_termresponse = NULL;</a>
<a name="ln7090"> </a>
<a name="ln7091">/*</a>
<a name="ln7092"> * Block triggering autocommands until unblock_autocmd() is called.</a>
<a name="ln7093"> * Can be used recursively, so long as it's symmetric.</a>
<a name="ln7094"> */</a>
<a name="ln7095">void block_autocmds(void)</a>
<a name="ln7096">{</a>
<a name="ln7097">  /* Remember the value of v:termresponse. */</a>
<a name="ln7098">  if (autocmd_blocked == 0)</a>
<a name="ln7099">    old_termresponse = get_vim_var_str(VV_TERMRESPONSE);</a>
<a name="ln7100">  ++autocmd_blocked;</a>
<a name="ln7101">}</a>
<a name="ln7102"> </a>
<a name="ln7103">void unblock_autocmds(void)</a>
<a name="ln7104">{</a>
<a name="ln7105">  --autocmd_blocked;</a>
<a name="ln7106"> </a>
<a name="ln7107">  /* When v:termresponse was set while autocommands were blocked, trigger</a>
<a name="ln7108">   * the autocommands now.  Esp. useful when executing a shell command</a>
<a name="ln7109">   * during startup (nvim -d). */</a>
<a name="ln7110">  if (autocmd_blocked == 0</a>
<a name="ln7111">      &amp;&amp; get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)</a>
<a name="ln7112">    apply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln7113">}</a>
<a name="ln7114"> </a>
<a name="ln7115">// Find next autocommand pattern that matches.</a>
<a name="ln7116">static void</a>
<a name="ln7117">auto_next_pat(</a>
<a name="ln7118">    AutoPatCmd *apc,</a>
<a name="ln7119">    int stop_at_last                   /* stop when 'last' flag is set */</a>
<a name="ln7120">)</a>
<a name="ln7121">{</a>
<a name="ln7122">  AutoPat     *ap;</a>
<a name="ln7123">  AutoCmd     *cp;</a>
<a name="ln7124">  char        *s;</a>
<a name="ln7125"> </a>
<a name="ln7126">  XFREE_CLEAR(sourcing_name);</a>
<a name="ln7127"> </a>
<a name="ln7128">  for (ap = apc-&gt;curpat; ap != NULL &amp;&amp; !got_int; ap = ap-&gt;next) {</a>
<a name="ln7129">    apc-&gt;curpat = NULL;</a>
<a name="ln7130"> </a>
<a name="ln7131">    /* Only use a pattern when it has not been removed, has commands and</a>
<a name="ln7132">     * the group matches. For buffer-local autocommands only check the</a>
<a name="ln7133">     * buffer number. */</a>
<a name="ln7134">    if (ap-&gt;pat != NULL &amp;&amp; ap-&gt;cmds != NULL</a>
<a name="ln7135">        &amp;&amp; (apc-&gt;group == AUGROUP_ALL || apc-&gt;group == ap-&gt;group)) {</a>
<a name="ln7136">      /* execution-condition */</a>
<a name="ln7137">      if (ap-&gt;buflocal_nr == 0</a>
<a name="ln7138">          ? match_file_pat(NULL, &amp;ap-&gt;reg_prog, apc-&gt;fname, apc-&gt;sfname,</a>
<a name="ln7139">                           apc-&gt;tail, ap-&gt;allow_dirs)</a>
<a name="ln7140">          : ap-&gt;buflocal_nr == apc-&gt;arg_bufnr) {</a>
<a name="ln7141">        const char *const name = event_nr2name(apc-&gt;event);</a>
<a name="ln7142">        s = _(&quot;%s Autocommands for \&quot;%s\&quot;&quot;);</a>
<a name="ln7143">        const size_t sourcing_name_len = (STRLEN(s) + strlen(name) + ap-&gt;patlen</a>
<a name="ln7144">                                          + 1);</a>
<a name="ln7145">        sourcing_name = xmalloc(sourcing_name_len);</a>
<a name="ln7146">        snprintf((char *)sourcing_name, sourcing_name_len, s, name,</a>
<a name="ln7147">                 (char *)ap-&gt;pat);</a>
<a name="ln7148">        if (p_verbose &gt;= 8) {</a>
<a name="ln7149">          verbose_enter();</a>
<a name="ln7150">          smsg(_(&quot;Executing %s&quot;), sourcing_name);</a>
<a name="ln7151">          verbose_leave();</a>
<a name="ln7152">        }</a>
<a name="ln7153"> </a>
<a name="ln7154">        apc-&gt;curpat = ap;</a>
<a name="ln7155">        apc-&gt;nextcmd = ap-&gt;cmds;</a>
<a name="ln7156">        /* mark last command */</a>
<a name="ln7157">        for (cp = ap-&gt;cmds; cp-&gt;next != NULL; cp = cp-&gt;next)</a>
<a name="ln7158">          cp-&gt;last = FALSE;</a>
<a name="ln7159">        cp-&gt;last = TRUE;</a>
<a name="ln7160">      }</a>
<a name="ln7161">      line_breakcheck();</a>
<a name="ln7162">      if (apc-&gt;curpat != NULL)              /* found a match */</a>
<a name="ln7163">        break;</a>
<a name="ln7164">    }</a>
<a name="ln7165">    if (stop_at_last &amp;&amp; ap-&gt;last)</a>
<a name="ln7166">      break;</a>
<a name="ln7167">  }</a>
<a name="ln7168">}</a>
<a name="ln7169"> </a>
<a name="ln7170">/// Get next autocommand command.</a>
<a name="ln7171">/// Called by do_cmdline() to get the next line for &quot;:if&quot;.</a>
<a name="ln7172">/// @return allocated string, or NULL for end of autocommands.</a>
<a name="ln7173">char_u *getnextac(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln7174">{</a>
<a name="ln7175">  AutoPatCmd      *acp = (AutoPatCmd *)cookie;</a>
<a name="ln7176">  char_u          *retval;</a>
<a name="ln7177">  AutoCmd         *ac;</a>
<a name="ln7178"> </a>
<a name="ln7179">  /* Can be called again after returning the last line. */</a>
<a name="ln7180">  if (acp-&gt;curpat == NULL)</a>
<a name="ln7181">    return NULL;</a>
<a name="ln7182"> </a>
<a name="ln7183">  /* repeat until we find an autocommand to execute */</a>
<a name="ln7184">  for (;; ) {</a>
<a name="ln7185">    /* skip removed commands */</a>
<a name="ln7186">    while (acp-&gt;nextcmd != NULL &amp;&amp; acp-&gt;nextcmd-&gt;cmd == NULL)</a>
<a name="ln7187">      if (acp-&gt;nextcmd-&gt;last)</a>
<a name="ln7188">        acp-&gt;nextcmd = NULL;</a>
<a name="ln7189">      else</a>
<a name="ln7190">        acp-&gt;nextcmd = acp-&gt;nextcmd-&gt;next;</a>
<a name="ln7191"> </a>
<a name="ln7192">    if (acp-&gt;nextcmd != NULL)</a>
<a name="ln7193">      break;</a>
<a name="ln7194"> </a>
<a name="ln7195">    /* at end of commands, find next pattern that matches */</a>
<a name="ln7196">    if (acp-&gt;curpat-&gt;last)</a>
<a name="ln7197">      acp-&gt;curpat = NULL;</a>
<a name="ln7198">    else</a>
<a name="ln7199">      acp-&gt;curpat = acp-&gt;curpat-&gt;next;</a>
<a name="ln7200">    if (acp-&gt;curpat != NULL)</a>
<a name="ln7201">      auto_next_pat(acp, TRUE);</a>
<a name="ln7202">    if (acp-&gt;curpat == NULL)</a>
<a name="ln7203">      return NULL;</a>
<a name="ln7204">  }</a>
<a name="ln7205"> </a>
<a name="ln7206">  ac = acp-&gt;nextcmd;</a>
<a name="ln7207"> </a>
<a name="ln7208">  if (p_verbose &gt;= 9) {</a>
<a name="ln7209">    verbose_enter_scroll();</a>
<a name="ln7210">    smsg(_(&quot;autocommand %s&quot;), ac-&gt;cmd);</a>
<a name="ln7211">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln7212">    verbose_leave_scroll();</a>
<a name="ln7213">  }</a>
<a name="ln7214">  retval = vim_strsave(ac-&gt;cmd);</a>
<a name="ln7215">  // Remove one-shot (&quot;once&quot;) autocmd in anticipation of its execution.</a>
<a name="ln7216">  if (ac-&gt;once) {</a>
<a name="ln7217">    au_del_cmd(ac);</a>
<a name="ln7218">  }</a>
<a name="ln7219">  autocmd_nested = ac-&gt;nested;</a>
<a name="ln7220">  current_sctx = ac-&gt;script_ctx;</a>
<a name="ln7221">  if (ac-&gt;last) {</a>
<a name="ln7222">    acp-&gt;nextcmd = NULL;</a>
<a name="ln7223">  } else {</a>
<a name="ln7224">    acp-&gt;nextcmd = ac-&gt;next;</a>
<a name="ln7225">  }</a>
<a name="ln7226"> </a>
<a name="ln7227">  return retval;</a>
<a name="ln7228">}</a>
<a name="ln7229"> </a>
<a name="ln7230">/// Return true if there is a matching autocommand for &quot;fname&quot;.</a>
<a name="ln7231">/// To account for buffer-local autocommands, function needs to know</a>
<a name="ln7232">/// in which buffer the file will be opened.</a>
<a name="ln7233">///</a>
<a name="ln7234">/// @param event event that occurred.</a>
<a name="ln7235">/// @param sfname filename the event occurred in.</a>
<a name="ln7236">/// @param buf buffer the file is open in</a>
<a name="ln7237">bool has_autocmd(event_T event, char_u *sfname, buf_T *buf)</a>
<a name="ln7238">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7239">{</a>
<a name="ln7240">  AutoPat     *ap;</a>
<a name="ln7241">  char_u      *fname;</a>
<a name="ln7242">  char_u      *tail = path_tail(sfname);</a>
<a name="ln7243">  bool retval = false;</a>
<a name="ln7244"> </a>
<a name="ln7245">  fname = (char_u *)FullName_save((char *)sfname, false);</a>
<a name="ln7246">  if (fname == NULL) {</a>
<a name="ln7247">    return false;</a>
<a name="ln7248">  }</a>
<a name="ln7249"> </a>
<a name="ln7250">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7251">  // Replace all backslashes with forward slashes. This makes the</a>
<a name="ln7252">  // autocommand patterns portable between Unix and Windows.</a>
<a name="ln7253">  sfname = vim_strsave(sfname);</a>
<a name="ln7254">  forward_slash(sfname);</a>
<a name="ln7255">  forward_slash(fname);</a>
<a name="ln7256">#endif</a>
<a name="ln7257"> </a>
<a name="ln7258">  for (ap = first_autopat[(int)event]; ap != NULL; ap = ap-&gt;next) {</a>
<a name="ln7259">    if (ap-&gt;pat != NULL &amp;&amp; ap-&gt;cmds != NULL</a>
<a name="ln7260">        &amp;&amp; (ap-&gt;buflocal_nr == 0</a>
<a name="ln7261">            ? match_file_pat(NULL, &amp;ap-&gt;reg_prog, fname, sfname, tail,</a>
<a name="ln7262">                             ap-&gt;allow_dirs)</a>
<a name="ln7263">            : buf != NULL &amp;&amp; ap-&gt;buflocal_nr == buf-&gt;b_fnum)) {</a>
<a name="ln7264">      retval = true;</a>
<a name="ln7265">      break;</a>
<a name="ln7266">    }</a>
<a name="ln7267">  }</a>
<a name="ln7268"> </a>
<a name="ln7269">  xfree(fname);</a>
<a name="ln7270">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7271">  xfree(sfname);</a>
<a name="ln7272">#endif</a>
<a name="ln7273"> </a>
<a name="ln7274">  return retval;</a>
<a name="ln7275">}</a>
<a name="ln7276"> </a>
<a name="ln7277">/*</a>
<a name="ln7278"> * Function given to ExpandGeneric() to obtain the list of autocommand group</a>
<a name="ln7279"> * names.</a>
<a name="ln7280"> */</a>
<a name="ln7281">char_u *get_augroup_name(expand_T *xp, int idx)</a>
<a name="ln7282">{</a>
<a name="ln7283">  if (idx == augroups.ga_len) {  // add &quot;END&quot; add the end</a>
<a name="ln7284">    return (char_u *)&quot;END&quot;;</a>
<a name="ln7285">  }</a>
<a name="ln7286">  if (idx &gt;= augroups.ga_len) {  // end of list</a>
<a name="ln7287">    return NULL;</a>
<a name="ln7288">  }</a>
<a name="ln7289">  if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup()) {</a>
<a name="ln7290">    // skip deleted entries</a>
<a name="ln7291">    return (char_u *)&quot;&quot;;</a>
<a name="ln7292">  }</a>
<a name="ln7293">  return (char_u *)AUGROUP_NAME(idx);</a>
<a name="ln7294">}</a>
<a name="ln7295"> </a>
<a name="ln7296">static int include_groups = FALSE;</a>
<a name="ln7297"> </a>
<a name="ln7298">char_u *</a>
<a name="ln7299">set_context_in_autocmd (</a>
<a name="ln7300">    expand_T *xp,</a>
<a name="ln7301">    char_u *arg,</a>
<a name="ln7302">    int doautocmd                  /* TRUE for :doauto*, FALSE for :autocmd */</a>
<a name="ln7303">)</a>
<a name="ln7304">{</a>
<a name="ln7305">  char_u      *p;</a>
<a name="ln7306">  int group;</a>
<a name="ln7307"> </a>
<a name="ln7308">  /* check for a group name, skip it if present */</a>
<a name="ln7309">  include_groups = FALSE;</a>
<a name="ln7310">  p = arg;</a>
<a name="ln7311">  group = au_get_grouparg(&amp;arg);</a>
<a name="ln7312"> </a>
<a name="ln7313">  /* If there only is a group name that's what we expand. */</a>
<a name="ln7314">  if (*arg == NUL &amp;&amp; group != AUGROUP_ALL &amp;&amp; !ascii_iswhite(arg[-1])) {</a>
<a name="ln7315">    arg = p;</a>
<a name="ln7316">    group = AUGROUP_ALL;</a>
<a name="ln7317">  }</a>
<a name="ln7318"> </a>
<a name="ln7319">  /* skip over event name */</a>
<a name="ln7320">  for (p = arg; *p != NUL &amp;&amp; !ascii_iswhite(*p); ++p)</a>
<a name="ln7321">    if (*p == ',')</a>
<a name="ln7322">      arg = p + 1;</a>
<a name="ln7323">  if (*p == NUL) {</a>
<a name="ln7324">    if (group == AUGROUP_ALL)</a>
<a name="ln7325">      include_groups = TRUE;</a>
<a name="ln7326">    xp-&gt;xp_context = EXPAND_EVENTS;         /* expand event name */</a>
<a name="ln7327">    xp-&gt;xp_pattern = arg;</a>
<a name="ln7328">    return NULL;</a>
<a name="ln7329">  }</a>
<a name="ln7330"> </a>
<a name="ln7331">  /* skip over pattern */</a>
<a name="ln7332">  arg = skipwhite(p);</a>
<a name="ln7333">  while (*arg &amp;&amp; (!ascii_iswhite(*arg) || arg[-1] == '\\'))</a>
<a name="ln7334">    arg++;</a>
<a name="ln7335">  if (*arg)</a>
<a name="ln7336">    return arg;                             /* expand (next) command */</a>
<a name="ln7337"> </a>
<a name="ln7338">  if (doautocmd)</a>
<a name="ln7339">    xp-&gt;xp_context = EXPAND_FILES;          /* expand file names */</a>
<a name="ln7340">  else</a>
<a name="ln7341">    xp-&gt;xp_context = EXPAND_NOTHING;        /* pattern is not expanded */</a>
<a name="ln7342">  return NULL;</a>
<a name="ln7343">}</a>
<a name="ln7344"> </a>
<a name="ln7345">/*</a>
<a name="ln7346"> * Function given to ExpandGeneric() to obtain the list of event names.</a>
<a name="ln7347"> */</a>
<a name="ln7348">char_u *get_event_name(expand_T *xp, int idx)</a>
<a name="ln7349">{</a>
<a name="ln7350">  if (idx &lt; augroups.ga_len) {          // First list group names, if wanted</a>
<a name="ln7351">    if (!include_groups || AUGROUP_NAME(idx) == NULL</a>
<a name="ln7352">        || AUGROUP_NAME(idx) == get_deleted_augroup()) {</a>
<a name="ln7353">      return (char_u *)&quot;&quot;;              // skip deleted entries</a>
<a name="ln7354">    }</a>
<a name="ln7355">    return (char_u *)AUGROUP_NAME(idx);</a>
<a name="ln7356">  }</a>
<a name="ln7357">  return (char_u *)event_names[idx - augroups.ga_len].name;</a>
<a name="ln7358">}</a>
<a name="ln7359"> </a>
<a name="ln7360"> </a>
<a name="ln7361">/// Check whether given autocommand is supported</a>
<a name="ln7362">///</a>
<a name="ln7363">/// @param[in]  event  Event to check.</a>
<a name="ln7364">///</a>
<a name="ln7365">/// @return True if it is, false otherwise.</a>
<a name="ln7366">bool autocmd_supported(const char *const event)</a>
<a name="ln7367">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7368">{</a>
<a name="ln7369">  char_u *p;</a>
<a name="ln7370">  return event_name2nr((const char_u *)event, &amp;p) != NUM_EVENTS;</a>
<a name="ln7371">}</a>
<a name="ln7372"> </a>
<a name="ln7373">/// Return true if an autocommand is defined for a group, event and</a>
<a name="ln7374">/// pattern:  The group can be omitted to accept any group.</a>
<a name="ln7375">/// `event` and `pattern` can be omitted to accept any event and pattern.</a>
<a name="ln7376">/// Buffer-local patterns &lt;buffer&gt; or &lt;buffer=N&gt; are accepted.</a>
<a name="ln7377">/// Used for:</a>
<a name="ln7378">///   exists(&quot;#Group&quot;) or</a>
<a name="ln7379">///   exists(&quot;#Group#Event&quot;) or</a>
<a name="ln7380">///   exists(&quot;#Group#Event#pat&quot;) or</a>
<a name="ln7381">///   exists(&quot;#Event&quot;) or</a>
<a name="ln7382">///   exists(&quot;#Event#pat&quot;)</a>
<a name="ln7383">///</a>
<a name="ln7384">/// @param arg autocommand string</a>
<a name="ln7385">bool au_exists(const char *const arg) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7386">{</a>
<a name="ln7387">  event_T event;</a>
<a name="ln7388">  AutoPat     *ap;</a>
<a name="ln7389">  buf_T       *buflocal_buf = NULL;</a>
<a name="ln7390">  int group;</a>
<a name="ln7391">  bool retval = false;</a>
<a name="ln7392"> </a>
<a name="ln7393">  // Make a copy so that we can change the '#' chars to a NUL.</a>
<a name="ln7394">  char *const arg_save = xstrdup(arg);</a>
<a name="ln7395">  char *p = strchr(arg_save, '#');</a>
<a name="ln7396">  if (p != NULL) {</a>
<a name="ln7397">    *p++ = NUL;</a>
<a name="ln7398">  }</a>
<a name="ln7399"> </a>
<a name="ln7400">  // First, look for an autocmd group name.</a>
<a name="ln7401">  group = au_find_group((char_u *)arg_save);</a>
<a name="ln7402">  char *event_name;</a>
<a name="ln7403">  if (group == AUGROUP_ERROR) {</a>
<a name="ln7404">    /* Didn't match a group name, assume the first argument is an event. */</a>
<a name="ln7405">    group = AUGROUP_ALL;</a>
<a name="ln7406">    event_name = arg_save;</a>
<a name="ln7407">  } else {</a>
<a name="ln7408">    if (p == NULL) {</a>
<a name="ln7409">      // &quot;Group&quot;: group name is present and it's recognized</a>
<a name="ln7410">      retval = true;</a>
<a name="ln7411">      goto theend;</a>
<a name="ln7412">    }</a>
<a name="ln7413"> </a>
<a name="ln7414">    // Must be &quot;Group#Event&quot; or &quot;Group#Event#pat&quot;.</a>
<a name="ln7415">    event_name = p;</a>
<a name="ln7416">    p = strchr(event_name, '#');</a>
<a name="ln7417">    if (p != NULL) {</a>
<a name="ln7418">      *p++ = NUL;  // &quot;Group#Event#pat&quot;</a>
<a name="ln7419">    }</a>
<a name="ln7420">  }</a>
<a name="ln7421"> </a>
<a name="ln7422">  char *pattern = p;  // &quot;pattern&quot; is NULL when there is no pattern.</a>
<a name="ln7423"> </a>
<a name="ln7424">  // Find the index (enum) for the event name.</a>
<a name="ln7425">  event = event_name2nr((char_u *)event_name, (char_u **)&amp;p);</a>
<a name="ln7426"> </a>
<a name="ln7427">  /* return FALSE if the event name is not recognized */</a>
<a name="ln7428">  if (event == NUM_EVENTS)</a>
<a name="ln7429">    goto theend;</a>
<a name="ln7430"> </a>
<a name="ln7431">  /* Find the first autocommand for this event.</a>
<a name="ln7432">   * If there isn't any, return FALSE;</a>
<a name="ln7433">   * If there is one and no pattern given, return TRUE; */</a>
<a name="ln7434">  ap = first_autopat[(int)event];</a>
<a name="ln7435">  if (ap == NULL)</a>
<a name="ln7436">    goto theend;</a>
<a name="ln7437"> </a>
<a name="ln7438">  /* if pattern is &quot;&lt;buffer&gt;&quot;, special handling is needed which uses curbuf */</a>
<a name="ln7439">  /* for pattern &quot;&lt;buffer=N&gt;, fnamecmp() will work fine */</a>
<a name="ln7440">  if (pattern != NULL &amp;&amp; STRICMP(pattern, &quot;&lt;buffer&gt;&quot;) == 0)</a>
<a name="ln7441">    buflocal_buf = curbuf;</a>
<a name="ln7442"> </a>
<a name="ln7443">  /* Check if there is an autocommand with the given pattern. */</a>
<a name="ln7444">  for (; ap != NULL; ap = ap-&gt;next)</a>
<a name="ln7445">    /* only use a pattern when it has not been removed and has commands. */</a>
<a name="ln7446">    /* For buffer-local autocommands, fnamecmp() works fine. */</a>
<a name="ln7447">    if (ap-&gt;pat != NULL &amp;&amp; ap-&gt;cmds != NULL</a>
<a name="ln7448">        &amp;&amp; (group == AUGROUP_ALL || ap-&gt;group == group)</a>
<a name="ln7449">        &amp;&amp; (pattern == NULL</a>
<a name="ln7450">            || (buflocal_buf == NULL</a>
<a name="ln7451">                ? fnamecmp(ap-&gt;pat, (char_u *)pattern) == 0</a>
<a name="ln7452">                : ap-&gt;buflocal_nr == buflocal_buf-&gt;b_fnum))) {</a>
<a name="ln7453">      retval = true;</a>
<a name="ln7454">      break;</a>
<a name="ln7455">    }</a>
<a name="ln7456"> </a>
<a name="ln7457">theend:</a>
<a name="ln7458">  xfree(arg_save);</a>
<a name="ln7459">  return retval;</a>
<a name="ln7460">}</a>
<a name="ln7461"> </a>
<a name="ln7462">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln7463">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln7464">/// vim_regcomp() often.</a>
<a name="ln7465">///</a>
<a name="ln7466">/// Used for autocommands and 'wildignore'.</a>
<a name="ln7467">///</a>
<a name="ln7468">/// @param pattern pattern to match with</a>
<a name="ln7469">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln7470">/// @param fname full path of the file name</a>
<a name="ln7471">/// @param sfname short file name or NULL</a>
<a name="ln7472">/// @param tail tail of the path</a>
<a name="ln7473">/// @param allow_dirs Allow matching with dir</a>
<a name="ln7474">///</a>
<a name="ln7475">/// @return true if there is a match, false otherwise</a>
<a name="ln7476">static bool match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname,</a>
<a name="ln7477">                           char_u *sfname, char_u *tail, int allow_dirs)</a>
<a name="ln7478">{</a>
<a name="ln7479">  regmatch_T regmatch;</a>
<a name="ln7480">  bool result = false;</a>
<a name="ln7481"> </a>
<a name="ln7482">  regmatch.rm_ic = p_fic;   /* ignore case if 'fileignorecase' is set */</a>
<a name="ln7483">  {</a>
<a name="ln7484">    if (prog != NULL)</a>
<a name="ln7485">      regmatch.regprog = *prog;</a>
<a name="ln7486">    else</a>
<a name="ln7487">      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln7488">  }</a>
<a name="ln7489"> </a>
<a name="ln7490">  /*</a>
<a name="ln7491">   * Try for a match with the pattern with:</a>
<a name="ln7492">   * 1. the full file name, when the pattern has a '/'.</a>
<a name="ln7493">   * 2. the short file name, when the pattern has a '/'.</a>
<a name="ln7494">   * 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln7495">   */</a>
<a name="ln7496">  if (regmatch.regprog != NULL</a>
<a name="ln7497">      &amp;&amp; ((allow_dirs</a>
<a name="ln7498">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln7499">               || (sfname != NULL</a>
<a name="ln7500">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln7501">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln7502">    result = true;</a>
<a name="ln7503">  }</a>
<a name="ln7504"> </a>
<a name="ln7505">  if (prog != NULL) {</a>
<a name="ln7506">    *prog = regmatch.regprog;</a>
<a name="ln7507">  } else {</a>
<a name="ln7508">    vim_regfree(regmatch.regprog);</a>
<a name="ln7509">  }</a>
<a name="ln7510">  return result;</a>
<a name="ln7511">}</a>
<a name="ln7512"> </a>
<a name="ln7513">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln7514">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln7515">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln7516">///</a>
<a name="ln7517">/// @param list list of patterns to match</a>
<a name="ln7518">/// @param sfname short file name</a>
<a name="ln7519">/// @param ffname full file name</a>
<a name="ln7520">///</a>
<a name="ln7521">/// @return true if there was a match</a>
<a name="ln7522">bool match_file_list(char_u *list, char_u *sfname, char_u *ffname)</a>
<a name="ln7523">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln7524">{</a>
<a name="ln7525">  char_u buf[100];</a>
<a name="ln7526">  char_u      *tail;</a>
<a name="ln7527">  char_u      *regpat;</a>
<a name="ln7528">  char allow_dirs;</a>
<a name="ln7529">  bool match;</a>
<a name="ln7530">  char_u      *p;</a>
<a name="ln7531"> </a>
<a name="ln7532">  tail = path_tail(sfname);</a>
<a name="ln7533"> </a>
<a name="ln7534">  // try all patterns in 'wildignore'</a>
<a name="ln7535">  p = list;</a>
<a name="ln7536">  while (*p) {</a>
<a name="ln7537">    copy_option_part(&amp;p, buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln7538">    regpat = file_pat_to_reg_pat(buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln7539">    if (regpat == NULL) {</a>
<a name="ln7540">      break;</a>
<a name="ln7541">    }</a>
<a name="ln7542">    match = match_file_pat(regpat, NULL, ffname, sfname, tail, (int)allow_dirs);</a>
<a name="ln7543">    xfree(regpat);</a>
<a name="ln7544">    if (match) {</a>
<a name="ln7545">      return true;</a>
<a name="ln7546">    }</a>
<a name="ln7547">  }</a>
<a name="ln7548">  return false;</a>
<a name="ln7549">}</a>
<a name="ln7550"> </a>
<a name="ln7551">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln7552">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln7553">/// is a directory path separator to be matched, then TRUE is put in</a>
<a name="ln7554">/// allow_dirs, otherwise FALSE is put there -- webb.</a>
<a name="ln7555">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln7556">///</a>
<a name="ln7557">/// Returns NULL on failure.</a>
<a name="ln7558">char_u * file_pat_to_reg_pat(</a>
<a name="ln7559">    const char_u *pat,</a>
<a name="ln7560">    const char_u *pat_end,   // first char after pattern or NULL</a>
<a name="ln7561">    char *allow_dirs,        // Result passed back out in here</a>
<a name="ln7562">    int no_bslash            // Don't use a backward slash as pathsep</a>
<a name="ln7563">)</a>
<a name="ln7564">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln7565">{</a>
<a name="ln7566">  const char_u *endp;</a>
<a name="ln7567">  char_u      *reg_pat;</a>
<a name="ln7568">  const char_u *p;</a>
<a name="ln7569">  int nested = 0;</a>
<a name="ln7570">  int add_dollar = TRUE;</a>
<a name="ln7571"> </a>
<a name="ln7572">  if (allow_dirs != NULL)</a>
<a name="ln7573">    *allow_dirs = FALSE;</a>
<a name="ln7574">  if (pat_end == NULL)</a>
<a name="ln7575">    pat_end = pat + STRLEN(pat);</a>
<a name="ln7576"> </a>
<a name="ln7577">  if (pat_end == pat) {</a>
<a name="ln7578">    return (char_u *)xstrdup(&quot;^$&quot;);</a>
<a name="ln7579">  }</a>
<a name="ln7580"> </a>
<a name="ln7581">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln7582"> </a>
<a name="ln7583">  for (p = pat; p &lt; pat_end; p++) {</a>
<a name="ln7584">    switch (*p) {</a>
<a name="ln7585">    case '*':</a>
<a name="ln7586">    case '.':</a>
<a name="ln7587">    case ',':</a>
<a name="ln7588">    case '{':</a>
<a name="ln7589">    case '}':</a>
<a name="ln7590">    case '~':</a>
<a name="ln7591">      size += 2;                /* extra backslash */</a>
<a name="ln7592">      break;</a>
<a name="ln7593">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7594">    case '\\':</a>
<a name="ln7595">    case '/':</a>
<a name="ln7596">      size += 4;                /* could become &quot;[\/]&quot; */</a>
<a name="ln7597">      break;</a>
<a name="ln7598">#endif</a>
<a name="ln7599">    default:</a>
<a name="ln7600">      size++;</a>
<a name="ln7601">      break;</a>
<a name="ln7602">    }</a>
<a name="ln7603">  }</a>
<a name="ln7604">  reg_pat = xmalloc(size + 1);</a>
<a name="ln7605"> </a>
<a name="ln7606">  size_t i = 0;</a>
<a name="ln7607"> </a>
<a name="ln7608">  if (pat[0] == '*')</a>
<a name="ln7609">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1)</a>
<a name="ln7610">      pat++;</a>
<a name="ln7611">  else</a>
<a name="ln7612">    reg_pat[i++] = '^';</a>
<a name="ln7613">  endp = pat_end - 1;</a>
<a name="ln7614">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln7615">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln7616">      endp--;</a>
<a name="ln7617">    }</a>
<a name="ln7618">    add_dollar = false;</a>
<a name="ln7619">  }</a>
<a name="ln7620">  for (p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln7621">    switch (*p) {</a>
<a name="ln7622">    case '*':</a>
<a name="ln7623">      reg_pat[i++] = '.';</a>
<a name="ln7624">      reg_pat[i++] = '*';</a>
<a name="ln7625">      while (p[1] == '*')               /* &quot;**&quot; matches like &quot;*&quot; */</a>
<a name="ln7626">        ++p;</a>
<a name="ln7627">      break;</a>
<a name="ln7628">    case '.':</a>
<a name="ln7629">    case '~':</a>
<a name="ln7630">      reg_pat[i++] = '\\';</a>
<a name="ln7631">      reg_pat[i++] = *p;</a>
<a name="ln7632">      break;</a>
<a name="ln7633">    case '?':</a>
<a name="ln7634">      reg_pat[i++] = '.';</a>
<a name="ln7635">      break;</a>
<a name="ln7636">    case '\\':</a>
<a name="ln7637">      if (p[1] == NUL)</a>
<a name="ln7638">        break;</a>
<a name="ln7639">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7640">      if (!no_bslash) {</a>
<a name="ln7641">        /* translate:</a>
<a name="ln7642">         * &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln7643">         * &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln7644">         * &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln7645">         * &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln7646">         */</a>
<a name="ln7647">        if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln7648">            &amp;&amp; p[1] != '+') {</a>
<a name="ln7649">          reg_pat[i++] = '[';</a>
<a name="ln7650">          reg_pat[i++] = '\\';</a>
<a name="ln7651">          reg_pat[i++] = '/';</a>
<a name="ln7652">          reg_pat[i++] = ']';</a>
<a name="ln7653">          if (allow_dirs != NULL)</a>
<a name="ln7654">            *allow_dirs = TRUE;</a>
<a name="ln7655">          break;</a>
<a name="ln7656">        }</a>
<a name="ln7657">      }</a>
<a name="ln7658">#endif</a>
<a name="ln7659">      /* Undo escaping from ExpandEscape():</a>
<a name="ln7660">       * foo\?bar -&gt; foo?bar</a>
<a name="ln7661">       * foo\%bar -&gt; foo%bar</a>
<a name="ln7662">       * foo\,bar -&gt; foo,bar</a>
<a name="ln7663">       * foo\ bar -&gt; foo bar</a>
<a name="ln7664">       * Don't unescape \, * and others that are also special in a</a>
<a name="ln7665">       * regexp.</a>
<a name="ln7666">       * An escaped { must be unescaped since we use magic not</a>
<a name="ln7667">       * verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln7668">       */</a>
<a name="ln7669">      if (*++p == '?'</a>
<a name="ln7670">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7671">          &amp;&amp; no_bslash</a>
<a name="ln7672">#endif</a>
<a name="ln7673">          ) {</a>
<a name="ln7674">        reg_pat[i++] = '?';</a>
<a name="ln7675">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln7676">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln7677">        reg_pat[i++] = *p;</a>
<a name="ln7678">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln7679">        reg_pat[i++] = '\\';</a>
<a name="ln7680">        reg_pat[i++] = '{';</a>
<a name="ln7681">        p += 2;</a>
<a name="ln7682">      } else {</a>
<a name="ln7683">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln7684">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7685">            &amp;&amp; (!no_bslash || *p != '\\')</a>
<a name="ln7686">#endif</a>
<a name="ln7687">            )</a>
<a name="ln7688">          *allow_dirs = TRUE;</a>
<a name="ln7689">        reg_pat[i++] = '\\';</a>
<a name="ln7690">        reg_pat[i++] = *p;</a>
<a name="ln7691">      }</a>
<a name="ln7692">      break;</a>
<a name="ln7693">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln7694">    case '/':</a>
<a name="ln7695">      reg_pat[i++] = '[';</a>
<a name="ln7696">      reg_pat[i++] = '\\';</a>
<a name="ln7697">      reg_pat[i++] = '/';</a>
<a name="ln7698">      reg_pat[i++] = ']';</a>
<a name="ln7699">      if (allow_dirs != NULL)</a>
<a name="ln7700">        *allow_dirs = TRUE;</a>
<a name="ln7701">      break;</a>
<a name="ln7702">#endif</a>
<a name="ln7703">    case '{':</a>
<a name="ln7704">      reg_pat[i++] = '\\';</a>
<a name="ln7705">      reg_pat[i++] = '(';</a>
<a name="ln7706">      nested++;</a>
<a name="ln7707">      break;</a>
<a name="ln7708">    case '}':</a>
<a name="ln7709">      reg_pat[i++] = '\\';</a>
<a name="ln7710">      reg_pat[i++] = ')';</a>
<a name="ln7711">      --nested;</a>
<a name="ln7712">      break;</a>
<a name="ln7713">    case ',':</a>
<a name="ln7714">      if (nested) {</a>
<a name="ln7715">        reg_pat[i++] = '\\';</a>
<a name="ln7716">        reg_pat[i++] = '|';</a>
<a name="ln7717">      } else</a>
<a name="ln7718">        reg_pat[i++] = ',';</a>
<a name="ln7719">      break;</a>
<a name="ln7720">    default:</a>
<a name="ln7721">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln7722">        *allow_dirs = true;</a>
<a name="ln7723">      }</a>
<a name="ln7724">      reg_pat[i++] = *p;</a>
<a name="ln7725">      break;</a>
<a name="ln7726">    }</a>
<a name="ln7727">  }</a>
<a name="ln7728">  if (add_dollar)</a>
<a name="ln7729">    reg_pat[i++] = '$';</a>
<a name="ln7730">  reg_pat[i] = NUL;</a>
<a name="ln7731">  if (nested != 0) {</a>
<a name="ln7732">    if (nested &lt; 0) {</a>
<a name="ln7733">      EMSG(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln7734">    } else {</a>
<a name="ln7735">      EMSG(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln7736">    }</a>
<a name="ln7737">    XFREE_CLEAR(reg_pat);</a>
<a name="ln7738">  }</a>
<a name="ln7739">  return reg_pat;</a>
<a name="ln7740">}</a>
<a name="ln7741"> </a>
<a name="ln7742">#if defined(EINTR)</a>
<a name="ln7743">/*</a>
<a name="ln7744"> * Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln7745"> * by a SIGWINCH).</a>
<a name="ln7746"> */</a>
<a name="ln7747">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln7748">{</a>
<a name="ln7749">  long ret;</a>
<a name="ln7750"> </a>
<a name="ln7751">  for (;; ) {</a>
<a name="ln7752">    ret = read(fd, buf, bufsize);</a>
<a name="ln7753">    if (ret &gt;= 0 || errno != EINTR)</a>
<a name="ln7754">      break;</a>
<a name="ln7755">  }</a>
<a name="ln7756">  return ret;</a>
<a name="ln7757">}</a>
<a name="ln7758"> </a>
<a name="ln7759">/*</a>
<a name="ln7760"> * Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln7761"> * by a SIGWINCH).</a>
<a name="ln7762"> */</a>
<a name="ln7763">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln7764">{</a>
<a name="ln7765">  long ret = 0;</a>
<a name="ln7766">  long wlen;</a>
<a name="ln7767"> </a>
<a name="ln7768">  /* Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln7769">   * by a signal. */</a>
<a name="ln7770">  while (ret &lt; (long)bufsize) {</a>
<a name="ln7771">    wlen = write(fd, (char *)buf + ret, bufsize - ret);</a>
<a name="ln7772">    if (wlen &lt; 0) {</a>
<a name="ln7773">      if (errno != EINTR)</a>
<a name="ln7774">        break;</a>
<a name="ln7775">    } else</a>
<a name="ln7776">      ret += wlen;</a>
<a name="ln7777">  }</a>
<a name="ln7778">  return ret;</a>
<a name="ln7779">}</a>
<a name="ln7780">#endif</a>

</code></pre>
<div class="balloon" rel="4599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="7537"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fold.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// vim: set fdm=marker fdl=1 fdc=3</a>
<a name="ln5"> </a>
<a name="ln6">/*</a>
<a name="ln7"> * fold.c: code for folding</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;nvim/vim.h&quot;</a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/fold.h&quot;</a>
<a name="ln16">#include &quot;nvim/change.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln19">#include &quot;nvim/diff.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval.h&quot;</a>
<a name="ln21">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln23">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln24">#include &quot;nvim/indent.h&quot;</a>
<a name="ln25">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln26">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln27">#include &quot;nvim/mark.h&quot;</a>
<a name="ln28">#include &quot;nvim/memline.h&quot;</a>
<a name="ln29">#include &quot;nvim/memory.h&quot;</a>
<a name="ln30">#include &quot;nvim/message.h&quot;</a>
<a name="ln31">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln32">#include &quot;nvim/garray.h&quot;</a>
<a name="ln33">#include &quot;nvim/move.h&quot;</a>
<a name="ln34">#include &quot;nvim/option.h&quot;</a>
<a name="ln35">#include &quot;nvim/screen.h&quot;</a>
<a name="ln36">#include &quot;nvim/strings.h&quot;</a>
<a name="ln37">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln38">#include &quot;nvim/undo.h&quot;</a>
<a name="ln39">#include &quot;nvim/ops.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">/* local declarations. {{{1 */</a>
<a name="ln42">/* typedef fold_T {{{2 */</a>
<a name="ln43">/*</a>
<a name="ln44"> * The toplevel folds for each window are stored in the w_folds growarray.</a>
<a name="ln45"> * Each toplevel fold can contain an array of second level folds in the</a>
<a name="ln46"> * fd_nested growarray.</a>
<a name="ln47"> * The info stored in both growarrays is the same: An array of fold_T.</a>
<a name="ln48"> */</a>
<a name="ln49">typedef struct {</a>
<a name="ln50">  linenr_T fd_top;              // first line of fold; for nested fold</a>
<a name="ln51">                                // relative to parent</a>
<a name="ln52">  linenr_T fd_len;              // number of lines in the fold</a>
<a name="ln53">  garray_T fd_nested;           // array of nested folds</a>
<a name="ln54">  char fd_flags;                // see below</a>
<a name="ln55">  TriState fd_small;            // kTrue, kFalse, or kNone: fold smaller than</a>
<a name="ln56">                                // 'foldminlines'; kNone applies to nested</a>
<a name="ln57">                                // folds too</a>
<a name="ln58">} fold_T;</a>
<a name="ln59"> </a>
<a name="ln60">#define FD_OPEN         0       /* fold is open (nested ones can be closed) */</a>
<a name="ln61">#define FD_CLOSED       1       /* fold is closed */</a>
<a name="ln62">#define FD_LEVEL        2       /* depends on 'foldlevel' (nested folds too) */</a>
<a name="ln63"> </a>
<a name="ln64">#define MAX_LEVEL       20      /* maximum fold depth */</a>
<a name="ln65"> </a>
<a name="ln66">/* Define &quot;fline_T&quot;, passed to get fold level for a line. {{{2 */</a>
<a name="ln67">typedef struct {</a>
<a name="ln68">  win_T       *wp;              /* window */</a>
<a name="ln69">  linenr_T lnum;                /* current line number */</a>
<a name="ln70">  linenr_T off;                 /* offset between lnum and real line number */</a>
<a name="ln71">  linenr_T lnum_save;           /* line nr used by foldUpdateIEMSRecurse() */</a>
<a name="ln72">  int lvl;                      /* current level (-1 for undefined) */</a>
<a name="ln73">  int lvl_next;                 /* level used for next line */</a>
<a name="ln74">  int start;                    /* number of folds that are forced to start at</a>
<a name="ln75">                                   this line. */</a>
<a name="ln76">  int end;                      /* level of fold that is forced to end below</a>
<a name="ln77">                                   this line */</a>
<a name="ln78">  int had_end;                  /* level of fold that is forced to end above</a>
<a name="ln79">                                   this line (copy of &quot;end&quot; of prev. line) */</a>
<a name="ln80">} fline_T;</a>
<a name="ln81"> </a>
<a name="ln82">// Flag is set when redrawing is needed.</a>
<a name="ln83">static bool fold_changed;</a>
<a name="ln84"> </a>
<a name="ln85">/* Function used by foldUpdateIEMSRecurse */</a>
<a name="ln86">typedef void (*LevelGetter)(fline_T *);</a>
<a name="ln87"> </a>
<a name="ln88">/* static functions {{{2 */</a>
<a name="ln89"> </a>
<a name="ln90">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln91"># include &quot;fold.c.generated.h&quot;</a>
<a name="ln92">#endif</a>
<a name="ln93">static char *e_nofold = N_(&quot;E490: No fold found&quot;);</a>
<a name="ln94"> </a>
<a name="ln95">/*</a>
<a name="ln96"> * While updating the folds lines between invalid_top and invalid_bot have an</a>
<a name="ln97"> * undefined fold level.  Only used for the window currently being updated.</a>
<a name="ln98"> */</a>
<a name="ln99">static linenr_T invalid_top = (linenr_T)0;</a>
<a name="ln100">static linenr_T invalid_bot = (linenr_T)0;</a>
<a name="ln101"> </a>
<a name="ln102">/*</a>
<a name="ln103"> * When using 'foldexpr' we sometimes get the level of the next line, which</a>
<a name="ln104"> * calls foldlevel() to get the level of the current line, which hasn't been</a>
<a name="ln105"> * stored yet.  To get around this chicken-egg problem the level of the</a>
<a name="ln106"> * previous line is stored here when available.  prev_lnum is zero when the</a>
<a name="ln107"> * level is not available.</a>
<a name="ln108"> */</a>
<a name="ln109">static linenr_T prev_lnum = 0;</a>
<a name="ln110">static int prev_lnum_lvl = -1;</a>
<a name="ln111"> </a>
<a name="ln112">/* Flags used for &quot;done&quot; argument of setManualFold. */</a>
<a name="ln113">#define DONE_NOTHING    0</a>
<a name="ln114">#define DONE_ACTION     1       /* did close or open a fold */</a>
<a name="ln115">#define DONE_FOLD       2       /* did find a fold */</a>
<a name="ln116"> </a>
<a name="ln117">static size_t foldstartmarkerlen;</a>
<a name="ln118">static char_u *foldendmarker;</a>
<a name="ln119">static size_t foldendmarkerlen;</a>
<a name="ln120"> </a>
<a name="ln121">/* Exported folding functions. {{{1 */</a>
<a name="ln122">/* copyFoldingState() {{{2 */</a>
<a name="ln123">/*</a>
<a name="ln124"> * Copy that folding state from window &quot;wp_from&quot; to window &quot;wp_to&quot;.</a>
<a name="ln125"> */</a>
<a name="ln126">void copyFoldingState(win_T *wp_from, win_T *wp_to)</a>
<a name="ln127">{</a>
<a name="ln128">  wp_to-&gt;w_fold_manual = wp_from-&gt;w_fold_manual;</a>
<a name="ln129">  wp_to-&gt;w_foldinvalid = wp_from-&gt;w_foldinvalid;</a>
<a name="ln130">  cloneFoldGrowArray(&amp;wp_from-&gt;w_folds, &amp;wp_to-&gt;w_folds);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">/* hasAnyFolding() {{{2 */</a>
<a name="ln134">/*</a>
<a name="ln135"> * Return TRUE if there may be folded lines in the current window.</a>
<a name="ln136"> */</a>
<a name="ln137">int hasAnyFolding(win_T *win)</a>
<a name="ln138">{</a>
<a name="ln139">  /* very simple now, but can become more complex later */</a>
<a name="ln140">  return !win-&gt;w_buffer-&gt;terminal &amp;&amp; win-&gt;w_p_fen</a>
<a name="ln141">         &amp;&amp; (!foldmethodIsManual(win) || !GA_EMPTY(&amp;win-&gt;w_folds));</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">/* hasFolding() {{{2 */</a>
<a name="ln145">/*</a>
<a name="ln146"> * Return TRUE if line &quot;lnum&quot; in the current window is part of a closed</a>
<a name="ln147"> * fold.</a>
<a name="ln148"> * When returning TRUE, *firstp and *lastp are set to the first and last</a>
<a name="ln149"> * lnum of the sequence of folded lines (skipped when NULL).</a>
<a name="ln150"> */</a>
<a name="ln151">bool hasFolding(linenr_T lnum, linenr_T *firstp, linenr_T *lastp)</a>
<a name="ln152">{</a>
<a name="ln153">  return hasFoldingWin(curwin, lnum, firstp, lastp, true, NULL);</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">// hasFoldingWin() {{{2</a>
<a name="ln157">/// Search folds starting at lnum</a>
<a name="ln158">/// @param lnum first line to search</a>
<a name="ln159">/// @param[out] first first line of fold containing lnum</a>
<a name="ln160">/// @param[out] lastp last line with a fold</a>
<a name="ln161">/// @param cache when true: use cached values of window</a>
<a name="ln162">/// @param[out] infop where to store fold info</a>
<a name="ln163">///</a>
<a name="ln164">/// @return true if range contains folds</a>
<a name="ln165">bool hasFoldingWin(</a>
<a name="ln166">    win_T *const win,</a>
<a name="ln167">    const linenr_T lnum,</a>
<a name="ln168">    linenr_T *const firstp,</a>
<a name="ln169">    linenr_T *const lastp,</a>
<a name="ln170">    const bool cache,</a>
<a name="ln171">    foldinfo_T *const infop</a>
<a name="ln172">)</a>
<a name="ln173">{</a>
<a name="ln174">  bool had_folded = false;</a>
<a name="ln175">  linenr_T first = 0;</a>
<a name="ln176">  linenr_T last = 0;</a>
<a name="ln177">  linenr_T lnum_rel = lnum;</a>
<a name="ln178">  fold_T      *fp;</a>
<a name="ln179">  int level = 0;</a>
<a name="ln180">  bool use_level = false;</a>
<a name="ln181">  bool maybe_small = false;</a>
<a name="ln182">  int low_level = 0;</a>
<a name="ln183"> </a>
<a name="ln184">  checkupdate(win);</a>
<a name="ln185"> </a>
<a name="ln186">  // Return quickly when there is no folding at all in this window.</a>
<a name="ln187">  if (!hasAnyFolding(win)) {</a>
<a name="ln188">    if (infop != NULL)</a>
<a name="ln189">      infop-&gt;fi_level = 0;</a>
<a name="ln190">    return false;</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193">  if (cache) {</a>
<a name="ln194">    /*</a>
<a name="ln195">     * First look in cached info for displayed lines.  This is probably</a>
<a name="ln196">     * the fastest, but it can only be used if the entry is still valid.</a>
<a name="ln197">     */</a>
<a name="ln198">    const int x = find_wl_entry(win, lnum);</a>
<a name="ln199">    if (x &gt;= 0) {</a>
<a name="ln200">      first = win-&gt;w_lines[x].wl_lnum;</a>
<a name="ln201">      last = win-&gt;w_lines[x].wl_lastlnum;</a>
<a name="ln202">      had_folded = win-&gt;w_lines[x].wl_folded;</a>
<a name="ln203">    }</a>
<a name="ln204">  }</a>
<a name="ln205"> </a>
<a name="ln206">  if (first == 0) {</a>
<a name="ln207">    /*</a>
<a name="ln208">     * Recursively search for a fold that contains &quot;lnum&quot;.</a>
<a name="ln209">     */</a>
<a name="ln210">    garray_T *gap = &amp;win-&gt;w_folds;</a>
<a name="ln211">    for (;; ) {</a>
<a name="ln212">      if (!foldFind(gap, lnum_rel, &amp;fp))</a>
<a name="ln213">        break;</a>
<a name="ln214"> </a>
<a name="ln215">      /* Remember lowest level of fold that starts in &quot;lnum&quot;. */</a>
<a name="ln216">      if (lnum_rel == fp-&gt;fd_top &amp;&amp; low_level == 0)</a>
<a name="ln217">        low_level = level + 1;</a>
<a name="ln218"> </a>
<a name="ln219">      first += fp-&gt;fd_top;</a>
<a name="ln220">      last += fp-&gt;fd_top;</a>
<a name="ln221"> </a>
<a name="ln222">      /* is this fold closed? */</a>
<a name="ln223">      had_folded = check_closed(win, fp, &amp;use_level, level,</a>
<a name="ln224">          &amp;maybe_small, lnum - lnum_rel);</a>
<a name="ln225">      if (had_folded) {</a>
<a name="ln226">        /* Fold closed: Set last and quit loop. */</a>
<a name="ln227">        last += fp-&gt;fd_len - 1;</a>
<a name="ln228">        break;</a>
<a name="ln229">      }</a>
<a name="ln230"> </a>
<a name="ln231">      /* Fold found, but it's open: Check nested folds.  Line number is</a>
<a name="ln232">       * relative to containing fold. */</a>
<a name="ln233">      gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln234">      lnum_rel -= fp-&gt;fd_top;</a>
<a name="ln235">      ++level;</a>
<a name="ln236">    }</a>
<a name="ln237">  }</a>
<a name="ln238"> </a>
<a name="ln239">  if (!had_folded) {</a>
<a name="ln240">    if (infop != NULL) {</a>
<a name="ln241">      infop-&gt;fi_level = level;</a>
<a name="ln242">      infop-&gt;fi_lnum = lnum - lnum_rel;</a>
<a name="ln243">      infop-&gt;fi_low_level = low_level == 0 ? level : low_level;</a>
<a name="ln244">    }</a>
<a name="ln245">    return false;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  if (last &gt; win-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln249">    last = win-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln250">  }</a>
<a name="ln251">  if (lastp != NULL)</a>
<a name="ln252">    *lastp = last;</a>
<a name="ln253">  if (firstp != NULL)</a>
<a name="ln254">    *firstp = first;</a>
<a name="ln255">  if (infop != NULL) {</a>
<a name="ln256">    infop-&gt;fi_level = level + 1;</a>
<a name="ln257">    infop-&gt;fi_lnum = first;</a>
<a name="ln258">    infop-&gt;fi_low_level = low_level == 0 ? level + 1 : low_level;</a>
<a name="ln259">  }</a>
<a name="ln260">  return true;</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/* foldLevel() {{{2 */</a>
<a name="ln264">/*</a>
<a name="ln265"> * Return fold level at line number &quot;lnum&quot; in the current window.</a>
<a name="ln266"> */</a>
<a name="ln267">int foldLevel(linenr_T lnum)</a>
<a name="ln268">{</a>
<a name="ln269">  /* While updating the folds lines between invalid_top and invalid_bot have</a>
<a name="ln270">   * an undefined fold level.  Otherwise update the folds first. */</a>
<a name="ln271">  if (invalid_top == (linenr_T)0)</a>
<a name="ln272">    checkupdate(curwin);</a>
<a name="ln273">  else if (lnum == prev_lnum &amp;&amp; prev_lnum_lvl &gt;= 0)</a>
<a name="ln274">    return prev_lnum_lvl;</a>
<a name="ln275">  else if (lnum &gt;= invalid_top &amp;&amp; lnum &lt;= invalid_bot)</a>
<a name="ln276">    return -1;</a>
<a name="ln277"> </a>
<a name="ln278">  /* Return quickly when there is no folding at all in this window. */</a>
<a name="ln279">  if (!hasAnyFolding(curwin))</a>
<a name="ln280">    return 0;</a>
<a name="ln281"> </a>
<a name="ln282">  return foldLevelWin(curwin, lnum);</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">// lineFolded() {{{2</a>
<a name="ln286">// Low level function to check if a line is folded.  Doesn't use any caching.</a>
<a name="ln287">// Return true if line is folded.</a>
<a name="ln288">// Return false if line is not folded.</a>
<a name="ln289">bool lineFolded(win_T *const win, const linenr_T lnum)</a>
<a name="ln290">{</a>
<a name="ln291">  return fold_info(win, lnum).fi_lines != 0;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">/// fold_info() {{{2</a>
<a name="ln295">///</a>
<a name="ln296">/// Count the number of lines that are folded at line number &quot;lnum&quot;.</a>
<a name="ln297">/// Normally &quot;lnum&quot; is the first line of a possible fold, and the returned</a>
<a name="ln298">/// number is the number of lines in the fold.</a>
<a name="ln299">/// Doesn't use caching from the displayed window.</a>
<a name="ln300">///</a>
<a name="ln301">/// @return with the fold level info.</a>
<a name="ln302">///         fi_lines = number of folded lines from &quot;lnum&quot;,</a>
<a name="ln303">///                    or 0 if line is not folded.</a>
<a name="ln304">foldinfo_T fold_info(win_T *win, linenr_T lnum)</a>
<a name="ln305">{</a>
<a name="ln306">  foldinfo_T info;</a>
<a name="ln307">  linenr_T last;</a>
<a name="ln308"> </a>
<a name="ln309">  if (hasFoldingWin(win, lnum, NULL, &amp;last, false, &amp;info)) {</a>
<a name="ln310">    info.fi_lines = (long)(last - lnum + 1);</a>
<a name="ln311">  } else {</a>
<a name="ln312">    info.fi_lines = 0;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  return info;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/* foldmethodIsManual() {{{2 */</a>
<a name="ln319">/*</a>
<a name="ln320"> * Return TRUE if 'foldmethod' is &quot;manual&quot;</a>
<a name="ln321"> */</a>
<a name="ln322">int foldmethodIsManual(win_T *wp)</a>
<a name="ln323">{</a>
<a name="ln324">  return wp-&gt;w_p_fdm[3] == 'u';</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">/* foldmethodIsIndent() {{{2 */</a>
<a name="ln328">/*</a>
<a name="ln329"> * Return TRUE if 'foldmethod' is &quot;indent&quot;</a>
<a name="ln330"> */</a>
<a name="ln331">int foldmethodIsIndent(win_T *wp)</a>
<a name="ln332">{</a>
<a name="ln333">  return wp-&gt;w_p_fdm[0] == 'i';</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">/* foldmethodIsExpr() {{{2 */</a>
<a name="ln337">/*</a>
<a name="ln338"> * Return TRUE if 'foldmethod' is &quot;expr&quot;</a>
<a name="ln339"> */</a>
<a name="ln340">int foldmethodIsExpr(win_T *wp)</a>
<a name="ln341">{</a>
<a name="ln342">  return wp-&gt;w_p_fdm[1] == 'x';</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">/* foldmethodIsMarker() {{{2 */</a>
<a name="ln346">/*</a>
<a name="ln347"> * Return TRUE if 'foldmethod' is &quot;marker&quot;</a>
<a name="ln348"> */</a>
<a name="ln349">int foldmethodIsMarker(win_T *wp)</a>
<a name="ln350">{</a>
<a name="ln351">  return wp-&gt;w_p_fdm[2] == 'r';</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">/* foldmethodIsSyntax() {{{2 */</a>
<a name="ln355">/*</a>
<a name="ln356"> * Return TRUE if 'foldmethod' is &quot;syntax&quot;</a>
<a name="ln357"> */</a>
<a name="ln358">int foldmethodIsSyntax(win_T *wp)</a>
<a name="ln359">{</a>
<a name="ln360">  return wp-&gt;w_p_fdm[0] == 's';</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">/* foldmethodIsDiff() {{{2 */</a>
<a name="ln364">/*</a>
<a name="ln365"> * Return TRUE if 'foldmethod' is &quot;diff&quot;</a>
<a name="ln366"> */</a>
<a name="ln367">int foldmethodIsDiff(win_T *wp)</a>
<a name="ln368">{</a>
<a name="ln369">  return wp-&gt;w_p_fdm[0] == 'd';</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">// closeFold() {{{2</a>
<a name="ln373">/// Close fold for current window at line &quot;lnum&quot;.</a>
<a name="ln374">/// Repeat &quot;count&quot; times.</a>
<a name="ln375">void closeFold(pos_T pos, long count)</a>
<a name="ln376">{</a>
<a name="ln377">  setFoldRepeat(pos, count, false);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">/* closeFoldRecurse() {{{2 */</a>
<a name="ln381">/*</a>
<a name="ln382"> * Close fold for current window at line &quot;lnum&quot; recursively.</a>
<a name="ln383"> */</a>
<a name="ln384">void closeFoldRecurse(pos_T pos)</a>
<a name="ln385">{</a>
<a name="ln386">  (void)setManualFold(pos, false, true, NULL);</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">/* opFoldRange() {{{2 */</a>
<a name="ln390">/*</a>
<a name="ln391"> * Open or Close folds for current window in lines &quot;first&quot; to &quot;last&quot;.</a>
<a name="ln392"> * Used for &quot;zo&quot;, &quot;zO&quot;, &quot;zc&quot; and &quot;zC&quot; in Visual mode.</a>
<a name="ln393"> */</a>
<a name="ln394">void</a>
<a name="ln395">opFoldRange(</a>
<a name="ln396">    pos_T firstpos,</a>
<a name="ln397">    pos_T lastpos,</a>
<a name="ln398">    int opening,                    // TRUE to open, FALSE to close</a>
<a name="ln399">    int recurse,                    // TRUE to do it recursively</a>
<a name="ln400">    int had_visual                  // TRUE when Visual selection used</a>
<a name="ln401">)</a>
<a name="ln402">{</a>
<a name="ln403">  int done = DONE_NOTHING;              // avoid error messages</a>
<a name="ln404">  linenr_T first = firstpos.lnum;</a>
<a name="ln405">  linenr_T last = lastpos.lnum;</a>
<a name="ln406">  linenr_T lnum;</a>
<a name="ln407">  linenr_T lnum_next;</a>
<a name="ln408"> </a>
<a name="ln409">  for (lnum = first; lnum &lt;= last; lnum = lnum_next + 1) {</a>
<a name="ln410">    pos_T temp = { lnum, 0, 0 };</a>
<a name="ln411">    lnum_next = lnum;</a>
<a name="ln412">    /* Opening one level only: next fold to open is after the one going to</a>
<a name="ln413">     * be opened. */</a>
<a name="ln414">    if (opening &amp;&amp; !recurse)</a>
<a name="ln415">      (void)hasFolding(lnum, NULL, &amp;lnum_next);</a>
<a name="ln416">    (void)setManualFold(temp, opening, recurse, &amp;done);</a>
<a name="ln417">    // Closing one level only: next line to close a fold is after just</a>
<a name="ln418">    // closed fold.</a>
<a name="ln419">    if (!opening &amp;&amp; !recurse) {</a>
<a name="ln420">      (void)hasFolding(lnum, NULL, &amp;lnum_next);</a>
<a name="ln421">    }</a>
<a name="ln422">  }</a>
<a name="ln423">  if (done == DONE_NOTHING)</a>
<a name="ln424">    EMSG(_(e_nofold));</a>
<a name="ln425">  /* Force a redraw to remove the Visual highlighting. */</a>
<a name="ln426">  if (had_visual)</a>
<a name="ln427">    redraw_curbuf_later(INVERTED);</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">/* openFold() {{{2 */</a>
<a name="ln431">/*</a>
<a name="ln432"> * Open fold for current window at line &quot;lnum&quot;.</a>
<a name="ln433"> * Repeat &quot;count&quot; times.</a>
<a name="ln434"> */</a>
<a name="ln435">void openFold(pos_T pos, long count)</a>
<a name="ln436">{</a>
<a name="ln437">  setFoldRepeat(pos, count, true);</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/* openFoldRecurse() {{{2 */</a>
<a name="ln441">/*</a>
<a name="ln442"> * Open fold for current window at line &quot;lnum&quot; recursively.</a>
<a name="ln443"> */</a>
<a name="ln444">void openFoldRecurse(pos_T pos)</a>
<a name="ln445">{</a>
<a name="ln446">  (void)setManualFold(pos, true, true, NULL);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">/* foldOpenCursor() {{{2 */</a>
<a name="ln450">/*</a>
<a name="ln451"> * Open folds until the cursor line is not in a closed fold.</a>
<a name="ln452"> */</a>
<a name="ln453">void foldOpenCursor(void)</a>
<a name="ln454">{</a>
<a name="ln455">  int done;</a>
<a name="ln456"> </a>
<a name="ln457">  checkupdate(curwin);</a>
<a name="ln458">  if (hasAnyFolding(curwin))</a>
<a name="ln459">    for (;; ) {</a>
<a name="ln460">      done = DONE_NOTHING;</a>
<a name="ln461">      (void)setManualFold(curwin-&gt;w_cursor, true, false, &amp;done);</a>
<a name="ln462">      if (!(done &amp; DONE_ACTION)) {</a>
<a name="ln463">        break;</a>
<a name="ln464">      }</a>
<a name="ln465">    }</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/* newFoldLevel() {{{2 */</a>
<a name="ln469">/*</a>
<a name="ln470"> * Set new foldlevel for current window.</a>
<a name="ln471"> */</a>
<a name="ln472">void newFoldLevel(void)</a>
<a name="ln473">{</a>
<a name="ln474">  newFoldLevelWin(curwin);</a>
<a name="ln475"> </a>
<a name="ln476">  if (foldmethodIsDiff(curwin) &amp;&amp; curwin-&gt;w_p_scb) {</a>
<a name="ln477">    /*</a>
<a name="ln478">     * Set the same foldlevel in other windows in diff mode.</a>
<a name="ln479">     */</a>
<a name="ln480">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln481">      if (wp != curwin &amp;&amp; foldmethodIsDiff(wp) &amp;&amp; wp-&gt;w_p_scb) {</a>
<a name="ln482">        wp-&gt;w_p_fdl = curwin-&gt;w_p_fdl;</a>
<a name="ln483">        newFoldLevelWin(wp);</a>
<a name="ln484">      }</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">static void newFoldLevelWin(win_T *wp)</a>
<a name="ln490">{</a>
<a name="ln491">  fold_T      *fp;</a>
<a name="ln492"> </a>
<a name="ln493">  checkupdate(wp);</a>
<a name="ln494">  if (wp-&gt;w_fold_manual) {</a>
<a name="ln495">    /* Set all flags for the first level of folds to FD_LEVEL.  Following</a>
<a name="ln496">     * manual open/close will then change the flags to FD_OPEN or</a>
<a name="ln497">     * FD_CLOSED for those folds that don't use 'foldlevel'. */</a>
<a name="ln498">    fp = (fold_T *)wp-&gt;w_folds.ga_data;</a>
<a name="ln499">    for (int i = 0; i &lt; wp-&gt;w_folds.ga_len; ++i)</a>
<a name="ln500">      fp[i].fd_flags = FD_LEVEL;</a>
<a name="ln501">    wp-&gt;w_fold_manual = false;</a>
<a name="ln502">  }</a>
<a name="ln503">  changed_window_setting_win(wp);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">/* foldCheckClose() {{{2 */</a>
<a name="ln507">/*</a>
<a name="ln508"> * Apply 'foldlevel' to all folds that don't contain the cursor.</a>
<a name="ln509"> */</a>
<a name="ln510">void foldCheckClose(void)</a>
<a name="ln511">{</a>
<a name="ln512">  if (*p_fcl != NUL) {  /* can only be &quot;all&quot; right now */</a>
<a name="ln513">    checkupdate(curwin);</a>
<a name="ln514">    if (checkCloseRec(&amp;curwin-&gt;w_folds, curwin-&gt;w_cursor.lnum,</a>
<a name="ln515">            (int)curwin-&gt;w_p_fdl))</a>
<a name="ln516">      changed_window_setting();</a>
<a name="ln517">  }</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/* checkCloseRec() {{{2 */</a>
<a name="ln521">static int checkCloseRec(garray_T *gap, linenr_T lnum, int level)</a>
<a name="ln522">{</a>
<a name="ln523">  fold_T      *fp;</a>
<a name="ln524">  int retval = FALSE;</a>
<a name="ln525"> </a>
<a name="ln526">  fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln527">  for (int i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln528">    /* Only manually opened folds may need to be closed. */</a>
<a name="ln529">    if (fp[i].fd_flags == FD_OPEN) {</a>
<a name="ln530">      if (level &lt;= 0 &amp;&amp; (lnum &lt; fp[i].fd_top</a>
<a name="ln531">                         || lnum &gt;= fp[i].fd_top + fp[i].fd_len)) {</a>
<a name="ln532">        fp[i].fd_flags = FD_LEVEL;</a>
<a name="ln533">        retval = TRUE;</a>
<a name="ln534">      } else</a>
<a name="ln535">        retval |= checkCloseRec(&amp;fp[i].fd_nested, lnum - fp[i].fd_top,</a>
<a name="ln536">            level - 1);</a>
<a name="ln537">    }</a>
<a name="ln538">  }</a>
<a name="ln539">  return retval;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/* foldCreateAllowed() {{{2 */</a>
<a name="ln543">/*</a>
<a name="ln544"> * Return TRUE if it's allowed to manually create or delete a fold.</a>
<a name="ln545"> * Give an error message and return FALSE if not.</a>
<a name="ln546"> */</a>
<a name="ln547">int foldManualAllowed(int create)</a>
<a name="ln548">{</a>
<a name="ln549">  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))</a>
<a name="ln550">    return TRUE;</a>
<a name="ln551">  if (create)</a>
<a name="ln552">    EMSG(_(&quot;E350: Cannot create fold with current 'foldmethod'&quot;));</a>
<a name="ln553">  else</a>
<a name="ln554">    EMSG(_(&quot;E351: Cannot delete fold with current 'foldmethod'&quot;));</a>
<a name="ln555">  return FALSE;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">// foldCreate() {{{2</a>
<a name="ln559">/// Create a fold from line &quot;start&quot; to line &quot;end&quot; (inclusive) in the current</a>
<a name="ln560">/// window.</a>
<a name="ln561">void foldCreate(win_T *wp, pos_T start, pos_T end)</a>
<a name="ln562">{</a>
<a name="ln563">  fold_T      *fp;</a>
<a name="ln564">  garray_T    *gap;</a>
<a name="ln565">  garray_T fold_ga;</a>
<a name="ln566">  int i;</a>
<a name="ln567">  int cont;</a>
<a name="ln568">  int use_level = FALSE;</a>
<a name="ln569">  int closed = FALSE;</a>
<a name="ln570">  int level = 0;</a>
<a name="ln571">  pos_T start_rel = start;</a>
<a name="ln572">  pos_T end_rel = end;</a>
<a name="ln573"> </a>
<a name="ln574">  if (start.lnum &gt; end.lnum) {</a>
<a name="ln575">    // reverse the range</a>
<a name="ln576">    end = start_rel;</a>
<a name="ln577">    start = end_rel;</a>
<a name="ln578">    start_rel = start;</a>
<a name="ln579">    end_rel = end;</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  // When 'foldmethod' is &quot;marker&quot; add markers, which creates the folds.</a>
<a name="ln583">  if (foldmethodIsMarker(wp)) {</a>
<a name="ln584">    foldCreateMarkers(wp, start, end);</a>
<a name="ln585">    return;</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  checkupdate(wp);</a>
<a name="ln589"> </a>
<a name="ln590">  // Find the place to insert the new fold</a>
<a name="ln591">  gap = &amp;wp-&gt;w_folds;</a>
<a name="ln592">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln593">    i = 0;</a>
<a name="ln594">  } else {</a>
<a name="ln595">    for (;;) {</a>
<a name="ln596">      if (!foldFind(gap, start_rel.lnum, &amp;fp)) {</a>
<a name="ln597">        break;</a>
<a name="ln598">      }</a>
<a name="ln599">      if (fp-&gt;fd_top + fp-&gt;fd_len &gt; end_rel.lnum) {</a>
<a name="ln600">        // New fold is completely inside this fold: Go one level deeper.</a>
<a name="ln601">        gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln602">        start_rel.lnum -= fp-&gt;fd_top;</a>
<a name="ln603">        end_rel.lnum -= fp-&gt;fd_top;</a>
<a name="ln604">        if (use_level || fp-&gt;fd_flags == FD_LEVEL) {</a>
<a name="ln605">          use_level = true;</a>
<a name="ln606">          if (level &gt;= wp-&gt;w_p_fdl) {</a>
<a name="ln607">            closed = true;</a>
<a name="ln608">          }</a>
<a name="ln609">        } else if (fp-&gt;fd_flags == FD_CLOSED) {</a>
<a name="ln610">          closed = true;</a>
<a name="ln611">        }</a>
<a name="ln612">        level++;</a>
<a name="ln613">      } else {</a>
<a name="ln614">        // This fold and new fold overlap: Insert here and move some folds</a>
<a name="ln615">        // inside the new fold.</a>
<a name="ln616">        break;</a>
<a name="ln617">      }</a>
<a name="ln618">    }</a>
<a name="ln619">    i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  ga_grow(gap, 1);</a>
<a name="ln623">  {</a>
<a name="ln624">    fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln625">    ga_init(&amp;fold_ga, (int)sizeof(fold_T), 10);</a>
<a name="ln626"> </a>
<a name="ln627">    // Count number of folds that will be contained in the new fold.</a>
<a name="ln628">    for (cont = 0; i + cont &lt; gap-&gt;ga_len; cont++) {</a>
<a name="ln629">      if (fp[cont].fd_top &gt; end_rel.lnum) {</a>
<a name="ln630">        break;</a>
<a name="ln631">      }</a>
<a name="ln632">    }</a>
<a name="ln633">    if (cont &gt; 0) {</a>
<a name="ln634">      ga_grow(&amp;fold_ga, cont);</a>
<a name="ln635">      /* If the first fold starts before the new fold, let the new fold</a>
<a name="ln636">       * start there.  Otherwise the existing fold would change. */</a>
<a name="ln637">      if (start_rel.lnum &gt; fp-&gt;fd_top) {</a>
<a name="ln638">        start_rel.lnum = fp-&gt;fd_top;</a>
<a name="ln639">      }</a>
<a name="ln640"> </a>
<a name="ln641">      // When last contained fold isn't completely contained, adjust end</a>
<a name="ln642">      // of new fold.</a>
<a name="ln643">      if (end_rel.lnum &lt; fp[cont - 1].fd_top + fp[cont - 1].fd_len - 1) {</a>
<a name="ln644">        end_rel.lnum = fp[cont - 1].fd_top + fp[cont - 1].fd_len - 1;</a>
<a name="ln645">      }</a>
<a name="ln646">      // Move contained folds to inside new fold</a>
<a name="ln647">      memmove(fold_ga.ga_data, fp, sizeof(fold_T) * (size_t)cont);</a>
<a name="ln648">      fold_ga.ga_len += cont;</a>
<a name="ln649">      i += cont;</a>
<a name="ln650"> </a>
<a name="ln651">      /* Adjust line numbers in contained folds to be relative to the</a>
<a name="ln652">       * new fold. */</a>
<a name="ln653">      for (int j = 0; j &lt; cont; j++) {</a>
<a name="ln654">        ((fold_T *)fold_ga.ga_data)[j].fd_top -= start_rel.lnum;</a>
<a name="ln655">      }</a>
<a name="ln656">    }</a>
<a name="ln657">    /* Move remaining entries to after the new fold. */</a>
<a name="ln658">    if (i &lt; gap-&gt;ga_len)</a>
<a name="ln659">      memmove(fp + 1, (fold_T *)gap-&gt;ga_data + i,</a>
<a name="ln660">              sizeof(fold_T) * (size_t)(gap-&gt;ga_len - i));</a>
<a name="ln661">    gap-&gt;ga_len = gap-&gt;ga_len + 1 - cont;</a>
<a name="ln662"> </a>
<a name="ln663">    /* insert new fold */</a>
<a name="ln664">    fp-&gt;fd_nested = fold_ga;</a>
<a name="ln665">    fp-&gt;fd_top = start_rel.lnum;</a>
<a name="ln666">    fp-&gt;fd_len = end_rel.lnum - start_rel.lnum + 1;</a>
<a name="ln667"> </a>
<a name="ln668">    /* We want the new fold to be closed.  If it would remain open because</a>
<a name="ln669">     * of using 'foldlevel', need to adjust fd_flags of containing folds.</a>
<a name="ln670">     */</a>
<a name="ln671">    if (use_level &amp;&amp; !closed &amp;&amp; level &lt; wp-&gt;w_p_fdl) {</a>
<a name="ln672">      closeFold(start, 1L);</a>
<a name="ln673">    }</a>
<a name="ln674">    if (!use_level) {</a>
<a name="ln675">      wp-&gt;w_fold_manual = true;</a>
<a name="ln676">    }</a>
<a name="ln677">    fp-&gt;fd_flags = FD_CLOSED;</a>
<a name="ln678">    fp-&gt;fd_small = kNone;</a>
<a name="ln679"> </a>
<a name="ln680">    // redraw</a>
<a name="ln681">    changed_window_setting_win(wp);</a>
<a name="ln682">  }</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">// deleteFold() {{{2</a>
<a name="ln687">/// @param start delete all folds from start to end when not 0</a>
<a name="ln688">/// @param end delete all folds from start to end when not 0</a>
<a name="ln689">/// @param recursive delete recursively if true</a>
<a name="ln690">/// @param had_visual true when Visual selection used</a>
<a name="ln691">void deleteFold(</a>
<a name="ln692">    win_T *const wp,</a>
<a name="ln693">    const linenr_T start,</a>
<a name="ln694">    const linenr_T end,</a>
<a name="ln695">    const int recursive,</a>
<a name="ln696">    const bool had_visual         // true when Visual selection used</a>
<a name="ln697">)</a>
<a name="ln698">{</a>
<a name="ln699">  fold_T      *fp;</a>
<a name="ln700">  fold_T      *found_fp = NULL;</a>
<a name="ln701">  linenr_T found_off = 0;</a>
<a name="ln702">  bool maybe_small = false;</a>
<a name="ln703">  int level = 0;</a>
<a name="ln704">  linenr_T lnum = start;</a>
<a name="ln705">  bool did_one = false;</a>
<a name="ln706">  linenr_T first_lnum = MAXLNUM;</a>
<a name="ln707">  linenr_T last_lnum = 0;</a>
<a name="ln708"> </a>
<a name="ln709">  checkupdate(wp);</a>
<a name="ln710"> </a>
<a name="ln711">  while (lnum &lt;= end) {</a>
<a name="ln712">    // Find the deepest fold for &quot;start&quot;.</a>
<a name="ln713">    garray_T *gap = &amp;wp-&gt;w_folds;</a>
<a name="ln714">    garray_T *found_ga = NULL;</a>
<a name="ln715">    linenr_T lnum_off = 0;</a>
<a name="ln716">    bool use_level = false;</a>
<a name="ln717">    for (;; ) {</a>
<a name="ln718">      if (!foldFind(gap, lnum - lnum_off, &amp;fp))</a>
<a name="ln719">        break;</a>
<a name="ln720">      /* lnum is inside this fold, remember info */</a>
<a name="ln721">      found_ga = gap;</a>
<a name="ln722">      found_fp = fp;</a>
<a name="ln723">      found_off = lnum_off;</a>
<a name="ln724"> </a>
<a name="ln725">      // if &quot;lnum&quot; is folded, don't check nesting</a>
<a name="ln726">      if (check_closed(wp, fp, &amp;use_level, level,</a>
<a name="ln727">                       &amp;maybe_small, lnum_off)) {</a>
<a name="ln728">        break;</a>
<a name="ln729">      }</a>
<a name="ln730"> </a>
<a name="ln731">      /* check nested folds */</a>
<a name="ln732">      gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln733">      lnum_off += fp-&gt;fd_top;</a>
<a name="ln734">      ++level;</a>
<a name="ln735">    }</a>
<a name="ln736">    if (found_ga == NULL) {</a>
<a name="ln737">      ++lnum;</a>
<a name="ln738">    } else {</a>
<a name="ln739">      lnum = found_fp-&gt;fd_top + found_fp-&gt;fd_len + found_off;</a>
<a name="ln740"> </a>
<a name="ln741">      if (foldmethodIsManual(wp)) {</a>
<a name="ln742">        deleteFoldEntry(wp, found_ga,</a>
<a name="ln743">                        (int)(found_fp - (fold_T *)found_ga-&gt;ga_data),</a>
<a name="ln744">                        recursive);</a>
<a name="ln745">      } else {</a>
<a name="ln746">        if (first_lnum &gt; found_fp-&gt;fd_top + found_off) {</a>
<a name="ln747">          first_lnum = found_fp-&gt;fd_top + found_off;</a>
<a name="ln748">        }</a>
<a name="ln749">        if (last_lnum &lt; lnum) {</a>
<a name="ln750">          last_lnum = lnum;</a>
<a name="ln751">        }</a>
<a name="ln752">        if (!did_one) {</a>
<a name="ln753">          parseMarker(wp);</a>
<a name="ln754">        }</a>
<a name="ln755">        deleteFoldMarkers(wp, found_fp, recursive, found_off);</a>
<a name="ln756">      }</a>
<a name="ln757">      did_one = true;</a>
<a name="ln758"> </a>
<a name="ln759">      // redraw window</a>
<a name="ln760">      changed_window_setting_win(wp);</a>
<a name="ln761">    }</a>
<a name="ln762">  }</a>
<a name="ln763">  if (!did_one) {</a>
<a name="ln764">    EMSG(_(e_nofold));</a>
<a name="ln765">    // Force a redraw to remove the Visual highlighting.</a>
<a name="ln766">    if (had_visual) {</a>
<a name="ln767">      redraw_buf_later(wp-&gt;w_buffer, INVERTED);</a>
<a name="ln768">    }</a>
<a name="ln769">  } else {</a>
<a name="ln770">    // Deleting markers may make cursor column invalid</a>
<a name="ln771">    check_cursor_col_win(wp);</a>
<a name="ln772">  }</a>
<a name="ln773"> </a>
<a name="ln774">  if (last_lnum &gt; 0) {</a>
<a name="ln775">    // TODO(teto): pass the buffer</a>
<a name="ln776">    changed_lines(first_lnum, (colnr_T)0, last_lnum, 0L, false);</a>
<a name="ln777"> </a>
<a name="ln778">    // send one nvim_buf_lines_event at the end</a>
<a name="ln779">    // last_lnum is the line *after* the last line of the outermost fold</a>
<a name="ln780">    // that was modified. Note also that deleting a fold might only require</a>
<a name="ln781">    // the modification of the *first* line of the fold, but we send through a</a>
<a name="ln782">    // notification that includes every line that was part of the fold</a>
<a name="ln783">    int64_t num_changed = last_lnum - first_lnum;</a>
<a name="ln784">    buf_updates_send_changes(wp-&gt;w_buffer, first_lnum, num_changed,</a>
<a name="ln785">                             num_changed, true);</a>
<a name="ln786">  }</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/* clearFolding() {{{2 */</a>
<a name="ln790">/*</a>
<a name="ln791"> * Remove all folding for window &quot;win&quot;.</a>
<a name="ln792"> */</a>
<a name="ln793">void clearFolding(win_T *win)</a>
<a name="ln794">{</a>
<a name="ln795">  deleteFoldRecurse(win-&gt;w_buffer, &amp;win-&gt;w_folds);</a>
<a name="ln796">  win-&gt;w_foldinvalid = false;</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">/* foldUpdate() {{{2 */</a>
<a name="ln800">/*</a>
<a name="ln801"> * Update folds for changes in the buffer of a window.</a>
<a name="ln802"> * Note that inserted/deleted lines must have already been taken care of by</a>
<a name="ln803"> * calling foldMarkAdjust().</a>
<a name="ln804"> * The changes in lines from top to bot (inclusive).</a>
<a name="ln805"> */</a>
<a name="ln806">void foldUpdate(win_T *wp, linenr_T top, linenr_T bot)</a>
<a name="ln807">{</a>
<a name="ln808">  if (compl_busy || State &amp; INSERT) {</a>
<a name="ln809">    return;</a>
<a name="ln810">  }</a>
<a name="ln811"> </a>
<a name="ln812">  if (need_diff_redraw) {</a>
<a name="ln813">    // will update later</a>
<a name="ln814">    return;</a>
<a name="ln815">  }</a>
<a name="ln816"> </a>
<a name="ln817">  if (wp-&gt;w_folds.ga_len &gt; 0) {</a>
<a name="ln818">    // Mark all folds from top to bot as maybe-small.</a>
<a name="ln819">    fold_T *fp;</a>
<a name="ln820">    (void)foldFind(&amp;wp-&gt;w_folds, top, &amp;fp);</a>
<a name="ln821">    while (fp &lt; (fold_T *)wp-&gt;w_folds.ga_data + wp-&gt;w_folds.ga_len</a>
<a name="ln822">           &amp;&amp; fp-&gt;fd_top &lt; bot) {</a>
<a name="ln823">      fp-&gt;fd_small = kNone;</a>
<a name="ln824">      fp++;</a>
<a name="ln825">    }</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  if (foldmethodIsIndent(wp)</a>
<a name="ln829">      || foldmethodIsExpr(wp)</a>
<a name="ln830">      || foldmethodIsMarker(wp)</a>
<a name="ln831">      || foldmethodIsDiff(wp)</a>
<a name="ln832">      || foldmethodIsSyntax(wp)) {</a>
<a name="ln833">    int save_got_int = got_int;</a>
<a name="ln834"> </a>
<a name="ln835">    /* reset got_int here, otherwise it won't work */</a>
<a name="ln836">    got_int = FALSE;</a>
<a name="ln837">    foldUpdateIEMS(wp, top, bot);</a>
<a name="ln838">    got_int |= save_got_int;</a>
<a name="ln839">  }</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">/// Updates folds when leaving insert-mode.</a>
<a name="ln843">void foldUpdateAfterInsert(void)</a>
<a name="ln844">{</a>
<a name="ln845">  if (foldmethodIsManual(curwin)  // foldmethod=manual: No need to update.</a>
<a name="ln846">      // These foldmethods are too slow, do not auto-update on insert-leave.</a>
<a name="ln847">      || foldmethodIsSyntax(curwin) || foldmethodIsExpr(curwin)) {</a>
<a name="ln848">    return;</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  foldUpdateAll(curwin);</a>
<a name="ln852">  foldOpenCursor();</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/* foldUpdateAll() {{{2 */</a>
<a name="ln856">/*</a>
<a name="ln857"> * Update all lines in a window for folding.</a>
<a name="ln858"> * Used when a fold setting changes or after reloading the buffer.</a>
<a name="ln859"> * The actual updating is postponed until fold info is used, to avoid doing</a>
<a name="ln860"> * every time a setting is changed or a syntax item is added.</a>
<a name="ln861"> */</a>
<a name="ln862">void foldUpdateAll(win_T *win)</a>
<a name="ln863">{</a>
<a name="ln864">  win-&gt;w_foldinvalid = true;</a>
<a name="ln865">  redraw_later(win, NOT_VALID);</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868">// foldMoveTo() {{{2</a>
<a name="ln869">//</a>
<a name="ln870">// If &quot;updown&quot; is false: Move to the start or end of the fold.</a>
<a name="ln871">// If &quot;updown&quot; is true: move to fold at the same level.</a>
<a name="ln872">// If not moved return FAIL.</a>
<a name="ln873">int foldMoveTo(</a>
<a name="ln874">    const bool updown,</a>
<a name="ln875">    const int dir,              // FORWARD or BACKWARD</a>
<a name="ln876">    const long count</a>
<a name="ln877">)</a>
<a name="ln878">{</a>
<a name="ln879">  int retval = FAIL;</a>
<a name="ln880">  linenr_T lnum;</a>
<a name="ln881">  fold_T      *fp;</a>
<a name="ln882"> </a>
<a name="ln883">  checkupdate(curwin);</a>
<a name="ln884"> </a>
<a name="ln885">  // Repeat &quot;count&quot; times.</a>
<a name="ln886">  for (long n = 0; n &lt; count; n++) {</a>
<a name="ln887">    // Find nested folds.  Stop when a fold is closed.  The deepest fold</a>
<a name="ln888">    // that moves the cursor is used.</a>
<a name="ln889">    linenr_T lnum_off = 0;</a>
<a name="ln890">    garray_T *gap = &amp;curwin-&gt;w_folds;</a>
<a name="ln891">    if (gap-&gt;ga_len == 0) {</a>
<a name="ln892">      break;</a>
<a name="ln893">    }</a>
<a name="ln894">    bool use_level = false;</a>
<a name="ln895">    bool maybe_small = false;</a>
<a name="ln896">    linenr_T lnum_found = curwin-&gt;w_cursor.lnum;</a>
<a name="ln897">    int level = 0;</a>
<a name="ln898">    bool last = false;</a>
<a name="ln899">    for (;; ) {</a>
<a name="ln900">      if (!foldFind(gap, curwin-&gt;w_cursor.lnum - lnum_off, &amp;fp)) {</a>
<a name="ln901">        if (!updown)</a>
<a name="ln902">          break;</a>
<a name="ln903"> </a>
<a name="ln904">        /* When moving up, consider a fold above the cursor; when</a>
<a name="ln905">         * moving down consider a fold below the cursor. */</a>
<a name="ln906">        if (dir == FORWARD) {</a>
<a name="ln907">          if (fp - (fold_T *)gap-&gt;ga_data &gt;= gap-&gt;ga_len)</a>
<a name="ln908">            break;</a>
<a name="ln909">          --fp;</a>
<a name="ln910">        } else {</a>
<a name="ln911">          if (fp == (fold_T *)gap-&gt;ga_data)</a>
<a name="ln912">            break;</a>
<a name="ln913">        }</a>
<a name="ln914">        /* don't look for contained folds, they will always move</a>
<a name="ln915">         * the cursor too far. */</a>
<a name="ln916">        last = true;</a>
<a name="ln917">      }</a>
<a name="ln918"> </a>
<a name="ln919">      if (!last) {</a>
<a name="ln920">        /* Check if this fold is closed. */</a>
<a name="ln921">        if (check_closed(curwin, fp, &amp;use_level, level,</a>
<a name="ln922">                         &amp;maybe_small, lnum_off)) {</a>
<a name="ln923">          last = true;</a>
<a name="ln924">        }</a>
<a name="ln925"> </a>
<a name="ln926">        /* &quot;[z&quot; and &quot;]z&quot; stop at closed fold */</a>
<a name="ln927">        if (last &amp;&amp; !updown)</a>
<a name="ln928">          break;</a>
<a name="ln929">      }</a>
<a name="ln930"> </a>
<a name="ln931">      if (updown) {</a>
<a name="ln932">        if (dir == FORWARD) {</a>
<a name="ln933">          /* to start of next fold if there is one */</a>
<a name="ln934">          if (fp + 1 - (fold_T *)gap-&gt;ga_data &lt; gap-&gt;ga_len) {</a>
<a name="ln935">            lnum = fp[1].fd_top + lnum_off;</a>
<a name="ln936">            if (lnum &gt; curwin-&gt;w_cursor.lnum)</a>
<a name="ln937">              lnum_found = lnum;</a>
<a name="ln938">          }</a>
<a name="ln939">        } else {</a>
<a name="ln940">          /* to end of previous fold if there is one */</a>
<a name="ln941">          if (fp &gt; (fold_T *)gap-&gt;ga_data) {</a>
<a name="ln942">            lnum = fp[-1].fd_top + lnum_off + fp[-1].fd_len - 1;</a>
<a name="ln943">            if (lnum &lt; curwin-&gt;w_cursor.lnum)</a>
<a name="ln944">              lnum_found = lnum;</a>
<a name="ln945">          }</a>
<a name="ln946">        }</a>
<a name="ln947">      } else {</a>
<a name="ln948">        /* Open fold found, set cursor to its start/end and then check</a>
<a name="ln949">         * nested folds. */</a>
<a name="ln950">        if (dir == FORWARD) {</a>
<a name="ln951">          lnum = fp-&gt;fd_top + lnum_off + fp-&gt;fd_len - 1;</a>
<a name="ln952">          if (lnum &gt; curwin-&gt;w_cursor.lnum)</a>
<a name="ln953">            lnum_found = lnum;</a>
<a name="ln954">        } else {</a>
<a name="ln955">          lnum = fp-&gt;fd_top + lnum_off;</a>
<a name="ln956">          if (lnum &lt; curwin-&gt;w_cursor.lnum)</a>
<a name="ln957">            lnum_found = lnum;</a>
<a name="ln958">        }</a>
<a name="ln959">      }</a>
<a name="ln960"> </a>
<a name="ln961">      if (last)</a>
<a name="ln962">        break;</a>
<a name="ln963"> </a>
<a name="ln964">      /* Check nested folds (if any). */</a>
<a name="ln965">      gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln966">      lnum_off += fp-&gt;fd_top;</a>
<a name="ln967">      ++level;</a>
<a name="ln968">    }</a>
<a name="ln969">    if (lnum_found != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln970">      if (retval == FAIL)</a>
<a name="ln971">        setpcmark();</a>
<a name="ln972">      curwin-&gt;w_cursor.lnum = lnum_found;</a>
<a name="ln973">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln974">      retval = OK;</a>
<a name="ln975">    } else</a>
<a name="ln976">      break;</a>
<a name="ln977">  }</a>
<a name="ln978"> </a>
<a name="ln979">  return retval;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">/* foldInitWin() {{{2 */</a>
<a name="ln983">/*</a>
<a name="ln984"> * Init the fold info in a new window.</a>
<a name="ln985"> */</a>
<a name="ln986">void foldInitWin(win_T *new_win)</a>
<a name="ln987">{</a>
<a name="ln988">  ga_init(&amp;new_win-&gt;w_folds, (int)sizeof(fold_T), 10);</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">/* find_wl_entry() {{{2 */</a>
<a name="ln992">/*</a>
<a name="ln993"> * Find an entry in the win-&gt;w_lines[] array for buffer line &quot;lnum&quot;.</a>
<a name="ln994"> * Only valid entries are considered (for entries where wl_valid is FALSE the</a>
<a name="ln995"> * line number can be wrong).</a>
<a name="ln996"> * Returns index of entry or -1 if not found.</a>
<a name="ln997"> */</a>
<a name="ln998">int find_wl_entry(win_T *win, linenr_T lnum)</a>
<a name="ln999">{</a>
<a name="ln1000">  int i;</a>
<a name="ln1001"> </a>
<a name="ln1002">  for (i = 0; i &lt; win-&gt;w_lines_valid; ++i)</a>
<a name="ln1003">    if (win-&gt;w_lines[i].wl_valid) {</a>
<a name="ln1004">      if (lnum &lt; win-&gt;w_lines[i].wl_lnum)</a>
<a name="ln1005">        return -1;</a>
<a name="ln1006">      if (lnum &lt;= win-&gt;w_lines[i].wl_lastlnum)</a>
<a name="ln1007">        return i;</a>
<a name="ln1008">    }</a>
<a name="ln1009">  return -1;</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">/* foldAdjustVisual() {{{2 */</a>
<a name="ln1013">/*</a>
<a name="ln1014"> * Adjust the Visual area to include any fold at the start or end completely.</a>
<a name="ln1015"> */</a>
<a name="ln1016">void foldAdjustVisual(void)</a>
<a name="ln1017">{</a>
<a name="ln1018">  pos_T       *start, *end;</a>
<a name="ln1019">  char_u      *ptr;</a>
<a name="ln1020"> </a>
<a name="ln1021">  if (!VIsual_active || !hasAnyFolding(curwin))</a>
<a name="ln1022">    return;</a>
<a name="ln1023"> </a>
<a name="ln1024">  if (ltoreq(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln1025">    start = &amp;VIsual;</a>
<a name="ln1026">    end = &amp;curwin-&gt;w_cursor;</a>
<a name="ln1027">  } else {</a>
<a name="ln1028">    start = &amp;curwin-&gt;w_cursor;</a>
<a name="ln1029">    end = &amp;VIsual;</a>
<a name="ln1030">  }</a>
<a name="ln1031">  if (hasFolding(start-&gt;lnum, &amp;start-&gt;lnum, NULL))</a>
<a name="ln1032">    start-&gt;col = 0;</a>
<a name="ln1033">  if (hasFolding(end-&gt;lnum, NULL, &amp;end-&gt;lnum)) {</a>
<a name="ln1034">    ptr = ml_get(end-&gt;lnum);</a>
<a name="ln1035">    end-&gt;col = (colnr_T)STRLEN(ptr);</a>
<a name="ln1036">    if (end-&gt;col &gt; 0 &amp;&amp; *p_sel == 'o')</a>
<a name="ln1037">      --end-&gt;col;</a>
<a name="ln1038">    /* prevent cursor from moving on the trail byte */</a>
<a name="ln1039">    if (has_mbyte)</a>
<a name="ln1040">      mb_adjust_cursor();</a>
<a name="ln1041">  }</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/* cursor_foldstart() {{{2 */</a>
<a name="ln1045">/*</a>
<a name="ln1046"> * Move the cursor to the first line of a closed fold.</a>
<a name="ln1047"> */</a>
<a name="ln1048">void foldAdjustCursor(void)</a>
<a name="ln1049">{</a>
<a name="ln1050">  (void)hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum, NULL);</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">/* Internal functions for &quot;fold_T&quot; {{{1 */</a>
<a name="ln1054">/* cloneFoldGrowArray() {{{2 */</a>
<a name="ln1055">/*</a>
<a name="ln1056"> * Will &quot;clone&quot; (i.e deep copy) a garray_T of folds.</a>
<a name="ln1057"> */</a>
<a name="ln1058">void cloneFoldGrowArray(garray_T *from, garray_T *to)</a>
<a name="ln1059">{</a>
<a name="ln1060">  fold_T      *from_p;</a>
<a name="ln1061">  fold_T      *to_p;</a>
<a name="ln1062"> </a>
<a name="ln1063">  ga_init(to, from-&gt;ga_itemsize, from-&gt;ga_growsize);</a>
<a name="ln1064"> </a>
<a name="ln1065">  if (GA_EMPTY(from))</a>
<a name="ln1066">    return;</a>
<a name="ln1067"> </a>
<a name="ln1068">  ga_grow(to, from-&gt;ga_len);</a>
<a name="ln1069"> </a>
<a name="ln1070">  from_p = (fold_T *)from-&gt;ga_data;</a>
<a name="ln1071">  to_p = (fold_T *)to-&gt;ga_data;</a>
<a name="ln1072"> </a>
<a name="ln1073">  for (int i = 0; i &lt; from-&gt;ga_len; i++) {</a>
<a name="ln1074">    to_p-&gt;fd_top = from_p-&gt;fd_top;</a>
<a name="ln1075">    to_p-&gt;fd_len = from_p-&gt;fd_len;</a>
<a name="ln1076">    to_p-&gt;fd_flags = from_p-&gt;fd_flags;</a>
<a name="ln1077">    to_p-&gt;fd_small = from_p-&gt;fd_small;</a>
<a name="ln1078">    cloneFoldGrowArray(&amp;from_p-&gt;fd_nested, &amp;to_p-&gt;fd_nested);</a>
<a name="ln1079">    ++to-&gt;ga_len;</a>
<a name="ln1080">    ++from_p;</a>
<a name="ln1081">    ++to_p;</a>
<a name="ln1082">  }</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/* foldFind() {{{2 */</a>
<a name="ln1086">/*</a>
<a name="ln1087"> * Search for line &quot;lnum&quot; in folds of growarray &quot;gap&quot;.</a>
<a name="ln1088"> * Set *fpp to the fold struct for the fold that contains &quot;lnum&quot; or</a>
<a name="ln1089"> * the first fold below it (careful: it can be beyond the end of the array!).</a>
<a name="ln1090"> * Returns FALSE when there is no fold that contains &quot;lnum&quot;.</a>
<a name="ln1091"> */</a>
<a name="ln1092">static bool foldFind(const garray_T *gap, linenr_T lnum, fold_T **fpp)</a>
<a name="ln1093">{</a>
<a name="ln1094">  linenr_T low, high;</a>
<a name="ln1095">  fold_T      *fp;</a>
<a name="ln1096"> </a>
<a name="ln1097">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln1098">    *fpp = NULL;</a>
<a name="ln1099">    return false;</a>
<a name="ln1100">  }</a>
<a name="ln1101"> </a>
<a name="ln1102">  /*</a>
<a name="ln1103">   * Perform a binary search.</a>
<a name="ln1104">   * &quot;low&quot; is lowest index of possible match.</a>
<a name="ln1105">   * &quot;high&quot; is highest index of possible match.</a>
<a name="ln1106">   */</a>
<a name="ln1107">  fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln1108">  low = 0;</a>
<a name="ln1109">  high = gap-&gt;ga_len - 1;</a>
<a name="ln1110">  while (low &lt;= high) {</a>
<a name="ln1111">    linenr_T i = (low + high) / 2;</a>
<a name="ln1112">    if (fp[i].fd_top &gt; lnum)</a>
<a name="ln1113">      /* fold below lnum, adjust high */</a>
<a name="ln1114">      high = i - 1;</a>
<a name="ln1115">    else if (fp[i].fd_top + fp[i].fd_len &lt;= lnum)</a>
<a name="ln1116">      /* fold above lnum, adjust low */</a>
<a name="ln1117">      low = i + 1;</a>
<a name="ln1118">    else {</a>
<a name="ln1119">      /* lnum is inside this fold */</a>
<a name="ln1120">      *fpp = fp + i;</a>
<a name="ln1121">      return TRUE;</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124">  *fpp = fp + low;</a>
<a name="ln1125">  return false;</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">/* foldLevelWin() {{{2 */</a>
<a name="ln1129">/*</a>
<a name="ln1130"> * Return fold level at line number &quot;lnum&quot; in window &quot;wp&quot;.</a>
<a name="ln1131"> */</a>
<a name="ln1132">static int foldLevelWin(win_T *wp, linenr_T lnum)</a>
<a name="ln1133">{</a>
<a name="ln1134">  fold_T      *fp;</a>
<a name="ln1135">  linenr_T lnum_rel = lnum;</a>
<a name="ln1136">  int level =  0;</a>
<a name="ln1137">  garray_T    *gap;</a>
<a name="ln1138"> </a>
<a name="ln1139">  /* Recursively search for a fold that contains &quot;lnum&quot;. */</a>
<a name="ln1140">  gap = &amp;wp-&gt;w_folds;</a>
<a name="ln1141">  for (;; ) {</a>
<a name="ln1142">    if (!foldFind(gap, lnum_rel, &amp;fp))</a>
<a name="ln1143">      break;</a>
<a name="ln1144">    /* Check nested folds.  Line number is relative to containing fold. */</a>
<a name="ln1145">    gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln1146">    lnum_rel -= fp-&gt;fd_top;</a>
<a name="ln1147">    ++level;</a>
<a name="ln1148">  }</a>
<a name="ln1149"> </a>
<a name="ln1150">  return level;</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153">/* checkupdate() {{{2 */</a>
<a name="ln1154">/*</a>
<a name="ln1155"> * Check if the folds in window &quot;wp&quot; are invalid and update them if needed.</a>
<a name="ln1156"> */</a>
<a name="ln1157">static void checkupdate(win_T *wp)</a>
<a name="ln1158">{</a>
<a name="ln1159">  if (wp-&gt;w_foldinvalid) {</a>
<a name="ln1160">    foldUpdate(wp, (linenr_T)1, (linenr_T)MAXLNUM);     /* will update all */</a>
<a name="ln1161">    wp-&gt;w_foldinvalid = false;</a>
<a name="ln1162">  }</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">/* setFoldRepeat() {{{2 */</a>
<a name="ln1166">/*</a>
<a name="ln1167"> * Open or close fold for current window at line &quot;lnum&quot;.</a>
<a name="ln1168"> * Repeat &quot;count&quot; times.</a>
<a name="ln1169"> */</a>
<a name="ln1170">static void setFoldRepeat(pos_T pos, long count, int do_open)</a>
<a name="ln1171">{</a>
<a name="ln1172">  int done;</a>
<a name="ln1173">  long n;</a>
<a name="ln1174"> </a>
<a name="ln1175">  for (n = 0; n &lt; count; ++n) {</a>
<a name="ln1176">    done = DONE_NOTHING;</a>
<a name="ln1177">    (void)setManualFold(pos, do_open, false, &amp;done);</a>
<a name="ln1178">    if (!(done &amp; DONE_ACTION)) {</a>
<a name="ln1179">      /* Only give an error message when no fold could be opened. */</a>
<a name="ln1180">      if (n == 0 &amp;&amp; !(done &amp; DONE_FOLD))</a>
<a name="ln1181">        EMSG(_(e_nofold));</a>
<a name="ln1182">      break;</a>
<a name="ln1183">    }</a>
<a name="ln1184">  }</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">/* setManualFold() {{{2 */</a>
<a name="ln1188">/*</a>
<a name="ln1189"> * Open or close the fold in the current window which contains &quot;lnum&quot;.</a>
<a name="ln1190"> * Also does this for other windows in diff mode when needed.</a>
<a name="ln1191"> */</a>
<a name="ln1192">static linenr_T</a>
<a name="ln1193">setManualFold(</a>
<a name="ln1194">    pos_T pos,</a>
<a name="ln1195">    int opening,                // TRUE when opening, FALSE when closing</a>
<a name="ln1196">    int recurse,                // TRUE when closing/opening recursive</a>
<a name="ln1197">    int *donep</a>
<a name="ln1198">)</a>
<a name="ln1199">{</a>
<a name="ln1200">  linenr_T lnum = pos.lnum;</a>
<a name="ln1201">  if (foldmethodIsDiff(curwin) &amp;&amp; curwin-&gt;w_p_scb) {</a>
<a name="ln1202">    linenr_T dlnum;</a>
<a name="ln1203"> </a>
<a name="ln1204">    /*</a>
<a name="ln1205">     * Do the same operation in other windows in diff mode.  Calculate the</a>
<a name="ln1206">     * line number from the diffs.</a>
<a name="ln1207">     */</a>
<a name="ln1208">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1209">      if (wp != curwin &amp;&amp; foldmethodIsDiff(wp) &amp;&amp; wp-&gt;w_p_scb) {</a>
<a name="ln1210">        dlnum = diff_lnum_win(curwin-&gt;w_cursor.lnum, wp);</a>
<a name="ln1211">        if (dlnum != 0) {</a>
<a name="ln1212">          (void)setManualFoldWin(wp, dlnum, opening, recurse, NULL);</a>
<a name="ln1213">        }</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216">  }</a>
<a name="ln1217"> </a>
<a name="ln1218">  return setManualFoldWin(curwin, lnum, opening, recurse, donep);</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221">/* setManualFoldWin() {{{2 */</a>
<a name="ln1222">/*</a>
<a name="ln1223"> * Open or close the fold in window &quot;wp&quot; which contains &quot;lnum&quot;.</a>
<a name="ln1224"> * &quot;donep&quot;, when not NULL, points to flag that is set to DONE_FOLD when some</a>
<a name="ln1225"> * fold was found and to DONE_ACTION when some fold was opened or closed.</a>
<a name="ln1226"> * When &quot;donep&quot; is NULL give an error message when no fold was found for</a>
<a name="ln1227"> * &quot;lnum&quot;, but only if &quot;wp&quot; is &quot;curwin&quot;.</a>
<a name="ln1228"> * Return the line number of the next line that could be closed.</a>
<a name="ln1229"> * It's only valid when &quot;opening&quot; is TRUE!</a>
<a name="ln1230"> */</a>
<a name="ln1231">static linenr_T</a>
<a name="ln1232">setManualFoldWin(</a>
<a name="ln1233">    win_T *wp,</a>
<a name="ln1234">    linenr_T lnum,</a>
<a name="ln1235">    int opening,                // TRUE when opening, FALSE when closing</a>
<a name="ln1236">    int recurse,                // TRUE when closing/opening recursive</a>
<a name="ln1237">    int *donep</a>
<a name="ln1238">)</a>
<a name="ln1239">{</a>
<a name="ln1240">  fold_T      *fp;</a>
<a name="ln1241">  fold_T      *fp2;</a>
<a name="ln1242">  fold_T      *found = NULL;</a>
<a name="ln1243">  int j;</a>
<a name="ln1244">  int level = 0;</a>
<a name="ln1245">  int use_level = FALSE;</a>
<a name="ln1246">  int found_fold = FALSE;</a>
<a name="ln1247">  garray_T    *gap;</a>
<a name="ln1248">  linenr_T next = MAXLNUM;</a>
<a name="ln1249">  linenr_T off = 0;</a>
<a name="ln1250">  int done = 0;</a>
<a name="ln1251"> </a>
<a name="ln1252">  checkupdate(wp);</a>
<a name="ln1253"> </a>
<a name="ln1254">  /*</a>
<a name="ln1255">   * Find the fold, open or close it.</a>
<a name="ln1256">   */</a>
<a name="ln1257">  gap = &amp;wp-&gt;w_folds;</a>
<a name="ln1258">  for (;; ) {</a>
<a name="ln1259">    if (!foldFind(gap, lnum, &amp;fp)) {</a>
<a name="ln1260">      // If there is a following fold, continue there next time.</a>
<a name="ln1261">      if (fp != NULL &amp;&amp; fp &lt; (fold_T *)gap-&gt;ga_data + gap-&gt;ga_len) {</a>
<a name="ln1262">        next = fp-&gt;fd_top + off;</a>
<a name="ln1263">      }</a>
<a name="ln1264">      break;</a>
<a name="ln1265">    }</a>
<a name="ln1266"> </a>
<a name="ln1267">    /* lnum is inside this fold */</a>
<a name="ln1268">    found_fold = TRUE;</a>
<a name="ln1269"> </a>
<a name="ln1270">    /* If there is a following fold, continue there next time. */</a>
<a name="ln1271">    if (fp + 1 &lt; (fold_T *)gap-&gt;ga_data + gap-&gt;ga_len)</a>
<a name="ln1272">      next = fp[1].fd_top + off;</a>
<a name="ln1273"> </a>
<a name="ln1274">    /* Change from level-dependent folding to manual. */</a>
<a name="ln1275">    if (use_level || fp-&gt;fd_flags == FD_LEVEL) {</a>
<a name="ln1276">      use_level = TRUE;</a>
<a name="ln1277">      if (level &gt;= wp-&gt;w_p_fdl)</a>
<a name="ln1278">        fp-&gt;fd_flags = FD_CLOSED;</a>
<a name="ln1279">      else</a>
<a name="ln1280">        fp-&gt;fd_flags = FD_OPEN;</a>
<a name="ln1281">      fp2 = (fold_T *)fp-&gt;fd_nested.ga_data;</a>
<a name="ln1282">      for (j = 0; j &lt; fp-&gt;fd_nested.ga_len; ++j)</a>
<a name="ln1283">        fp2[j].fd_flags = FD_LEVEL;</a>
<a name="ln1284">    }</a>
<a name="ln1285"> </a>
<a name="ln1286">    /* Simple case: Close recursively means closing the fold. */</a>
<a name="ln1287">    if (!opening &amp;&amp; recurse) {</a>
<a name="ln1288">      if (fp-&gt;fd_flags != FD_CLOSED) {</a>
<a name="ln1289">        done |= DONE_ACTION;</a>
<a name="ln1290">        fp-&gt;fd_flags = FD_CLOSED;</a>
<a name="ln1291">      }</a>
<a name="ln1292">    } else if (fp-&gt;fd_flags == FD_CLOSED) {</a>
<a name="ln1293">      /* When opening, open topmost closed fold. */</a>
<a name="ln1294">      if (opening) {</a>
<a name="ln1295">        fp-&gt;fd_flags = FD_OPEN;</a>
<a name="ln1296">        done |= DONE_ACTION;</a>
<a name="ln1297">        if (recurse)</a>
<a name="ln1298">          foldOpenNested(fp);</a>
<a name="ln1299">      }</a>
<a name="ln1300">      break;</a>
<a name="ln1301">    }</a>
<a name="ln1302"> </a>
<a name="ln1303">    /* fold is open, check nested folds */</a>
<a name="ln1304">    found = fp;</a>
<a name="ln1305">    gap = &amp;fp-&gt;fd_nested;</a>
<a name="ln1306">    lnum -= fp-&gt;fd_top;</a>
<a name="ln1307">    off += fp-&gt;fd_top;</a>
<a name="ln1308">    ++level;</a>
<a name="ln1309">  }</a>
<a name="ln1310">  if (found_fold) {</a>
<a name="ln1311">    /* When closing and not recurse, close deepest open fold. */</a>
<a name="ln1312">    if (!opening &amp;&amp; found != NULL) {</a>
<a name="ln1313">      found-&gt;fd_flags = FD_CLOSED;</a>
<a name="ln1314">      done |= DONE_ACTION;</a>
<a name="ln1315">    }</a>
<a name="ln1316">    wp-&gt;w_fold_manual = true;</a>
<a name="ln1317">    if (done &amp; DONE_ACTION)</a>
<a name="ln1318">      changed_window_setting_win(wp);</a>
<a name="ln1319">    done |= DONE_FOLD;</a>
<a name="ln1320">  } else if (donep == NULL &amp;&amp; wp == curwin)</a>
<a name="ln1321">    EMSG(_(e_nofold));</a>
<a name="ln1322"> </a>
<a name="ln1323">  if (donep != NULL)</a>
<a name="ln1324">    *donep |= done;</a>
<a name="ln1325"> </a>
<a name="ln1326">  return next;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">/* foldOpenNested() {{{2 */</a>
<a name="ln1330">/*</a>
<a name="ln1331"> * Open all nested folds in fold &quot;fpr&quot; recursively.</a>
<a name="ln1332"> */</a>
<a name="ln1333">static void foldOpenNested(fold_T *fpr)</a>
<a name="ln1334">{</a>
<a name="ln1335">  fold_T      *fp;</a>
<a name="ln1336"> </a>
<a name="ln1337">  fp = (fold_T *)fpr-&gt;fd_nested.ga_data;</a>
<a name="ln1338">  for (int i = 0; i &lt; fpr-&gt;fd_nested.ga_len; ++i) {</a>
<a name="ln1339">    foldOpenNested(&amp;fp[i]);</a>
<a name="ln1340">    fp[i].fd_flags = FD_OPEN;</a>
<a name="ln1341">  }</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344">// deleteFoldEntry() {{{2</a>
<a name="ln1345">// Delete fold &quot;idx&quot; from growarray &quot;gap&quot;.</a>
<a name="ln1346">// When &quot;recursive&quot; is true also delete all the folds contained in it.</a>
<a name="ln1347">// When &quot;recursive&quot; is false contained folds are moved one level up.</a>
<a name="ln1348">static void deleteFoldEntry(win_T *const wp, garray_T *const gap, const int idx,</a>
<a name="ln1349">                            const bool recursive)</a>
<a name="ln1350">{</a>
<a name="ln1351">  fold_T *fp = (fold_T *)gap-&gt;ga_data + idx;</a>
<a name="ln1352">  if (recursive || GA_EMPTY(&amp;fp-&gt;fd_nested)) {</a>
<a name="ln1353">    // recursively delete the contained folds</a>
<a name="ln1354">    deleteFoldRecurse(wp-&gt;w_buffer, &amp;fp-&gt;fd_nested);</a>
<a name="ln1355">    gap-&gt;ga_len--;</a>
<a name="ln1356">    if (idx &lt; gap-&gt;ga_len) {</a>
<a name="ln1357">      memmove(fp, fp + 1, sizeof(*fp) * (size_t)(gap-&gt;ga_len - idx));</a>
<a name="ln1358">    }</a>
<a name="ln1359">  } else {</a>
<a name="ln1360">    /* Move nested folds one level up, to overwrite the fold that is</a>
<a name="ln1361">     * deleted. */</a>
<a name="ln1362">    int moved = fp-&gt;fd_nested.ga_len;</a>
<a name="ln1363">    ga_grow(gap, moved - 1);</a>
<a name="ln1364">    {</a>
<a name="ln1365">      /* Get &quot;fp&quot; again, the array may have been reallocated. */</a>
<a name="ln1366">      fp = (fold_T *)gap-&gt;ga_data + idx;</a>
<a name="ln1367"> </a>
<a name="ln1368">      // adjust fd_top and fd_flags for the moved folds</a>
<a name="ln1369">      fold_T *nfp = (fold_T *)fp-&gt;fd_nested.ga_data;</a>
<a name="ln1370">      for (int i = 0; i &lt; moved; i++) {</a>
<a name="ln1371">        nfp[i].fd_top += fp-&gt;fd_top;</a>
<a name="ln1372">        if (fp-&gt;fd_flags == FD_LEVEL)</a>
<a name="ln1373">          nfp[i].fd_flags = FD_LEVEL;</a>
<a name="ln1374">        if (fp-&gt;fd_small == kNone) {</a>
<a name="ln1375">          nfp[i].fd_small = kNone;</a>
<a name="ln1376">        }</a>
<a name="ln1377">      }</a>
<a name="ln1378"> </a>
<a name="ln1379">      // move the existing folds down to make room</a>
<a name="ln1380">      if (idx + 1 &lt; gap-&gt;ga_len) {</a>
<a name="ln1381">        memmove(fp + moved, fp + 1,</a>
<a name="ln1382">                sizeof(*fp) * (size_t)(gap-&gt;ga_len - (idx + 1)));</a>
<a name="ln1383">      }</a>
<a name="ln1384">      // move the contained folds one level up</a>
<a name="ln1385">      memmove(fp, nfp, sizeof(*fp) * (size_t)moved);</a>
<a name="ln1386">      xfree(nfp);</a>
<a name="ln1387">      gap-&gt;ga_len += moved - 1;</a>
<a name="ln1388">    }</a>
<a name="ln1389">  }</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">/* deleteFoldRecurse() {{{2 */</a>
<a name="ln1393">/*</a>
<a name="ln1394"> * Delete nested folds in a fold.</a>
<a name="ln1395"> */</a>
<a name="ln1396">void deleteFoldRecurse(buf_T *bp, garray_T *gap)</a>
<a name="ln1397">{</a>
<a name="ln1398"># define DELETE_FOLD_NESTED(fd) deleteFoldRecurse(bp, &amp;((fd)-&gt;fd_nested))</a>
<a name="ln1399">  GA_DEEP_CLEAR(gap, fold_T, DELETE_FOLD_NESTED);</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">/* foldMarkAdjust() {{{2 */</a>
<a name="ln1403">/*</a>
<a name="ln1404"> * Update line numbers of folds for inserted/deleted lines.</a>
<a name="ln1405"> */</a>
<a name="ln1406">void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after)</a>
<a name="ln1407">{</a>
<a name="ln1408">  /* If deleting marks from line1 to line2, but not deleting all those</a>
<a name="ln1409">   * lines, set line2 so that only deleted lines have their folds removed. */</a>
<a name="ln1410">  if (amount == MAXLNUM &amp;&amp; line2 &gt;= line1 &amp;&amp; line2 - line1 &gt;= -amount_after)</a>
<a name="ln1411">    line2 = line1 - amount_after - 1;</a>
<a name="ln1412">  /* If appending a line in Insert mode, it should be included in the fold</a>
<a name="ln1413">   * just above the line. */</a>
<a name="ln1414">  if ((State &amp; INSERT) &amp;&amp; amount == (linenr_T)1 &amp;&amp; line2 == MAXLNUM) {</a>
<a name="ln1415">    line1--;</a>
<a name="ln1416">  }</a>
<a name="ln1417">  foldMarkAdjustRecurse(wp, &amp;wp-&gt;w_folds, line1, line2, amount, amount_after);</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">// foldMarkAdjustRecurse() {{{2</a>
<a name="ln1421">static void foldMarkAdjustRecurse(</a>
<a name="ln1422">    win_T *wp, garray_T *gap,</a>
<a name="ln1423">    linenr_T line1, linenr_T line2, long amount, long amount_after</a>
<a name="ln1424">)</a>
<a name="ln1425">{</a>
<a name="ln1426">  fold_T      *fp;</a>
<a name="ln1427">  linenr_T last;</a>
<a name="ln1428">  linenr_T top;</a>
<a name="ln1429"> </a>
<a name="ln1430">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln1431">    return;</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  /* In Insert mode an inserted line at the top of a fold is considered part</a>
<a name="ln1435">   * of the fold, otherwise it isn't. */</a>
<a name="ln1436">  if ((State &amp; INSERT) &amp;&amp; amount == (linenr_T)1 &amp;&amp; line2 == MAXLNUM)</a>
<a name="ln1437">    top = line1 + 1;</a>
<a name="ln1438">  else</a>
<a name="ln1439">    top = line1;</a>
<a name="ln1440"> </a>
<a name="ln1441">  /* Find the fold containing or just below &quot;line1&quot;. */</a>
<a name="ln1442">  (void)foldFind(gap, line1, &amp;fp);</a>
<a name="ln1443"> </a>
<a name="ln1444">  /*</a>
<a name="ln1445">   * Adjust all folds below &quot;line1&quot; that are affected.</a>
<a name="ln1446">   */</a>
<a name="ln1447">  for (int i = (int)(fp - (fold_T *)gap-&gt;ga_data); i &lt; gap-&gt;ga_len; ++i, ++fp) {</a>
<a name="ln1448">    /*</a>
<a name="ln1449">     * Check for these situations:</a>
<a name="ln1450">     *	  1  2	3</a>
<a name="ln1451">     *	  1  2	3</a>
<a name="ln1452">     * line1     2	3  4  5</a>
<a name="ln1453">     *	     2	3  4  5</a>
<a name="ln1454">     *	     2	3  4  5</a>
<a name="ln1455">     * line2     2	3  4  5</a>
<a name="ln1456">     *		3     5  6</a>
<a name="ln1457">     *		3     5  6</a>
<a name="ln1458">     */</a>
<a name="ln1459"> </a>
<a name="ln1460">    last = fp-&gt;fd_top + fp-&gt;fd_len - 1;     /* last line of fold */</a>
<a name="ln1461"> </a>
<a name="ln1462">    /* 1. fold completely above line1: nothing to do */</a>
<a name="ln1463">    if (last &lt; line1)</a>
<a name="ln1464">      continue;</a>
<a name="ln1465"> </a>
<a name="ln1466">    /* 6. fold below line2: only adjust for amount_after */</a>
<a name="ln1467">    if (fp-&gt;fd_top &gt; line2) {</a>
<a name="ln1468">      if (amount_after == 0)</a>
<a name="ln1469">        break;</a>
<a name="ln1470">      fp-&gt;fd_top += amount_after;</a>
<a name="ln1471">    } else {</a>
<a name="ln1472">      if (fp-&gt;fd_top &gt;= top &amp;&amp; last &lt;= line2) {</a>
<a name="ln1473">        // 4. fold completely contained in range</a>
<a name="ln1474">        if (amount == MAXLNUM) {</a>
<a name="ln1475">          // Deleting lines: delete the fold completely</a>
<a name="ln1476">          deleteFoldEntry(wp, gap, i, true);</a>
<a name="ln1477">          i--;              // adjust index for deletion</a>
<a name="ln1478">          fp--;</a>
<a name="ln1479">        } else {</a>
<a name="ln1480">          fp-&gt;fd_top += amount;</a>
<a name="ln1481">        }</a>
<a name="ln1482">      } else {</a>
<a name="ln1483">        if (fp-&gt;fd_top &lt; top) {</a>
<a name="ln1484">          // 2 or 3: need to correct nested folds too</a>
<a name="ln1485">          foldMarkAdjustRecurse(wp, &amp;fp-&gt;fd_nested, line1 - fp-&gt;fd_top,</a>
<a name="ln1486">                                line2 - fp-&gt;fd_top, amount, amount_after);</a>
<a name="ln1487">          if (last &lt;= line2) {</a>
<a name="ln1488">            /* 2. fold contains line1, line2 is below fold */</a>
<a name="ln1489">            if (amount == MAXLNUM)</a>
<a name="ln1490">              fp-&gt;fd_len = line1 - fp-&gt;fd_top;</a>
<a name="ln1491">            else</a>
<a name="ln1492">              fp-&gt;fd_len += amount;</a>
<a name="ln1493">          } else {</a>
<a name="ln1494">            /* 3. fold contains line1 and line2 */</a>
<a name="ln1495">            fp-&gt;fd_len += amount_after;</a>
<a name="ln1496">          }</a>
<a name="ln1497">        } else {</a>
<a name="ln1498">          /* 5. fold is below line1 and contains line2; need to</a>
<a name="ln1499">           * correct nested folds too */</a>
<a name="ln1500">          if (amount == MAXLNUM) {</a>
<a name="ln1501">            foldMarkAdjustRecurse(wp, &amp;fp-&gt;fd_nested, line1 - fp-&gt;fd_top,</a>
<a name="ln1502">                                  line2 - fp-&gt;fd_top, amount,</a>
<a name="ln1503">                                  amount_after + (fp-&gt;fd_top - top));</a>
<a name="ln1504">            fp-&gt;fd_len -= line2 - fp-&gt;fd_top + 1;</a>
<a name="ln1505">            fp-&gt;fd_top = line1;</a>
<a name="ln1506">          } else {</a>
<a name="ln1507">            foldMarkAdjustRecurse(wp, &amp;fp-&gt;fd_nested, line1 - fp-&gt;fd_top,</a>
<a name="ln1508">                                  line2 - fp-&gt;fd_top, amount,</a>
<a name="ln1509">                                  amount_after - amount);</a>
<a name="ln1510">            fp-&gt;fd_len += amount_after - amount;</a>
<a name="ln1511">            fp-&gt;fd_top += amount;</a>
<a name="ln1512">          }</a>
<a name="ln1513">        }</a>
<a name="ln1514">      }</a>
<a name="ln1515">    }</a>
<a name="ln1516">  }</a>
<a name="ln1517">}</a>
<a name="ln1518"> </a>
<a name="ln1519">/* getDeepestNesting() {{{2 */</a>
<a name="ln1520">/*</a>
<a name="ln1521"> * Get the lowest 'foldlevel' value that makes the deepest nested fold in the</a>
<a name="ln1522"> * current window open.</a>
<a name="ln1523"> */</a>
<a name="ln1524">int getDeepestNesting(win_T *wp)</a>
<a name="ln1525">{</a>
<a name="ln1526">  checkupdate(wp);</a>
<a name="ln1527">  return getDeepestNestingRecurse(&amp;wp-&gt;w_folds);</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530">static int getDeepestNestingRecurse(garray_T *gap)</a>
<a name="ln1531">{</a>
<a name="ln1532">  int level;</a>
<a name="ln1533">  int maxlevel = 0;</a>
<a name="ln1534">  fold_T      *fp;</a>
<a name="ln1535"> </a>
<a name="ln1536">  fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln1537">  for (int i = 0; i &lt; gap-&gt;ga_len; ++i) {</a>
<a name="ln1538">    level = getDeepestNestingRecurse(&amp;fp[i].fd_nested) + 1;</a>
<a name="ln1539">    if (level &gt; maxlevel)</a>
<a name="ln1540">      maxlevel = level;</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  return maxlevel;</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">// check_closed() {{{2</a>
<a name="ln1547">/// Check if a fold is closed and update the info needed to check nested folds.</a>
<a name="ln1548">///</a>
<a name="ln1549">/// @param[in,out] use_levelp true: outer fold had FD_LEVEL</a>
<a name="ln1550">/// @param[in,out] fp fold to check</a>
<a name="ln1551">/// @param level folding depth</a>
<a name="ln1552">/// @param[out] maybe_smallp true: outer this had fd_small == kNone</a>
<a name="ln1553">/// @param lnum_off line number offset for fp-&gt;fd_top</a>
<a name="ln1554">/// @return true if fold is closed</a>
<a name="ln1555">static bool check_closed(</a>
<a name="ln1556">    win_T *const wp,</a>
<a name="ln1557">    fold_T *const fp,</a>
<a name="ln1558">    bool *const use_levelp,</a>
<a name="ln1559">    const int level,</a>
<a name="ln1560">    bool *const maybe_smallp,</a>
<a name="ln1561">    const linenr_T lnum_off</a>
<a name="ln1562">)</a>
<a name="ln1563">{</a>
<a name="ln1564">  bool closed = false;</a>
<a name="ln1565"> </a>
<a name="ln1566">  /* Check if this fold is closed.  If the flag is FD_LEVEL this</a>
<a name="ln1567">   * fold and all folds it contains depend on 'foldlevel'. */</a>
<a name="ln1568">  if (*use_levelp || fp-&gt;fd_flags == FD_LEVEL) {</a>
<a name="ln1569">    *use_levelp = true;</a>
<a name="ln1570">    if (level &gt;= wp-&gt;w_p_fdl) {</a>
<a name="ln1571">      closed = true;</a>
<a name="ln1572">    }</a>
<a name="ln1573">  } else if (fp-&gt;fd_flags == FD_CLOSED) {</a>
<a name="ln1574">    closed = true;</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  // Small fold isn't closed anyway.</a>
<a name="ln1578">  if (fp-&gt;fd_small == kNone) {</a>
<a name="ln1579">    *maybe_smallp = true;</a>
<a name="ln1580">  }</a>
<a name="ln1581">  if (closed) {</a>
<a name="ln1582">    if (*maybe_smallp) {</a>
<a name="ln1583">      fp-&gt;fd_small = kNone;</a>
<a name="ln1584">    }</a>
<a name="ln1585">    checkSmall(wp, fp, lnum_off);</a>
<a name="ln1586">    if (fp-&gt;fd_small == kTrue) {</a>
<a name="ln1587">      closed = false;</a>
<a name="ln1588">    }</a>
<a name="ln1589">  }</a>
<a name="ln1590">  return closed;</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">// checkSmall() {{{2</a>
<a name="ln1594">/// Update fd_small field of fold &quot;fp&quot;.</a>
<a name="ln1595">/// @param lnum_off offset for fp-&gt;fd_top</a>
<a name="ln1596">static void</a>
<a name="ln1597">checkSmall(</a>
<a name="ln1598">    win_T *const wp,</a>
<a name="ln1599">    fold_T *const fp,</a>
<a name="ln1600">    const linenr_T lnum_off       // offset for fp-&gt;fd_top</a>
<a name="ln1601">)</a>
<a name="ln1602">{</a>
<a name="ln1603">  if (fp-&gt;fd_small == kNone) {</a>
<a name="ln1604">    // Mark any nested folds to maybe-small</a>
<a name="ln1605">    setSmallMaybe(&amp;fp-&gt;fd_nested);</a>
<a name="ln1606"> </a>
<a name="ln1607">    if (fp-&gt;fd_len &gt; wp-&gt;w_p_fml) {</a>
<a name="ln1608">      fp-&gt;fd_small = kFalse;</a>
<a name="ln1609">    } else {</a>
<a name="ln1610">      int count = 0;</a>
<a name="ln1611">      for (int n = 0; n &lt; fp-&gt;fd_len; n++) {</a>
<a name="ln1612">        count += plines_win_nofold(wp, fp-&gt;fd_top + lnum_off + n);</a>
<a name="ln1613">        if (count &gt; wp-&gt;w_p_fml) {</a>
<a name="ln1614">          fp-&gt;fd_small = kFalse;</a>
<a name="ln1615">          return;</a>
<a name="ln1616">        }</a>
<a name="ln1617">      }</a>
<a name="ln1618">      fp-&gt;fd_small = kTrue;</a>
<a name="ln1619">    }</a>
<a name="ln1620">  }</a>
<a name="ln1621">}</a>
<a name="ln1622"> </a>
<a name="ln1623">// setSmallMaybe() {{{2</a>
<a name="ln1624">// Set small flags in &quot;gap&quot; to kNone.</a>
<a name="ln1625">static void setSmallMaybe(garray_T *gap)</a>
<a name="ln1626">{</a>
<a name="ln1627">  fold_T *fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln1628">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln1629">    fp[i].fd_small = kNone;</a>
<a name="ln1630">  }</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">/* foldCreateMarkers() {{{2 */</a>
<a name="ln1634">/*</a>
<a name="ln1635"> * Create a fold from line &quot;start&quot; to line &quot;end&quot; (inclusive) in the current</a>
<a name="ln1636"> * window by adding markers.</a>
<a name="ln1637"> */</a>
<a name="ln1638">static void foldCreateMarkers(win_T *wp, pos_T start, pos_T end)</a>
<a name="ln1639">{</a>
<a name="ln1640">  buf_T *buf = wp-&gt;w_buffer;</a>
<a name="ln1641">  if (!MODIFIABLE(buf)) {</a>
<a name="ln1642">    EMSG(_(e_modifiable));</a>
<a name="ln1643">    return;</a>
<a name="ln1644">  }</a>
<a name="ln1645">  parseMarker(wp);</a>
<a name="ln1646"> </a>
<a name="ln1647">  foldAddMarker(buf, start, wp-&gt;w_p_fmr, foldstartmarkerlen);</a>
<a name="ln1648">  foldAddMarker(buf, end, foldendmarker, foldendmarkerlen);</a>
<a name="ln1649"> </a>
<a name="ln1650">  /* Update both changes here, to avoid all folds after the start are</a>
<a name="ln1651">   * changed when the start marker is inserted and the end isn't. */</a>
<a name="ln1652">  // TODO(teto): pass the buffer</a>
<a name="ln1653">  changed_lines(start.lnum, (colnr_T)0, end.lnum, 0L, false);</a>
<a name="ln1654"> </a>
<a name="ln1655">  // Note: foldAddMarker() may not actually change start and/or end if</a>
<a name="ln1656">  // u_save() is unable to save the buffer line, but we send the</a>
<a name="ln1657">  // nvim_buf_lines_event anyway since it won't do any harm.</a>
<a name="ln1658">  int64_t num_changed = 1 + end.lnum - start.lnum;</a>
<a name="ln1659">  buf_updates_send_changes(buf, start.lnum, num_changed, num_changed, true);</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662">/* foldAddMarker() {{{2 */</a>
<a name="ln1663">/*</a>
<a name="ln1664"> * Add &quot;marker[markerlen]&quot; in 'commentstring' to line &quot;lnum&quot;.</a>
<a name="ln1665"> */</a>
<a name="ln1666">static void foldAddMarker(</a>
<a name="ln1667">    buf_T *buf, pos_T pos, const char_u *marker, size_t markerlen)</a>
<a name="ln1668">{</a>
<a name="ln1669">  char_u      *cms = buf-&gt;b_p_cms;</a>
<a name="ln1670">  char_u      *line;</a>
<a name="ln1671">  char_u      *newline;</a>
<a name="ln1672">  char_u      *p = (char_u *)strstr((char *)buf-&gt;b_p_cms, &quot;%s&quot;);</a>
<a name="ln1673">  bool line_is_comment = false;</a>
<a name="ln1674">  linenr_T lnum = pos.lnum;</a>
<a name="ln1675"> </a>
<a name="ln1676">  // Allocate a new line: old-line + 'cms'-start + marker + 'cms'-end</a>
<a name="ln1677">  line = ml_get_buf(buf, lnum, false);</a>
<a name="ln1678">  size_t line_len = STRLEN(line);</a>
<a name="ln1679">  size_t added = 0;</a>
<a name="ln1680"> </a>
<a name="ln1681">  if (u_save(lnum - 1, lnum + 1) == OK) {</a>
<a name="ln1682">    // Check if the line ends with an unclosed comment</a>
<a name="ln1683">    skip_comment(line, false, false, &amp;line_is_comment);</a>
<a name="ln1684">    newline = xmalloc(line_len + markerlen + STRLEN(cms) + 1);</a>
<a name="ln1685">    STRCPY(newline, line);</a>
<a name="ln1686">    // Append the marker to the end of the line</a>
<a name="ln1687">    if (p == NULL || line_is_comment) {</a>
<a name="ln1688">      STRLCPY(newline + line_len, marker, markerlen + 1);</a>
<a name="ln1689">      added = markerlen;</a>
<a name="ln1690">    } else {</a>
<a name="ln1691">      STRCPY(newline + line_len, cms);</a>
<a name="ln1692">      memcpy(newline + line_len + (p - cms), marker, markerlen);</a>
<a name="ln1693">      STRCPY(newline + line_len + (p - cms) + markerlen, p + 2);</a>
<a name="ln1694">      added = markerlen + STRLEN(cms)-2;</a>
<a name="ln1695">    }</a>
<a name="ln1696">    ml_replace_buf(buf, lnum, newline, false);</a>
<a name="ln1697">    if (added) {</a>
<a name="ln1698">      extmark_splice_cols(buf, (int)lnum-1, (int)line_len,</a>
<a name="ln1699">                          0, (int)added, kExtmarkUndo);</a>
<a name="ln1700">    }</a>
<a name="ln1701">  }</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">/* deleteFoldMarkers() {{{2 */</a>
<a name="ln1705">/*</a>
<a name="ln1706"> * Delete the markers for a fold, causing it to be deleted.</a>
<a name="ln1707"> */</a>
<a name="ln1708">static void</a>
<a name="ln1709">deleteFoldMarkers(</a>
<a name="ln1710">    win_T *wp,</a>
<a name="ln1711">    fold_T *fp,</a>
<a name="ln1712">    int recursive,</a>
<a name="ln1713">    linenr_T lnum_off             // offset for fp-&gt;fd_top</a>
<a name="ln1714">)</a>
<a name="ln1715">{</a>
<a name="ln1716">  if (recursive) {</a>
<a name="ln1717">    for (int i = 0; i &lt; fp-&gt;fd_nested.ga_len; i++) {</a>
<a name="ln1718">      deleteFoldMarkers(wp, (fold_T *)fp-&gt;fd_nested.ga_data + i, true,</a>
<a name="ln1719">                        lnum_off + fp-&gt;fd_top);</a>
<a name="ln1720">    }</a>
<a name="ln1721">  }</a>
<a name="ln1722">  foldDelMarker(wp-&gt;w_buffer, fp-&gt;fd_top+lnum_off, wp-&gt;w_p_fmr,</a>
<a name="ln1723">                foldstartmarkerlen);</a>
<a name="ln1724">  foldDelMarker(wp-&gt;w_buffer, fp-&gt;fd_top + lnum_off + fp-&gt;fd_len - 1,</a>
<a name="ln1725">                foldendmarker, foldendmarkerlen);</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">// foldDelMarker() {{{2</a>
<a name="ln1729">//</a>
<a name="ln1730">// Delete marker &quot;marker[markerlen]&quot; at the end of line &quot;lnum&quot;.</a>
<a name="ln1731">// Delete 'commentstring' if it matches.</a>
<a name="ln1732">// If the marker is not found, there is no error message.  Could be a missing</a>
<a name="ln1733">// close-marker.</a>
<a name="ln1734">static void foldDelMarker(</a>
<a name="ln1735">    buf_T *buf, linenr_T lnum, char_u *marker, size_t markerlen</a>
<a name="ln1736">)</a>
<a name="ln1737">{</a>
<a name="ln1738">  char_u      *newline;</a>
<a name="ln1739">  char_u      *cms = buf-&gt;b_p_cms;</a>
<a name="ln1740">  char_u      *cms2;</a>
<a name="ln1741"> </a>
<a name="ln1742">  // end marker may be missing and fold extends below the last line</a>
<a name="ln1743">  if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1744">    return;</a>
<a name="ln1745">  }</a>
<a name="ln1746">  char_u *line = ml_get_buf(buf, lnum, false);</a>
<a name="ln1747">  for (char_u *p = line; *p != NUL; p++) {</a>
<a name="ln1748">    if (STRNCMP(p, marker, markerlen) != 0) {</a>
<a name="ln1749">      continue;</a>
<a name="ln1750">    }</a>
<a name="ln1751">    /* Found the marker, include a digit if it's there. */</a>
<a name="ln1752">    size_t len = markerlen;</a>
<a name="ln1753">    if (ascii_isdigit(p[len]))</a>
<a name="ln1754">      ++len;</a>
<a name="ln1755">    if (*cms != NUL) {</a>
<a name="ln1756">      /* Also delete 'commentstring' if it matches. */</a>
<a name="ln1757">      cms2 = (char_u *)strstr((char *)cms, &quot;%s&quot;);</a>
<a name="ln1758">      if (p - line &gt;= cms2 - cms</a>
<a name="ln1759">          &amp;&amp; STRNCMP(p - (cms2 - cms), cms, cms2 - cms) == 0</a>
<a name="ln1760">          &amp;&amp; STRNCMP(p + len, cms2 + 2, STRLEN(cms2 + 2)) == 0) {</a>
<a name="ln1761">        p -= cms2 - cms;</a>
<a name="ln1762">        len += STRLEN(cms) - 2;</a>
<a name="ln1763">      }</a>
<a name="ln1764">    }</a>
<a name="ln1765">    if (u_save(lnum - 1, lnum + 1) == OK) {</a>
<a name="ln1766">      /* Make new line: text-before-marker + text-after-marker */</a>
<a name="ln1767">      newline = xmalloc(STRLEN(line) - len + 1);</a>
<a name="ln1768">      assert(p &gt;= line);</a>
<a name="ln1769">      memcpy(newline, line, (size_t)(p - line));</a>
<a name="ln1770">      STRCPY(newline + (p - line), p + len);</a>
<a name="ln1771">      ml_replace_buf(buf, lnum, newline, false);</a>
<a name="ln1772">      extmark_splice_cols(buf, (int)lnum-1, (int)(p - line),</a>
<a name="ln1773">                          (int)len, 0, kExtmarkUndo);</a>
<a name="ln1774">    }</a>
<a name="ln1775">    break;</a>
<a name="ln1776">  }</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">// get_foldtext() {{{2</a>
<a name="ln1780">/// Generates text to display</a>
<a name="ln1781">///</a>
<a name="ln1782">/// @param buf allocated memory of length FOLD_TEXT_LEN. Used when 'foldtext'</a>
<a name="ln1783">///            isn't set puts the result in &quot;buf[FOLD_TEXT_LEN]&quot;.</a>
<a name="ln1784">/// @param at line &quot;lnum&quot;, with last line &quot;lnume&quot;.</a>
<a name="ln1785">/// @return the text for a closed fold</a>
<a name="ln1786">///</a>
<a name="ln1787">/// Otherwise the result is in allocated memory.</a>
<a name="ln1788">char_u *get_foldtext(win_T *wp, linenr_T lnum, linenr_T lnume,</a>
<a name="ln1789">                     foldinfo_T foldinfo, char_u *buf)</a>
<a name="ln1790">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1791">{</a>
<a name="ln1792">  char_u      *text = NULL;</a>
<a name="ln1793">  /* an error occurred when evaluating 'fdt' setting */</a>
<a name="ln1794">  static int got_fdt_error = FALSE;</a>
<a name="ln1795">  int save_did_emsg = did_emsg;</a>
<a name="ln1796">  static win_T    *last_wp = NULL;</a>
<a name="ln1797">  static linenr_T last_lnum = 0;</a>
<a name="ln1798"> </a>
<a name="ln1799">  if (last_wp == NULL || last_wp != wp || last_lnum &gt; lnum || last_lnum == 0)</a>
<a name="ln1800">    /* window changed, try evaluating foldtext setting once again */</a>
<a name="ln1801">    got_fdt_error = FALSE;</a>
<a name="ln1802"> </a>
<a name="ln1803">  if (!got_fdt_error)</a>
<a name="ln1804">    /* a previous error should not abort evaluating 'foldexpr' */</a>
<a name="ln1805">    did_emsg = FALSE;</a>
<a name="ln1806"> </a>
<a name="ln1807">  if (*wp-&gt;w_p_fdt != NUL) {</a>
<a name="ln1808">    char dashes[MAX_LEVEL + 2];</a>
<a name="ln1809">    win_T   *save_curwin;</a>
<a name="ln1810">    int level;</a>
<a name="ln1811">    char_u  *p;</a>
<a name="ln1812"> </a>
<a name="ln1813">    // Set &quot;v:foldstart&quot; and &quot;v:foldend&quot;.</a>
<a name="ln1814">    set_vim_var_nr(VV_FOLDSTART, (varnumber_T) lnum);</a>
<a name="ln1815">    set_vim_var_nr(VV_FOLDEND, (varnumber_T) lnume);</a>
<a name="ln1816"> </a>
<a name="ln1817">    // Set &quot;v:folddashes&quot; to a string of &quot;level&quot; dashes.</a>
<a name="ln1818">    // Set &quot;v:foldlevel&quot; to &quot;level&quot;.</a>
<a name="ln1819">    level = foldinfo.fi_level;</a>
<a name="ln1820">    if (level &gt; (int)sizeof(dashes) - 1) {</a>
<a name="ln1821">      level = (int)sizeof(dashes) - 1;</a>
<a name="ln1822">    }</a>
<a name="ln1823">    memset(dashes, '-', (size_t)level);</a>
<a name="ln1824">    dashes[level] = NUL;</a>
<a name="ln1825">    set_vim_var_string(VV_FOLDDASHES, dashes, -1);</a>
<a name="ln1826">    set_vim_var_nr(VV_FOLDLEVEL, (varnumber_T) level);</a>
<a name="ln1827"> </a>
<a name="ln1828">    /* skip evaluating foldtext on errors */</a>
<a name="ln1829">    if (!got_fdt_error) {</a>
<a name="ln1830">      save_curwin = curwin;</a>
<a name="ln1831">      curwin = wp;</a>
<a name="ln1832">      curbuf = wp-&gt;w_buffer;</a>
<a name="ln1833"> </a>
<a name="ln1834">      ++emsg_silent;       /* handle exceptions, but don't display errors */</a>
<a name="ln1835">      text = eval_to_string_safe(wp-&gt;w_p_fdt, NULL,</a>
<a name="ln1836">          was_set_insecurely((char_u *)&quot;foldtext&quot;, OPT_LOCAL));</a>
<a name="ln1837">      --emsg_silent;</a>
<a name="ln1838"> </a>
<a name="ln1839">      if (text == NULL || did_emsg)</a>
<a name="ln1840">        got_fdt_error = TRUE;</a>
<a name="ln1841"> </a>
<a name="ln1842">      curwin = save_curwin;</a>
<a name="ln1843">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln1844">    }</a>
<a name="ln1845">    last_lnum = lnum;</a>
<a name="ln1846">    last_wp   = wp;</a>
<a name="ln1847">    set_vim_var_string(VV_FOLDDASHES, NULL, -1);</a>
<a name="ln1848"> </a>
<a name="ln1849">    if (!did_emsg &amp;&amp; save_did_emsg)</a>
<a name="ln1850">      did_emsg = save_did_emsg;</a>
<a name="ln1851"> </a>
<a name="ln1852">    if (text != NULL) {</a>
<a name="ln1853">      /* Replace unprintable characters, if there are any.  But</a>
<a name="ln1854">       * replace a TAB with a space. */</a>
<a name="ln1855">      for (p = text; *p != NUL; p++) {</a>
<a name="ln1856">        int len = utfc_ptr2len(p);</a>
<a name="ln1857"> </a>
<a name="ln1858">        if (len &gt; 1) {</a>
<a name="ln1859">          if (!vim_isprintc(utf_ptr2char(p))) {</a>
<a name="ln1860">            break;</a>
<a name="ln1861">          }</a>
<a name="ln1862">          p += len - 1;</a>
<a name="ln1863">        } else if (*p == TAB)</a>
<a name="ln1864">          *p = ' ';</a>
<a name="ln1865">        else if (ptr2cells(p) &gt; 1)</a>
<a name="ln1866">          break;</a>
<a name="ln1867">      }</a>
<a name="ln1868">      if (*p != NUL) {</a>
<a name="ln1869">        p = (char_u *)transstr((const char *)text);</a>
<a name="ln1870">        xfree(text);</a>
<a name="ln1871">        text = p;</a>
<a name="ln1872">      }</a>
<a name="ln1873">    }</a>
<a name="ln1874">  }</a>
<a name="ln1875">  if (text == NULL) {</a>
<a name="ln1876">    unsigned long count = (unsigned long)(lnume - lnum + 1);</a>
<a name="ln1877"> </a>
<a name="ln1878">    vim_snprintf((char *)buf, FOLD_TEXT_LEN,</a>
<a name="ln1879">                 NGETTEXT(&quot;+--%3ld line folded&quot;,</a>
<a name="ln1880">                          &quot;+--%3ld lines folded &quot;, count),</a>
<a name="ln1881">                 count);</a>
<a name="ln1882">    text = buf;</a>
<a name="ln1883">  }</a>
<a name="ln1884">  return text;</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">/* foldtext_cleanup() {{{2 */</a>
<a name="ln1888">/*</a>
<a name="ln1889"> * Remove 'foldmarker' and 'commentstring' from &quot;str&quot; (in-place).</a>
<a name="ln1890"> */</a>
<a name="ln1891">void foldtext_cleanup(char_u *str)</a>
<a name="ln1892">{</a>
<a name="ln1893">  char_u      *s;</a>
<a name="ln1894">  char_u      *p;</a>
<a name="ln1895">  int did1 = FALSE;</a>
<a name="ln1896">  int did2 = FALSE;</a>
<a name="ln1897"> </a>
<a name="ln1898">  /* Ignore leading and trailing white space in 'commentstring'. */</a>
<a name="ln1899">  char_u *cms_start = skipwhite(curbuf-&gt;b_p_cms);</a>
<a name="ln1900">  size_t cms_slen = STRLEN(cms_start);</a>
<a name="ln1901">  while (cms_slen &gt; 0 &amp;&amp; ascii_iswhite(cms_start[cms_slen - 1]))</a>
<a name="ln1902">    --cms_slen;</a>
<a name="ln1903"> </a>
<a name="ln1904">  /* locate &quot;%s&quot; in 'commentstring', use the part before and after it. */</a>
<a name="ln1905">  char_u *cms_end = (char_u *)strstr((char *)cms_start, &quot;%s&quot;);</a>
<a name="ln1906">  size_t cms_elen = 0;</a>
<a name="ln1907">  if (cms_end != NULL) {</a>
<a name="ln1908">    cms_elen = cms_slen - (size_t)(cms_end - cms_start);</a>
<a name="ln1909">    cms_slen = (size_t)(cms_end - cms_start);</a>
<a name="ln1910"> </a>
<a name="ln1911">    /* exclude white space before &quot;%s&quot; */</a>
<a name="ln1912">    while (cms_slen &gt; 0 &amp;&amp; ascii_iswhite(cms_start[cms_slen - 1]))</a>
<a name="ln1913">      --cms_slen;</a>
<a name="ln1914"> </a>
<a name="ln1915">    /* skip &quot;%s&quot; and white space after it */</a>
<a name="ln1916">    s = skipwhite(cms_end + 2);</a>
<a name="ln1917">    cms_elen -= (size_t)(s - cms_end);</a>
<a name="ln1918">    cms_end = s;</a>
<a name="ln1919">  }</a>
<a name="ln1920">  parseMarker(curwin);</a>
<a name="ln1921"> </a>
<a name="ln1922">  for (s = str; *s != NUL; ) {</a>
<a name="ln1923">    size_t len = 0;</a>
<a name="ln1924">    if (STRNCMP(s, curwin-&gt;w_p_fmr, foldstartmarkerlen) == 0)</a>
<a name="ln1925">      len = foldstartmarkerlen;</a>
<a name="ln1926">    else if (STRNCMP(s, foldendmarker, foldendmarkerlen) == 0)</a>
<a name="ln1927">      len = foldendmarkerlen;</a>
<a name="ln1928">    if (len &gt; 0) {</a>
<a name="ln1929">      if (ascii_isdigit(s[len]))</a>
<a name="ln1930">        ++len;</a>
<a name="ln1931"> </a>
<a name="ln1932">      /* May remove 'commentstring' start.  Useful when it's a double</a>
<a name="ln1933">       * quote and we already removed a double quote. */</a>
<a name="ln1934">      for (p = s; p &gt; str &amp;&amp; ascii_iswhite(p[-1]); --p)</a>
<a name="ln1935">        ;</a>
<a name="ln1936">      if (p &gt;= str + cms_slen</a>
<a name="ln1937">          &amp;&amp; STRNCMP(p - cms_slen, cms_start, cms_slen) == 0) {</a>
<a name="ln1938">        len += (size_t)(s - p) + cms_slen;</a>
<a name="ln1939">        s = p - cms_slen;</a>
<a name="ln1940">      }</a>
<a name="ln1941">    } else if (cms_end != NULL) {</a>
<a name="ln1942">      if (!did1 &amp;&amp; cms_slen &gt; 0 &amp;&amp; STRNCMP(s, cms_start, cms_slen) == 0) {</a>
<a name="ln1943">        len = cms_slen;</a>
<a name="ln1944">        did1 = TRUE;</a>
<a name="ln1945">      } else if (!did2 &amp;&amp; cms_elen &gt; 0</a>
<a name="ln1946">                 &amp;&amp; STRNCMP(s, cms_end, cms_elen) == 0) {</a>
<a name="ln1947">        len = cms_elen;</a>
<a name="ln1948">        did2 = TRUE;</a>
<a name="ln1949">      }</a>
<a name="ln1950">    }</a>
<a name="ln1951">    if (len != 0) {</a>
<a name="ln1952">      while (ascii_iswhite(s[len]))</a>
<a name="ln1953">        ++len;</a>
<a name="ln1954">      STRMOVE(s, s + len);</a>
<a name="ln1955">    } else {</a>
<a name="ln1956">      MB_PTR_ADV(s);</a>
<a name="ln1957">    }</a>
<a name="ln1958">  }</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">/* Folding by indent, expr, marker and syntax. {{{1 */</a>
<a name="ln1962">/* Function declarations. {{{2 */</a>
<a name="ln1963"> </a>
<a name="ln1964">/* foldUpdateIEMS() {{{2 */</a>
<a name="ln1965">/*</a>
<a name="ln1966"> * Update the folding for window &quot;wp&quot;, at least from lines &quot;top&quot; to &quot;bot&quot;.</a>
<a name="ln1967"> * IEMS = &quot;Indent Expr Marker Syntax&quot;</a>
<a name="ln1968"> */</a>
<a name="ln1969">static void foldUpdateIEMS(win_T *const wp, linenr_T top, linenr_T bot)</a>
<a name="ln1970">{</a>
<a name="ln1971">  fline_T fline;</a>
<a name="ln1972">  LevelGetter getlevel = NULL;</a>
<a name="ln1973">  fold_T      *fp;</a>
<a name="ln1974"> </a>
<a name="ln1975">  /* Avoid problems when being called recursively. */</a>
<a name="ln1976">  if (invalid_top != (linenr_T)0)</a>
<a name="ln1977">    return;</a>
<a name="ln1978"> </a>
<a name="ln1979">  if (wp-&gt;w_foldinvalid) {</a>
<a name="ln1980">    /* Need to update all folds. */</a>
<a name="ln1981">    top = 1;</a>
<a name="ln1982">    bot = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1983">    wp-&gt;w_foldinvalid = false;</a>
<a name="ln1984"> </a>
<a name="ln1985">    /* Mark all folds a maybe-small. */</a>
<a name="ln1986">    setSmallMaybe(&amp;wp-&gt;w_folds);</a>
<a name="ln1987">  }</a>
<a name="ln1988"> </a>
<a name="ln1989">  /* add the context for &quot;diff&quot; folding */</a>
<a name="ln1990">  if (foldmethodIsDiff(wp)) {</a>
<a name="ln1991">    if (top &gt; diff_context)</a>
<a name="ln1992">      top -= diff_context;</a>
<a name="ln1993">    else</a>
<a name="ln1994">      top = 1;</a>
<a name="ln1995">    bot += diff_context;</a>
<a name="ln1996">  }</a>
<a name="ln1997"> </a>
<a name="ln1998">  // When deleting lines at the end of the buffer &quot;top&quot; can be past the end</a>
<a name="ln1999">  // of the buffer.</a>
<a name="ln2000">  if (top &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln2001">    top = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln2002">  }</a>
<a name="ln2003"> </a>
<a name="ln2004">  fold_changed = false;</a>
<a name="ln2005">  fline.wp = wp;</a>
<a name="ln2006">  fline.off = 0;</a>
<a name="ln2007">  fline.lvl = 0;</a>
<a name="ln2008">  fline.lvl_next = -1;</a>
<a name="ln2009">  fline.start = 0;</a>
<a name="ln2010">  fline.end = MAX_LEVEL + 1;</a>
<a name="ln2011">  fline.had_end = MAX_LEVEL + 1;</a>
<a name="ln2012"> </a>
<a name="ln2013">  invalid_top = top;</a>
<a name="ln2014">  invalid_bot = bot;</a>
<a name="ln2015"> </a>
<a name="ln2016">  if (foldmethodIsMarker(wp)) {</a>
<a name="ln2017">    getlevel = foldlevelMarker;</a>
<a name="ln2018"> </a>
<a name="ln2019">    /* Init marker variables to speed up foldlevelMarker(). */</a>
<a name="ln2020">    parseMarker(wp);</a>
<a name="ln2021"> </a>
<a name="ln2022">    /* Need to get the level of the line above top, it is used if there is</a>
<a name="ln2023">     * no marker at the top. */</a>
<a name="ln2024">    if (top &gt; 1) {</a>
<a name="ln2025">      // Get the fold level at top - 1.</a>
<a name="ln2026">      const int level = foldLevelWin(wp, top - 1);</a>
<a name="ln2027"> </a>
<a name="ln2028">      /* The fold may end just above the top, check for that. */</a>
<a name="ln2029">      fline.lnum = top - 1;</a>
<a name="ln2030">      fline.lvl = level;</a>
<a name="ln2031">      getlevel(&amp;fline);</a>
<a name="ln2032"> </a>
<a name="ln2033">      /* If a fold started here, we already had the level, if it stops</a>
<a name="ln2034">       * here, we need to use lvl_next.  Could also start and end a fold</a>
<a name="ln2035">       * in the same line. */</a>
<a name="ln2036">      if (fline.lvl &gt; level)</a>
<a name="ln2037">        fline.lvl = level - (fline.lvl - fline.lvl_next);</a>
<a name="ln2038">      else</a>
<a name="ln2039">        fline.lvl = fline.lvl_next;</a>
<a name="ln2040">    }</a>
<a name="ln2041">    fline.lnum = top;</a>
<a name="ln2042">    getlevel(&amp;fline);</a>
<a name="ln2043">  } else {</a>
<a name="ln2044">    fline.lnum = top;</a>
<a name="ln2045">    if (foldmethodIsExpr(wp)) {</a>
<a name="ln2046">      getlevel = foldlevelExpr;</a>
<a name="ln2047">      /* start one line back, because a &quot;&lt;1&quot; may indicate the end of a</a>
<a name="ln2048">       * fold in the topline */</a>
<a name="ln2049">      if (top &gt; 1)</a>
<a name="ln2050">        --fline.lnum;</a>
<a name="ln2051">    } else if (foldmethodIsSyntax(wp))</a>
<a name="ln2052">      getlevel = foldlevelSyntax;</a>
<a name="ln2053">    else if (foldmethodIsDiff(wp))</a>
<a name="ln2054">      getlevel = foldlevelDiff;</a>
<a name="ln2055">    else</a>
<a name="ln2056">      getlevel = foldlevelIndent;</a>
<a name="ln2057"> </a>
<a name="ln2058">    /* Backup to a line for which the fold level is defined.  Since it's</a>
<a name="ln2059">     * always defined for line one, we will stop there. */</a>
<a name="ln2060">    fline.lvl = -1;</a>
<a name="ln2061">    for (; !got_int; --fline.lnum) {</a>
<a name="ln2062">      /* Reset lvl_next each time, because it will be set to a value for</a>
<a name="ln2063">       * the next line, but we search backwards here. */</a>
<a name="ln2064">      fline.lvl_next = -1;</a>
<a name="ln2065">      getlevel(&amp;fline);</a>
<a name="ln2066">      if (fline.lvl &gt;= 0)</a>
<a name="ln2067">        break;</a>
<a name="ln2068">    }</a>
<a name="ln2069">  }</a>
<a name="ln2070"> </a>
<a name="ln2071">  /*</a>
<a name="ln2072">   * If folding is defined by the syntax, it is possible that a change in</a>
<a name="ln2073">   * one line will cause all sub-folds of the current fold to change (e.g.,</a>
<a name="ln2074">   * closing a C-style comment can cause folds in the subsequent lines to</a>
<a name="ln2075">   * appear). To take that into account we should adjust the value of &quot;bot&quot;</a>
<a name="ln2076">   * to point to the end of the current fold:</a>
<a name="ln2077">   */</a>
<a name="ln2078">  if (foldlevelSyntax == getlevel) {</a>
<a name="ln2079">    garray_T *gap = &amp;wp-&gt;w_folds;</a>
<a name="ln2080">    fold_T   *fpn = NULL;</a>
<a name="ln2081">    int current_fdl = 0;</a>
<a name="ln2082">    linenr_T fold_start_lnum = 0;</a>
<a name="ln2083">    linenr_T lnum_rel = fline.lnum;</a>
<a name="ln2084"> </a>
<a name="ln2085">    while (current_fdl &lt; fline.lvl) {</a>
<a name="ln2086">      if (!foldFind(gap, lnum_rel, &amp;fpn))</a>
<a name="ln2087">        break;</a>
<a name="ln2088">      ++current_fdl;</a>
<a name="ln2089"> </a>
<a name="ln2090">      fold_start_lnum += fpn-&gt;fd_top;</a>
<a name="ln2091">      gap = &amp;fpn-&gt;fd_nested;</a>
<a name="ln2092">      lnum_rel -= fpn-&gt;fd_top;</a>
<a name="ln2093">    }</a>
<a name="ln2094">    if (fpn != NULL &amp;&amp; current_fdl == fline.lvl) {</a>
<a name="ln2095">      linenr_T fold_end_lnum = fold_start_lnum + fpn-&gt;fd_len;</a>
<a name="ln2096"> </a>
<a name="ln2097">      if (fold_end_lnum &gt; bot)</a>
<a name="ln2098">        bot = fold_end_lnum;</a>
<a name="ln2099">    }</a>
<a name="ln2100">  }</a>
<a name="ln2101"> </a>
<a name="ln2102">  linenr_T start = fline.lnum;</a>
<a name="ln2103">  linenr_T end = bot;</a>
<a name="ln2104">  // Do at least one line.</a>
<a name="ln2105">  if (start &gt; end &amp;&amp; end &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln2106">    end = start;</a>
<a name="ln2107">  }</a>
<a name="ln2108">  while (!got_int) {</a>
<a name="ln2109">    /* Always stop at the end of the file (&quot;end&quot; can be past the end of</a>
<a name="ln2110">     * the file). */</a>
<a name="ln2111">    if (fline.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln2112">      break;</a>
<a name="ln2113">    if (fline.lnum &gt; end) {</a>
<a name="ln2114">      /* For &quot;marker&quot;, &quot;expr&quot;  and &quot;syntax&quot;  methods: If a change caused</a>
<a name="ln2115">       * a fold to be removed, we need to continue at least until where</a>
<a name="ln2116">       * it ended. */</a>
<a name="ln2117">      if (getlevel != foldlevelMarker</a>
<a name="ln2118">          &amp;&amp; getlevel != foldlevelSyntax</a>
<a name="ln2119">          &amp;&amp; getlevel != foldlevelExpr)</a>
<a name="ln2120">        break;</a>
<a name="ln2121">      if ((start &lt;= end</a>
<a name="ln2122">           &amp;&amp; foldFind(&amp;wp-&gt;w_folds, end, &amp;fp)</a>
<a name="ln2123">           &amp;&amp; fp-&gt;fd_top + fp-&gt;fd_len - 1 &gt; end)</a>
<a name="ln2124">          || (fline.lvl == 0</a>
<a name="ln2125">              &amp;&amp; foldFind(&amp;wp-&gt;w_folds, fline.lnum, &amp;fp)</a>
<a name="ln2126">              &amp;&amp; fp-&gt;fd_top &lt; fline.lnum))</a>
<a name="ln2127">        end = fp-&gt;fd_top + fp-&gt;fd_len - 1;</a>
<a name="ln2128">      else if (getlevel == foldlevelSyntax</a>
<a name="ln2129">               &amp;&amp; foldLevelWin(wp, fline.lnum) != fline.lvl)</a>
<a name="ln2130">        /* For &quot;syntax&quot; method: Compare the foldlevel that the syntax</a>
<a name="ln2131">         * tells us to the foldlevel from the existing folds.  If they</a>
<a name="ln2132">         * don't match continue updating folds. */</a>
<a name="ln2133">        end = fline.lnum;</a>
<a name="ln2134">      else</a>
<a name="ln2135">        break;</a>
<a name="ln2136">    }</a>
<a name="ln2137"> </a>
<a name="ln2138">    /* A level 1 fold starts at a line with foldlevel &gt; 0. */</a>
<a name="ln2139">    if (fline.lvl &gt; 0) {</a>
<a name="ln2140">      invalid_top = fline.lnum;</a>
<a name="ln2141">      invalid_bot = end;</a>
<a name="ln2142">      end = foldUpdateIEMSRecurse(&amp;wp-&gt;w_folds, 1, start, &amp;fline, getlevel, end,</a>
<a name="ln2143">                                  FD_LEVEL);</a>
<a name="ln2144">      start = fline.lnum;</a>
<a name="ln2145">    } else {</a>
<a name="ln2146">      if (fline.lnum == wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln2147">        break;</a>
<a name="ln2148">      ++fline.lnum;</a>
<a name="ln2149">      fline.lvl = fline.lvl_next;</a>
<a name="ln2150">      getlevel(&amp;fline);</a>
<a name="ln2151">    }</a>
<a name="ln2152">  }</a>
<a name="ln2153"> </a>
<a name="ln2154">  // There can't be any folds from start until end now.</a>
<a name="ln2155">  foldRemove(wp, &amp;wp-&gt;w_folds, start, end);</a>
<a name="ln2156"> </a>
<a name="ln2157">  /* If some fold changed, need to redraw and position cursor. */</a>
<a name="ln2158">  if (fold_changed &amp;&amp; wp-&gt;w_p_fen)</a>
<a name="ln2159">    changed_window_setting_win(wp);</a>
<a name="ln2160"> </a>
<a name="ln2161">  /* If we updated folds past &quot;bot&quot;, need to redraw more lines.  Don't do</a>
<a name="ln2162">   * this in other situations, the changed lines will be redrawn anyway and</a>
<a name="ln2163">   * this method can cause the whole window to be updated. */</a>
<a name="ln2164">  if (end != bot) {</a>
<a name="ln2165">    if (wp-&gt;w_redraw_top == 0 || wp-&gt;w_redraw_top &gt; top)</a>
<a name="ln2166">      wp-&gt;w_redraw_top = top;</a>
<a name="ln2167">    if (wp-&gt;w_redraw_bot &lt; end)</a>
<a name="ln2168">      wp-&gt;w_redraw_bot = end;</a>
<a name="ln2169">  }</a>
<a name="ln2170"> </a>
<a name="ln2171">  invalid_top = (linenr_T)0;</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174">/* foldUpdateIEMSRecurse() {{{2 */</a>
<a name="ln2175">/*</a>
<a name="ln2176"> * Update a fold that starts at &quot;flp-&gt;lnum&quot;.  At this line there is always a</a>
<a name="ln2177"> * valid foldlevel, and its level &gt;= &quot;level&quot;.</a>
<a name="ln2178"> * &quot;flp&quot; is valid for &quot;flp-&gt;lnum&quot; when called and it's valid when returning.</a>
<a name="ln2179"> * &quot;flp-&gt;lnum&quot; is set to the lnum just below the fold, if it ends before</a>
<a name="ln2180"> * &quot;bot&quot;, it's &quot;bot&quot; plus one if the fold continues and it's bigger when using</a>
<a name="ln2181"> * the marker method and a text change made following folds to change.</a>
<a name="ln2182"> * When returning, &quot;flp-&gt;lnum_save&quot; is the line number that was used to get</a>
<a name="ln2183"> * the level when the level at &quot;flp-&gt;lnum&quot; is invalid.</a>
<a name="ln2184"> * Remove any folds from &quot;startlnum&quot; up to here at this level.</a>
<a name="ln2185"> * Recursively update nested folds.</a>
<a name="ln2186"> * Below line &quot;bot&quot; there are no changes in the text.</a>
<a name="ln2187"> * &quot;flp-&gt;lnum&quot;, &quot;flp-&gt;lnum_save&quot; and &quot;bot&quot; are relative to the start of the</a>
<a name="ln2188"> * outer fold.</a>
<a name="ln2189"> * &quot;flp-&gt;off&quot; is the offset to the real line number in the buffer.</a>
<a name="ln2190"> *</a>
<a name="ln2191"> * All this would be a lot simpler if all folds in the range would be deleted</a>
<a name="ln2192"> * and then created again.  But we would lose all information about the</a>
<a name="ln2193"> * folds, even when making changes that don't affect the folding (e.g. &quot;vj~&quot;).</a>
<a name="ln2194"> *</a>
<a name="ln2195"> * Returns bot, which may have been increased for lines that also need to be</a>
<a name="ln2196"> * updated as a result of a detected change in the fold.</a>
<a name="ln2197"> */</a>
<a name="ln2198">static linenr_T foldUpdateIEMSRecurse(</a>
<a name="ln2199">    garray_T *const gap, const int level, const linenr_T startlnum,</a>
<a name="ln2200">    fline_T *const flp, LevelGetter getlevel, linenr_T bot,</a>
<a name="ln2201">    const char topflags  // containing fold flags</a>
<a name="ln2202">)</a>
<a name="ln2203">{</a>
<a name="ln2204">  linenr_T ll;</a>
<a name="ln2205">  fold_T      *fp = NULL;</a>
<a name="ln2206">  fold_T      *fp2;</a>
<a name="ln2207">  int lvl = level;</a>
<a name="ln2208">  linenr_T startlnum2 = startlnum;</a>
<a name="ln2209">  const linenr_T firstlnum = flp-&gt;lnum;     // first lnum we got</a>
<a name="ln2210">  int i;</a>
<a name="ln2211">  bool finish = false;</a>
<a name="ln2212">  const linenr_T linecount = flp-&gt;wp-&gt;w_buffer-&gt;b_ml.ml_line_count - flp-&gt;off;</a>
<a name="ln2213">  int concat;</a>
<a name="ln2214"> </a>
<a name="ln2215">  /*</a>
<a name="ln2216">   * If using the marker method, the start line is not the start of a fold</a>
<a name="ln2217">   * at the level we're dealing with and the level is non-zero, we must use</a>
<a name="ln2218">   * the previous fold.  But ignore a fold that starts at or below</a>
<a name="ln2219">   * startlnum, it must be deleted.</a>
<a name="ln2220">   */</a>
<a name="ln2221">  if (getlevel == foldlevelMarker &amp;&amp; flp-&gt;start &lt;= flp-&gt;lvl - level</a>
<a name="ln2222">      &amp;&amp; flp-&gt;lvl &gt; 0) {</a>
<a name="ln2223">    (void)foldFind(gap, startlnum - 1, &amp;fp);</a>
<a name="ln2224">    if (fp &gt;= ((fold_T *)gap-&gt;ga_data) + gap-&gt;ga_len</a>
<a name="ln2225">        || fp-&gt;fd_top &gt;= startlnum) {</a>
<a name="ln2226">      fp = NULL;</a>
<a name="ln2227">    }</a>
<a name="ln2228">  }</a>
<a name="ln2229"> </a>
<a name="ln2230">  /*</a>
<a name="ln2231">   * Loop over all lines in this fold, or until &quot;bot&quot; is hit.</a>
<a name="ln2232">   * Handle nested folds inside of this fold.</a>
<a name="ln2233">   * &quot;flp-&gt;lnum&quot; is the current line.  When finding the end of the fold, it</a>
<a name="ln2234">   * is just below the end of the fold.</a>
<a name="ln2235">   * &quot;*flp&quot; contains the level of the line &quot;flp-&gt;lnum&quot; or a following one if</a>
<a name="ln2236">   * there are lines with an invalid fold level.  &quot;flp-&gt;lnum_save&quot; is the</a>
<a name="ln2237">   * line number that was used to get the fold level (below &quot;flp-&gt;lnum&quot; when</a>
<a name="ln2238">   * it has an invalid fold level).  When called the fold level is always</a>
<a name="ln2239">   * valid, thus &quot;flp-&gt;lnum_save&quot; is equal to &quot;flp-&gt;lnum&quot;.</a>
<a name="ln2240">   */</a>
<a name="ln2241">  flp-&gt;lnum_save = flp-&gt;lnum;</a>
<a name="ln2242">  while (!got_int) {</a>
<a name="ln2243">    /* Updating folds can be slow, check for CTRL-C. */</a>
<a name="ln2244">    line_breakcheck();</a>
<a name="ln2245"> </a>
<a name="ln2246">    /* Set &quot;lvl&quot; to the level of line &quot;flp-&gt;lnum&quot;.  When flp-&gt;start is set</a>
<a name="ln2247">     * and after the first line of the fold, set the level to zero to</a>
<a name="ln2248">     * force the fold to end.  Do the same when had_end is set: Previous</a>
<a name="ln2249">     * line was marked as end of a fold. */</a>
<a name="ln2250">    lvl = flp-&gt;lvl;</a>
<a name="ln2251">    if (lvl &gt; MAX_LEVEL)</a>
<a name="ln2252">      lvl = MAX_LEVEL;</a>
<a name="ln2253">    if (flp-&gt;lnum &gt; firstlnum</a>
<a name="ln2254">        &amp;&amp; (level &gt; lvl - flp-&gt;start || level &gt;= flp-&gt;had_end))</a>
<a name="ln2255">      lvl = 0;</a>
<a name="ln2256"> </a>
<a name="ln2257">    if (flp-&gt;lnum &gt; bot &amp;&amp; !finish &amp;&amp; fp != NULL) {</a>
<a name="ln2258">      /* For &quot;marker&quot; and &quot;syntax&quot; methods:</a>
<a name="ln2259">       * - If a change caused a nested fold to be removed, we need to</a>
<a name="ln2260">       *   delete it and continue at least until where it ended.</a>
<a name="ln2261">       * - If a change caused a nested fold to be created, or this fold</a>
<a name="ln2262">       *   to continue below its original end, need to finish this fold.</a>
<a name="ln2263">       */</a>
<a name="ln2264">      if (getlevel != foldlevelMarker</a>
<a name="ln2265">          &amp;&amp; getlevel != foldlevelExpr</a>
<a name="ln2266">          &amp;&amp; getlevel != foldlevelSyntax)</a>
<a name="ln2267">        break;</a>
<a name="ln2268">      i = 0;</a>
<a name="ln2269">      fp2 = fp;</a>
<a name="ln2270">      if (lvl &gt;= level) {</a>
<a name="ln2271">        /* Compute how deep the folds currently are, if it's deeper</a>
<a name="ln2272">         * than &quot;lvl&quot; then some must be deleted, need to update</a>
<a name="ln2273">         * at least one nested fold. */</a>
<a name="ln2274">        ll = flp-&gt;lnum - fp-&gt;fd_top;</a>
<a name="ln2275">        while (foldFind(&amp;fp2-&gt;fd_nested, ll, &amp;fp2)) {</a>
<a name="ln2276">          ++i;</a>
<a name="ln2277">          ll -= fp2-&gt;fd_top;</a>
<a name="ln2278">        }</a>
<a name="ln2279">      }</a>
<a name="ln2280">      if (lvl &lt; level + i) {</a>
<a name="ln2281">        (void)foldFind(&amp;fp-&gt;fd_nested, flp-&gt;lnum - fp-&gt;fd_top, &amp;fp2);</a>
<a name="ln2282">        if (fp2 != NULL) {</a>
<a name="ln2283">          bot = fp2-&gt;fd_top + fp2-&gt;fd_len - 1 + fp-&gt;fd_top;</a>
<a name="ln2284">        }</a>
<a name="ln2285">      } else if (fp-&gt;fd_top + fp-&gt;fd_len &lt;= flp-&gt;lnum &amp;&amp; lvl &gt;= level) {</a>
<a name="ln2286">        finish = true;</a>
<a name="ln2287">      } else {</a>
<a name="ln2288">        break;</a>
<a name="ln2289">      }</a>
<a name="ln2290">    }</a>
<a name="ln2291"> </a>
<a name="ln2292">    /* At the start of the first nested fold and at the end of the current</a>
<a name="ln2293">     * fold: check if existing folds at this level, before the current</a>
<a name="ln2294">     * one, need to be deleted or truncated. */</a>
<a name="ln2295">    if (fp == NULL</a>
<a name="ln2296">        &amp;&amp; (lvl != level</a>
<a name="ln2297">            || flp-&gt;lnum_save &gt;= bot</a>
<a name="ln2298">            || flp-&gt;start != 0</a>
<a name="ln2299">            || flp-&gt;had_end &lt;= MAX_LEVEL</a>
<a name="ln2300">            || flp-&gt;lnum == linecount)) {</a>
<a name="ln2301">      /*</a>
<a name="ln2302">       * Remove or update folds that have lines between startlnum and</a>
<a name="ln2303">       * firstlnum.</a>
<a name="ln2304">       */</a>
<a name="ln2305">      while (!got_int) {</a>
<a name="ln2306">        /* set concat to 1 if it's allowed to concatenated this fold</a>
<a name="ln2307">         * with a previous one that touches it. */</a>
<a name="ln2308">        if (flp-&gt;start != 0 || flp-&gt;had_end &lt;= MAX_LEVEL)</a>
<a name="ln2309">          concat = 0;</a>
<a name="ln2310">        else</a>
<a name="ln2311">          concat = 1;</a>
<a name="ln2312"> </a>
<a name="ln2313">        /* Find an existing fold to re-use.  Preferably one that</a>
<a name="ln2314">         * includes startlnum, otherwise one that ends just before</a>
<a name="ln2315">         * startlnum or starts after it. */</a>
<a name="ln2316">        if (gap-&gt;ga_len &gt; 0</a>
<a name="ln2317">            &amp;&amp; (foldFind(gap, startlnum, &amp;fp)</a>
<a name="ln2318">                || (fp &lt; ((fold_T *)gap-&gt;ga_data) + gap-&gt;ga_len</a>
<a name="ln2319">                    &amp;&amp; fp-&gt;fd_top &lt;= firstlnum)</a>
<a name="ln2320">                || foldFind(gap, firstlnum - concat, &amp;fp)</a>
<a name="ln2321">                || (fp &lt; ((fold_T *)gap-&gt;ga_data) + gap-&gt;ga_len</a>
<a name="ln2322">                    &amp;&amp; ((lvl &lt; level &amp;&amp; fp-&gt;fd_top &lt; flp-&gt;lnum)</a>
<a name="ln2323">                        || (lvl &gt;= level</a>
<a name="ln2324">                            &amp;&amp; fp-&gt;fd_top &lt;= flp-&gt;lnum_save))))) {</a>
<a name="ln2325">          if (fp-&gt;fd_top + fp-&gt;fd_len + concat &gt; firstlnum) {</a>
<a name="ln2326">            /* Use existing fold for the new fold.  If it starts</a>
<a name="ln2327">             * before where we started looking, extend it.  If it</a>
<a name="ln2328">             * starts at another line, update nested folds to keep</a>
<a name="ln2329">             * their position, compensating for the new fd_top. */</a>
<a name="ln2330">            if (fp-&gt;fd_top == firstlnum) {</a>
<a name="ln2331">              // We have found a fold beginning exactly where we want one.</a>
<a name="ln2332">            } else if (fp-&gt;fd_top &gt;= startlnum) {</a>
<a name="ln2333">              if (fp-&gt;fd_top &gt; firstlnum) {</a>
<a name="ln2334">                // We will move the start of this fold up, hence we move all</a>
<a name="ln2335">                // nested folds (with relative line numbers) down.</a>
<a name="ln2336">                foldMarkAdjustRecurse(flp-&gt;wp, &amp;fp-&gt;fd_nested,</a>
<a name="ln2337">                                      (linenr_T)0, (linenr_T)MAXLNUM,</a>
<a name="ln2338">                                      (long)(fp-&gt;fd_top - firstlnum), 0L);</a>
<a name="ln2339">              } else {</a>
<a name="ln2340">                // Will move fold down, move nested folds relatively up.</a>
<a name="ln2341">                foldMarkAdjustRecurse(flp-&gt;wp, &amp;fp-&gt;fd_nested,</a>
<a name="ln2342">                                      (linenr_T)0,</a>
<a name="ln2343">                                      (long)(firstlnum - fp-&gt;fd_top - 1),</a>
<a name="ln2344">                                      (linenr_T)MAXLNUM,</a>
<a name="ln2345">                                      (long)(fp-&gt;fd_top - firstlnum));</a>
<a name="ln2346">              }</a>
<a name="ln2347">              fp-&gt;fd_len += fp-&gt;fd_top - firstlnum;</a>
<a name="ln2348">              fp-&gt;fd_top = firstlnum;</a>
<a name="ln2349">              fold_changed = true;</a>
<a name="ln2350">            } else if ((flp-&gt;start != 0 &amp;&amp; lvl == level)</a>
<a name="ln2351">                       || (firstlnum != startlnum)) {</a>
<a name="ln2352">              // Before there was a fold spanning from above startlnum to below</a>
<a name="ln2353">              // firstlnum. This fold is valid above startlnum (because we are</a>
<a name="ln2354">              // not updating that range), but there is now a break in it.</a>
<a name="ln2355">              // If the break is because we are now forced to start a new fold</a>
<a name="ln2356">              // at the level &quot;level&quot; at line fline-&gt;lnum, then we need to</a>
<a name="ln2357">              // split the fold at fline-&gt;lnum.</a>
<a name="ln2358">              // If the break is because the range [startlnum, firstlnum) is</a>
<a name="ln2359">              // now at a lower indent than &quot;level&quot;, we need to split the fold</a>
<a name="ln2360">              // in this range.</a>
<a name="ln2361">              // Any splits have to be done recursively.</a>
<a name="ln2362">              linenr_T breakstart;</a>
<a name="ln2363">              linenr_T breakend;</a>
<a name="ln2364">              if (firstlnum != startlnum) {</a>
<a name="ln2365">                breakstart = startlnum;</a>
<a name="ln2366">                breakend = firstlnum;</a>
<a name="ln2367">              } else {</a>
<a name="ln2368">                breakstart = flp-&gt;lnum;</a>
<a name="ln2369">                breakend = flp-&gt;lnum;</a>
<a name="ln2370">              }</a>
<a name="ln2371">              foldRemove(flp-&gt;wp, &amp;fp-&gt;fd_nested, breakstart - fp-&gt;fd_top,</a>
<a name="ln2372">                         breakend - fp-&gt;fd_top);</a>
<a name="ln2373">              i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln2374">              foldSplit(flp-&gt;wp-&gt;w_buffer, gap, i, breakstart, breakend - 1);</a>
<a name="ln2375">              fp = (fold_T *)gap-&gt;ga_data + i + 1;</a>
<a name="ln2376">              /* If using the &quot;marker&quot; or &quot;syntax&quot; method, we</a>
<a name="ln2377">               * need to continue until the end of the fold is</a>
<a name="ln2378">               * found. */</a>
<a name="ln2379">              if (getlevel == foldlevelMarker</a>
<a name="ln2380">                  || getlevel == foldlevelExpr</a>
<a name="ln2381">                  || getlevel == foldlevelSyntax) {</a>
<a name="ln2382">                finish = true;</a>
<a name="ln2383">              }</a>
<a name="ln2384">            }</a>
<a name="ln2385">            if (fp-&gt;fd_top == startlnum &amp;&amp; concat) {</a>
<a name="ln2386">              i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln2387">              if (i != 0) {</a>
<a name="ln2388">                fp2 = fp - 1;</a>
<a name="ln2389">                if (fp2-&gt;fd_top + fp2-&gt;fd_len == fp-&gt;fd_top) {</a>
<a name="ln2390">                  foldMerge(flp-&gt;wp, fp2, gap, fp);</a>
<a name="ln2391">                  fp = fp2;</a>
<a name="ln2392">                }</a>
<a name="ln2393">              }</a>
<a name="ln2394">            }</a>
<a name="ln2395">            break;</a>
<a name="ln2396">          }</a>
<a name="ln2397">          if (fp-&gt;fd_top &gt;= startlnum) {</a>
<a name="ln2398">            // A fold that starts at or after startlnum and stops</a>
<a name="ln2399">            // before the new fold must be deleted.  Continue</a>
<a name="ln2400">            // looking for the next one.</a>
<a name="ln2401">            deleteFoldEntry(flp-&gt;wp, gap,</a>
<a name="ln2402">                            (int)(fp - (fold_T *)gap-&gt;ga_data), true);</a>
<a name="ln2403">          } else {</a>
<a name="ln2404">            /* A fold has some lines above startlnum, truncate it</a>
<a name="ln2405">             * to stop just above startlnum.  */</a>
<a name="ln2406">            fp-&gt;fd_len = startlnum - fp-&gt;fd_top;</a>
<a name="ln2407">            foldMarkAdjustRecurse(flp-&gt;wp, &amp;fp-&gt;fd_nested,</a>
<a name="ln2408">                                  (linenr_T)fp-&gt;fd_len, (linenr_T)MAXLNUM,</a>
<a name="ln2409">                                  (linenr_T)MAXLNUM, 0L);</a>
<a name="ln2410">            fold_changed = true;</a>
<a name="ln2411">          }</a>
<a name="ln2412">        } else {</a>
<a name="ln2413">          /* Insert new fold.  Careful: ga_data may be NULL and it</a>
<a name="ln2414">           * may change! */</a>
<a name="ln2415">          if (gap-&gt;ga_len == 0) {</a>
<a name="ln2416">            i = 0;</a>
<a name="ln2417">          } else {</a>
<a name="ln2418">            i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln2419">          }</a>
<a name="ln2420">          foldInsert(gap, i);</a>
<a name="ln2421">          fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln2422">          /* The new fold continues until bot, unless we find the</a>
<a name="ln2423">           * end earlier. */</a>
<a name="ln2424">          fp-&gt;fd_top = firstlnum;</a>
<a name="ln2425">          fp-&gt;fd_len = bot - firstlnum + 1;</a>
<a name="ln2426">          /* When the containing fold is open, the new fold is open.</a>
<a name="ln2427">           * The new fold is closed if the fold above it is closed.</a>
<a name="ln2428">           * The first fold depends on the containing fold. */</a>
<a name="ln2429">          if (topflags == FD_OPEN) {</a>
<a name="ln2430">            flp-&gt;wp-&gt;w_fold_manual = true;</a>
<a name="ln2431">            fp-&gt;fd_flags = FD_OPEN;</a>
<a name="ln2432">          } else if (i &lt;= 0) {</a>
<a name="ln2433">            fp-&gt;fd_flags = topflags;</a>
<a name="ln2434">            if (topflags != FD_LEVEL)</a>
<a name="ln2435">              flp-&gt;wp-&gt;w_fold_manual = true;</a>
<a name="ln2436">          } else</a>
<a name="ln2437">            fp-&gt;fd_flags = (fp - 1)-&gt;fd_flags;</a>
<a name="ln2438">          fp-&gt;fd_small = kNone;</a>
<a name="ln2439">          // If using the &quot;marker&quot;, &quot;expr&quot; or &quot;syntax&quot; method, we</a>
<a name="ln2440">          // need to continue until the end of the fold is found.</a>
<a name="ln2441">          if (getlevel == foldlevelMarker</a>
<a name="ln2442">              || getlevel == foldlevelExpr</a>
<a name="ln2443">              || getlevel == foldlevelSyntax) {</a>
<a name="ln2444">            finish = true;</a>
<a name="ln2445">          }</a>
<a name="ln2446">          fold_changed = true;</a>
<a name="ln2447">          break;</a>
<a name="ln2448">        }</a>
<a name="ln2449">      }</a>
<a name="ln2450">    }</a>
<a name="ln2451"> </a>
<a name="ln2452">    if (lvl &lt; level || flp-&gt;lnum &gt; linecount) {</a>
<a name="ln2453">      /*</a>
<a name="ln2454">       * Found a line with a lower foldlevel, this fold ends just above</a>
<a name="ln2455">       * &quot;flp-&gt;lnum&quot;.</a>
<a name="ln2456">       */</a>
<a name="ln2457">      break;</a>
<a name="ln2458">    }</a>
<a name="ln2459"> </a>
<a name="ln2460">    /*</a>
<a name="ln2461">     * The fold includes the line &quot;flp-&gt;lnum&quot; and &quot;flp-&gt;lnum_save&quot;.</a>
<a name="ln2462">     * Check &quot;fp&quot; for safety.</a>
<a name="ln2463">     */</a>
<a name="ln2464">    if (lvl &gt; level &amp;&amp; fp != NULL) {</a>
<a name="ln2465">      // There is a nested fold, handle it recursively.</a>
<a name="ln2466">      // At least do one line (can happen when finish is true).</a>
<a name="ln2467">      if (bot &lt; flp-&gt;lnum) {</a>
<a name="ln2468">        bot = flp-&gt;lnum;</a>
<a name="ln2469">      }</a>
<a name="ln2470"> </a>
<a name="ln2471">      /* Line numbers in the nested fold are relative to the start of</a>
<a name="ln2472">       * this fold. */</a>
<a name="ln2473">      flp-&gt;lnum = flp-&gt;lnum_save - fp-&gt;fd_top;</a>
<a name="ln2474">      flp-&gt;off += fp-&gt;fd_top;</a>
<a name="ln2475">      i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln2476">      bot = foldUpdateIEMSRecurse(&amp;fp-&gt;fd_nested, level + 1,</a>
<a name="ln2477">                                  startlnum2 - fp-&gt;fd_top, flp, getlevel,</a>
<a name="ln2478">                                  bot - fp-&gt;fd_top, fp-&gt;fd_flags);</a>
<a name="ln2479">      fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln2480">      flp-&gt;lnum += fp-&gt;fd_top;</a>
<a name="ln2481">      flp-&gt;lnum_save += fp-&gt;fd_top;</a>
<a name="ln2482">      flp-&gt;off -= fp-&gt;fd_top;</a>
<a name="ln2483">      bot += fp-&gt;fd_top;</a>
<a name="ln2484">      startlnum2 = flp-&gt;lnum;</a>
<a name="ln2485"> </a>
<a name="ln2486">      /* This fold may end at the same line, don't incr. flp-&gt;lnum. */</a>
<a name="ln2487">    } else {</a>
<a name="ln2488">      /*</a>
<a name="ln2489">       * Get the level of the next line, then continue the loop to check</a>
<a name="ln2490">       * if it ends there.</a>
<a name="ln2491">       * Skip over undefined lines, to find the foldlevel after it.</a>
<a name="ln2492">       * For the last line in the file the foldlevel is always valid.</a>
<a name="ln2493">       */</a>
<a name="ln2494">      flp-&gt;lnum = flp-&gt;lnum_save;</a>
<a name="ln2495">      ll = flp-&gt;lnum + 1;</a>
<a name="ln2496">      while (!got_int) {</a>
<a name="ln2497">        /* Make the previous level available to foldlevel(). */</a>
<a name="ln2498">        prev_lnum = flp-&gt;lnum;</a>
<a name="ln2499">        prev_lnum_lvl = flp-&gt;lvl;</a>
<a name="ln2500"> </a>
<a name="ln2501">        if (++flp-&gt;lnum &gt; linecount)</a>
<a name="ln2502">          break;</a>
<a name="ln2503">        flp-&gt;lvl = flp-&gt;lvl_next;</a>
<a name="ln2504">        getlevel(flp);</a>
<a name="ln2505">        if (flp-&gt;lvl &gt;= 0 || flp-&gt;had_end &lt;= MAX_LEVEL)</a>
<a name="ln2506">          break;</a>
<a name="ln2507">      }</a>
<a name="ln2508">      prev_lnum = 0;</a>
<a name="ln2509">      if (flp-&gt;lnum &gt; linecount)</a>
<a name="ln2510">        break;</a>
<a name="ln2511"> </a>
<a name="ln2512">      /* leave flp-&gt;lnum_save to lnum of the line that was used to get</a>
<a name="ln2513">       * the level, flp-&gt;lnum to the lnum of the next line. */</a>
<a name="ln2514">      flp-&gt;lnum_save = flp-&gt;lnum;</a>
<a name="ln2515">      flp-&gt;lnum = ll;</a>
<a name="ln2516">    }</a>
<a name="ln2517">  }</a>
<a name="ln2518"> </a>
<a name="ln2519">  if (fp == NULL)       /* only happens when got_int is set */</a>
<a name="ln2520">    return bot;</a>
<a name="ln2521"> </a>
<a name="ln2522">  /*</a>
<a name="ln2523">   * Get here when:</a>
<a name="ln2524">   * lvl &lt; level: the folds ends just above &quot;flp-&gt;lnum&quot;</a>
<a name="ln2525">   * lvl &gt;= level: fold continues below &quot;bot&quot;</a>
<a name="ln2526">   */</a>
<a name="ln2527"> </a>
<a name="ln2528">  // Current fold at least extends until lnum.</a>
<a name="ln2529">  if (fp-&gt;fd_len &lt; flp-&gt;lnum - fp-&gt;fd_top) {</a>
<a name="ln2530">    fp-&gt;fd_len = flp-&gt;lnum - fp-&gt;fd_top;</a>
<a name="ln2531">    fp-&gt;fd_small = kNone;</a>
<a name="ln2532">    fold_changed = true;</a>
<a name="ln2533">  } else if (fp-&gt;fd_top + fp-&gt;fd_len &gt; linecount) {</a>
<a name="ln2534">    // running into the end of the buffer (deleted last line)</a>
<a name="ln2535">    fp-&gt;fd_len = linecount - fp-&gt;fd_top + 1;</a>
<a name="ln2536">  }</a>
<a name="ln2537"> </a>
<a name="ln2538">  // Delete contained folds from the end of the last one found until where</a>
<a name="ln2539">  // we stopped looking.</a>
<a name="ln2540">  foldRemove(flp-&gt;wp, &amp;fp-&gt;fd_nested, startlnum2 - fp-&gt;fd_top,</a>
<a name="ln2541">             flp-&gt;lnum - 1 - fp-&gt;fd_top);</a>
<a name="ln2542"> </a>
<a name="ln2543">  if (lvl &lt; level) {</a>
<a name="ln2544">    // End of fold found, update the length when it got shorter.</a>
<a name="ln2545">    if (fp-&gt;fd_len != flp-&gt;lnum - fp-&gt;fd_top) {</a>
<a name="ln2546">      if (fp-&gt;fd_top + fp-&gt;fd_len - 1 &gt; bot) {</a>
<a name="ln2547">        // fold continued below bot</a>
<a name="ln2548">        if (getlevel == foldlevelMarker</a>
<a name="ln2549">            || getlevel == foldlevelExpr</a>
<a name="ln2550">            || getlevel == foldlevelSyntax) {</a>
<a name="ln2551">          // marker method: truncate the fold and make sure the</a>
<a name="ln2552">          // previously included lines are processed again</a>
<a name="ln2553">          bot = fp-&gt;fd_top + fp-&gt;fd_len - 1;</a>
<a name="ln2554">          fp-&gt;fd_len = flp-&gt;lnum - fp-&gt;fd_top;</a>
<a name="ln2555">        } else {</a>
<a name="ln2556">          // indent or expr method: split fold to create a new one</a>
<a name="ln2557">          // below bot</a>
<a name="ln2558">          i = (int)(fp - (fold_T *)gap-&gt;ga_data);</a>
<a name="ln2559">          foldSplit(flp-&gt;wp-&gt;w_buffer, gap, i, flp-&gt;lnum, bot);</a>
<a name="ln2560">          fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln2561">        }</a>
<a name="ln2562">      } else {</a>
<a name="ln2563">        fp-&gt;fd_len = flp-&gt;lnum - fp-&gt;fd_top;</a>
<a name="ln2564">      }</a>
<a name="ln2565">      fold_changed = true;</a>
<a name="ln2566">    }</a>
<a name="ln2567">  }</a>
<a name="ln2568"> </a>
<a name="ln2569">  /* delete following folds that end before the current line */</a>
<a name="ln2570">  for (;; ) {</a>
<a name="ln2571">    fp2 = fp + 1;</a>
<a name="ln2572">    if (fp2 &gt;= (fold_T *)gap-&gt;ga_data + gap-&gt;ga_len</a>
<a name="ln2573">        || fp2-&gt;fd_top &gt; flp-&gt;lnum)</a>
<a name="ln2574">      break;</a>
<a name="ln2575">    if (fp2-&gt;fd_top + fp2-&gt;fd_len &gt; flp-&gt;lnum) {</a>
<a name="ln2576">      if (fp2-&gt;fd_top &lt; flp-&gt;lnum) {</a>
<a name="ln2577">        // Make fold that includes lnum start at lnum.</a>
<a name="ln2578">        foldMarkAdjustRecurse(flp-&gt;wp, &amp;fp2-&gt;fd_nested,</a>
<a name="ln2579">                              (linenr_T)0, (long)(flp-&gt;lnum - fp2-&gt;fd_top - 1),</a>
<a name="ln2580">                              (linenr_T)MAXLNUM, (long)(fp2-&gt;fd_top-flp-&gt;lnum));</a>
<a name="ln2581">        fp2-&gt;fd_len -= flp-&gt;lnum - fp2-&gt;fd_top;</a>
<a name="ln2582">        fp2-&gt;fd_top = flp-&gt;lnum;</a>
<a name="ln2583">        fold_changed = true;</a>
<a name="ln2584">      }</a>
<a name="ln2585"> </a>
<a name="ln2586">      if (lvl &gt;= level) {</a>
<a name="ln2587">        // merge new fold with existing fold that follows</a>
<a name="ln2588">        foldMerge(flp-&gt;wp, fp, gap, fp2);</a>
<a name="ln2589">      }</a>
<a name="ln2590">      break;</a>
<a name="ln2591">    }</a>
<a name="ln2592">    fold_changed = true;</a>
<a name="ln2593">    deleteFoldEntry(flp-&gt;wp, gap, (int)(fp2 - (fold_T *)gap-&gt;ga_data), true);</a>
<a name="ln2594">  }</a>
<a name="ln2595"> </a>
<a name="ln2596">  /* Need to redraw the lines we inspected, which might be further down than</a>
<a name="ln2597">   * was asked for. */</a>
<a name="ln2598">  if (bot &lt; flp-&gt;lnum - 1)</a>
<a name="ln2599">    bot = flp-&gt;lnum - 1;</a>
<a name="ln2600"> </a>
<a name="ln2601">  return bot;</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">/* foldInsert() {{{2 */</a>
<a name="ln2605">/*</a>
<a name="ln2606"> * Insert a new fold in &quot;gap&quot; at position &quot;i&quot;.</a>
<a name="ln2607"> */</a>
<a name="ln2608">static void foldInsert(garray_T *gap, int i)</a>
<a name="ln2609">{</a>
<a name="ln2610">  fold_T      *fp;</a>
<a name="ln2611"> </a>
<a name="ln2612">  ga_grow(gap, 1);</a>
<a name="ln2613"> </a>
<a name="ln2614">  fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln2615">  if (gap-&gt;ga_len &gt; 0 &amp;&amp; i &lt; gap-&gt;ga_len) {</a>
<a name="ln2616">    memmove(fp + 1, fp, sizeof(fold_T) * (size_t)(gap-&gt;ga_len - i));</a>
<a name="ln2617">  }</a>
<a name="ln2618">  gap-&gt;ga_len++;</a>
<a name="ln2619">  ga_init(&amp;fp-&gt;fd_nested, (int)sizeof(fold_T), 10);</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">/* foldSplit() {{{2 */</a>
<a name="ln2623">/*</a>
<a name="ln2624"> * Split the &quot;i&quot;th fold in &quot;gap&quot;, which starts before &quot;top&quot; and ends below</a>
<a name="ln2625"> * &quot;bot&quot; in two pieces, one ending above &quot;top&quot; and the other starting below</a>
<a name="ln2626"> * &quot;bot&quot;.</a>
<a name="ln2627"> * The caller must first have taken care of any nested folds from &quot;top&quot; to</a>
<a name="ln2628"> * &quot;bot&quot;!</a>
<a name="ln2629"> */</a>
<a name="ln2630">static void foldSplit(buf_T *buf, garray_T *const gap,</a>
<a name="ln2631">                      const int i, const linenr_T top,</a>
<a name="ln2632">                      const linenr_T bot</a>
<a name="ln2633">                      )</a>
<a name="ln2634">{</a>
<a name="ln2635">  fold_T      *fp2;</a>
<a name="ln2636"> </a>
<a name="ln2637">  /* The fold continues below bot, need to split it. */</a>
<a name="ln2638">  foldInsert(gap, i + 1);</a>
<a name="ln2639"> </a>
<a name="ln2640">  fold_T *const fp = (fold_T *)gap-&gt;ga_data + i;</a>
<a name="ln2641">  fp[1].fd_top = bot + 1;</a>
<a name="ln2642">  // check for wrap around (MAXLNUM, and 32bit)</a>
<a name="ln2643">  assert(fp[1].fd_top &gt; bot);</a>
<a name="ln2644">  fp[1].fd_len = fp-&gt;fd_len - (fp[1].fd_top - fp-&gt;fd_top);</a>
<a name="ln2645">  fp[1].fd_flags = fp-&gt;fd_flags;</a>
<a name="ln2646">  fp[1].fd_small = kNone;</a>
<a name="ln2647">  fp-&gt;fd_small = kNone;</a>
<a name="ln2648"> </a>
<a name="ln2649">  /* Move nested folds below bot to new fold.  There can't be</a>
<a name="ln2650">   * any between top and bot, they have been removed by the caller. */</a>
<a name="ln2651">  garray_T *const gap1 = &amp;fp-&gt;fd_nested;</a>
<a name="ln2652">  garray_T *const gap2 = &amp;fp[1].fd_nested;</a>
<a name="ln2653">  if (foldFind(gap1, bot + 1 - fp-&gt;fd_top, &amp;fp2)) {</a>
<a name="ln2654">    const int len = (int)((fold_T *)gap1-&gt;ga_data + gap1-&gt;ga_len - fp2);</a>
<a name="ln2655">    if (len &gt; 0) {</a>
<a name="ln2656">      ga_grow(gap2, len);</a>
<a name="ln2657">      for (int idx = 0; idx &lt; len; idx++) {</a>
<a name="ln2658">        ((fold_T *)gap2-&gt;ga_data)[idx] = fp2[idx];</a>
<a name="ln2659">        ((fold_T *)gap2-&gt;ga_data)[idx].fd_top</a>
<a name="ln2660">          -= fp[1].fd_top - fp-&gt;fd_top;</a>
<a name="ln2661">      }</a>
<a name="ln2662">      gap2-&gt;ga_len = len;</a>
<a name="ln2663">      gap1-&gt;ga_len -= len;</a>
<a name="ln2664">    }</a>
<a name="ln2665">  }</a>
<a name="ln2666">  fp-&gt;fd_len = top - fp-&gt;fd_top;</a>
<a name="ln2667">  fold_changed = true;</a>
<a name="ln2668">}</a>
<a name="ln2669"> </a>
<a name="ln2670">/* foldRemove() {{{2 */</a>
<a name="ln2671">/*</a>
<a name="ln2672"> * Remove folds within the range &quot;top&quot; to and including &quot;bot&quot;.</a>
<a name="ln2673"> * Check for these situations:</a>
<a name="ln2674"> *      1  2  3</a>
<a name="ln2675"> *      1  2  3</a>
<a name="ln2676"> * top     2  3  4  5</a>
<a name="ln2677"> *     2  3  4  5</a>
<a name="ln2678"> * bot     2  3  4  5</a>
<a name="ln2679"> *        3     5  6</a>
<a name="ln2680"> *        3     5  6</a>
<a name="ln2681"> *</a>
<a name="ln2682"> * 1: not changed</a>
<a name="ln2683"> * 2: truncate to stop above &quot;top&quot;</a>
<a name="ln2684"> * 3: split in two parts, one stops above &quot;top&quot;, other starts below &quot;bot&quot;.</a>
<a name="ln2685"> * 4: deleted</a>
<a name="ln2686"> * 5: made to start below &quot;bot&quot;.</a>
<a name="ln2687"> * 6: not changed</a>
<a name="ln2688"> */</a>
<a name="ln2689">static void foldRemove(</a>
<a name="ln2690">    win_T *const wp, garray_T *gap, linenr_T top, linenr_T bot</a>
<a name="ln2691">)</a>
<a name="ln2692">{</a>
<a name="ln2693">  fold_T      *fp = NULL;</a>
<a name="ln2694"> </a>
<a name="ln2695">  if (bot &lt; top) {</a>
<a name="ln2696">    return;             // nothing to do</a>
<a name="ln2697">  }</a>
<a name="ln2698"> </a>
<a name="ln2699">  while (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln2700">    // Find fold that includes top or a following one.</a>
<a name="ln2701">    if (foldFind(gap, top, &amp;fp) &amp;&amp; fp-&gt;fd_top &lt; top) {</a>
<a name="ln2702">      // 2: or 3: need to delete nested folds</a>
<a name="ln2703">      foldRemove(wp, &amp;fp-&gt;fd_nested, top - fp-&gt;fd_top, bot - fp-&gt;fd_top);</a>
<a name="ln2704">      if (fp-&gt;fd_top + fp-&gt;fd_len - 1 &gt; bot) {</a>
<a name="ln2705">        // 3: need to split it.</a>
<a name="ln2706">        foldSplit(wp-&gt;w_buffer, gap,</a>
<a name="ln2707">                  (int)(fp - (fold_T *)gap-&gt;ga_data), top, bot);</a>
<a name="ln2708">      } else {</a>
<a name="ln2709">        // 2: truncate fold at &quot;top&quot;.</a>
<a name="ln2710">        fp-&gt;fd_len = top - fp-&gt;fd_top;</a>
<a name="ln2711">      }</a>
<a name="ln2712">      fold_changed = true;</a>
<a name="ln2713">      continue;</a>
<a name="ln2714">    }</a>
<a name="ln2715">    if (gap-&gt;ga_data == NULL</a>
<a name="ln2716">        || fp &gt;= (fold_T *)(gap-&gt;ga_data) + gap-&gt;ga_len</a>
<a name="ln2717">        || fp-&gt;fd_top &gt; bot) {</a>
<a name="ln2718">      // 6: Found a fold below bot, can stop looking.</a>
<a name="ln2719">      break;</a>
<a name="ln2720">    }</a>
<a name="ln2721">    if (fp-&gt;fd_top &gt;= top) {</a>
<a name="ln2722">      // Found an entry below top.</a>
<a name="ln2723">      fold_changed = true;</a>
<a name="ln2724">      if (fp-&gt;fd_top + fp-&gt;fd_len - 1 &gt; bot) {</a>
<a name="ln2725">        // 5: Make fold that includes bot start below bot.</a>
<a name="ln2726">        foldMarkAdjustRecurse(</a>
<a name="ln2727">            wp, &amp;fp-&gt;fd_nested,</a>
<a name="ln2728">            (linenr_T)0, (long)(bot - fp-&gt;fd_top),</a>
<a name="ln2729">            (linenr_T)MAXLNUM, (long)(fp-&gt;fd_top - bot - 1));</a>
<a name="ln2730">        fp-&gt;fd_len -= bot - fp-&gt;fd_top + 1;</a>
<a name="ln2731">        fp-&gt;fd_top = bot + 1;</a>
<a name="ln2732">        break;</a>
<a name="ln2733">      }</a>
<a name="ln2734"> </a>
<a name="ln2735">      // 4: Delete completely contained fold.</a>
<a name="ln2736">      deleteFoldEntry(wp, gap, (int)(fp - (fold_T *)gap-&gt;ga_data), true);</a>
<a name="ln2737">    }</a>
<a name="ln2738">  }</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">// foldReverseOrder() {{{2</a>
<a name="ln2742">static void foldReverseOrder(</a>
<a name="ln2743">    garray_T *gap,</a>
<a name="ln2744">    const linenr_T start_arg,</a>
<a name="ln2745">    const linenr_T end_arg)</a>
<a name="ln2746">{</a>
<a name="ln2747">  linenr_T start = start_arg;</a>
<a name="ln2748">  linenr_T end = end_arg;</a>
<a name="ln2749">  for (; start &lt; end; start++, end--) {</a>
<a name="ln2750">    fold_T *left = (fold_T *)gap-&gt;ga_data + start;</a>
<a name="ln2751">    fold_T *right = (fold_T *)gap-&gt;ga_data + end;</a>
<a name="ln2752">    fold_T tmp = *left;</a>
<a name="ln2753">    *left = *right;</a>
<a name="ln2754">    *right = tmp;</a>
<a name="ln2755">  }</a>
<a name="ln2756">}</a>
<a name="ln2757"> </a>
<a name="ln2758">// foldMoveRange() {{{2</a>
<a name="ln2759">// Move folds within the inclusive range &quot;line1&quot; to &quot;line2&quot; to after &quot;dest&quot;</a>
<a name="ln2760">// require &quot;line1&quot; &lt;= &quot;line2&quot; &lt;= &quot;dest&quot;</a>
<a name="ln2761">//</a>
<a name="ln2762">// There are the following situations for the first fold at or below line1 - 1.</a>
<a name="ln2763">//       1  2  3  4</a>
<a name="ln2764">//       1  2  3  4</a>
<a name="ln2765">// line1    2  3  4</a>
<a name="ln2766">//          2  3  4  5  6  7</a>
<a name="ln2767">// line2       3  4  5  6  7</a>
<a name="ln2768">//             3  4     6  7  8  9</a>
<a name="ln2769">// dest           4        7  8  9</a>
<a name="ln2770">//                4        7  8    10</a>
<a name="ln2771">//                4        7  8    10</a>
<a name="ln2772">//</a>
<a name="ln2773">// In the following descriptions, &quot;moved&quot; means moving in the buffer, *and* in</a>
<a name="ln2774">// the fold array.</a>
<a name="ln2775">// Meanwhile, &quot;shifted&quot; just means moving in the buffer.</a>
<a name="ln2776">// 1. not changed</a>
<a name="ln2777">// 2. truncated above line1</a>
<a name="ln2778">// 3. length reduced by  line2 - line1, folds starting between the end of 3 and</a>
<a name="ln2779">//    dest are truncated and shifted up</a>
<a name="ln2780">// 4. internal folds moved (from [line1, line2] to dest)</a>
<a name="ln2781">// 5. moved to dest.</a>
<a name="ln2782">// 6. truncated below line2 and moved.</a>
<a name="ln2783">// 7. length reduced by line2 - dest, folds starting between line2 and dest are</a>
<a name="ln2784">//    removed, top is moved down by move_len.</a>
<a name="ln2785">// 8. truncated below dest and shifted up.</a>
<a name="ln2786">// 9. shifted up</a>
<a name="ln2787">// 10. not changed</a>
<a name="ln2788">static void truncate_fold(win_T *const wp, fold_T *fp, linenr_T end)</a>
<a name="ln2789">{</a>
<a name="ln2790">  // I want to stop *at here*, foldRemove() stops *above* top</a>
<a name="ln2791">  end += 1;</a>
<a name="ln2792">  foldRemove(wp, &amp;fp-&gt;fd_nested, end - fp-&gt;fd_top, MAXLNUM);</a>
<a name="ln2793">  fp-&gt;fd_len = end - fp-&gt;fd_top;</a>
<a name="ln2794">}</a>
<a name="ln2795"> </a>
<a name="ln2796">#define FOLD_END(fp) ((fp)-&gt;fd_top + (fp)-&gt;fd_len - 1)</a>
<a name="ln2797">#define VALID_FOLD(fp, gap) \</a>
<a name="ln2798">  ((gap)-&gt;ga_len &gt; 0 &amp;&amp; (fp) &lt; ((fold_T *)(gap)-&gt;ga_data + (gap)-&gt;ga_len))</a>
<a name="ln2799">#define FOLD_INDEX(fp, gap) ((size_t)(fp - ((fold_T *)(gap)-&gt;ga_data)))</a>
<a name="ln2800">void foldMoveRange(</a>
<a name="ln2801">    win_T *const wp, garray_T *gap,</a>
<a name="ln2802">    const linenr_T line1, const linenr_T line2,</a>
<a name="ln2803">    const linenr_T dest</a>
<a name="ln2804">)</a>
<a name="ln2805">{</a>
<a name="ln2806">  fold_T *fp;</a>
<a name="ln2807">  const linenr_T range_len = line2 - line1 + 1;</a>
<a name="ln2808">  const linenr_T move_len = dest - line2;</a>
<a name="ln2809">  const bool at_start = foldFind(gap, line1 - 1, &amp;fp);</a>
<a name="ln2810"> </a>
<a name="ln2811">  if (at_start) {</a>
<a name="ln2812">    if (FOLD_END(fp) &gt; dest) {</a>
<a name="ln2813">      // Case 4 -- don't have to change this fold, but have to move nested</a>
<a name="ln2814">      // folds.</a>
<a name="ln2815">      foldMoveRange(wp, &amp;fp-&gt;fd_nested, line1 - fp-&gt;fd_top, line2 -</a>
<a name="ln2816">                    fp-&gt;fd_top, dest - fp-&gt;fd_top);</a>
<a name="ln2817">      return;</a>
<a name="ln2818">    } else if (FOLD_END(fp) &gt; line2) {</a>
<a name="ln2819">      // Case 3 -- Remove nested folds between line1 and line2 &amp; reduce the</a>
<a name="ln2820">      // length of fold by &quot;range_len&quot;.</a>
<a name="ln2821">      // Folds after this one must be dealt with.</a>
<a name="ln2822">      foldMarkAdjustRecurse(wp, &amp;fp-&gt;fd_nested, line1 - fp-&gt;fd_top,</a>
<a name="ln2823">                            line2 - fp-&gt;fd_top, MAXLNUM, -range_len);</a>
<a name="ln2824">      fp-&gt;fd_len -= range_len;</a>
<a name="ln2825">    } else {</a>
<a name="ln2826">      // Case 2 -- truncate fold *above* line1.</a>
<a name="ln2827">      // Folds after this one must be dealt with.</a>
<a name="ln2828">      truncate_fold(wp, fp, line1 - 1);</a>
<a name="ln2829">    }</a>
<a name="ln2830">    // Look at the next fold, and treat that one as if it were the first after</a>
<a name="ln2831">    // &quot;line1&quot; (because now it is).</a>
<a name="ln2832">    fp = fp + 1;</a>
<a name="ln2833">  }</a>
<a name="ln2834"> </a>
<a name="ln2835">  if (!VALID_FOLD(fp, gap) || fp-&gt;fd_top &gt; dest) {</a>
<a name="ln2836">    // No folds after &quot;line1&quot; and before &quot;dest&quot;</a>
<a name="ln2837">    // Case 10.</a>
<a name="ln2838">    return;</a>
<a name="ln2839">  } else if (fp-&gt;fd_top &gt; line2) {</a>
<a name="ln2840">    for (; VALID_FOLD(fp, gap) &amp;&amp; FOLD_END(fp) &lt;= dest; fp++) {</a>
<a name="ln2841">      // Case 9. (for all case 9's) -- shift up.</a>
<a name="ln2842">      fp-&gt;fd_top -= range_len;</a>
<a name="ln2843">    }</a>
<a name="ln2844">    if (VALID_FOLD(fp, gap) &amp;&amp; fp-&gt;fd_top &lt;= dest) {</a>
<a name="ln2845">      // Case 8. -- ensure truncated at dest, shift up</a>
<a name="ln2846">      truncate_fold(wp, fp, dest);</a>
<a name="ln2847">      fp-&gt;fd_top -= range_len;</a>
<a name="ln2848">    }</a>
<a name="ln2849">    return;</a>
<a name="ln2850">  } else if (FOLD_END(fp) &gt; dest) {</a>
<a name="ln2851">    // Case 7 -- remove nested folds and shrink</a>
<a name="ln2852">    foldMarkAdjustRecurse(wp, &amp;fp-&gt;fd_nested, line2 + 1 - fp-&gt;fd_top,</a>
<a name="ln2853">                          dest - fp-&gt;fd_top, MAXLNUM, -move_len);</a>
<a name="ln2854">    fp-&gt;fd_len -= move_len;</a>
<a name="ln2855">    fp-&gt;fd_top += move_len;</a>
<a name="ln2856">    return;</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">  // Case 5 or 6: changes rely on whether there are folds between the end of</a>
<a name="ln2860">  // this fold and &quot;dest&quot;.</a>
<a name="ln2861">  size_t move_start = FOLD_INDEX(fp, gap);</a>
<a name="ln2862">  size_t move_end = 0, dest_index = 0;</a>
<a name="ln2863">  for (; VALID_FOLD(fp, gap) &amp;&amp; fp-&gt;fd_top &lt;= dest; fp++) {</a>
<a name="ln2864">    if (fp-&gt;fd_top &lt;= line2) {</a>
<a name="ln2865">      // 5, or 6</a>
<a name="ln2866">      if (FOLD_END(fp) &gt; line2) {</a>
<a name="ln2867">        // 6, truncate before moving</a>
<a name="ln2868">        truncate_fold(wp, fp, line2);</a>
<a name="ln2869">      }</a>
<a name="ln2870">      fp-&gt;fd_top += move_len;</a>
<a name="ln2871">      continue;</a>
<a name="ln2872">    }</a>
<a name="ln2873"> </a>
<a name="ln2874">    // Record index of the first fold after the moved range.</a>
<a name="ln2875">    if (move_end == 0) {</a>
<a name="ln2876">      move_end = FOLD_INDEX(fp, gap);</a>
<a name="ln2877">    }</a>
<a name="ln2878"> </a>
<a name="ln2879">    if (FOLD_END(fp) &gt; dest) {</a>
<a name="ln2880">      truncate_fold(wp, fp, dest);</a>
<a name="ln2881">    }</a>
<a name="ln2882"> </a>
<a name="ln2883">    fp-&gt;fd_top -= range_len;</a>
<a name="ln2884">  }</a>
<a name="ln2885">  dest_index = FOLD_INDEX(fp, gap);</a>
<a name="ln2886"> </a>
<a name="ln2887">  // All folds are now correct, but not necessarily in the correct order.</a>
<a name="ln2888">  // We must swap folds in the range [move_end, dest_index) with those in the</a>
<a name="ln2889">  // range [move_start, move_end).</a>
<a name="ln2890">  if (move_end == 0) {</a>
<a name="ln2891">    // There are no folds after those moved, so none were moved out of order.</a>
<a name="ln2892">    return;</a>
<a name="ln2893">  }</a>
<a name="ln2894">  foldReverseOrder(gap, (linenr_T)move_start, (linenr_T)(dest_index - 1));</a>
<a name="ln2895">  foldReverseOrder(gap, (linenr_T)move_start,</a>
<a name="ln2896">                   (linenr_T)(move_start + dest_index - move_end - 1));</a>
<a name="ln2897">  foldReverseOrder(gap, (linenr_T)(move_start + dest_index - move_end),</a>
<a name="ln2898">                   (linenr_T)(dest_index - 1));</a>
<a name="ln2899">}</a>
<a name="ln2900">#undef FOLD_END</a>
<a name="ln2901">#undef VALID_FOLD</a>
<a name="ln2902">#undef FOLD_INDEX</a>
<a name="ln2903"> </a>
<a name="ln2904">/* foldMerge() {{{2 */</a>
<a name="ln2905">/*</a>
<a name="ln2906"> * Merge two adjacent folds (and the nested ones in them).</a>
<a name="ln2907"> * This only works correctly when the folds are really adjacent!  Thus &quot;fp1&quot;</a>
<a name="ln2908"> * must end just above &quot;fp2&quot;.</a>
<a name="ln2909"> * The resulting fold is &quot;fp1&quot;, nested folds are moved from &quot;fp2&quot; to &quot;fp1&quot;.</a>
<a name="ln2910"> * Fold entry &quot;fp2&quot; in &quot;gap&quot; is deleted.</a>
<a name="ln2911"> */</a>
<a name="ln2912">static void foldMerge(win_T *const wp, fold_T *fp1, garray_T *gap, fold_T *fp2)</a>
<a name="ln2913">{</a>
<a name="ln2914">  fold_T      *fp3;</a>
<a name="ln2915">  fold_T      *fp4;</a>
<a name="ln2916">  int idx;</a>
<a name="ln2917">  garray_T    *gap1 = &amp;fp1-&gt;fd_nested;</a>
<a name="ln2918">  garray_T    *gap2 = &amp;fp2-&gt;fd_nested;</a>
<a name="ln2919"> </a>
<a name="ln2920">  /* If the last nested fold in fp1 touches the first nested fold in fp2,</a>
<a name="ln2921">   * merge them recursively. */</a>
<a name="ln2922">  if (foldFind(gap1, fp1-&gt;fd_len - 1L, &amp;fp3) &amp;&amp; foldFind(gap2, 0L, &amp;fp4)) {</a>
<a name="ln2923">    foldMerge(wp, fp3, gap2, fp4);</a>
<a name="ln2924">  }</a>
<a name="ln2925"> </a>
<a name="ln2926">  /* Move nested folds in fp2 to the end of fp1. */</a>
<a name="ln2927">  if (!GA_EMPTY(gap2)) {</a>
<a name="ln2928">    ga_grow(gap1, gap2-&gt;ga_len);</a>
<a name="ln2929">    for (idx = 0; idx &lt; gap2-&gt;ga_len; ++idx) {</a>
<a name="ln2930">      ((fold_T *)gap1-&gt;ga_data)[gap1-&gt;ga_len]</a>
<a name="ln2931">        = ((fold_T *)gap2-&gt;ga_data)[idx];</a>
<a name="ln2932">      ((fold_T *)gap1-&gt;ga_data)[gap1-&gt;ga_len].fd_top += fp1-&gt;fd_len;</a>
<a name="ln2933">      ++gap1-&gt;ga_len;</a>
<a name="ln2934">    }</a>
<a name="ln2935">    gap2-&gt;ga_len = 0;</a>
<a name="ln2936">  }</a>
<a name="ln2937"> </a>
<a name="ln2938">  fp1-&gt;fd_len += fp2-&gt;fd_len;</a>
<a name="ln2939">  deleteFoldEntry(wp, gap, (int)(fp2 - (fold_T *)gap-&gt;ga_data), true);</a>
<a name="ln2940">  fold_changed = true;</a>
<a name="ln2941">}</a>
<a name="ln2942"> </a>
<a name="ln2943">/* foldlevelIndent() {{{2 */</a>
<a name="ln2944">/*</a>
<a name="ln2945"> * Low level function to get the foldlevel for the &quot;indent&quot; method.</a>
<a name="ln2946"> * Doesn't use any caching.</a>
<a name="ln2947"> * Returns a level of -1 if the foldlevel depends on surrounding lines.</a>
<a name="ln2948"> */</a>
<a name="ln2949">static void foldlevelIndent(fline_T *flp)</a>
<a name="ln2950">{</a>
<a name="ln2951">  char_u      *s;</a>
<a name="ln2952">  buf_T       *buf;</a>
<a name="ln2953">  linenr_T lnum = flp-&gt;lnum + flp-&gt;off;</a>
<a name="ln2954"> </a>
<a name="ln2955">  buf = flp-&gt;wp-&gt;w_buffer;</a>
<a name="ln2956">  s = skipwhite(ml_get_buf(buf, lnum, FALSE));</a>
<a name="ln2957"> </a>
<a name="ln2958">  /* empty line or lines starting with a character in 'foldignore': level</a>
<a name="ln2959">   * depends on surrounding lines */</a>
<a name="ln2960">  if (*s == NUL || vim_strchr(flp-&gt;wp-&gt;w_p_fdi, *s) != NULL) {</a>
<a name="ln2961">    /* first and last line can't be undefined, use level 0 */</a>
<a name="ln2962">    if (lnum == 1 || lnum == buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2963">      flp-&gt;lvl = 0;</a>
<a name="ln2964">    else</a>
<a name="ln2965">      flp-&gt;lvl = -1;</a>
<a name="ln2966">  } else {</a>
<a name="ln2967">    flp-&gt;lvl = get_indent_buf(buf, lnum) / get_sw_value(buf);</a>
<a name="ln2968">  }</a>
<a name="ln2969">  if (flp-&gt;lvl &gt; flp-&gt;wp-&gt;w_p_fdn) {</a>
<a name="ln2970">    flp-&gt;lvl = (int) MAX(0, flp-&gt;wp-&gt;w_p_fdn);</a>
<a name="ln2971">  }</a>
<a name="ln2972">}</a>
<a name="ln2973"> </a>
<a name="ln2974">/* foldlevelDiff() {{{2 */</a>
<a name="ln2975">/*</a>
<a name="ln2976"> * Low level function to get the foldlevel for the &quot;diff&quot; method.</a>
<a name="ln2977"> * Doesn't use any caching.</a>
<a name="ln2978"> */</a>
<a name="ln2979">static void foldlevelDiff(fline_T *flp)</a>
<a name="ln2980">{</a>
<a name="ln2981">  if (diff_infold(flp-&gt;wp, flp-&gt;lnum + flp-&gt;off))</a>
<a name="ln2982">    flp-&gt;lvl = 1;</a>
<a name="ln2983">  else</a>
<a name="ln2984">    flp-&gt;lvl = 0;</a>
<a name="ln2985">}</a>
<a name="ln2986"> </a>
<a name="ln2987">/* foldlevelExpr() {{{2 */</a>
<a name="ln2988">/*</a>
<a name="ln2989"> * Low level function to get the foldlevel for the &quot;expr&quot; method.</a>
<a name="ln2990"> * Doesn't use any caching.</a>
<a name="ln2991"> * Returns a level of -1 if the foldlevel depends on surrounding lines.</a>
<a name="ln2992"> */</a>
<a name="ln2993">static void foldlevelExpr(fline_T *flp)</a>
<a name="ln2994">{</a>
<a name="ln2995">  win_T       *win;</a>
<a name="ln2996">  int n;</a>
<a name="ln2997">  int c;</a>
<a name="ln2998">  linenr_T lnum = flp-&gt;lnum + flp-&gt;off;</a>
<a name="ln2999"> </a>
<a name="ln3000">  win = curwin;</a>
<a name="ln3001">  curwin = flp-&gt;wp;</a>
<a name="ln3002">  curbuf = flp-&gt;wp-&gt;w_buffer;</a>
<a name="ln3003">  set_vim_var_nr(VV_LNUM, (varnumber_T) lnum);</a>
<a name="ln3004"> </a>
<a name="ln3005">  flp-&gt;start = 0;</a>
<a name="ln3006">  flp-&gt;had_end = flp-&gt;end;</a>
<a name="ln3007">  flp-&gt;end = MAX_LEVEL + 1;</a>
<a name="ln3008">  if (lnum &lt;= 1)</a>
<a name="ln3009">    flp-&gt;lvl = 0;</a>
<a name="ln3010"> </a>
<a name="ln3011">  /* KeyTyped may be reset to 0 when calling a function which invokes</a>
<a name="ln3012">   * do_cmdline().  To make 'foldopen' work correctly restore KeyTyped. */</a>
<a name="ln3013">  const bool save_keytyped = KeyTyped;</a>
<a name="ln3014">  n = (int)eval_foldexpr(flp-&gt;wp-&gt;w_p_fde, &amp;c);</a>
<a name="ln3015">  KeyTyped = save_keytyped;</a>
<a name="ln3016"> </a>
<a name="ln3017">  switch (c) {</a>
<a name="ln3018">  /* &quot;a1&quot;, &quot;a2&quot;, .. : add to the fold level */</a>
<a name="ln3019">  case 'a': if (flp-&gt;lvl &gt;= 0) {</a>
<a name="ln3020">      flp-&gt;lvl += n;</a>
<a name="ln3021">      flp-&gt;lvl_next = flp-&gt;lvl;</a>
<a name="ln3022">  }</a>
<a name="ln3023">    flp-&gt;start = n;</a>
<a name="ln3024">    break;</a>
<a name="ln3025"> </a>
<a name="ln3026">  /* &quot;s1&quot;, &quot;s2&quot;, .. : subtract from the fold level */</a>
<a name="ln3027">  case 's': if (flp-&gt;lvl &gt;= 0) {</a>
<a name="ln3028">      if (n &gt; flp-&gt;lvl)</a>
<a name="ln3029">        flp-&gt;lvl_next = 0;</a>
<a name="ln3030">      else</a>
<a name="ln3031">        flp-&gt;lvl_next = flp-&gt;lvl - n;</a>
<a name="ln3032">      flp-&gt;end = flp-&gt;lvl_next + 1;</a>
<a name="ln3033">  }</a>
<a name="ln3034">    break;</a>
<a name="ln3035"> </a>
<a name="ln3036">  /* &quot;&gt;1&quot;, &quot;&gt;2&quot;, .. : start a fold with a certain level */</a>
<a name="ln3037">  case '&gt;': flp-&gt;lvl = n;</a>
<a name="ln3038">    flp-&gt;lvl_next = n;</a>
<a name="ln3039">    flp-&gt;start = 1;</a>
<a name="ln3040">    break;</a>
<a name="ln3041"> </a>
<a name="ln3042">  /* &quot;&lt;1&quot;, &quot;&lt;2&quot;, .. : end a fold with a certain level */</a>
<a name="ln3043">  case '&lt;': flp-&gt;lvl_next = n - 1;</a>
<a name="ln3044">    flp-&gt;end = n;</a>
<a name="ln3045">    break;</a>
<a name="ln3046"> </a>
<a name="ln3047">  /* &quot;=&quot;: No change in level */</a>
<a name="ln3048">  case '=': flp-&gt;lvl_next = flp-&gt;lvl;</a>
<a name="ln3049">    break;</a>
<a name="ln3050"> </a>
<a name="ln3051">  /* &quot;-1&quot;, &quot;0&quot;, &quot;1&quot;, ..: set fold level */</a>
<a name="ln3052">  default:  if (n &lt; 0)</a>
<a name="ln3053">      /* Use the current level for the next line, so that &quot;a1&quot;</a>
<a name="ln3054">       * will work there. */</a>
<a name="ln3055">      flp-&gt;lvl_next = flp-&gt;lvl;</a>
<a name="ln3056">    else</a>
<a name="ln3057">      flp-&gt;lvl_next = n;</a>
<a name="ln3058">    flp-&gt;lvl = n;</a>
<a name="ln3059">    break;</a>
<a name="ln3060">  }</a>
<a name="ln3061"> </a>
<a name="ln3062">  /* If the level is unknown for the first or the last line in the file, use</a>
<a name="ln3063">   * level 0. */</a>
<a name="ln3064">  if (flp-&gt;lvl &lt; 0) {</a>
<a name="ln3065">    if (lnum &lt;= 1) {</a>
<a name="ln3066">      flp-&gt;lvl = 0;</a>
<a name="ln3067">      flp-&gt;lvl_next = 0;</a>
<a name="ln3068">    }</a>
<a name="ln3069">    if (lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3070">      flp-&gt;lvl_next = 0;</a>
<a name="ln3071">  }</a>
<a name="ln3072"> </a>
<a name="ln3073">  curwin = win;</a>
<a name="ln3074">  curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">/* parseMarker() {{{2 */</a>
<a name="ln3078">/*</a>
<a name="ln3079"> * Parse 'foldmarker' and set &quot;foldendmarker&quot;, &quot;foldstartmarkerlen&quot; and</a>
<a name="ln3080"> * &quot;foldendmarkerlen&quot;.</a>
<a name="ln3081"> * Relies on the option value to have been checked for correctness already.</a>
<a name="ln3082"> */</a>
<a name="ln3083">static void parseMarker(win_T *wp)</a>
<a name="ln3084">{</a>
<a name="ln3085">  foldendmarker = vim_strchr(wp-&gt;w_p_fmr, ',');</a>
<a name="ln3086">  foldstartmarkerlen = (size_t)(foldendmarker++ - wp-&gt;w_p_fmr);</a>
<a name="ln3087">  foldendmarkerlen = STRLEN(foldendmarker);</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">/* foldlevelMarker() {{{2 */</a>
<a name="ln3091">/*</a>
<a name="ln3092"> * Low level function to get the foldlevel for the &quot;marker&quot; method.</a>
<a name="ln3093"> * &quot;foldendmarker&quot;, &quot;foldstartmarkerlen&quot; and &quot;foldendmarkerlen&quot; must have been</a>
<a name="ln3094"> * set before calling this.</a>
<a name="ln3095"> * Requires that flp-&gt;lvl is set to the fold level of the previous line!</a>
<a name="ln3096"> * Careful: This means you can't call this function twice on the same line.</a>
<a name="ln3097"> * Doesn't use any caching.</a>
<a name="ln3098"> * Sets flp-&gt;start when a start marker was found.</a>
<a name="ln3099"> */</a>
<a name="ln3100">static void foldlevelMarker(fline_T *flp)</a>
<a name="ln3101">{</a>
<a name="ln3102">  char_u      *startmarker;</a>
<a name="ln3103">  int cstart;</a>
<a name="ln3104">  int cend;</a>
<a name="ln3105">  int start_lvl = flp-&gt;lvl;</a>
<a name="ln3106">  char_u      *s;</a>
<a name="ln3107">  int n;</a>
<a name="ln3108"> </a>
<a name="ln3109">  /* cache a few values for speed */</a>
<a name="ln3110">  startmarker = flp-&gt;wp-&gt;w_p_fmr;</a>
<a name="ln3111">  cstart = *startmarker;</a>
<a name="ln3112">  ++startmarker;</a>
<a name="ln3113">  cend = *foldendmarker;</a>
<a name="ln3114"> </a>
<a name="ln3115">  /* Default: no start found, next level is same as current level */</a>
<a name="ln3116">  flp-&gt;start = 0;</a>
<a name="ln3117">  flp-&gt;lvl_next = flp-&gt;lvl;</a>
<a name="ln3118"> </a>
<a name="ln3119">  s = ml_get_buf(flp-&gt;wp-&gt;w_buffer, flp-&gt;lnum + flp-&gt;off, FALSE);</a>
<a name="ln3120">  while (*s) {</a>
<a name="ln3121">    if (*s == cstart</a>
<a name="ln3122">        &amp;&amp; STRNCMP(s + 1, startmarker, foldstartmarkerlen - 1) == 0) {</a>
<a name="ln3123">      /* found startmarker: set flp-&gt;lvl */</a>
<a name="ln3124">      s += foldstartmarkerlen;</a>
<a name="ln3125">      if (ascii_isdigit(*s)) {</a>
<a name="ln3126">        n = atoi((char *)s);</a>
<a name="ln3127">        if (n &gt; 0) {</a>
<a name="ln3128">          flp-&gt;lvl = n;</a>
<a name="ln3129">          flp-&gt;lvl_next = n;</a>
<a name="ln3130">          if (n &lt;= start_lvl)</a>
<a name="ln3131">            flp-&gt;start = 1;</a>
<a name="ln3132">          else</a>
<a name="ln3133">            flp-&gt;start = n - start_lvl;</a>
<a name="ln3134">        }</a>
<a name="ln3135">      } else {</a>
<a name="ln3136">        ++flp-&gt;lvl;</a>
<a name="ln3137">        ++flp-&gt;lvl_next;</a>
<a name="ln3138">        ++flp-&gt;start;</a>
<a name="ln3139">      }</a>
<a name="ln3140">    } else if (*s == cend &amp;&amp; STRNCMP(s + 1, foldendmarker + 1,</a>
<a name="ln3141">                                     foldendmarkerlen - 1) == 0) {</a>
<a name="ln3142">      /* found endmarker: set flp-&gt;lvl_next */</a>
<a name="ln3143">      s += foldendmarkerlen;</a>
<a name="ln3144">      if (ascii_isdigit(*s)) {</a>
<a name="ln3145">        n = atoi((char *)s);</a>
<a name="ln3146">        if (n &gt; 0) {</a>
<a name="ln3147">          flp-&gt;lvl = n;</a>
<a name="ln3148">          flp-&gt;lvl_next = n - 1;</a>
<a name="ln3149">          /* never start a fold with an end marker */</a>
<a name="ln3150">          if (flp-&gt;lvl_next &gt; start_lvl)</a>
<a name="ln3151">            flp-&gt;lvl_next = start_lvl;</a>
<a name="ln3152">        }</a>
<a name="ln3153">      } else {</a>
<a name="ln3154">        flp-&gt;lvl_next--;</a>
<a name="ln3155">      }</a>
<a name="ln3156">    } else {</a>
<a name="ln3157">      MB_PTR_ADV(s);</a>
<a name="ln3158">    }</a>
<a name="ln3159">  }</a>
<a name="ln3160"> </a>
<a name="ln3161">  /* The level can't go negative, must be missing a start marker. */</a>
<a name="ln3162">  if (flp-&gt;lvl_next &lt; 0)</a>
<a name="ln3163">    flp-&gt;lvl_next = 0;</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166">/* foldlevelSyntax() {{{2 */</a>
<a name="ln3167">/*</a>
<a name="ln3168"> * Low level function to get the foldlevel for the &quot;syntax&quot; method.</a>
<a name="ln3169"> * Doesn't use any caching.</a>
<a name="ln3170"> */</a>
<a name="ln3171">static void foldlevelSyntax(fline_T *flp)</a>
<a name="ln3172">{</a>
<a name="ln3173">  linenr_T lnum = flp-&gt;lnum + flp-&gt;off;</a>
<a name="ln3174">  int n;</a>
<a name="ln3175"> </a>
<a name="ln3176">  /* Use the maximum fold level at the start of this line and the next. */</a>
<a name="ln3177">  flp-&gt;lvl = syn_get_foldlevel(flp-&gt;wp, lnum);</a>
<a name="ln3178">  flp-&gt;start = 0;</a>
<a name="ln3179">  if (lnum &lt; flp-&gt;wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln3180">    n = syn_get_foldlevel(flp-&gt;wp, lnum + 1);</a>
<a name="ln3181">    if (n &gt; flp-&gt;lvl) {</a>
<a name="ln3182">      flp-&gt;start = n - flp-&gt;lvl;        /* fold(s) start here */</a>
<a name="ln3183">      flp-&gt;lvl = n;</a>
<a name="ln3184">    }</a>
<a name="ln3185">  }</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188">/* functions for storing the fold state in a View {{{1 */</a>
<a name="ln3189">/* put_folds() {{{2 */</a>
<a name="ln3190"> </a>
<a name="ln3191">/*</a>
<a name="ln3192"> * Write commands to &quot;fd&quot; to restore the manual folds in window &quot;wp&quot;.</a>
<a name="ln3193"> * Return FAIL if writing fails.</a>
<a name="ln3194"> */</a>
<a name="ln3195">int put_folds(FILE *fd, win_T *wp)</a>
<a name="ln3196">{</a>
<a name="ln3197">  if (foldmethodIsManual(wp)) {</a>
<a name="ln3198">    if (put_line(fd, &quot;silent! normal! zE&quot;) == FAIL</a>
<a name="ln3199">        || put_folds_recurse(fd, &amp;wp-&gt;w_folds, (linenr_T)0) == FAIL)</a>
<a name="ln3200">      return FAIL;</a>
<a name="ln3201">  }</a>
<a name="ln3202"> </a>
<a name="ln3203">  /* If some folds are manually opened/closed, need to restore that. */</a>
<a name="ln3204">  if (wp-&gt;w_fold_manual)</a>
<a name="ln3205">    return put_foldopen_recurse(fd, wp, &amp;wp-&gt;w_folds, (linenr_T)0);</a>
<a name="ln3206"> </a>
<a name="ln3207">  return OK;</a>
<a name="ln3208">}</a>
<a name="ln3209"> </a>
<a name="ln3210">/* put_folds_recurse() {{{2 */</a>
<a name="ln3211">/*</a>
<a name="ln3212"> * Write commands to &quot;fd&quot; to recreate manually created folds.</a>
<a name="ln3213"> * Returns FAIL when writing failed.</a>
<a name="ln3214"> */</a>
<a name="ln3215">static int put_folds_recurse(FILE *fd, garray_T *gap, linenr_T off)</a>
<a name="ln3216">{</a>
<a name="ln3217">  fold_T *fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln3218">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln3219">    /* Do nested folds first, they will be created closed. */</a>
<a name="ln3220">    if (put_folds_recurse(fd, &amp;fp-&gt;fd_nested, off + fp-&gt;fd_top) == FAIL)</a>
<a name="ln3221">      return FAIL;</a>
<a name="ln3222">    if (fprintf(fd, &quot;%&quot; PRId64 &quot;,%&quot; PRId64 &quot;fold&quot;,</a>
<a name="ln3223">                (int64_t)(fp-&gt;fd_top + off),</a>
<a name="ln3224">                (int64_t)(fp-&gt;fd_top + off + fp-&gt;fd_len - 1)) &lt; 0</a>
<a name="ln3225">        || put_eol(fd) == FAIL)</a>
<a name="ln3226">      return FAIL;</a>
<a name="ln3227">    ++fp;</a>
<a name="ln3228">  }</a>
<a name="ln3229">  return OK;</a>
<a name="ln3230">}</a>
<a name="ln3231"> </a>
<a name="ln3232">/* put_foldopen_recurse() {{{2 */</a>
<a name="ln3233">/*</a>
<a name="ln3234"> * Write commands to &quot;fd&quot; to open and close manually opened/closed folds.</a>
<a name="ln3235"> * Returns FAIL when writing failed.</a>
<a name="ln3236"> */</a>
<a name="ln3237">static int put_foldopen_recurse(FILE *fd, win_T *wp, garray_T *gap, linenr_T off)</a>
<a name="ln3238">{</a>
<a name="ln3239">  int level;</a>
<a name="ln3240"> </a>
<a name="ln3241">  fold_T *fp = (fold_T *)gap-&gt;ga_data;</a>
<a name="ln3242">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln3243">    if (fp-&gt;fd_flags != FD_LEVEL) {</a>
<a name="ln3244">      if (!GA_EMPTY(&amp;fp-&gt;fd_nested)) {</a>
<a name="ln3245">        /* open nested folds while this fold is open */</a>
<a name="ln3246">        if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(fp-&gt;fd_top + off)) &lt; 0</a>
<a name="ln3247">            || put_eol(fd) == FAIL</a>
<a name="ln3248">            || put_line(fd, &quot;normal! zo&quot;) == FAIL)</a>
<a name="ln3249">          return FAIL;</a>
<a name="ln3250">        if (put_foldopen_recurse(fd, wp, &amp;fp-&gt;fd_nested,</a>
<a name="ln3251">                off + fp-&gt;fd_top)</a>
<a name="ln3252">            == FAIL)</a>
<a name="ln3253">          return FAIL;</a>
<a name="ln3254">        /* close the parent when needed */</a>
<a name="ln3255">        if (fp-&gt;fd_flags == FD_CLOSED) {</a>
<a name="ln3256">          if (put_fold_open_close(fd, fp, off) == FAIL)</a>
<a name="ln3257">            return FAIL;</a>
<a name="ln3258">        }</a>
<a name="ln3259">      } else {</a>
<a name="ln3260">        /* Open or close the leaf according to the window foldlevel.</a>
<a name="ln3261">         * Do not close a leaf that is already closed, as it will close</a>
<a name="ln3262">         * the parent. */</a>
<a name="ln3263">        level = foldLevelWin(wp, off + fp-&gt;fd_top);</a>
<a name="ln3264">        if ((fp-&gt;fd_flags == FD_CLOSED &amp;&amp; wp-&gt;w_p_fdl &gt;= level)</a>
<a name="ln3265">            || (fp-&gt;fd_flags != FD_CLOSED &amp;&amp; wp-&gt;w_p_fdl &lt; level))</a>
<a name="ln3266">          if (put_fold_open_close(fd, fp, off) == FAIL)</a>
<a name="ln3267">            return FAIL;</a>
<a name="ln3268">      }</a>
<a name="ln3269">    }</a>
<a name="ln3270">    ++fp;</a>
<a name="ln3271">  }</a>
<a name="ln3272"> </a>
<a name="ln3273">  return OK;</a>
<a name="ln3274">}</a>
<a name="ln3275"> </a>
<a name="ln3276">/* put_fold_open_close() {{{2 */</a>
<a name="ln3277">/*</a>
<a name="ln3278"> * Write the open or close command to &quot;fd&quot;.</a>
<a name="ln3279"> * Returns FAIL when writing failed.</a>
<a name="ln3280"> */</a>
<a name="ln3281">static int put_fold_open_close(FILE *fd, fold_T *fp, linenr_T off)</a>
<a name="ln3282">{</a>
<a name="ln3283">  if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(fp-&gt;fd_top + off)) &lt; 0</a>
<a name="ln3284">      || put_eol(fd) == FAIL</a>
<a name="ln3285">      || fprintf(fd, &quot;normal! z%c&quot;,</a>
<a name="ln3286">          fp-&gt;fd_flags == FD_CLOSED ? 'c' : 'o') &lt; 0</a>
<a name="ln3287">      || put_eol(fd) == FAIL)</a>
<a name="ln3288">    return FAIL;</a>
<a name="ln3289"> </a>
<a name="ln3290">  return OK;</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">/* }}}1 */</a>

</code></pre>
<div class="balloon" rel="2840"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (gap)->ga_len > 0.</p></div>
<div class="balloon" rel="2844"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (gap)->ga_len > 0.</p></div>
<div class="balloon" rel="2863"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: (gap)->ga_len > 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

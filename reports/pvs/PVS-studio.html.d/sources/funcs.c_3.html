
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>funcs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;float.h&gt;</a>
<a name="ln5">#include &lt;math.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln12">#include &quot;nvim/change.h&quot;</a>
<a name="ln13">#include &quot;nvim/channel.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/context.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/diff.h&quot;</a>
<a name="ln18">#include &quot;nvim/edit.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln32">#include &quot;nvim/indent.h&quot;</a>
<a name="ln33">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln34">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln35">#include &quot;nvim/macros.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/math.h&quot;</a>
<a name="ln38">#include &quot;nvim/memline.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln41">#include &quot;nvim/move.h&quot;</a>
<a name="ln42">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln43">#include &quot;nvim/msgpack_rpc/server.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/dl.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln49">#include &quot;nvim/path.h&quot;</a>
<a name="ln50">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln51">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln52">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln53">#include &quot;nvim/screen.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/version.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">/// Describe data to return from find_some_match()</a>
<a name="ln68">typedef enum {</a>
<a name="ln69">  kSomeMatch,  ///&lt; Data for match().</a>
<a name="ln70">  kSomeMatchEnd,  ///&lt; Data for matchend().</a>
<a name="ln71">  kSomeMatchList,  ///&lt; Data for matchlist().</a>
<a name="ln72">  kSomeMatchStr,  ///&lt; Data for matchstr().</a>
<a name="ln73">  kSomeMatchStrPos,  ///&lt; Data for matchstrpos().</a>
<a name="ln74">} SomeMatchType;</a>
<a name="ln75"> </a>
<a name="ln76">KHASH_MAP_INIT_STR(functions, VimLFuncDef)</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln80"># include &quot;eval/funcs.c.generated.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef _MSC_VER</a>
<a name="ln83">// This prevents MSVC from replacing the functions with intrinsics,</a>
<a name="ln84">// and causing errors when trying to get their addresses in funcs.generated.h</a>
<a name="ln85">#pragma function(ceil)</a>
<a name="ln86">#pragma function(floor)</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES</a>
<a name="ln90">PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH</a>
<a name="ln91">#include &quot;funcs.generated.h&quot;</a>
<a name="ln92">PRAGMA_DIAG_POP</a>
<a name="ln93">PRAGMA_DIAG_POP</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static char *e_listarg = N_(&quot;E686: Argument of %s must be a List&quot;);</a>
<a name="ln98">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln99"> </a>
<a name="ln100">/// Dummy va_list for passing to vim_snprintf</a>
<a name="ln101">///</a>
<a name="ln102">/// Used because:</a>
<a name="ln103">/// - passing a NULL pointer doesn't work when va_list isn't a pointer</a>
<a name="ln104">/// - locally in the function results in a &quot;used before set&quot; warning</a>
<a name="ln105">/// - using va_start() to initialize it gives &quot;function with fixed args&quot; error</a>
<a name="ln106">static va_list dummy_ap;</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/// Function given to ExpandGeneric() to obtain the list of internal</a>
<a name="ln110">/// or user defined function names.</a>
<a name="ln111">char_u *get_function_name(expand_T *xp, int idx)</a>
<a name="ln112">{</a>
<a name="ln113">  static int intidx = -1;</a>
<a name="ln114">  char_u *name;</a>
<a name="ln115"> </a>
<a name="ln116">  if (idx == 0)</a>
<a name="ln117">    intidx = -1;</a>
<a name="ln118">  if (intidx &lt; 0) {</a>
<a name="ln119">    name = get_user_func_name(xp, idx);</a>
<a name="ln120">    if (name != NULL)</a>
<a name="ln121">      return name;</a>
<a name="ln122">  }</a>
<a name="ln123">  while ((size_t)++intidx &lt; ARRAY_SIZE(functions)</a>
<a name="ln124">         &amp;&amp; functions[intidx].name[0] == '\0') {</a>
<a name="ln125">  }</a>
<a name="ln126"> </a>
<a name="ln127">  if ((size_t)intidx &gt;= ARRAY_SIZE(functions)) {</a>
<a name="ln128">    return NULL;</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  const char *const key = functions[intidx].name;</a>
<a name="ln132">  const size_t key_len = strlen(key);</a>
<a name="ln133">  memcpy(IObuff, key, key_len);</a>
<a name="ln134">  IObuff[key_len] = '(';</a>
<a name="ln135">  if (functions[intidx].max_argc == 0) {</a>
<a name="ln136">    IObuff[key_len + 1] = ')';</a>
<a name="ln137">    IObuff[key_len + 2] = NUL;</a>
<a name="ln138">  } else {</a>
<a name="ln139">    IObuff[key_len + 1] = NUL;</a>
<a name="ln140">  }</a>
<a name="ln141">  return IObuff;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">/// Function given to ExpandGeneric() to obtain the list of internal or</a>
<a name="ln145">/// user defined variable or function names.</a>
<a name="ln146">char_u *get_expr_name(expand_T *xp, int idx)</a>
<a name="ln147">{</a>
<a name="ln148">  static int intidx = -1;</a>
<a name="ln149">  char_u *name;</a>
<a name="ln150"> </a>
<a name="ln151">  if (idx == 0)</a>
<a name="ln152">    intidx = -1;</a>
<a name="ln153">  if (intidx &lt; 0) {</a>
<a name="ln154">    name = get_function_name(xp, idx);</a>
<a name="ln155">    if (name != NULL)</a>
<a name="ln156">      return name;</a>
<a name="ln157">  }</a>
<a name="ln158">  return get_user_var_name(xp, ++intidx);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/// Find internal function in hash functions</a>
<a name="ln162">///</a>
<a name="ln163">/// @param[in]  name  Name of the function.</a>
<a name="ln164">///</a>
<a name="ln165">/// Returns pointer to the function definition or NULL if not found.</a>
<a name="ln166">const VimLFuncDef *find_internal_func(const char *const name)</a>
<a name="ln167">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln168">{</a>
<a name="ln169">  size_t len = strlen(name);</a>
<a name="ln170">  return find_internal_func_gperf(name, len);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/*</a>
<a name="ln174"> * Return TRUE for a non-zero Number and a non-empty String.</a>
<a name="ln175"> */</a>
<a name="ln176">static int non_zero_arg(typval_T *argvars)</a>
<a name="ln177">{</a>
<a name="ln178">  return ((argvars[0].v_type == VAR_NUMBER</a>
<a name="ln179">           &amp;&amp; argvars[0].vval.v_number != 0)</a>
<a name="ln180">          || (argvars[0].v_type == VAR_BOOL</a>
<a name="ln181">              &amp;&amp; argvars[0].vval.v_bool == kBoolVarTrue)</a>
<a name="ln182">          || (argvars[0].v_type == VAR_STRING</a>
<a name="ln183">              &amp;&amp; argvars[0].vval.v_string != NULL</a>
<a name="ln184">              &amp;&amp; *argvars[0].vval.v_string != NUL));</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">// Apply a floating point C function on a typval with one float_T.</a>
<a name="ln188">//</a>
<a name="ln189">// Some versions of glibc on i386 have an optimization that makes it harder to</a>
<a name="ln190">// call math functions indirectly from inside an inlined function, causing</a>
<a name="ln191">// compile-time errors. Avoid `inline` in that case. #3072</a>
<a name="ln192">static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln193">{</a>
<a name="ln194">  float_T f;</a>
<a name="ln195">  float_T (*function)(float_T) = (float_T (*)(float_T))fptr;</a>
<a name="ln196"> </a>
<a name="ln197">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln198">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln199">    rettv-&gt;vval.v_float = function(f);</a>
<a name="ln200">  } else {</a>
<a name="ln201">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln202">  }</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln206">{</a>
<a name="ln207">  if (check_secure()) {</a>
<a name="ln208">    return;</a>
<a name="ln209">  }</a>
<a name="ln210"> </a>
<a name="ln211">  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;</a>
<a name="ln212"> </a>
<a name="ln213">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln214"> </a>
<a name="ln215">  for (typval_T *tv = argvars; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln216">    ADD(args, vim_to_object(tv));</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  Error err = ERROR_INIT;</a>
<a name="ln220">  Object result = fn(VIML_INTERNAL_CALL, args, &amp;err);</a>
<a name="ln221"> </a>
<a name="ln222">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln223">    emsgf_multiline((const char *)e_api_error, err.msg);</a>
<a name="ln224">    goto end;</a>
<a name="ln225">  }</a>
<a name="ln226"> </a>
<a name="ln227">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln228">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">end:</a>
<a name="ln232">  api_free_array(args);</a>
<a name="ln233">  api_free_object(result);</a>
<a name="ln234">  api_clear_error(&amp;err);</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">/*</a>
<a name="ln238"> * &quot;abs(expr)&quot; function</a>
<a name="ln239"> */</a>
<a name="ln240">static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln241">{</a>
<a name="ln242">  if (argvars[0].v_type == VAR_FLOAT) {</a>
<a name="ln243">    float_op_wrapper(argvars, rettv, (FunPtr)&amp;fabs);</a>
<a name="ln244">  } else {</a>
<a name="ln245">    varnumber_T n;</a>
<a name="ln246">    bool error = false;</a>
<a name="ln247"> </a>
<a name="ln248">    n = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln249">    if (error) {</a>
<a name="ln250">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln251">    } else if (n &gt; 0) {</a>
<a name="ln252">      rettv-&gt;vval.v_number = n;</a>
<a name="ln253">    } else {</a>
<a name="ln254">      rettv-&gt;vval.v_number = -n;</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/*</a>
<a name="ln260"> * &quot;add(list, item)&quot; function</a>
<a name="ln261"> */</a>
<a name="ln262">static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln263">{</a>
<a name="ln264">  rettv-&gt;vval.v_number = 1;  // Default: failed.</a>
<a name="ln265">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln266">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln267">    if (!tv_check_lock(tv_list_locked(l), N_(&quot;add() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln268">      tv_list_append_tv(l, &amp;argvars[1]);</a>
<a name="ln269">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln270">    }</a>
<a name="ln271">  } else {</a>
<a name="ln272">    EMSG(_(e_listreq));</a>
<a name="ln273">  }</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/*</a>
<a name="ln277"> * &quot;and(expr, expr)&quot; function</a>
<a name="ln278"> */</a>
<a name="ln279">static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln280">{</a>
<a name="ln281">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln282">                         &amp; tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">/// &quot;api_info()&quot; function</a>
<a name="ln287">static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln288">{</a>
<a name="ln289">  Dictionary metadata = api_metadata();</a>
<a name="ln290">  (void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);</a>
<a name="ln291">  api_free_dictionary(metadata);</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">// &quot;append(lnum, string/list)&quot; function</a>
<a name="ln295">static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln296">{</a>
<a name="ln297">  const linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln298"> </a>
<a name="ln299">  set_buffer_lines(curbuf, lnum, true, &amp;argvars[1], rettv);</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">// &quot;appendbufline(buf, lnum, string/list)&quot; function</a>
<a name="ln303">static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln304">{</a>
<a name="ln305">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln306">  if (buf == NULL) {</a>
<a name="ln307">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln308">  } else {</a>
<a name="ln309">    const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln310">    set_buffer_lines(buf, lnum, true, &amp;argvars[2], rettv);</a>
<a name="ln311">  }</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln315">{</a>
<a name="ln316">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln317">    // use the current window</a>
<a name="ln318">    rettv-&gt;vval.v_number = ARGCOUNT;</a>
<a name="ln319">  } else if (argvars[0].v_type == VAR_NUMBER</a>
<a name="ln320">             &amp;&amp; tv_get_number(&amp;argvars[0]) == -1) {</a>
<a name="ln321">    // use the global argument list</a>
<a name="ln322">    rettv-&gt;vval.v_number = GARGCOUNT;</a>
<a name="ln323">  } else {</a>
<a name="ln324">    // use the argument list of the specified window</a>
<a name="ln325">    win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln326">    if (wp != NULL) {</a>
<a name="ln327">      rettv-&gt;vval.v_number = WARGCOUNT(wp);</a>
<a name="ln328">    } else {</a>
<a name="ln329">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">/*</a>
<a name="ln335"> * &quot;argidx()&quot; function</a>
<a name="ln336"> */</a>
<a name="ln337">static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln338">{</a>
<a name="ln339">  rettv-&gt;vval.v_number = curwin-&gt;w_arg_idx;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">/// &quot;arglistid&quot; function</a>
<a name="ln343">static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln344">{</a>
<a name="ln345">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln346">  win_T *wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln347">  if (wp != NULL) {</a>
<a name="ln348">    rettv-&gt;vval.v_number = wp-&gt;w_alist-&gt;id;</a>
<a name="ln349">  }</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">/*</a>
<a name="ln353"> * &quot;argv(nr)&quot; function</a>
<a name="ln354"> */</a>
<a name="ln355">static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln356">{</a>
<a name="ln357">  aentry_T *arglist = NULL;</a>
<a name="ln358">  int argcount = -1;</a>
<a name="ln359"> </a>
<a name="ln360">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln361">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln362">      arglist = ARGLIST;</a>
<a name="ln363">      argcount = ARGCOUNT;</a>
<a name="ln364">    } else if (argvars[1].v_type == VAR_NUMBER</a>
<a name="ln365">               &amp;&amp; tv_get_number(&amp;argvars[1]) == -1) {</a>
<a name="ln366">      arglist = GARGLIST;</a>
<a name="ln367">      argcount = GARGCOUNT;</a>
<a name="ln368">    } else {</a>
<a name="ln369">      win_T *wp = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln370">      if (wp != NULL) {</a>
<a name="ln371">        // Use the argument list of the specified window</a>
<a name="ln372">        arglist = WARGLIST(wp);</a>
<a name="ln373">        argcount = WARGCOUNT(wp);</a>
<a name="ln374">      }</a>
<a name="ln375">    }</a>
<a name="ln376">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln377">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln378">    int idx = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln379">    if (arglist != NULL &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; argcount) {</a>
<a name="ln380">      rettv-&gt;vval.v_string = (char_u *)xstrdup(</a>
<a name="ln381">          (const char *)alist_name(&amp;arglist[idx]));</a>
<a name="ln382">    } else if (idx == -1) {</a>
<a name="ln383">      get_arglist_as_rettv(arglist, argcount, rettv);</a>
<a name="ln384">    }</a>
<a name="ln385">  } else {</a>
<a name="ln386">    get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);</a>
<a name="ln387">  }</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln391">{</a>
<a name="ln392">  const char *const cmd = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln393">  garray_T ga;</a>
<a name="ln394">  int ret = 0;</a>
<a name="ln395"> </a>
<a name="ln396">  called_vim_beep = false;</a>
<a name="ln397">  suppress_errthrow = true;</a>
<a name="ln398">  emsg_silent = false;</a>
<a name="ln399">  do_cmdline_cmd(cmd);</a>
<a name="ln400">  if (!called_vim_beep) {</a>
<a name="ln401">    prepare_assert_error(&amp;ga);</a>
<a name="ln402">    ga_concat(&amp;ga, (const char_u *)&quot;command did not beep: &quot;);</a>
<a name="ln403">    ga_concat(&amp;ga, (const char_u *)cmd);</a>
<a name="ln404">    assert_error(&amp;ga);</a>
<a name="ln405">    ga_clear(&amp;ga);</a>
<a name="ln406">    ret = 1;</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  suppress_errthrow = false;</a>
<a name="ln410">  emsg_on_display = false;</a>
<a name="ln411">  rettv-&gt;vval.v_number = ret;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">// &quot;assert_equal(expected, actual[, msg])&quot; function</a>
<a name="ln415">static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln416">{</a>
<a name="ln417">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">// &quot;assert_equalfile(fname-one, fname-two[, msg])&quot; function</a>
<a name="ln421">static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln422">{</a>
<a name="ln423">  rettv-&gt;vval.v_number = assert_equalfile(argvars);</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">// &quot;assert_notequal(expected, actual[, msg])&quot; function</a>
<a name="ln427">static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln428">{</a>
<a name="ln429">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">/// &quot;assert_report(msg)</a>
<a name="ln433">static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln434">{</a>
<a name="ln435">    garray_T ga;</a>
<a name="ln436"> </a>
<a name="ln437">    prepare_assert_error(&amp;ga);</a>
<a name="ln438">    ga_concat(&amp;ga, (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln439">    assert_error(&amp;ga);</a>
<a name="ln440">    ga_clear(&amp;ga);</a>
<a name="ln441">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/// &quot;assert_exception(string[, msg])&quot; function</a>
<a name="ln445">static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln446">{</a>
<a name="ln447">  rettv-&gt;vval.v_number = assert_exception(argvars);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">/// &quot;assert_fails(cmd [, error [, msg]])&quot; function</a>
<a name="ln451">static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln452">{</a>
<a name="ln453">  rettv-&gt;vval.v_number = assert_fails(argvars);</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">// &quot;assert_false(actual[, msg])&quot; function</a>
<a name="ln457">static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln458">{</a>
<a name="ln459">  rettv-&gt;vval.v_number = assert_bool(argvars, false);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/// &quot;assert_inrange(lower, upper[, msg])&quot; function</a>
<a name="ln463">static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln464">{</a>
<a name="ln465">  rettv-&gt;vval.v_number = assert_inrange(argvars);</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/// &quot;assert_match(pattern, actual[, msg])&quot; function</a>
<a name="ln469">static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln470">{</a>
<a name="ln471">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_MATCH);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">/// &quot;assert_notmatch(pattern, actual[, msg])&quot; function</a>
<a name="ln475">static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln476">{</a>
<a name="ln477">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">// &quot;assert_true(actual[, msg])&quot; function</a>
<a name="ln481">static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln482">{</a>
<a name="ln483">  rettv-&gt;vval.v_number = assert_bool(argvars, true);</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">/*</a>
<a name="ln487"> * &quot;atan2()&quot; function</a>
<a name="ln488"> */</a>
<a name="ln489">static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln490">{</a>
<a name="ln491">  float_T fx;</a>
<a name="ln492">  float_T fy;</a>
<a name="ln493"> </a>
<a name="ln494">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln495">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln496">    rettv-&gt;vval.v_float = atan2(fx, fy);</a>
<a name="ln497">  } else {</a>
<a name="ln498">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln499">  }</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">/*</a>
<a name="ln503"> * &quot;browse(save, title, initdir, default)&quot; function</a>
<a name="ln504"> */</a>
<a name="ln505">static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln506">{</a>
<a name="ln507">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln508">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">/*</a>
<a name="ln512"> * &quot;browsedir(title, initdir)&quot; function</a>
<a name="ln513"> */</a>
<a name="ln514">static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln515">{</a>
<a name="ln516">  f_browse(argvars, rettv, NULL);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">/*</a>
<a name="ln521"> * Find a buffer by number or exact name.</a>
<a name="ln522"> */</a>
<a name="ln523">static buf_T *find_buffer(typval_T *avar)</a>
<a name="ln524">{</a>
<a name="ln525">  buf_T       *buf = NULL;</a>
<a name="ln526"> </a>
<a name="ln527">  if (avar-&gt;v_type == VAR_NUMBER)</a>
<a name="ln528">    buf = buflist_findnr((int)avar-&gt;vval.v_number);</a>
<a name="ln529">  else if (avar-&gt;v_type == VAR_STRING &amp;&amp; avar-&gt;vval.v_string != NULL) {</a>
<a name="ln530">    buf = buflist_findname_exp(avar-&gt;vval.v_string);</a>
<a name="ln531">    if (buf == NULL) {</a>
<a name="ln532">      /* No full path name match, try a match with a URL or a &quot;nofile&quot;</a>
<a name="ln533">       * buffer, these don't use the full path. */</a>
<a name="ln534">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln535">        if (bp-&gt;b_fname != NULL</a>
<a name="ln536">            &amp;&amp; (path_with_url((char *)bp-&gt;b_fname)</a>
<a name="ln537">                || bt_nofile(bp)</a>
<a name="ln538">                )</a>
<a name="ln539">            &amp;&amp; STRCMP(bp-&gt;b_fname, avar-&gt;vval.v_string) == 0) {</a>
<a name="ln540">          buf = bp;</a>
<a name="ln541">          break;</a>
<a name="ln542">        }</a>
<a name="ln543">      }</a>
<a name="ln544">    }</a>
<a name="ln545">  }</a>
<a name="ln546">  return buf;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">// &quot;bufadd(expr)&quot; function</a>
<a name="ln550">static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln551">{</a>
<a name="ln552">  char_u *name = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln553"> </a>
<a name="ln554">  rettv-&gt;vval.v_number = buflist_add(*name == NUL ? NULL : name, 0);</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">/*</a>
<a name="ln558"> * &quot;bufexists(expr)&quot; function</a>
<a name="ln559"> */</a>
<a name="ln560">static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln561">{</a>
<a name="ln562">  rettv-&gt;vval.v_number = (find_buffer(&amp;argvars[0]) != NULL);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">/*</a>
<a name="ln566"> * &quot;buflisted(expr)&quot; function</a>
<a name="ln567"> */</a>
<a name="ln568">static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln569">{</a>
<a name="ln570">  buf_T       *buf;</a>
<a name="ln571"> </a>
<a name="ln572">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln573">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_p_bl);</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">// &quot;bufload(expr)&quot; function</a>
<a name="ln577">static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln578">{</a>
<a name="ln579">  buf_T *buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln580"> </a>
<a name="ln581">  if (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln582">    aco_save_T aco;</a>
<a name="ln583"> </a>
<a name="ln584">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln585">    swap_exists_action = SEA_NONE;</a>
<a name="ln586">    open_buffer(false, NULL, 0);</a>
<a name="ln587">    aucmd_restbuf(&amp;aco);</a>
<a name="ln588">  }</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/*</a>
<a name="ln592"> * &quot;bufloaded(expr)&quot; function</a>
<a name="ln593"> */</a>
<a name="ln594">static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln595">{</a>
<a name="ln596">  buf_T       *buf;</a>
<a name="ln597"> </a>
<a name="ln598">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln599">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">/*</a>
<a name="ln603"> * &quot;bufname(expr)&quot; function</a>
<a name="ln604"> */</a>
<a name="ln605">static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln606">{</a>
<a name="ln607">  const buf_T *buf;</a>
<a name="ln608">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln609">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln610">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln611">    buf = curbuf;</a>
<a name="ln612">  } else {</a>
<a name="ln613">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln614">      return;</a>
<a name="ln615">    }</a>
<a name="ln616">    emsg_off++;</a>
<a name="ln617">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln618">    emsg_off--;</a>
<a name="ln619">  }</a>
<a name="ln620">  if (buf != NULL &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln621">    rettv-&gt;vval.v_string = (char_u *)xstrdup((char *)buf-&gt;b_fname);</a>
<a name="ln622">  }</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">/*</a>
<a name="ln626"> * &quot;bufnr(expr)&quot; function</a>
<a name="ln627"> */</a>
<a name="ln628">static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln629">{</a>
<a name="ln630">  const buf_T *buf;</a>
<a name="ln631">  bool error = false;</a>
<a name="ln632"> </a>
<a name="ln633">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln634"> </a>
<a name="ln635">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln636">    buf = curbuf;</a>
<a name="ln637">  } else {</a>
<a name="ln638">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln639">      return;</a>
<a name="ln640">    }</a>
<a name="ln641">    emsg_off++;</a>
<a name="ln642">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln643">    emsg_off--;</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  // If the buffer isn't found and the second argument is not zero create a</a>
<a name="ln647">  // new buffer.</a>
<a name="ln648">  const char *name;</a>
<a name="ln649">  if (buf == NULL</a>
<a name="ln650">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln651">      &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error) != 0</a>
<a name="ln652">      &amp;&amp; !error</a>
<a name="ln653">      &amp;&amp; (name = tv_get_string_chk(&amp;argvars[0])) != NULL) {</a>
<a name="ln654">    buf = buflist_new((char_u *)name, NULL, 1, 0);</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  if (buf != NULL) {</a>
<a name="ln658">    rettv-&gt;vval.v_number = buf-&gt;b_fnum;</a>
<a name="ln659">  }</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr)</a>
<a name="ln663">{</a>
<a name="ln664">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln665">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln666">    return;</a>
<a name="ln667">  }</a>
<a name="ln668"> </a>
<a name="ln669">  emsg_off++;</a>
<a name="ln670">  buf_T *buf = tv_get_buf(&amp;argvars[0], true);</a>
<a name="ln671">  if (buf == NULL) {  // no need to search if buffer was not found</a>
<a name="ln672">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln673">    goto end;</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  int winnr = 0;</a>
<a name="ln677">  int winid;</a>
<a name="ln678">  bool found_buf = false;</a>
<a name="ln679">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln680">    winnr++;</a>
<a name="ln681">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln682">      found_buf = true;</a>
<a name="ln683">      winid = wp-&gt;handle;</a>
<a name="ln684">      break;</a>
<a name="ln685">    }</a>
<a name="ln686">  }</a>
<a name="ln687">  rettv-&gt;vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);</a>
<a name="ln688">end:</a>
<a name="ln689">  emsg_off--;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">/// &quot;bufwinid(nr)&quot; function</a>
<a name="ln693">static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {</a>
<a name="ln694">  buf_win_common(argvars, rettv, false);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">/// &quot;bufwinnr(nr)&quot; function</a>
<a name="ln698">static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln699">{</a>
<a name="ln700">  buf_win_common(argvars, rettv, true);</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">/*</a>
<a name="ln704"> * Get buffer by number or pattern.</a>
<a name="ln705"> */</a>
<a name="ln706">buf_T *tv_get_buf(typval_T *tv, int curtab_only)</a>
<a name="ln707">{</a>
<a name="ln708">  char_u      *name = tv-&gt;vval.v_string;</a>
<a name="ln709">  int save_magic;</a>
<a name="ln710">  char_u      *save_cpo;</a>
<a name="ln711">  buf_T       *buf;</a>
<a name="ln712"> </a>
<a name="ln713">  if (tv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln714">    return buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln715">  if (tv-&gt;v_type != VAR_STRING)</a>
<a name="ln716">    return NULL;</a>
<a name="ln717">  if (name == NULL || *name == NUL)</a>
<a name="ln718">    return curbuf;</a>
<a name="ln719">  if (name[0] == '$' &amp;&amp; name[1] == NUL)</a>
<a name="ln720">    return lastbuf;</a>
<a name="ln721"> </a>
<a name="ln722">  // Ignore 'magic' and 'cpoptions' here to make scripts portable</a>
<a name="ln723">  save_magic = p_magic;</a>
<a name="ln724">  p_magic = TRUE;</a>
<a name="ln725">  save_cpo = p_cpo;</a>
<a name="ln726">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln727"> </a>
<a name="ln728">  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),</a>
<a name="ln729">                                       true, false, curtab_only));</a>
<a name="ln730"> </a>
<a name="ln731">  p_magic = save_magic;</a>
<a name="ln732">  p_cpo = save_cpo;</a>
<a name="ln733"> </a>
<a name="ln734">  // If not found, try expanding the name, like done for bufexists().</a>
<a name="ln735">  if (buf == NULL) {</a>
<a name="ln736">    buf = find_buffer(tv);</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  return buf;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">/// Get the buffer from &quot;arg&quot; and give an error and return NULL if it is not</a>
<a name="ln743">/// valid.</a>
<a name="ln744">buf_T * get_buf_arg(typval_T *arg)</a>
<a name="ln745">{</a>
<a name="ln746">  buf_T *buf;</a>
<a name="ln747"> </a>
<a name="ln748">  emsg_off++;</a>
<a name="ln749">  buf = tv_get_buf(arg, false);</a>
<a name="ln750">  emsg_off--;</a>
<a name="ln751">  if (buf == NULL) {</a>
<a name="ln752">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), tv_get_string(arg));</a>
<a name="ln753">  }</a>
<a name="ln754">  return buf;</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">/*</a>
<a name="ln758"> * &quot;byte2line(byte)&quot; function</a>
<a name="ln759"> */</a>
<a name="ln760">static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln761">{</a>
<a name="ln762">  long boff = tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln763">  if (boff &lt; 0) {</a>
<a name="ln764">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln765">  } else {</a>
<a name="ln766">    rettv-&gt;vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,</a>
<a name="ln767">                                                               &amp;boff, false);</a>
<a name="ln768">  }</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">static void byteidx(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln772">{</a>
<a name="ln773">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln774">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln775">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln776">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln777">    return;</a>
<a name="ln778">  }</a>
<a name="ln779"> </a>
<a name="ln780">  const char *t = str;</a>
<a name="ln781">  for (; idx &gt; 0; idx--) {</a>
<a name="ln782">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln783">      return;</a>
<a name="ln784">    }</a>
<a name="ln785">    if (comp) {</a>
<a name="ln786">      t += utf_ptr2len((const char_u *)t);</a>
<a name="ln787">    } else {</a>
<a name="ln788">      t += utfc_ptr2len((const char_u *)t);</a>
<a name="ln789">    }</a>
<a name="ln790">  }</a>
<a name="ln791">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/*</a>
<a name="ln795"> * &quot;byteidx()&quot; function</a>
<a name="ln796"> */</a>
<a name="ln797">static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln798">{</a>
<a name="ln799">  byteidx(argvars, rettv, FALSE);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">/*</a>
<a name="ln803"> * &quot;byteidxcomp()&quot; function</a>
<a name="ln804"> */</a>
<a name="ln805">static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln806">{</a>
<a name="ln807">  byteidx(argvars, rettv, TRUE);</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">/// &quot;call(func, arglist [, dict])&quot; function</a>
<a name="ln811">static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln812">{</a>
<a name="ln813">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln814">    EMSG(_(e_listreq));</a>
<a name="ln815">    return;</a>
<a name="ln816">  }</a>
<a name="ln817">  if (argvars[1].vval.v_list == NULL) {</a>
<a name="ln818">    return;</a>
<a name="ln819">  }</a>
<a name="ln820"> </a>
<a name="ln821">  char_u      *func;</a>
<a name="ln822">  partial_T   *partial = NULL;</a>
<a name="ln823">  dict_T      *selfdict = NULL;</a>
<a name="ln824">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln825">    func = argvars[0].vval.v_string;</a>
<a name="ln826">  } else if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln827">    partial = argvars[0].vval.v_partial;</a>
<a name="ln828">    func = partial_name(partial);</a>
<a name="ln829">  } else if (nlua_is_table_from_lua(&amp;argvars[0])) {</a>
<a name="ln830">    func = nlua_register_table_as_callable(&amp;argvars[0]);</a>
<a name="ln831">  } else {</a>
<a name="ln832">    func = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  if (*func == NUL) {</a>
<a name="ln836">    return;             // type error or empty name</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln840">    if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln841">      EMSG(_(e_dictreq));</a>
<a name="ln842">      return;</a>
<a name="ln843">    }</a>
<a name="ln844">    selfdict = argvars[2].vval.v_dict;</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  func_call(func, &amp;argvars[1], partial, selfdict, rettv);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/*</a>
<a name="ln851"> * &quot;changenr()&quot; function</a>
<a name="ln852"> */</a>
<a name="ln853">static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln854">{</a>
<a name="ln855">  rettv-&gt;vval.v_number = curbuf-&gt;b_u_seq_cur;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// &quot;chanclose(id[, stream])&quot; function</a>
<a name="ln859">static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln860">{</a>
<a name="ln861">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln862">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln863"> </a>
<a name="ln864">  if (check_secure()) {</a>
<a name="ln865">    return;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING</a>
<a name="ln869">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln870">    EMSG(_(e_invarg));</a>
<a name="ln871">    return;</a>
<a name="ln872">  }</a>
<a name="ln873"> </a>
<a name="ln874">  ChannelPart part = kChannelPartAll;</a>
<a name="ln875">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln876">    char *stream = (char *)argvars[1].vval.v_string;</a>
<a name="ln877">    if (!strcmp(stream, &quot;stdin&quot;)) {</a>
<a name="ln878">      part = kChannelPartStdin;</a>
<a name="ln879">    } else if (!strcmp(stream, &quot;stdout&quot;)) {</a>
<a name="ln880">      part = kChannelPartStdout;</a>
<a name="ln881">    } else if (!strcmp(stream, &quot;stderr&quot;)) {</a>
<a name="ln882">      part = kChannelPartStderr;</a>
<a name="ln883">    } else if (!strcmp(stream, &quot;rpc&quot;)) {</a>
<a name="ln884">      part = kChannelPartRpc;</a>
<a name="ln885">    } else {</a>
<a name="ln886">      EMSG2(_(&quot;Invalid channel stream \&quot;%s\&quot;&quot;), stream);</a>
<a name="ln887">      return;</a>
<a name="ln888">    }</a>
<a name="ln889">  }</a>
<a name="ln890">  const char *error;</a>
<a name="ln891">  rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number, part, &amp;error);</a>
<a name="ln892">  if (!rettv-&gt;vval.v_number) {</a>
<a name="ln893">    EMSG(error);</a>
<a name="ln894">  }</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">// &quot;chansend(id, data)&quot; function</a>
<a name="ln898">static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln899">{</a>
<a name="ln900">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln901">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln902"> </a>
<a name="ln903">  if (check_secure()) {</a>
<a name="ln904">    return;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln908">    // First argument is the channel id and second is the data to write</a>
<a name="ln909">    EMSG(_(e_invarg));</a>
<a name="ln910">    return;</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  ptrdiff_t input_len = 0;</a>
<a name="ln914">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln915">  if (!input) {</a>
<a name="ln916">    // Either the error has been handled by save_tv_as_string(),</a>
<a name="ln917">    // or there is no input to send.</a>
<a name="ln918">    return;</a>
<a name="ln919">  }</a>
<a name="ln920">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln921">  const char *error = NULL;</a>
<a name="ln922">  rettv-&gt;vval.v_number = channel_send(id, input, input_len, &amp;error);</a>
<a name="ln923">  if (error) {</a>
<a name="ln924">    EMSG(error);</a>
<a name="ln925">  }</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">/*</a>
<a name="ln929"> * &quot;char2nr(string)&quot; function</a>
<a name="ln930"> */</a>
<a name="ln931">static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln932">{</a>
<a name="ln933">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln934">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln935">      return;</a>
<a name="ln936">    }</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  rettv-&gt;vval.v_number = utf_ptr2char(</a>
<a name="ln940">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">/*</a>
<a name="ln944"> * &quot;cindent(lnum)&quot; function</a>
<a name="ln945"> */</a>
<a name="ln946">static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln947">{</a>
<a name="ln948">  pos_T pos;</a>
<a name="ln949">  linenr_T lnum;</a>
<a name="ln950"> </a>
<a name="ln951">  pos = curwin-&gt;w_cursor;</a>
<a name="ln952">  lnum = tv_get_lnum(argvars);</a>
<a name="ln953">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln954">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln955">    rettv-&gt;vval.v_number = get_c_indent();</a>
<a name="ln956">    curwin-&gt;w_cursor = pos;</a>
<a name="ln957">  } else</a>
<a name="ln958">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">static win_T * get_optional_window(typval_T *argvars, int idx)</a>
<a name="ln962">{</a>
<a name="ln963">  win_T *win = curwin;</a>
<a name="ln964"> </a>
<a name="ln965">  if (argvars[idx].v_type != VAR_UNKNOWN) {</a>
<a name="ln966">    win = find_win_by_nr_or_id(&amp;argvars[idx]);</a>
<a name="ln967">    if (win == NULL) {</a>
<a name="ln968">      EMSG(_(e_invalwindow));</a>
<a name="ln969">      return NULL;</a>
<a name="ln970">    }</a>
<a name="ln971">  }</a>
<a name="ln972">  return win;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">/*</a>
<a name="ln976"> * &quot;clearmatches()&quot; function</a>
<a name="ln977"> */</a>
<a name="ln978">static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln979">{</a>
<a name="ln980">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln981"> </a>
<a name="ln982">  if (win != NULL) {</a>
<a name="ln983">    clear_matches(win);</a>
<a name="ln984">  }</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">/*</a>
<a name="ln988"> * &quot;col(string)&quot; function</a>
<a name="ln989"> */</a>
<a name="ln990">static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln991">{</a>
<a name="ln992">  colnr_T col = 0;</a>
<a name="ln993">  pos_T       *fp;</a>
<a name="ln994">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln995"> </a>
<a name="ln996">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln997">  if (fp != NULL &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln998">    if (fp-&gt;col == MAXCOL) {</a>
<a name="ln999">      // '&gt; can be MAXCOL, get the length of the line then</a>
<a name="ln1000">      if (fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1001">        col = (colnr_T)STRLEN(ml_get(fp-&gt;lnum)) + 1;</a>
<a name="ln1002">      } else {</a>
<a name="ln1003">        col = MAXCOL;</a>
<a name="ln1004">      }</a>
<a name="ln1005">    } else {</a>
<a name="ln1006">      col = fp-&gt;col + 1;</a>
<a name="ln1007">      // col(&quot;.&quot;) when the cursor is on the NUL at the end of the line</a>
<a name="ln1008">      // because of &quot;coladd&quot; can be seen as an extra column.</a>
<a name="ln1009">      if (virtual_active() &amp;&amp; fp == &amp;curwin-&gt;w_cursor) {</a>
<a name="ln1010">        char_u  *p = get_cursor_pos_ptr();</a>
<a name="ln1011"> </a>
<a name="ln1012">        if (curwin-&gt;w_cursor.coladd &gt;= (colnr_T)chartabsize(p,</a>
<a name="ln1013">                curwin-&gt;w_virtcol - curwin-&gt;w_cursor.coladd)) {</a>
<a name="ln1014">          int l;</a>
<a name="ln1015"> </a>
<a name="ln1016">          if (*p != NUL &amp;&amp; p[(l = (*mb_ptr2len)(p))] == NUL)</a>
<a name="ln1017">            col += l;</a>
<a name="ln1018">        }</a>
<a name="ln1019">      }</a>
<a name="ln1020">    }</a>
<a name="ln1021">  }</a>
<a name="ln1022">  rettv-&gt;vval.v_number = col;</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">/*</a>
<a name="ln1026"> * &quot;complete()&quot; function</a>
<a name="ln1027"> */</a>
<a name="ln1028">static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1029">{</a>
<a name="ln1030">  if ((State &amp; INSERT) == 0) {</a>
<a name="ln1031">    EMSG(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln1032">    return;</a>
<a name="ln1033">  }</a>
<a name="ln1034"> </a>
<a name="ln1035">  /* Check for undo allowed here, because if something was already inserted</a>
<a name="ln1036">   * the line was already saved for undo and this check isn't done. */</a>
<a name="ln1037">  if (!undo_allowed())</a>
<a name="ln1038">    return;</a>
<a name="ln1039"> </a>
<a name="ln1040">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln1041">    EMSG(_(e_invarg));</a>
<a name="ln1042">    return;</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  const colnr_T startcol = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln1046">  if (startcol &lt;= 0) {</a>
<a name="ln1047">    return;</a>
<a name="ln1048">  }</a>
<a name="ln1049"> </a>
<a name="ln1050">  set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">/*</a>
<a name="ln1054"> * &quot;complete_add()&quot; function</a>
<a name="ln1055"> */</a>
<a name="ln1056">static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1057">{</a>
<a name="ln1058">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/*</a>
<a name="ln1062"> * &quot;complete_check()&quot; function</a>
<a name="ln1063"> */</a>
<a name="ln1064">static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1065">{</a>
<a name="ln1066">  int saved = RedrawingDisabled;</a>
<a name="ln1067"> </a>
<a name="ln1068">  RedrawingDisabled = 0;</a>
<a name="ln1069">  ins_compl_check_keys(0, true);</a>
<a name="ln1070">  rettv-&gt;vval.v_number = compl_interrupted;</a>
<a name="ln1071">  RedrawingDisabled = saved;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">// &quot;complete_info()&quot; function</a>
<a name="ln1075">static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1076">{</a>
<a name="ln1077">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1078"> </a>
<a name="ln1079">  list_T *what_list = NULL;</a>
<a name="ln1080"> </a>
<a name="ln1081">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1082">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1083">      EMSG(_(e_listreq));</a>
<a name="ln1084">      return;</a>
<a name="ln1085">    }</a>
<a name="ln1086">    what_list = argvars[0].vval.v_list;</a>
<a name="ln1087">  }</a>
<a name="ln1088">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">/*</a>
<a name="ln1092"> * &quot;confirm(message, buttons[, default [, type]])&quot; function</a>
<a name="ln1093"> */</a>
<a name="ln1094">static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1095">{</a>
<a name="ln1096">  char buf[NUMBUFLEN];</a>
<a name="ln1097">  char buf2[NUMBUFLEN];</a>
<a name="ln1098">  const char *message;</a>
<a name="ln1099">  const char *buttons = NULL;</a>
<a name="ln1100">  int def = 1;</a>
<a name="ln1101">  int type = VIM_GENERIC;</a>
<a name="ln1102">  const char *typestr;</a>
<a name="ln1103">  bool error = false;</a>
<a name="ln1104"> </a>
<a name="ln1105">  message = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1106">  if (message == NULL) {</a>
<a name="ln1107">    error = true;</a>
<a name="ln1108">  }</a>
<a name="ln1109">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1110">    buttons = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1111">    if (buttons == NULL) {</a>
<a name="ln1112">      error = true;</a>
<a name="ln1113">    }</a>
<a name="ln1114">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1115">      def = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1116">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1117">        typestr = tv_get_string_buf_chk(&amp;argvars[3], buf2);</a>
<a name="ln1118">        if (typestr == NULL) {</a>
<a name="ln1119">          error = true;</a>
<a name="ln1120">        } else {</a>
<a name="ln1121">          switch (TOUPPER_ASC(*typestr)) {</a>
<a name="ln1122">            case 'E': type = VIM_ERROR; break;</a>
<a name="ln1123">            case 'Q': type = VIM_QUESTION; break;</a>
<a name="ln1124">            case 'I': type = VIM_INFO; break;</a>
<a name="ln1125">            case 'W': type = VIM_WARNING; break;</a>
<a name="ln1126">            case 'G': type = VIM_GENERIC; break;</a>
<a name="ln1127">          }</a>
<a name="ln1128">        }</a>
<a name="ln1129">      }</a>
<a name="ln1130">    }</a>
<a name="ln1131">  }</a>
<a name="ln1132"> </a>
<a name="ln1133">  if (buttons == NULL || *buttons == NUL) {</a>
<a name="ln1134">    buttons = _(&quot;&amp;Ok&quot;);</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  if (!error) {</a>
<a name="ln1138">    rettv-&gt;vval.v_number = do_dialog(</a>
<a name="ln1139">        type, NULL, (char_u *)message, (char_u *)buttons, def, NULL, false);</a>
<a name="ln1140">  }</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">/*</a>
<a name="ln1144"> * &quot;copy()&quot; function</a>
<a name="ln1145"> */</a>
<a name="ln1146">static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1147">{</a>
<a name="ln1148">  var_item_copy(NULL, &amp;argvars[0], rettv, false, 0);</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">/*</a>
<a name="ln1152"> * &quot;count()&quot; function</a>
<a name="ln1153"> */</a>
<a name="ln1154">static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1155">{</a>
<a name="ln1156">  long n = 0;</a>
<a name="ln1157">  int ic = 0;</a>
<a name="ln1158">  bool error = false;</a>
<a name="ln1159"> </a>
<a name="ln1160">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1161">    ic = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1162">  }</a>
<a name="ln1163"> </a>
<a name="ln1164">  if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln1165">    const char_u *expr = (char_u *)tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1166">    const char_u *p = argvars[0].vval.v_string;</a>
<a name="ln1167"> </a>
<a name="ln1168">    if (!error &amp;&amp; expr != NULL &amp;&amp; *expr != NUL &amp;&amp; p != NULL) {</a>
<a name="ln1169">      if (ic) {</a>
<a name="ln1170">        const size_t len = STRLEN(expr);</a>
<a name="ln1171"> </a>
<a name="ln1172">        while (*p != NUL) {</a>
<a name="ln1173">          if (mb_strnicmp(p, expr, len) == 0) {</a>
<a name="ln1174">            n++;</a>
<a name="ln1175">            p += len;</a>
<a name="ln1176">          } else {</a>
<a name="ln1177">            MB_PTR_ADV(p);</a>
<a name="ln1178">          }</a>
<a name="ln1179">        }</a>
<a name="ln1180">      } else {</a>
<a name="ln1181">        char_u *next;</a>
<a name="ln1182">        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != NULL) {</a>
<a name="ln1183">          n++;</a>
<a name="ln1184">          p = next + STRLEN(expr);</a>
<a name="ln1185">        }</a>
<a name="ln1186">      }</a>
<a name="ln1187">    }</a>
<a name="ln1188">  } else if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1189">    listitem_T      *li;</a>
<a name="ln1190">    list_T          *l;</a>
<a name="ln1191">    long idx;</a>
<a name="ln1192"> </a>
<a name="ln1193">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln1194">      li = tv_list_first(l);</a>
<a name="ln1195">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1196">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1197">          idx = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1198">          if (!error) {</a>
<a name="ln1199">            li = tv_list_find(l, idx);</a>
<a name="ln1200">            if (li == NULL) {</a>
<a name="ln1201">              EMSGN(_(e_listidx), idx);</a>
<a name="ln1202">            }</a>
<a name="ln1203">          }</a>
<a name="ln1204">        }</a>
<a name="ln1205">        if (error)</a>
<a name="ln1206">          li = NULL;</a>
<a name="ln1207">      }</a>
<a name="ln1208"> </a>
<a name="ln1209">      for (; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1210">        if (tv_equal(TV_LIST_ITEM_TV(li), &amp;argvars[1], ic, false)) {</a>
<a name="ln1211">          n++;</a>
<a name="ln1212">        }</a>
<a name="ln1213">      }</a>
<a name="ln1214">    }</a>
<a name="ln1215">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln1216">    int todo;</a>
<a name="ln1217">    dict_T          *d;</a>
<a name="ln1218">    hashitem_T      *hi;</a>
<a name="ln1219"> </a>
<a name="ln1220">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln1221">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1222">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1223">          EMSG(_(e_invarg));</a>
<a name="ln1224">        }</a>
<a name="ln1225">      }</a>
<a name="ln1226"> </a>
<a name="ln1227">      todo = error ? 0 : (int)d-&gt;dv_hashtab.ht_used;</a>
<a name="ln1228">      for (hi = d-&gt;dv_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln1229">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1230">          todo--;</a>
<a name="ln1231">          if (tv_equal(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, &amp;argvars[1], ic, false)) {</a>
<a name="ln1232">            n++;</a>
<a name="ln1233">          }</a>
<a name="ln1234">        }</a>
<a name="ln1235">      }</a>
<a name="ln1236">    }</a>
<a name="ln1237">  } else {</a>
<a name="ln1238">    EMSG2(_(e_listdictarg), &quot;count()&quot;);</a>
<a name="ln1239">  }</a>
<a name="ln1240">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">/*</a>
<a name="ln1244"> * &quot;cscope_connection([{num} , {dbpath} [, {prepend}]])&quot; function</a>
<a name="ln1245"> *</a>
<a name="ln1246"> * Checks the existence of a cscope connection.</a>
<a name="ln1247"> */</a>
<a name="ln1248">static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1249">{</a>
<a name="ln1250">  int num = 0;</a>
<a name="ln1251">  const char *dbpath = NULL;</a>
<a name="ln1252">  const char *prepend = NULL;</a>
<a name="ln1253">  char buf[NUMBUFLEN];</a>
<a name="ln1254"> </a>
<a name="ln1255">  if (argvars[0].v_type != VAR_UNKNOWN</a>
<a name="ln1256">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1257">    num = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1258">    dbpath = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1259">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1260">      prepend = tv_get_string_buf(&amp;argvars[2], buf);</a>
<a name="ln1261">    }</a>
<a name="ln1262">  }</a>
<a name="ln1263"> </a>
<a name="ln1264">  rettv-&gt;vval.v_number = cs_connection(num, (char_u *)dbpath,</a>
<a name="ln1265">                                       (char_u *)prepend);</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">/// &quot;ctxget([{index}])&quot; function</a>
<a name="ln1269">static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1270">{</a>
<a name="ln1271">  size_t index = 0;</a>
<a name="ln1272">  if (argvars[0].v_type == VAR_NUMBER) {</a>
<a name="ln1273">    index = argvars[0].vval.v_number;</a>
<a name="ln1274">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1275">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as an argument&quot;);</a>
<a name="ln1276">    return;</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  Context *ctx = ctx_get(index);</a>
<a name="ln1280">  if (ctx == NULL) {</a>
<a name="ln1281">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1282">    return;</a>
<a name="ln1283">  }</a>
<a name="ln1284"> </a>
<a name="ln1285">  Dictionary ctx_dict = ctx_to_dict(ctx);</a>
<a name="ln1286">  Error err = ERROR_INIT;</a>
<a name="ln1287">  object_to_vim(DICTIONARY_OBJ(ctx_dict), rettv, &amp;err);</a>
<a name="ln1288">  api_free_dictionary(ctx_dict);</a>
<a name="ln1289">  api_clear_error(&amp;err);</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">/// &quot;ctxpop()&quot; function</a>
<a name="ln1293">static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1294">{</a>
<a name="ln1295">  if (!ctx_restore(NULL, kCtxAll)) {</a>
<a name="ln1296">    EMSG(_(&quot;Context stack is empty&quot;));</a>
<a name="ln1297">  }</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300">/// &quot;ctxpush([{types}])&quot; function</a>
<a name="ln1301">static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1302">{</a>
<a name="ln1303">  int types = kCtxAll;</a>
<a name="ln1304">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1305">    types = 0;</a>
<a name="ln1306">    TV_LIST_ITER(argvars[0].vval.v_list, li, {</a>
<a name="ln1307">      typval_T *tv_li = TV_LIST_ITEM_TV(li);</a>
<a name="ln1308">      if (tv_li-&gt;v_type == VAR_STRING) {</a>
<a name="ln1309">        if (strequal((char *)tv_li-&gt;vval.v_string, &quot;regs&quot;)) {</a>
<a name="ln1310">          types |= kCtxRegs;</a>
<a name="ln1311">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;jumps&quot;)) {</a>
<a name="ln1312">          types |= kCtxJumps;</a>
<a name="ln1313">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;bufs&quot;)) {</a>
<a name="ln1314">          types |= kCtxBufs;</a>
<a name="ln1315">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;gvars&quot;)) {</a>
<a name="ln1316">          types |= kCtxGVars;</a>
<a name="ln1317">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;sfuncs&quot;)) {</a>
<a name="ln1318">          types |= kCtxSFuncs;</a>
<a name="ln1319">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;funcs&quot;)) {</a>
<a name="ln1320">          types |= kCtxFuncs;</a>
<a name="ln1321">        }</a>
<a name="ln1322">      }</a>
<a name="ln1323">    });</a>
<a name="ln1324">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1325">    EMSG2(_(e_invarg2), &quot;expected nothing or a List as an argument&quot;);</a>
<a name="ln1326">    return;</a>
<a name="ln1327">  }</a>
<a name="ln1328">  ctx_save(NULL, types);</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">/// &quot;ctxset({context}[, {index}])&quot; function</a>
<a name="ln1332">static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1333">{</a>
<a name="ln1334">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1335">    EMSG2(_(e_invarg2), &quot;expected dictionary as first argument&quot;);</a>
<a name="ln1336">    return;</a>
<a name="ln1337">  }</a>
<a name="ln1338"> </a>
<a name="ln1339">  size_t index = 0;</a>
<a name="ln1340">  if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln1341">    index = argvars[1].vval.v_number;</a>
<a name="ln1342">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1343">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as second argument&quot;);</a>
<a name="ln1344">    return;</a>
<a name="ln1345">  }</a>
<a name="ln1346"> </a>
<a name="ln1347">  Context *ctx = ctx_get(index);</a>
<a name="ln1348">  if (ctx == NULL) {</a>
<a name="ln1349">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1350">    return;</a>
<a name="ln1351">  }</a>
<a name="ln1352"> </a>
<a name="ln1353">  int save_did_emsg = did_emsg;</a>
<a name="ln1354">  did_emsg = false;</a>
<a name="ln1355"> </a>
<a name="ln1356">  Dictionary dict = vim_to_object(&amp;argvars[0]).data.dictionary;</a>
<a name="ln1357">  Context tmp = CONTEXT_INIT;</a>
<a name="ln1358">  ctx_from_dict(dict, &amp;tmp);</a>
<a name="ln1359"> </a>
<a name="ln1360">  if (did_emsg) {</a>
<a name="ln1361">    ctx_free(&amp;tmp);</a>
<a name="ln1362">  } else {</a>
<a name="ln1363">    ctx_free(ctx);</a>
<a name="ln1364">    *ctx = tmp;</a>
<a name="ln1365">  }</a>
<a name="ln1366"> </a>
<a name="ln1367">  api_free_dictionary(dict);</a>
<a name="ln1368">  did_emsg = save_did_emsg;</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">/// &quot;ctxsize()&quot; function</a>
<a name="ln1372">static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1373">{</a>
<a name="ln1374">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1375">  rettv-&gt;vval.v_number = ctx_size();</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">/// &quot;cursor(lnum, col)&quot; function, or</a>
<a name="ln1379">/// &quot;cursor(list)&quot;</a>
<a name="ln1380">///</a>
<a name="ln1381">/// Moves the cursor to the specified line and column.</a>
<a name="ln1382">///</a>
<a name="ln1383">/// @returns 0 when the position could be set, -1 otherwise.</a>
<a name="ln1384">static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1385">{</a>
<a name="ln1386">  long line, col;</a>
<a name="ln1387">  long coladd = 0;</a>
<a name="ln1388">  bool set_curswant = true;</a>
<a name="ln1389"> </a>
<a name="ln1390">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1391">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1392">    pos_T pos;</a>
<a name="ln1393">    colnr_T curswant = -1;</a>
<a name="ln1394"> </a>
<a name="ln1395">    if (list2fpos(argvars, &amp;pos, NULL, &amp;curswant) == FAIL) {</a>
<a name="ln1396">      EMSG(_(e_invarg));</a>
<a name="ln1397">      return;</a>
<a name="ln1398">    }</a>
<a name="ln1399"> </a>
<a name="ln1400">    line = pos.lnum;</a>
<a name="ln1401">    col = pos.col;</a>
<a name="ln1402">    coladd = pos.coladd;</a>
<a name="ln1403">    if (curswant &gt;= 0) {</a>
<a name="ln1404">      curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln1405">      set_curswant = false;</a>
<a name="ln1406">    }</a>
<a name="ln1407">  } else {</a>
<a name="ln1408">    line = tv_get_lnum(argvars);</a>
<a name="ln1409">    col = (long)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1410">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1411">      coladd = (long)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1412">    }</a>
<a name="ln1413">  }</a>
<a name="ln1414">  if (line &lt; 0 || col &lt; 0</a>
<a name="ln1415">      || coladd &lt; 0) {</a>
<a name="ln1416">    return;             // type error; errmsg already given</a>
<a name="ln1417">  }</a>
<a name="ln1418">  if (line &gt; 0) {</a>
<a name="ln1419">    curwin-&gt;w_cursor.lnum = line;</a>
<a name="ln1420">  }</a>
<a name="ln1421">  if (col &gt; 0) {</a>
<a name="ln1422">    curwin-&gt;w_cursor.col = col - 1;</a>
<a name="ln1423">  }</a>
<a name="ln1424">  curwin-&gt;w_cursor.coladd = coladd;</a>
<a name="ln1425"> </a>
<a name="ln1426">  // Make sure the cursor is in a valid position.</a>
<a name="ln1427">  check_cursor();</a>
<a name="ln1428">  // Correct cursor for multi-byte character.</a>
<a name="ln1429">  mb_adjust_cursor();</a>
<a name="ln1430"> </a>
<a name="ln1431">  curwin-&gt;w_set_curswant = set_curswant;</a>
<a name="ln1432">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435">// &quot;debugbreak()&quot; function</a>
<a name="ln1436">static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1437">{</a>
<a name="ln1438">  int pid;</a>
<a name="ln1439"> </a>
<a name="ln1440">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln1441">  pid = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1442">  if (pid == 0) {</a>
<a name="ln1443">    EMSG(_(e_invarg));</a>
<a name="ln1444">  } else {</a>
<a name="ln1445">#ifdef WIN32</a>
<a name="ln1446">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);</a>
<a name="ln1447"> </a>
<a name="ln1448">    if (hProcess != NULL) {</a>
<a name="ln1449">      DebugBreakProcess(hProcess);</a>
<a name="ln1450">      CloseHandle(hProcess);</a>
<a name="ln1451">      rettv-&gt;vval.v_number = OK;</a>
<a name="ln1452">    }</a>
<a name="ln1453">#else</a>
<a name="ln1454">    uv_kill(pid, SIGINT);</a>
<a name="ln1455">#endif</a>
<a name="ln1456">  }</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">// &quot;deepcopy()&quot; function</a>
<a name="ln1460">static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1461">{</a>
<a name="ln1462">  int noref = 0;</a>
<a name="ln1463"> </a>
<a name="ln1464">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1465">    noref = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1466">  }</a>
<a name="ln1467">  if (noref &lt; 0 || noref &gt; 1) {</a>
<a name="ln1468">    EMSG(_(e_invarg));</a>
<a name="ln1469">  } else {</a>
<a name="ln1470">    var_item_copy(NULL, &amp;argvars[0], rettv, true, (noref == 0</a>
<a name="ln1471">                                                   ? get_copyID()</a>
<a name="ln1472">                                                   : 0));</a>
<a name="ln1473">  }</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476">// &quot;delete()&quot; function</a>
<a name="ln1477">static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1478">{</a>
<a name="ln1479">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1480">  if (check_secure()) {</a>
<a name="ln1481">    return;</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1485">  if (*name == NUL) {</a>
<a name="ln1486">    EMSG(_(e_invarg));</a>
<a name="ln1487">    return;</a>
<a name="ln1488">  }</a>
<a name="ln1489"> </a>
<a name="ln1490">  char nbuf[NUMBUFLEN];</a>
<a name="ln1491">  const char *flags;</a>
<a name="ln1492">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1493">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln1494">  } else {</a>
<a name="ln1495">    flags = &quot;&quot;;</a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  if (*flags == NUL) {</a>
<a name="ln1499">    // delete a file</a>
<a name="ln1500">    rettv-&gt;vval.v_number = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln1501">  } else if (strcmp(flags, &quot;d&quot;) == 0) {</a>
<a name="ln1502">    // delete an empty directory</a>
<a name="ln1503">    rettv-&gt;vval.v_number = os_rmdir(name) == 0 ? 0 : -1;</a>
<a name="ln1504">  } else if (strcmp(flags, &quot;rf&quot;) == 0) {</a>
<a name="ln1505">    // delete a directory recursively</a>
<a name="ln1506">    rettv-&gt;vval.v_number = delete_recursive(name);</a>
<a name="ln1507">  } else {</a>
<a name="ln1508">    emsgf(_(e_invexpr2), flags);</a>
<a name="ln1509">  }</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512">// dictwatcheradd(dict, key, funcref) function</a>
<a name="ln1513">static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1514">{</a>
<a name="ln1515">  if (check_secure()) {</a>
<a name="ln1516">    return;</a>
<a name="ln1517">  }</a>
<a name="ln1518"> </a>
<a name="ln1519">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1520">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1521">    return;</a>
<a name="ln1522">  } else if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln1523">    const char *const arg_errmsg = _(&quot;dictwatcheradd() argument&quot;);</a>
<a name="ln1524">    const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1525">    emsgf(_(e_readonlyvar), (int)arg_errmsg_len, arg_errmsg);</a>
<a name="ln1526">    return;</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529">  if (argvars[1].v_type != VAR_STRING &amp;&amp; argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1530">    emsgf(_(e_invarg2), &quot;key&quot;);</a>
<a name="ln1531">    return;</a>
<a name="ln1532">  }</a>
<a name="ln1533"> </a>
<a name="ln1534">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1535">  if (key_pattern == NULL) {</a>
<a name="ln1536">    return;</a>
<a name="ln1537">  }</a>
<a name="ln1538">  const size_t key_pattern_len = strlen(key_pattern);</a>
<a name="ln1539"> </a>
<a name="ln1540">  Callback callback;</a>
<a name="ln1541">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1542">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1543">    return;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,</a>
<a name="ln1547">                      callback);</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">// dictwatcherdel(dict, key, funcref) function</a>
<a name="ln1551">static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1552">{</a>
<a name="ln1553">  if (check_secure()) {</a>
<a name="ln1554">    return;</a>
<a name="ln1555">  }</a>
<a name="ln1556"> </a>
<a name="ln1557">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1558">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1559">    return;</a>
<a name="ln1560">  }</a>
<a name="ln1561"> </a>
<a name="ln1562">  if (argvars[2].v_type != VAR_FUNC &amp;&amp; argvars[2].v_type != VAR_STRING) {</a>
<a name="ln1563">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1564">    return;</a>
<a name="ln1565">  }</a>
<a name="ln1566"> </a>
<a name="ln1567">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1568">  if (key_pattern == NULL) {</a>
<a name="ln1569">    return;</a>
<a name="ln1570">  }</a>
<a name="ln1571"> </a>
<a name="ln1572">  Callback callback;</a>
<a name="ln1573">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1574">    return;</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,</a>
<a name="ln1578">                              strlen(key_pattern), callback)) {</a>
<a name="ln1579">    EMSG(&quot;Couldn't find a watcher matching key and callback&quot;);</a>
<a name="ln1580">  }</a>
<a name="ln1581"> </a>
<a name="ln1582">  callback_free(&amp;callback);</a>
<a name="ln1583">}</a>
<a name="ln1584"> </a>
<a name="ln1585">/// &quot;deletebufline()&quot; function</a>
<a name="ln1586">static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1587">{</a>
<a name="ln1588">  linenr_T last;</a>
<a name="ln1589">  buf_T *curbuf_save = NULL;</a>
<a name="ln1590">  win_T *curwin_save = NULL;</a>
<a name="ln1591"> </a>
<a name="ln1592">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln1593">  if (buf == NULL) {</a>
<a name="ln1594">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1595">    return;</a>
<a name="ln1596">  }</a>
<a name="ln1597">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln1598"> </a>
<a name="ln1599">  const linenr_T first = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln1600">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1601">    last = tv_get_lnum_buf(&amp;argvars[2], buf);</a>
<a name="ln1602">  } else {</a>
<a name="ln1603">    last = first;</a>
<a name="ln1604">  }</a>
<a name="ln1605"> </a>
<a name="ln1606">  if (buf-&gt;b_ml.ml_mfp == NULL || first &lt; 1</a>
<a name="ln1607">      || first &gt; buf-&gt;b_ml.ml_line_count || last &lt; first) {</a>
<a name="ln1608">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1609">    return;</a>
<a name="ln1610">  }</a>
<a name="ln1611"> </a>
<a name="ln1612">  if (!is_curbuf) {</a>
<a name="ln1613">    curbuf_save = curbuf;</a>
<a name="ln1614">    curwin_save = curwin;</a>
<a name="ln1615">    curbuf = buf;</a>
<a name="ln1616">    find_win_for_curbuf();</a>
<a name="ln1617">  }</a>
<a name="ln1618">  if (last &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1619">    last = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1620">  }</a>
<a name="ln1621">  const long count = last - first + 1;</a>
<a name="ln1622"> </a>
<a name="ln1623">  // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln1624">  // undone separately from what was previously inserted.</a>
<a name="ln1625">  if (u_sync_once == 2) {</a>
<a name="ln1626">    u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln1627">    u_sync(true);</a>
<a name="ln1628">  }</a>
<a name="ln1629"> </a>
<a name="ln1630">  if (u_save(first - 1, last + 1) == FAIL) {</a>
<a name="ln1631">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1632">    return;</a>
<a name="ln1633">  }</a>
<a name="ln1634"> </a>
<a name="ln1635">  for (linenr_T lnum = first; lnum &lt;= last; lnum++) {</a>
<a name="ln1636">    ml_delete(first, true);</a>
<a name="ln1637">  }</a>
<a name="ln1638"> </a>
<a name="ln1639">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1640">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1641">      if (wp-&gt;w_cursor.lnum &gt; last) {</a>
<a name="ln1642">        wp-&gt;w_cursor.lnum -= count;</a>
<a name="ln1643">      } else if (wp-&gt;w_cursor.lnum&gt; first) {</a>
<a name="ln1644">        wp-&gt;w_cursor.lnum = first;</a>
<a name="ln1645">      }</a>
<a name="ln1646">      if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1647">        wp-&gt;w_cursor.lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1648">      }</a>
<a name="ln1649">    }</a>
<a name="ln1650">  }</a>
<a name="ln1651">  check_cursor_col();</a>
<a name="ln1652">  deleted_lines_mark(first, count);</a>
<a name="ln1653"> </a>
<a name="ln1654">  if (!is_curbuf) {</a>
<a name="ln1655">    curbuf = curbuf_save;</a>
<a name="ln1656">    curwin = curwin_save;</a>
<a name="ln1657">  }</a>
<a name="ln1658">}</a>
<a name="ln1659"> </a>
<a name="ln1660">/*</a>
<a name="ln1661"> * &quot;did_filetype()&quot; function</a>
<a name="ln1662"> */</a>
<a name="ln1663">static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1664">{</a>
<a name="ln1665">  rettv-&gt;vval.v_number = did_filetype;</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">/*</a>
<a name="ln1669"> * &quot;diff_filler()&quot; function</a>
<a name="ln1670"> */</a>
<a name="ln1671">static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1672">{</a>
<a name="ln1673">  rettv-&gt;vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">/*</a>
<a name="ln1677"> * &quot;diff_hlID()&quot; function</a>
<a name="ln1678"> */</a>
<a name="ln1679">static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1680">{</a>
<a name="ln1681">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln1682">  static linenr_T prev_lnum = 0;</a>
<a name="ln1683">  static int changedtick = 0;</a>
<a name="ln1684">  static int fnum = 0;</a>
<a name="ln1685">  static int change_start = 0;</a>
<a name="ln1686">  static int change_end = 0;</a>
<a name="ln1687">  static hlf_T hlID = (hlf_T)0;</a>
<a name="ln1688">  int filler_lines;</a>
<a name="ln1689">  int col;</a>
<a name="ln1690"> </a>
<a name="ln1691">  if (lnum &lt; 0) {       // ignore type error in {lnum} arg</a>
<a name="ln1692">    lnum = 0;</a>
<a name="ln1693">  }</a>
<a name="ln1694">  if (lnum != prev_lnum</a>
<a name="ln1695">      || changedtick != buf_get_changedtick(curbuf)</a>
<a name="ln1696">      || fnum != curbuf-&gt;b_fnum) {</a>
<a name="ln1697">    // New line, buffer, change: need to get the values.</a>
<a name="ln1698">    filler_lines = diff_check(curwin, lnum);</a>
<a name="ln1699">    if (filler_lines &lt; 0) {</a>
<a name="ln1700">      if (filler_lines == -1) {</a>
<a name="ln1701">        change_start = MAXCOL;</a>
<a name="ln1702">        change_end = -1;</a>
<a name="ln1703">        if (diff_find_change(curwin, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln1704">          hlID = HLF_ADD;               // added line</a>
<a name="ln1705">        } else {</a>
<a name="ln1706">          hlID = HLF_CHD;               // changed line</a>
<a name="ln1707">        }</a>
<a name="ln1708">      } else {</a>
<a name="ln1709">        hlID = HLF_ADD;         // added line</a>
<a name="ln1710">      }</a>
<a name="ln1711">    } else {</a>
<a name="ln1712">      hlID = (hlf_T)0;</a>
<a name="ln1713">    }</a>
<a name="ln1714">    prev_lnum = lnum;</a>
<a name="ln1715">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1716">    fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1717">  }</a>
<a name="ln1718"> </a>
<a name="ln1719">  if (hlID == HLF_CHD || hlID == HLF_TXD) {</a>
<a name="ln1720">    col = tv_get_number(&amp;argvars[1]) - 1;  // Ignore type error in {col}.</a>
<a name="ln1721">    if (col &gt;= change_start &amp;&amp; col &lt;= change_end) {</a>
<a name="ln1722">      hlID = HLF_TXD;  // Changed text.</a>
<a name="ln1723">    } else {</a>
<a name="ln1724">      hlID = HLF_CHD;  // Changed line.</a>
<a name="ln1725">    }</a>
<a name="ln1726">  }</a>
<a name="ln1727">  rettv-&gt;vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">/*</a>
<a name="ln1731"> * &quot;empty({expr})&quot; function</a>
<a name="ln1732"> */</a>
<a name="ln1733">static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1734">{</a>
<a name="ln1735">  bool n = true;</a>
<a name="ln1736"> </a>
<a name="ln1737">  switch (argvars[0].v_type) {</a>
<a name="ln1738">    case VAR_STRING:</a>
<a name="ln1739">    case VAR_FUNC: {</a>
<a name="ln1740">      n = argvars[0].vval.v_string == NULL</a>
<a name="ln1741">          || *argvars[0].vval.v_string == NUL;</a>
<a name="ln1742">      break;</a>
<a name="ln1743">    }</a>
<a name="ln1744">    case VAR_PARTIAL: {</a>
<a name="ln1745">      n = false;</a>
<a name="ln1746">      break;</a>
<a name="ln1747">    }</a>
<a name="ln1748">    case VAR_NUMBER: {</a>
<a name="ln1749">      n = argvars[0].vval.v_number == 0;</a>
<a name="ln1750">      break;</a>
<a name="ln1751">    }</a>
<a name="ln1752">    case VAR_FLOAT: {</a>
<a name="ln1753">      n = argvars[0].vval.v_float == 0.0;</a>
<a name="ln1754">      break;</a>
<a name="ln1755">    }</a>
<a name="ln1756">    case VAR_LIST: {</a>
<a name="ln1757">      n = (tv_list_len(argvars[0].vval.v_list) == 0);</a>
<a name="ln1758">      break;</a>
<a name="ln1759">    }</a>
<a name="ln1760">    case VAR_DICT: {</a>
<a name="ln1761">      n = (tv_dict_len(argvars[0].vval.v_dict) == 0);</a>
<a name="ln1762">      break;</a>
<a name="ln1763">    }</a>
<a name="ln1764">    case VAR_BOOL: {</a>
<a name="ln1765">      switch (argvars[0].vval.v_bool) {</a>
<a name="ln1766">        case kBoolVarTrue: {</a>
<a name="ln1767">          n = false;</a>
<a name="ln1768">          break;</a>
<a name="ln1769">        }</a>
<a name="ln1770">        case kBoolVarFalse: {</a>
<a name="ln1771">          n = true;</a>
<a name="ln1772">          break;</a>
<a name="ln1773">        }</a>
<a name="ln1774">      }</a>
<a name="ln1775">      break;</a>
<a name="ln1776">    }</a>
<a name="ln1777">    case VAR_SPECIAL: {</a>
<a name="ln1778">      n = argvars[0].vval.v_special == kSpecialVarNull;</a>
<a name="ln1779">      break;</a>
<a name="ln1780">    }</a>
<a name="ln1781">    case VAR_UNKNOWN: {</a>
<a name="ln1782">      internal_error(&quot;f_empty(UNKNOWN)&quot;);</a>
<a name="ln1783">      break;</a>
<a name="ln1784">    }</a>
<a name="ln1785">  }</a>
<a name="ln1786"> </a>
<a name="ln1787">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1788">}</a>
<a name="ln1789"> </a>
<a name="ln1790">/// &quot;environ()&quot; function</a>
<a name="ln1791">static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1792">{</a>
<a name="ln1793">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1794"> </a>
<a name="ln1795">  size_t env_size = os_get_fullenv_size();</a>
<a name="ln1796">  char **env = xmalloc(sizeof(*env) * (env_size + 1));</a>
<a name="ln1797">  env[env_size] = NULL;</a>
<a name="ln1798"> </a>
<a name="ln1799">  os_copy_fullenv(env, env_size);</a>
<a name="ln1800"> </a>
<a name="ln1801">  for (size_t i = 0; i &lt; env_size; i++) {</a>
<a name="ln1802">    const char * str = env[i];</a>
<a name="ln1803">    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),</a>
<a name="ln1804">                                    '=');</a>
<a name="ln1805">    assert(end != NULL);</a>
<a name="ln1806">    ptrdiff_t len = end - str;</a>
<a name="ln1807">    assert(len &gt; 0);</a>
<a name="ln1808">    const char * value = str + len + 1;</a>
<a name="ln1809">    tv_dict_add_str(rettv-&gt;vval.v_dict,</a>
<a name="ln1810">                    str, len,</a>
<a name="ln1811">                    value);</a>
<a name="ln1812">  }</a>
<a name="ln1813">  os_free_fullenv(env);</a>
<a name="ln1814">}</a>
<a name="ln1815"> </a>
<a name="ln1816">/*</a>
<a name="ln1817"> * &quot;escape({string}, {chars})&quot; function</a>
<a name="ln1818"> */</a>
<a name="ln1819">static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1820">{</a>
<a name="ln1821">  char buf[NUMBUFLEN];</a>
<a name="ln1822"> </a>
<a name="ln1823">  rettv-&gt;vval.v_string = vim_strsave_escaped(</a>
<a name="ln1824">      (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln1825">      (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln1826">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">/// &quot;getenv()&quot; function</a>
<a name="ln1830">static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1831">{</a>
<a name="ln1832">  char_u *p = (char_u *)vim_getenv(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1833"> </a>
<a name="ln1834">  if (p == NULL) {</a>
<a name="ln1835">    rettv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1836">    rettv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1837">    return;</a>
<a name="ln1838">  }</a>
<a name="ln1839">  rettv-&gt;vval.v_string = p;</a>
<a name="ln1840">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843">/*</a>
<a name="ln1844"> * &quot;eval()&quot; function</a>
<a name="ln1845"> */</a>
<a name="ln1846">static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1847">{</a>
<a name="ln1848">  const char *s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1849">  if (s != NULL) {</a>
<a name="ln1850">    s = (const char *)skipwhite((const char_u *)s);</a>
<a name="ln1851">  }</a>
<a name="ln1852"> </a>
<a name="ln1853">  const char *const expr_start = s;</a>
<a name="ln1854">  if (s == NULL || eval1((char_u **)&amp;s, rettv, true) == FAIL) {</a>
<a name="ln1855">    if (expr_start != NULL &amp;&amp; !aborting()) {</a>
<a name="ln1856">      EMSG2(_(e_invexpr2), expr_start);</a>
<a name="ln1857">    }</a>
<a name="ln1858">    need_clr_eos = FALSE;</a>
<a name="ln1859">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1860">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1861">  } else if (*s != NUL) {</a>
<a name="ln1862">    EMSG(_(e_trailing));</a>
<a name="ln1863">  }</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/*</a>
<a name="ln1867"> * &quot;eventhandler()&quot; function</a>
<a name="ln1868"> */</a>
<a name="ln1869">static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1870">{</a>
<a name="ln1871">  rettv-&gt;vval.v_number = vgetc_busy;</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">/*</a>
<a name="ln1875"> * &quot;executable()&quot; function</a>
<a name="ln1876"> */</a>
<a name="ln1877">static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1878">{</a>
<a name="ln1879">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln1880">    return;</a>
<a name="ln1881">  }</a>
<a name="ln1882"> </a>
<a name="ln1883">  // Check in $PATH and also check directly if there is a directory name</a>
<a name="ln1884">  rettv-&gt;vval.v_number = os_can_exe(tv_get_string(&amp;argvars[0]), NULL, true);</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">typedef struct {</a>
<a name="ln1888">  const list_T *const l;</a>
<a name="ln1889">  const listitem_T *li;</a>
<a name="ln1890">} GetListLineCookie;</a>
<a name="ln1891"> </a>
<a name="ln1892">static char_u *get_list_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln1893">{</a>
<a name="ln1894">  GetListLineCookie *const p = (GetListLineCookie *)cookie;</a>
<a name="ln1895"> </a>
<a name="ln1896">  const listitem_T *const item = p-&gt;li;</a>
<a name="ln1897">  if (item == NULL) {</a>
<a name="ln1898">    return NULL;</a>
<a name="ln1899">  }</a>
<a name="ln1900">  char buf[NUMBUFLEN];</a>
<a name="ln1901">  const char *const s = tv_get_string_buf_chk(TV_LIST_ITEM_TV(item), buf);</a>
<a name="ln1902">  p-&gt;li = TV_LIST_ITEM_NEXT(p-&gt;l, item);</a>
<a name="ln1903">  return (char_u *)(s == NULL ? NULL : xstrdup(s));</a>
<a name="ln1904">}</a>
<a name="ln1905"> </a>
<a name="ln1906">// &quot;execute(command)&quot; function</a>
<a name="ln1907">static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1908">{</a>
<a name="ln1909">  const int save_msg_silent = msg_silent;</a>
<a name="ln1910">  const int save_emsg_silent = emsg_silent;</a>
<a name="ln1911">  const bool save_emsg_noredir = emsg_noredir;</a>
<a name="ln1912">  const bool save_redir_off = redir_off;</a>
<a name="ln1913">  garray_T *const save_capture_ga = capture_ga;</a>
<a name="ln1914">  const int save_msg_col = msg_col;</a>
<a name="ln1915">  bool echo_output = false;</a>
<a name="ln1916"> </a>
<a name="ln1917">  if (check_secure()) {</a>
<a name="ln1918">    return;</a>
<a name="ln1919">  }</a>
<a name="ln1920"> </a>
<a name="ln1921">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1922">    char buf[NUMBUFLEN];</a>
<a name="ln1923">    const char *const s = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1924"> </a>
<a name="ln1925">    if (s == NULL) {</a>
<a name="ln1926">      return;</a>
<a name="ln1927">    }</a>
<a name="ln1928">    if (*s == NUL) {</a>
<a name="ln1929">      echo_output = true;</a>
<a name="ln1930">    }</a>
<a name="ln1931">    if (strncmp(s, &quot;silent&quot;, 6) == 0) {</a>
<a name="ln1932">      msg_silent++;</a>
<a name="ln1933">    }</a>
<a name="ln1934">    if (strcmp(s, &quot;silent!&quot;) == 0) {</a>
<a name="ln1935">      emsg_silent = true;</a>
<a name="ln1936">      emsg_noredir = true;</a>
<a name="ln1937">    }</a>
<a name="ln1938">  } else {</a>
<a name="ln1939">    msg_silent++;</a>
<a name="ln1940">  }</a>
<a name="ln1941"> </a>
<a name="ln1942">  garray_T capture_local;</a>
<a name="ln1943">  ga_init(&amp;capture_local, (int)sizeof(char), 80);</a>
<a name="ln1944">  capture_ga = &amp;capture_local;</a>
<a name="ln1945">  redir_off = false;</a>
<a name="ln1946">  if (!echo_output) {</a>
<a name="ln1947">    msg_col = 0;  // prevent leading spaces</a>
<a name="ln1948">  }</a>
<a name="ln1949"> </a>
<a name="ln1950">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1951">    do_cmdline_cmd(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1952">  } else if (argvars[0].vval.v_list != NULL) {</a>
<a name="ln1953">    list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln1954">    tv_list_ref(list);</a>
<a name="ln1955">    GetListLineCookie cookie = {</a>
<a name="ln1956">      .l = list,</a>
<a name="ln1957">      .li = tv_list_first(list),</a>
<a name="ln1958">    };</a>
<a name="ln1959">    do_cmdline(NULL, get_list_line, (void *)&amp;cookie,</a>
<a name="ln1960">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);</a>
<a name="ln1961">    tv_list_unref(list);</a>
<a name="ln1962">  }</a>
<a name="ln1963">  msg_silent = save_msg_silent;</a>
<a name="ln1964">  emsg_silent = save_emsg_silent;</a>
<a name="ln1965">  emsg_noredir = save_emsg_noredir;</a>
<a name="ln1966">  redir_off = save_redir_off;</a>
<a name="ln1967">  // &quot;silent reg&quot; or &quot;silent echo x&quot; leaves msg_col somewhere in the line.</a>
<a name="ln1968">  if (echo_output) {</a>
<a name="ln1969">    // When not working silently: put it in column zero.  A following</a>
<a name="ln1970">    // &quot;echon&quot; will overwrite the message, unavoidably.</a>
<a name="ln1971">    msg_col = 0;</a>
<a name="ln1972">  } else {</a>
<a name="ln1973">    // When working silently: Put it back where it was, since nothing</a>
<a name="ln1974">    // should have been written.</a>
<a name="ln1975">    msg_col = save_msg_col;</a>
<a name="ln1976">  }</a>
<a name="ln1977"> </a>
<a name="ln1978">  ga_append(capture_ga, NUL);</a>
<a name="ln1979">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1980">  rettv-&gt;vval.v_string = capture_ga-&gt;ga_data;</a>
<a name="ln1981"> </a>
<a name="ln1982">  capture_ga = save_capture_ga;</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">/// &quot;exepath()&quot; function</a>
<a name="ln1986">static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1987">{</a>
<a name="ln1988">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln1989">    return;</a>
<a name="ln1990">  }</a>
<a name="ln1991"> </a>
<a name="ln1992">  char *path = NULL;</a>
<a name="ln1993"> </a>
<a name="ln1994">  (void)os_can_exe(tv_get_string(&amp;argvars[0]), &amp;path, true);</a>
<a name="ln1995"> </a>
<a name="ln1996">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1997">  rettv-&gt;vval.v_string = (char_u *)path;</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000">/*</a>
<a name="ln2001"> * &quot;exists()&quot; function</a>
<a name="ln2002"> */</a>
<a name="ln2003">static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2004">{</a>
<a name="ln2005">  int n = false;</a>
<a name="ln2006">  int len = 0;</a>
<a name="ln2007"> </a>
<a name="ln2008">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2009">  if (*p == '$') {  // Environment variable.</a>
<a name="ln2010">    // First try &quot;normal&quot; environment variables (fast).</a>
<a name="ln2011">    if (os_env_exists(p + 1)) {</a>
<a name="ln2012">      n = true;</a>
<a name="ln2013">    } else {</a>
<a name="ln2014">      // Try expanding things like $VIM and ${HOME}.</a>
<a name="ln2015">      char_u *const exp = expand_env_save((char_u *)p);</a>
<a name="ln2016">      if (exp != NULL &amp;&amp; *exp != '$') {</a>
<a name="ln2017">        n = true;</a>
<a name="ln2018">      }</a>
<a name="ln2019">      xfree(exp);</a>
<a name="ln2020">    }</a>
<a name="ln2021">  } else if (*p == '&amp;' || *p == '+') {  // Option.</a>
<a name="ln2022">    n = (get_option_tv(&amp;p, NULL, true) == OK);</a>
<a name="ln2023">    if (*skipwhite((const char_u *)p) != NUL) {</a>
<a name="ln2024">      n = false;  // Trailing garbage.</a>
<a name="ln2025">    }</a>
<a name="ln2026">  } else if (*p == '*') {  // Internal or user defined function.</a>
<a name="ln2027">    n = function_exists(p + 1, false);</a>
<a name="ln2028">  } else if (*p == ':') {</a>
<a name="ln2029">    n = cmd_exists(p + 1);</a>
<a name="ln2030">  } else if (*p == '#') {</a>
<a name="ln2031">    if (p[1] == '#') {</a>
<a name="ln2032">      n = autocmd_supported(p + 2);</a>
<a name="ln2033">    } else {</a>
<a name="ln2034">      n = au_exists(p + 1);</a>
<a name="ln2035">    }</a>
<a name="ln2036">  } else {  // Internal variable.</a>
<a name="ln2037">    typval_T tv;</a>
<a name="ln2038"> </a>
<a name="ln2039">    // get_name_len() takes care of expanding curly braces</a>
<a name="ln2040">    const char *name = p;</a>
<a name="ln2041">    char *tofree;</a>
<a name="ln2042">    len = get_name_len((const char **)&amp;p, &amp;tofree, true, false);</a>
<a name="ln2043">    if (len &gt; 0) {</a>
<a name="ln2044">      if (tofree != NULL) {</a>
<a name="ln2045">        name = tofree;</a>
<a name="ln2046">      }</a>
<a name="ln2047">      n = (get_var_tv(name, len, &amp;tv, NULL, false, true) == OK);</a>
<a name="ln2048">      if (n) {</a>
<a name="ln2049">        // Handle d.key, l[idx], f(expr).</a>
<a name="ln2050">        n = (handle_subscript(&amp;p, &amp;tv, true, false) == OK);</a>
<a name="ln2051">        if (n) {</a>
<a name="ln2052">          tv_clear(&amp;tv);</a>
<a name="ln2053">        }</a>
<a name="ln2054">      }</a>
<a name="ln2055">    }</a>
<a name="ln2056">    if (*p != NUL)</a>
<a name="ln2057">      n = FALSE;</a>
<a name="ln2058"> </a>
<a name="ln2059">    xfree(tofree);</a>
<a name="ln2060">  }</a>
<a name="ln2061"> </a>
<a name="ln2062">  rettv-&gt;vval.v_number = n;</a>
<a name="ln2063">}</a>
<a name="ln2064"> </a>
<a name="ln2065">/*</a>
<a name="ln2066"> * &quot;expand()&quot; function</a>
<a name="ln2067"> */</a>
<a name="ln2068">static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2069">{</a>
<a name="ln2070">  size_t len;</a>
<a name="ln2071">  char_u      *errormsg;</a>
<a name="ln2072">  int options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;</a>
<a name="ln2073">  expand_T xpc;</a>
<a name="ln2074">  bool error = false;</a>
<a name="ln2075">  char_u *result;</a>
<a name="ln2076">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2077">  char_u *p_csl_save = p_csl;</a>
<a name="ln2078"> </a>
<a name="ln2079">  // avoid using 'completeslash' here</a>
<a name="ln2080">  p_csl = empty_option;</a>
<a name="ln2081">#endif</a>
<a name="ln2082"> </a>
<a name="ln2083">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2084">  if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2085">      &amp;&amp; argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2086">      &amp;&amp; tv_get_number_chk(&amp;argvars[2], &amp;error)</a>
<a name="ln2087">      &amp;&amp; !error) {</a>
<a name="ln2088">    tv_list_set_ret(rettv, NULL);</a>
<a name="ln2089">  }</a>
<a name="ln2090"> </a>
<a name="ln2091">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2092">  if (*s == '%' || *s == '#' || *s == '&lt;') {</a>
<a name="ln2093">    emsg_off++;</a>
<a name="ln2094">    result = eval_vars((char_u *)s, (char_u *)s, &amp;len, NULL, &amp;errormsg, NULL);</a>
<a name="ln2095">    emsg_off--;</a>
<a name="ln2096">    if (rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2097">      tv_list_alloc_ret(rettv, (result != NULL));</a>
<a name="ln2098">      if (result != NULL) {</a>
<a name="ln2099">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)result, -1);</a>
<a name="ln2100">      }</a>
<a name="ln2101">      XFREE_CLEAR(result);</a>
<a name="ln2102">    } else {</a>
<a name="ln2103">      rettv-&gt;vval.v_string = result;</a>
<a name="ln2104">    }</a>
<a name="ln2105">  } else {</a>
<a name="ln2106">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln2107">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln2108">    if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2109">        &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln2110">      options |= WILD_KEEP_ALL;</a>
<a name="ln2111">    }</a>
<a name="ln2112">    if (!error) {</a>
<a name="ln2113">      ExpandInit(&amp;xpc);</a>
<a name="ln2114">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln2115">      if (p_wic) {</a>
<a name="ln2116">        options += WILD_ICASE;</a>
<a name="ln2117">      }</a>
<a name="ln2118">      if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln2119">        rettv-&gt;vval.v_string = ExpandOne(&amp;xpc, (char_u *)s, NULL, options,</a>
<a name="ln2120">                                         WILD_ALL);</a>
<a name="ln2121">      } else {</a>
<a name="ln2122">        ExpandOne(&amp;xpc, (char_u *)s, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln2123">        tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln2124">        for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln2125">          tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2126">                                (const char *)xpc.xp_files[i], -1);</a>
<a name="ln2127">        }</a>
<a name="ln2128">        ExpandCleanup(&amp;xpc);</a>
<a name="ln2129">      }</a>
<a name="ln2130">    } else {</a>
<a name="ln2131">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2132">    }</a>
<a name="ln2133">  }</a>
<a name="ln2134">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2135">  p_csl = p_csl_save;</a>
<a name="ln2136">#endif</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139"> </a>
<a name="ln2140">/// &quot;menu_get(path [, modes])&quot; function</a>
<a name="ln2141">static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2142">{</a>
<a name="ln2143">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2144">  int modes = MENU_ALL_MODES;</a>
<a name="ln2145">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2146">    const char_u *const strmodes = (char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln2147">    modes = get_menu_cmd_modes(strmodes, false, NULL, NULL);</a>
<a name="ln2148">  }</a>
<a name="ln2149">  menu_get((char_u *)tv_get_string(&amp;argvars[0]), modes, rettv-&gt;vval.v_list);</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152">// &quot;expandcmd()&quot; function</a>
<a name="ln2153">// Expand all the special characters in a command string.</a>
<a name="ln2154">static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2155">{</a>
<a name="ln2156">  char_u *errormsg = NULL;</a>
<a name="ln2157"> </a>
<a name="ln2158">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2159">  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2160"> </a>
<a name="ln2161">  exarg_T eap = {</a>
<a name="ln2162">    .cmd = cmdstr,</a>
<a name="ln2163">    .arg = cmdstr,</a>
<a name="ln2164">    .usefilter = false,</a>
<a name="ln2165">    .nextcmd = NULL,</a>
<a name="ln2166">    .cmdidx = CMD_USER,</a>
<a name="ln2167">  };</a>
<a name="ln2168">  eap.argt |= EX_NOSPC;</a>
<a name="ln2169"> </a>
<a name="ln2170">  expand_filename(&amp;eap, &amp;cmdstr, &amp;errormsg);</a>
<a name="ln2171">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln2172">    EMSG(errormsg);</a>
<a name="ln2173">  }</a>
<a name="ln2174">  rettv-&gt;vval.v_string = cmdstr;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177"> </a>
<a name="ln2178">/// &quot;flatten(list[, {maxdepth}])&quot; function</a>
<a name="ln2179">static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2180">{</a>
<a name="ln2181">  list_T *list;</a>
<a name="ln2182">  long maxdepth;</a>
<a name="ln2183">  bool error = false;</a>
<a name="ln2184"> </a>
<a name="ln2185">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2186">    EMSG2(_(e_listarg), &quot;flatten()&quot;);</a>
<a name="ln2187">    return;</a>
<a name="ln2188">  }</a>
<a name="ln2189"> </a>
<a name="ln2190">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln2191">    maxdepth = 999999;</a>
<a name="ln2192">  } else {</a>
<a name="ln2193">    maxdepth = (long)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2194">    if (error) {</a>
<a name="ln2195">      return;</a>
<a name="ln2196">    }</a>
<a name="ln2197">    if (maxdepth &lt; 0) {</a>
<a name="ln2198">      EMSG(_(&quot;E900: maxdepth must be non-negative number&quot;));</a>
<a name="ln2199">      return;</a>
<a name="ln2200">    }</a>
<a name="ln2201">  }</a>
<a name="ln2202"> </a>
<a name="ln2203">  list = argvars[0].vval.v_list;</a>
<a name="ln2204">  if (list != NULL</a>
<a name="ln2205">      &amp;&amp; !tv_check_lock(tv_list_locked(list),</a>
<a name="ln2206">                        N_(&quot;flatten() argument&quot;),</a>
<a name="ln2207">                        TV_TRANSLATE)</a>
<a name="ln2208">      &amp;&amp; tv_list_flatten(list, maxdepth) == OK) {</a>
<a name="ln2209">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2210">  }</a>
<a name="ln2211">}</a>
<a name="ln2212"> </a>
<a name="ln2213">/*</a>
<a name="ln2214"> * &quot;extend(list, list [, idx])&quot; function</a>
<a name="ln2215"> * &quot;extend(dict, dict [, action])&quot; function</a>
<a name="ln2216"> */</a>
<a name="ln2217">static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2218">{</a>
<a name="ln2219">  const char *const arg_errmsg = N_(&quot;extend() argument&quot;);</a>
<a name="ln2220"> </a>
<a name="ln2221">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_LIST) {</a>
<a name="ln2222">    long before;</a>
<a name="ln2223">    bool error = false;</a>
<a name="ln2224"> </a>
<a name="ln2225">    list_T *const l1 = argvars[0].vval.v_list;</a>
<a name="ln2226">    list_T *const l2 = argvars[1].vval.v_list;</a>
<a name="ln2227">    if (!tv_check_lock(tv_list_locked(l1), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2228">      listitem_T *item;</a>
<a name="ln2229">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2230">        before = (long)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2231">        if (error) {</a>
<a name="ln2232">          return;  // Type error; errmsg already given.</a>
<a name="ln2233">        }</a>
<a name="ln2234"> </a>
<a name="ln2235">        if (before == tv_list_len(l1)) {</a>
<a name="ln2236">          item = NULL;</a>
<a name="ln2237">        } else {</a>
<a name="ln2238">          item = tv_list_find(l1, before);</a>
<a name="ln2239">          if (item == NULL) {</a>
<a name="ln2240">            EMSGN(_(e_listidx), before);</a>
<a name="ln2241">            return;</a>
<a name="ln2242">          }</a>
<a name="ln2243">        }</a>
<a name="ln2244">      } else {</a>
<a name="ln2245">        item = NULL;</a>
<a name="ln2246">      }</a>
<a name="ln2247">      tv_list_extend(l1, l2, item);</a>
<a name="ln2248"> </a>
<a name="ln2249">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2250">    }</a>
<a name="ln2251">  } else if (argvars[0].v_type == VAR_DICT &amp;&amp; argvars[1].v_type ==</a>
<a name="ln2252">             VAR_DICT) {</a>
<a name="ln2253">    dict_T *const d1 = argvars[0].vval.v_dict;</a>
<a name="ln2254">    dict_T *const d2 = argvars[1].vval.v_dict;</a>
<a name="ln2255">    if (d1 == NULL) {</a>
<a name="ln2256">      const bool locked = tv_check_lock(VAR_FIXED, arg_errmsg, TV_TRANSLATE);</a>
<a name="ln2257">      (void)locked;</a>
<a name="ln2258">      assert(locked == true);</a>
<a name="ln2259">    } else if (d2 == NULL) {</a>
<a name="ln2260">      // Do nothing</a>
<a name="ln2261">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2262">    } else if (!tv_check_lock(d1-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2263">      const char *action = &quot;force&quot;;</a>
<a name="ln2264">      // Check the third argument.</a>
<a name="ln2265">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2266">        const char *const av[] = { &quot;keep&quot;, &quot;force&quot;, &quot;error&quot; };</a>
<a name="ln2267"> </a>
<a name="ln2268">        action = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln2269">        if (action == NULL) {</a>
<a name="ln2270">          return;  // Type error; error message already given.</a>
<a name="ln2271">        }</a>
<a name="ln2272">        size_t i;</a>
<a name="ln2273">        for (i = 0; i &lt; ARRAY_SIZE(av); i++) {</a>
<a name="ln2274">          if (strcmp(action, av[i]) == 0) {</a>
<a name="ln2275">            break;</a>
<a name="ln2276">          }</a>
<a name="ln2277">        }</a>
<a name="ln2278">        if (i == 3) {</a>
<a name="ln2279">          EMSG2(_(e_invarg2), action);</a>
<a name="ln2280">          return;</a>
<a name="ln2281">        }</a>
<a name="ln2282">      }</a>
<a name="ln2283"> </a>
<a name="ln2284">      tv_dict_extend(d1, d2, action);</a>
<a name="ln2285"> </a>
<a name="ln2286">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2287">    }</a>
<a name="ln2288">  } else {</a>
<a name="ln2289">    EMSG2(_(e_listdictarg), &quot;extend()&quot;);</a>
<a name="ln2290">  }</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">/*</a>
<a name="ln2294"> * &quot;feedkeys()&quot; function</a>
<a name="ln2295"> */</a>
<a name="ln2296">static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2297">{</a>
<a name="ln2298">  // This is not allowed in the sandbox.  If the commands would still be</a>
<a name="ln2299">  // executed in the sandbox it would be OK, but it probably happens later,</a>
<a name="ln2300">  // when &quot;sandbox&quot; is no longer set.</a>
<a name="ln2301">  if (check_secure()) {</a>
<a name="ln2302">    return;</a>
<a name="ln2303">  }</a>
<a name="ln2304"> </a>
<a name="ln2305">  const char *const keys = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2306">  char nbuf[NUMBUFLEN];</a>
<a name="ln2307">  const char *flags = NULL;</a>
<a name="ln2308">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2309">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  nvim_feedkeys(cstr_as_string((char *)keys),</a>
<a name="ln2313">                cstr_as_string((char *)flags), true);</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316">/// &quot;filereadable()&quot; function</a>
<a name="ln2317">static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2318">{</a>
<a name="ln2319">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2320">  rettv-&gt;vval.v_number =</a>
<a name="ln2321">    (*p &amp;&amp; !os_isdir((const char_u *)p) &amp;&amp; os_file_is_readable(p));</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324">/*</a>
<a name="ln2325"> * Return 0 for not writable, 1 for writable file, 2 for a dir which we have</a>
<a name="ln2326"> * rights to write into.</a>
<a name="ln2327"> */</a>
<a name="ln2328">static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2329">{</a>
<a name="ln2330">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2331">  rettv-&gt;vval.v_number = os_file_is_writable(filename);</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334"> </a>
<a name="ln2335">static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)</a>
<a name="ln2336">{</a>
<a name="ln2337">  char_u *fresult = NULL;</a>
<a name="ln2338">  char_u *path = *curbuf-&gt;b_p_path == NUL ? p_path : curbuf-&gt;b_p_path;</a>
<a name="ln2339">  int count = 1;</a>
<a name="ln2340">  bool first = true;</a>
<a name="ln2341">  bool error = false;</a>
<a name="ln2342"> </a>
<a name="ln2343">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2344">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2345"> </a>
<a name="ln2346">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2347"> </a>
<a name="ln2348">  char pathbuf[NUMBUFLEN];</a>
<a name="ln2349">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2350">    const char *p = tv_get_string_buf_chk(&amp;argvars[1], pathbuf);</a>
<a name="ln2351">    if (p == NULL) {</a>
<a name="ln2352">      error = true;</a>
<a name="ln2353">    } else {</a>
<a name="ln2354">      if (*p != NUL) {</a>
<a name="ln2355">        path = (char_u *)p;</a>
<a name="ln2356">      }</a>
<a name="ln2357"> </a>
<a name="ln2358">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2359">        count = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2360">      }</a>
<a name="ln2361">    }</a>
<a name="ln2362">  }</a>
<a name="ln2363"> </a>
<a name="ln2364">  if (count &lt; 0) {</a>
<a name="ln2365">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2366">  }</a>
<a name="ln2367"> </a>
<a name="ln2368">  if (*fname != NUL &amp;&amp; !error) {</a>
<a name="ln2369">    do {</a>
<a name="ln2370">      if (rettv-&gt;v_type == VAR_STRING || rettv-&gt;v_type == VAR_LIST)</a>
<a name="ln2371">        xfree(fresult);</a>
<a name="ln2372">      fresult = find_file_in_path_option(first ? (char_u *)fname : NULL,</a>
<a name="ln2373">                                         first ? strlen(fname) : 0,</a>
<a name="ln2374">                                         0, first, path,</a>
<a name="ln2375">                                         find_what, curbuf-&gt;b_ffname,</a>
<a name="ln2376">                                         (find_what == FINDFILE_DIR</a>
<a name="ln2377">                                          ? (char_u *)&quot;&quot;</a>
<a name="ln2378">                                          : curbuf-&gt;b_p_sua));</a>
<a name="ln2379">      first = false;</a>
<a name="ln2380"> </a>
<a name="ln2381">      if (fresult != NULL &amp;&amp; rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2382">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)fresult, -1);</a>
<a name="ln2383">      }</a>
<a name="ln2384">    } while ((rettv-&gt;v_type == VAR_LIST || --count &gt; 0) &amp;&amp; fresult != NULL);</a>
<a name="ln2385">  }</a>
<a name="ln2386"> </a>
<a name="ln2387">  if (rettv-&gt;v_type == VAR_STRING)</a>
<a name="ln2388">    rettv-&gt;vval.v_string = fresult;</a>
<a name="ln2389">}</a>
<a name="ln2390"> </a>
<a name="ln2391"> </a>
<a name="ln2392">/*</a>
<a name="ln2393"> * &quot;filter()&quot; function</a>
<a name="ln2394"> */</a>
<a name="ln2395">static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2396">{</a>
<a name="ln2397">  filter_map(argvars, rettv, FALSE);</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400">/*</a>
<a name="ln2401"> * &quot;finddir({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2402"> */</a>
<a name="ln2403">static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2404">{</a>
<a name="ln2405">  findfilendir(argvars, rettv, FINDFILE_DIR);</a>
<a name="ln2406">}</a>
<a name="ln2407"> </a>
<a name="ln2408">/*</a>
<a name="ln2409"> * &quot;findfile({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2410"> */</a>
<a name="ln2411">static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2412">{</a>
<a name="ln2413">  findfilendir(argvars, rettv, FINDFILE_FILE);</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">/*</a>
<a name="ln2417"> * &quot;float2nr({float})&quot; function</a>
<a name="ln2418"> */</a>
<a name="ln2419">static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2420">{</a>
<a name="ln2421">  float_T f;</a>
<a name="ln2422"> </a>
<a name="ln2423">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln2424">    if (f &lt;= (float_T)-VARNUMBER_MAX + DBL_EPSILON) {</a>
<a name="ln2425">      rettv-&gt;vval.v_number = -VARNUMBER_MAX;</a>
<a name="ln2426">    } else if (f &gt;= (float_T)VARNUMBER_MAX - DBL_EPSILON) {</a>
<a name="ln2427">      rettv-&gt;vval.v_number = VARNUMBER_MAX;</a>
<a name="ln2428">    } else {</a>
<a name="ln2429">      rettv-&gt;vval.v_number = (varnumber_T)f;</a>
<a name="ln2430">    }</a>
<a name="ln2431">  }</a>
<a name="ln2432">}</a>
<a name="ln2433"> </a>
<a name="ln2434">/*</a>
<a name="ln2435"> * &quot;fmod()&quot; function</a>
<a name="ln2436"> */</a>
<a name="ln2437">static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2438">{</a>
<a name="ln2439">  float_T fx;</a>
<a name="ln2440">  float_T fy;</a>
<a name="ln2441"> </a>
<a name="ln2442">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2443">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln2444">    rettv-&gt;vval.v_float = fmod(fx, fy);</a>
<a name="ln2445">  } else {</a>
<a name="ln2446">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln2447">  }</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">/*</a>
<a name="ln2451"> * &quot;fnameescape({string})&quot; function</a>
<a name="ln2452"> */</a>
<a name="ln2453">static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2454">{</a>
<a name="ln2455">  rettv-&gt;vval.v_string = (char_u *)vim_strsave_fnameescape(</a>
<a name="ln2456">      tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2457">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2458">}</a>
<a name="ln2459"> </a>
<a name="ln2460">/*</a>
<a name="ln2461"> * &quot;fnamemodify({fname}, {mods})&quot; function</a>
<a name="ln2462"> */</a>
<a name="ln2463">static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2464">{</a>
<a name="ln2465">  char_u *fbuf = NULL;</a>
<a name="ln2466">  size_t len = 0;</a>
<a name="ln2467">  char buf[NUMBUFLEN];</a>
<a name="ln2468">  const char *fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2469">  const char *const mods = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2470">  if (fname == NULL || mods == NULL) {</a>
<a name="ln2471">    fname = NULL;</a>
<a name="ln2472">  } else {</a>
<a name="ln2473">    len = strlen(fname);</a>
<a name="ln2474">    size_t usedlen = 0;</a>
<a name="ln2475">    if (mods != NULL &amp;&amp; *mods != NUL) {</a>
<a name="ln2476">      (void)modify_fname((char_u *)mods, false, &amp;usedlen,</a>
<a name="ln2477">                         (char_u **)&amp;fname, &amp;fbuf, &amp;len);</a>
<a name="ln2478">    }</a>
<a name="ln2479">  }</a>
<a name="ln2480"> </a>
<a name="ln2481">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2482">  if (fname == NULL) {</a>
<a name="ln2483">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2484">  } else {</a>
<a name="ln2485">    rettv-&gt;vval.v_string = (char_u *)xmemdupz(fname, len);</a>
<a name="ln2486">  }</a>
<a name="ln2487">  xfree(fbuf);</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490"> </a>
<a name="ln2491">/*</a>
<a name="ln2492"> * &quot;foldclosed()&quot; function</a>
<a name="ln2493"> */</a>
<a name="ln2494">static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)</a>
<a name="ln2495">{</a>
<a name="ln2496">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2497">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2498">    linenr_T first;</a>
<a name="ln2499">    linenr_T last;</a>
<a name="ln2500">    if (hasFoldingWin(curwin, lnum, &amp;first, &amp;last, false, NULL)) {</a>
<a name="ln2501">      if (end) {</a>
<a name="ln2502">        rettv-&gt;vval.v_number = (varnumber_T)last;</a>
<a name="ln2503">      } else {</a>
<a name="ln2504">        rettv-&gt;vval.v_number = (varnumber_T)first;</a>
<a name="ln2505">      }</a>
<a name="ln2506">      return;</a>
<a name="ln2507">    }</a>
<a name="ln2508">  }</a>
<a name="ln2509">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">/*</a>
<a name="ln2513"> * &quot;foldclosed()&quot; function</a>
<a name="ln2514"> */</a>
<a name="ln2515">static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2516">{</a>
<a name="ln2517">  foldclosed_both(argvars, rettv, FALSE);</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520">/*</a>
<a name="ln2521"> * &quot;foldclosedend()&quot; function</a>
<a name="ln2522"> */</a>
<a name="ln2523">static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2524">{</a>
<a name="ln2525">  foldclosed_both(argvars, rettv, TRUE);</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">/*</a>
<a name="ln2529"> * &quot;foldlevel()&quot; function</a>
<a name="ln2530"> */</a>
<a name="ln2531">static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2532">{</a>
<a name="ln2533">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2534">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2535">    rettv-&gt;vval.v_number = foldLevel(lnum);</a>
<a name="ln2536">  }</a>
<a name="ln2537">}</a>
<a name="ln2538"> </a>
<a name="ln2539">/*</a>
<a name="ln2540"> * &quot;foldtext()&quot; function</a>
<a name="ln2541"> */</a>
<a name="ln2542">static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2543">{</a>
<a name="ln2544">  linenr_T    foldstart;</a>
<a name="ln2545">  linenr_T    foldend;</a>
<a name="ln2546">  char_u      *dashes;</a>
<a name="ln2547">  linenr_T    lnum;</a>
<a name="ln2548">  char_u      *s;</a>
<a name="ln2549">  char_u      *r;</a>
<a name="ln2550">  int         len;</a>
<a name="ln2551">  char        *txt;</a>
<a name="ln2552"> </a>
<a name="ln2553">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2554">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2555"> </a>
<a name="ln2556">  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);</a>
<a name="ln2557">  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);</a>
<a name="ln2558">  dashes = get_vim_var_str(VV_FOLDDASHES);</a>
<a name="ln2559">  if (foldstart &gt; 0 &amp;&amp; foldend &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2560">    // Find first non-empty line in the fold.</a>
<a name="ln2561">    for (lnum = foldstart; lnum &lt; foldend; lnum++) {</a>
<a name="ln2562">      if (!linewhite(lnum)) {</a>
<a name="ln2563">        break;</a>
<a name="ln2564">      }</a>
<a name="ln2565">    }</a>
<a name="ln2566"> </a>
<a name="ln2567">    // Find interesting text in this line.</a>
<a name="ln2568">    s = skipwhite(ml_get(lnum));</a>
<a name="ln2569">    // skip C comment-start</a>
<a name="ln2570">    if (s[0] == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln2571">      s = skipwhite(s + 2);</a>
<a name="ln2572">      if (*skipwhite(s) == NUL &amp;&amp; lnum + 1 &lt; foldend) {</a>
<a name="ln2573">        s = skipwhite(ml_get(lnum + 1));</a>
<a name="ln2574">        if (*s == '*')</a>
<a name="ln2575">          s = skipwhite(s + 1);</a>
<a name="ln2576">      }</a>
<a name="ln2577">    }</a>
<a name="ln2578">    unsigned long count = (unsigned long)(foldend - foldstart + 1);</a>
<a name="ln2579">    txt = NGETTEXT(&quot;+-%s%3ld line: &quot;, &quot;+-%s%3ld lines: &quot;, count);</a>
<a name="ln2580">    r = xmalloc(STRLEN(txt)</a>
<a name="ln2581">                + STRLEN(dashes)  // for %s</a>
<a name="ln2582">                + 20              // for %3ld</a>
<a name="ln2583">                + STRLEN(s));     // concatenated</a>
<a name="ln2584">    sprintf((char *)r, txt, dashes, count);</a>
<a name="ln2585">    len = (int)STRLEN(r);</a>
<a name="ln2586">    STRCAT(r, s);</a>
<a name="ln2587">    // remove 'foldmarker' and 'commentstring'</a>
<a name="ln2588">    foldtext_cleanup(r + len);</a>
<a name="ln2589">    rettv-&gt;vval.v_string = r;</a>
<a name="ln2590">  }</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">/*</a>
<a name="ln2594"> * &quot;foldtextresult(lnum)&quot; function</a>
<a name="ln2595"> */</a>
<a name="ln2596">static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2597">{</a>
<a name="ln2598">  char_u      *text;</a>
<a name="ln2599">  char_u buf[FOLD_TEXT_LEN];</a>
<a name="ln2600">  static bool entered = false;</a>
<a name="ln2601"> </a>
<a name="ln2602">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2603">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2604">  if (entered) {</a>
<a name="ln2605">    return;  // reject recursive use</a>
<a name="ln2606">  }</a>
<a name="ln2607">  entered = true;</a>
<a name="ln2608">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2609">  // Treat illegal types and illegal string values for {lnum} the same.</a>
<a name="ln2610">  if (lnum &lt; 0) {</a>
<a name="ln2611">    lnum = 0;</a>
<a name="ln2612">  }</a>
<a name="ln2613"> </a>
<a name="ln2614">  foldinfo_T info = fold_info(curwin, lnum);</a>
<a name="ln2615">  if (info.fi_lines &gt; 0) {</a>
<a name="ln2616">    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);</a>
<a name="ln2617">    if (text == buf) {</a>
<a name="ln2618">      text = vim_strsave(text);</a>
<a name="ln2619">    }</a>
<a name="ln2620">    rettv-&gt;vval.v_string = text;</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  entered = false;</a>
<a name="ln2624">}</a>
<a name="ln2625"> </a>
<a name="ln2626">/*</a>
<a name="ln2627"> * &quot;foreground()&quot; function</a>
<a name="ln2628"> */</a>
<a name="ln2629">static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2630">{</a>
<a name="ln2631">}</a>
<a name="ln2632"> </a>
<a name="ln2633">static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2634">{</a>
<a name="ln2635">  common_function(argvars, rettv, true, fptr);</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2639">{</a>
<a name="ln2640">  common_function(argvars, rettv, false, fptr);</a>
<a name="ln2641">}</a>
<a name="ln2642"> </a>
<a name="ln2643">/// &quot;garbagecollect()&quot; function</a>
<a name="ln2644">static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2645">{</a>
<a name="ln2646">  // This is postponed until we are back at the toplevel, because we may be</a>
<a name="ln2647">  // using Lists and Dicts internally.  E.g.: &quot;:echo [garbagecollect()]&quot;.</a>
<a name="ln2648">  want_garbage_collect = true;</a>
<a name="ln2649"> </a>
<a name="ln2650">  if (argvars[0].v_type != VAR_UNKNOWN &amp;&amp; tv_get_number(&amp;argvars[0]) == 1) {</a>
<a name="ln2651">    garbage_collect_at_exit = true;</a>
<a name="ln2652">  }</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655">/*</a>
<a name="ln2656"> * &quot;get()&quot; function</a>
<a name="ln2657"> */</a>
<a name="ln2658">static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2659">{</a>
<a name="ln2660">  listitem_T  *li;</a>
<a name="ln2661">  list_T      *l;</a>
<a name="ln2662">  dictitem_T  *di;</a>
<a name="ln2663">  dict_T      *d;</a>
<a name="ln2664">  typval_T    *tv = NULL;</a>
<a name="ln2665">  bool what_is_dict = false;</a>
<a name="ln2666"> </a>
<a name="ln2667">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln2668">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln2669">      bool error = false;</a>
<a name="ln2670"> </a>
<a name="ln2671">      li = tv_list_find(l, tv_get_number_chk(&amp;argvars[1], &amp;error));</a>
<a name="ln2672">      if (!error &amp;&amp; li != NULL) {</a>
<a name="ln2673">        tv = TV_LIST_ITEM_TV(li);</a>
<a name="ln2674">      }</a>
<a name="ln2675">    }</a>
<a name="ln2676">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2677">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln2678">      di = tv_dict_find(d, tv_get_string(&amp;argvars[1]), -1);</a>
<a name="ln2679">      if (di != NULL) {</a>
<a name="ln2680">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln2681">      }</a>
<a name="ln2682">    }</a>
<a name="ln2683">  } else if (tv_is_func(argvars[0])) {</a>
<a name="ln2684">    partial_T *pt;</a>
<a name="ln2685">    partial_T fref_pt;</a>
<a name="ln2686"> </a>
<a name="ln2687">    if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln2688">      pt = argvars[0].vval.v_partial;</a>
<a name="ln2689">    } else {</a>
<a name="ln2690">      memset(&amp;fref_pt, 0, sizeof(fref_pt));</a>
<a name="ln2691">      fref_pt.pt_name = argvars[0].vval.v_string;</a>
<a name="ln2692">      pt = &amp;fref_pt;</a>
<a name="ln2693">    }</a>
<a name="ln2694"> </a>
<a name="ln2695">    if (pt != NULL) {</a>
<a name="ln2696">      const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2697"> </a>
<a name="ln2698">      if (strcmp(what, &quot;func&quot;) == 0 || strcmp(what, &quot;name&quot;) == 0) {</a>
<a name="ln2699">        rettv-&gt;v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);</a>
<a name="ln2700">        const char *const n = (const char *)partial_name(pt);</a>
<a name="ln2701">        assert(n != NULL);</a>
<a name="ln2702">        rettv-&gt;vval.v_string = (char_u *)xstrdup(n);</a>
<a name="ln2703">        if (rettv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2704">          func_ref(rettv-&gt;vval.v_string);</a>
<a name="ln2705">        }</a>
<a name="ln2706">      } else if (strcmp(what, &quot;dict&quot;) == 0) {</a>
<a name="ln2707">        what_is_dict = true;</a>
<a name="ln2708">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln2709">          tv_dict_set_ret(rettv, pt-&gt;pt_dict);</a>
<a name="ln2710">        }</a>
<a name="ln2711">      } else if (strcmp(what, &quot;args&quot;) == 0) {</a>
<a name="ln2712">        rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln2713">        if (tv_list_alloc_ret(rettv, pt-&gt;pt_argc) != NULL) {</a>
<a name="ln2714">          for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln2715">            tv_list_append_tv(rettv-&gt;vval.v_list, &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln2716">          }</a>
<a name="ln2717">        }</a>
<a name="ln2718">      } else {</a>
<a name="ln2719">        EMSG2(_(e_invarg2), what);</a>
<a name="ln2720">      }</a>
<a name="ln2721"> </a>
<a name="ln2722">      // When {what} == &quot;dict&quot; and pt-&gt;pt_dict == NULL, evaluate the</a>
<a name="ln2723">      // third argument</a>
<a name="ln2724">      if (!what_is_dict) {</a>
<a name="ln2725">        return;</a>
<a name="ln2726">      }</a>
<a name="ln2727">    }</a>
<a name="ln2728">  } else {</a>
<a name="ln2729">    EMSG2(_(e_listdictarg), &quot;get()&quot;);</a>
<a name="ln2730">  }</a>
<a name="ln2731"> </a>
<a name="ln2732">  if (tv == NULL) {</a>
<a name="ln2733">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2734">      tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2735">    }</a>
<a name="ln2736">  } else {</a>
<a name="ln2737">    tv_copy(tv, rettv);</a>
<a name="ln2738">  }</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">/// &quot;getbufinfo()&quot; function</a>
<a name="ln2742">static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2743">{</a>
<a name="ln2744">  buf_T *argbuf = NULL;</a>
<a name="ln2745">  bool filtered = false;</a>
<a name="ln2746">  bool sel_buflisted = false;</a>
<a name="ln2747">  bool sel_bufloaded = false;</a>
<a name="ln2748">  bool sel_bufmodified = false;</a>
<a name="ln2749"> </a>
<a name="ln2750">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2751"> </a>
<a name="ln2752">  // List of all the buffers or selected buffers</a>
<a name="ln2753">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2754">    dict_T *sel_d = argvars[0].vval.v_dict;</a>
<a name="ln2755"> </a>
<a name="ln2756">    if (sel_d != NULL) {</a>
<a name="ln2757">      dictitem_T *di;</a>
<a name="ln2758"> </a>
<a name="ln2759">      filtered = true;</a>
<a name="ln2760"> </a>
<a name="ln2761">      di = tv_dict_find(sel_d, S_LEN(&quot;buflisted&quot;));</a>
<a name="ln2762">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2763">        sel_buflisted = true;</a>
<a name="ln2764">      }</a>
<a name="ln2765"> </a>
<a name="ln2766">      di = tv_dict_find(sel_d, S_LEN(&quot;bufloaded&quot;));</a>
<a name="ln2767">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2768">        sel_bufloaded = true;</a>
<a name="ln2769">      }</a>
<a name="ln2770">      di = tv_dict_find(sel_d, S_LEN(&quot;bufmodified&quot;));</a>
<a name="ln2771">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2772">        sel_bufmodified = true;</a>
<a name="ln2773">      }</a>
<a name="ln2774">    }</a>
<a name="ln2775">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2776">    // Information about one buffer.  Argument specifies the buffer</a>
<a name="ln2777">    if (tv_check_num(&amp;argvars[0])) {  // issue errmsg if type error</a>
<a name="ln2778">      emsg_off++;</a>
<a name="ln2779">      argbuf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2780">      emsg_off--;</a>
<a name="ln2781">      if (argbuf == NULL) {</a>
<a name="ln2782">        return;</a>
<a name="ln2783">      }</a>
<a name="ln2784">    }</a>
<a name="ln2785">  }</a>
<a name="ln2786"> </a>
<a name="ln2787">  // Return information about all the buffers or a specified buffer</a>
<a name="ln2788">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2789">    if (argbuf != NULL &amp;&amp; argbuf != buf) {</a>
<a name="ln2790">      continue;</a>
<a name="ln2791">    }</a>
<a name="ln2792">    if (filtered &amp;&amp; ((sel_bufloaded &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2793">                     || (sel_buflisted &amp;&amp; !buf-&gt;b_p_bl)</a>
<a name="ln2794">                     || (sel_bufmodified &amp;&amp; !buf-&gt;b_changed))) {</a>
<a name="ln2795">      continue;</a>
<a name="ln2796">    }</a>
<a name="ln2797"> </a>
<a name="ln2798">    dict_T *const d = get_buffer_info(buf);</a>
<a name="ln2799">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln2800">    if (argbuf != NULL) {</a>
<a name="ln2801">      return;</a>
<a name="ln2802">    }</a>
<a name="ln2803">  }</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806">/*</a>
<a name="ln2807"> * Get line or list of lines from buffer &quot;buf&quot; into &quot;rettv&quot;.</a>
<a name="ln2808"> * Return a range (from start to end) of lines in rettv from the specified</a>
<a name="ln2809"> * buffer.</a>
<a name="ln2810"> * If 'retlist' is TRUE, then the lines are returned as a Vim List.</a>
<a name="ln2811"> */</a>
<a name="ln2812">static void get_buffer_lines(buf_T *buf,</a>
<a name="ln2813">                             linenr_T start,</a>
<a name="ln2814">                             linenr_T end,</a>
<a name="ln2815">                             int retlist,</a>
<a name="ln2816">                             typval_T *rettv)</a>
<a name="ln2817">{</a>
<a name="ln2818">  rettv-&gt;v_type = (retlist ? VAR_LIST : VAR_STRING);</a>
<a name="ln2819">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2820"> </a>
<a name="ln2821">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL || start &lt; 0 || end &lt; start) {</a>
<a name="ln2822">    if (retlist) {</a>
<a name="ln2823">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln2824">    }</a>
<a name="ln2825">    return;</a>
<a name="ln2826">  }</a>
<a name="ln2827"> </a>
<a name="ln2828">  if (retlist) {</a>
<a name="ln2829">    if (start &lt; 1) {</a>
<a name="ln2830">      start = 1;</a>
<a name="ln2831">    }</a>
<a name="ln2832">    if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2833">      end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2834">    }</a>
<a name="ln2835">    tv_list_alloc_ret(rettv, end - start + 1);</a>
<a name="ln2836">    while (start &lt;= end) {</a>
<a name="ln2837">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2838">                            (const char *)ml_get_buf(buf, start++, false), -1);</a>
<a name="ln2839">    }</a>
<a name="ln2840">  } else {</a>
<a name="ln2841">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2842">    rettv-&gt;vval.v_string = ((start &gt;= 1 &amp;&amp; start &lt;= buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2843">                            ? vim_strsave(ml_get_buf(buf, start, false))</a>
<a name="ln2844">                            : NULL);</a>
<a name="ln2845">  }</a>
<a name="ln2846">}</a>
<a name="ln2847"> </a>
<a name="ln2848">/*</a>
<a name="ln2849"> * &quot;getbufline()&quot; function</a>
<a name="ln2850"> */</a>
<a name="ln2851">static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2852">{</a>
<a name="ln2853">  buf_T *buf = NULL;</a>
<a name="ln2854"> </a>
<a name="ln2855">  if (tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2856">    emsg_off++;</a>
<a name="ln2857">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2858">    emsg_off--;</a>
<a name="ln2859">  }</a>
<a name="ln2860"> </a>
<a name="ln2861">  const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln2862">  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN</a>
<a name="ln2863">                        ? lnum</a>
<a name="ln2864">                        : tv_get_lnum_buf(&amp;argvars[2], buf));</a>
<a name="ln2865"> </a>
<a name="ln2866">  get_buffer_lines(buf, lnum, end, true, rettv);</a>
<a name="ln2867">}</a>
<a name="ln2868"> </a>
<a name="ln2869">/*</a>
<a name="ln2870"> * &quot;getbufvar()&quot; function</a>
<a name="ln2871"> */</a>
<a name="ln2872">static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2873">{</a>
<a name="ln2874">  bool done = false;</a>
<a name="ln2875"> </a>
<a name="ln2876">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2877">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2878"> </a>
<a name="ln2879">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2880">    goto f_getbufvar_end;</a>
<a name="ln2881">  }</a>
<a name="ln2882"> </a>
<a name="ln2883">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2884">  emsg_off++;</a>
<a name="ln2885">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2886"> </a>
<a name="ln2887">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln2888">    if (*varname == '&amp;') {  // buffer-local-option</a>
<a name="ln2889">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln2890"> </a>
<a name="ln2891">      // set curbuf to be our buf, temporarily</a>
<a name="ln2892">      curbuf = buf;</a>
<a name="ln2893"> </a>
<a name="ln2894">      if (varname[1] == NUL) {</a>
<a name="ln2895">        // get all buffer-local options in a dict</a>
<a name="ln2896">        dict_T *opts = get_winbuf_options(true);</a>
<a name="ln2897"> </a>
<a name="ln2898">        if (opts != NULL) {</a>
<a name="ln2899">          tv_dict_set_ret(rettv, opts);</a>
<a name="ln2900">          done = true;</a>
<a name="ln2901">        }</a>
<a name="ln2902">      } else if (get_option_tv(&amp;varname, rettv, true) == OK) {</a>
<a name="ln2903">        // buffer-local-option</a>
<a name="ln2904">        done = true;</a>
<a name="ln2905">      }</a>
<a name="ln2906"> </a>
<a name="ln2907">      // restore previous notion of curbuf</a>
<a name="ln2908">      curbuf = save_curbuf;</a>
<a name="ln2909">    } else {</a>
<a name="ln2910">      // Look up the variable.</a>
<a name="ln2911">      // Let getbufvar({nr}, &quot;&quot;) return the &quot;b:&quot; dictionary.</a>
<a name="ln2912">      dictitem_T *const v = *varname == NUL</a>
<a name="ln2913">        ? (dictitem_T *)&amp;buf-&gt;b_bufvar</a>
<a name="ln2914">        : find_var_in_ht(&amp;buf-&gt;b_vars-&gt;dv_hashtab, 'b',</a>
<a name="ln2915">                         varname, strlen(varname), false);</a>
<a name="ln2916">      if (v != NULL) {</a>
<a name="ln2917">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln2918">        done = true;</a>
<a name="ln2919">      }</a>
<a name="ln2920">    }</a>
<a name="ln2921">  }</a>
<a name="ln2922">  emsg_off--;</a>
<a name="ln2923"> </a>
<a name="ln2924">f_getbufvar_end:</a>
<a name="ln2925">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2926">    // use the default value</a>
<a name="ln2927">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2928">  }</a>
<a name="ln2929">}</a>
<a name="ln2930"> </a>
<a name="ln2931">// &quot;getchangelist()&quot; function</a>
<a name="ln2932">static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2933">{</a>
<a name="ln2934">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln2935">  vim_ignored = tv_get_number(&amp;argvars[0]);  // issue errmsg if type error</a>
<a name="ln2936">  emsg_off++;</a>
<a name="ln2937">  const buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2938">  emsg_off--;</a>
<a name="ln2939">  if (buf == NULL) {</a>
<a name="ln2940">    return;</a>
<a name="ln2941">  }</a>
<a name="ln2942"> </a>
<a name="ln2943">  list_T *const l = tv_list_alloc(buf-&gt;b_changelistlen);</a>
<a name="ln2944">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln2945">  // The current window change list index tracks only the position in the</a>
<a name="ln2946">  // current buffer change list. For other buffers, use the change list</a>
<a name="ln2947">  // length as the current index.</a>
<a name="ln2948">  tv_list_append_number(rettv-&gt;vval.v_list,</a>
<a name="ln2949">                        (buf == curwin-&gt;w_buffer)</a>
<a name="ln2950">                        ? curwin-&gt;w_changelistidx</a>
<a name="ln2951">                        : buf-&gt;b_changelistlen);</a>
<a name="ln2952"> </a>
<a name="ln2953">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln2954">    if (buf-&gt;b_changelist[i].mark.lnum == 0) {</a>
<a name="ln2955">      continue;</a>
<a name="ln2956">    }</a>
<a name="ln2957">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln2958">    tv_list_append_dict(l, d);</a>
<a name="ln2959">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), buf-&gt;b_changelist[i].mark.lnum);</a>
<a name="ln2960">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), buf-&gt;b_changelist[i].mark.col);</a>
<a name="ln2961">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), buf-&gt;b_changelist[i].mark.coladd);</a>
<a name="ln2962">  }</a>
<a name="ln2963">}</a>
<a name="ln2964"> </a>
<a name="ln2965">/*</a>
<a name="ln2966"> * &quot;getchar()&quot; function</a>
<a name="ln2967"> */</a>
<a name="ln2968">static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2969">{</a>
<a name="ln2970">  varnumber_T n;</a>
<a name="ln2971">  bool error = false;</a>
<a name="ln2972"> </a>
<a name="ln2973">  no_mapping++;</a>
<a name="ln2974">  for (;; ) {</a>
<a name="ln2975">    // Position the cursor.  Needed after a message that ends in a space,</a>
<a name="ln2976">    // or if event processing caused a redraw.</a>
<a name="ln2977">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln2978"> </a>
<a name="ln2979">    if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln2980">      // getchar(): blocking wait.</a>
<a name="ln2981">      if (!(char_avail() || using_script() || input_available())) {</a>
<a name="ln2982">        (void)os_inchar(NULL, 0, -1, 0, main_loop.events);</a>
<a name="ln2983">        if (!multiqueue_empty(main_loop.events)) {</a>
<a name="ln2984">          multiqueue_process_events(main_loop.events);</a>
<a name="ln2985">          continue;</a>
<a name="ln2986">        }</a>
<a name="ln2987">      }</a>
<a name="ln2988">      n = safe_vgetc();</a>
<a name="ln2989">    } else if (tv_get_number_chk(&amp;argvars[0], &amp;error) == 1) {</a>
<a name="ln2990">      // getchar(1): only check if char avail</a>
<a name="ln2991">      n = vpeekc_any();</a>
<a name="ln2992">    } else if (error || vpeekc_any() == NUL) {</a>
<a name="ln2993">      // illegal argument or getchar(0) and no char avail: return zero</a>
<a name="ln2994">      n = 0;</a>
<a name="ln2995">    } else {</a>
<a name="ln2996">      // getchar(0) and char avail() != NUL: get a character.</a>
<a name="ln2997">      // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.</a>
<a name="ln2998">      n = safe_vgetc();</a>
<a name="ln2999">    }</a>
<a name="ln3000"> </a>
<a name="ln3001">    if (n == K_IGNORE || n == K_VER_SCROLLBAR || n == K_HOR_SCROLLBAR) {</a>
<a name="ln3002">      continue;</a>
<a name="ln3003">    }</a>
<a name="ln3004">    break;</a>
<a name="ln3005">  }</a>
<a name="ln3006">  no_mapping--;</a>
<a name="ln3007"> </a>
<a name="ln3008">  set_vim_var_nr(VV_MOUSE_WIN, 0);</a>
<a name="ln3009">  set_vim_var_nr(VV_MOUSE_WINID, 0);</a>
<a name="ln3010">  set_vim_var_nr(VV_MOUSE_LNUM, 0);</a>
<a name="ln3011">  set_vim_var_nr(VV_MOUSE_COL, 0);</a>
<a name="ln3012"> </a>
<a name="ln3013">  rettv-&gt;vval.v_number = n;</a>
<a name="ln3014">  if (IS_SPECIAL(n) || mod_mask != 0) {</a>
<a name="ln3015">    char_u temp[10];                // modifier: 3, mbyte-char: 6, NUL: 1</a>
<a name="ln3016">    int i = 0;</a>
<a name="ln3017"> </a>
<a name="ln3018">    // Turn a special key into three bytes, plus modifier.</a>
<a name="ln3019">    if (mod_mask != 0) {</a>
<a name="ln3020">      temp[i++] = K_SPECIAL;</a>
<a name="ln3021">      temp[i++] = KS_MODIFIER;</a>
<a name="ln3022">      temp[i++] = mod_mask;</a>
<a name="ln3023">    }</a>
<a name="ln3024">    if (IS_SPECIAL(n)) {</a>
<a name="ln3025">      temp[i++] = K_SPECIAL;</a>
<a name="ln3026">      temp[i++] = K_SECOND(n);</a>
<a name="ln3027">      temp[i++] = K_THIRD(n);</a>
<a name="ln3028">    } else {</a>
<a name="ln3029">      i += utf_char2bytes(n, temp + i);</a>
<a name="ln3030">    }</a>
<a name="ln3031">    temp[i++] = NUL;</a>
<a name="ln3032">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3033">    rettv-&gt;vval.v_string = vim_strsave(temp);</a>
<a name="ln3034"> </a>
<a name="ln3035">    if (is_mouse_key(n)) {</a>
<a name="ln3036">      int row = mouse_row;</a>
<a name="ln3037">      int col = mouse_col;</a>
<a name="ln3038">      int grid = mouse_grid;</a>
<a name="ln3039">      win_T       *win;</a>
<a name="ln3040">      linenr_T lnum;</a>
<a name="ln3041">      win_T       *wp;</a>
<a name="ln3042">      int winnr = 1;</a>
<a name="ln3043"> </a>
<a name="ln3044">      if (row &gt;= 0 &amp;&amp; col &gt;= 0) {</a>
<a name="ln3045">        /* Find the window at the mouse coordinates and compute the</a>
<a name="ln3046">         * text position. */</a>
<a name="ln3047">        win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3048">        if (win == NULL) {</a>
<a name="ln3049">          return;</a>
<a name="ln3050">        }</a>
<a name="ln3051">        (void)mouse_comp_pos(win, &amp;row, &amp;col, &amp;lnum);</a>
<a name="ln3052">        for (wp = firstwin; wp != win; wp = wp-&gt;w_next)</a>
<a name="ln3053">          ++winnr;</a>
<a name="ln3054">        set_vim_var_nr(VV_MOUSE_WIN, winnr);</a>
<a name="ln3055">        set_vim_var_nr(VV_MOUSE_WINID, wp-&gt;handle);</a>
<a name="ln3056">        set_vim_var_nr(VV_MOUSE_LNUM, lnum);</a>
<a name="ln3057">        set_vim_var_nr(VV_MOUSE_COL, col + 1);</a>
<a name="ln3058">      }</a>
<a name="ln3059">    }</a>
<a name="ln3060">  }</a>
<a name="ln3061">}</a>
<a name="ln3062"> </a>
<a name="ln3063">/*</a>
<a name="ln3064"> * &quot;getcharmod()&quot; function</a>
<a name="ln3065"> */</a>
<a name="ln3066">static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3067">{</a>
<a name="ln3068">  rettv-&gt;vval.v_number = mod_mask;</a>
<a name="ln3069">}</a>
<a name="ln3070"> </a>
<a name="ln3071">/*</a>
<a name="ln3072"> * &quot;getcharsearch()&quot; function</a>
<a name="ln3073"> */</a>
<a name="ln3074">static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3075">{</a>
<a name="ln3076">  tv_dict_alloc_ret(rettv);</a>
<a name="ln3077"> </a>
<a name="ln3078">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln3079"> </a>
<a name="ln3080">  tv_dict_add_str(dict, S_LEN(&quot;char&quot;), last_csearch());</a>
<a name="ln3081">  tv_dict_add_nr(dict, S_LEN(&quot;forward&quot;), last_csearch_forward());</a>
<a name="ln3082">  tv_dict_add_nr(dict, S_LEN(&quot;until&quot;), last_csearch_until());</a>
<a name="ln3083">}</a>
<a name="ln3084"> </a>
<a name="ln3085">/*</a>
<a name="ln3086"> * &quot;getcmdline()&quot; function</a>
<a name="ln3087"> */</a>
<a name="ln3088">static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3089">{</a>
<a name="ln3090">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3091">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln3092">}</a>
<a name="ln3093"> </a>
<a name="ln3094">/*</a>
<a name="ln3095"> * &quot;getcmdpos()&quot; function</a>
<a name="ln3096"> */</a>
<a name="ln3097">static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3098">{</a>
<a name="ln3099">  rettv-&gt;vval.v_number = get_cmdline_pos() + 1;</a>
<a name="ln3100">}</a>
<a name="ln3101"> </a>
<a name="ln3102">/*</a>
<a name="ln3103"> * &quot;getcmdtype()&quot; function</a>
<a name="ln3104"> */</a>
<a name="ln3105">static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3106">{</a>
<a name="ln3107">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3108">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3109">  rettv-&gt;vval.v_string[0] = get_cmdline_type();</a>
<a name="ln3110">}</a>
<a name="ln3111"> </a>
<a name="ln3112">/*</a>
<a name="ln3113"> * &quot;getcmdwintype()&quot; function</a>
<a name="ln3114"> */</a>
<a name="ln3115">static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3116">{</a>
<a name="ln3117">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3118">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3119">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3120">  rettv-&gt;vval.v_string[0] = cmdwin_type;</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">// &quot;getcompletion()&quot; function</a>
<a name="ln3124">static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3125">{</a>
<a name="ln3126">  char_u        *pat;</a>
<a name="ln3127">  expand_T      xpc;</a>
<a name="ln3128">  bool          filtered = false;</a>
<a name="ln3129">  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH</a>
<a name="ln3130">          | WILD_NO_BEEP;</a>
<a name="ln3131"> </a>
<a name="ln3132">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3133">    filtered = (bool)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln3134">  }</a>
<a name="ln3135"> </a>
<a name="ln3136">  if (p_wic) {</a>
<a name="ln3137">    options |= WILD_ICASE;</a>
<a name="ln3138">  }</a>
<a name="ln3139"> </a>
<a name="ln3140">  // For filtered results, 'wildignore' is used</a>
<a name="ln3141">  if (!filtered) {</a>
<a name="ln3142">    options |= WILD_KEEP_ALL;</a>
<a name="ln3143">  }</a>
<a name="ln3144"> </a>
<a name="ln3145">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln3146">    EMSG(_(e_invarg));</a>
<a name="ln3147">    return;</a>
<a name="ln3148">  }</a>
<a name="ln3149"> </a>
<a name="ln3150">  if (strcmp(tv_get_string(&amp;argvars[1]), &quot;cmdline&quot;) == 0) {</a>
<a name="ln3151">    set_one_cmd_context(&amp;xpc, tv_get_string(&amp;argvars[0]));</a>
<a name="ln3152">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3153">    goto theend;</a>
<a name="ln3154">  }</a>
<a name="ln3155"> </a>
<a name="ln3156">  ExpandInit(&amp;xpc);</a>
<a name="ln3157">  xpc.xp_pattern = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3158">  xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3159">  xpc.xp_context = cmdcomplete_str_to_type(</a>
<a name="ln3160">      (char_u *)tv_get_string(&amp;argvars[1]));</a>
<a name="ln3161">  if (xpc.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3162">    EMSG2(_(e_invarg2), argvars[1].vval.v_string);</a>
<a name="ln3163">    return;</a>
<a name="ln3164">  }</a>
<a name="ln3165"> </a>
<a name="ln3166">  if (xpc.xp_context == EXPAND_MENUS) {</a>
<a name="ln3167">    set_context_in_menu_cmd(&amp;xpc, (char_u *)&quot;menu&quot;, xpc.xp_pattern, false);</a>
<a name="ln3168">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3169">  }</a>
<a name="ln3170"> </a>
<a name="ln3171">  if (xpc.xp_context == EXPAND_CSCOPE) {</a>
<a name="ln3172">    set_context_in_cscope_cmd(&amp;xpc, (const char *)xpc.xp_pattern, CMD_cscope);</a>
<a name="ln3173">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3174">  }</a>
<a name="ln3175"> </a>
<a name="ln3176">  if (xpc.xp_context == EXPAND_SIGN) {</a>
<a name="ln3177">    set_context_in_sign_cmd(&amp;xpc, xpc.xp_pattern);</a>
<a name="ln3178">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3179">  }</a>
<a name="ln3180"> </a>
<a name="ln3181">theend:</a>
<a name="ln3182">  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);</a>
<a name="ln3183">  ExpandOne(&amp;xpc, pat, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln3184">  tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3185"> </a>
<a name="ln3186">  for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3187">    tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3188">                          -1);</a>
<a name="ln3189">  }</a>
<a name="ln3190">  xfree(pat);</a>
<a name="ln3191">  ExpandCleanup(&amp;xpc);</a>
<a name="ln3192">}</a>
<a name="ln3193"> </a>
<a name="ln3194">/// `getcwd([{win}[, {tab}]])` function</a>
<a name="ln3195">///</a>
<a name="ln3196">/// Every scope not specified implies the currently selected scope object.</a>
<a name="ln3197">///</a>
<a name="ln3198">/// @pre  The arguments must be of type number.</a>
<a name="ln3199">/// @pre  There may not be more than two arguments.</a>
<a name="ln3200">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln3201">///</a>
<a name="ln3202">/// @post  The return value will be a string.</a>
<a name="ln3203">static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3204">{</a>
<a name="ln3205">  // Possible scope of working directory to return.</a>
<a name="ln3206">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln3207"> </a>
<a name="ln3208">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln3209">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln3210">  int scope_number[] = {</a>
<a name="ln3211">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln3212">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln3213">  };</a>
<a name="ln3214"> </a>
<a name="ln3215">  char_u *cwd  = NULL;  // Current working directory to print</a>
<a name="ln3216">  char_u *from = NULL;  // The original string to copy</a>
<a name="ln3217"> </a>
<a name="ln3218">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln3219">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln3220"> </a>
<a name="ln3221">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3222">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3223"> </a>
<a name="ln3224">  // Pre-conditions and scope extraction together</a>
<a name="ln3225">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln3226">    // If there is no argument there are no more scopes after it, break out.</a>
<a name="ln3227">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln3228">      break;</a>
<a name="ln3229">    }</a>
<a name="ln3230">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln3231">      EMSG(_(e_invarg));</a>
<a name="ln3232">      return;</a>
<a name="ln3233">    }</a>
<a name="ln3234">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln3235">    // It is an error for the scope number to be less than `-1`.</a>
<a name="ln3236">    if (scope_number[i] &lt; -1) {</a>
<a name="ln3237">      EMSG(_(e_invarg));</a>
<a name="ln3238">      return;</a>
<a name="ln3239">    }</a>
<a name="ln3240">    // Use the narrowest scope the user requested</a>
<a name="ln3241">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln3242">      // The scope is the current iteration step.</a>
<a name="ln3243">      scope = i;</a>
<a name="ln3244">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln3245">      scope = i + 1;</a>
<a name="ln3246">    }</a>
<a name="ln3247">  }</a>
<a name="ln3248"> </a>
<a name="ln3249">  // If the user didn't specify anything, default to window scope</a>
<a name="ln3250">  if (scope == kCdScopeInvalid) {</a>
<a name="ln3251">    scope = MIN_CD_SCOPE;</a>
<a name="ln3252">  }</a>
<a name="ln3253"> </a>
<a name="ln3254">  // Find the tabpage by number</a>
<a name="ln3255">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln3256">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln3257">    if (!tp) {</a>
<a name="ln3258">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln3259">      return;</a>
<a name="ln3260">    }</a>
<a name="ln3261">  }</a>
<a name="ln3262"> </a>
<a name="ln3263">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln3264">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln3265">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln3266">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln3267">      return;</a>
<a name="ln3268">    }</a>
<a name="ln3269"> </a>
<a name="ln3270">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln3271">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln3272">      if (!win) {</a>
<a name="ln3273">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln3274">        return;</a>
<a name="ln3275">      }</a>
<a name="ln3276">    }</a>
<a name="ln3277">  }</a>
<a name="ln3278"> </a>
<a name="ln3279">  cwd = xmalloc(MAXPATHL);</a>
<a name="ln3280"> </a>
<a name="ln3281">  switch (scope) {</a>
<a name="ln3282">    case kCdScopeWindow:</a>
<a name="ln3283">      assert(win);</a>
<a name="ln3284">      from = win-&gt;w_localdir;</a>
<a name="ln3285">      if (from) {</a>
<a name="ln3286">        break;</a>
<a name="ln3287">      }</a>
<a name="ln3288">      FALLTHROUGH;</a>
<a name="ln3289">    case kCdScopeTab:</a>
<a name="ln3290">      assert(tp);</a>
<a name="ln3291">      from = tp-&gt;tp_localdir;</a>
<a name="ln3292">      if (from) {</a>
<a name="ln3293">        break;</a>
<a name="ln3294">      }</a>
<a name="ln3295">      FALLTHROUGH;</a>
<a name="ln3296">    case kCdScopeGlobal:</a>
<a name="ln3297">      if (globaldir) {        // `globaldir` is not always set.</a>
<a name="ln3298">        from = globaldir;</a>
<a name="ln3299">      } else if (os_dirname(cwd, MAXPATHL) == FAIL) {  // Get the OS CWD.</a>
<a name="ln3300">        from = (char_u *)&quot;&quot;;  // Return empty string on failure.</a>
<a name="ln3301">      }</a>
<a name="ln3302">      break;</a>
<a name="ln3303">    case kCdScopeInvalid:     // We should never get here</a>
<a name="ln3304">      assert(false);</a>
<a name="ln3305">  }</a>
<a name="ln3306"> </a>
<a name="ln3307">  if (from) {</a>
<a name="ln3308">    xstrlcpy((char *)cwd, (char *)from, MAXPATHL);</a>
<a name="ln3309">  }</a>
<a name="ln3310"> </a>
<a name="ln3311">  rettv-&gt;vval.v_string = vim_strsave(cwd);</a>
<a name="ln3312">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3313">  slash_adjust(rettv-&gt;vval.v_string);</a>
<a name="ln3314">#endif</a>
<a name="ln3315"> </a>
<a name="ln3316">  xfree(cwd);</a>
<a name="ln3317">}</a>
<a name="ln3318"> </a>
<a name="ln3319">/*</a>
<a name="ln3320"> * &quot;getfontname()&quot; function</a>
<a name="ln3321"> */</a>
<a name="ln3322">static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3323">{</a>
<a name="ln3324">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3325">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3326">}</a>
<a name="ln3327"> </a>
<a name="ln3328">/*</a>
<a name="ln3329"> * &quot;getfperm({fname})&quot; function</a>
<a name="ln3330"> */</a>
<a name="ln3331">static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3332">{</a>
<a name="ln3333">  char *perm = NULL;</a>
<a name="ln3334">  char_u flags[] = &quot;rwx&quot;;</a>
<a name="ln3335"> </a>
<a name="ln3336">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3337">  int32_t file_perm = os_getperm(filename);</a>
<a name="ln3338">  if (file_perm &gt;= 0) {</a>
<a name="ln3339">    perm = xstrdup(&quot;---------&quot;);</a>
<a name="ln3340">    for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln3341">      if (file_perm &amp; (1 &lt;&lt; (8 - i))) {</a>
<a name="ln3342">        perm[i] = flags[i % 3];</a>
<a name="ln3343">      }</a>
<a name="ln3344">    }</a>
<a name="ln3345">  }</a>
<a name="ln3346">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3347">  rettv-&gt;vval.v_string = (char_u *)perm;</a>
<a name="ln3348">}</a>
<a name="ln3349"> </a>
<a name="ln3350">/*</a>
<a name="ln3351"> * &quot;getfsize({fname})&quot; function</a>
<a name="ln3352"> */</a>
<a name="ln3353">static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3354">{</a>
<a name="ln3355">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3356"> </a>
<a name="ln3357">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3358"> </a>
<a name="ln3359">  FileInfo file_info;</a>
<a name="ln3360">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3361">    uint64_t filesize = os_fileinfo_size(&amp;file_info);</a>
<a name="ln3362">    if (os_isdir((const char_u *)fname)) {</a>
<a name="ln3363">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln3364">    } else {</a>
<a name="ln3365">      rettv-&gt;vval.v_number = (varnumber_T)filesize;</a>
<a name="ln3366"> </a>
<a name="ln3367">      // non-perfect check for overflow</a>
<a name="ln3368">      if ((uint64_t)rettv-&gt;vval.v_number != filesize) {</a>
<a name="ln3369">        rettv-&gt;vval.v_number = -2;</a>
<a name="ln3370">      }</a>
<a name="ln3371">    }</a>
<a name="ln3372">  } else {</a>
<a name="ln3373">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3374">  }</a>
<a name="ln3375">}</a>
<a name="ln3376"> </a>
<a name="ln3377">/*</a>
<a name="ln3378"> * &quot;getftime({fname})&quot; function</a>
<a name="ln3379"> */</a>
<a name="ln3380">static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3381">{</a>
<a name="ln3382">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3383"> </a>
<a name="ln3384">  FileInfo file_info;</a>
<a name="ln3385">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3386">    rettv-&gt;vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3387">  } else {</a>
<a name="ln3388">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3389">  }</a>
<a name="ln3390">}</a>
<a name="ln3391"> </a>
<a name="ln3392">/*</a>
<a name="ln3393"> * &quot;getftype({fname})&quot; function</a>
<a name="ln3394"> */</a>
<a name="ln3395">static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3396">{</a>
<a name="ln3397">  char_u      *type = NULL;</a>
<a name="ln3398">  char        *t;</a>
<a name="ln3399"> </a>
<a name="ln3400">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3401"> </a>
<a name="ln3402">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3403">  FileInfo file_info;</a>
<a name="ln3404">  if (os_fileinfo_link(fname, &amp;file_info)) {</a>
<a name="ln3405">    uint64_t mode = file_info.stat.st_mode;</a>
<a name="ln3406">    if (S_ISREG(mode)) {</a>
<a name="ln3407">      t = &quot;file&quot;;</a>
<a name="ln3408">    } else if (S_ISDIR(mode)) {</a>
<a name="ln3409">      t = &quot;dir&quot;;</a>
<a name="ln3410">    } else if (S_ISLNK(mode)) {</a>
<a name="ln3411">      t = &quot;link&quot;;</a>
<a name="ln3412">    } else if (S_ISBLK(mode)) {</a>
<a name="ln3413">      t = &quot;bdev&quot;;</a>
<a name="ln3414">    } else if (S_ISCHR(mode)) {</a>
<a name="ln3415">      t = &quot;cdev&quot;;</a>
<a name="ln3416">    } else if (S_ISFIFO(mode)) {</a>
<a name="ln3417">      t = &quot;fifo&quot;;</a>
<a name="ln3418">    } else if (S_ISSOCK(mode)) {</a>
<a name="ln3419">      t = &quot;socket&quot;;</a>
<a name="ln3420">    } else {</a>
<a name="ln3421">      t = &quot;other&quot;;</a>
<a name="ln3422">    }</a>
<a name="ln3423">    type = vim_strsave((char_u *)t);</a>
<a name="ln3424">  }</a>
<a name="ln3425">  rettv-&gt;vval.v_string = type;</a>
<a name="ln3426">}</a>
<a name="ln3427"> </a>
<a name="ln3428">// &quot;getjumplist()&quot; function</a>
<a name="ln3429">static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3430">{</a>
<a name="ln3431">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3432">  win_T *const wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln3433">  if (wp == NULL) {</a>
<a name="ln3434">    return;</a>
<a name="ln3435">  }</a>
<a name="ln3436"> </a>
<a name="ln3437">  cleanup_jumplist(wp, true);</a>
<a name="ln3438"> </a>
<a name="ln3439">  list_T *const l = tv_list_alloc(wp-&gt;w_jumplistlen);</a>
<a name="ln3440">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3441">  tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_jumplistidx);</a>
<a name="ln3442"> </a>
<a name="ln3443">  for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln3444">    if (wp-&gt;w_jumplist[i].fmark.mark.lnum == 0) {</a>
<a name="ln3445">      continue;</a>
<a name="ln3446">    }</a>
<a name="ln3447">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3448">    tv_list_append_dict(l, d);</a>
<a name="ln3449">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), wp-&gt;w_jumplist[i].fmark.mark.lnum);</a>
<a name="ln3450">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), wp-&gt;w_jumplist[i].fmark.mark.col);</a>
<a name="ln3451">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), wp-&gt;w_jumplist[i].fmark.mark.coladd);</a>
<a name="ln3452">    tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), wp-&gt;w_jumplist[i].fmark.fnum);</a>
<a name="ln3453">    if (wp-&gt;w_jumplist[i].fname != NULL) {</a>
<a name="ln3454">      tv_dict_add_str(d, S_LEN(&quot;filename&quot;), (char *)wp-&gt;w_jumplist[i].fname);</a>
<a name="ln3455">    }</a>
<a name="ln3456">  }</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">/*</a>
<a name="ln3460"> * &quot;getline(lnum, [end])&quot; function</a>
<a name="ln3461"> */</a>
<a name="ln3462">static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3463">{</a>
<a name="ln3464">  linenr_T end;</a>
<a name="ln3465">  bool retlist;</a>
<a name="ln3466"> </a>
<a name="ln3467">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln3468">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln3469">    end = lnum;</a>
<a name="ln3470">    retlist = false;</a>
<a name="ln3471">  } else {</a>
<a name="ln3472">    end = tv_get_lnum(&amp;argvars[1]);</a>
<a name="ln3473">    retlist = true;</a>
<a name="ln3474">  }</a>
<a name="ln3475"> </a>
<a name="ln3476">  get_buffer_lines(curbuf, lnum, end, retlist, rettv);</a>
<a name="ln3477">}</a>
<a name="ln3478"> </a>
<a name="ln3479">/// &quot;getloclist()&quot; function</a>
<a name="ln3480">static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3481">{</a>
<a name="ln3482">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3483">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln3484">}</a>
<a name="ln3485"> </a>
<a name="ln3486"> </a>
<a name="ln3487">/// &quot;getmarklist()&quot; function</a>
<a name="ln3488">static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3489">{</a>
<a name="ln3490">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3491"> </a>
<a name="ln3492">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3493">    get_global_marks(rettv-&gt;vval.v_list);</a>
<a name="ln3494">    return;</a>
<a name="ln3495">  }</a>
<a name="ln3496"> </a>
<a name="ln3497">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3498">  if (buf == NULL) {</a>
<a name="ln3499">    return;</a>
<a name="ln3500">  }</a>
<a name="ln3501"> </a>
<a name="ln3502">  get_buf_local_marks(buf, rettv-&gt;vval.v_list);</a>
<a name="ln3503">}</a>
<a name="ln3504"> </a>
<a name="ln3505">/*</a>
<a name="ln3506"> * &quot;getmatches()&quot; function</a>
<a name="ln3507"> */</a>
<a name="ln3508">static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3509">{</a>
<a name="ln3510">  matchitem_T *cur;</a>
<a name="ln3511">  int i;</a>
<a name="ln3512">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln3513"> </a>
<a name="ln3514">  if (win == NULL) {</a>
<a name="ln3515">    return;</a>
<a name="ln3516">  }</a>
<a name="ln3517"> </a>
<a name="ln3518">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3519">  cur = win-&gt;w_match_head;</a>
<a name="ln3520">  while (cur != NULL) {</a>
<a name="ln3521">    dict_T *dict = tv_dict_alloc();</a>
<a name="ln3522">    if (cur-&gt;match.regprog == NULL) {</a>
<a name="ln3523">      // match added with matchaddpos()</a>
<a name="ln3524">      for (i = 0; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln3525">        llpos_T   *llpos;</a>
<a name="ln3526">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln3527"> </a>
<a name="ln3528">        llpos = &amp;cur-&gt;pos.pos[i];</a>
<a name="ln3529">        if (llpos-&gt;lnum == 0) {</a>
<a name="ln3530">          break;</a>
<a name="ln3531">        }</a>
<a name="ln3532">        list_T *const l = tv_list_alloc(1 + (llpos-&gt;col &gt; 0 ? 2 : 0));</a>
<a name="ln3533">        tv_list_append_number(l, (varnumber_T)llpos-&gt;lnum);</a>
<a name="ln3534">        if (llpos-&gt;col &gt; 0) {</a>
<a name="ln3535">          tv_list_append_number(l, (varnumber_T)llpos-&gt;col);</a>
<a name="ln3536">          tv_list_append_number(l, (varnumber_T)llpos-&gt;len);</a>
<a name="ln3537">        }</a>
<a name="ln3538">        int len = snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i + 1);</a>
<a name="ln3539">        assert((size_t)len &lt; sizeof(buf));</a>
<a name="ln3540">        tv_dict_add_list(dict, buf, (size_t)len, l);</a>
<a name="ln3541">      }</a>
<a name="ln3542">    } else {</a>
<a name="ln3543">      tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (const char *)cur-&gt;pattern);</a>
<a name="ln3544">    }</a>
<a name="ln3545">    tv_dict_add_str(dict, S_LEN(&quot;group&quot;),</a>
<a name="ln3546">                    (const char *)syn_id2name(cur-&gt;hlg_id));</a>
<a name="ln3547">    tv_dict_add_nr(dict, S_LEN(&quot;priority&quot;), (varnumber_T)cur-&gt;priority);</a>
<a name="ln3548">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), (varnumber_T)cur-&gt;id);</a>
<a name="ln3549"> </a>
<a name="ln3550">    if (cur-&gt;conceal_char) {</a>
<a name="ln3551">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln3552"> </a>
<a name="ln3553">      buf[utf_char2bytes((int)cur-&gt;conceal_char, (char_u *)buf)] = NUL;</a>
<a name="ln3554">      tv_dict_add_str(dict, S_LEN(&quot;conceal&quot;), buf);</a>
<a name="ln3555">    }</a>
<a name="ln3556"> </a>
<a name="ln3557">    tv_list_append_dict(rettv-&gt;vval.v_list, dict);</a>
<a name="ln3558">    cur = cur-&gt;next;</a>
<a name="ln3559">  }</a>
<a name="ln3560">}</a>
<a name="ln3561"> </a>
<a name="ln3562">/*</a>
<a name="ln3563"> * &quot;getpid()&quot; function</a>
<a name="ln3564"> */</a>
<a name="ln3565">static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3566">{</a>
<a name="ln3567">  rettv-&gt;vval.v_number = os_get_pid();</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)</a>
<a name="ln3571">{</a>
<a name="ln3572">  pos_T *fp;</a>
<a name="ln3573">  int fnum = -1;</a>
<a name="ln3574"> </a>
<a name="ln3575">  if (getcurpos) {</a>
<a name="ln3576">    fp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln3577">  } else {</a>
<a name="ln3578">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln3579">  }</a>
<a name="ln3580"> </a>
<a name="ln3581">  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));</a>
<a name="ln3582">  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);</a>
<a name="ln3583">  tv_list_append_number(l, ((fp != NULL)</a>
<a name="ln3584">                            ? (varnumber_T)fp-&gt;lnum</a>
<a name="ln3585">                            : (varnumber_T)0));</a>
<a name="ln3586">  tv_list_append_number(</a>
<a name="ln3587">      l, ((fp != NULL)</a>
<a name="ln3588">          ? (varnumber_T)(fp-&gt;col == MAXCOL ? MAXCOL : fp-&gt;col + 1)</a>
<a name="ln3589">          : (varnumber_T)0));</a>
<a name="ln3590">  tv_list_append_number(</a>
<a name="ln3591">      l, (fp != NULL) ? (varnumber_T)fp-&gt;coladd : (varnumber_T)0);</a>
<a name="ln3592">  if (getcurpos) {</a>
<a name="ln3593">    const int save_set_curswant = curwin-&gt;w_set_curswant;</a>
<a name="ln3594">    const colnr_T save_curswant = curwin-&gt;w_curswant;</a>
<a name="ln3595">    const colnr_T save_virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln3596"> </a>
<a name="ln3597">    update_curswant();</a>
<a name="ln3598">    tv_list_append_number(l, (curwin-&gt;w_curswant == MAXCOL</a>
<a name="ln3599">                              ? (varnumber_T)MAXCOL</a>
<a name="ln3600">                              : (varnumber_T)curwin-&gt;w_curswant + 1));</a>
<a name="ln3601"> </a>
<a name="ln3602">    // Do not change &quot;curswant&quot;, as it is unexpected that a get</a>
<a name="ln3603">    // function has a side effect.</a>
<a name="ln3604">    if (save_set_curswant) {</a>
<a name="ln3605">      curwin-&gt;w_set_curswant = save_set_curswant;</a>
<a name="ln3606">      curwin-&gt;w_curswant = save_curswant;</a>
<a name="ln3607">      curwin-&gt;w_virtcol = save_virtcol;</a>
<a name="ln3608">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln3609">    }</a>
<a name="ln3610">  }</a>
<a name="ln3611">}</a>
<a name="ln3612"> </a>
<a name="ln3613">/*</a>
<a name="ln3614"> * &quot;getcurpos(string)&quot; function</a>
<a name="ln3615"> */</a>
<a name="ln3616">static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3617">{</a>
<a name="ln3618">  getpos_both(argvars, rettv, true);</a>
<a name="ln3619">}</a>
<a name="ln3620"> </a>
<a name="ln3621">/*</a>
<a name="ln3622"> * &quot;getpos(string)&quot; function</a>
<a name="ln3623"> */</a>
<a name="ln3624">static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3625">{</a>
<a name="ln3626">  getpos_both(argvars, rettv, false);</a>
<a name="ln3627">}</a>
<a name="ln3628"> </a>
<a name="ln3629">/// &quot;getqflist()&quot; functions</a>
<a name="ln3630">static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3631">{</a>
<a name="ln3632">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln3633">}</a>
<a name="ln3634"> </a>
<a name="ln3635">/// &quot;getreg()&quot; function</a>
<a name="ln3636">static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3637">{</a>
<a name="ln3638">  const char *strregname;</a>
<a name="ln3639">  int arg2 = false;</a>
<a name="ln3640">  bool return_list = false;</a>
<a name="ln3641">  bool error = false;</a>
<a name="ln3642"> </a>
<a name="ln3643">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3644">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3645">    error = strregname == NULL;</a>
<a name="ln3646">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3647">      arg2 = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln3648">      if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3649">        return_list = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3650">      }</a>
<a name="ln3651">    }</a>
<a name="ln3652">  } else {</a>
<a name="ln3653">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3654">  }</a>
<a name="ln3655"> </a>
<a name="ln3656">  if (error) {</a>
<a name="ln3657">    return;</a>
<a name="ln3658">  }</a>
<a name="ln3659"> </a>
<a name="ln3660">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3661">  if (regname == 0) {</a>
<a name="ln3662">    regname = '&quot;';</a>
<a name="ln3663">  }</a>
<a name="ln3664"> </a>
<a name="ln3665">  if (return_list) {</a>
<a name="ln3666">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln3667">    rettv-&gt;vval.v_list =</a>
<a name="ln3668">      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);</a>
<a name="ln3669">    if (rettv-&gt;vval.v_list == NULL) {</a>
<a name="ln3670">      rettv-&gt;vval.v_list = tv_list_alloc(0);</a>
<a name="ln3671">    }</a>
<a name="ln3672">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln3673">  } else {</a>
<a name="ln3674">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3675">    rettv-&gt;vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);</a>
<a name="ln3676">  }</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">/*</a>
<a name="ln3680"> * &quot;getregtype()&quot; function</a>
<a name="ln3681"> */</a>
<a name="ln3682">static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3683">{</a>
<a name="ln3684">  const char *strregname;</a>
<a name="ln3685"> </a>
<a name="ln3686">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3687">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3688">    if (strregname == NULL) {  // Type error; errmsg already given.</a>
<a name="ln3689">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3690">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3691">      return;</a>
<a name="ln3692">    }</a>
<a name="ln3693">  } else {</a>
<a name="ln3694">    // Default to v:register.</a>
<a name="ln3695">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3696">  }</a>
<a name="ln3697"> </a>
<a name="ln3698">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3699">  if (regname == 0) {</a>
<a name="ln3700">    regname = '&quot;';</a>
<a name="ln3701">  }</a>
<a name="ln3702"> </a>
<a name="ln3703">  colnr_T reglen = 0;</a>
<a name="ln3704">  char buf[NUMBUFLEN + 2];</a>
<a name="ln3705">  MotionType reg_type = get_reg_type(regname, &amp;reglen);</a>
<a name="ln3706">  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));</a>
<a name="ln3707"> </a>
<a name="ln3708">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3709">  rettv-&gt;vval.v_string = (char_u *)xstrdup(buf);</a>
<a name="ln3710">}</a>
<a name="ln3711"> </a>
<a name="ln3712">/// &quot;gettabinfo()&quot; function</a>
<a name="ln3713">static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3714">{</a>
<a name="ln3715">  tabpage_T *tparg = NULL;</a>
<a name="ln3716"> </a>
<a name="ln3717">  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN</a>
<a name="ln3718">                            ? 1</a>
<a name="ln3719">                            : kListLenMayKnow));</a>
<a name="ln3720"> </a>
<a name="ln3721">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3722">    // Information about one tab page</a>
<a name="ln3723">    tparg = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3724">    if (tparg == NULL) {</a>
<a name="ln3725">      return;</a>
<a name="ln3726">    }</a>
<a name="ln3727">  }</a>
<a name="ln3728"> </a>
<a name="ln3729">  // Get information about a specific tab page or all tab pages</a>
<a name="ln3730">  int tpnr = 0;</a>
<a name="ln3731">  FOR_ALL_TABS(tp) {</a>
<a name="ln3732">    tpnr++;</a>
<a name="ln3733">    if (tparg != NULL &amp;&amp; tp != tparg) {</a>
<a name="ln3734">      continue;</a>
<a name="ln3735">    }</a>
<a name="ln3736">    dict_T *const d = get_tabpage_info(tp, tpnr);</a>
<a name="ln3737">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3738">    if (tparg != NULL) {</a>
<a name="ln3739">      return;</a>
<a name="ln3740">    }</a>
<a name="ln3741">  }</a>
<a name="ln3742">}</a>
<a name="ln3743"> </a>
<a name="ln3744">/*</a>
<a name="ln3745"> * &quot;gettabvar()&quot; function</a>
<a name="ln3746"> */</a>
<a name="ln3747">static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3748">{</a>
<a name="ln3749">  win_T *oldcurwin;</a>
<a name="ln3750">  tabpage_T *oldtabpage;</a>
<a name="ln3751">  bool done = false;</a>
<a name="ln3752"> </a>
<a name="ln3753">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3754">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3755"> </a>
<a name="ln3756">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3757">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3758">  if (tp != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln3759">    // Set tp to be our tabpage, temporarily.  Also set the window to the</a>
<a name="ln3760">    // first window in the tabpage, otherwise the window is not valid.</a>
<a name="ln3761">    win_T *const window = tp == curtab || tp-&gt;tp_firstwin == NULL</a>
<a name="ln3762">        ? firstwin</a>
<a name="ln3763">        : tp-&gt;tp_firstwin;</a>
<a name="ln3764">    if (switch_win(&amp;oldcurwin, &amp;oldtabpage, window, tp, true) == OK) {</a>
<a name="ln3765">      // look up the variable</a>
<a name="ln3766">      // Let gettabvar({nr}, &quot;&quot;) return the &quot;t:&quot; dictionary.</a>
<a name="ln3767">      const dictitem_T *const v = find_var_in_ht(&amp;tp-&gt;tp_vars-&gt;dv_hashtab, 't',</a>
<a name="ln3768">                                                 varname, strlen(varname),</a>
<a name="ln3769">                                                 false);</a>
<a name="ln3770">      if (v != NULL) {</a>
<a name="ln3771">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln3772">        done = true;</a>
<a name="ln3773">      }</a>
<a name="ln3774">    }</a>
<a name="ln3775"> </a>
<a name="ln3776">    // restore previous notion of curwin</a>
<a name="ln3777">    restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln3778">  }</a>
<a name="ln3779"> </a>
<a name="ln3780">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3781">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln3782">  }</a>
<a name="ln3783">}</a>
<a name="ln3784"> </a>
<a name="ln3785">/*</a>
<a name="ln3786"> * &quot;gettabwinvar()&quot; function</a>
<a name="ln3787"> */</a>
<a name="ln3788">static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3789">{</a>
<a name="ln3790">  getwinvar(argvars, rettv, 1);</a>
<a name="ln3791">}</a>
<a name="ln3792"> </a>
<a name="ln3793">// &quot;gettagstack()&quot; function</a>
<a name="ln3794">static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3795">{</a>
<a name="ln3796">    win_T        *wp = curwin;                  // default is current window</a>
<a name="ln3797"> </a>
<a name="ln3798">    tv_dict_alloc_ret(rettv);</a>
<a name="ln3799"> </a>
<a name="ln3800">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3801">        wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3802">        if (wp == NULL) {</a>
<a name="ln3803">          return;</a>
<a name="ln3804">        }</a>
<a name="ln3805">    }</a>
<a name="ln3806"> </a>
<a name="ln3807">    get_tagstack(wp, rettv-&gt;vval.v_dict);</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">/// &quot;getwininfo()&quot; function</a>
<a name="ln3811">static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3812">{</a>
<a name="ln3813">  win_T *wparg = NULL;</a>
<a name="ln3814"> </a>
<a name="ln3815">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3816"> </a>
<a name="ln3817">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3818">    wparg = win_id2wp(argvars);</a>
<a name="ln3819">    if (wparg == NULL) {</a>
<a name="ln3820">      return;</a>
<a name="ln3821">    }</a>
<a name="ln3822">  }</a>
<a name="ln3823"> </a>
<a name="ln3824">  // Collect information about either all the windows across all the tab</a>
<a name="ln3825">  // pages or one particular window.</a>
<a name="ln3826">  int16_t tabnr = 0;</a>
<a name="ln3827">  FOR_ALL_TABS(tp) {</a>
<a name="ln3828">    tabnr++;</a>
<a name="ln3829">    int16_t winnr = 0;</a>
<a name="ln3830">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3831">      winnr++;</a>
<a name="ln3832">      if (wparg != NULL &amp;&amp; wp != wparg) {</a>
<a name="ln3833">        continue;</a>
<a name="ln3834">      }</a>
<a name="ln3835">      dict_T *const d = get_win_info(wp, tabnr, winnr);</a>
<a name="ln3836">      tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3837">      if (wparg != NULL) {</a>
<a name="ln3838">        // found information about a specific window</a>
<a name="ln3839">        return;</a>
<a name="ln3840">      }</a>
<a name="ln3841">    }</a>
<a name="ln3842">  }</a>
<a name="ln3843">}</a>
<a name="ln3844"> </a>
<a name="ln3845">// Dummy timer callback. Used by f_wait().</a>
<a name="ln3846">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3847">{</a>
<a name="ln3848">}</a>
<a name="ln3849"> </a>
<a name="ln3850">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln3851">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3852">{</a>
<a name="ln3853">  xfree(tw);</a>
<a name="ln3854">}</a>
<a name="ln3855"> </a>
<a name="ln3856">/// &quot;wait(timeout, condition[, interval])&quot; function</a>
<a name="ln3857">static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3858">{</a>
<a name="ln3859">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3860">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3861"> </a>
<a name="ln3862">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln3863">    EMSG2(_(e_invargval), &quot;1&quot;);</a>
<a name="ln3864">    return;</a>
<a name="ln3865">  }</a>
<a name="ln3866">  if ((argvars[2].v_type != VAR_NUMBER &amp;&amp; argvars[2].v_type != VAR_UNKNOWN)</a>
<a name="ln3867">      || (argvars[2].v_type == VAR_NUMBER &amp;&amp; argvars[2].vval.v_number &lt;= 0)) {</a>
<a name="ln3868">    EMSG2(_(e_invargval), &quot;3&quot;);</a>
<a name="ln3869">    return;</a>
<a name="ln3870">  }</a>
<a name="ln3871"> </a>
<a name="ln3872">  int timeout = argvars[0].vval.v_number;</a>
<a name="ln3873">  typval_T expr = argvars[1];</a>
<a name="ln3874">  int interval = argvars[2].v_type == VAR_NUMBER</a>
<a name="ln3875">    ? argvars[2].vval.v_number</a>
<a name="ln3876">    : 200;  // Default.</a>
<a name="ln3877">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln3878"> </a>
<a name="ln3879">  // Start dummy timer.</a>
<a name="ln3880">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln3881">  tw-&gt;events = main_loop.events;</a>
<a name="ln3882">  tw-&gt;blockable = true;</a>
<a name="ln3883">  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);</a>
<a name="ln3884"> </a>
<a name="ln3885">  typval_T argv = TV_INITIAL_VALUE;</a>
<a name="ln3886">  typval_T exprval = TV_INITIAL_VALUE;</a>
<a name="ln3887">  bool error = false;</a>
<a name="ln3888">  int save_called_emsg = called_emsg;</a>
<a name="ln3889">  called_emsg = false;</a>
<a name="ln3890"> </a>
<a name="ln3891">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, timeout,</a>
<a name="ln3892">                            eval_expr_typval(&amp;expr, &amp;argv, 0, &amp;exprval) != OK</a>
<a name="ln3893">                            || tv_get_number_chk(&amp;exprval, &amp;error)</a>
<a name="ln3894">                            || called_emsg || error || got_int);</a>
<a name="ln3895"> </a>
<a name="ln3896">  if (called_emsg || error) {</a>
<a name="ln3897">    rettv-&gt;vval.v_number = -3;</a>
<a name="ln3898">  } else if (got_int) {</a>
<a name="ln3899">    got_int = false;</a>
<a name="ln3900">    vgetc();</a>
<a name="ln3901">    rettv-&gt;vval.v_number = -2;</a>
<a name="ln3902">  } else if (tv_get_number_chk(&amp;exprval, &amp;error)) {</a>
<a name="ln3903">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln3904">  }</a>
<a name="ln3905"> </a>
<a name="ln3906">  called_emsg = save_called_emsg;</a>
<a name="ln3907"> </a>
<a name="ln3908">  // Stop dummy timer</a>
<a name="ln3909">  time_watcher_stop(tw);</a>
<a name="ln3910">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln3911">}</a>
<a name="ln3912"> </a>
<a name="ln3913">// &quot;win_screenpos()&quot; function</a>
<a name="ln3914">static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3915">{</a>
<a name="ln3916">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3917">  const win_T *const wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3918">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_winrow + 1);</a>
<a name="ln3919">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_wincol + 1);</a>
<a name="ln3920">}</a>
<a name="ln3921"> </a>
<a name="ln3922">// &quot;getwinpos({timeout})&quot; function</a>
<a name="ln3923">static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3924">{</a>
<a name="ln3925">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3926">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln3927">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln3928">}</a>
<a name="ln3929"> </a>
<a name="ln3930">/*</a>
<a name="ln3931"> * &quot;getwinposx()&quot; function</a>
<a name="ln3932"> */</a>
<a name="ln3933">static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3934">{</a>
<a name="ln3935">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">/*</a>
<a name="ln3939"> * &quot;getwinposy()&quot; function</a>
<a name="ln3940"> */</a>
<a name="ln3941">static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3942">{</a>
<a name="ln3943">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3944">}</a>
<a name="ln3945"> </a>
<a name="ln3946">/// &quot;getwinvar()&quot; function</a>
<a name="ln3947">static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3948">{</a>
<a name="ln3949">  getwinvar(argvars, rettv, 0);</a>
<a name="ln3950">}</a>
<a name="ln3951"> </a>
<a name="ln3952">/*</a>
<a name="ln3953"> * &quot;glob()&quot; function</a>
<a name="ln3954"> */</a>
<a name="ln3955">static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3956">{</a>
<a name="ln3957">  int options = WILD_SILENT|WILD_USE_NL;</a>
<a name="ln3958">  expand_T xpc;</a>
<a name="ln3959">  bool error = false;</a>
<a name="ln3960"> </a>
<a name="ln3961">  /* When the optional second argument is non-zero, don't remove matches</a>
<a name="ln3962">  * for 'wildignore' and don't put matches for 'suffixes' at the end. */</a>
<a name="ln3963">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3964">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3965">    if (tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln3966">      options |= WILD_KEEP_ALL;</a>
<a name="ln3967">    }</a>
<a name="ln3968">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3969">      if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln3970">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln3971">      }</a>
<a name="ln3972">      if (argvars[3].v_type != VAR_UNKNOWN</a>
<a name="ln3973">          &amp;&amp; tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln3974">        options |= WILD_ALLLINKS;</a>
<a name="ln3975">      }</a>
<a name="ln3976">    }</a>
<a name="ln3977">  }</a>
<a name="ln3978">  if (!error) {</a>
<a name="ln3979">    ExpandInit(&amp;xpc);</a>
<a name="ln3980">    xpc.xp_context = EXPAND_FILES;</a>
<a name="ln3981">    if (p_wic)</a>
<a name="ln3982">      options += WILD_ICASE;</a>
<a name="ln3983">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln3984">      rettv-&gt;vval.v_string = ExpandOne(</a>
<a name="ln3985">          &amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options, WILD_ALL);</a>
<a name="ln3986">    } else {</a>
<a name="ln3987">      ExpandOne(&amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options,</a>
<a name="ln3988">                WILD_ALL_KEEP);</a>
<a name="ln3989">      tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3990">      for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3991">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3992">                              -1);</a>
<a name="ln3993">      }</a>
<a name="ln3994">      ExpandCleanup(&amp;xpc);</a>
<a name="ln3995">    }</a>
<a name="ln3996">  } else</a>
<a name="ln3997">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3998">}</a>
<a name="ln3999"> </a>
<a name="ln4000">/// &quot;globpath()&quot; function</a>
<a name="ln4001">static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4002">{</a>
<a name="ln4003">  int flags = WILD_IGNORE_COMPLETESLASH;  // Flags for globpath.</a>
<a name="ln4004">  bool error = false;</a>
<a name="ln4005"> </a>
<a name="ln4006">  // Return a string, or a list if the optional third argument is non-zero.</a>
<a name="ln4007">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4008"> </a>
<a name="ln4009">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4010">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4011">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln4012">    if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4013">      flags |= WILD_KEEP_ALL;</a>
<a name="ln4014">    }</a>
<a name="ln4015"> </a>
<a name="ln4016">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4017">      if (tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4018">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4019">      }</a>
<a name="ln4020">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln4021">          &amp;&amp; tv_get_number_chk(&amp;argvars[4], &amp;error)) {</a>
<a name="ln4022">        flags |= WILD_ALLLINKS;</a>
<a name="ln4023">      }</a>
<a name="ln4024">    }</a>
<a name="ln4025">  }</a>
<a name="ln4026"> </a>
<a name="ln4027">  char buf1[NUMBUFLEN];</a>
<a name="ln4028">  const char *const file = tv_get_string_buf_chk(&amp;argvars[1], buf1);</a>
<a name="ln4029">  if (file != NULL &amp;&amp; !error) {</a>
<a name="ln4030">    garray_T ga;</a>
<a name="ln4031">    ga_init(&amp;ga, (int)sizeof(char_u *), 10);</a>
<a name="ln4032">    globpath((char_u *)tv_get_string(&amp;argvars[0]), (char_u *)file, &amp;ga, flags);</a>
<a name="ln4033"> </a>
<a name="ln4034">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4035">      rettv-&gt;vval.v_string = ga_concat_strings_sep(&amp;ga, &quot;\n&quot;);</a>
<a name="ln4036">    } else {</a>
<a name="ln4037">      tv_list_alloc_ret(rettv, ga.ga_len);</a>
<a name="ln4038">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln4039">        tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln4040">                              ((const char **)(ga.ga_data))[i], -1);</a>
<a name="ln4041">      }</a>
<a name="ln4042">    }</a>
<a name="ln4043"> </a>
<a name="ln4044">    ga_clear_strings(&amp;ga);</a>
<a name="ln4045">  } else {</a>
<a name="ln4046">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4047">  }</a>
<a name="ln4048">}</a>
<a name="ln4049"> </a>
<a name="ln4050">// &quot;glob2regpat()&quot; function</a>
<a name="ln4051">static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4052">{</a>
<a name="ln4053">  const char *const pat = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4054"> </a>
<a name="ln4055">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4056">  rettv-&gt;vval.v_string = ((pat == NULL)</a>
<a name="ln4057">                          ? NULL</a>
<a name="ln4058">                          : file_pat_to_reg_pat((char_u *)pat, NULL, NULL,</a>
<a name="ln4059">                                                false));</a>
<a name="ln4060">}</a>
<a name="ln4061"> </a>
<a name="ln4062">/// &quot;has()&quot; function</a>
<a name="ln4063">static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4064">{</a>
<a name="ln4065">  static const char *const has_list[] = {</a>
<a name="ln4066">#if defined(BSD) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln4067">    &quot;bsd&quot;,</a>
<a name="ln4068">#endif</a>
<a name="ln4069">#ifdef UNIX</a>
<a name="ln4070">    &quot;unix&quot;,</a>
<a name="ln4071">#endif</a>
<a name="ln4072">#if defined(WIN32)</a>
<a name="ln4073">    &quot;win32&quot;,</a>
<a name="ln4074">#endif</a>
<a name="ln4075">#ifdef _WIN64</a>
<a name="ln4076">    &quot;win64&quot;,</a>
<a name="ln4077">#endif</a>
<a name="ln4078">    &quot;fname_case&quot;,</a>
<a name="ln4079">#ifdef HAVE_ACL</a>
<a name="ln4080">    &quot;acl&quot;,</a>
<a name="ln4081">#endif</a>
<a name="ln4082">    &quot;autochdir&quot;,</a>
<a name="ln4083">    &quot;arabic&quot;,</a>
<a name="ln4084">    &quot;autocmd&quot;,</a>
<a name="ln4085">    &quot;browsefilter&quot;,</a>
<a name="ln4086">    &quot;byte_offset&quot;,</a>
<a name="ln4087">    &quot;cindent&quot;,</a>
<a name="ln4088">    &quot;cmdline_compl&quot;,</a>
<a name="ln4089">    &quot;cmdline_hist&quot;,</a>
<a name="ln4090">    &quot;comments&quot;,</a>
<a name="ln4091">    &quot;conceal&quot;,</a>
<a name="ln4092">    &quot;cscope&quot;,</a>
<a name="ln4093">    &quot;cursorbind&quot;,</a>
<a name="ln4094">    &quot;cursorshape&quot;,</a>
<a name="ln4095">#ifdef DEBUG</a>
<a name="ln4096">    &quot;debug&quot;,</a>
<a name="ln4097">#endif</a>
<a name="ln4098">    &quot;dialog_con&quot;,</a>
<a name="ln4099">    &quot;diff&quot;,</a>
<a name="ln4100">    &quot;digraphs&quot;,</a>
<a name="ln4101">    &quot;eval&quot;,         // always present, of course!</a>
<a name="ln4102">    &quot;ex_extra&quot;,</a>
<a name="ln4103">    &quot;extra_search&quot;,</a>
<a name="ln4104">    &quot;file_in_path&quot;,</a>
<a name="ln4105">    &quot;filterpipe&quot;,</a>
<a name="ln4106">    &quot;find_in_path&quot;,</a>
<a name="ln4107">    &quot;float&quot;,</a>
<a name="ln4108">    &quot;folding&quot;,</a>
<a name="ln4109">#if defined(UNIX)</a>
<a name="ln4110">    &quot;fork&quot;,</a>
<a name="ln4111">#endif</a>
<a name="ln4112">    &quot;gettext&quot;,</a>
<a name="ln4113">#if defined(HAVE_ICONV)</a>
<a name="ln4114">    &quot;iconv&quot;,</a>
<a name="ln4115">#endif</a>
<a name="ln4116">    &quot;insert_expand&quot;,</a>
<a name="ln4117">    &quot;jumplist&quot;,</a>
<a name="ln4118">    &quot;keymap&quot;,</a>
<a name="ln4119">    &quot;lambda&quot;,</a>
<a name="ln4120">    &quot;langmap&quot;,</a>
<a name="ln4121">    &quot;libcall&quot;,</a>
<a name="ln4122">    &quot;linebreak&quot;,</a>
<a name="ln4123">    &quot;lispindent&quot;,</a>
<a name="ln4124">    &quot;listcmds&quot;,</a>
<a name="ln4125">    &quot;localmap&quot;,</a>
<a name="ln4126">#ifdef __APPLE__</a>
<a name="ln4127">    &quot;mac&quot;,</a>
<a name="ln4128">    &quot;macunix&quot;,</a>
<a name="ln4129">    &quot;osx&quot;,</a>
<a name="ln4130">    &quot;osxdarwin&quot;,</a>
<a name="ln4131">#endif</a>
<a name="ln4132">    &quot;menu&quot;,</a>
<a name="ln4133">    &quot;mksession&quot;,</a>
<a name="ln4134">    &quot;modify_fname&quot;,</a>
<a name="ln4135">    &quot;mouse&quot;,</a>
<a name="ln4136">    &quot;multi_byte&quot;,</a>
<a name="ln4137">    &quot;multi_lang&quot;,</a>
<a name="ln4138">    &quot;num64&quot;,</a>
<a name="ln4139">    &quot;packages&quot;,</a>
<a name="ln4140">    &quot;path_extra&quot;,</a>
<a name="ln4141">    &quot;persistent_undo&quot;,</a>
<a name="ln4142">    &quot;postscript&quot;,</a>
<a name="ln4143">    &quot;printer&quot;,</a>
<a name="ln4144">    &quot;profile&quot;,</a>
<a name="ln4145">    &quot;pythonx&quot;,</a>
<a name="ln4146">    &quot;reltime&quot;,</a>
<a name="ln4147">    &quot;quickfix&quot;,</a>
<a name="ln4148">    &quot;rightleft&quot;,</a>
<a name="ln4149">    &quot;scrollbind&quot;,</a>
<a name="ln4150">    &quot;showcmd&quot;,</a>
<a name="ln4151">    &quot;cmdline_info&quot;,</a>
<a name="ln4152">    &quot;shada&quot;,</a>
<a name="ln4153">    &quot;signs&quot;,</a>
<a name="ln4154">    &quot;smartindent&quot;,</a>
<a name="ln4155">    &quot;startuptime&quot;,</a>
<a name="ln4156">    &quot;statusline&quot;,</a>
<a name="ln4157">    &quot;spell&quot;,</a>
<a name="ln4158">    &quot;syntax&quot;,</a>
<a name="ln4159">#if !defined(UNIX)</a>
<a name="ln4160">    &quot;system&quot;,  // TODO(SplinterOfChaos): This IS defined for UNIX!</a>
<a name="ln4161">#endif</a>
<a name="ln4162">    &quot;tablineat&quot;,</a>
<a name="ln4163">    &quot;tag_binary&quot;,</a>
<a name="ln4164">    &quot;termguicolors&quot;,</a>
<a name="ln4165">    &quot;termresponse&quot;,</a>
<a name="ln4166">    &quot;textobjects&quot;,</a>
<a name="ln4167">    &quot;timers&quot;,</a>
<a name="ln4168">    &quot;title&quot;,</a>
<a name="ln4169">    &quot;user-commands&quot;,        // was accidentally included in 5.4</a>
<a name="ln4170">    &quot;user_commands&quot;,</a>
<a name="ln4171">    &quot;vertsplit&quot;,</a>
<a name="ln4172">    &quot;virtualedit&quot;,</a>
<a name="ln4173">    &quot;visual&quot;,</a>
<a name="ln4174">    &quot;visualextra&quot;,</a>
<a name="ln4175">    &quot;vreplace&quot;,</a>
<a name="ln4176">    &quot;wildignore&quot;,</a>
<a name="ln4177">    &quot;wildmenu&quot;,</a>
<a name="ln4178">    &quot;windows&quot;,</a>
<a name="ln4179">    &quot;winaltkeys&quot;,</a>
<a name="ln4180">    &quot;writebackup&quot;,</a>
<a name="ln4181">#if defined(HAVE_WSL)</a>
<a name="ln4182">    &quot;wsl&quot;,</a>
<a name="ln4183">#endif</a>
<a name="ln4184">    &quot;nvim&quot;,</a>
<a name="ln4185">  };</a>
<a name="ln4186"> </a>
<a name="ln4187">  bool n = false;</a>
<a name="ln4188">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4189">  for (size_t i = 0; i &lt; ARRAY_SIZE(has_list); i++) {</a>
<a name="ln4190">    if (STRICMP(name, has_list[i]) == 0) {</a>
<a name="ln4191">      n = true;</a>
<a name="ln4192">      break;</a>
<a name="ln4193">    }</a>
<a name="ln4194">  }</a>
<a name="ln4195"> </a>
<a name="ln4196">  if (!n) {</a>
<a name="ln4197">    if (STRNICMP(name, &quot;patch&quot;, 5) == 0) {</a>
<a name="ln4198">      if (name[5] == '-'</a>
<a name="ln4199">          &amp;&amp; strlen(name) &gt;= 11</a>
<a name="ln4200">          &amp;&amp; ascii_isdigit(name[6])</a>
<a name="ln4201">          &amp;&amp; ascii_isdigit(name[8])</a>
<a name="ln4202">          &amp;&amp; ascii_isdigit(name[10])) {</a>
<a name="ln4203">        int major = atoi(name + 6);</a>
<a name="ln4204">        int minor = atoi(name + 8);</a>
<a name="ln4205"> </a>
<a name="ln4206">        // Expect &quot;patch-9.9.01234&quot;.</a>
<a name="ln4207">        n = (major &lt; VIM_VERSION_MAJOR</a>
<a name="ln4208">             || (major == VIM_VERSION_MAJOR</a>
<a name="ln4209">                 &amp;&amp; (minor &lt; VIM_VERSION_MINOR</a>
<a name="ln4210">                     || (minor == VIM_VERSION_MINOR</a>
<a name="ln4211">                         &amp;&amp; has_vim_patch(atoi(name + 10))))));</a>
<a name="ln4212">      } else {</a>
<a name="ln4213">        n = has_vim_patch(atoi(name + 5));</a>
<a name="ln4214">      }</a>
<a name="ln4215">    } else if (STRNICMP(name, &quot;nvim-&quot;, 5) == 0) {</a>
<a name="ln4216">      // Expect &quot;nvim-x.y.z&quot;</a>
<a name="ln4217">      n = has_nvim_version(name + 5);</a>
<a name="ln4218">    } else if (STRICMP(name, &quot;vim_starting&quot;) == 0) {</a>
<a name="ln4219">      n = (starting != 0);</a>
<a name="ln4220">    } else if (STRICMP(name, &quot;ttyin&quot;) == 0) {</a>
<a name="ln4221">      n = stdin_isatty;</a>
<a name="ln4222">    } else if (STRICMP(name, &quot;ttyout&quot;) == 0) {</a>
<a name="ln4223">      n = stdout_isatty;</a>
<a name="ln4224">    } else if (STRICMP(name, &quot;multi_byte_encoding&quot;) == 0) {</a>
<a name="ln4225">      n = true;</a>
<a name="ln4226">    } else if (STRICMP(name, &quot;syntax_items&quot;) == 0) {</a>
<a name="ln4227">      n = syntax_present(curwin);</a>
<a name="ln4228">    } else if (STRICMP(name, &quot;clipboard_working&quot;) == 0) {</a>
<a name="ln4229">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4230">#ifdef UNIX</a>
<a name="ln4231">    } else if (STRICMP(name, &quot;unnamedplus&quot;) == 0) {</a>
<a name="ln4232">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4233">#endif</a>
<a name="ln4234">    }</a>
<a name="ln4235">  }</a>
<a name="ln4236"> </a>
<a name="ln4237">  if (!n &amp;&amp; eval_has_provider(name)) {</a>
<a name="ln4238">    n = true;</a>
<a name="ln4239">  }</a>
<a name="ln4240"> </a>
<a name="ln4241">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4242">}</a>
<a name="ln4243"> </a>
<a name="ln4244">/*</a>
<a name="ln4245"> * &quot;has_key()&quot; function</a>
<a name="ln4246"> */</a>
<a name="ln4247">static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4248">{</a>
<a name="ln4249">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln4250">    EMSG(_(e_dictreq));</a>
<a name="ln4251">    return;</a>
<a name="ln4252">  }</a>
<a name="ln4253">  if (argvars[0].vval.v_dict == NULL)</a>
<a name="ln4254">    return;</a>
<a name="ln4255"> </a>
<a name="ln4256">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln4257">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln4258">                                      -1) != NULL;</a>
<a name="ln4259">}</a>
<a name="ln4260"> </a>
<a name="ln4261">/// `haslocaldir([{win}[, {tab}]])` function</a>
<a name="ln4262">///</a>
<a name="ln4263">/// Returns `1` if the scope object has a local directory, `0` otherwise. If a</a>
<a name="ln4264">/// scope object is not specified the current one is implied. This function</a>
<a name="ln4265">/// share a lot of code with `f_getcwd`.</a>
<a name="ln4266">///</a>
<a name="ln4267">/// @pre  The arguments must be of type number.</a>
<a name="ln4268">/// @pre  There may not be more than two arguments.</a>
<a name="ln4269">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln4270">///</a>
<a name="ln4271">/// @post  The return value will be either the number `1` or `0`.</a>
<a name="ln4272">static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4273">{</a>
<a name="ln4274">  // Possible scope of working directory to return.</a>
<a name="ln4275">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln4276"> </a>
<a name="ln4277">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln4278">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln4279">  int scope_number[] = {</a>
<a name="ln4280">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln4281">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln4282">  };</a>
<a name="ln4283"> </a>
<a name="ln4284">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln4285">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln4286"> </a>
<a name="ln4287">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4288">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4289"> </a>
<a name="ln4290">  // Pre-conditions and scope extraction together</a>
<a name="ln4291">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln4292">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln4293">      break;</a>
<a name="ln4294">    }</a>
<a name="ln4295">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln4296">      EMSG(_(e_invarg));</a>
<a name="ln4297">      return;</a>
<a name="ln4298">    }</a>
<a name="ln4299">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln4300">    if (scope_number[i] &lt; -1) {</a>
<a name="ln4301">      EMSG(_(e_invarg));</a>
<a name="ln4302">      return;</a>
<a name="ln4303">    }</a>
<a name="ln4304">    // Use the narrowest scope the user requested</a>
<a name="ln4305">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln4306">      // The scope is the current iteration step.</a>
<a name="ln4307">      scope = i;</a>
<a name="ln4308">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln4309">      scope = i + 1;</a>
<a name="ln4310">    }</a>
<a name="ln4311">  }</a>
<a name="ln4312"> </a>
<a name="ln4313">  // If the user didn't specify anything, default to window scope</a>
<a name="ln4314">  if (scope == kCdScopeInvalid) {</a>
<a name="ln4315">    scope = MIN_CD_SCOPE;</a>
<a name="ln4316">  }</a>
<a name="ln4317"> </a>
<a name="ln4318">  // Find the tabpage by number</a>
<a name="ln4319">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln4320">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln4321">    if (!tp) {</a>
<a name="ln4322">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln4323">      return;</a>
<a name="ln4324">    }</a>
<a name="ln4325">  }</a>
<a name="ln4326"> </a>
<a name="ln4327">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln4328">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln4329">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln4330">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln4331">      return;</a>
<a name="ln4332">    }</a>
<a name="ln4333"> </a>
<a name="ln4334">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln4335">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln4336">      if (!win) {</a>
<a name="ln4337">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln4338">        return;</a>
<a name="ln4339">      }</a>
<a name="ln4340">    }</a>
<a name="ln4341">  }</a>
<a name="ln4342"> </a>
<a name="ln4343">  switch (scope) {</a>
<a name="ln4344">    case kCdScopeWindow:</a>
<a name="ln4345">      assert(win);</a>
<a name="ln4346">      rettv-&gt;vval.v_number = win-&gt;w_localdir ? 1 : 0;</a>
<a name="ln4347">      break;</a>
<a name="ln4348">    case kCdScopeTab:</a>
<a name="ln4349">      assert(tp);</a>
<a name="ln4350">      rettv-&gt;vval.v_number = tp-&gt;tp_localdir ? 1 : 0;</a>
<a name="ln4351">      break;</a>
<a name="ln4352">    case kCdScopeGlobal:</a>
<a name="ln4353">      // The global scope never has a local directory</a>
<a name="ln4354">      break;</a>
<a name="ln4355">    case kCdScopeInvalid:</a>
<a name="ln4356">      // We should never get here</a>
<a name="ln4357">      assert(false);</a>
<a name="ln4358">  }</a>
<a name="ln4359">}</a>
<a name="ln4360"> </a>
<a name="ln4361">/*</a>
<a name="ln4362"> * &quot;hasmapto()&quot; function</a>
<a name="ln4363"> */</a>
<a name="ln4364">static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4365">{</a>
<a name="ln4366">  const char *mode;</a>
<a name="ln4367">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4368">  bool abbr = false;</a>
<a name="ln4369">  char buf[NUMBUFLEN];</a>
<a name="ln4370">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4371">    mode = &quot;nvo&quot;;</a>
<a name="ln4372">  } else {</a>
<a name="ln4373">    mode = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4374">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4375">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln4376">    }</a>
<a name="ln4377">  }</a>
<a name="ln4378"> </a>
<a name="ln4379">  if (map_to_exists(name, mode, abbr)) {</a>
<a name="ln4380">    rettv-&gt;vval.v_number = true;</a>
<a name="ln4381">  } else {</a>
<a name="ln4382">    rettv-&gt;vval.v_number = false;</a>
<a name="ln4383">  }</a>
<a name="ln4384">}</a>
<a name="ln4385"> </a>
<a name="ln4386">/*</a>
<a name="ln4387"> * &quot;histadd()&quot; function</a>
<a name="ln4388"> */</a>
<a name="ln4389">static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4390">{</a>
<a name="ln4391">  HistoryType histype;</a>
<a name="ln4392"> </a>
<a name="ln4393">  rettv-&gt;vval.v_number = false;</a>
<a name="ln4394">  if (check_secure()) {</a>
<a name="ln4395">    return;</a>
<a name="ln4396">  }</a>
<a name="ln4397">  const char *str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4398">  histype = str != NULL ? get_histtype(str, strlen(str), false) : HIST_INVALID;</a>
<a name="ln4399">  if (histype != HIST_INVALID) {</a>
<a name="ln4400">    char buf[NUMBUFLEN];</a>
<a name="ln4401">    str = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4402">    if (*str != NUL) {</a>
<a name="ln4403">      init_history();</a>
<a name="ln4404">      add_to_history(histype, (char_u *)str, false, NUL);</a>
<a name="ln4405">      rettv-&gt;vval.v_number = true;</a>
<a name="ln4406">      return;</a>
<a name="ln4407">    }</a>
<a name="ln4408">  }</a>
<a name="ln4409">}</a>
<a name="ln4410"> </a>
<a name="ln4411">/*</a>
<a name="ln4412"> * &quot;histdel()&quot; function</a>
<a name="ln4413"> */</a>
<a name="ln4414">static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4415">{</a>
<a name="ln4416">  int n;</a>
<a name="ln4417">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4418">  if (str == NULL) {</a>
<a name="ln4419">    n = 0;</a>
<a name="ln4420">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4421">    // only one argument: clear entire history</a>
<a name="ln4422">    n = clr_history(get_histtype(str, strlen(str), false));</a>
<a name="ln4423">  } else if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln4424">    // index given: remove that entry</a>
<a name="ln4425">    n = del_history_idx(get_histtype(str, strlen(str), false),</a>
<a name="ln4426">                        (int)tv_get_number(&amp;argvars[1]));</a>
<a name="ln4427">  } else {</a>
<a name="ln4428">    // string given: remove all matching entries</a>
<a name="ln4429">    char buf[NUMBUFLEN];</a>
<a name="ln4430">    n = del_history_entry(get_histtype(str, strlen(str), false),</a>
<a name="ln4431">                          (char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln4432">  }</a>
<a name="ln4433">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4434">}</a>
<a name="ln4435"> </a>
<a name="ln4436">/*</a>
<a name="ln4437"> * &quot;histget()&quot; function</a>
<a name="ln4438"> */</a>
<a name="ln4439">static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4440">{</a>
<a name="ln4441">  HistoryType type;</a>
<a name="ln4442">  int idx;</a>
<a name="ln4443"> </a>
<a name="ln4444">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4445">  if (str == NULL) {</a>
<a name="ln4446">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4447">  } else {</a>
<a name="ln4448">    type = get_histtype(str, strlen(str), false);</a>
<a name="ln4449">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4450">      idx = get_history_idx(type);</a>
<a name="ln4451">    } else {</a>
<a name="ln4452">      idx = (int)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln4453">    }</a>
<a name="ln4454">    // -1 on type error</a>
<a name="ln4455">    rettv-&gt;vval.v_string = vim_strsave(get_history_entry(type, idx));</a>
<a name="ln4456">  }</a>
<a name="ln4457">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4458">}</a>
<a name="ln4459"> </a>
<a name="ln4460">/*</a>
<a name="ln4461"> * &quot;histnr()&quot; function</a>
<a name="ln4462"> */</a>
<a name="ln4463">static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4464">{</a>
<a name="ln4465">  const char *const history = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln4466">  HistoryType i = history == NULL</a>
<a name="ln4467">    ? HIST_INVALID</a>
<a name="ln4468">    : get_histtype(history, strlen(history), false);</a>
<a name="ln4469">  if (i != HIST_INVALID) {</a>
<a name="ln4470">    i = get_history_idx(i);</a>
<a name="ln4471">  }</a>
<a name="ln4472">  rettv-&gt;vval.v_number = i;</a>
<a name="ln4473">}</a>
<a name="ln4474"> </a>
<a name="ln4475">/*</a>
<a name="ln4476"> * &quot;highlightID(name)&quot; function</a>
<a name="ln4477"> */</a>
<a name="ln4478">static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4479">{</a>
<a name="ln4480">  rettv-&gt;vval.v_number = syn_name2id(</a>
<a name="ln4481">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4482">}</a>
<a name="ln4483"> </a>
<a name="ln4484">/*</a>
<a name="ln4485"> * &quot;highlight_exists()&quot; function</a>
<a name="ln4486"> */</a>
<a name="ln4487">static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4488">{</a>
<a name="ln4489">  rettv-&gt;vval.v_number = highlight_exists(</a>
<a name="ln4490">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4491">}</a>
<a name="ln4492"> </a>
<a name="ln4493">/*</a>
<a name="ln4494"> * &quot;hostname()&quot; function</a>
<a name="ln4495"> */</a>
<a name="ln4496">static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4497">{</a>
<a name="ln4498">  char hostname[256];</a>
<a name="ln4499"> </a>
<a name="ln4500">  os_get_hostname(hostname, 256);</a>
<a name="ln4501">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4502">  rettv-&gt;vval.v_string = vim_strsave((char_u *)hostname);</a>
<a name="ln4503">}</a>
<a name="ln4504"> </a>
<a name="ln4505">/*</a>
<a name="ln4506"> * iconv() function</a>
<a name="ln4507"> */</a>
<a name="ln4508">static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4509">{</a>
<a name="ln4510">  vimconv_T vimconv;</a>
<a name="ln4511"> </a>
<a name="ln4512">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4513">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4514"> </a>
<a name="ln4515">  const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4516">  char buf1[NUMBUFLEN];</a>
<a name="ln4517">  char_u *const from = enc_canonize(enc_skip(</a>
<a name="ln4518">      (char_u *)tv_get_string_buf(&amp;argvars[1], buf1)));</a>
<a name="ln4519">  char buf2[NUMBUFLEN];</a>
<a name="ln4520">  char_u *const to = enc_canonize(enc_skip(</a>
<a name="ln4521">      (char_u *)tv_get_string_buf(&amp;argvars[2], buf2)));</a>
<a name="ln4522">  vimconv.vc_type = CONV_NONE;</a>
<a name="ln4523">  convert_setup(&amp;vimconv, from, to);</a>
<a name="ln4524"> </a>
<a name="ln4525">  // If the encodings are equal, no conversion needed.</a>
<a name="ln4526">  if (vimconv.vc_type == CONV_NONE) {</a>
<a name="ln4527">    rettv-&gt;vval.v_string = (char_u *)xstrdup(str);</a>
<a name="ln4528">  } else {</a>
<a name="ln4529">    rettv-&gt;vval.v_string = string_convert(&amp;vimconv, (char_u *)str, NULL);</a>
<a name="ln4530">  }</a>
<a name="ln4531"> </a>
<a name="ln4532">  convert_setup(&amp;vimconv, NULL, NULL);</a>
<a name="ln4533">  xfree(from);</a>
<a name="ln4534">  xfree(to);</a>
<a name="ln4535">}</a>
<a name="ln4536"> </a>
<a name="ln4537">/*</a>
<a name="ln4538"> * &quot;indent()&quot; function</a>
<a name="ln4539"> */</a>
<a name="ln4540">static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4541">{</a>
<a name="ln4542">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln4543">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4544">    rettv-&gt;vval.v_number = get_indent_lnum(lnum);</a>
<a name="ln4545">  } else {</a>
<a name="ln4546">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4547">  }</a>
<a name="ln4548">}</a>
<a name="ln4549"> </a>
<a name="ln4550">/*</a>
<a name="ln4551"> * &quot;index()&quot; function</a>
<a name="ln4552"> */</a>
<a name="ln4553">static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4554">{</a>
<a name="ln4555">  long idx = 0;</a>
<a name="ln4556">  bool ic = false;</a>
<a name="ln4557"> </a>
<a name="ln4558">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4559">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4560">    EMSG(_(e_listreq));</a>
<a name="ln4561">    return;</a>
<a name="ln4562">  }</a>
<a name="ln4563">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln4564">  if (l != NULL) {</a>
<a name="ln4565">    listitem_T *item = tv_list_first(l);</a>
<a name="ln4566">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4567">      bool error = false;</a>
<a name="ln4568"> </a>
<a name="ln4569">      // Start at specified item.</a>
<a name="ln4570">      idx = tv_list_uidx(l, tv_get_number_chk(&amp;argvars[2], &amp;error));</a>
<a name="ln4571">      if (error || idx == -1) {</a>
<a name="ln4572">        item = NULL;</a>
<a name="ln4573">      } else {</a>
<a name="ln4574">        item = tv_list_find(l, idx);</a>
<a name="ln4575">        assert(item != NULL);</a>
<a name="ln4576">      }</a>
<a name="ln4577">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4578">        ic = !!tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln4579">        if (error) {</a>
<a name="ln4580">          item = NULL;</a>
<a name="ln4581">        }</a>
<a name="ln4582">      }</a>
<a name="ln4583">    }</a>
<a name="ln4584"> </a>
<a name="ln4585">    for (; item != NULL; item = TV_LIST_ITEM_NEXT(l, item), idx++) {</a>
<a name="ln4586">      if (tv_equal(TV_LIST_ITEM_TV(item), &amp;argvars[1], ic, false)) {</a>
<a name="ln4587">        rettv-&gt;vval.v_number = idx;</a>
<a name="ln4588">        break;</a>
<a name="ln4589">      }</a>
<a name="ln4590">    }</a>
<a name="ln4591">  }</a>
<a name="ln4592">}</a>
<a name="ln4593"> </a>
<a name="ln4594">static bool inputsecret_flag = false;</a>
<a name="ln4595"> </a>
<a name="ln4596">/*</a>
<a name="ln4597"> * &quot;input()&quot; function</a>
<a name="ln4598"> *     Also handles inputsecret() when inputsecret is set.</a>
<a name="ln4599"> */</a>
<a name="ln4600">static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4601">{</a>
<a name="ln4602">  get_user_input(argvars, rettv, FALSE, inputsecret_flag);</a>
<a name="ln4603">}</a>
<a name="ln4604"> </a>
<a name="ln4605">/*</a>
<a name="ln4606"> * &quot;inputdialog()&quot; function</a>
<a name="ln4607"> */</a>
<a name="ln4608">static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4609">{</a>
<a name="ln4610">  get_user_input(argvars, rettv, TRUE, inputsecret_flag);</a>
<a name="ln4611">}</a>
<a name="ln4612"> </a>
<a name="ln4613">/*</a>
<a name="ln4614"> * &quot;inputlist()&quot; function</a>
<a name="ln4615"> */</a>
<a name="ln4616">static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4617">{</a>
<a name="ln4618">  int selected;</a>
<a name="ln4619">  int mouse_used;</a>
<a name="ln4620"> </a>
<a name="ln4621">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4622">    EMSG2(_(e_listarg), &quot;inputlist()&quot;);</a>
<a name="ln4623">    return;</a>
<a name="ln4624">  }</a>
<a name="ln4625"> </a>
<a name="ln4626">  msg_start();</a>
<a name="ln4627">  msg_row = Rows - 1;   // for when 'cmdheight' &gt; 1</a>
<a name="ln4628">  lines_left = Rows;    // avoid more prompt</a>
<a name="ln4629">  msg_scroll = true;</a>
<a name="ln4630">  msg_clr_eos();</a>
<a name="ln4631"> </a>
<a name="ln4632">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln4633">    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4634">    msg_putchar('\n');</a>
<a name="ln4635">  });</a>
<a name="ln4636"> </a>
<a name="ln4637">  // Ask for choice.</a>
<a name="ln4638">  selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln4639">  if (mouse_used) {</a>
<a name="ln4640">    selected -= lines_left;</a>
<a name="ln4641">  }</a>
<a name="ln4642"> </a>
<a name="ln4643">  rettv-&gt;vval.v_number = selected;</a>
<a name="ln4644">}</a>
<a name="ln4645"> </a>
<a name="ln4646"> </a>
<a name="ln4647">static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, NULL };</a>
<a name="ln4648"> </a>
<a name="ln4649">/// &quot;inputrestore()&quot; function</a>
<a name="ln4650">static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4651">{</a>
<a name="ln4652">  if (!GA_EMPTY(&amp;ga_userinput)) {</a>
<a name="ln4653">    ga_userinput.ga_len--;</a>
<a name="ln4654">    restore_typeahead((tasave_T *)(ga_userinput.ga_data)</a>
<a name="ln4655">                      + ga_userinput.ga_len);</a>
<a name="ln4656">    // default return is zero == OK</a>
<a name="ln4657">  } else if (p_verbose &gt; 1) {</a>
<a name="ln4658">    verb_msg(_(&quot;called inputrestore() more often than inputsave()&quot;));</a>
<a name="ln4659">    rettv-&gt;vval.v_number = 1;  // Failed</a>
<a name="ln4660">  }</a>
<a name="ln4661">}</a>
<a name="ln4662"> </a>
<a name="ln4663">/// &quot;inputsave()&quot; function</a>
<a name="ln4664">static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4665">{</a>
<a name="ln4666">  // Add an entry to the stack of typeahead storage.</a>
<a name="ln4667">  tasave_T *p = GA_APPEND_VIA_PTR(tasave_T, &amp;ga_userinput);</a>
<a name="ln4668">  save_typeahead(p);</a>
<a name="ln4669">}</a>
<a name="ln4670"> </a>
<a name="ln4671">/// &quot;inputsecret()&quot; function</a>
<a name="ln4672">static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4673">{</a>
<a name="ln4674">  cmdline_star++;</a>
<a name="ln4675">  inputsecret_flag = true;</a>
<a name="ln4676">  f_input(argvars, rettv, NULL);</a>
<a name="ln4677">  cmdline_star--;</a>
<a name="ln4678">  inputsecret_flag = false;</a>
<a name="ln4679">}</a>
<a name="ln4680"> </a>
<a name="ln4681">/*</a>
<a name="ln4682"> * &quot;insert()&quot; function</a>
<a name="ln4683"> */</a>
<a name="ln4684">static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4685">{</a>
<a name="ln4686">  list_T *l;</a>
<a name="ln4687">  bool error = false;</a>
<a name="ln4688"> </a>
<a name="ln4689">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4690">    EMSG2(_(e_listarg), &quot;insert()&quot;);</a>
<a name="ln4691">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln4692">                            N_(&quot;insert() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln4693">    long before = 0;</a>
<a name="ln4694">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4695">      before = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln4696">    }</a>
<a name="ln4697">    if (error) {</a>
<a name="ln4698">      // type error; errmsg already given</a>
<a name="ln4699">      return;</a>
<a name="ln4700">    }</a>
<a name="ln4701"> </a>
<a name="ln4702">    listitem_T *item = NULL;</a>
<a name="ln4703">    if (before != tv_list_len(l)) {</a>
<a name="ln4704">      item = tv_list_find(l, before);</a>
<a name="ln4705">      if (item == NULL) {</a>
<a name="ln4706">        EMSGN(_(e_listidx), before);</a>
<a name="ln4707">        l = NULL;</a>
<a name="ln4708">      }</a>
<a name="ln4709">    }</a>
<a name="ln4710">    if (l != NULL) {</a>
<a name="ln4711">      tv_list_insert_tv(l, &amp;argvars[1], item);</a>
<a name="ln4712">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln4713">    }</a>
<a name="ln4714">  }</a>
<a name="ln4715">}</a>
<a name="ln4716"> </a>
<a name="ln4717">// &quot;interrupt()&quot; function</a>
<a name="ln4718">static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED,</a>
<a name="ln4719">                        typval_T *rettv FUNC_ATTR_UNUSED,</a>
<a name="ln4720">                        FunPtr fptr FUNC_ATTR_UNUSED)</a>
<a name="ln4721">{</a>
<a name="ln4722">  got_int = true;</a>
<a name="ln4723">}</a>
<a name="ln4724"> </a>
<a name="ln4725">/*</a>
<a name="ln4726"> * &quot;invert(expr)&quot; function</a>
<a name="ln4727"> */</a>
<a name="ln4728">static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4729">{</a>
<a name="ln4730">  rettv-&gt;vval.v_number = ~tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln4731">}</a>
<a name="ln4732"> </a>
<a name="ln4733">/*</a>
<a name="ln4734"> * &quot;isdirectory()&quot; function</a>
<a name="ln4735"> */</a>
<a name="ln4736">static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4737">{</a>
<a name="ln4738">  rettv-&gt;vval.v_number = os_isdir((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4739">}</a>
<a name="ln4740"> </a>
<a name="ln4741">/*</a>
<a name="ln4742"> * &quot;islocked()&quot; function</a>
<a name="ln4743"> */</a>
<a name="ln4744">static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4745">{</a>
<a name="ln4746">  lval_T lv;</a>
<a name="ln4747">  dictitem_T  *di;</a>
<a name="ln4748"> </a>
<a name="ln4749">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4750">  const char_u *const end = get_lval((char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln4751">                                     NULL,</a>
<a name="ln4752">                                     &amp;lv, false, false,</a>
<a name="ln4753">                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,</a>
<a name="ln4754">                                     FNE_CHECK_START);</a>
<a name="ln4755">  if (end != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln4756">    if (*end != NUL) {</a>
<a name="ln4757">      EMSG(_(e_trailing));</a>
<a name="ln4758">    } else {</a>
<a name="ln4759">      if (lv.ll_tv == NULL) {</a>
<a name="ln4760">        di = find_var((const char *)lv.ll_name, lv.ll_name_len, NULL, true);</a>
<a name="ln4761">        if (di != NULL) {</a>
<a name="ln4762">          // Consider a variable locked when:</a>
<a name="ln4763">          // 1. the variable itself is locked</a>
<a name="ln4764">          // 2. the value of the variable is locked.</a>
<a name="ln4765">          // 3. the List or Dict value is locked.</a>
<a name="ln4766">          rettv-&gt;vval.v_number = ((di-&gt;di_flags &amp; DI_FLAGS_LOCK)</a>
<a name="ln4767">                                  || tv_islocked(&amp;di-&gt;di_tv));</a>
<a name="ln4768">        }</a>
<a name="ln4769">      } else if (lv.ll_range) {</a>
<a name="ln4770">        EMSG(_(&quot;E786: Range not allowed&quot;));</a>
<a name="ln4771">      } else if (lv.ll_newkey != NULL) {</a>
<a name="ln4772">        EMSG2(_(e_dictkey), lv.ll_newkey);</a>
<a name="ln4773">      } else if (lv.ll_list != NULL) {</a>
<a name="ln4774">        // List item.</a>
<a name="ln4775">        rettv-&gt;vval.v_number = tv_islocked(TV_LIST_ITEM_TV(lv.ll_li));</a>
<a name="ln4776">      } else {</a>
<a name="ln4777">        // Dictionary item.</a>
<a name="ln4778">        rettv-&gt;vval.v_number = tv_islocked(&amp;lv.ll_di-&gt;di_tv);</a>
<a name="ln4779">      }</a>
<a name="ln4780">    }</a>
<a name="ln4781">  }</a>
<a name="ln4782"> </a>
<a name="ln4783">  clear_lval(&amp;lv);</a>
<a name="ln4784">}</a>
<a name="ln4785"> </a>
<a name="ln4786">// &quot;isinf()&quot; function</a>
<a name="ln4787">static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4788">{</a>
<a name="ln4789">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4790">      &amp;&amp; xisinf(argvars[0].vval.v_float)) {</a>
<a name="ln4791">    rettv-&gt;vval.v_number = argvars[0].vval.v_float &gt; 0.0 ? 1 : -1;</a>
<a name="ln4792">  }</a>
<a name="ln4793">}</a>
<a name="ln4794"> </a>
<a name="ln4795">// &quot;isnan()&quot; function</a>
<a name="ln4796">static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4797">{</a>
<a name="ln4798">  rettv-&gt;vval.v_number = argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4799">    &amp;&amp; xisnan(argvars[0].vval.v_float);</a>
<a name="ln4800">}</a>
<a name="ln4801"> </a>
<a name="ln4802">/// &quot;id()&quot; function</a>
<a name="ln4803">static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4804">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4805">{</a>
<a name="ln4806">  const int len = vim_vsnprintf_typval(NULL, 0, &quot;%p&quot;, dummy_ap, argvars);</a>
<a name="ln4807">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4808">  rettv-&gt;vval.v_string = xmalloc(len + 1);</a>
<a name="ln4809">  vim_vsnprintf_typval((char *)rettv-&gt;vval.v_string, len + 1, &quot;%p&quot;,</a>
<a name="ln4810">                       dummy_ap, argvars);</a>
<a name="ln4811">}</a>
<a name="ln4812"> </a>
<a name="ln4813">/*</a>
<a name="ln4814"> * &quot;items(dict)&quot; function</a>
<a name="ln4815"> */</a>
<a name="ln4816">static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4817">{</a>
<a name="ln4818">  dict_list(argvars, rettv, 2);</a>
<a name="ln4819">}</a>
<a name="ln4820"> </a>
<a name="ln4821">// &quot;jobpid(id)&quot; function</a>
<a name="ln4822">static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4823">{</a>
<a name="ln4824">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4825">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4826"> </a>
<a name="ln4827">  if (check_secure()) {</a>
<a name="ln4828">    return;</a>
<a name="ln4829">  }</a>
<a name="ln4830"> </a>
<a name="ln4831">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4832">    EMSG(_(e_invarg));</a>
<a name="ln4833">    return;</a>
<a name="ln4834">  }</a>
<a name="ln4835"> </a>
<a name="ln4836">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4837">  if (!data) {</a>
<a name="ln4838">    return;</a>
<a name="ln4839">  }</a>
<a name="ln4840"> </a>
<a name="ln4841">  Process *proc = (Process *)&amp;data-&gt;stream.proc;</a>
<a name="ln4842">  rettv-&gt;vval.v_number = proc-&gt;pid;</a>
<a name="ln4843">}</a>
<a name="ln4844"> </a>
<a name="ln4845">// &quot;jobresize(job, width, height)&quot; function</a>
<a name="ln4846">static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4847">{</a>
<a name="ln4848">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4849">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4850"> </a>
<a name="ln4851">  if (check_secure()) {</a>
<a name="ln4852">    return;</a>
<a name="ln4853">  }</a>
<a name="ln4854"> </a>
<a name="ln4855">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln4856">      || argvars[2].v_type != VAR_NUMBER) {</a>
<a name="ln4857">    // job id, width, height</a>
<a name="ln4858">    EMSG(_(e_invarg));</a>
<a name="ln4859">    return;</a>
<a name="ln4860">  }</a>
<a name="ln4861"> </a>
<a name="ln4862"> </a>
<a name="ln4863">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4864">  if (!data) {</a>
<a name="ln4865">    return;</a>
<a name="ln4866">  }</a>
<a name="ln4867"> </a>
<a name="ln4868">  if (data-&gt;stream.proc.type != kProcessTypePty) {</a>
<a name="ln4869">    EMSG(_(e_channotpty));</a>
<a name="ln4870">    return;</a>
<a name="ln4871">  }</a>
<a name="ln4872"> </a>
<a name="ln4873">  pty_process_resize(&amp;data-&gt;stream.pty, argvars[1].vval.v_number,</a>
<a name="ln4874">                     argvars[2].vval.v_number);</a>
<a name="ln4875">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln4876">}</a>
<a name="ln4877"> </a>
<a name="ln4878">// &quot;jobstart()&quot; function</a>
<a name="ln4879">static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4880">{</a>
<a name="ln4881">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4882">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4883"> </a>
<a name="ln4884">  if (check_secure()) {</a>
<a name="ln4885">    return;</a>
<a name="ln4886">  }</a>
<a name="ln4887"> </a>
<a name="ln4888">  bool executable = true;</a>
<a name="ln4889">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln4890">  char **env = NULL;</a>
<a name="ln4891">  if (!argv) {</a>
<a name="ln4892">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln4893">    return;  // Did error message in tv_to_argv.</a>
<a name="ln4894">  }</a>
<a name="ln4895"> </a>
<a name="ln4896">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4897">    // Wrong argument types</a>
<a name="ln4898">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln4899">    shell_free_argv(argv);</a>
<a name="ln4900">    return;</a>
<a name="ln4901">  }</a>
<a name="ln4902"> </a>
<a name="ln4903"> </a>
<a name="ln4904">  dict_T *job_opts = NULL;</a>
<a name="ln4905">  bool detach = false;</a>
<a name="ln4906">  bool rpc = false;</a>
<a name="ln4907">  bool pty = false;</a>
<a name="ln4908">  bool clear_env = false;</a>
<a name="ln4909">  bool overlapped = false;</a>
<a name="ln4910">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln4911">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln4912">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln4913">  char *cwd = NULL;</a>
<a name="ln4914">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln4915">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln4916"> </a>
<a name="ln4917">    detach = tv_dict_get_number(job_opts, &quot;detach&quot;) != 0;</a>
<a name="ln4918">    rpc = tv_dict_get_number(job_opts, &quot;rpc&quot;) != 0;</a>
<a name="ln4919">    pty = tv_dict_get_number(job_opts, &quot;pty&quot;) != 0;</a>
<a name="ln4920">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln4921">    overlapped = tv_dict_get_number(job_opts, &quot;overlapped&quot;) != 0;</a>
<a name="ln4922"> </a>
<a name="ln4923">    if (pty &amp;&amp; rpc) {</a>
<a name="ln4924">      EMSG2(_(e_invarg2), &quot;job cannot have both 'pty' and 'rpc' options set&quot;);</a>
<a name="ln4925">      shell_free_argv(argv);</a>
<a name="ln4926">      return;</a>
<a name="ln4927">    }</a>
<a name="ln4928"> </a>
<a name="ln4929">#ifdef WIN32</a>
<a name="ln4930">    if (pty &amp;&amp; overlapped) {</a>
<a name="ln4931">      EMSG2(_(e_invarg2),</a>
<a name="ln4932">            &quot;job cannot have both 'pty' and 'overlapped' options set&quot;);</a>
<a name="ln4933">      shell_free_argv(argv);</a>
<a name="ln4934">      return;</a>
<a name="ln4935">    }</a>
<a name="ln4936">#endif</a>
<a name="ln4937"> </a>
<a name="ln4938">    char *new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln4939">    if (new_cwd &amp;&amp; strlen(new_cwd) &gt; 0) {</a>
<a name="ln4940">      cwd = new_cwd;</a>
<a name="ln4941">      // The new cwd must be a directory.</a>
<a name="ln4942">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln4943">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln4944">        shell_free_argv(argv);</a>
<a name="ln4945">        return;</a>
<a name="ln4946">      }</a>
<a name="ln4947">    }</a>
<a name="ln4948">    dictitem_T *job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln4949">    if (job_env) {</a>
<a name="ln4950">      if (job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln4951">        EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln4952">        shell_free_argv(argv);</a>
<a name="ln4953">        return;</a>
<a name="ln4954">      }</a>
<a name="ln4955"> </a>
<a name="ln4956">      size_t custom_env_size = (size_t)tv_dict_len(job_env-&gt;di_tv.vval.v_dict);</a>
<a name="ln4957">      size_t i = 0;</a>
<a name="ln4958">      size_t env_size = 0;</a>
<a name="ln4959"> </a>
<a name="ln4960">      if (clear_env) {</a>
<a name="ln4961">        // + 1 for last null entry</a>
<a name="ln4962">        env = xmalloc((custom_env_size + 1) * sizeof(*env));</a>
<a name="ln4963">        env_size = 0;</a>
<a name="ln4964">      } else {</a>
<a name="ln4965">        env_size = os_get_fullenv_size();</a>
<a name="ln4966"> </a>
<a name="ln4967">        env = xmalloc((custom_env_size + env_size + 1) * sizeof(*env));</a>
<a name="ln4968"> </a>
<a name="ln4969">        os_copy_fullenv(env, env_size);</a>
<a name="ln4970">        i = env_size;</a>
<a name="ln4971">      }</a>
<a name="ln4972">      assert(env);  // env must be allocated at this point</a>
<a name="ln4973"> </a>
<a name="ln4974">      TV_DICT_ITER(job_env-&gt;di_tv.vval.v_dict, var, {</a>
<a name="ln4975">        const char *str = tv_get_string(&amp;var-&gt;di_tv);</a>
<a name="ln4976">        assert(str);</a>
<a name="ln4977">        size_t len = STRLEN(var-&gt;di_key) + strlen(str) + strlen(&quot;=&quot;) + 1;</a>
<a name="ln4978">        env[i] = xmalloc(len);</a>
<a name="ln4979">        snprintf(env[i], len, &quot;%s=%s&quot;, (char *)var-&gt;di_key, str);</a>
<a name="ln4980">        i++;</a>
<a name="ln4981">      });</a>
<a name="ln4982"> </a>
<a name="ln4983">      // must be null terminated</a>
<a name="ln4984">      env[env_size + custom_env_size] = NULL;</a>
<a name="ln4985">    }</a>
<a name="ln4986"> </a>
<a name="ln4987"> </a>
<a name="ln4988">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln4989">      shell_free_argv(argv);</a>
<a name="ln4990">      return;</a>
<a name="ln4991">    }</a>
<a name="ln4992">  }</a>
<a name="ln4993"> </a>
<a name="ln4994">  uint16_t width = 0, height = 0;</a>
<a name="ln4995">  char *term_name = NULL;</a>
<a name="ln4996"> </a>
<a name="ln4997">  if (pty) {</a>
<a name="ln4998">    width = (uint16_t)tv_dict_get_number(job_opts, &quot;width&quot;);</a>
<a name="ln4999">    height = (uint16_t)tv_dict_get_number(job_opts, &quot;height&quot;);</a>
<a name="ln5000">    term_name = tv_dict_get_string(job_opts, &quot;TERM&quot;, true);</a>
<a name="ln5001">  }</a>
<a name="ln5002"> </a>
<a name="ln5003">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,</a>
<a name="ln5004">                                    rpc, overlapped, detach, cwd, width, height,</a>
<a name="ln5005">                                    term_name, env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln5006">  if (chan) {</a>
<a name="ln5007">    channel_create_event(chan, NULL);</a>
<a name="ln5008">  }</a>
<a name="ln5009">}</a>
<a name="ln5010"> </a>
<a name="ln5011">// &quot;jobstop()&quot; function</a>
<a name="ln5012">static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5013">{</a>
<a name="ln5014">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5015">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5016"> </a>
<a name="ln5017">  if (check_secure()) {</a>
<a name="ln5018">    return;</a>
<a name="ln5019">  }</a>
<a name="ln5020"> </a>
<a name="ln5021">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln5022">    // Only argument is the job id</a>
<a name="ln5023">    EMSG(_(e_invarg));</a>
<a name="ln5024">    return;</a>
<a name="ln5025">  }</a>
<a name="ln5026"> </a>
<a name="ln5027">  Channel *data = find_job(argvars[0].vval.v_number, false);</a>
<a name="ln5028">  if (!data) {</a>
<a name="ln5029">    return;</a>
<a name="ln5030">  }</a>
<a name="ln5031"> </a>
<a name="ln5032">  const char *error = NULL;</a>
<a name="ln5033">  if (data-&gt;is_rpc) {</a>
<a name="ln5034">    // Ignore return code, but show error later.</a>
<a name="ln5035">    (void)channel_close(data-&gt;id, kChannelPartRpc, &amp;error);</a>
<a name="ln5036">  }</a>
<a name="ln5037">  process_stop((Process *)&amp;data-&gt;stream.proc);</a>
<a name="ln5038">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5039">  if (error) {</a>
<a name="ln5040">    EMSG(error);</a>
<a name="ln5041">  }</a>
<a name="ln5042">}</a>
<a name="ln5043"> </a>
<a name="ln5044">// &quot;jobwait(ids[, timeout])&quot; function</a>
<a name="ln5045">static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5046">{</a>
<a name="ln5047">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5048">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5049"> </a>
<a name="ln5050">  if (check_secure()) {</a>
<a name="ln5051">    return;</a>
<a name="ln5052">  }</a>
<a name="ln5053">  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5054">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln5055">    EMSG(_(e_invarg));</a>
<a name="ln5056">    return;</a>
<a name="ln5057">  }</a>
<a name="ln5058"> </a>
<a name="ln5059">  ui_busy_start();</a>
<a name="ln5060">  list_T *args = argvars[0].vval.v_list;</a>
<a name="ln5061">  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));</a>
<a name="ln5062">  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &amp;main_loop);</a>
<a name="ln5063"> </a>
<a name="ln5064">  // Validate, prepare jobs for waiting.</a>
<a name="ln5065">  int i = 0;</a>
<a name="ln5066">  TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln5067">    Channel *chan = NULL;</a>
<a name="ln5068">    if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_NUMBER</a>
<a name="ln5069">        || !(chan = find_job(TV_LIST_ITEM_TV(arg)-&gt;vval.v_number, false))) {</a>
<a name="ln5070">      jobs[i] = NULL;  // Invalid job.</a>
<a name="ln5071">    } else {</a>
<a name="ln5072">      jobs[i] = chan;</a>
<a name="ln5073">      channel_incref(chan);</a>
<a name="ln5074">      if (chan-&gt;stream.proc.status &lt; 0) {</a>
<a name="ln5075">        // Process any pending events on the job's queue before temporarily</a>
<a name="ln5076">        // replacing it.</a>
<a name="ln5077">        multiqueue_process_events(chan-&gt;events);</a>
<a name="ln5078">        multiqueue_replace_parent(chan-&gt;events, waiting_jobs);</a>
<a name="ln5079">      }</a>
<a name="ln5080">    }</a>
<a name="ln5081">    i++;</a>
<a name="ln5082">  });</a>
<a name="ln5083"> </a>
<a name="ln5084">  int remaining = -1;</a>
<a name="ln5085">  uint64_t before = 0;</a>
<a name="ln5086">  if (argvars[1].v_type == VAR_NUMBER &amp;&amp; argvars[1].vval.v_number &gt;= 0) {</a>
<a name="ln5087">    remaining = argvars[1].vval.v_number;</a>
<a name="ln5088">    before = os_hrtime();</a>
<a name="ln5089">  }</a>
<a name="ln5090"> </a>
<a name="ln5091">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5092">    if (remaining == 0) {</a>
<a name="ln5093">      break;  // Timeout.</a>
<a name="ln5094">    }</a>
<a name="ln5095">    if (jobs[i] == NULL) {</a>
<a name="ln5096">      continue;  // Invalid job, will assign status=-3 below.</a>
<a name="ln5097">    }</a>
<a name="ln5098">    int status = process_wait(&amp;jobs[i]-&gt;stream.proc, remaining,</a>
<a name="ln5099">                              waiting_jobs);</a>
<a name="ln5100">    if (status &lt; 0) {</a>
<a name="ln5101">      break;  // Interrupted (CTRL-C) or timeout, skip remaining jobs.</a>
<a name="ln5102">    }</a>
<a name="ln5103">    if (remaining &gt; 0) {</a>
<a name="ln5104">      uint64_t now = os_hrtime();</a>
<a name="ln5105">      remaining = MIN(0, remaining - (int)((now - before) / 1000000));</a>
<a name="ln5106">      before = now;</a>
<a name="ln5107">    }</a>
<a name="ln5108">  }</a>
<a name="ln5109"> </a>
<a name="ln5110">  list_T *const rv = tv_list_alloc(tv_list_len(args));</a>
<a name="ln5111"> </a>
<a name="ln5112">  // For each job:</a>
<a name="ln5113">  //  * Restore its parent queue if the job is still alive.</a>
<a name="ln5114">  //  * Append its status to the output list, or:</a>
<a name="ln5115">  //       -3 for &quot;invalid job id&quot;</a>
<a name="ln5116">  //       -2 for &quot;interrupted&quot; (user hit CTRL-C)</a>
<a name="ln5117">  //       -1 for jobs that were skipped or timed out</a>
<a name="ln5118">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5119">    if (jobs[i] == NULL) {</a>
<a name="ln5120">      tv_list_append_number(rv, -3);</a>
<a name="ln5121">      continue;</a>
<a name="ln5122">    }</a>
<a name="ln5123">    multiqueue_process_events(jobs[i]-&gt;events);</a>
<a name="ln5124">    multiqueue_replace_parent(jobs[i]-&gt;events, main_loop.events);</a>
<a name="ln5125"> </a>
<a name="ln5126">    tv_list_append_number(rv, jobs[i]-&gt;stream.proc.status);</a>
<a name="ln5127">    channel_decref(jobs[i]);</a>
<a name="ln5128">  }</a>
<a name="ln5129"> </a>
<a name="ln5130">  multiqueue_free(waiting_jobs);</a>
<a name="ln5131">  xfree(jobs);</a>
<a name="ln5132">  ui_busy_stop();</a>
<a name="ln5133">  tv_list_ref(rv);</a>
<a name="ln5134">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5135">  rettv-&gt;vval.v_list = rv;</a>
<a name="ln5136">}</a>
<a name="ln5137"> </a>
<a name="ln5138">/*</a>
<a name="ln5139"> * &quot;join()&quot; function</a>
<a name="ln5140"> */</a>
<a name="ln5141">static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5142">{</a>
<a name="ln5143">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5144">    EMSG(_(e_listreq));</a>
<a name="ln5145">    return;</a>
<a name="ln5146">  }</a>
<a name="ln5147">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln5148">                           ? &quot; &quot;</a>
<a name="ln5149">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln5150"> </a>
<a name="ln5151">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5152"> </a>
<a name="ln5153">  if (sep != NULL) {</a>
<a name="ln5154">    garray_T ga;</a>
<a name="ln5155">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5156">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln5157">    ga_append(&amp;ga, NUL);</a>
<a name="ln5158">    rettv-&gt;vval.v_string = (char_u *)ga.ga_data;</a>
<a name="ln5159">  } else {</a>
<a name="ln5160">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5161">  }</a>
<a name="ln5162">}</a>
<a name="ln5163"> </a>
<a name="ln5164">/// json_decode() function</a>
<a name="ln5165">static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5166">{</a>
<a name="ln5167">  char numbuf[NUMBUFLEN];</a>
<a name="ln5168">  const char *s = NULL;</a>
<a name="ln5169">  char *tofree = NULL;</a>
<a name="ln5170">  size_t len;</a>
<a name="ln5171">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5172">    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &amp;len, &amp;tofree)) {</a>
<a name="ln5173">      EMSG(_(&quot;E474: Failed to convert list to string&quot;));</a>
<a name="ln5174">      return;</a>
<a name="ln5175">    }</a>
<a name="ln5176">    s = tofree;</a>
<a name="ln5177">    if (s == NULL) {</a>
<a name="ln5178">      assert(len == 0);</a>
<a name="ln5179">      s = &quot;&quot;;</a>
<a name="ln5180">    }</a>
<a name="ln5181">  } else {</a>
<a name="ln5182">    s = tv_get_string_buf_chk(&amp;argvars[0], numbuf);</a>
<a name="ln5183">    if (s) {</a>
<a name="ln5184">      len = strlen(s);</a>
<a name="ln5185">    } else {</a>
<a name="ln5186">      return;</a>
<a name="ln5187">    }</a>
<a name="ln5188">  }</a>
<a name="ln5189">  if (json_decode_string(s, len, rettv) == FAIL) {</a>
<a name="ln5190">    emsgf(_(&quot;E474: Failed to parse %.*s&quot;), (int)len, s);</a>
<a name="ln5191">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5192">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln5193">  }</a>
<a name="ln5194">  assert(rettv-&gt;v_type != VAR_UNKNOWN);</a>
<a name="ln5195">  xfree(tofree);</a>
<a name="ln5196">}</a>
<a name="ln5197"> </a>
<a name="ln5198">/// json_encode() function</a>
<a name="ln5199">static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5200">{</a>
<a name="ln5201">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5202">  rettv-&gt;vval.v_string = (char_u *)encode_tv2json(&amp;argvars[0], NULL);</a>
<a name="ln5203">}</a>
<a name="ln5204"> </a>
<a name="ln5205">/*</a>
<a name="ln5206"> * &quot;keys()&quot; function</a>
<a name="ln5207"> */</a>
<a name="ln5208">static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5209">{</a>
<a name="ln5210">  dict_list(argvars, rettv, 0);</a>
<a name="ln5211">}</a>
<a name="ln5212"> </a>
<a name="ln5213">/*</a>
<a name="ln5214"> * &quot;last_buffer_nr()&quot; function.</a>
<a name="ln5215"> */</a>
<a name="ln5216">static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5217">{</a>
<a name="ln5218">  int n = 0;</a>
<a name="ln5219"> </a>
<a name="ln5220">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5221">    if (n &lt; buf-&gt;b_fnum) {</a>
<a name="ln5222">      n = buf-&gt;b_fnum;</a>
<a name="ln5223">    }</a>
<a name="ln5224">  }</a>
<a name="ln5225"> </a>
<a name="ln5226">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5227">}</a>
<a name="ln5228"> </a>
<a name="ln5229">/*</a>
<a name="ln5230"> * &quot;len()&quot; function</a>
<a name="ln5231"> */</a>
<a name="ln5232">static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5233">{</a>
<a name="ln5234">  switch (argvars[0].v_type) {</a>
<a name="ln5235">    case VAR_STRING:</a>
<a name="ln5236">    case VAR_NUMBER: {</a>
<a name="ln5237">      rettv-&gt;vval.v_number = (varnumber_T)strlen(</a>
<a name="ln5238">          tv_get_string(&amp;argvars[0]));</a>
<a name="ln5239">      break;</a>
<a name="ln5240">    }</a>
<a name="ln5241">    case VAR_LIST: {</a>
<a name="ln5242">      rettv-&gt;vval.v_number = tv_list_len(argvars[0].vval.v_list);</a>
<a name="ln5243">      break;</a>
<a name="ln5244">    }</a>
<a name="ln5245">    case VAR_DICT: {</a>
<a name="ln5246">      rettv-&gt;vval.v_number = tv_dict_len(argvars[0].vval.v_dict);</a>
<a name="ln5247">      break;</a>
<a name="ln5248">    }</a>
<a name="ln5249">    case VAR_UNKNOWN:</a>
<a name="ln5250">    case VAR_BOOL:</a>
<a name="ln5251">    case VAR_SPECIAL:</a>
<a name="ln5252">    case VAR_FLOAT:</a>
<a name="ln5253">    case VAR_PARTIAL:</a>
<a name="ln5254">    case VAR_FUNC: {</a>
<a name="ln5255">      EMSG(_(&quot;E701: Invalid type for len()&quot;));</a>
<a name="ln5256">      break;</a>
<a name="ln5257">    }</a>
<a name="ln5258">  }</a>
<a name="ln5259">}</a>
<a name="ln5260"> </a>
<a name="ln5261">static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)</a>
<a name="ln5262">{</a>
<a name="ln5263">  rettv-&gt;v_type = out_type;</a>
<a name="ln5264">  if (out_type != VAR_NUMBER) {</a>
<a name="ln5265">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5266">  }</a>
<a name="ln5267"> </a>
<a name="ln5268">  if (check_secure()) {</a>
<a name="ln5269">    return;</a>
<a name="ln5270">  }</a>
<a name="ln5271"> </a>
<a name="ln5272">  // The first two args (libname and funcname) must be strings</a>
<a name="ln5273">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln5274">    return;</a>
<a name="ln5275">  }</a>
<a name="ln5276"> </a>
<a name="ln5277">  const char *libname = (char *)argvars[0].vval.v_string;</a>
<a name="ln5278">  const char *funcname = (char *)argvars[1].vval.v_string;</a>
<a name="ln5279"> </a>
<a name="ln5280">  VarType in_type = argvars[2].v_type;</a>
<a name="ln5281"> </a>
<a name="ln5282">  // input variables</a>
<a name="ln5283">  char *str_in = (in_type == VAR_STRING)</a>
<a name="ln5284">      ? (char *)argvars[2].vval.v_string : NULL;</a>
<a name="ln5285">  int int_in = argvars[2].vval.v_number;</a>
<a name="ln5286"> </a>
<a name="ln5287">  // output variables</a>
<a name="ln5288">  char **str_out = (out_type == VAR_STRING)</a>
<a name="ln5289">      ? (char **)&amp;rettv-&gt;vval.v_string : NULL;</a>
<a name="ln5290">  int int_out = 0;</a>
<a name="ln5291"> </a>
<a name="ln5292">  bool success = os_libcall(libname, funcname,</a>
<a name="ln5293">                            str_in, int_in,</a>
<a name="ln5294">                            str_out, &amp;int_out);</a>
<a name="ln5295"> </a>
<a name="ln5296">  if (!success) {</a>
<a name="ln5297">    EMSG2(_(e_libcall), funcname);</a>
<a name="ln5298">    return;</a>
<a name="ln5299">  }</a>
<a name="ln5300"> </a>
<a name="ln5301">  if (out_type == VAR_NUMBER) {</a>
<a name="ln5302">     rettv-&gt;vval.v_number = (varnumber_T)int_out;</a>
<a name="ln5303">  }</a>
<a name="ln5304">}</a>
<a name="ln5305"> </a>
<a name="ln5306">/*</a>
<a name="ln5307"> * &quot;libcall()&quot; function</a>
<a name="ln5308"> */</a>
<a name="ln5309">static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5310">{</a>
<a name="ln5311">  libcall_common(argvars, rettv, VAR_STRING);</a>
<a name="ln5312">}</a>
<a name="ln5313"> </a>
<a name="ln5314">/*</a>
<a name="ln5315"> * &quot;libcallnr()&quot; function</a>
<a name="ln5316"> */</a>
<a name="ln5317">static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5318">{</a>
<a name="ln5319">  libcall_common(argvars, rettv, VAR_NUMBER);</a>
<a name="ln5320">}</a>
<a name="ln5321"> </a>
<a name="ln5322">/*</a>
<a name="ln5323"> * &quot;line(string)&quot; function</a>
<a name="ln5324"> */</a>
<a name="ln5325">static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5326">{</a>
<a name="ln5327">  linenr_T lnum = 0;</a>
<a name="ln5328">  pos_T       *fp;</a>
<a name="ln5329">  int fnum;</a>
<a name="ln5330"> </a>
<a name="ln5331">  fp = var2fpos(&amp;argvars[0], TRUE, &amp;fnum);</a>
<a name="ln5332">  if (fp != NULL)</a>
<a name="ln5333">    lnum = fp-&gt;lnum;</a>
<a name="ln5334">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln5335">}</a>
<a name="ln5336"> </a>
<a name="ln5337">/*</a>
<a name="ln5338"> * &quot;line2byte(lnum)&quot; function</a>
<a name="ln5339"> */</a>
<a name="ln5340">static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5341">{</a>
<a name="ln5342">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5343">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5344">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5345">  } else {</a>
<a name="ln5346">    rettv-&gt;vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL, false);</a>
<a name="ln5347">  }</a>
<a name="ln5348">  if (rettv-&gt;vval.v_number &gt;= 0) {</a>
<a name="ln5349">    rettv-&gt;vval.v_number++;</a>
<a name="ln5350">  }</a>
<a name="ln5351">}</a>
<a name="ln5352"> </a>
<a name="ln5353">/*</a>
<a name="ln5354"> * &quot;lispindent(lnum)&quot; function</a>
<a name="ln5355"> */</a>
<a name="ln5356">static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5357">{</a>
<a name="ln5358">  const pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5359">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5360">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5361">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5362">    rettv-&gt;vval.v_number = get_lisp_indent();</a>
<a name="ln5363">    curwin-&gt;w_cursor = pos;</a>
<a name="ln5364">  } else {</a>
<a name="ln5365">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5366">  }</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369">// &quot;list2str()&quot; function</a>
<a name="ln5370">static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5371">{</a>
<a name="ln5372">  garray_T ga;</a>
<a name="ln5373"> </a>
<a name="ln5374">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5375">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5376">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5377">    EMSG(_(e_invarg));</a>
<a name="ln5378">    return;</a>
<a name="ln5379">  }</a>
<a name="ln5380"> </a>
<a name="ln5381">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln5382">  if (l == NULL) {</a>
<a name="ln5383">    return;  // empty list results in empty string</a>
<a name="ln5384">  }</a>
<a name="ln5385"> </a>
<a name="ln5386">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln5387">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5388"> </a>
<a name="ln5389">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln5390">    buf[utf_char2bytes(tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln5391">    ga_concat(&amp;ga, buf);</a>
<a name="ln5392">  });</a>
<a name="ln5393">  ga_append(&amp;ga, NUL);</a>
<a name="ln5394"> </a>
<a name="ln5395">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5396">}</a>
<a name="ln5397"> </a>
<a name="ln5398">/*</a>
<a name="ln5399"> * &quot;localtime()&quot; function</a>
<a name="ln5400"> */</a>
<a name="ln5401">static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5402">{</a>
<a name="ln5403">  rettv-&gt;vval.v_number = (varnumber_T)time(NULL);</a>
<a name="ln5404">}</a>
<a name="ln5405"> </a>
<a name="ln5406"> </a>
<a name="ln5407">static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)</a>
<a name="ln5408">{</a>
<a name="ln5409">  char_u *keys_buf = NULL;</a>
<a name="ln5410">  char_u *rhs;</a>
<a name="ln5411">  int mode;</a>
<a name="ln5412">  int abbr = FALSE;</a>
<a name="ln5413">  int get_dict = FALSE;</a>
<a name="ln5414">  mapblock_T  *mp;</a>
<a name="ln5415">  int buffer_local;</a>
<a name="ln5416"> </a>
<a name="ln5417">  // Return empty string for failure.</a>
<a name="ln5418">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5419">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5420"> </a>
<a name="ln5421">  char_u *keys = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5422">  if (*keys == NUL) {</a>
<a name="ln5423">    return;</a>
<a name="ln5424">  }</a>
<a name="ln5425"> </a>
<a name="ln5426">  char buf[NUMBUFLEN];</a>
<a name="ln5427">  const char *which;</a>
<a name="ln5428">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5429">    which = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5430">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5431">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln5432">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5433">        get_dict = tv_get_number(&amp;argvars[3]);</a>
<a name="ln5434">      }</a>
<a name="ln5435">    }</a>
<a name="ln5436">  } else {</a>
<a name="ln5437">    which = &quot;&quot;;</a>
<a name="ln5438">  }</a>
<a name="ln5439">  if (which == NULL) {</a>
<a name="ln5440">    return;</a>
<a name="ln5441">  }</a>
<a name="ln5442"> </a>
<a name="ln5443">  mode = get_map_mode((char_u **)&amp;which, 0);</a>
<a name="ln5444"> </a>
<a name="ln5445">  keys = replace_termcodes(keys, STRLEN(keys), &amp;keys_buf, true, true, true,</a>
<a name="ln5446">                           CPO_TO_CPO_FLAGS);</a>
<a name="ln5447">  rhs = check_map(keys, mode, exact, false, abbr, &amp;mp, &amp;buffer_local);</a>
<a name="ln5448">  xfree(keys_buf);</a>
<a name="ln5449"> </a>
<a name="ln5450">  if (!get_dict) {</a>
<a name="ln5451">    // Return a string.</a>
<a name="ln5452">    if (rhs != NULL) {</a>
<a name="ln5453">      if (*rhs == NUL) {</a>
<a name="ln5454">        rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;&lt;Nop&gt;&quot;);</a>
<a name="ln5455">      } else {</a>
<a name="ln5456">        rettv-&gt;vval.v_string = (char_u *)str2special_save(</a>
<a name="ln5457">            (char *)rhs, false, false);</a>
<a name="ln5458">      }</a>
<a name="ln5459">    }</a>
<a name="ln5460"> </a>
<a name="ln5461">  } else {</a>
<a name="ln5462">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5463">    if (rhs != NULL) {</a>
<a name="ln5464">      // Return a dictionary.</a>
<a name="ln5465">      mapblock_fill_dict(rettv-&gt;vval.v_dict, mp, buffer_local, true);</a>
<a name="ln5466">    }</a>
<a name="ln5467">  }</a>
<a name="ln5468">}</a>
<a name="ln5469"> </a>
<a name="ln5470">/// luaeval() function implementation</a>
<a name="ln5471">static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5472">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5473">{</a>
<a name="ln5474">  const char *const str = (const char *)tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5475">  if (str == NULL) {</a>
<a name="ln5476">    return;</a>
<a name="ln5477">  }</a>
<a name="ln5478"> </a>
<a name="ln5479">  nlua_typval_eval(cstr_as_string((char *)str), &amp;argvars[1], rettv);</a>
<a name="ln5480">}</a>
<a name="ln5481"> </a>
<a name="ln5482">/*</a>
<a name="ln5483"> * &quot;map()&quot; function</a>
<a name="ln5484"> */</a>
<a name="ln5485">static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5486">{</a>
<a name="ln5487">  filter_map(argvars, rettv, TRUE);</a>
<a name="ln5488">}</a>
<a name="ln5489"> </a>
<a name="ln5490">/*</a>
<a name="ln5491"> * &quot;maparg()&quot; function</a>
<a name="ln5492"> */</a>
<a name="ln5493">static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5494">{</a>
<a name="ln5495">  get_maparg(argvars, rettv, TRUE);</a>
<a name="ln5496">}</a>
<a name="ln5497"> </a>
<a name="ln5498">/*</a>
<a name="ln5499"> * &quot;mapcheck()&quot; function</a>
<a name="ln5500"> */</a>
<a name="ln5501">static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5502">{</a>
<a name="ln5503">  get_maparg(argvars, rettv, FALSE);</a>
<a name="ln5504">}</a>
<a name="ln5505"> </a>
<a name="ln5506"> </a>
<a name="ln5507">static void find_some_match(typval_T *const argvars, typval_T *const rettv,</a>
<a name="ln5508">                            const SomeMatchType type)</a>
<a name="ln5509">{</a>
<a name="ln5510">  char_u      *str = NULL;</a>
<a name="ln5511">  long        len = 0;</a>
<a name="ln5512">  char_u      *expr = NULL;</a>
<a name="ln5513">  regmatch_T regmatch;</a>
<a name="ln5514">  char_u      *save_cpo;</a>
<a name="ln5515">  long start = 0;</a>
<a name="ln5516">  long nth = 1;</a>
<a name="ln5517">  colnr_T startcol = 0;</a>
<a name="ln5518">  bool match = false;</a>
<a name="ln5519">  list_T      *l = NULL;</a>
<a name="ln5520">  listitem_T  *li = NULL;</a>
<a name="ln5521">  long idx = 0;</a>
<a name="ln5522">  char_u      *tofree = NULL;</a>
<a name="ln5523"> </a>
<a name="ln5524">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln5525">  save_cpo = p_cpo;</a>
<a name="ln5526">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5527"> </a>
<a name="ln5528">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5529">  switch (type) {</a>
<a name="ln5530">    // matchlist(): return empty list when there are no matches.</a>
<a name="ln5531">    case kSomeMatchList: {</a>
<a name="ln5532">      tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln5533">      break;</a>
<a name="ln5534">    }</a>
<a name="ln5535">    // matchstrpos(): return [&quot;&quot;, -1, -1, -1]</a>
<a name="ln5536">    case kSomeMatchStrPos: {</a>
<a name="ln5537">      tv_list_alloc_ret(rettv, 4);</a>
<a name="ln5538">      tv_list_append_string(rettv-&gt;vval.v_list, &quot;&quot;, 0);</a>
<a name="ln5539">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5540">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5541">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5542">      break;</a>
<a name="ln5543">    }</a>
<a name="ln5544">    case kSomeMatchStr: {</a>
<a name="ln5545">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5546">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5547">      break;</a>
<a name="ln5548">    }</a>
<a name="ln5549">    case kSomeMatch:</a>
<a name="ln5550">    case kSomeMatchEnd: {</a>
<a name="ln5551">      // Do nothing: zero is default.</a>
<a name="ln5552">      break;</a>
<a name="ln5553">    }</a>
<a name="ln5554">  }</a>
<a name="ln5555"> </a>
<a name="ln5556">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5557">    if ((l = argvars[0].vval.v_list) == NULL) {</a>
<a name="ln5558">      goto theend;</a>
<a name="ln5559">    }</a>
<a name="ln5560">    li = tv_list_first(l);</a>
<a name="ln5561">  } else {</a>
<a name="ln5562">    expr = str = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5563">    len = (long)STRLEN(str);</a>
<a name="ln5564">  }</a>
<a name="ln5565"> </a>
<a name="ln5566">  char patbuf[NUMBUFLEN];</a>
<a name="ln5567">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5568">  if (pat == NULL) {</a>
<a name="ln5569">    goto theend;</a>
<a name="ln5570">  }</a>
<a name="ln5571"> </a>
<a name="ln5572">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5573">    bool error = false;</a>
<a name="ln5574"> </a>
<a name="ln5575">    start = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5576">    if (error) {</a>
<a name="ln5577">      goto theend;</a>
<a name="ln5578">    }</a>
<a name="ln5579">    if (l != NULL) {</a>
<a name="ln5580">      idx = tv_list_uidx(l, start);</a>
<a name="ln5581">      if (idx == -1) {</a>
<a name="ln5582">        goto theend;</a>
<a name="ln5583">      }</a>
<a name="ln5584">      li = tv_list_find(l, idx);</a>
<a name="ln5585">    } else {</a>
<a name="ln5586">      if (start &lt; 0)</a>
<a name="ln5587">        start = 0;</a>
<a name="ln5588">      if (start &gt; len)</a>
<a name="ln5589">        goto theend;</a>
<a name="ln5590">      // When &quot;count&quot; argument is there ignore matches before &quot;start&quot;,</a>
<a name="ln5591">      // otherwise skip part of the string.  Differs when pattern is &quot;^&quot;</a>
<a name="ln5592">      // or &quot;\&lt;&quot;.</a>
<a name="ln5593">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5594">        startcol = start;</a>
<a name="ln5595">      } else {</a>
<a name="ln5596">        str += start;</a>
<a name="ln5597">        len -= start;</a>
<a name="ln5598">      }</a>
<a name="ln5599">    }</a>
<a name="ln5600"> </a>
<a name="ln5601">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5602">      nth = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5603">    }</a>
<a name="ln5604">    if (error) {</a>
<a name="ln5605">      goto theend;</a>
<a name="ln5606">    }</a>
<a name="ln5607">  }</a>
<a name="ln5608"> </a>
<a name="ln5609">  regmatch.regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING);</a>
<a name="ln5610">  if (regmatch.regprog != NULL) {</a>
<a name="ln5611">    regmatch.rm_ic = p_ic;</a>
<a name="ln5612"> </a>
<a name="ln5613">    for (;; ) {</a>
<a name="ln5614">      if (l != NULL) {</a>
<a name="ln5615">        if (li == NULL) {</a>
<a name="ln5616">          match = false;</a>
<a name="ln5617">          break;</a>
<a name="ln5618">        }</a>
<a name="ln5619">        xfree(tofree);</a>
<a name="ln5620">        tofree = expr = str = (char_u *)encode_tv2echo(TV_LIST_ITEM_TV(li),</a>
<a name="ln5621">                                                       NULL);</a>
<a name="ln5622">        if (str == NULL) {</a>
<a name="ln5623">          break;</a>
<a name="ln5624">        }</a>
<a name="ln5625">      }</a>
<a name="ln5626"> </a>
<a name="ln5627">      match = vim_regexec_nl(&amp;regmatch, str, (colnr_T)startcol);</a>
<a name="ln5628"> </a>
<a name="ln5629">      if (match &amp;&amp; --nth &lt;= 0)</a>
<a name="ln5630">        break;</a>
<a name="ln5631">      if (l == NULL &amp;&amp; !match)</a>
<a name="ln5632">        break;</a>
<a name="ln5633"> </a>
<a name="ln5634">      // Advance to just after the match.</a>
<a name="ln5635">      if (l != NULL) {</a>
<a name="ln5636">        li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5637">        idx++;</a>
<a name="ln5638">      } else {</a>
<a name="ln5639">        startcol = (colnr_T)(regmatch.startp[0]</a>
<a name="ln5640">                             + (*mb_ptr2len)(regmatch.startp[0]) - str);</a>
<a name="ln5641">        if (startcol &gt; (colnr_T)len || str + startcol &lt;= regmatch.startp[0]) {</a>
<a name="ln5642">            match = false;</a>
<a name="ln5643">            break;</a>
<a name="ln5644">        }</a>
<a name="ln5645">      }</a>
<a name="ln5646">    }</a>
<a name="ln5647"> </a>
<a name="ln5648">    if (match) {</a>
<a name="ln5649">      switch (type) {</a>
<a name="ln5650">        case kSomeMatchStrPos: {</a>
<a name="ln5651">          list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5652">          listitem_T *li1 = tv_list_first(ret_l);</a>
<a name="ln5653">          listitem_T *li2 = TV_LIST_ITEM_NEXT(ret_l, li1);</a>
<a name="ln5654">          listitem_T *li3 = TV_LIST_ITEM_NEXT(ret_l, li2);</a>
<a name="ln5655">          listitem_T *li4 = TV_LIST_ITEM_NEXT(ret_l, li3);</a>
<a name="ln5656">          xfree(TV_LIST_ITEM_TV(li1)-&gt;vval.v_string);</a>
<a name="ln5657"> </a>
<a name="ln5658">          const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);</a>
<a name="ln5659">          TV_LIST_ITEM_TV(li1)-&gt;vval.v_string = xmemdupz(</a>
<a name="ln5660">              (const char *)regmatch.startp[0], rd);</a>
<a name="ln5661">          TV_LIST_ITEM_TV(li3)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5662">              regmatch.startp[0] - expr);</a>
<a name="ln5663">          TV_LIST_ITEM_TV(li4)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5664">              regmatch.endp[0] - expr);</a>
<a name="ln5665">          if (l != NULL) {</a>
<a name="ln5666">            TV_LIST_ITEM_TV(li2)-&gt;vval.v_number = (varnumber_T)idx;</a>
<a name="ln5667">          }</a>
<a name="ln5668">          break;</a>
<a name="ln5669">        }</a>
<a name="ln5670">        case kSomeMatchList: {</a>
<a name="ln5671">          // Return list with matched string and submatches.</a>
<a name="ln5672">          for (int i = 0; i &lt; NSUBEXP; i++) {</a>
<a name="ln5673">            if (regmatch.endp[i] == NULL) {</a>
<a name="ln5674">              tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5675">            } else {</a>
<a name="ln5676">              tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5677">                                    (const char *)regmatch.startp[i],</a>
<a name="ln5678">                                    (regmatch.endp[i] - regmatch.startp[i]));</a>
<a name="ln5679">            }</a>
<a name="ln5680">          }</a>
<a name="ln5681">          break;</a>
<a name="ln5682">        }</a>
<a name="ln5683">        case kSomeMatchStr: {</a>
<a name="ln5684">          // Return matched string.</a>
<a name="ln5685">          if (l != NULL) {</a>
<a name="ln5686">            tv_copy(TV_LIST_ITEM_TV(li), rettv);</a>
<a name="ln5687">          } else {</a>
<a name="ln5688">            rettv-&gt;vval.v_string = (char_u *)xmemdupz(</a>
<a name="ln5689">                (const char *)regmatch.startp[0],</a>
<a name="ln5690">                (size_t)(regmatch.endp[0] - regmatch.startp[0]));</a>
<a name="ln5691">          }</a>
<a name="ln5692">          break;</a>
<a name="ln5693">        }</a>
<a name="ln5694">        case kSomeMatch:</a>
<a name="ln5695">        case kSomeMatchEnd: {</a>
<a name="ln5696">          if (l != NULL) {</a>
<a name="ln5697">            rettv-&gt;vval.v_number = idx;</a>
<a name="ln5698">          } else {</a>
<a name="ln5699">            if (type == kSomeMatch) {</a>
<a name="ln5700">              rettv-&gt;vval.v_number =</a>
<a name="ln5701">                (varnumber_T)(regmatch.startp[0] - str);</a>
<a name="ln5702">            } else {</a>
<a name="ln5703">              rettv-&gt;vval.v_number =</a>
<a name="ln5704">                (varnumber_T)(regmatch.endp[0] - str);</a>
<a name="ln5705">            }</a>
<a name="ln5706">            rettv-&gt;vval.v_number += (varnumber_T)(str - expr);</a>
<a name="ln5707">          }</a>
<a name="ln5708">          break;</a>
<a name="ln5709">        }</a>
<a name="ln5710">      }</a>
<a name="ln5711">    }</a>
<a name="ln5712">    vim_regfree(regmatch.regprog);</a>
<a name="ln5713">  }</a>
<a name="ln5714"> </a>
<a name="ln5715">theend:</a>
<a name="ln5716">  if (type == kSomeMatchStrPos &amp;&amp; l == NULL &amp;&amp; rettv-&gt;vval.v_list != NULL) {</a>
<a name="ln5717">    // matchstrpos() without a list: drop the second item</a>
<a name="ln5718">    list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5719">    tv_list_item_remove(ret_l, TV_LIST_ITEM_NEXT(ret_l, tv_list_first(ret_l)));</a>
<a name="ln5720">  }</a>
<a name="ln5721"> </a>
<a name="ln5722">  xfree(tofree);</a>
<a name="ln5723">  p_cpo = save_cpo;</a>
<a name="ln5724">}</a>
<a name="ln5725"> </a>
<a name="ln5726">/*</a>
<a name="ln5727"> * &quot;match()&quot; function</a>
<a name="ln5728"> */</a>
<a name="ln5729">static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5730">{</a>
<a name="ln5731">  find_some_match(argvars, rettv, kSomeMatch);</a>
<a name="ln5732">}</a>
<a name="ln5733"> </a>
<a name="ln5734">/*</a>
<a name="ln5735"> * &quot;matchadd()&quot; function</a>
<a name="ln5736"> */</a>
<a name="ln5737">static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5738">{</a>
<a name="ln5739">  char grpbuf[NUMBUFLEN];</a>
<a name="ln5740">  char patbuf[NUMBUFLEN];</a>
<a name="ln5741">  // group</a>
<a name="ln5742">  const char *const grp = tv_get_string_buf_chk(&amp;argvars[0], grpbuf);</a>
<a name="ln5743">  // pattern</a>
<a name="ln5744">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5745">  // default priority</a>
<a name="ln5746">  int prio = 10;</a>
<a name="ln5747">  int id = -1;</a>
<a name="ln5748">  bool error = false;</a>
<a name="ln5749">  const char *conceal_char = NULL;</a>
<a name="ln5750">  win_T *win = curwin;</a>
<a name="ln5751"> </a>
<a name="ln5752">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5753"> </a>
<a name="ln5754">  if (grp == NULL || pat == NULL) {</a>
<a name="ln5755">    return;</a>
<a name="ln5756">  }</a>
<a name="ln5757">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5758">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5759">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5760">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5761">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5762">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5763">        return;</a>
<a name="ln5764">      }</a>
<a name="ln5765">    }</a>
<a name="ln5766">  }</a>
<a name="ln5767">  if (error) {</a>
<a name="ln5768">    return;</a>
<a name="ln5769">  }</a>
<a name="ln5770">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln5771">    EMSGN(_(&quot;E798: ID is reserved for \&quot;:match\&quot;: %&quot; PRId64), id);</a>
<a name="ln5772">    return;</a>
<a name="ln5773">  }</a>
<a name="ln5774"> </a>
<a name="ln5775">  rettv-&gt;vval.v_number = match_add(win, grp, pat, prio, id, NULL, conceal_char);</a>
<a name="ln5776">}</a>
<a name="ln5777"> </a>
<a name="ln5778">static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5779">{</a>
<a name="ln5780">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5781"> </a>
<a name="ln5782">  char buf[NUMBUFLEN];</a>
<a name="ln5783">  const char *const group = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln5784">  if (group == NULL) {</a>
<a name="ln5785">    return;</a>
<a name="ln5786">  }</a>
<a name="ln5787"> </a>
<a name="ln5788">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln5789">    EMSG2(_(e_listarg), &quot;matchaddpos()&quot;);</a>
<a name="ln5790">    return;</a>
<a name="ln5791">  }</a>
<a name="ln5792"> </a>
<a name="ln5793">  list_T *l;</a>
<a name="ln5794">  l = argvars[1].vval.v_list;</a>
<a name="ln5795">  if (l == NULL) {</a>
<a name="ln5796">    return;</a>
<a name="ln5797">  }</a>
<a name="ln5798"> </a>
<a name="ln5799">  bool error = false;</a>
<a name="ln5800">  int prio = 10;</a>
<a name="ln5801">  int id = -1;</a>
<a name="ln5802">  const char *conceal_char = NULL;</a>
<a name="ln5803">  win_T *win = curwin;</a>
<a name="ln5804"> </a>
<a name="ln5805">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5806">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5807">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5808">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5809">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5810">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5811">        return;</a>
<a name="ln5812">      }</a>
<a name="ln5813">    }</a>
<a name="ln5814">  }</a>
<a name="ln5815">  if (error == true) {</a>
<a name="ln5816">    return;</a>
<a name="ln5817">  }</a>
<a name="ln5818"> </a>
<a name="ln5819">  // id == 3 is ok because matchaddpos() is supposed to substitute :3match</a>
<a name="ln5820">  if (id == 1 || id == 2) {</a>
<a name="ln5821">    EMSGN(_(&quot;E798: ID is reserved for \&quot;match\&quot;: %&quot; PRId64), id);</a>
<a name="ln5822">    return;</a>
<a name="ln5823">  }</a>
<a name="ln5824"> </a>
<a name="ln5825">  rettv-&gt;vval.v_number = match_add(win, group, NULL, prio, id, l, conceal_char);</a>
<a name="ln5826">}</a>
<a name="ln5827"> </a>
<a name="ln5828">/*</a>
<a name="ln5829"> * &quot;matcharg()&quot; function</a>
<a name="ln5830"> */</a>
<a name="ln5831">static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5832">{</a>
<a name="ln5833">  const int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln5834"> </a>
<a name="ln5835">  tv_list_alloc_ret(rettv, (id &gt;= 1 &amp;&amp; id &lt;= 3</a>
<a name="ln5836">                            ? 2</a>
<a name="ln5837">                            : 0));</a>
<a name="ln5838"> </a>
<a name="ln5839">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln5840">    matchitem_T *const m = (matchitem_T *)get_match(curwin, id);</a>
<a name="ln5841"> </a>
<a name="ln5842">    if (m != NULL) {</a>
<a name="ln5843">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5844">                            (const char *)syn_id2name(m-&gt;hlg_id), -1);</a>
<a name="ln5845">      tv_list_append_string(rettv-&gt;vval.v_list, (const char *)m-&gt;pattern, -1);</a>
<a name="ln5846">    } else {</a>
<a name="ln5847">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5848">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5849">    }</a>
<a name="ln5850">  }</a>
<a name="ln5851">}</a>
<a name="ln5852"> </a>
<a name="ln5853">/*</a>
<a name="ln5854"> * &quot;matchdelete()&quot; function</a>
<a name="ln5855"> */</a>
<a name="ln5856">static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5857">{</a>
<a name="ln5858">  win_T   *win = get_optional_window(argvars, 1);</a>
<a name="ln5859">  if (win == NULL) {</a>
<a name="ln5860">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5861">  } else {</a>
<a name="ln5862">    rettv-&gt;vval.v_number = match_delete(win,</a>
<a name="ln5863">                                        (int)tv_get_number(&amp;argvars[0]), true);</a>
<a name="ln5864">  }</a>
<a name="ln5865">}</a>
<a name="ln5866"> </a>
<a name="ln5867">/*</a>
<a name="ln5868"> * &quot;matchend()&quot; function</a>
<a name="ln5869"> */</a>
<a name="ln5870">static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5871">{</a>
<a name="ln5872">  find_some_match(argvars, rettv, kSomeMatchEnd);</a>
<a name="ln5873">}</a>
<a name="ln5874"> </a>
<a name="ln5875">/*</a>
<a name="ln5876"> * &quot;matchlist()&quot; function</a>
<a name="ln5877"> */</a>
<a name="ln5878">static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5879">{</a>
<a name="ln5880">  find_some_match(argvars, rettv, kSomeMatchList);</a>
<a name="ln5881">}</a>
<a name="ln5882"> </a>
<a name="ln5883">/*</a>
<a name="ln5884"> * &quot;matchstr()&quot; function</a>
<a name="ln5885"> */</a>
<a name="ln5886">static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5887">{</a>
<a name="ln5888">  find_some_match(argvars, rettv, kSomeMatchStr);</a>
<a name="ln5889">}</a>
<a name="ln5890"> </a>
<a name="ln5891">/// &quot;matchstrpos()&quot; function</a>
<a name="ln5892">static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5893">{</a>
<a name="ln5894">  find_some_match(argvars, rettv, kSomeMatchStrPos);</a>
<a name="ln5895">}</a>
<a name="ln5896"> </a>
<a name="ln5897">/// Get maximal/minimal number value in a list or dictionary</a>
<a name="ln5898">///</a>
<a name="ln5899">/// @param[in]  tv  List or dictionary to work with. If it contains something</a>
<a name="ln5900">///                 that is not an integer number (or cannot be coerced to</a>
<a name="ln5901">///                 it) error is given.</a>
<a name="ln5902">/// @param[out]  rettv  Location where result will be saved. Only assigns</a>
<a name="ln5903">///                     vval.v_number, type is not touched. Returns zero for</a>
<a name="ln5904">///                     empty lists/dictionaries.</a>
<a name="ln5905">/// @param[in]  domax  Determines whether maximal or minimal value is desired.</a>
<a name="ln5906">static void max_min(const typval_T *const tv, typval_T *const rettv,</a>
<a name="ln5907">                    const bool domax)</a>
<a name="ln5908">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5909">{</a>
<a name="ln5910">  bool error = false;</a>
<a name="ln5911"> </a>
<a name="ln5912">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5913">  varnumber_T n = (domax ? VARNUMBER_MIN : VARNUMBER_MAX);</a>
<a name="ln5914">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln5915">    if (tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln5916">      return;</a>
<a name="ln5917">    }</a>
<a name="ln5918">    TV_LIST_ITER_CONST(tv-&gt;vval.v_list, li, {</a>
<a name="ln5919">      const varnumber_T i = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln5920">      if (error) {</a>
<a name="ln5921">        return;</a>
<a name="ln5922">      }</a>
<a name="ln5923">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln5924">        n = i;</a>
<a name="ln5925">      }</a>
<a name="ln5926">    });</a>
<a name="ln5927">  } else if (tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln5928">    if (tv_dict_len(tv-&gt;vval.v_dict) == 0) {</a>
<a name="ln5929">      return;</a>
<a name="ln5930">    }</a>
<a name="ln5931">    TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln5932">      const varnumber_T i = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln5933">      if (error) {</a>
<a name="ln5934">        return;</a>
<a name="ln5935">      }</a>
<a name="ln5936">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln5937">        n = i;</a>
<a name="ln5938">      }</a>
<a name="ln5939">    });</a>
<a name="ln5940">  } else {</a>
<a name="ln5941">    EMSG2(_(e_listdictarg), domax ? &quot;max()&quot; : &quot;min()&quot;);</a>
<a name="ln5942">    return;</a>
<a name="ln5943">  }</a>
<a name="ln5944">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5945">}</a>
<a name="ln5946"> </a>
<a name="ln5947">/*</a>
<a name="ln5948"> * &quot;max()&quot; function</a>
<a name="ln5949"> */</a>
<a name="ln5950">static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5951">{</a>
<a name="ln5952">  max_min(argvars, rettv, TRUE);</a>
<a name="ln5953">}</a>
<a name="ln5954"> </a>
<a name="ln5955">/*</a>
<a name="ln5956"> * &quot;min()&quot; function</a>
<a name="ln5957"> */</a>
<a name="ln5958">static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5959">{</a>
<a name="ln5960">  max_min(argvars, rettv, FALSE);</a>
<a name="ln5961">}</a>
<a name="ln5962"> </a>
<a name="ln5963">/*</a>
<a name="ln5964"> * &quot;mkdir()&quot; function</a>
<a name="ln5965"> */</a>
<a name="ln5966">static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5967">{</a>
<a name="ln5968">  int prot = 0755;  // -V536</a>
<a name="ln5969"> </a>
<a name="ln5970">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln5971">  if (check_secure()) {</a>
<a name="ln5972">    return;</a>
<a name="ln5973">  }</a>
<a name="ln5974"> </a>
<a name="ln5975">  char buf[NUMBUFLEN];</a>
<a name="ln5976">  const char *const dir = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln5977">  if (*dir == NUL) {</a>
<a name="ln5978">    return;</a>
<a name="ln5979">  }</a>
<a name="ln5980"> </a>
<a name="ln5981">  if (*path_tail((char_u *)dir) == NUL) {</a>
<a name="ln5982">    // Remove trailing slashes.</a>
<a name="ln5983">    *path_tail_with_sep((char_u *)dir) = NUL;</a>
<a name="ln5984">  }</a>
<a name="ln5985"> </a>
<a name="ln5986">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5987">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5988">      prot = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln5989">      if (prot == -1) {</a>
<a name="ln5990">        return;</a>
<a name="ln5991">      }</a>
<a name="ln5992">    }</a>
<a name="ln5993">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;p&quot;) == 0) {</a>
<a name="ln5994">      char *failed_dir;</a>
<a name="ln5995">      int ret = os_mkdir_recurse(dir, prot, &amp;failed_dir);</a>
<a name="ln5996">      if (ret != 0) {</a>
<a name="ln5997">        EMSG3(_(e_mkdir), failed_dir, os_strerror(ret));</a>
<a name="ln5998">        xfree(failed_dir);</a>
<a name="ln5999">        rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6000">        return;</a>
<a name="ln6001">      } else {</a>
<a name="ln6002">        rettv-&gt;vval.v_number = OK;</a>
<a name="ln6003">        return;</a>
<a name="ln6004">      }</a>
<a name="ln6005">    }</a>
<a name="ln6006">  }</a>
<a name="ln6007">  rettv-&gt;vval.v_number = vim_mkdir_emsg(dir, prot);</a>
<a name="ln6008">}</a>
<a name="ln6009"> </a>
<a name="ln6010">/// &quot;mode()&quot; function</a>
<a name="ln6011">static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6012">{</a>
<a name="ln6013">  char *mode = get_mode();</a>
<a name="ln6014"> </a>
<a name="ln6015">  // Clear out the minor mode when the argument is not a non-zero number or</a>
<a name="ln6016">  // non-empty string.</a>
<a name="ln6017">  if (!non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln6018">    mode[1] = NUL;</a>
<a name="ln6019">  }</a>
<a name="ln6020"> </a>
<a name="ln6021">  rettv-&gt;vval.v_string = (char_u *)mode;</a>
<a name="ln6022">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6023">}</a>
<a name="ln6024"> </a>
<a name="ln6025">/// &quot;msgpackdump()&quot; function</a>
<a name="ln6026">static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6027">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6028">{</a>
<a name="ln6029">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6030">    EMSG2(_(e_listarg), &quot;msgpackdump()&quot;);</a>
<a name="ln6031">    return;</a>
<a name="ln6032">  }</a>
<a name="ln6033">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6034">  list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6035">  msgpack_packer *lpacker = msgpack_packer_new(ret_list, &amp;encode_list_write);</a>
<a name="ln6036">  const char *const msg = _(&quot;msgpackdump() argument, index %i&quot;);</a>
<a name="ln6037">  // Assume that translation will not take more then 4 times more space</a>
<a name="ln6038">  char msgbuf[sizeof(&quot;msgpackdump() argument, index &quot;) * 4 + NUMBUFLEN];</a>
<a name="ln6039">  int idx = 0;</a>
<a name="ln6040">  TV_LIST_ITER(list, li, {</a>
<a name="ln6041">    vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx);</a>
<a name="ln6042">    idx++;</a>
<a name="ln6043">    if (encode_vim_to_msgpack(lpacker, TV_LIST_ITEM_TV(li), msgbuf) == FAIL) {</a>
<a name="ln6044">      break;</a>
<a name="ln6045">    }</a>
<a name="ln6046">  });</a>
<a name="ln6047">  msgpack_packer_free(lpacker);</a>
<a name="ln6048">}</a>
<a name="ln6049"> </a>
<a name="ln6050">/// &quot;msgpackparse&quot; function</a>
<a name="ln6051">static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6052">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6053">{</a>
<a name="ln6054">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6055">    EMSG2(_(e_listarg), &quot;msgpackparse()&quot;);</a>
<a name="ln6056">    return;</a>
<a name="ln6057">  }</a>
<a name="ln6058">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6059">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6060">  if (tv_list_len(list) == 0) {</a>
<a name="ln6061">    return;</a>
<a name="ln6062">  }</a>
<a name="ln6063">  if (TV_LIST_ITEM_TV(tv_list_first(list))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6064">    EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6065">    return;</a>
<a name="ln6066">  }</a>
<a name="ln6067">  ListReaderState lrstate = encode_init_lrstate(list);</a>
<a name="ln6068">  msgpack_unpacker *const unpacker = msgpack_unpacker_new(IOSIZE);</a>
<a name="ln6069">  if (unpacker == NULL) {</a>
<a name="ln6070">    EMSG(_(e_outofmem));</a>
<a name="ln6071">    return;</a>
<a name="ln6072">  }</a>
<a name="ln6073">  msgpack_unpacked unpacked;</a>
<a name="ln6074">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln6075">  do {</a>
<a name="ln6076">    if (!msgpack_unpacker_reserve_buffer(unpacker, IOSIZE)) {</a>
<a name="ln6077">      EMSG(_(e_outofmem));</a>
<a name="ln6078">      goto f_msgpackparse_exit;</a>
<a name="ln6079">    }</a>
<a name="ln6080">    size_t read_bytes;</a>
<a name="ln6081">    const int rlret = encode_read_from_list(</a>
<a name="ln6082">        &amp;lrstate, msgpack_unpacker_buffer(unpacker), IOSIZE, &amp;read_bytes);</a>
<a name="ln6083">    if (rlret == FAIL) {</a>
<a name="ln6084">      EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6085">      goto f_msgpackparse_exit;</a>
<a name="ln6086">    }</a>
<a name="ln6087">    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);</a>
<a name="ln6088">    if (read_bytes == 0) {</a>
<a name="ln6089">      break;</a>
<a name="ln6090">    }</a>
<a name="ln6091">    while (unpacker-&gt;off &lt; unpacker-&gt;used) {</a>
<a name="ln6092">      const msgpack_unpack_return result = msgpack_unpacker_next(unpacker,</a>
<a name="ln6093">                                                                 &amp;unpacked);</a>
<a name="ln6094">      if (result == MSGPACK_UNPACK_PARSE_ERROR) {</a>
<a name="ln6095">        EMSG2(_(e_invarg2), &quot;Failed to parse msgpack string&quot;);</a>
<a name="ln6096">        goto f_msgpackparse_exit;</a>
<a name="ln6097">      }</a>
<a name="ln6098">      if (result == MSGPACK_UNPACK_NOMEM_ERROR) {</a>
<a name="ln6099">        EMSG(_(e_outofmem));</a>
<a name="ln6100">        goto f_msgpackparse_exit;</a>
<a name="ln6101">      }</a>
<a name="ln6102">      if (result == MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln6103">        typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6104">        if (msgpack_to_vim(unpacked.data, &amp;tv) == FAIL) {</a>
<a name="ln6105">          EMSG2(_(e_invarg2), &quot;Failed to convert msgpack string&quot;);</a>
<a name="ln6106">          goto f_msgpackparse_exit;</a>
<a name="ln6107">        }</a>
<a name="ln6108">        tv_list_append_owned_tv(ret_list, tv);</a>
<a name="ln6109">      }</a>
<a name="ln6110">      if (result == MSGPACK_UNPACK_CONTINUE) {</a>
<a name="ln6111">        if (rlret == OK) {</a>
<a name="ln6112">          EMSG2(_(e_invarg2), &quot;Incomplete msgpack string&quot;);</a>
<a name="ln6113">        }</a>
<a name="ln6114">        break;</a>
<a name="ln6115">      }</a>
<a name="ln6116">    }</a>
<a name="ln6117">    if (rlret == OK) {</a>
<a name="ln6118">      break;</a>
<a name="ln6119">    }</a>
<a name="ln6120">  } while (true);</a>
<a name="ln6121"> </a>
<a name="ln6122">f_msgpackparse_exit:</a>
<a name="ln6123">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln6124">  msgpack_unpacker_free(unpacker);</a>
<a name="ln6125">  return;</a>
<a name="ln6126">}</a>
<a name="ln6127"> </a>
<a name="ln6128">/*</a>
<a name="ln6129"> * &quot;nextnonblank()&quot; function</a>
<a name="ln6130"> */</a>
<a name="ln6131">static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6132">{</a>
<a name="ln6133">  linenr_T lnum;</a>
<a name="ln6134"> </a>
<a name="ln6135">  for (lnum = tv_get_lnum(argvars);; lnum++) {</a>
<a name="ln6136">    if (lnum &lt; 0 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6137">      lnum = 0;</a>
<a name="ln6138">      break;</a>
<a name="ln6139">    }</a>
<a name="ln6140">    if (*skipwhite(ml_get(lnum)) != NUL) {</a>
<a name="ln6141">      break;</a>
<a name="ln6142">    }</a>
<a name="ln6143">  }</a>
<a name="ln6144">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6145">}</a>
<a name="ln6146"> </a>
<a name="ln6147">/*</a>
<a name="ln6148"> * &quot;nr2char()&quot; function</a>
<a name="ln6149"> */</a>
<a name="ln6150">static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6151">{</a>
<a name="ln6152">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6153">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln6154">      return;</a>
<a name="ln6155">    }</a>
<a name="ln6156">  }</a>
<a name="ln6157"> </a>
<a name="ln6158">  bool error = false;</a>
<a name="ln6159">  const varnumber_T num = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6160">  if (error) {</a>
<a name="ln6161">    return;</a>
<a name="ln6162">  }</a>
<a name="ln6163">  if (num &lt; 0) {</a>
<a name="ln6164">    EMSG(_(&quot;E5070: Character number must not be less than zero&quot;));</a>
<a name="ln6165">    return;</a>
<a name="ln6166">  }</a>
<a name="ln6167">  if (num &gt; INT_MAX) {</a>
<a name="ln6168">    emsgf(_(&quot;E5071: Character number must not be greater than INT_MAX (%i)&quot;),</a>
<a name="ln6169">          INT_MAX);</a>
<a name="ln6170">    return;</a>
<a name="ln6171">  }</a>
<a name="ln6172"> </a>
<a name="ln6173">  char buf[MB_MAXBYTES];</a>
<a name="ln6174">  const int len = utf_char2bytes((int)num, (char_u *)buf);</a>
<a name="ln6175"> </a>
<a name="ln6176">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6177">  rettv-&gt;vval.v_string = xmemdupz(buf, (size_t)len);</a>
<a name="ln6178">}</a>
<a name="ln6179"> </a>
<a name="ln6180">/*</a>
<a name="ln6181"> * &quot;or(expr, expr)&quot; function</a>
<a name="ln6182"> */</a>
<a name="ln6183">static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6184">{</a>
<a name="ln6185">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln6186">                         | tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln6187">}</a>
<a name="ln6188"> </a>
<a name="ln6189">/*</a>
<a name="ln6190"> * &quot;pathshorten()&quot; function</a>
<a name="ln6191"> */</a>
<a name="ln6192">static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6193">{</a>
<a name="ln6194">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6195">  const char *const s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln6196">  if (!s) {</a>
<a name="ln6197">    return;</a>
<a name="ln6198">  }</a>
<a name="ln6199">  rettv-&gt;vval.v_string = shorten_dir((char_u *)xstrdup(s));</a>
<a name="ln6200">}</a>
<a name="ln6201"> </a>
<a name="ln6202">/*</a>
<a name="ln6203"> * &quot;pow()&quot; function</a>
<a name="ln6204"> */</a>
<a name="ln6205">static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6206">{</a>
<a name="ln6207">  float_T fx;</a>
<a name="ln6208">  float_T fy;</a>
<a name="ln6209"> </a>
<a name="ln6210">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln6211">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln6212">    rettv-&gt;vval.v_float = pow(fx, fy);</a>
<a name="ln6213">  } else {</a>
<a name="ln6214">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln6215">  }</a>
<a name="ln6216">}</a>
<a name="ln6217"> </a>
<a name="ln6218">/*</a>
<a name="ln6219"> * &quot;prevnonblank()&quot; function</a>
<a name="ln6220"> */</a>
<a name="ln6221">static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6222">{</a>
<a name="ln6223">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln6224">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6225">    lnum = 0;</a>
<a name="ln6226">  } else {</a>
<a name="ln6227">    while (lnum &gt;= 1 &amp;&amp; *skipwhite(ml_get(lnum)) == NUL) {</a>
<a name="ln6228">      lnum--;</a>
<a name="ln6229">    }</a>
<a name="ln6230">  }</a>
<a name="ln6231">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6232">}</a>
<a name="ln6233"> </a>
<a name="ln6234">/*</a>
<a name="ln6235"> * &quot;printf()&quot; function</a>
<a name="ln6236"> */</a>
<a name="ln6237">static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6238">{</a>
<a name="ln6239">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6240">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6241">  {</a>
<a name="ln6242">    int len;</a>
<a name="ln6243">    int saved_did_emsg = did_emsg;</a>
<a name="ln6244"> </a>
<a name="ln6245">    // Get the required length, allocate the buffer and do it for real.</a>
<a name="ln6246">    did_emsg = false;</a>
<a name="ln6247">    char buf[NUMBUFLEN];</a>
<a name="ln6248">    const char *fmt = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6249">    len = vim_vsnprintf_typval(NULL, 0, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6250">    if (!did_emsg) {</a>
<a name="ln6251">      char *s = xmalloc(len + 1);</a>
<a name="ln6252">      rettv-&gt;vval.v_string = (char_u *)s;</a>
<a name="ln6253">      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6254">    }</a>
<a name="ln6255">    did_emsg |= saved_did_emsg;</a>
<a name="ln6256">  }</a>
<a name="ln6257">}</a>
<a name="ln6258"> </a>
<a name="ln6259">// &quot;prompt_setcallback({buffer}, {callback})&quot; function</a>
<a name="ln6260">static void f_prompt_setcallback(typval_T *argvars,</a>
<a name="ln6261">                                 typval_T *rettv, FunPtr fptr)</a>
<a name="ln6262">{</a>
<a name="ln6263">    buf_T *buf;</a>
<a name="ln6264">    Callback prompt_callback = { .type = kCallbackNone };</a>
<a name="ln6265"> </a>
<a name="ln6266">    if (check_secure()) {</a>
<a name="ln6267">      return;</a>
<a name="ln6268">    }</a>
<a name="ln6269">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6270">    if (buf == NULL) {</a>
<a name="ln6271">      return;</a>
<a name="ln6272">    }</a>
<a name="ln6273"> </a>
<a name="ln6274">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6275">      if (!callback_from_typval(&amp;prompt_callback, &amp;argvars[1])) {</a>
<a name="ln6276">        return;</a>
<a name="ln6277">      }</a>
<a name="ln6278">    }</a>
<a name="ln6279"> </a>
<a name="ln6280">    callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln6281">    buf-&gt;b_prompt_callback = prompt_callback;</a>
<a name="ln6282">}</a>
<a name="ln6283"> </a>
<a name="ln6284">// &quot;prompt_setinterrupt({buffer}, {callback})&quot; function</a>
<a name="ln6285">static void f_prompt_setinterrupt(typval_T *argvars,</a>
<a name="ln6286">                                  typval_T *rettv, FunPtr fptr)</a>
<a name="ln6287">{</a>
<a name="ln6288">    buf_T *buf;</a>
<a name="ln6289">    Callback interrupt_callback = { .type = kCallbackNone };</a>
<a name="ln6290"> </a>
<a name="ln6291">    if (check_secure()) {</a>
<a name="ln6292">      return;</a>
<a name="ln6293">    }</a>
<a name="ln6294">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6295">    if (buf == NULL) {</a>
<a name="ln6296">      return;</a>
<a name="ln6297">    }</a>
<a name="ln6298"> </a>
<a name="ln6299">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6300">      if (!callback_from_typval(&amp;interrupt_callback, &amp;argvars[1])) {</a>
<a name="ln6301">        return;</a>
<a name="ln6302">      }</a>
<a name="ln6303">    }</a>
<a name="ln6304"> </a>
<a name="ln6305">    callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln6306">    buf-&gt;b_prompt_interrupt= interrupt_callback;</a>
<a name="ln6307">}</a>
<a name="ln6308"> </a>
<a name="ln6309">// &quot;prompt_setprompt({buffer}, {text})&quot; function</a>
<a name="ln6310">static void f_prompt_setprompt(typval_T *argvars,</a>
<a name="ln6311">                               typval_T *rettv, FunPtr fptr)</a>
<a name="ln6312">{</a>
<a name="ln6313">    buf_T *buf;</a>
<a name="ln6314">    const char_u *text;</a>
<a name="ln6315"> </a>
<a name="ln6316">    if (check_secure()) {</a>
<a name="ln6317">      return;</a>
<a name="ln6318">    }</a>
<a name="ln6319">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6320">    if (buf == NULL) {</a>
<a name="ln6321">      return;</a>
<a name="ln6322">    }</a>
<a name="ln6323"> </a>
<a name="ln6324">    text = (const char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln6325">    xfree(buf-&gt;b_prompt_text);</a>
<a name="ln6326">    buf-&gt;b_prompt_text = vim_strsave(text);</a>
<a name="ln6327">}</a>
<a name="ln6328"> </a>
<a name="ln6329">// &quot;pum_getpos()&quot; function</a>
<a name="ln6330">static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6331">{</a>
<a name="ln6332">  tv_dict_alloc_ret(rettv);</a>
<a name="ln6333">  pum_set_event_info(rettv-&gt;vval.v_dict);</a>
<a name="ln6334">}</a>
<a name="ln6335"> </a>
<a name="ln6336">/*</a>
<a name="ln6337"> * &quot;pumvisible()&quot; function</a>
<a name="ln6338"> */</a>
<a name="ln6339">static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6340">{</a>
<a name="ln6341">  if (pum_visible())</a>
<a name="ln6342">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln6343">}</a>
<a name="ln6344"> </a>
<a name="ln6345">/*</a>
<a name="ln6346"> * &quot;pyeval()&quot; function</a>
<a name="ln6347"> */</a>
<a name="ln6348">static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6349">{</a>
<a name="ln6350">  script_host_eval(&quot;python&quot;, argvars, rettv);</a>
<a name="ln6351">}</a>
<a name="ln6352"> </a>
<a name="ln6353">/*</a>
<a name="ln6354"> * &quot;py3eval()&quot; function</a>
<a name="ln6355"> */</a>
<a name="ln6356">static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6357">{</a>
<a name="ln6358">  script_host_eval(&quot;python3&quot;, argvars, rettv);</a>
<a name="ln6359">}</a>
<a name="ln6360"> </a>
<a name="ln6361">// &quot;pyxeval()&quot; function</a>
<a name="ln6362">static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6363">{</a>
<a name="ln6364">  init_pyxversion();</a>
<a name="ln6365">  if (p_pyx == 2) {</a>
<a name="ln6366">    f_pyeval(argvars, rettv, NULL);</a>
<a name="ln6367">  } else {</a>
<a name="ln6368">    f_py3eval(argvars, rettv, NULL);</a>
<a name="ln6369">  }</a>
<a name="ln6370">}</a>
<a name="ln6371"> </a>
<a name="ln6372">///</a>
<a name="ln6373">/// &quot;perleval()&quot; function</a>
<a name="ln6374">///</a>
<a name="ln6375">static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6376">{</a>
<a name="ln6377">  script_host_eval(&quot;perl&quot;, argvars, rettv);</a>
<a name="ln6378">}</a>
<a name="ln6379"> </a>
<a name="ln6380">// &quot;rubyeval()&quot; function</a>
<a name="ln6381">static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6382">{</a>
<a name="ln6383">  script_host_eval(&quot;ruby&quot;, argvars, rettv);</a>
<a name="ln6384">}</a>
<a name="ln6385"> </a>
<a name="ln6386">/*</a>
<a name="ln6387"> * &quot;range()&quot; function</a>
<a name="ln6388"> */</a>
<a name="ln6389">static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6390">{</a>
<a name="ln6391">  varnumber_T start;</a>
<a name="ln6392">  varnumber_T end;</a>
<a name="ln6393">  varnumber_T stride = 1;</a>
<a name="ln6394">  varnumber_T i;</a>
<a name="ln6395">  bool error = false;</a>
<a name="ln6396"> </a>
<a name="ln6397">  start = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6398">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6399">    end = start - 1;</a>
<a name="ln6400">    start = 0;</a>
<a name="ln6401">  } else {</a>
<a name="ln6402">    end = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6403">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6404">      stride = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6405">    }</a>
<a name="ln6406">  }</a>
<a name="ln6407"> </a>
<a name="ln6408">  if (error) {</a>
<a name="ln6409">    return;  // Type error; errmsg already given.</a>
<a name="ln6410">  }</a>
<a name="ln6411">  if (stride == 0) {</a>
<a name="ln6412">    EMSG(_(&quot;E726: Stride is zero&quot;));</a>
<a name="ln6413">  } else if (stride &gt; 0 ? end + 1 &lt; start : end - 1 &gt; start) {</a>
<a name="ln6414">    EMSG(_(&quot;E727: Start past end&quot;));</a>
<a name="ln6415">  } else {</a>
<a name="ln6416">    tv_list_alloc_ret(rettv, (end - start) / stride);</a>
<a name="ln6417">    for (i = start; stride &gt; 0 ? i &lt;= end : i &gt;= end; i += stride) {</a>
<a name="ln6418">      tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)i);</a>
<a name="ln6419">    }</a>
<a name="ln6420">  }</a>
<a name="ln6421">}</a>
<a name="ln6422"> </a>
<a name="ln6423">// Evaluate &quot;expr&quot; for readdir().</a>
<a name="ln6424">static varnumber_T readdir_checkitem(typval_T *expr, const char *name)</a>
<a name="ln6425">{</a>
<a name="ln6426">  typval_T save_val;</a>
<a name="ln6427">  typval_T rettv;</a>
<a name="ln6428">  typval_T argv[2];</a>
<a name="ln6429">  varnumber_T retval = 0;</a>
<a name="ln6430">  bool error = false;</a>
<a name="ln6431"> </a>
<a name="ln6432">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6433">  set_vim_var_string(VV_VAL, name, -1);</a>
<a name="ln6434">  argv[0].v_type = VAR_STRING;</a>
<a name="ln6435">  argv[0].vval.v_string = (char_u *)name;</a>
<a name="ln6436"> </a>
<a name="ln6437">  if (eval_expr_typval(expr, argv, 1, &amp;rettv) == FAIL) {</a>
<a name="ln6438">    goto theend;</a>
<a name="ln6439">  }</a>
<a name="ln6440"> </a>
<a name="ln6441">  retval = tv_get_number_chk(&amp;rettv, &amp;error);</a>
<a name="ln6442">  if (error) {</a>
<a name="ln6443">    retval = -1;</a>
<a name="ln6444">  }</a>
<a name="ln6445"> </a>
<a name="ln6446">  tv_clear(&amp;rettv);</a>
<a name="ln6447"> </a>
<a name="ln6448">theend:</a>
<a name="ln6449">  set_vim_var_string(VV_VAL, NULL, 0);</a>
<a name="ln6450">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6451">  return retval;</a>
<a name="ln6452">}</a>
<a name="ln6453"> </a>
<a name="ln6454">// &quot;readdir()&quot; function</a>
<a name="ln6455">static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6456">{</a>
<a name="ln6457">  typval_T *expr;</a>
<a name="ln6458">  const char *path;</a>
<a name="ln6459">  garray_T ga;</a>
<a name="ln6460">  Directory dir;</a>
<a name="ln6461"> </a>
<a name="ln6462">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6463">  path = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6464">  expr = &amp;argvars[1];</a>
<a name="ln6465">  ga_init(&amp;ga, (int)sizeof(char *), 20);</a>
<a name="ln6466"> </a>
<a name="ln6467">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln6468">    smsg(_(e_notopen), path);</a>
<a name="ln6469">  } else {</a>
<a name="ln6470">    for (;;) {</a>
<a name="ln6471">      bool ignore;</a>
<a name="ln6472"> </a>
<a name="ln6473">      path = os_scandir_next(&amp;dir);</a>
<a name="ln6474">      if (path == NULL) {</a>
<a name="ln6475">        break;</a>
<a name="ln6476">      }</a>
<a name="ln6477"> </a>
<a name="ln6478">      ignore = (path[0] == '.'</a>
<a name="ln6479">                &amp;&amp; (path[1] == NUL || (path[1] == '.' &amp;&amp; path[2] == NUL)));</a>
<a name="ln6480">      if (!ignore &amp;&amp; expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6481">        varnumber_T r = readdir_checkitem(expr, path);</a>
<a name="ln6482"> </a>
<a name="ln6483">        if (r &lt; 0) {</a>
<a name="ln6484">          break;</a>
<a name="ln6485">        }</a>
<a name="ln6486">        if (r == 0) {</a>
<a name="ln6487">          ignore = true;</a>
<a name="ln6488">        }</a>
<a name="ln6489">      }</a>
<a name="ln6490"> </a>
<a name="ln6491">      if (!ignore) {</a>
<a name="ln6492">        ga_grow(&amp;ga, 1);</a>
<a name="ln6493">        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);</a>
<a name="ln6494">      }</a>
<a name="ln6495">    }</a>
<a name="ln6496"> </a>
<a name="ln6497">    os_closedir(&amp;dir);</a>
<a name="ln6498">  }</a>
<a name="ln6499"> </a>
<a name="ln6500">  if (rettv-&gt;vval.v_list != NULL &amp;&amp; ga.ga_len &gt; 0) {</a>
<a name="ln6501">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln6502">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln6503">      path = ((const char **)ga.ga_data)[i];</a>
<a name="ln6504">      tv_list_append_string(rettv-&gt;vval.v_list, path, -1);</a>
<a name="ln6505">    }</a>
<a name="ln6506">  }</a>
<a name="ln6507">  ga_clear_strings(&amp;ga);</a>
<a name="ln6508">}</a>
<a name="ln6509"> </a>
<a name="ln6510">/*</a>
<a name="ln6511"> * &quot;readfile()&quot; function</a>
<a name="ln6512"> */</a>
<a name="ln6513">static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6514">{</a>
<a name="ln6515">  bool binary = false;</a>
<a name="ln6516">  FILE        *fd;</a>
<a name="ln6517">  char_u buf[(IOSIZE/256) * 256];       // rounded to avoid odd + 1</a>
<a name="ln6518">  int io_size = sizeof(buf);</a>
<a name="ln6519">  int readlen;                          // size of last fread()</a>
<a name="ln6520">  char_u      *prev    = NULL;          // previously read bytes, if any</a>
<a name="ln6521">  long prevlen  = 0;                    // length of data in prev</a>
<a name="ln6522">  long prevsize = 0;                    // size of prev buffer</a>
<a name="ln6523">  long maxline  = MAXLNUM;</a>
<a name="ln6524"> </a>
<a name="ln6525">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6526">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;b&quot;) == 0) {</a>
<a name="ln6527">      binary = true;</a>
<a name="ln6528">    }</a>
<a name="ln6529">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6530">      maxline = tv_get_number(&amp;argvars[2]);</a>
<a name="ln6531">    }</a>
<a name="ln6532">  }</a>
<a name="ln6533"> </a>
<a name="ln6534">  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6535"> </a>
<a name="ln6536">  // Always open the file in binary mode, library functions have a mind of</a>
<a name="ln6537">  // their own about CR-LF conversion.</a>
<a name="ln6538">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6539">  if (*fname == NUL || (fd = os_fopen(fname, READBIN)) == NULL) {</a>
<a name="ln6540">    EMSG2(_(e_notopen), *fname == NUL ? _(&quot;&lt;empty&gt;&quot;) : fname);</a>
<a name="ln6541">    return;</a>
<a name="ln6542">  }</a>
<a name="ln6543"> </a>
<a name="ln6544">  while (maxline &lt; 0 || tv_list_len(l) &lt; maxline) {</a>
<a name="ln6545">    readlen = (int)fread(buf, 1, io_size, fd);</a>
<a name="ln6546"> </a>
<a name="ln6547">    // This for loop processes what was read, but is also entered at end</a>
<a name="ln6548">    // of file so that either:</a>
<a name="ln6549">    // - an incomplete line gets written</a>
<a name="ln6550">    // - a &quot;binary&quot; file gets an empty line at the end if it ends in a</a>
<a name="ln6551">    //   newline.</a>
<a name="ln6552">    char_u *p;  // Position in buf.</a>
<a name="ln6553">    char_u *start;  // Start of current line.</a>
<a name="ln6554">    for (p = buf, start = buf;</a>
<a name="ln6555">         p &lt; buf + readlen || (readlen &lt;= 0 &amp;&amp; (prevlen &gt; 0 || binary));</a>
<a name="ln6556">         p++) {</a>
<a name="ln6557">      if (*p == '\n' || readlen &lt;= 0) {</a>
<a name="ln6558">        char_u      *s  = NULL;</a>
<a name="ln6559">        size_t len = p - start;</a>
<a name="ln6560"> </a>
<a name="ln6561">        // Finished a line.  Remove CRs before NL.</a>
<a name="ln6562">        if (readlen &gt; 0 &amp;&amp; !binary) {</a>
<a name="ln6563">          while (len &gt; 0 &amp;&amp; start[len - 1] == '\r') {</a>
<a name="ln6564">            len--;</a>
<a name="ln6565">          }</a>
<a name="ln6566">          // removal may cross back to the &quot;prev&quot; string</a>
<a name="ln6567">          if (len == 0) {</a>
<a name="ln6568">            while (prevlen &gt; 0 &amp;&amp; prev[prevlen - 1] == '\r') {</a>
<a name="ln6569">              prevlen--;</a>
<a name="ln6570">            }</a>
<a name="ln6571">          }</a>
<a name="ln6572">        }</a>
<a name="ln6573">        if (prevlen == 0) {</a>
<a name="ln6574">          assert(len &lt; INT_MAX);</a>
<a name="ln6575">          s = vim_strnsave(start, len);</a>
<a name="ln6576">        } else {</a>
<a name="ln6577">          /* Change &quot;prev&quot; buffer to be the right size.  This way</a>
<a name="ln6578">           * the bytes are only copied once, and very long lines are</a>
<a name="ln6579">           * allocated only once.  */</a>
<a name="ln6580">          s = xrealloc(prev, prevlen + len + 1);</a>
<a name="ln6581">          memcpy(s + prevlen, start, len);</a>
<a name="ln6582">          s[prevlen + len] = NUL;</a>
<a name="ln6583">          prev = NULL;             // the list will own the string</a>
<a name="ln6584">          prevlen = prevsize = 0;</a>
<a name="ln6585">        }</a>
<a name="ln6586"> </a>
<a name="ln6587">        tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln6588">          .v_type = VAR_STRING,</a>
<a name="ln6589">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6590">          .vval.v_string = s,</a>
<a name="ln6591">        });</a>
<a name="ln6592"> </a>
<a name="ln6593">        start = p + 1;  // Step over newline.</a>
<a name="ln6594">        if (maxline &lt; 0) {</a>
<a name="ln6595">          if (tv_list_len(l) &gt; -maxline) {</a>
<a name="ln6596">            assert(tv_list_len(l) == 1 + (-maxline));</a>
<a name="ln6597">            tv_list_item_remove(l, tv_list_first(l));</a>
<a name="ln6598">          }</a>
<a name="ln6599">        } else if (tv_list_len(l) &gt;= maxline) {</a>
<a name="ln6600">          assert(tv_list_len(l) == maxline);</a>
<a name="ln6601">          break;</a>
<a name="ln6602">        }</a>
<a name="ln6603">        if (readlen &lt;= 0) {</a>
<a name="ln6604">          break;</a>
<a name="ln6605">        }</a>
<a name="ln6606">      } else if (*p == NUL) {</a>
<a name="ln6607">        *p = '\n';</a>
<a name="ln6608">      // Check for utf8 &quot;bom&quot;; U+FEFF is encoded as EF BB BF.  Do this</a>
<a name="ln6609">      // when finding the BF and check the previous two bytes.</a>
<a name="ln6610">      } else if (*p == 0xbf &amp;&amp; !binary) {</a>
<a name="ln6611">        // Find the two bytes before the 0xbf.  If p is at buf, or buf + 1,</a>
<a name="ln6612">        // these may be in the &quot;prev&quot; string.</a>
<a name="ln6613">        char_u back1 = p &gt;= buf + 1 ? p[-1]</a>
<a name="ln6614">                       : prevlen &gt;= 1 ? prev[prevlen - 1] : NUL;</a>
<a name="ln6615">        char_u back2 = p &gt;= buf + 2 ? p[-2]</a>
<a name="ln6616">                       : p == buf + 1 &amp;&amp; prevlen &gt;= 1 ? prev[prevlen - 1]</a>
<a name="ln6617">                       : prevlen &gt;= 2 ? prev[prevlen - 2] : NUL;</a>
<a name="ln6618"> </a>
<a name="ln6619">        if (back2 == 0xef &amp;&amp; back1 == 0xbb) {</a>
<a name="ln6620">          char_u *dest = p - 2;</a>
<a name="ln6621"> </a>
<a name="ln6622">          // Usually a BOM is at the beginning of a file, and so at</a>
<a name="ln6623">          // the beginning of a line; then we can just step over it.</a>
<a name="ln6624">          if (start == dest) {</a>
<a name="ln6625">            start = p + 1;</a>
<a name="ln6626">          } else {</a>
<a name="ln6627">            // have to shuffle buf to close gap</a>
<a name="ln6628">            int adjust_prevlen = 0;</a>
<a name="ln6629"> </a>
<a name="ln6630">            if (dest &lt; buf) {  // -V782</a>
<a name="ln6631">              adjust_prevlen = (int)(buf - dest);  // -V782</a>
<a name="ln6632">              // adjust_prevlen must be 1 or 2.</a>
<a name="ln6633">              dest = buf;</a>
<a name="ln6634">            }</a>
<a name="ln6635">            if (readlen &gt; p - buf + 1)</a>
<a name="ln6636">              memmove(dest, p + 1, readlen - (p - buf) - 1);</a>
<a name="ln6637">            readlen -= 3 - adjust_prevlen;</a>
<a name="ln6638">            prevlen -= adjust_prevlen;</a>
<a name="ln6639">            p = dest - 1;</a>
<a name="ln6640">          }</a>
<a name="ln6641">        }</a>
<a name="ln6642">      }</a>
<a name="ln6643">    }     // for</a>
<a name="ln6644"> </a>
<a name="ln6645">    if ((maxline &gt;= 0 &amp;&amp; tv_list_len(l) &gt;= maxline) || readlen &lt;= 0) {</a>
<a name="ln6646">      break;</a>
<a name="ln6647">    }</a>
<a name="ln6648">    if (start &lt; p) {</a>
<a name="ln6649">      // There's part of a line in buf, store it in &quot;prev&quot;.</a>
<a name="ln6650">      if (p - start + prevlen &gt;= prevsize) {</a>
<a name="ln6651">        /* A common use case is ordinary text files and &quot;prev&quot; gets a</a>
<a name="ln6652">         * fragment of a line, so the first allocation is made</a>
<a name="ln6653">         * small, to avoid repeatedly 'allocing' large and</a>
<a name="ln6654">         * 'reallocing' small. */</a>
<a name="ln6655">        if (prevsize == 0)</a>
<a name="ln6656">          prevsize = (long)(p - start);</a>
<a name="ln6657">        else {</a>
<a name="ln6658">          long grow50pc = (prevsize * 3) / 2;</a>
<a name="ln6659">          long growmin  = (long)((p - start) * 2 + prevlen);</a>
<a name="ln6660">          prevsize = grow50pc &gt; growmin ? grow50pc : growmin;</a>
<a name="ln6661">        }</a>
<a name="ln6662">        prev = xrealloc(prev, prevsize);</a>
<a name="ln6663">      }</a>
<a name="ln6664">      // Add the line part to end of &quot;prev&quot;.</a>
<a name="ln6665">      memmove(prev + prevlen, start, p - start);</a>
<a name="ln6666">      prevlen += (long)(p - start);</a>
<a name="ln6667">    }</a>
<a name="ln6668">  }   // while</a>
<a name="ln6669"> </a>
<a name="ln6670">  xfree(prev);</a>
<a name="ln6671">  fclose(fd);</a>
<a name="ln6672">}</a>
<a name="ln6673"> </a>
<a name="ln6674">// &quot;reg_executing()&quot; function</a>
<a name="ln6675">static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6676">{</a>
<a name="ln6677">  return_register(reg_executing, rettv);</a>
<a name="ln6678">}</a>
<a name="ln6679"> </a>
<a name="ln6680">// &quot;reg_recording()&quot; function</a>
<a name="ln6681">static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6682">{</a>
<a name="ln6683">  return_register(reg_recording, rettv);</a>
<a name="ln6684">}</a>
<a name="ln6685"> </a>
<a name="ln6686">/// list2proftime - convert a List to proftime_T</a>
<a name="ln6687">///</a>
<a name="ln6688">/// @param arg The input list, must be of type VAR_LIST and have</a>
<a name="ln6689">///            exactly 2 items</a>
<a name="ln6690">/// @param[out] tm The proftime_T representation of `arg`</a>
<a name="ln6691">/// @return OK In case of success, FAIL in case of error</a>
<a name="ln6692">static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6693">{</a>
<a name="ln6694">  if (arg-&gt;v_type != VAR_LIST || tv_list_len(arg-&gt;vval.v_list) != 2) {</a>
<a name="ln6695">    return FAIL;</a>
<a name="ln6696">  }</a>
<a name="ln6697"> </a>
<a name="ln6698">  bool error = false;</a>
<a name="ln6699">  varnumber_T n1 = tv_list_find_nr(arg-&gt;vval.v_list, 0L, &amp;error);</a>
<a name="ln6700">  varnumber_T n2 = tv_list_find_nr(arg-&gt;vval.v_list, 1L, &amp;error);</a>
<a name="ln6701">  if (error) {</a>
<a name="ln6702">    return FAIL;</a>
<a name="ln6703">  }</a>
<a name="ln6704"> </a>
<a name="ln6705">  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit</a>
<a name="ln6706">  // values, now we combine them again.</a>
<a name="ln6707">  union {</a>
<a name="ln6708">    struct { int32_t low, high; } split;</a>
<a name="ln6709">    proftime_T prof;</a>
<a name="ln6710">  } u = { .split.high = n1, .split.low = n2 };</a>
<a name="ln6711"> </a>
<a name="ln6712">  *tm = u.prof;</a>
<a name="ln6713"> </a>
<a name="ln6714">  return OK;</a>
<a name="ln6715">}</a>
<a name="ln6716"> </a>
<a name="ln6717">/// f_reltime - return an item that represents a time value</a>
<a name="ln6718">///</a>
<a name="ln6719">/// @param[out] rettv Without an argument it returns the current time. With</a>
<a name="ln6720">///             one argument it returns the time passed since the argument.</a>
<a name="ln6721">///             With two arguments it returns the time passed between</a>
<a name="ln6722">///             the two arguments.</a>
<a name="ln6723">static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6724">{</a>
<a name="ln6725">  proftime_T res;</a>
<a name="ln6726">  proftime_T start;</a>
<a name="ln6727"> </a>
<a name="ln6728">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln6729">    // no arguments: get current time.</a>
<a name="ln6730">    res = profile_start();</a>
<a name="ln6731">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6732">    if (list2proftime(&amp;argvars[0], &amp;res) == FAIL) {</a>
<a name="ln6733">      return;</a>
<a name="ln6734">    }</a>
<a name="ln6735">    res = profile_end(res);</a>
<a name="ln6736">  } else {</a>
<a name="ln6737">    // two arguments: compute the difference.</a>
<a name="ln6738">    if (list2proftime(&amp;argvars[0], &amp;start) == FAIL</a>
<a name="ln6739">        || list2proftime(&amp;argvars[1], &amp;res) == FAIL) {</a>
<a name="ln6740">      return;</a>
<a name="ln6741">    }</a>
<a name="ln6742">    res = profile_sub(res, start);</a>
<a name="ln6743">  }</a>
<a name="ln6744"> </a>
<a name="ln6745">  // we have to store the 64-bit proftime_T inside of a list of int's</a>
<a name="ln6746">  // (varnumber_T is defined as int). For all our supported platforms, int's</a>
<a name="ln6747">  // are at least 32-bits wide. So we'll use two 32-bit values to store it.</a>
<a name="ln6748">  union {</a>
<a name="ln6749">    struct { int32_t low, high; } split;</a>
<a name="ln6750">    proftime_T prof;</a>
<a name="ln6751">  } u = { .prof = res };</a>
<a name="ln6752"> </a>
<a name="ln6753">  // statically assert that the union type conv will provide the correct</a>
<a name="ln6754">  // results, if varnumber_T or proftime_T change, the union cast will need</a>
<a name="ln6755">  // to be revised.</a>
<a name="ln6756">  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) &amp;&amp; sizeof(u.split) == sizeof(u),</a>
<a name="ln6757">      &quot;type punning will produce incorrect results on this platform&quot;);</a>
<a name="ln6758"> </a>
<a name="ln6759">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln6760">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.high);</a>
<a name="ln6761">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.low);</a>
<a name="ln6762">}</a>
<a name="ln6763"> </a>
<a name="ln6764">/// &quot;reltimestr()&quot; function</a>
<a name="ln6765">static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6766">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6767">{</a>
<a name="ln6768">  proftime_T tm;</a>
<a name="ln6769"> </a>
<a name="ln6770">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6771">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6772">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln6773">    rettv-&gt;vval.v_string = (char_u *)xstrdup(profile_msg(tm));</a>
<a name="ln6774">  }</a>
<a name="ln6775">}</a>
<a name="ln6776"> </a>
<a name="ln6777">/*</a>
<a name="ln6778"> * &quot;remove()&quot; function</a>
<a name="ln6779"> */</a>
<a name="ln6780">static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6781">{</a>
<a name="ln6782">  list_T      *l;</a>
<a name="ln6783">  listitem_T  *item, *item2;</a>
<a name="ln6784">  listitem_T  *li;</a>
<a name="ln6785">  long idx;</a>
<a name="ln6786">  long end;</a>
<a name="ln6787">  dict_T      *d;</a>
<a name="ln6788">  dictitem_T  *di;</a>
<a name="ln6789">  const char *const arg_errmsg = N_(&quot;remove() argument&quot;);</a>
<a name="ln6790"> </a>
<a name="ln6791">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln6792">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6793">      EMSG2(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln6794">    } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln6795">               &amp;&amp; !tv_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6796">      const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln6797">      if (key != NULL) {</a>
<a name="ln6798">        di = tv_dict_find(d, key, -1);</a>
<a name="ln6799">        if (di == NULL) {</a>
<a name="ln6800">          EMSG2(_(e_dictkey), key);</a>
<a name="ln6801">        } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln6802">                   &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6803">          *rettv = di-&gt;di_tv;</a>
<a name="ln6804">          di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln6805">          tv_dict_item_remove(d, di);</a>
<a name="ln6806">          if (tv_dict_is_watched(d)) {</a>
<a name="ln6807">            tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln6808">          }</a>
<a name="ln6809">        }</a>
<a name="ln6810">      }</a>
<a name="ln6811">    }</a>
<a name="ln6812">  } else if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6813">    EMSG2(_(e_listdictarg), &quot;remove()&quot;);</a>
<a name="ln6814">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln6815">                            arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6816">    bool error = false;</a>
<a name="ln6817"> </a>
<a name="ln6818">    idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6819">    if (error) {</a>
<a name="ln6820">      // Type error: do nothing, errmsg already given.</a>
<a name="ln6821">    } else if ((item = tv_list_find(l, idx)) == NULL) {</a>
<a name="ln6822">      EMSGN(_(e_listidx), idx);</a>
<a name="ln6823">    } else {</a>
<a name="ln6824">      if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln6825">        // Remove one item, return its value.</a>
<a name="ln6826">        tv_list_drop_items(l, item, item);</a>
<a name="ln6827">        *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln6828">        xfree(item);</a>
<a name="ln6829">      } else {</a>
<a name="ln6830">        // Remove range of items, return list with values.</a>
<a name="ln6831">        end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6832">        if (error) {</a>
<a name="ln6833">          // Type error: do nothing.</a>
<a name="ln6834">        } else if ((item2 = tv_list_find(l, end)) == NULL) {</a>
<a name="ln6835">          EMSGN(_(e_listidx), end);</a>
<a name="ln6836">        } else {</a>
<a name="ln6837">          int cnt = 0;</a>
<a name="ln6838"> </a>
<a name="ln6839">          for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln6840">            cnt++;</a>
<a name="ln6841">            if (li == item2) {</a>
<a name="ln6842">              break;</a>
<a name="ln6843">            }</a>
<a name="ln6844">          }</a>
<a name="ln6845">          if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln6846">            EMSG(_(e_invrange));</a>
<a name="ln6847">          } else {</a>
<a name="ln6848">            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln6849">                               cnt);</a>
<a name="ln6850">          }</a>
<a name="ln6851">        }</a>
<a name="ln6852">      }</a>
<a name="ln6853">    }</a>
<a name="ln6854">  }</a>
<a name="ln6855">}</a>
<a name="ln6856"> </a>
<a name="ln6857">/*</a>
<a name="ln6858"> * &quot;rename({from}, {to})&quot; function</a>
<a name="ln6859"> */</a>
<a name="ln6860">static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6861">{</a>
<a name="ln6862">  if (check_secure()) {</a>
<a name="ln6863">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln6864">  } else {</a>
<a name="ln6865">    char buf[NUMBUFLEN];</a>
<a name="ln6866">    rettv-&gt;vval.v_number = vim_rename(</a>
<a name="ln6867">        (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln6868">        (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln6869">  }</a>
<a name="ln6870">}</a>
<a name="ln6871"> </a>
<a name="ln6872">/*</a>
<a name="ln6873"> * &quot;repeat()&quot; function</a>
<a name="ln6874"> */</a>
<a name="ln6875">static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6876">{</a>
<a name="ln6877">  varnumber_T n = tv_get_number(&amp;argvars[1]);</a>
<a name="ln6878">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln6879">    tv_list_alloc_ret(rettv, (n &gt; 0) * n * tv_list_len(argvars[0].vval.v_list));</a>
<a name="ln6880">    while (n-- &gt; 0) {</a>
<a name="ln6881">      tv_list_extend(rettv-&gt;vval.v_list, argvars[0].vval.v_list, NULL);</a>
<a name="ln6882">    }</a>
<a name="ln6883">  } else {</a>
<a name="ln6884">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6885">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6886">    if (n &lt;= 0) {</a>
<a name="ln6887">      return;</a>
<a name="ln6888">    }</a>
<a name="ln6889"> </a>
<a name="ln6890">    const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6891"> </a>
<a name="ln6892">    const size_t slen = strlen(p);</a>
<a name="ln6893">    if (slen == 0) {</a>
<a name="ln6894">      return;</a>
<a name="ln6895">    }</a>
<a name="ln6896">    const size_t len = slen * n;</a>
<a name="ln6897">    // Detect overflow.</a>
<a name="ln6898">    if (len / n != slen) {</a>
<a name="ln6899">      return;</a>
<a name="ln6900">    }</a>
<a name="ln6901"> </a>
<a name="ln6902">    char *const r = xmallocz(len);</a>
<a name="ln6903">    for (varnumber_T i = 0; i &lt; n; i++) {</a>
<a name="ln6904">      memmove(r + i * slen, p, slen);</a>
<a name="ln6905">    }</a>
<a name="ln6906"> </a>
<a name="ln6907">    rettv-&gt;vval.v_string = (char_u *)r;</a>
<a name="ln6908">  }</a>
<a name="ln6909">}</a>
<a name="ln6910"> </a>
<a name="ln6911">/*</a>
<a name="ln6912"> * &quot;resolve()&quot; function</a>
<a name="ln6913"> */</a>
<a name="ln6914">static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6915">{</a>
<a name="ln6916">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6917">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6918">#ifdef WIN32</a>
<a name="ln6919">  char *v = os_resolve_shortcut(fname);</a>
<a name="ln6920">  if (v == NULL) {</a>
<a name="ln6921">    if (os_is_reparse_point_include(fname)) {</a>
<a name="ln6922">      v = os_realpath(fname, v);</a>
<a name="ln6923">    }</a>
<a name="ln6924">  }</a>
<a name="ln6925">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln6926">#else</a>
<a name="ln6927"># ifdef HAVE_READLINK</a>
<a name="ln6928">  {</a>
<a name="ln6929">    bool is_relative_to_current = false;</a>
<a name="ln6930">    bool has_trailing_pathsep = false;</a>
<a name="ln6931">    int limit = 100;</a>
<a name="ln6932"> </a>
<a name="ln6933">    char *p = xstrdup(fname);</a>
<a name="ln6934"> </a>
<a name="ln6935">    if (p[0] == '.' &amp;&amp; (vim_ispathsep(p[1])</a>
<a name="ln6936">                        || (p[1] == '.' &amp;&amp; (vim_ispathsep(p[2]))))) {</a>
<a name="ln6937">      is_relative_to_current = true;</a>
<a name="ln6938">    }</a>
<a name="ln6939"> </a>
<a name="ln6940">    ptrdiff_t len = (ptrdiff_t)strlen(p);</a>
<a name="ln6941">    if (len &gt; 1 &amp;&amp; after_pathsep(p, p + len)) {</a>
<a name="ln6942">      has_trailing_pathsep = true;</a>
<a name="ln6943">      p[len - 1] = NUL;  // The trailing slash breaks readlink().</a>
<a name="ln6944">    }</a>
<a name="ln6945"> </a>
<a name="ln6946">    char *q = (char *)path_next_component(p);</a>
<a name="ln6947">    char *remain = NULL;</a>
<a name="ln6948">    if (*q != NUL) {</a>
<a name="ln6949">      // Separate the first path component in &quot;p&quot;, and keep the</a>
<a name="ln6950">      // remainder (beginning with the path separator).</a>
<a name="ln6951">      remain = xstrdup(q - 1);</a>
<a name="ln6952">      q[-1] = NUL;</a>
<a name="ln6953">    }</a>
<a name="ln6954"> </a>
<a name="ln6955">    char *const buf = xmallocz(MAXPATHL);</a>
<a name="ln6956"> </a>
<a name="ln6957">    char *cpy;</a>
<a name="ln6958">    for (;; ) {</a>
<a name="ln6959">      for (;; ) {</a>
<a name="ln6960">        len = readlink(p, buf, MAXPATHL);</a>
<a name="ln6961">        if (len &lt;= 0) {</a>
<a name="ln6962">          break;</a>
<a name="ln6963">        }</a>
<a name="ln6964">        buf[len] = NUL;</a>
<a name="ln6965"> </a>
<a name="ln6966">        if (limit-- == 0) {</a>
<a name="ln6967">          xfree(p);</a>
<a name="ln6968">          xfree(remain);</a>
<a name="ln6969">          EMSG(_(&quot;E655: Too many symbolic links (cycle?)&quot;));</a>
<a name="ln6970">          rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6971">          xfree(buf);</a>
<a name="ln6972">          return;</a>
<a name="ln6973">        }</a>
<a name="ln6974"> </a>
<a name="ln6975">        // Ensure that the result will have a trailing path separator</a>
<a name="ln6976">        // if the argument has one. */</a>
<a name="ln6977">        if (remain == NULL &amp;&amp; has_trailing_pathsep) {</a>
<a name="ln6978">          add_pathsep(buf);</a>
<a name="ln6979">        }</a>
<a name="ln6980"> </a>
<a name="ln6981">        // Separate the first path component in the link value and</a>
<a name="ln6982">        // concatenate the remainders. */</a>
<a name="ln6983">        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);</a>
<a name="ln6984">        if (*q != NUL) {</a>
<a name="ln6985">          cpy = remain;</a>
<a name="ln6986">          remain = (remain</a>
<a name="ln6987">                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)</a>
<a name="ln6988">                    : xstrdup(q - 1));</a>
<a name="ln6989">          xfree(cpy);</a>
<a name="ln6990">          q[-1] = NUL;</a>
<a name="ln6991">        }</a>
<a name="ln6992"> </a>
<a name="ln6993">        q = (char *)path_tail((char_u *)p);</a>
<a name="ln6994">        if (q &gt; p &amp;&amp; *q == NUL) {</a>
<a name="ln6995">          // Ignore trailing path separator.</a>
<a name="ln6996">          q[-1] = NUL;</a>
<a name="ln6997">          q = (char *)path_tail((char_u *)p);</a>
<a name="ln6998">        }</a>
<a name="ln6999">        if (q &gt; p &amp;&amp; !path_is_absolute((const char_u *)buf)) {</a>
<a name="ln7000">          // Symlink is relative to directory of argument. Replace the</a>
<a name="ln7001">          // symlink with the resolved name in the same directory.</a>
<a name="ln7002">          const size_t p_len = strlen(p);</a>
<a name="ln7003">          const size_t buf_len = strlen(buf);</a>
<a name="ln7004">          p = xrealloc(p, p_len + buf_len + 1);</a>
<a name="ln7005">          memcpy(path_tail((char_u *)p), buf, buf_len + 1);</a>
<a name="ln7006">        } else {</a>
<a name="ln7007">          xfree(p);</a>
<a name="ln7008">          p = xstrdup(buf);</a>
<a name="ln7009">        }</a>
<a name="ln7010">      }</a>
<a name="ln7011"> </a>
<a name="ln7012">      if (remain == NULL) {</a>
<a name="ln7013">        break;</a>
<a name="ln7014">      }</a>
<a name="ln7015"> </a>
<a name="ln7016">      // Append the first path component of &quot;remain&quot; to &quot;p&quot;.</a>
<a name="ln7017">      q = (char *)path_next_component(remain + 1);</a>
<a name="ln7018">      len = q - remain - (*q != NUL);</a>
<a name="ln7019">      const size_t p_len = strlen(p);</a>
<a name="ln7020">      cpy = xmallocz(p_len + len);</a>
<a name="ln7021">      memcpy(cpy, p, p_len + 1);</a>
<a name="ln7022">      xstrlcat(cpy + p_len, remain, len + 1);</a>
<a name="ln7023">      xfree(p);</a>
<a name="ln7024">      p = cpy;</a>
<a name="ln7025"> </a>
<a name="ln7026">      // Shorten &quot;remain&quot;.</a>
<a name="ln7027">      if (*q != NUL) {</a>
<a name="ln7028">        STRMOVE(remain, q - 1);</a>
<a name="ln7029">      } else {</a>
<a name="ln7030">        XFREE_CLEAR(remain);</a>
<a name="ln7031">      }</a>
<a name="ln7032">    }</a>
<a name="ln7033"> </a>
<a name="ln7034">    // If the result is a relative path name, make it explicitly relative to</a>
<a name="ln7035">    // the current directory if and only if the argument had this form.</a>
<a name="ln7036">    if (!vim_ispathsep(*p)) {</a>
<a name="ln7037">      if (is_relative_to_current</a>
<a name="ln7038">          &amp;&amp; *p != NUL</a>
<a name="ln7039">          &amp;&amp; !(p[0] == '.'</a>
<a name="ln7040">               &amp;&amp; (p[1] == NUL</a>
<a name="ln7041">                   || vim_ispathsep(p[1])</a>
<a name="ln7042">                   || (p[1] == '.'</a>
<a name="ln7043">                       &amp;&amp; (p[2] == NUL</a>
<a name="ln7044">                           || vim_ispathsep(p[2])))))) {</a>
<a name="ln7045">        // Prepend &quot;./&quot;.</a>
<a name="ln7046">        cpy = (char *)concat_str((const char_u *)&quot;./&quot;, (const char_u *)p);</a>
<a name="ln7047">        xfree(p);</a>
<a name="ln7048">        p = cpy;</a>
<a name="ln7049">      } else if (!is_relative_to_current) {</a>
<a name="ln7050">        // Strip leading &quot;./&quot;.</a>
<a name="ln7051">        q = p;</a>
<a name="ln7052">        while (q[0] == '.' &amp;&amp; vim_ispathsep(q[1])) {</a>
<a name="ln7053">          q += 2;</a>
<a name="ln7054">        }</a>
<a name="ln7055">        if (q &gt; p) {</a>
<a name="ln7056">          STRMOVE(p, p + 2);</a>
<a name="ln7057">        }</a>
<a name="ln7058">      }</a>
<a name="ln7059">    }</a>
<a name="ln7060"> </a>
<a name="ln7061">    // Ensure that the result will have no trailing path separator</a>
<a name="ln7062">    // if the argument had none.  But keep &quot;/&quot; or &quot;//&quot;.</a>
<a name="ln7063">    if (!has_trailing_pathsep) {</a>
<a name="ln7064">      q = p + strlen(p);</a>
<a name="ln7065">      if (after_pathsep(p, q)) {</a>
<a name="ln7066">        *path_tail_with_sep((char_u *)p) = NUL;</a>
<a name="ln7067">      }</a>
<a name="ln7068">    }</a>
<a name="ln7069"> </a>
<a name="ln7070">    rettv-&gt;vval.v_string = (char_u *)p;</a>
<a name="ln7071">    xfree(buf);</a>
<a name="ln7072">  }</a>
<a name="ln7073"># else</a>
<a name="ln7074">  char *v = os_realpath(fname, NULL);</a>
<a name="ln7075">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7076"># endif</a>
<a name="ln7077">#endif</a>
<a name="ln7078"> </a>
<a name="ln7079">  simplify_filename(rettv-&gt;vval.v_string);</a>
<a name="ln7080">}</a>
<a name="ln7081"> </a>
<a name="ln7082">/*</a>
<a name="ln7083"> * &quot;reverse({list})&quot; function</a>
<a name="ln7084"> */</a>
<a name="ln7085">static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7086">{</a>
<a name="ln7087">  list_T *l;</a>
<a name="ln7088">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7089">    EMSG2(_(e_listarg), &quot;reverse()&quot;);</a>
<a name="ln7090">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7091">                            N_(&quot;reverse() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln7092">    tv_list_reverse(l);</a>
<a name="ln7093">    tv_list_set_ret(rettv, l);</a>
<a name="ln7094">  }</a>
<a name="ln7095">}</a>
<a name="ln7096"> </a>
<a name="ln7097">#define SP_NOMOVE       0x01        ///&lt; don't move cursor</a>
<a name="ln7098">#define SP_REPEAT       0x02        ///&lt; repeat to find outer pair</a>
<a name="ln7099">#define SP_RETCOUNT     0x04        ///&lt; return matchcount</a>
<a name="ln7100">#define SP_SETPCMARK    0x08        ///&lt; set previous context mark</a>
<a name="ln7101">#define SP_START        0x10        ///&lt; accept match at start position</a>
<a name="ln7102">#define SP_SUBPAT       0x20        ///&lt; return nr of matching sub-pattern</a>
<a name="ln7103">#define SP_END          0x40        ///&lt; leave cursor at end of match</a>
<a name="ln7104">#define SP_COLUMN       0x80        ///&lt; start at cursor column</a>
<a name="ln7105"> </a>
<a name="ln7106">/*</a>
<a name="ln7107"> * Get flags for a search function.</a>
<a name="ln7108"> * Possibly sets &quot;p_ws&quot;.</a>
<a name="ln7109"> * Returns BACKWARD, FORWARD or zero (for an error).</a>
<a name="ln7110"> */</a>
<a name="ln7111">static int get_search_arg(typval_T *varp, int *flagsp)</a>
<a name="ln7112">{</a>
<a name="ln7113">  int dir = FORWARD;</a>
<a name="ln7114">  int mask;</a>
<a name="ln7115"> </a>
<a name="ln7116">  if (varp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln7117">    char nbuf[NUMBUFLEN];</a>
<a name="ln7118">    const char *flags = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7119">    if (flags == NULL) {</a>
<a name="ln7120">      return 0;  // Type error; errmsg already given.</a>
<a name="ln7121">    }</a>
<a name="ln7122">    while (*flags != NUL) {</a>
<a name="ln7123">      switch (*flags) {</a>
<a name="ln7124">        case 'b': dir = BACKWARD; break;</a>
<a name="ln7125">        case 'w': p_ws = true; break;</a>
<a name="ln7126">        case 'W': p_ws = false; break;</a>
<a name="ln7127">        default: {</a>
<a name="ln7128">          mask = 0;</a>
<a name="ln7129">          if (flagsp != NULL) {</a>
<a name="ln7130">            switch (*flags) {</a>
<a name="ln7131">              case 'c': mask = SP_START; break;</a>
<a name="ln7132">              case 'e': mask = SP_END; break;</a>
<a name="ln7133">              case 'm': mask = SP_RETCOUNT; break;</a>
<a name="ln7134">              case 'n': mask = SP_NOMOVE; break;</a>
<a name="ln7135">              case 'p': mask = SP_SUBPAT; break;</a>
<a name="ln7136">              case 'r': mask = SP_REPEAT; break;</a>
<a name="ln7137">              case 's': mask = SP_SETPCMARK; break;</a>
<a name="ln7138">              case 'z': mask = SP_COLUMN; break;</a>
<a name="ln7139">            }</a>
<a name="ln7140">          }</a>
<a name="ln7141">          if (mask == 0) {</a>
<a name="ln7142">            emsgf(_(e_invarg2), flags);</a>
<a name="ln7143">            dir = 0;</a>
<a name="ln7144">          } else {</a>
<a name="ln7145">            *flagsp |= mask;</a>
<a name="ln7146">          }</a>
<a name="ln7147">        }</a>
<a name="ln7148">      }</a>
<a name="ln7149">      if (dir == 0) {</a>
<a name="ln7150">        break;</a>
<a name="ln7151">      }</a>
<a name="ln7152">      flags++;</a>
<a name="ln7153">    }</a>
<a name="ln7154">  }</a>
<a name="ln7155">  return dir;</a>
<a name="ln7156">}</a>
<a name="ln7157"> </a>
<a name="ln7158">// Shared by search() and searchpos() functions.</a>
<a name="ln7159">static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)</a>
<a name="ln7160">{</a>
<a name="ln7161">  int flags;</a>
<a name="ln7162">  pos_T pos;</a>
<a name="ln7163">  pos_T save_cursor;</a>
<a name="ln7164">  bool save_p_ws = p_ws;</a>
<a name="ln7165">  int dir;</a>
<a name="ln7166">  int retval = 0;               // default: FAIL</a>
<a name="ln7167">  long lnum_stop = 0;</a>
<a name="ln7168">  proftime_T tm;</a>
<a name="ln7169">  long time_limit = 0;</a>
<a name="ln7170">  int options = SEARCH_KEEP;</a>
<a name="ln7171">  int subpatnum;</a>
<a name="ln7172">  searchit_arg_T sia;</a>
<a name="ln7173"> </a>
<a name="ln7174">  const char *const pat = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7175">  dir = get_search_arg(&amp;argvars[1], flagsp);  // May set p_ws.</a>
<a name="ln7176">  if (dir == 0) {</a>
<a name="ln7177">    goto theend;</a>
<a name="ln7178">  }</a>
<a name="ln7179">  flags = *flagsp;</a>
<a name="ln7180">  if (flags &amp; SP_START) {</a>
<a name="ln7181">    options |= SEARCH_START;</a>
<a name="ln7182">  }</a>
<a name="ln7183">  if (flags &amp; SP_END) {</a>
<a name="ln7184">    options |= SEARCH_END;</a>
<a name="ln7185">  }</a>
<a name="ln7186">  if (flags &amp; SP_COLUMN) {</a>
<a name="ln7187">    options |= SEARCH_COL;</a>
<a name="ln7188">  }</a>
<a name="ln7189"> </a>
<a name="ln7190">  // Optional arguments: line number to stop searching and timeout.</a>
<a name="ln7191">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7192">    lnum_stop = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln7193">    if (lnum_stop &lt; 0) {</a>
<a name="ln7194">      goto theend;</a>
<a name="ln7195">    }</a>
<a name="ln7196">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln7197">      time_limit = tv_get_number_chk(&amp;argvars[3], NULL);</a>
<a name="ln7198">      if (time_limit &lt; 0) {</a>
<a name="ln7199">        goto theend;</a>
<a name="ln7200">      }</a>
<a name="ln7201">    }</a>
<a name="ln7202">  }</a>
<a name="ln7203"> </a>
<a name="ln7204">  // Set the time limit, if there is one.</a>
<a name="ln7205">  tm = profile_setlimit(time_limit);</a>
<a name="ln7206"> </a>
<a name="ln7207">  /*</a>
<a name="ln7208">   * This function does not accept SP_REPEAT and SP_RETCOUNT flags.</a>
<a name="ln7209">   * Check to make sure only those flags are set.</a>
<a name="ln7210">   * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both</a>
<a name="ln7211">   * flags cannot be set. Check for that condition also.</a>
<a name="ln7212">   */</a>
<a name="ln7213">  if (((flags &amp; (SP_REPEAT | SP_RETCOUNT)) != 0)</a>
<a name="ln7214">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7215">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[1]));</a>
<a name="ln7216">    goto theend;</a>
<a name="ln7217">  }</a>
<a name="ln7218"> </a>
<a name="ln7219">  pos = save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7220">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7221">  sia.sa_stop_lnum = (linenr_T)lnum_stop;</a>
<a name="ln7222">  sia.sa_tm = &amp;tm;</a>
<a name="ln7223">  subpatnum = searchit(curwin, curbuf, &amp;pos, NULL, dir, (char_u *)pat, 1,</a>
<a name="ln7224">                       options, RE_SEARCH, &amp;sia);</a>
<a name="ln7225">  if (subpatnum != FAIL) {</a>
<a name="ln7226">    if (flags &amp; SP_SUBPAT)</a>
<a name="ln7227">      retval = subpatnum;</a>
<a name="ln7228">    else</a>
<a name="ln7229">      retval = pos.lnum;</a>
<a name="ln7230">    if (flags &amp; SP_SETPCMARK)</a>
<a name="ln7231">      setpcmark();</a>
<a name="ln7232">    curwin-&gt;w_cursor = pos;</a>
<a name="ln7233">    if (match_pos != NULL) {</a>
<a name="ln7234">      // Store the match cursor position</a>
<a name="ln7235">      match_pos-&gt;lnum = pos.lnum;</a>
<a name="ln7236">      match_pos-&gt;col = pos.col + 1;</a>
<a name="ln7237">    }</a>
<a name="ln7238">    // &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln7239">    // correct that here</a>
<a name="ln7240">    check_cursor();</a>
<a name="ln7241">  }</a>
<a name="ln7242"> </a>
<a name="ln7243">  // If 'n' flag is used: restore cursor position.</a>
<a name="ln7244">  if (flags &amp; SP_NOMOVE) {</a>
<a name="ln7245">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7246">  } else {</a>
<a name="ln7247">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7248">  }</a>
<a name="ln7249">theend:</a>
<a name="ln7250">  p_ws = save_p_ws;</a>
<a name="ln7251"> </a>
<a name="ln7252">  return retval;</a>
<a name="ln7253">}</a>
<a name="ln7254"> </a>
<a name="ln7255">// &quot;rpcnotify()&quot; function</a>
<a name="ln7256">static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7257">{</a>
<a name="ln7258">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7259">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7260"> </a>
<a name="ln7261">  if (check_secure()) {</a>
<a name="ln7262">    return;</a>
<a name="ln7263">  }</a>
<a name="ln7264"> </a>
<a name="ln7265">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt; 0) {</a>
<a name="ln7266">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7267">    return;</a>
<a name="ln7268">  }</a>
<a name="ln7269"> </a>
<a name="ln7270">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7271">    EMSG2(_(e_invarg2), &quot;Event type must be a string&quot;);</a>
<a name="ln7272">    return;</a>
<a name="ln7273">  }</a>
<a name="ln7274"> </a>
<a name="ln7275">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7276"> </a>
<a name="ln7277">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7278">    ADD(args, vim_to_object(tv));</a>
<a name="ln7279">  }</a>
<a name="ln7280"> </a>
<a name="ln7281">  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,</a>
<a name="ln7282">                      tv_get_string(&amp;argvars[1]), args)) {</a>
<a name="ln7283">    EMSG2(_(e_invarg2), &quot;Channel doesn't exist&quot;);</a>
<a name="ln7284">    return;</a>
<a name="ln7285">  }</a>
<a name="ln7286"> </a>
<a name="ln7287">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln7288">}</a>
<a name="ln7289"> </a>
<a name="ln7290">// &quot;rpcrequest()&quot; function</a>
<a name="ln7291">static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7292">{</a>
<a name="ln7293">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7294">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7295">  const int l_provider_call_nesting = provider_call_nesting;</a>
<a name="ln7296"> </a>
<a name="ln7297">  if (check_secure()) {</a>
<a name="ln7298">    return;</a>
<a name="ln7299">  }</a>
<a name="ln7300"> </a>
<a name="ln7301">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt;= 0) {</a>
<a name="ln7302">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7303">    return;</a>
<a name="ln7304">  }</a>
<a name="ln7305"> </a>
<a name="ln7306">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7307">    EMSG2(_(e_invarg2), &quot;Method name must be a string&quot;);</a>
<a name="ln7308">    return;</a>
<a name="ln7309">  }</a>
<a name="ln7310"> </a>
<a name="ln7311">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7312"> </a>
<a name="ln7313">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7314">    ADD(args, vim_to_object(tv));</a>
<a name="ln7315">  }</a>
<a name="ln7316"> </a>
<a name="ln7317">  sctx_T save_current_sctx;</a>
<a name="ln7318">  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;</a>
<a name="ln7319">  linenr_T save_sourcing_lnum;</a>
<a name="ln7320">  int save_autocmd_bufnr;</a>
<a name="ln7321">  funccal_entry_T funccal_entry;</a>
<a name="ln7322"> </a>
<a name="ln7323">  if (l_provider_call_nesting) {</a>
<a name="ln7324">    // If this is called from a provider function, restore the scope</a>
<a name="ln7325">    // information of the caller.</a>
<a name="ln7326">    save_current_sctx = current_sctx;</a>
<a name="ln7327">    save_sourcing_name = sourcing_name;</a>
<a name="ln7328">    save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln7329">    save_autocmd_fname = autocmd_fname;</a>
<a name="ln7330">    save_autocmd_match = autocmd_match;</a>
<a name="ln7331">    save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln7332">    save_funccal(&amp;funccal_entry);</a>
<a name="ln7333"> </a>
<a name="ln7334">    current_sctx = provider_caller_scope.script_ctx;</a>
<a name="ln7335">    sourcing_name = provider_caller_scope.sourcing_name;</a>
<a name="ln7336">    sourcing_lnum = provider_caller_scope.sourcing_lnum;</a>
<a name="ln7337">    autocmd_fname = provider_caller_scope.autocmd_fname;</a>
<a name="ln7338">    autocmd_match = provider_caller_scope.autocmd_match;</a>
<a name="ln7339">    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;</a>
<a name="ln7340">    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));</a>
<a name="ln7341">  }</a>
<a name="ln7342"> </a>
<a name="ln7343"> </a>
<a name="ln7344">  Error err = ERROR_INIT;</a>
<a name="ln7345"> </a>
<a name="ln7346">  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;</a>
<a name="ln7347">  const char *method = tv_get_string(&amp;argvars[1]);</a>
<a name="ln7348"> </a>
<a name="ln7349">  Object result = rpc_send_call(chan_id, method, args, &amp;err);</a>
<a name="ln7350"> </a>
<a name="ln7351">  if (l_provider_call_nesting) {</a>
<a name="ln7352">    current_sctx = save_current_sctx;</a>
<a name="ln7353">    sourcing_name = save_sourcing_name;</a>
<a name="ln7354">    sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7355">    autocmd_fname = save_autocmd_fname;</a>
<a name="ln7356">    autocmd_match = save_autocmd_match;</a>
<a name="ln7357">    autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7358">    restore_funccal();</a>
<a name="ln7359">  }</a>
<a name="ln7360"> </a>
<a name="ln7361">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7362">    const char *name = NULL;</a>
<a name="ln7363">    Channel *chan = find_channel(chan_id);</a>
<a name="ln7364">    if (chan) {</a>
<a name="ln7365">      name = rpc_client_name(chan);</a>
<a name="ln7366">    }</a>
<a name="ln7367">    msg_ext_set_kind(&quot;rpc_error&quot;);</a>
<a name="ln7368">    if (name) {</a>
<a name="ln7369">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot; (%s):\n%s&quot;,</a>
<a name="ln7370">                      method, chan_id, name, err.msg);</a>
<a name="ln7371">    } else {</a>
<a name="ln7372">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot;:\n%s&quot;,</a>
<a name="ln7373">                      method, chan_id, err.msg);</a>
<a name="ln7374">    }</a>
<a name="ln7375"> </a>
<a name="ln7376">    goto end;</a>
<a name="ln7377">  }</a>
<a name="ln7378"> </a>
<a name="ln7379">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln7380">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln7381">  }</a>
<a name="ln7382"> </a>
<a name="ln7383">end:</a>
<a name="ln7384">  api_free_object(result);</a>
<a name="ln7385">  api_clear_error(&amp;err);</a>
<a name="ln7386">}</a>
<a name="ln7387"> </a>
<a name="ln7388">// &quot;rpcstart()&quot; function (DEPRECATED)</a>
<a name="ln7389">static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7390">{</a>
<a name="ln7391">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7392">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7393"> </a>
<a name="ln7394">  if (check_secure()) {</a>
<a name="ln7395">    return;</a>
<a name="ln7396">  }</a>
<a name="ln7397"> </a>
<a name="ln7398">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln7399">      || (argvars[1].v_type != VAR_LIST &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln7400">    // Wrong argument types</a>
<a name="ln7401">    EMSG(_(e_invarg));</a>
<a name="ln7402">    return;</a>
<a name="ln7403">  }</a>
<a name="ln7404"> </a>
<a name="ln7405">  list_T *args = NULL;</a>
<a name="ln7406">  int argsl = 0;</a>
<a name="ln7407">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln7408">    args = argvars[1].vval.v_list;</a>
<a name="ln7409">    argsl = tv_list_len(args);</a>
<a name="ln7410">    // Assert that all list items are strings</a>
<a name="ln7411">    int i = 0;</a>
<a name="ln7412">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7413">      if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_STRING) {</a>
<a name="ln7414">        emsgf(_(&quot;E5010: List item %d of the second argument is not a string&quot;),</a>
<a name="ln7415">              i);</a>
<a name="ln7416">        return;</a>
<a name="ln7417">      }</a>
<a name="ln7418">      i++;</a>
<a name="ln7419">    });</a>
<a name="ln7420">  }</a>
<a name="ln7421"> </a>
<a name="ln7422">  if (argvars[0].vval.v_string == NULL || argvars[0].vval.v_string[0] == NUL) {</a>
<a name="ln7423">    EMSG(_(e_api_spawn_failed));</a>
<a name="ln7424">    return;</a>
<a name="ln7425">  }</a>
<a name="ln7426"> </a>
<a name="ln7427">  // Allocate extra memory for the argument vector and the NULL pointer</a>
<a name="ln7428">  int argvl = argsl + 2;</a>
<a name="ln7429">  char **argv = xmalloc(sizeof(char_u *) * argvl);</a>
<a name="ln7430"> </a>
<a name="ln7431">  // Copy program name</a>
<a name="ln7432">  argv[0] = xstrdup((char *)argvars[0].vval.v_string);</a>
<a name="ln7433"> </a>
<a name="ln7434">  int i = 1;</a>
<a name="ln7435">  // Copy arguments to the vector</a>
<a name="ln7436">  if (argsl &gt; 0) {</a>
<a name="ln7437">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7438">      argv[i++] = xstrdup(tv_get_string(TV_LIST_ITEM_TV(arg)));</a>
<a name="ln7439">    });</a>
<a name="ln7440">  }</a>
<a name="ln7441"> </a>
<a name="ln7442">  // The last item of argv must be NULL</a>
<a name="ln7443">  argv[i] = NULL;</a>
<a name="ln7444"> </a>
<a name="ln7445">  Channel *chan = channel_job_start(argv, CALLBACK_READER_INIT,</a>
<a name="ln7446">                                    CALLBACK_READER_INIT, CALLBACK_NONE,</a>
<a name="ln7447">                                    false, true, false, false, NULL, 0, 0,</a>
<a name="ln7448">                                    NULL, NULL, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln7449">  if (chan) {</a>
<a name="ln7450">    channel_create_event(chan, NULL);</a>
<a name="ln7451">  }</a>
<a name="ln7452">}</a>
<a name="ln7453"> </a>
<a name="ln7454">// &quot;rpcstop()&quot; function</a>
<a name="ln7455">static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7456">{</a>
<a name="ln7457">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7458">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7459"> </a>
<a name="ln7460">  if (check_secure()) {</a>
<a name="ln7461">    return;</a>
<a name="ln7462">  }</a>
<a name="ln7463"> </a>
<a name="ln7464">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln7465">    // Wrong argument types</a>
<a name="ln7466">    EMSG(_(e_invarg));</a>
<a name="ln7467">    return;</a>
<a name="ln7468">  }</a>
<a name="ln7469"> </a>
<a name="ln7470">  // if called with a job, stop it, else closes the channel</a>
<a name="ln7471">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln7472">  if (find_job(id, false)) {</a>
<a name="ln7473">    f_jobstop(argvars, rettv, NULL);</a>
<a name="ln7474">  } else {</a>
<a name="ln7475">    const char *error;</a>
<a name="ln7476">    rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number,</a>
<a name="ln7477">                                         kChannelPartRpc, &amp;error);</a>
<a name="ln7478">    if (!rettv-&gt;vval.v_number) {</a>
<a name="ln7479">      EMSG(error);</a>
<a name="ln7480">    }</a>
<a name="ln7481">  }</a>
<a name="ln7482">}</a>
<a name="ln7483"> </a>
<a name="ln7484">/*</a>
<a name="ln7485"> * &quot;screenattr()&quot; function</a>
<a name="ln7486"> */</a>
<a name="ln7487">static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7488">{</a>
<a name="ln7489">  int c;</a>
<a name="ln7490"> </a>
<a name="ln7491">  int row = (int)tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7492">  int col = (int)tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7493">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7494">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7495">    c = -1;</a>
<a name="ln7496">  } else {</a>
<a name="ln7497">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7498">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7499">    c = grid-&gt;attrs[grid-&gt;line_offset[row] + col];</a>
<a name="ln7500">  }</a>
<a name="ln7501">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7502">}</a>
<a name="ln7503"> </a>
<a name="ln7504">/*</a>
<a name="ln7505"> * &quot;screenchar()&quot; function</a>
<a name="ln7506"> */</a>
<a name="ln7507">static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7508">{</a>
<a name="ln7509">  int c;</a>
<a name="ln7510"> </a>
<a name="ln7511">  int row = tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7512">  int col = tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7513">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7514">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7515">    c = -1;</a>
<a name="ln7516">  } else {</a>
<a name="ln7517">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7518">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7519">    c = utf_ptr2char(grid-&gt;chars[grid-&gt;line_offset[row] + col]);</a>
<a name="ln7520">  }</a>
<a name="ln7521">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7522">}</a>
<a name="ln7523"> </a>
<a name="ln7524">/*</a>
<a name="ln7525"> * &quot;screencol()&quot; function</a>
<a name="ln7526"> *</a>
<a name="ln7527"> * First column is 1 to be consistent with virtcol().</a>
<a name="ln7528"> */</a>
<a name="ln7529">static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7530">{</a>
<a name="ln7531">  rettv-&gt;vval.v_number = ui_current_col() + 1;</a>
<a name="ln7532">}</a>
<a name="ln7533"> </a>
<a name="ln7534">/// &quot;screenpos({winid}, {lnum}, {col})&quot; function</a>
<a name="ln7535">static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7536">{</a>
<a name="ln7537">  pos_T pos;</a>
<a name="ln7538">  int row = 0;</a>
<a name="ln7539">  int scol = 0, ccol = 0, ecol = 0;</a>
<a name="ln7540"> </a>
<a name="ln7541">  tv_dict_alloc_ret(rettv);</a>
<a name="ln7542">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln7543"> </a>
<a name="ln7544">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7545">  if (wp == NULL) {</a>
<a name="ln7546">    return;</a>
<a name="ln7547">  }</a>
<a name="ln7548"> </a>
<a name="ln7549">  pos.lnum = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7550">  pos.col = tv_get_number(&amp;argvars[2]) - 1;</a>
<a name="ln7551">  pos.coladd = 0;</a>
<a name="ln7552">  textpos2screenpos(wp, &amp;pos, &amp;row, &amp;scol, &amp;ccol, &amp;ecol, false);</a>
<a name="ln7553"> </a>
<a name="ln7554">  tv_dict_add_nr(dict, S_LEN(&quot;row&quot;), row);</a>
<a name="ln7555">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), scol);</a>
<a name="ln7556">  tv_dict_add_nr(dict, S_LEN(&quot;curscol&quot;), ccol);</a>
<a name="ln7557">  tv_dict_add_nr(dict, S_LEN(&quot;endcol&quot;), ecol);</a>
<a name="ln7558">}</a>
<a name="ln7559"> </a>
<a name="ln7560">/*</a>
<a name="ln7561"> * &quot;screenrow()&quot; function</a>
<a name="ln7562"> */</a>
<a name="ln7563">static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7564">{</a>
<a name="ln7565">  rettv-&gt;vval.v_number = ui_current_row() + 1;</a>
<a name="ln7566">}</a>
<a name="ln7567"> </a>
<a name="ln7568">/*</a>
<a name="ln7569"> * &quot;search()&quot; function</a>
<a name="ln7570"> */</a>
<a name="ln7571">static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7572">{</a>
<a name="ln7573">  int flags = 0;</a>
<a name="ln7574"> </a>
<a name="ln7575">  rettv-&gt;vval.v_number = search_cmn(argvars, NULL, &amp;flags);</a>
<a name="ln7576">}</a>
<a name="ln7577"> </a>
<a name="ln7578">/*</a>
<a name="ln7579"> * &quot;searchdecl()&quot; function</a>
<a name="ln7580"> */</a>
<a name="ln7581">static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7582">{</a>
<a name="ln7583">  int locally = 1;</a>
<a name="ln7584">  int thisblock = 0;</a>
<a name="ln7585">  bool error = false;</a>
<a name="ln7586"> </a>
<a name="ln7587">  rettv-&gt;vval.v_number = 1;     // default: FAIL</a>
<a name="ln7588"> </a>
<a name="ln7589">  const char *const name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7590">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln7591">    locally = tv_get_number_chk(&amp;argvars[1], &amp;error) == 0;</a>
<a name="ln7592">    if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7593">      thisblock = tv_get_number_chk(&amp;argvars[2], &amp;error) != 0;</a>
<a name="ln7594">    }</a>
<a name="ln7595">  }</a>
<a name="ln7596">  if (!error &amp;&amp; name != NULL) {</a>
<a name="ln7597">    rettv-&gt;vval.v_number = find_decl((char_u *)name, strlen(name), locally,</a>
<a name="ln7598">                                     thisblock, SEARCH_KEEP) == FAIL;</a>
<a name="ln7599">  }</a>
<a name="ln7600">}</a>
<a name="ln7601"> </a>
<a name="ln7602">/*</a>
<a name="ln7603"> * Used by searchpair() and searchpairpos()</a>
<a name="ln7604"> */</a>
<a name="ln7605">static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)</a>
<a name="ln7606">{</a>
<a name="ln7607">  bool save_p_ws = p_ws;</a>
<a name="ln7608">  int dir;</a>
<a name="ln7609">  int flags = 0;</a>
<a name="ln7610">  int retval = 0;  // default: FAIL</a>
<a name="ln7611">  long lnum_stop = 0;</a>
<a name="ln7612">  long time_limit = 0;</a>
<a name="ln7613"> </a>
<a name="ln7614">  // Get the three pattern arguments: start, middle, end. Will result in an</a>
<a name="ln7615">  // error if not a valid argument.</a>
<a name="ln7616">  char nbuf1[NUMBUFLEN];</a>
<a name="ln7617">  char nbuf2[NUMBUFLEN];</a>
<a name="ln7618">  const char *spat = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7619">  const char *mpat = tv_get_string_buf_chk(&amp;argvars[1], nbuf1);</a>
<a name="ln7620">  const char *epat = tv_get_string_buf_chk(&amp;argvars[2], nbuf2);</a>
<a name="ln7621">  if (spat == NULL || mpat == NULL || epat == NULL) {</a>
<a name="ln7622">    goto theend;  // Type error.</a>
<a name="ln7623">  }</a>
<a name="ln7624"> </a>
<a name="ln7625">  // Handle the optional fourth argument: flags.</a>
<a name="ln7626">  dir = get_search_arg(&amp;argvars[3], &amp;flags);   // may set p_ws.</a>
<a name="ln7627">  if (dir == 0) {</a>
<a name="ln7628">    goto theend;</a>
<a name="ln7629">  }</a>
<a name="ln7630"> </a>
<a name="ln7631">  // Don't accept SP_END or SP_SUBPAT.</a>
<a name="ln7632">  // Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.</a>
<a name="ln7633">  if ((flags &amp; (SP_END | SP_SUBPAT)) != 0</a>
<a name="ln7634">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7635">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[3]));</a>
<a name="ln7636">    goto theend;</a>
<a name="ln7637">  }</a>
<a name="ln7638"> </a>
<a name="ln7639">  // Using 'r' implies 'W', otherwise it doesn't work.</a>
<a name="ln7640">  if (flags &amp; SP_REPEAT) {</a>
<a name="ln7641">    p_ws = false;</a>
<a name="ln7642">  }</a>
<a name="ln7643"> </a>
<a name="ln7644">  // Optional fifth argument: skip expression.</a>
<a name="ln7645">  const typval_T *skip;</a>
<a name="ln7646">  if (argvars[3].v_type == VAR_UNKNOWN</a>
<a name="ln7647">      || argvars[4].v_type == VAR_UNKNOWN) {</a>
<a name="ln7648">    skip = NULL;</a>
<a name="ln7649">  } else {</a>
<a name="ln7650">    skip = &amp;argvars[4];</a>
<a name="ln7651">    if (skip-&gt;v_type != VAR_FUNC</a>
<a name="ln7652">        &amp;&amp; skip-&gt;v_type != VAR_PARTIAL</a>
<a name="ln7653">        &amp;&amp; skip-&gt;v_type != VAR_STRING) {</a>
<a name="ln7654">      emsgf(_(e_invarg2), tv_get_string(&amp;argvars[4]));</a>
<a name="ln7655">      goto theend;  // Type error.</a>
<a name="ln7656">    }</a>
<a name="ln7657">    if (argvars[5].v_type != VAR_UNKNOWN) {</a>
<a name="ln7658">      lnum_stop = tv_get_number_chk(&amp;argvars[5], NULL);</a>
<a name="ln7659">      if (lnum_stop &lt; 0) {</a>
<a name="ln7660">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[5]));</a>
<a name="ln7661">        goto theend;</a>
<a name="ln7662">      }</a>
<a name="ln7663">      if (argvars[6].v_type != VAR_UNKNOWN) {</a>
<a name="ln7664">        time_limit = tv_get_number_chk(&amp;argvars[6], NULL);</a>
<a name="ln7665">        if (time_limit &lt; 0) {</a>
<a name="ln7666">          emsgf(_(e_invarg2), tv_get_string(&amp;argvars[6]));</a>
<a name="ln7667">          goto theend;</a>
<a name="ln7668">        }</a>
<a name="ln7669">      }</a>
<a name="ln7670">    }</a>
<a name="ln7671">  }</a>
<a name="ln7672"> </a>
<a name="ln7673">  retval = do_searchpair(</a>
<a name="ln7674">      spat, mpat, epat, dir, skip,</a>
<a name="ln7675">      flags, match_pos, lnum_stop, time_limit);</a>
<a name="ln7676"> </a>
<a name="ln7677">theend:</a>
<a name="ln7678">  p_ws = save_p_ws;</a>
<a name="ln7679"> </a>
<a name="ln7680">  return retval;</a>
<a name="ln7681">}</a>
<a name="ln7682"> </a>
<a name="ln7683">/*</a>
<a name="ln7684"> * &quot;searchpair()&quot; function</a>
<a name="ln7685"> */</a>
<a name="ln7686">static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7687">{</a>
<a name="ln7688">  rettv-&gt;vval.v_number = searchpair_cmn(argvars, NULL);</a>
<a name="ln7689">}</a>
<a name="ln7690"> </a>
<a name="ln7691">/*</a>
<a name="ln7692"> * &quot;searchpairpos()&quot; function</a>
<a name="ln7693"> */</a>
<a name="ln7694">static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7695">{</a>
<a name="ln7696">  pos_T match_pos;</a>
<a name="ln7697">  int lnum = 0;</a>
<a name="ln7698">  int col = 0;</a>
<a name="ln7699"> </a>
<a name="ln7700">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7701"> </a>
<a name="ln7702">  if (searchpair_cmn(argvars, &amp;match_pos) &gt; 0) {</a>
<a name="ln7703">    lnum = match_pos.lnum;</a>
<a name="ln7704">    col = match_pos.col;</a>
<a name="ln7705">  }</a>
<a name="ln7706"> </a>
<a name="ln7707">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7708">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7709">}</a>
<a name="ln7710"> </a>
<a name="ln7711">/*</a>
<a name="ln7712"> * Search for a start/middle/end thing.</a>
<a name="ln7713"> * Used by searchpair(), see its documentation for the details.</a>
<a name="ln7714"> * Returns 0 or -1 for no match,</a>
<a name="ln7715"> */</a>
<a name="ln7716">long</a>
<a name="ln7717">do_searchpair(</a>
<a name="ln7718">    const char *spat,      // start pattern</a>
<a name="ln7719">    const char *mpat,      // middle pattern</a>
<a name="ln7720">    const char *epat,      // end pattern</a>
<a name="ln7721">    int dir,               // BACKWARD or FORWARD</a>
<a name="ln7722">    const typval_T *skip,  // skip expression</a>
<a name="ln7723">    int flags,             // SP_SETPCMARK and other SP_ values</a>
<a name="ln7724">    pos_T *match_pos,</a>
<a name="ln7725">    linenr_T lnum_stop,    // stop at this line if not zero</a>
<a name="ln7726">    long time_limit        // stop after this many msec</a>
<a name="ln7727">)</a>
<a name="ln7728">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln7729">{</a>
<a name="ln7730">  char_u      *save_cpo;</a>
<a name="ln7731">  char_u      *pat, *pat2 = NULL, *pat3 = NULL;</a>
<a name="ln7732">  long retval = 0;</a>
<a name="ln7733">  pos_T pos;</a>
<a name="ln7734">  pos_T firstpos;</a>
<a name="ln7735">  pos_T foundpos;</a>
<a name="ln7736">  pos_T save_cursor;</a>
<a name="ln7737">  pos_T save_pos;</a>
<a name="ln7738">  int n;</a>
<a name="ln7739">  int nest = 1;</a>
<a name="ln7740">  bool use_skip = false;</a>
<a name="ln7741">  int options = SEARCH_KEEP;</a>
<a name="ln7742">  proftime_T tm;</a>
<a name="ln7743"> </a>
<a name="ln7744">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln7745">  save_cpo = p_cpo;</a>
<a name="ln7746">  p_cpo = empty_option;</a>
<a name="ln7747"> </a>
<a name="ln7748">  // Set the time limit, if there is one.</a>
<a name="ln7749">  tm = profile_setlimit(time_limit);</a>
<a name="ln7750"> </a>
<a name="ln7751">  // Make two search patterns: start/end (pat2, for in nested pairs) and</a>
<a name="ln7752">  // start/middle/end (pat3, for the top pair).</a>
<a name="ln7753">  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;</a>
<a name="ln7754">  pat2 = xmalloc(pat2_len);</a>
<a name="ln7755">  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;</a>
<a name="ln7756">  pat3 = xmalloc(pat3_len);</a>
<a name="ln7757">  snprintf((char *)pat2, pat2_len, &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat);</a>
<a name="ln7758">  if (*mpat == NUL) {</a>
<a name="ln7759">    STRCPY(pat3, pat2);</a>
<a name="ln7760">  } else {</a>
<a name="ln7761">    snprintf((char *)pat3, pat3_len,</a>
<a name="ln7762">             &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat, mpat);</a>
<a name="ln7763">  }</a>
<a name="ln7764">  if (flags &amp; SP_START) {</a>
<a name="ln7765">    options |= SEARCH_START;</a>
<a name="ln7766">  }</a>
<a name="ln7767"> </a>
<a name="ln7768">  if (skip != NULL) {</a>
<a name="ln7769">    // Empty string means to not use the skip expression.</a>
<a name="ln7770">    if (skip-&gt;v_type == VAR_STRING || skip-&gt;v_type == VAR_FUNC) {</a>
<a name="ln7771">      use_skip = skip-&gt;vval.v_string != NULL &amp;&amp; *skip-&gt;vval.v_string != NUL;</a>
<a name="ln7772">    }</a>
<a name="ln7773">  }</a>
<a name="ln7774"> </a>
<a name="ln7775">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7776">  pos = curwin-&gt;w_cursor;</a>
<a name="ln7777">  clearpos(&amp;firstpos);</a>
<a name="ln7778">  clearpos(&amp;foundpos);</a>
<a name="ln7779">  pat = pat3;</a>
<a name="ln7780">  for (;; ) {</a>
<a name="ln7781">    searchit_arg_T sia;</a>
<a name="ln7782">    memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7783">    sia.sa_stop_lnum = lnum_stop;</a>
<a name="ln7784">    sia.sa_tm = &amp;tm;</a>
<a name="ln7785"> </a>
<a name="ln7786">    n = searchit(curwin, curbuf, &amp;pos, NULL, dir, pat, 1L,</a>
<a name="ln7787">                 options, RE_SEARCH, &amp;sia);</a>
<a name="ln7788">    if (n == FAIL || (firstpos.lnum != 0 &amp;&amp; equalpos(pos, firstpos))) {</a>
<a name="ln7789">      // didn't find it or found the first match again: FAIL</a>
<a name="ln7790">      break;</a>
<a name="ln7791">    }</a>
<a name="ln7792"> </a>
<a name="ln7793">    if (firstpos.lnum == 0)</a>
<a name="ln7794">      firstpos = pos;</a>
<a name="ln7795">    if (equalpos(pos, foundpos)) {</a>
<a name="ln7796">      // Found the same position again.  Can happen with a pattern that</a>
<a name="ln7797">      // has &quot;\zs&quot; at the end and searching backwards.  Advance one</a>
<a name="ln7798">      // character and try again.</a>
<a name="ln7799">      if (dir == BACKWARD) {</a>
<a name="ln7800">        decl(&amp;pos);</a>
<a name="ln7801">      } else {</a>
<a name="ln7802">        incl(&amp;pos);</a>
<a name="ln7803">      }</a>
<a name="ln7804">    }</a>
<a name="ln7805">    foundpos = pos;</a>
<a name="ln7806"> </a>
<a name="ln7807">    // clear the start flag to avoid getting stuck here</a>
<a name="ln7808">    options &amp;= ~SEARCH_START;</a>
<a name="ln7809"> </a>
<a name="ln7810">    // If the skip pattern matches, ignore this match.</a>
<a name="ln7811">    if (use_skip) {</a>
<a name="ln7812">      save_pos = curwin-&gt;w_cursor;</a>
<a name="ln7813">      curwin-&gt;w_cursor = pos;</a>
<a name="ln7814">      bool err = false;</a>
<a name="ln7815">      const bool r = eval_expr_to_bool(skip, &amp;err);</a>
<a name="ln7816">      curwin-&gt;w_cursor = save_pos;</a>
<a name="ln7817">      if (err) {</a>
<a name="ln7818">        // Evaluating {skip} caused an error, break here.</a>
<a name="ln7819">        curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7820">        retval = -1;</a>
<a name="ln7821">        break;</a>
<a name="ln7822">      }</a>
<a name="ln7823">      if (r)</a>
<a name="ln7824">        continue;</a>
<a name="ln7825">    }</a>
<a name="ln7826"> </a>
<a name="ln7827">    if ((dir == BACKWARD &amp;&amp; n == 3) || (dir == FORWARD &amp;&amp; n == 2)) {</a>
<a name="ln7828">      // Found end when searching backwards or start when searching</a>
<a name="ln7829">      // forward: nested pair.</a>
<a name="ln7830">      nest++;</a>
<a name="ln7831">      pat = pat2;               // nested, don't search for middle</a>
<a name="ln7832">    } else {</a>
<a name="ln7833">      // Found end when searching forward or start when searching</a>
<a name="ln7834">      // backward: end of (nested) pair; or found middle in outer pair.</a>
<a name="ln7835">      if (--nest == 1) {</a>
<a name="ln7836">        pat = pat3;             // outer level, search for middle</a>
<a name="ln7837">      }</a>
<a name="ln7838">    }</a>
<a name="ln7839"> </a>
<a name="ln7840">    if (nest == 0) {</a>
<a name="ln7841">      // Found the match: return matchcount or line number.</a>
<a name="ln7842">      if (flags &amp; SP_RETCOUNT) {</a>
<a name="ln7843">        retval++;</a>
<a name="ln7844">      } else {</a>
<a name="ln7845">        retval = pos.lnum;</a>
<a name="ln7846">      }</a>
<a name="ln7847">      if (flags &amp; SP_SETPCMARK) {</a>
<a name="ln7848">        setpcmark();</a>
<a name="ln7849">      }</a>
<a name="ln7850">      curwin-&gt;w_cursor = pos;</a>
<a name="ln7851">      if (!(flags &amp; SP_REPEAT))</a>
<a name="ln7852">        break;</a>
<a name="ln7853">      nest = 1;             // search for next unmatched</a>
<a name="ln7854">    }</a>
<a name="ln7855">  }</a>
<a name="ln7856"> </a>
<a name="ln7857">  if (match_pos != NULL) {</a>
<a name="ln7858">    // Store the match cursor position</a>
<a name="ln7859">    match_pos-&gt;lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln7860">    match_pos-&gt;col = curwin-&gt;w_cursor.col + 1;</a>
<a name="ln7861">  }</a>
<a name="ln7862"> </a>
<a name="ln7863">  // If 'n' flag is used or search failed: restore cursor position.</a>
<a name="ln7864">  if ((flags &amp; SP_NOMOVE) || retval == 0) {</a>
<a name="ln7865">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7866">  }</a>
<a name="ln7867"> </a>
<a name="ln7868">  xfree(pat2);</a>
<a name="ln7869">  xfree(pat3);</a>
<a name="ln7870">  if (p_cpo == empty_option) {</a>
<a name="ln7871">    p_cpo = save_cpo;</a>
<a name="ln7872">  } else {</a>
<a name="ln7873">    // Darn, evaluating the {skip} expression changed the value.</a>
<a name="ln7874">    free_string_option(save_cpo);</a>
<a name="ln7875">  }</a>
<a name="ln7876"> </a>
<a name="ln7877">  return retval;</a>
<a name="ln7878">}</a>
<a name="ln7879"> </a>
<a name="ln7880">/*</a>
<a name="ln7881"> * &quot;searchpos()&quot; function</a>
<a name="ln7882"> */</a>
<a name="ln7883">static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7884">{</a>
<a name="ln7885">  pos_T match_pos;</a>
<a name="ln7886">  int flags = 0;</a>
<a name="ln7887"> </a>
<a name="ln7888">  const int n = search_cmn(argvars, &amp;match_pos, &amp;flags);</a>
<a name="ln7889"> </a>
<a name="ln7890">  tv_list_alloc_ret(rettv, 2 + (!!(flags &amp; SP_SUBPAT)));</a>
<a name="ln7891"> </a>
<a name="ln7892">  const int lnum = (n &gt; 0 ? match_pos.lnum : 0);</a>
<a name="ln7893">  const int col = (n &gt; 0 ? match_pos.col : 0);</a>
<a name="ln7894"> </a>
<a name="ln7895">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7896">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7897">  if (flags &amp; SP_SUBPAT) {</a>
<a name="ln7898">    tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)n);</a>
<a name="ln7899">  }</a>
<a name="ln7900">}</a>
<a name="ln7901"> </a>
<a name="ln7902">/// &quot;serverlist()&quot; function</a>
<a name="ln7903">static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7904">{</a>
<a name="ln7905">  size_t n;</a>
<a name="ln7906">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln7907"> </a>
<a name="ln7908">  // Copy addrs into a linked list.</a>
<a name="ln7909">  list_T *const l = tv_list_alloc_ret(rettv, n);</a>
<a name="ln7910">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln7911">    tv_list_append_allocated_string(l, addrs[i]);</a>
<a name="ln7912">  }</a>
<a name="ln7913">  xfree(addrs);</a>
<a name="ln7914">}</a>
<a name="ln7915"> </a>
<a name="ln7916">/// &quot;serverstart()&quot; function</a>
<a name="ln7917">static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7918">{</a>
<a name="ln7919">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7920">  rettv-&gt;vval.v_string = NULL;  // Address of the new server</a>
<a name="ln7921"> </a>
<a name="ln7922">  if (check_secure()) {</a>
<a name="ln7923">    return;</a>
<a name="ln7924">  }</a>
<a name="ln7925"> </a>
<a name="ln7926">  char *address;</a>
<a name="ln7927">  // If the user supplied an address, use it, otherwise use a temp.</a>
<a name="ln7928">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln7929">    if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln7930">      EMSG(_(e_invarg));</a>
<a name="ln7931">      return;</a>
<a name="ln7932">    } else {</a>
<a name="ln7933">      address = xstrdup(tv_get_string(argvars));</a>
<a name="ln7934">    }</a>
<a name="ln7935">  } else {</a>
<a name="ln7936">    address = server_address_new();</a>
<a name="ln7937">  }</a>
<a name="ln7938"> </a>
<a name="ln7939">  int result = server_start(address);</a>
<a name="ln7940">  xfree(address);</a>
<a name="ln7941"> </a>
<a name="ln7942">  if (result != 0) {</a>
<a name="ln7943">    EMSG2(&quot;Failed to start server: %s&quot;,</a>
<a name="ln7944">          result &gt; 0 ? &quot;Unknown system error&quot; : uv_strerror(result));</a>
<a name="ln7945">    return;</a>
<a name="ln7946">  }</a>
<a name="ln7947"> </a>
<a name="ln7948">  // Since it's possible server_start adjusted the given {address} (e.g.,</a>
<a name="ln7949">  // &quot;localhost:&quot; will now have a port), return the final value to the user.</a>
<a name="ln7950">  size_t n;</a>
<a name="ln7951">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln7952">  rettv-&gt;vval.v_string = (char_u *)addrs[n - 1];</a>
<a name="ln7953"> </a>
<a name="ln7954">  n--;</a>
<a name="ln7955">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln7956">    xfree(addrs[i]);</a>
<a name="ln7957">  }</a>
<a name="ln7958">  xfree(addrs);</a>
<a name="ln7959">}</a>
<a name="ln7960"> </a>
<a name="ln7961">/// &quot;serverstop()&quot; function</a>
<a name="ln7962">static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7963">{</a>
<a name="ln7964">  if (check_secure()) {</a>
<a name="ln7965">    return;</a>
<a name="ln7966">  }</a>
<a name="ln7967"> </a>
<a name="ln7968">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln7969">    EMSG(_(e_invarg));</a>
<a name="ln7970">    return;</a>
<a name="ln7971">  }</a>
<a name="ln7972"> </a>
<a name="ln7973">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7974">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7975">  if (argvars[0].vval.v_string) {</a>
<a name="ln7976">    bool rv = server_stop((char *)argvars[0].vval.v_string);</a>
<a name="ln7977">    rettv-&gt;vval.v_number = (rv ? 1 : 0);</a>
<a name="ln7978">  }</a>
<a name="ln7979">}</a>
<a name="ln7980"> </a>
<a name="ln7981">/// &quot;setbufline()&quot; function</a>
<a name="ln7982">static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7983">{</a>
<a name="ln7984">    linenr_T lnum;</a>
<a name="ln7985">    buf_T    *buf;</a>
<a name="ln7986"> </a>
<a name="ln7987">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln7988">    if (buf == NULL) {</a>
<a name="ln7989">      rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln7990">    } else {</a>
<a name="ln7991">      lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln7992">      set_buffer_lines(buf, lnum, false, &amp;argvars[2], rettv);</a>
<a name="ln7993">    }</a>
<a name="ln7994">}</a>
<a name="ln7995"> </a>
<a name="ln7996">/*</a>
<a name="ln7997"> * &quot;setbufvar()&quot; function</a>
<a name="ln7998"> */</a>
<a name="ln7999">static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8000">{</a>
<a name="ln8001">  if (check_secure()</a>
<a name="ln8002">      || !tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln8003">    return;</a>
<a name="ln8004">  }</a>
<a name="ln8005">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8006">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8007">  typval_T *varp = &amp;argvars[2];</a>
<a name="ln8008"> </a>
<a name="ln8009">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln8010">    if (*varname == '&amp;') {</a>
<a name="ln8011">      long numval;</a>
<a name="ln8012">      bool error = false;</a>
<a name="ln8013">      aco_save_T aco;</a>
<a name="ln8014"> </a>
<a name="ln8015">      // set curbuf to be our buf, temporarily</a>
<a name="ln8016">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln8017"> </a>
<a name="ln8018">      varname++;</a>
<a name="ln8019">      numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln8020">      char nbuf[NUMBUFLEN];</a>
<a name="ln8021">      const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln8022">      if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln8023">        set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln8024">      }</a>
<a name="ln8025"> </a>
<a name="ln8026">      // reset notion of buffer</a>
<a name="ln8027">      aucmd_restbuf(&amp;aco);</a>
<a name="ln8028">    } else {</a>
<a name="ln8029">      const size_t varname_len = STRLEN(varname);</a>
<a name="ln8030">      char *const bufvarname = xmalloc(varname_len + 3);</a>
<a name="ln8031">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln8032">      curbuf = buf;</a>
<a name="ln8033">      memcpy(bufvarname, &quot;b:&quot;, 2);</a>
<a name="ln8034">      memcpy(bufvarname + 2, varname, varname_len + 1);</a>
<a name="ln8035">      set_var(bufvarname, varname_len + 2, varp, true);</a>
<a name="ln8036">      xfree(bufvarname);</a>
<a name="ln8037">      curbuf = save_curbuf;</a>
<a name="ln8038">    }</a>
<a name="ln8039">  }</a>
<a name="ln8040">}</a>
<a name="ln8041"> </a>
<a name="ln8042">static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8043">{</a>
<a name="ln8044">  dict_T        *d;</a>
<a name="ln8045">  dictitem_T        *di;</a>
<a name="ln8046"> </a>
<a name="ln8047">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln8048">    EMSG(_(e_dictreq));</a>
<a name="ln8049">    return;</a>
<a name="ln8050">  }</a>
<a name="ln8051"> </a>
<a name="ln8052">  if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln8053">    char_u *const csearch = (char_u *)tv_dict_get_string(d, &quot;char&quot;, false);</a>
<a name="ln8054">    if (csearch != NULL) {</a>
<a name="ln8055">      int pcc[MAX_MCO];</a>
<a name="ln8056">      const int c = utfc_ptr2char(csearch, pcc);</a>
<a name="ln8057">      set_last_csearch(c, csearch, utfc_ptr2len(csearch));</a>
<a name="ln8058">    }</a>
<a name="ln8059"> </a>
<a name="ln8060">    di = tv_dict_find(d, S_LEN(&quot;forward&quot;));</a>
<a name="ln8061">    if (di != NULL) {</a>
<a name="ln8062">      set_csearch_direction(tv_get_number(&amp;di-&gt;di_tv) ? FORWARD : BACKWARD);</a>
<a name="ln8063">    }</a>
<a name="ln8064"> </a>
<a name="ln8065">    di = tv_dict_find(d, S_LEN(&quot;until&quot;));</a>
<a name="ln8066">    if (di != NULL) {</a>
<a name="ln8067">      set_csearch_until(!!tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln8068">    }</a>
<a name="ln8069">  }</a>
<a name="ln8070">}</a>
<a name="ln8071"> </a>
<a name="ln8072">/*</a>
<a name="ln8073"> * &quot;setcmdpos()&quot; function</a>
<a name="ln8074"> */</a>
<a name="ln8075">static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8076">{</a>
<a name="ln8077">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln8078"> </a>
<a name="ln8079">  if (pos &gt;= 0) {</a>
<a name="ln8080">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln8081">  }</a>
<a name="ln8082">}</a>
<a name="ln8083"> </a>
<a name="ln8084">/// &quot;setenv()&quot; function</a>
<a name="ln8085">static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8086">{</a>
<a name="ln8087">  char namebuf[NUMBUFLEN];</a>
<a name="ln8088">  char valbuf[NUMBUFLEN];</a>
<a name="ln8089">  const char *name = tv_get_string_buf(&amp;argvars[0], namebuf);</a>
<a name="ln8090"> </a>
<a name="ln8091">  if (argvars[1].v_type == VAR_SPECIAL</a>
<a name="ln8092">      &amp;&amp; argvars[1].vval.v_special == kSpecialVarNull) {</a>
<a name="ln8093">    os_unsetenv(name);</a>
<a name="ln8094">  } else {</a>
<a name="ln8095">    os_setenv(name, tv_get_string_buf(&amp;argvars[1], valbuf), 1);</a>
<a name="ln8096">  }</a>
<a name="ln8097">}</a>
<a name="ln8098"> </a>
<a name="ln8099">/// &quot;setfperm({fname}, {mode})&quot; function</a>
<a name="ln8100">static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8101">{</a>
<a name="ln8102">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8103"> </a>
<a name="ln8104">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8105">  if (fname == NULL) {</a>
<a name="ln8106">    return;</a>
<a name="ln8107">  }</a>
<a name="ln8108"> </a>
<a name="ln8109">  char modebuf[NUMBUFLEN];</a>
<a name="ln8110">  const char *const mode_str = tv_get_string_buf_chk(&amp;argvars[1], modebuf);</a>
<a name="ln8111">  if (mode_str == NULL) {</a>
<a name="ln8112">    return;</a>
<a name="ln8113">  }</a>
<a name="ln8114">  if (strlen(mode_str) != 9) {</a>
<a name="ln8115">    EMSG2(_(e_invarg2), mode_str);</a>
<a name="ln8116">    return;</a>
<a name="ln8117">  }</a>
<a name="ln8118"> </a>
<a name="ln8119">  int mask = 1;</a>
<a name="ln8120">  int mode = 0;</a>
<a name="ln8121">  for (int i = 8; i &gt;= 0; i--) {</a>
<a name="ln8122">    if (mode_str[i] != '-') {</a>
<a name="ln8123">      mode |= mask;</a>
<a name="ln8124">    }</a>
<a name="ln8125">    mask = mask &lt;&lt; 1;</a>
<a name="ln8126">  }</a>
<a name="ln8127">  rettv-&gt;vval.v_number = os_setperm(fname, mode) == OK;</a>
<a name="ln8128">}</a>
<a name="ln8129"> </a>
<a name="ln8130">/*</a>
<a name="ln8131"> * &quot;setline()&quot; function</a>
<a name="ln8132"> */</a>
<a name="ln8133">static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8134">{</a>
<a name="ln8135">  linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln8136">  set_buffer_lines(curbuf, lnum, false, &amp;argvars[1], rettv);</a>
<a name="ln8137">}</a>
<a name="ln8138"> </a>
<a name="ln8139">/// Create quickfix/location list from VimL values</a>
<a name="ln8140">///</a>
<a name="ln8141">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln8142">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln8143">///</a>
<a name="ln8144">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln8145">///                     which case quickfix list will be created.</a>
<a name="ln8146">/// @param[in]  args  [list, action, what]</a>
<a name="ln8147">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln8148">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln8149">///                      append to an existing list, replace its content,</a>
<a name="ln8150">///                      or create a new one.</a>
<a name="ln8151">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln8152">///                      Defaults to caller function name.</a>
<a name="ln8153">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln8154">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln8155">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8156">{</a>
<a name="ln8157">  static char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln8158">  const char *title = NULL;</a>
<a name="ln8159">  int action = ' ';</a>
<a name="ln8160">  static int recursive = 0;</a>
<a name="ln8161">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8162">  dict_T *what = NULL;</a>
<a name="ln8163"> </a>
<a name="ln8164">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln8165">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln8166">    EMSG(_(e_listreq));</a>
<a name="ln8167">    return;</a>
<a name="ln8168">  } else if (recursive != 0) {</a>
<a name="ln8169">    EMSG(_(e_au_recursive));</a>
<a name="ln8170">    return;</a>
<a name="ln8171">  }</a>
<a name="ln8172"> </a>
<a name="ln8173">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln8174">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8175">    // Option argument was not given.</a>
<a name="ln8176">    goto skip_args;</a>
<a name="ln8177">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln8178">    EMSG(_(e_stringreq));</a>
<a name="ln8179">    return;</a>
<a name="ln8180">  }</a>
<a name="ln8181">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln8182">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln8183">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln8184">    action = *act;</a>
<a name="ln8185">  } else {</a>
<a name="ln8186">    EMSG2(_(e_invact), act);</a>
<a name="ln8187">    return;</a>
<a name="ln8188">  }</a>
<a name="ln8189"> </a>
<a name="ln8190">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln8191">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8192">    // Option argument was not given.</a>
<a name="ln8193">    goto skip_args;</a>
<a name="ln8194">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln8195">    title = tv_get_string_chk(what_arg);</a>
<a name="ln8196">    if (!title) {</a>
<a name="ln8197">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln8198">      return;</a>
<a name="ln8199">    }</a>
<a name="ln8200">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln8201">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln8202">  } else {</a>
<a name="ln8203">    EMSG(_(e_dictreq));</a>
<a name="ln8204">    return;</a>
<a name="ln8205">  }</a>
<a name="ln8206"> </a>
<a name="ln8207">skip_args:</a>
<a name="ln8208">  if (!title) {</a>
<a name="ln8209">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln8210">  }</a>
<a name="ln8211"> </a>
<a name="ln8212">  recursive++;</a>
<a name="ln8213">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln8214">  if (set_errorlist(wp, l, action, (char_u *)title, what) == OK) {</a>
<a name="ln8215">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8216">  }</a>
<a name="ln8217">  recursive--;</a>
<a name="ln8218">}</a>
<a name="ln8219"> </a>
<a name="ln8220">/*</a>
<a name="ln8221"> * &quot;setloclist()&quot; function</a>
<a name="ln8222"> */</a>
<a name="ln8223">static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8224">{</a>
<a name="ln8225">  win_T       *win;</a>
<a name="ln8226"> </a>
<a name="ln8227">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8228"> </a>
<a name="ln8229">  win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8230">  if (win != NULL) {</a>
<a name="ln8231">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln8232">  }</a>
<a name="ln8233">}</a>
<a name="ln8234"> </a>
<a name="ln8235">/*</a>
<a name="ln8236"> * &quot;setmatches()&quot; function</a>
<a name="ln8237"> */</a>
<a name="ln8238">static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8239">{</a>
<a name="ln8240">  dict_T *d;</a>
<a name="ln8241">  list_T *s = NULL;</a>
<a name="ln8242">  win_T *win = get_optional_window(argvars, 1);</a>
<a name="ln8243"> </a>
<a name="ln8244">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8245">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln8246">    EMSG(_(e_listreq));</a>
<a name="ln8247">    return;</a>
<a name="ln8248">  }</a>
<a name="ln8249">  if (win == NULL) {</a>
<a name="ln8250">    return;</a>
<a name="ln8251">  }</a>
<a name="ln8252"> </a>
<a name="ln8253">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln8254">  // To some extent make sure that we are dealing with a list from</a>
<a name="ln8255">  // &quot;getmatches()&quot;.</a>
<a name="ln8256">  int li_idx = 0;</a>
<a name="ln8257">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8258">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT</a>
<a name="ln8259">        || (d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict) == NULL) {</a>
<a name="ln8260">      emsgf(_(&quot;E474: List item %d is either not a dictionary &quot;</a>
<a name="ln8261">              &quot;or an empty one&quot;), li_idx);</a>
<a name="ln8262">      return;</a>
<a name="ln8263">    }</a>
<a name="ln8264">    if (!(tv_dict_find(d, S_LEN(&quot;group&quot;)) != NULL</a>
<a name="ln8265">          &amp;&amp; (tv_dict_find(d, S_LEN(&quot;pattern&quot;)) != NULL</a>
<a name="ln8266">              || tv_dict_find(d, S_LEN(&quot;pos1&quot;)) != NULL)</a>
<a name="ln8267">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;priority&quot;)) != NULL</a>
<a name="ln8268">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;id&quot;)) != NULL)) {</a>
<a name="ln8269">      emsgf(_(&quot;E474: List item %d is missing one of the required keys&quot;),</a>
<a name="ln8270">            li_idx);</a>
<a name="ln8271">      return;</a>
<a name="ln8272">    }</a>
<a name="ln8273">    li_idx++;</a>
<a name="ln8274">  });</a>
<a name="ln8275"> </a>
<a name="ln8276">  clear_matches(win);</a>
<a name="ln8277">  bool match_add_failed = false;</a>
<a name="ln8278">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8279">    int i = 0;</a>
<a name="ln8280"> </a>
<a name="ln8281">    d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln8282">    dictitem_T *const di = tv_dict_find(d, S_LEN(&quot;pattern&quot;));</a>
<a name="ln8283">    if (di == NULL) {</a>
<a name="ln8284">      if (s == NULL) {</a>
<a name="ln8285">        s = tv_list_alloc(9);</a>
<a name="ln8286">      }</a>
<a name="ln8287"> </a>
<a name="ln8288">      // match from matchaddpos()</a>
<a name="ln8289">      for (i = 1; i &lt; 9; i++) {</a>
<a name="ln8290">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln8291">        snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i);</a>
<a name="ln8292">        dictitem_T *const pos_di = tv_dict_find(d, buf, -1);</a>
<a name="ln8293">        if (pos_di != NULL) {</a>
<a name="ln8294">          if (pos_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln8295">            return;</a>
<a name="ln8296">          }</a>
<a name="ln8297"> </a>
<a name="ln8298">          tv_list_append_tv(s, &amp;pos_di-&gt;di_tv);</a>
<a name="ln8299">          tv_list_ref(s);</a>
<a name="ln8300">        } else {</a>
<a name="ln8301">          break;</a>
<a name="ln8302">        }</a>
<a name="ln8303">      }</a>
<a name="ln8304">    }</a>
<a name="ln8305"> </a>
<a name="ln8306">    // Note: there are three number buffers involved:</a>
<a name="ln8307">    // - group_buf below.</a>
<a name="ln8308">    // - numbuf in tv_dict_get_string().</a>
<a name="ln8309">    // - mybuf in tv_get_string().</a>
<a name="ln8310">    //</a>
<a name="ln8311">    // If you change this code make sure that buffers will not get</a>
<a name="ln8312">    // accidentally reused.</a>
<a name="ln8313">    char group_buf[NUMBUFLEN];</a>
<a name="ln8314">    const char *const group = tv_dict_get_string_buf(d, &quot;group&quot;, group_buf);</a>
<a name="ln8315">    const int priority = (int)tv_dict_get_number(d, &quot;priority&quot;);</a>
<a name="ln8316">    const int id = (int)tv_dict_get_number(d, &quot;id&quot;);</a>
<a name="ln8317">    dictitem_T *const conceal_di = tv_dict_find(d, S_LEN(&quot;conceal&quot;));</a>
<a name="ln8318">    const char *const conceal = (conceal_di != NULL</a>
<a name="ln8319">                                 ? tv_get_string(&amp;conceal_di-&gt;di_tv)</a>
<a name="ln8320">                                 : NULL);</a>
<a name="ln8321">    if (i == 0) {</a>
<a name="ln8322">      if (match_add(win, group,</a>
<a name="ln8323">                    tv_dict_get_string(d, &quot;pattern&quot;, false),</a>
<a name="ln8324">                    priority, id, NULL, conceal) != id) {</a>
<a name="ln8325">        match_add_failed = true;</a>
<a name="ln8326">      }</a>
<a name="ln8327">    } else {</a>
<a name="ln8328">      if (match_add(win, group, NULL, priority, id, s, conceal) != id) {</a>
<a name="ln8329">        match_add_failed = true;</a>
<a name="ln8330">      }</a>
<a name="ln8331">      tv_list_unref(s);</a>
<a name="ln8332">      s = NULL;</a>
<a name="ln8333">    }</a>
<a name="ln8334">  });</a>
<a name="ln8335">  if (!match_add_failed) {</a>
<a name="ln8336">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8337">  }</a>
<a name="ln8338">}</a>
<a name="ln8339"> </a>
<a name="ln8340">/*</a>
<a name="ln8341"> * &quot;setpos()&quot; function</a>
<a name="ln8342"> */</a>
<a name="ln8343">static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8344">{</a>
<a name="ln8345">  pos_T pos;</a>
<a name="ln8346">  int fnum;</a>
<a name="ln8347">  colnr_T     curswant = -1;</a>
<a name="ln8348"> </a>
<a name="ln8349">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8350">  const char *const name = tv_get_string_chk(argvars);</a>
<a name="ln8351">  if (name != NULL) {</a>
<a name="ln8352">    if (list2fpos(&amp;argvars[1], &amp;pos, &amp;fnum, &amp;curswant) == OK) {</a>
<a name="ln8353">      if (pos.col != MAXCOL &amp;&amp; --pos.col &lt; 0) {</a>
<a name="ln8354">        pos.col = 0;</a>
<a name="ln8355">      }</a>
<a name="ln8356">      if (name[0] == '.' &amp;&amp; name[1] == NUL) {</a>
<a name="ln8357">        // set cursor; &quot;fnum&quot; is ignored</a>
<a name="ln8358">        curwin-&gt;w_cursor = pos;</a>
<a name="ln8359">        if (curswant &gt;= 0) {</a>
<a name="ln8360">          curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln8361">          curwin-&gt;w_set_curswant = false;</a>
<a name="ln8362">        }</a>
<a name="ln8363">        check_cursor();</a>
<a name="ln8364">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8365">      } else if (name[0] == '\'' &amp;&amp; name[1] != NUL &amp;&amp; name[2] == NUL)   {</a>
<a name="ln8366">        // set mark</a>
<a name="ln8367">        if (setmark_pos((uint8_t)name[1], &amp;pos, fnum) == OK) {</a>
<a name="ln8368">          rettv-&gt;vval.v_number = 0;</a>
<a name="ln8369">        }</a>
<a name="ln8370">      } else {</a>
<a name="ln8371">        EMSG(_(e_invarg));</a>
<a name="ln8372">      }</a>
<a name="ln8373">    }</a>
<a name="ln8374">  }</a>
<a name="ln8375">}</a>
<a name="ln8376"> </a>
<a name="ln8377">/*</a>
<a name="ln8378"> * &quot;setqflist()&quot; function</a>
<a name="ln8379"> */</a>
<a name="ln8380">static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8381">{</a>
<a name="ln8382">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln8383">}</a>
<a name="ln8384"> </a>
<a name="ln8385">/*</a>
<a name="ln8386"> * &quot;setreg()&quot; function</a>
<a name="ln8387"> */</a>
<a name="ln8388">static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8389">{</a>
<a name="ln8390">  int regname;</a>
<a name="ln8391">  bool append = false;</a>
<a name="ln8392">  MotionType yank_type;</a>
<a name="ln8393">  long block_len;</a>
<a name="ln8394"> </a>
<a name="ln8395">  block_len = -1;</a>
<a name="ln8396">  yank_type = kMTUnknown;</a>
<a name="ln8397"> </a>
<a name="ln8398">  rettv-&gt;vval.v_number = 1;  // FAIL is default.</a>
<a name="ln8399"> </a>
<a name="ln8400">  const char *const strregname = tv_get_string_chk(argvars);</a>
<a name="ln8401">  if (strregname == NULL) {</a>
<a name="ln8402">    return;  // Type error; errmsg already given.</a>
<a name="ln8403">  }</a>
<a name="ln8404">  regname = (uint8_t)(*strregname);</a>
<a name="ln8405">  if (regname == 0 || regname == '@') {</a>
<a name="ln8406">    regname = '&quot;';</a>
<a name="ln8407">  }</a>
<a name="ln8408"> </a>
<a name="ln8409">  bool set_unnamed = false;</a>
<a name="ln8410">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8411">    const char *stropt = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8412">    if (stropt == NULL) {</a>
<a name="ln8413">      return;  // Type error.</a>
<a name="ln8414">    }</a>
<a name="ln8415">    for (; *stropt != NUL; stropt++) {</a>
<a name="ln8416">      switch (*stropt) {</a>
<a name="ln8417">        case 'a': case 'A': {  // append</a>
<a name="ln8418">          append = true;</a>
<a name="ln8419">          break;</a>
<a name="ln8420">        }</a>
<a name="ln8421">        case 'v': case 'c': {  // character-wise selection</a>
<a name="ln8422">          yank_type = kMTCharWise;</a>
<a name="ln8423">          break;</a>
<a name="ln8424">        }</a>
<a name="ln8425">        case 'V': case 'l': {  // line-wise selection</a>
<a name="ln8426">          yank_type = kMTLineWise;</a>
<a name="ln8427">          break;</a>
<a name="ln8428">        }</a>
<a name="ln8429">        case 'b': case Ctrl_V: {  // block-wise selection</a>
<a name="ln8430">          yank_type = kMTBlockWise;</a>
<a name="ln8431">          if (ascii_isdigit(stropt[1])) {</a>
<a name="ln8432">            stropt++;</a>
<a name="ln8433">            block_len = getdigits_long((char_u **)&amp;stropt, true, 0) - 1;</a>
<a name="ln8434">            stropt--;</a>
<a name="ln8435">          }</a>
<a name="ln8436">          break;</a>
<a name="ln8437">        }</a>
<a name="ln8438">        case 'u': case '&quot;': {  // unnamed register</a>
<a name="ln8439">          set_unnamed = true;</a>
<a name="ln8440">          break;</a>
<a name="ln8441">        }</a>
<a name="ln8442">      }</a>
<a name="ln8443">    }</a>
<a name="ln8444">  }</a>
<a name="ln8445"> </a>
<a name="ln8446">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln8447">    list_T *ll = argvars[1].vval.v_list;</a>
<a name="ln8448">    // If the list is NULL handle like an empty list.</a>
<a name="ln8449">    const int len = tv_list_len(ll);</a>
<a name="ln8450"> </a>
<a name="ln8451">    // First half: use for pointers to result lines; second half: use for</a>
<a name="ln8452">    // pointers to allocated copies.</a>
<a name="ln8453">    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));</a>
<a name="ln8454">    const char **curval = (const char **)lstval;</a>
<a name="ln8455">    char **allocval = lstval + len + 2;</a>
<a name="ln8456">    char **curallocval = allocval;</a>
<a name="ln8457"> </a>
<a name="ln8458">    TV_LIST_ITER_CONST(ll, li, {</a>
<a name="ln8459">      char buf[NUMBUFLEN];</a>
<a name="ln8460">      *curval = tv_get_string_buf_chk(TV_LIST_ITEM_TV(li), buf);</a>
<a name="ln8461">      if (*curval == NULL) {</a>
<a name="ln8462">        goto free_lstval;</a>
<a name="ln8463">      }</a>
<a name="ln8464">      if (*curval == buf) {</a>
<a name="ln8465">        // Need to make a copy,</a>
<a name="ln8466">        // next tv_get_string_buf_chk() will overwrite the string.</a>
<a name="ln8467">        *curallocval = xstrdup(*curval);</a>
<a name="ln8468">        *curval = *curallocval;</a>
<a name="ln8469">        curallocval++;</a>
<a name="ln8470">      }</a>
<a name="ln8471">      curval++;</a>
<a name="ln8472">    });</a>
<a name="ln8473">    *curval++ = NULL;</a>
<a name="ln8474"> </a>
<a name="ln8475">    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,</a>
<a name="ln8476">                           block_len);</a>
<a name="ln8477"> </a>
<a name="ln8478">free_lstval:</a>
<a name="ln8479">    while (curallocval &gt; allocval) {</a>
<a name="ln8480">      xfree(*--curallocval);</a>
<a name="ln8481">    }</a>
<a name="ln8482">    xfree(lstval);</a>
<a name="ln8483">  } else {</a>
<a name="ln8484">    const char *strval = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8485">    if (strval == NULL) {</a>
<a name="ln8486">      return;</a>
<a name="ln8487">    }</a>
<a name="ln8488">    write_reg_contents_ex(regname, (const char_u *)strval, STRLEN(strval),</a>
<a name="ln8489">                          append, yank_type, block_len);</a>
<a name="ln8490">  }</a>
<a name="ln8491">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8492"> </a>
<a name="ln8493">  if (set_unnamed) {</a>
<a name="ln8494">    // Discard the result. We already handle the error case.</a>
<a name="ln8495">    if (op_reg_set_previous(regname)) { }</a>
<a name="ln8496">  }</a>
<a name="ln8497">}</a>
<a name="ln8498"> </a>
<a name="ln8499">/*</a>
<a name="ln8500"> * &quot;settabvar()&quot; function</a>
<a name="ln8501"> */</a>
<a name="ln8502">static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8503">{</a>
<a name="ln8504">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8505"> </a>
<a name="ln8506">  if (check_secure()) {</a>
<a name="ln8507">    return;</a>
<a name="ln8508">  }</a>
<a name="ln8509"> </a>
<a name="ln8510">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln8511">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8512">  typval_T *const varp = &amp;argvars[2];</a>
<a name="ln8513"> </a>
<a name="ln8514">  if (varname != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln8515">    tabpage_T *const save_curtab = curtab;</a>
<a name="ln8516">    goto_tabpage_tp(tp, false, false);</a>
<a name="ln8517"> </a>
<a name="ln8518">    const size_t varname_len = strlen(varname);</a>
<a name="ln8519">    char *const tabvarname = xmalloc(varname_len + 3);</a>
<a name="ln8520">    memcpy(tabvarname, &quot;t:&quot;, 2);</a>
<a name="ln8521">    memcpy(tabvarname + 2, varname, varname_len + 1);</a>
<a name="ln8522">    set_var(tabvarname, varname_len + 2, varp, true);</a>
<a name="ln8523">    xfree(tabvarname);</a>
<a name="ln8524"> </a>
<a name="ln8525">    // Restore current tabpage.</a>
<a name="ln8526">    if (valid_tabpage(save_curtab)) {</a>
<a name="ln8527">      goto_tabpage_tp(save_curtab, false, false);</a>
<a name="ln8528">    }</a>
<a name="ln8529">  }</a>
<a name="ln8530">}</a>
<a name="ln8531"> </a>
<a name="ln8532">/*</a>
<a name="ln8533"> * &quot;settabwinvar()&quot; function</a>
<a name="ln8534"> */</a>
<a name="ln8535">static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8536">{</a>
<a name="ln8537">  setwinvar(argvars, rettv, 1);</a>
<a name="ln8538">}</a>
<a name="ln8539"> </a>
<a name="ln8540">// &quot;settagstack()&quot; function</a>
<a name="ln8541">static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8542">{</a>
<a name="ln8543">    static char *e_invact2 = N_(&quot;E962: Invalid action: '%s'&quot;);</a>
<a name="ln8544">    win_T       *wp;</a>
<a name="ln8545">    dict_T      *d;</a>
<a name="ln8546">    int         action = 'r';</a>
<a name="ln8547"> </a>
<a name="ln8548">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln8549"> </a>
<a name="ln8550">    // first argument: window number or id</a>
<a name="ln8551">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8552">    if (wp == NULL) {</a>
<a name="ln8553">      return;</a>
<a name="ln8554">    }</a>
<a name="ln8555"> </a>
<a name="ln8556">    // second argument: dict with items to set in the tag stack</a>
<a name="ln8557">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8558">        EMSG(_(e_dictreq));</a>
<a name="ln8559">        return;</a>
<a name="ln8560">    }</a>
<a name="ln8561">    d = argvars[1].vval.v_dict;</a>
<a name="ln8562">    if (d == NULL) {</a>
<a name="ln8563">      return;</a>
<a name="ln8564">    }</a>
<a name="ln8565"> </a>
<a name="ln8566">    // third argument: action - 'a' for append and 'r' for replace.</a>
<a name="ln8567">    // default is to replace the stack.</a>
<a name="ln8568">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln8569">      action = 'r';</a>
<a name="ln8570">    } else if (argvars[2].v_type == VAR_STRING) {</a>
<a name="ln8571">        const char *actstr;</a>
<a name="ln8572">        actstr = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8573">        if (actstr == NULL) {</a>
<a name="ln8574">          return;</a>
<a name="ln8575">        }</a>
<a name="ln8576">        if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')</a>
<a name="ln8577">            &amp;&amp; actstr[1] == NUL) {</a>
<a name="ln8578">          action = *actstr;</a>
<a name="ln8579">        } else {</a>
<a name="ln8580">            EMSG2(_(e_invact2), actstr);</a>
<a name="ln8581">            return;</a>
<a name="ln8582">        }</a>
<a name="ln8583">    } else {</a>
<a name="ln8584">        EMSG(_(e_stringreq));</a>
<a name="ln8585">        return;</a>
<a name="ln8586">    }</a>
<a name="ln8587"> </a>
<a name="ln8588">    if (set_tagstack(wp, d, action) == OK) {</a>
<a name="ln8589">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8590">    } else {</a>
<a name="ln8591">      EMSG(_(e_listreq));</a>
<a name="ln8592">    }</a>
<a name="ln8593">}</a>
<a name="ln8594"> </a>
<a name="ln8595">/*</a>
<a name="ln8596"> * &quot;setwinvar()&quot; function</a>
<a name="ln8597"> */</a>
<a name="ln8598">static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8599">{</a>
<a name="ln8600">  setwinvar(argvars, rettv, 0);</a>
<a name="ln8601">}</a>
<a name="ln8602"> </a>
<a name="ln8603">/// f_sha256 - sha256({string}) function</a>
<a name="ln8604">static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8605">{</a>
<a name="ln8606">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8607">  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p) , NULL, 0);</a>
<a name="ln8608"> </a>
<a name="ln8609">  // make a copy of the hash (sha256_bytes returns a static buffer)</a>
<a name="ln8610">  rettv-&gt;vval.v_string = (char_u *)xstrdup(hash);</a>
<a name="ln8611">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8612">}</a>
<a name="ln8613"> </a>
<a name="ln8614">/*</a>
<a name="ln8615"> * &quot;shellescape({string})&quot; function</a>
<a name="ln8616"> */</a>
<a name="ln8617">static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8618">{</a>
<a name="ln8619">  const bool do_special = non_zero_arg(&amp;argvars[1]);</a>
<a name="ln8620"> </a>
<a name="ln8621">  rettv-&gt;vval.v_string = vim_strsave_shellescape(</a>
<a name="ln8622">      (const char_u *)tv_get_string(&amp;argvars[0]), do_special, do_special);</a>
<a name="ln8623">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8624">}</a>
<a name="ln8625"> </a>
<a name="ln8626">/*</a>
<a name="ln8627"> * shiftwidth() function</a>
<a name="ln8628"> */</a>
<a name="ln8629">static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8630">{</a>
<a name="ln8631">  rettv-&gt;vval.v_number = get_sw_value(curbuf);</a>
<a name="ln8632">}</a>
<a name="ln8633"> </a>
<a name="ln8634">/// &quot;sign_define()&quot; function</a>
<a name="ln8635">static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8636">{</a>
<a name="ln8637">  const char *name;</a>
<a name="ln8638">  dict_T *dict;</a>
<a name="ln8639">  char *icon = NULL;</a>
<a name="ln8640">  char *linehl = NULL;</a>
<a name="ln8641">  char *text = NULL;</a>
<a name="ln8642">  char *texthl = NULL;</a>
<a name="ln8643">  char *numhl = NULL;</a>
<a name="ln8644"> </a>
<a name="ln8645">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8646"> </a>
<a name="ln8647">  name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8648">  if (name == NULL) {</a>
<a name="ln8649">    return;</a>
<a name="ln8650">  }</a>
<a name="ln8651"> </a>
<a name="ln8652">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8653">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8654">      EMSG(_(e_dictreq));</a>
<a name="ln8655">      return;</a>
<a name="ln8656">    }</a>
<a name="ln8657"> </a>
<a name="ln8658">    // sign attributes</a>
<a name="ln8659">    dict = argvars[1].vval.v_dict;</a>
<a name="ln8660">    if (tv_dict_find(dict, &quot;icon&quot;, -1) != NULL) {</a>
<a name="ln8661">      icon = tv_dict_get_string(dict, &quot;icon&quot;, true);</a>
<a name="ln8662">    }</a>
<a name="ln8663">    if (tv_dict_find(dict, &quot;linehl&quot;, -1) != NULL) {</a>
<a name="ln8664">      linehl = tv_dict_get_string(dict, &quot;linehl&quot;, true);</a>
<a name="ln8665">    }</a>
<a name="ln8666">    if (tv_dict_find(dict, &quot;text&quot;, -1) != NULL) {</a>
<a name="ln8667">      text = tv_dict_get_string(dict, &quot;text&quot;, true);</a>
<a name="ln8668">    }</a>
<a name="ln8669">    if (tv_dict_find(dict, &quot;texthl&quot;, -1) != NULL) {</a>
<a name="ln8670">      texthl = tv_dict_get_string(dict, &quot;texthl&quot;, true);</a>
<a name="ln8671">    }</a>
<a name="ln8672">    if (tv_dict_find(dict, &quot;numhl&quot;, -1) != NULL) {</a>
<a name="ln8673">      numhl = tv_dict_get_string(dict, &quot;numhl&quot;, true);</a>
<a name="ln8674">    }</a>
<a name="ln8675">  }</a>
<a name="ln8676"> </a>
<a name="ln8677">  if (sign_define_by_name((char_u *)name, (char_u *)icon, (char_u *)linehl,</a>
<a name="ln8678">                          (char_u *)text, (char_u *)texthl, (char_u *)numhl)</a>
<a name="ln8679">      == OK) {</a>
<a name="ln8680">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8681">  }</a>
<a name="ln8682"> </a>
<a name="ln8683">  xfree(icon);</a>
<a name="ln8684">  xfree(linehl);</a>
<a name="ln8685">  xfree(text);</a>
<a name="ln8686">  xfree(texthl);</a>
<a name="ln8687">  xfree(numhl);</a>
<a name="ln8688">}</a>
<a name="ln8689"> </a>
<a name="ln8690">/// &quot;sign_getdefined()&quot; function</a>
<a name="ln8691">static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8692">{</a>
<a name="ln8693">  const char *name = NULL;</a>
<a name="ln8694"> </a>
<a name="ln8695">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8696"> </a>
<a name="ln8697">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8698">    name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8699">  }</a>
<a name="ln8700"> </a>
<a name="ln8701">  sign_getlist((const char_u *)name, rettv-&gt;vval.v_list);</a>
<a name="ln8702">}</a>
<a name="ln8703"> </a>
<a name="ln8704">/// &quot;sign_getplaced()&quot; function</a>
<a name="ln8705">static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8706">{</a>
<a name="ln8707">  buf_T *buf = NULL;</a>
<a name="ln8708">  dict_T *dict;</a>
<a name="ln8709">  dictitem_T *di;</a>
<a name="ln8710">  linenr_T lnum = 0;</a>
<a name="ln8711">  int sign_id = 0;</a>
<a name="ln8712">  const char *group = NULL;</a>
<a name="ln8713">  bool notanum = false;</a>
<a name="ln8714"> </a>
<a name="ln8715">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8716"> </a>
<a name="ln8717">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8718">    // get signs placed in the specified buffer</a>
<a name="ln8719">    buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln8720">    if (buf == NULL) {</a>
<a name="ln8721">      return;</a>
<a name="ln8722">    }</a>
<a name="ln8723"> </a>
<a name="ln8724">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8725">      if (argvars[1].v_type != VAR_DICT</a>
<a name="ln8726">          || ((dict = argvars[1].vval.v_dict) == NULL)) {</a>
<a name="ln8727">        EMSG(_(e_dictreq));</a>
<a name="ln8728">        return;</a>
<a name="ln8729">      }</a>
<a name="ln8730">      if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln8731">        // get signs placed at this line</a>
<a name="ln8732">        lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8733">        if (notanum) {</a>
<a name="ln8734">          return;</a>
<a name="ln8735">        }</a>
<a name="ln8736">        (void)lnum;</a>
<a name="ln8737">        lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln8738">      }</a>
<a name="ln8739">      if ((di = tv_dict_find(dict, &quot;id&quot;, -1)) != NULL) {</a>
<a name="ln8740">        // get sign placed with this identifier</a>
<a name="ln8741">        sign_id = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8742">        if (notanum) {</a>
<a name="ln8743">          return;</a>
<a name="ln8744">        }</a>
<a name="ln8745">      }</a>
<a name="ln8746">      if ((di = tv_dict_find(dict, &quot;group&quot;, -1)) != NULL) {</a>
<a name="ln8747">        group = tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln8748">        if (group == NULL) {</a>
<a name="ln8749">          return;</a>
<a name="ln8750">        }</a>
<a name="ln8751">        if (*group == '\0') {  // empty string means global group</a>
<a name="ln8752">          group = NULL;</a>
<a name="ln8753">        }</a>
<a name="ln8754">      }</a>
<a name="ln8755">    }</a>
<a name="ln8756">  }</a>
<a name="ln8757"> </a>
<a name="ln8758">  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,</a>
<a name="ln8759">                  rettv-&gt;vval.v_list);</a>
<a name="ln8760">}</a>
<a name="ln8761"> </a>
<a name="ln8762">/// &quot;sign_jump()&quot; function</a>
<a name="ln8763">static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8764">{</a>
<a name="ln8765">  int sign_id;</a>
<a name="ln8766">  char *sign_group = NULL;</a>
<a name="ln8767">  buf_T *buf;</a>
<a name="ln8768">  bool notanum = false;</a>
<a name="ln8769"> </a>
<a name="ln8770">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8771"> </a>
<a name="ln8772">  // Sign identifer</a>
<a name="ln8773">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln8774">  if (notanum) {</a>
<a name="ln8775">    return;</a>
<a name="ln8776">  }</a>
<a name="ln8777">  if (sign_id &lt;= 0) {</a>
<a name="ln8778">    EMSG(_(e_invarg));</a>
<a name="ln8779">    return;</a>
<a name="ln8780">  }</a>
<a name="ln8781"> </a>
<a name="ln8782">  // Sign group</a>
<a name="ln8783">  const char * sign_group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8784">  if (sign_group_chk == NULL) {</a>
<a name="ln8785">    return;</a>
<a name="ln8786">  }</a>
<a name="ln8787">  if (sign_group_chk[0] == '\0') {</a>
<a name="ln8788">    sign_group = NULL;  // global sign group</a>
<a name="ln8789">  } else {</a>
<a name="ln8790">    sign_group = xstrdup(sign_group_chk);</a>
<a name="ln8791">  }</a>
<a name="ln8792"> </a>
<a name="ln8793">  // Buffer to place the sign</a>
<a name="ln8794">  buf = get_buf_arg(&amp;argvars[2]);</a>
<a name="ln8795">  if (buf == NULL) {</a>
<a name="ln8796">    goto cleanup;</a>
<a name="ln8797">  }</a>
<a name="ln8798"> </a>
<a name="ln8799">  rettv-&gt;vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);</a>
<a name="ln8800"> </a>
<a name="ln8801">cleanup:</a>
<a name="ln8802">  xfree(sign_group);</a>
<a name="ln8803">}</a>
<a name="ln8804"> </a>
<a name="ln8805">/// &quot;sign_place()&quot; function</a>
<a name="ln8806">static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8807">{</a>
<a name="ln8808">  int sign_id;</a>
<a name="ln8809">  char_u *group = NULL;</a>
<a name="ln8810">  const char *sign_name;</a>
<a name="ln8811">  buf_T *buf;</a>
<a name="ln8812">  dict_T *dict;</a>
<a name="ln8813">  dictitem_T *di;</a>
<a name="ln8814">  linenr_T lnum = 0;</a>
<a name="ln8815">  int prio = SIGN_DEF_PRIO;</a>
<a name="ln8816">  bool notanum = false;</a>
<a name="ln8817"> </a>
<a name="ln8818">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8819"> </a>
<a name="ln8820">  // Sign identifer</a>
<a name="ln8821">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln8822">  if (notanum) {</a>
<a name="ln8823">    return;</a>
<a name="ln8824">  }</a>
<a name="ln8825">  if (sign_id &lt; 0) {</a>
<a name="ln8826">    EMSG(_(e_invarg));</a>
<a name="ln8827">    return;</a>
<a name="ln8828">  }</a>
<a name="ln8829"> </a>
<a name="ln8830">  // Sign group</a>
<a name="ln8831">  const char *group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8832">  if (group_chk == NULL) {</a>
<a name="ln8833">    return;</a>
<a name="ln8834">  }</a>
<a name="ln8835">  if (group_chk[0] == '\0') {</a>
<a name="ln8836">    group = NULL;  // global sign group</a>
<a name="ln8837">  } else {</a>
<a name="ln8838">    group = vim_strsave((const char_u *)group_chk);</a>
<a name="ln8839">  }</a>
<a name="ln8840"> </a>
<a name="ln8841">  // Sign name</a>
<a name="ln8842">  sign_name = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8843">  if (sign_name == NULL) {</a>
<a name="ln8844">    goto cleanup;</a>
<a name="ln8845">  }</a>
<a name="ln8846"> </a>
<a name="ln8847">  // Buffer to place the sign</a>
<a name="ln8848">  buf = get_buf_arg(&amp;argvars[3]);</a>
<a name="ln8849">  if (buf == NULL) {</a>
<a name="ln8850">    goto cleanup;</a>
<a name="ln8851">  }</a>
<a name="ln8852"> </a>
<a name="ln8853">  if (argvars[4].v_type != VAR_UNKNOWN) {</a>
<a name="ln8854">    if (argvars[4].v_type != VAR_DICT</a>
<a name="ln8855">        || ((dict = argvars[4].vval.v_dict) == NULL)) {</a>
<a name="ln8856">      EMSG(_(e_dictreq));</a>
<a name="ln8857">      goto cleanup;</a>
<a name="ln8858">    }</a>
<a name="ln8859"> </a>
<a name="ln8860">    // Line number where the sign is to be placed</a>
<a name="ln8861">    if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln8862">      lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8863">      if (notanum) {</a>
<a name="ln8864">        goto cleanup;</a>
<a name="ln8865">      }</a>
<a name="ln8866">      (void)lnum;</a>
<a name="ln8867">      lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln8868">    }</a>
<a name="ln8869">    if ((di = tv_dict_find(dict, &quot;priority&quot;, -1)) != NULL) {</a>
<a name="ln8870">      // Sign priority</a>
<a name="ln8871">      prio = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8872">      if (notanum) {</a>
<a name="ln8873">        goto cleanup;</a>
<a name="ln8874">      }</a>
<a name="ln8875">    }</a>
<a name="ln8876">  }</a>
<a name="ln8877"> </a>
<a name="ln8878">  if (sign_place(&amp;sign_id, group, (const char_u *)sign_name, buf, lnum, prio)</a>
<a name="ln8879">      == OK) {</a>
<a name="ln8880">    rettv-&gt;vval.v_number = sign_id;</a>
<a name="ln8881">  }</a>
<a name="ln8882"> </a>
<a name="ln8883">cleanup:</a>
<a name="ln8884">  xfree(group);</a>
<a name="ln8885">}</a>
<a name="ln8886"> </a>
<a name="ln8887">/// &quot;sign_undefine()&quot; function</a>
<a name="ln8888">static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8889">{</a>
<a name="ln8890">  const char *name;</a>
<a name="ln8891"> </a>
<a name="ln8892">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8893"> </a>
<a name="ln8894">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln8895">    // Free all the signs</a>
<a name="ln8896">    free_signs();</a>
<a name="ln8897">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8898">  } else {</a>
<a name="ln8899">    // Free only the specified sign</a>
<a name="ln8900">    name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8901">    if (name == NULL) {</a>
<a name="ln8902">      return;</a>
<a name="ln8903">    }</a>
<a name="ln8904"> </a>
<a name="ln8905">    if (sign_undefine_by_name((const char_u *)name) == OK) {</a>
<a name="ln8906">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8907">    }</a>
<a name="ln8908">  }</a>
<a name="ln8909">}</a>
<a name="ln8910"> </a>
<a name="ln8911">/// &quot;sign_unplace()&quot; function</a>
<a name="ln8912">static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8913">{</a>
<a name="ln8914">  dict_T *dict;</a>
<a name="ln8915">  dictitem_T *di;</a>
<a name="ln8916">  int sign_id = 0;</a>
<a name="ln8917">  buf_T *buf = NULL;</a>
<a name="ln8918">  char_u *group = NULL;</a>
<a name="ln8919"> </a>
<a name="ln8920">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8921"> </a>
<a name="ln8922">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8923">    EMSG(_(e_invarg));</a>
<a name="ln8924">    return;</a>
<a name="ln8925">  }</a>
<a name="ln8926"> </a>
<a name="ln8927">  const char *group_chk = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8928">  if (group_chk[0] == '\0') {</a>
<a name="ln8929">    group = NULL;  // global sign group</a>
<a name="ln8930">  } else {</a>
<a name="ln8931">    group = vim_strsave((const char_u *)group_chk);</a>
<a name="ln8932">  }</a>
<a name="ln8933"> </a>
<a name="ln8934">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8935">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8936">      EMSG(_(e_dictreq));</a>
<a name="ln8937">      goto cleanup;</a>
<a name="ln8938">    }</a>
<a name="ln8939">    dict = argvars[1].vval.v_dict;</a>
<a name="ln8940"> </a>
<a name="ln8941">    if ((di = tv_dict_find(dict, &quot;buffer&quot;, -1)) != NULL) {</a>
<a name="ln8942">      buf = get_buf_arg(&amp;di-&gt;di_tv);</a>
<a name="ln8943">      if (buf == NULL) {</a>
<a name="ln8944">        goto cleanup;</a>
<a name="ln8945">      }</a>
<a name="ln8946">    }</a>
<a name="ln8947">    if (tv_dict_find(dict, &quot;id&quot;, -1) != NULL) {</a>
<a name="ln8948">      sign_id = tv_dict_get_number(dict, &quot;id&quot;);</a>
<a name="ln8949">    }</a>
<a name="ln8950">  }</a>
<a name="ln8951"> </a>
<a name="ln8952">  if (buf == NULL) {</a>
<a name="ln8953">    // Delete the sign in all the buffers</a>
<a name="ln8954">    FOR_ALL_BUFFERS(cbuf) {</a>
<a name="ln8955">      if (sign_unplace(sign_id, group, cbuf, 0) == OK) {</a>
<a name="ln8956">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8957">      }</a>
<a name="ln8958">    }</a>
<a name="ln8959">  } else {</a>
<a name="ln8960">    if (sign_unplace(sign_id, group, buf, 0) == OK) {</a>
<a name="ln8961">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8962">    }</a>
<a name="ln8963">  }</a>
<a name="ln8964"> </a>
<a name="ln8965">cleanup:</a>
<a name="ln8966">  xfree(group);</a>
<a name="ln8967">}</a>
<a name="ln8968"> </a>
<a name="ln8969">/*</a>
<a name="ln8970"> * &quot;simplify()&quot; function</a>
<a name="ln8971"> */</a>
<a name="ln8972">static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8973">{</a>
<a name="ln8974">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8975">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln8976">  simplify_filename(rettv-&gt;vval.v_string);  // Simplify in place.</a>
<a name="ln8977">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8978">}</a>
<a name="ln8979"> </a>
<a name="ln8980">/// &quot;sockconnect()&quot; function</a>
<a name="ln8981">static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8982">{</a>
<a name="ln8983">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln8984">    EMSG(_(e_invarg));</a>
<a name="ln8985">    return;</a>
<a name="ln8986">  }</a>
<a name="ln8987">  if (argvars[2].v_type != VAR_DICT &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8988">    // Wrong argument types</a>
<a name="ln8989">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln8990">    return;</a>
<a name="ln8991">  }</a>
<a name="ln8992"> </a>
<a name="ln8993">  const char *mode = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8994">  const char *address = tv_get_string(&amp;argvars[1]);</a>
<a name="ln8995"> </a>
<a name="ln8996">  bool tcp;</a>
<a name="ln8997">  if (strcmp(mode, &quot;tcp&quot;) == 0) {</a>
<a name="ln8998">    tcp = true;</a>
<a name="ln8999">  } else if (strcmp(mode, &quot;pipe&quot;) == 0) {</a>
<a name="ln9000">    tcp = false;</a>
<a name="ln9001">  } else {</a>
<a name="ln9002">    EMSG2(_(e_invarg2), &quot;invalid mode&quot;);</a>
<a name="ln9003">    return;</a>
<a name="ln9004">  }</a>
<a name="ln9005"> </a>
<a name="ln9006">  bool rpc = false;</a>
<a name="ln9007">  CallbackReader on_data = CALLBACK_READER_INIT;</a>
<a name="ln9008">  if (argvars[2].v_type == VAR_DICT) {</a>
<a name="ln9009">    dict_T *opts = argvars[2].vval.v_dict;</a>
<a name="ln9010">    rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9011"> </a>
<a name="ln9012">    if (!tv_dict_get_callback(opts, S_LEN(&quot;on_data&quot;), &amp;on_data.cb)) {</a>
<a name="ln9013">      return;</a>
<a name="ln9014">    }</a>
<a name="ln9015">    on_data.buffered = tv_dict_get_number(opts, &quot;data_buffered&quot;);</a>
<a name="ln9016">    if (on_data.buffered &amp;&amp; on_data.cb.type == kCallbackNone) {</a>
<a name="ln9017">      on_data.self = opts;</a>
<a name="ln9018">    }</a>
<a name="ln9019">  }</a>
<a name="ln9020"> </a>
<a name="ln9021">  const char *error = NULL;</a>
<a name="ln9022">  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &amp;error);</a>
<a name="ln9023"> </a>
<a name="ln9024">  if (error) {</a>
<a name="ln9025">    EMSG2(_(&quot;connection failed: %s&quot;), error);</a>
<a name="ln9026">  }</a>
<a name="ln9027"> </a>
<a name="ln9028">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9029">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9030">}</a>
<a name="ln9031"> </a>
<a name="ln9032">/// struct storing information about current sort</a>
<a name="ln9033">typedef struct {</a>
<a name="ln9034">  int item_compare_ic;</a>
<a name="ln9035">  bool item_compare_numeric;</a>
<a name="ln9036">  bool item_compare_numbers;</a>
<a name="ln9037">  bool item_compare_float;</a>
<a name="ln9038">  const char *item_compare_func;</a>
<a name="ln9039">  partial_T *item_compare_partial;</a>
<a name="ln9040">  dict_T *item_compare_selfdict;</a>
<a name="ln9041">  bool item_compare_func_err;</a>
<a name="ln9042">} sortinfo_T;</a>
<a name="ln9043">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln9044"> </a>
<a name="ln9045">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln9046"> </a>
<a name="ln9047">/*</a>
<a name="ln9048"> * Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln9049"> */</a>
<a name="ln9050">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9051">{</a>
<a name="ln9052">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln9053">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln9054"> </a>
<a name="ln9055">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln9056">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln9057"> </a>
<a name="ln9058">  int res;</a>
<a name="ln9059"> </a>
<a name="ln9060">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln9061">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln9062">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln9063"> </a>
<a name="ln9064">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9065">    goto item_compare_end;</a>
<a name="ln9066">  }</a>
<a name="ln9067"> </a>
<a name="ln9068">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln9069">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln9070">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln9071"> </a>
<a name="ln9072">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9073">    goto item_compare_end;</a>
<a name="ln9074">  }</a>
<a name="ln9075"> </a>
<a name="ln9076">  char *tofree1 = NULL;</a>
<a name="ln9077">  char *tofree2 = NULL;</a>
<a name="ln9078">  char *p1;</a>
<a name="ln9079">  char *p2;</a>
<a name="ln9080"> </a>
<a name="ln9081">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln9082">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln9083">  // a non-string to do what the docs promise.</a>
<a name="ln9084">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln9085">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9086">      p1 = &quot;'&quot;;</a>
<a name="ln9087">    } else {</a>
<a name="ln9088">      p1 = (char *)tv1-&gt;vval.v_string;</a>
<a name="ln9089">    }</a>
<a name="ln9090">  } else {</a>
<a name="ln9091">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln9092">  }</a>
<a name="ln9093">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln9094">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9095">      p2 = &quot;'&quot;;</a>
<a name="ln9096">    } else {</a>
<a name="ln9097">      p2 = (char *)tv2-&gt;vval.v_string;</a>
<a name="ln9098">    }</a>
<a name="ln9099">  } else {</a>
<a name="ln9100">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln9101">  }</a>
<a name="ln9102">  if (p1 == NULL) {</a>
<a name="ln9103">    p1 = &quot;&quot;;</a>
<a name="ln9104">  }</a>
<a name="ln9105">  if (p2 == NULL) {</a>
<a name="ln9106">    p2 = &quot;&quot;;</a>
<a name="ln9107">  }</a>
<a name="ln9108">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9109">    if (sortinfo-&gt;item_compare_ic) {</a>
<a name="ln9110">      res = STRICMP(p1, p2);</a>
<a name="ln9111">    } else {</a>
<a name="ln9112">      res = STRCMP(p1, p2);</a>
<a name="ln9113">    }</a>
<a name="ln9114">  } else {</a>
<a name="ln9115">    double n1, n2;</a>
<a name="ln9116">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln9117">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln9118">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln9119">  }</a>
<a name="ln9120"> </a>
<a name="ln9121">  xfree(tofree1);</a>
<a name="ln9122">  xfree(tofree2);</a>
<a name="ln9123"> </a>
<a name="ln9124">item_compare_end:</a>
<a name="ln9125">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln9126">  // sort stable.</a>
<a name="ln9127">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9128">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9129">    // indexes are there.</a>
<a name="ln9130">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9131">  }</a>
<a name="ln9132">  return res;</a>
<a name="ln9133">}</a>
<a name="ln9134"> </a>
<a name="ln9135">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9136">{</a>
<a name="ln9137">  return item_compare(s1, s2, true);</a>
<a name="ln9138">}</a>
<a name="ln9139"> </a>
<a name="ln9140">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9141">{</a>
<a name="ln9142">  return item_compare(s1, s2, false);</a>
<a name="ln9143">}</a>
<a name="ln9144"> </a>
<a name="ln9145">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9146">{</a>
<a name="ln9147">  ListSortItem *si1, *si2;</a>
<a name="ln9148">  int res;</a>
<a name="ln9149">  typval_T rettv;</a>
<a name="ln9150">  typval_T argv[3];</a>
<a name="ln9151">  int dummy;</a>
<a name="ln9152">  const char *func_name;</a>
<a name="ln9153">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln9154"> </a>
<a name="ln9155">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln9156">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9157">    return 0;</a>
<a name="ln9158">  }</a>
<a name="ln9159"> </a>
<a name="ln9160">  si1 = (ListSortItem *)s1;</a>
<a name="ln9161">  si2 = (ListSortItem *)s2;</a>
<a name="ln9162"> </a>
<a name="ln9163">  if (partial == NULL) {</a>
<a name="ln9164">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln9165">  } else {</a>
<a name="ln9166">    func_name = (const char *)partial_name(partial);</a>
<a name="ln9167">  }</a>
<a name="ln9168"> </a>
<a name="ln9169">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln9170">  // in the copy without changing the original list items.</a>
<a name="ln9171">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln9172">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln9173"> </a>
<a name="ln9174">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln9175">  res = call_func((const char_u *)func_name,</a>
<a name="ln9176">                  -1,</a>
<a name="ln9177">                  &amp;rettv, 2, argv, NULL, 0L, 0L, &amp;dummy, true,</a>
<a name="ln9178">                  partial, sortinfo-&gt;item_compare_selfdict);</a>
<a name="ln9179">  tv_clear(&amp;argv[0]);</a>
<a name="ln9180">  tv_clear(&amp;argv[1]);</a>
<a name="ln9181"> </a>
<a name="ln9182">  if (res == FAIL) {</a>
<a name="ln9183">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln9184">  } else {</a>
<a name="ln9185">    res = tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln9186">  }</a>
<a name="ln9187">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9188">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln9189">  }</a>
<a name="ln9190">  tv_clear(&amp;rettv);</a>
<a name="ln9191"> </a>
<a name="ln9192">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln9193">  // the sort stable.</a>
<a name="ln9194">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9195">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9196">    // indexes are there.</a>
<a name="ln9197">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9198">  }</a>
<a name="ln9199"> </a>
<a name="ln9200">  return res;</a>
<a name="ln9201">}</a>
<a name="ln9202"> </a>
<a name="ln9203">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9204">{</a>
<a name="ln9205">  return item_compare2(s1, s2, true);</a>
<a name="ln9206">}</a>
<a name="ln9207"> </a>
<a name="ln9208">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9209">{</a>
<a name="ln9210">  return item_compare2(s1, s2, false);</a>
<a name="ln9211">}</a>
<a name="ln9212"> </a>
<a name="ln9213">/*</a>
<a name="ln9214"> * &quot;sort({list})&quot; function</a>
<a name="ln9215"> */</a>
<a name="ln9216">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln9217">{</a>
<a name="ln9218">  ListSortItem  *ptrs;</a>
<a name="ln9219">  long len;</a>
<a name="ln9220">  long i;</a>
<a name="ln9221"> </a>
<a name="ln9222">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln9223">  // the current one for nested calls.</a>
<a name="ln9224">  sortinfo_T info;</a>
<a name="ln9225">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln9226">  sortinfo = &amp;info;</a>
<a name="ln9227"> </a>
<a name="ln9228">  const char *const arg_errmsg = (sort</a>
<a name="ln9229">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln9230">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln9231"> </a>
<a name="ln9232">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9233">    EMSG2(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln9234">  } else {</a>
<a name="ln9235">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln9236">    if (tv_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln9237">      goto theend;</a>
<a name="ln9238">    }</a>
<a name="ln9239">    tv_list_set_ret(rettv, l);</a>
<a name="ln9240"> </a>
<a name="ln9241">    len = tv_list_len(l);</a>
<a name="ln9242">    if (len &lt;= 1) {</a>
<a name="ln9243">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln9244">    }</a>
<a name="ln9245"> </a>
<a name="ln9246">    info.item_compare_ic = false;</a>
<a name="ln9247">    info.item_compare_numeric = false;</a>
<a name="ln9248">    info.item_compare_numbers = false;</a>
<a name="ln9249">    info.item_compare_float = false;</a>
<a name="ln9250">    info.item_compare_func = NULL;</a>
<a name="ln9251">    info.item_compare_partial = NULL;</a>
<a name="ln9252">    info.item_compare_selfdict = NULL;</a>
<a name="ln9253"> </a>
<a name="ln9254">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9255">      // optional second argument: {func}</a>
<a name="ln9256">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln9257">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln9258">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln9259">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln9260">      } else {</a>
<a name="ln9261">        bool error = false;</a>
<a name="ln9262"> </a>
<a name="ln9263">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9264">        if (error) {</a>
<a name="ln9265">          goto theend;  // type error; errmsg already given</a>
<a name="ln9266">        }</a>
<a name="ln9267">        if (i == 1) {</a>
<a name="ln9268">          info.item_compare_ic = true;</a>
<a name="ln9269">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln9270">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9271">        } else if (i != 0) {</a>
<a name="ln9272">          EMSG(_(e_invarg));</a>
<a name="ln9273">          goto theend;</a>
<a name="ln9274">        }</a>
<a name="ln9275">        if (info.item_compare_func != NULL) {</a>
<a name="ln9276">          if (*info.item_compare_func == NUL) {</a>
<a name="ln9277">            // empty string means default sort</a>
<a name="ln9278">            info.item_compare_func = NULL;</a>
<a name="ln9279">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln9280">            info.item_compare_func = NULL;</a>
<a name="ln9281">            info.item_compare_numeric = true;</a>
<a name="ln9282">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln9283">            info.item_compare_func = NULL;</a>
<a name="ln9284">            info.item_compare_numbers = true;</a>
<a name="ln9285">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln9286">            info.item_compare_func = NULL;</a>
<a name="ln9287">            info.item_compare_float = true;</a>
<a name="ln9288">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln9289">            info.item_compare_func = NULL;</a>
<a name="ln9290">            info.item_compare_ic = true;</a>
<a name="ln9291">          }</a>
<a name="ln9292">        }</a>
<a name="ln9293">      }</a>
<a name="ln9294"> </a>
<a name="ln9295">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9296">        // optional third argument: {dict}</a>
<a name="ln9297">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln9298">          EMSG(_(e_dictreq));</a>
<a name="ln9299">          goto theend;</a>
<a name="ln9300">        }</a>
<a name="ln9301">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln9302">      }</a>
<a name="ln9303">    }</a>
<a name="ln9304"> </a>
<a name="ln9305">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln9306">    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));</a>
<a name="ln9307"> </a>
<a name="ln9308">    if (sort) {</a>
<a name="ln9309">      info.item_compare_func_err = false;</a>
<a name="ln9310">      tv_list_item_sort(l, ptrs,</a>
<a name="ln9311">                        ((info.item_compare_func == NULL</a>
<a name="ln9312">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln9313">                         ? item_compare_not_keeping_zero</a>
<a name="ln9314">                         : item_compare2_not_keeping_zero),</a>
<a name="ln9315">                        &amp;info.item_compare_func_err);</a>
<a name="ln9316">      if (info.item_compare_func_err) {</a>
<a name="ln9317">        EMSG(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln9318">      }</a>
<a name="ln9319">    } else {</a>
<a name="ln9320">      ListSorter item_compare_func_ptr;</a>
<a name="ln9321"> </a>
<a name="ln9322">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln9323">      info.item_compare_func_err = false;</a>
<a name="ln9324">      if (info.item_compare_func != NULL</a>
<a name="ln9325">          || info.item_compare_partial != NULL) {</a>
<a name="ln9326">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln9327">      } else {</a>
<a name="ln9328">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln9329">      }</a>
<a name="ln9330"> </a>
<a name="ln9331">      int idx = 0;</a>
<a name="ln9332">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln9333">           ; li != NULL;) {</a>
<a name="ln9334">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln9335">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln9336">          if (info.item_compare_func_err) {  // -V547</a>
<a name="ln9337">            EMSG(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln9338">            break;</a>
<a name="ln9339">          }</a>
<a name="ln9340">          li = tv_list_item_remove(l, li);</a>
<a name="ln9341">        } else {</a>
<a name="ln9342">          idx++;</a>
<a name="ln9343">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln9344">        }</a>
<a name="ln9345">      }</a>
<a name="ln9346">    }</a>
<a name="ln9347"> </a>
<a name="ln9348">    xfree(ptrs);</a>
<a name="ln9349">  }</a>
<a name="ln9350"> </a>
<a name="ln9351">theend:</a>
<a name="ln9352">  sortinfo = old_sortinfo;</a>
<a name="ln9353">}</a>
<a name="ln9354"> </a>
<a name="ln9355">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln9356">static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9357">{</a>
<a name="ln9358">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln9359">}</a>
<a name="ln9360"> </a>
<a name="ln9361">/// &quot;stdioopen()&quot; function</a>
<a name="ln9362">static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9363">{</a>
<a name="ln9364">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln9365">    EMSG(_(e_invarg));</a>
<a name="ln9366">    return;</a>
<a name="ln9367">  }</a>
<a name="ln9368"> </a>
<a name="ln9369"> </a>
<a name="ln9370">  bool rpc = false;</a>
<a name="ln9371">  CallbackReader on_stdin = CALLBACK_READER_INIT;</a>
<a name="ln9372">  dict_T *opts = argvars[0].vval.v_dict;</a>
<a name="ln9373">  rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9374"> </a>
<a name="ln9375">  if (!tv_dict_get_callback(opts, S_LEN(&quot;on_stdin&quot;), &amp;on_stdin.cb)) {</a>
<a name="ln9376">    return;</a>
<a name="ln9377">  }</a>
<a name="ln9378">  on_stdin.buffered = tv_dict_get_number(opts, &quot;stdin_buffered&quot;);</a>
<a name="ln9379">  if (on_stdin.buffered &amp;&amp; on_stdin.cb.type == kCallbackNone) {</a>
<a name="ln9380">    on_stdin.self = opts;</a>
<a name="ln9381">  }</a>
<a name="ln9382"> </a>
<a name="ln9383">  const char *error;</a>
<a name="ln9384">  uint64_t id = channel_from_stdio(rpc, on_stdin, &amp;error);</a>
<a name="ln9385">  if (!id) {</a>
<a name="ln9386">    EMSG2(e_stdiochan2, error);</a>
<a name="ln9387">  }</a>
<a name="ln9388"> </a>
<a name="ln9389"> </a>
<a name="ln9390">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9391">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9392">}</a>
<a name="ln9393"> </a>
<a name="ln9394">/// &quot;uniq({list})&quot; function</a>
<a name="ln9395">static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9396">{</a>
<a name="ln9397">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln9398">}</a>
<a name="ln9399"> </a>
<a name="ln9400">// &quot;reltimefloat()&quot; function</a>
<a name="ln9401">static void f_reltimefloat(typval_T *argvars , typval_T *rettv, FunPtr fptr)</a>
<a name="ln9402">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9403">{</a>
<a name="ln9404">  proftime_T tm;</a>
<a name="ln9405"> </a>
<a name="ln9406">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9407">  rettv-&gt;vval.v_float = 0;</a>
<a name="ln9408">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln9409">    rettv-&gt;vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;</a>
<a name="ln9410">  }</a>
<a name="ln9411">}</a>
<a name="ln9412"> </a>
<a name="ln9413">/*</a>
<a name="ln9414"> * &quot;soundfold({word})&quot; function</a>
<a name="ln9415"> */</a>
<a name="ln9416">static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9417">{</a>
<a name="ln9418">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9419">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9420">  rettv-&gt;vval.v_string = (char_u *)eval_soundfold(s);</a>
<a name="ln9421">}</a>
<a name="ln9422"> </a>
<a name="ln9423">/*</a>
<a name="ln9424"> * &quot;spellbadword()&quot; function</a>
<a name="ln9425"> */</a>
<a name="ln9426">static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9427">{</a>
<a name="ln9428">  const char *word = &quot;&quot;;</a>
<a name="ln9429">  hlf_T attr = HLF_COUNT;</a>
<a name="ln9430">  size_t len = 0;</a>
<a name="ln9431"> </a>
<a name="ln9432">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9433">    // Find the start and length of the badly spelled word.</a>
<a name="ln9434">    len = spell_move_to(curwin, FORWARD, true, true, &amp;attr);</a>
<a name="ln9435">    if (len != 0) {</a>
<a name="ln9436">      word = (char *)get_cursor_pos_ptr();</a>
<a name="ln9437">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln9438">    }</a>
<a name="ln9439">  } else if (curwin-&gt;w_p_spell &amp;&amp; *curbuf-&gt;b_s.b_p_spl != NUL) {</a>
<a name="ln9440">    const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9441">    int capcol = -1;</a>
<a name="ln9442"> </a>
<a name="ln9443">    if (str != NULL) {</a>
<a name="ln9444">      // Check the argument for spelling.</a>
<a name="ln9445">      while (*str != NUL) {</a>
<a name="ln9446">        len = spell_check(curwin, (char_u *)str, &amp;attr, &amp;capcol, false);</a>
<a name="ln9447">        if (attr != HLF_COUNT) {</a>
<a name="ln9448">          word = str;</a>
<a name="ln9449">          break;</a>
<a name="ln9450">        }</a>
<a name="ln9451">        str += len;</a>
<a name="ln9452">        capcol -= len;</a>
<a name="ln9453">        len = 0;</a>
<a name="ln9454">      }</a>
<a name="ln9455">    }</a>
<a name="ln9456">  }</a>
<a name="ln9457"> </a>
<a name="ln9458">  assert(len &lt;= INT_MAX);</a>
<a name="ln9459">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln9460">  tv_list_append_string(rettv-&gt;vval.v_list, word, len);</a>
<a name="ln9461">  tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln9462">                        (attr == HLF_SPB ? &quot;bad&quot;</a>
<a name="ln9463">                         : attr == HLF_SPR ? &quot;rare&quot;</a>
<a name="ln9464">                         : attr == HLF_SPL ? &quot;local&quot;</a>
<a name="ln9465">                         : attr == HLF_SPC ? &quot;caps&quot;</a>
<a name="ln9466">                         : NULL), -1);</a>
<a name="ln9467">}</a>
<a name="ln9468"> </a>
<a name="ln9469">/*</a>
<a name="ln9470"> * &quot;spellsuggest()&quot; function</a>
<a name="ln9471"> */</a>
<a name="ln9472">static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9473">{</a>
<a name="ln9474">  bool typeerr = false;</a>
<a name="ln9475">  int maxcount;</a>
<a name="ln9476">  garray_T ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln9477">  bool need_capital = false;</a>
<a name="ln9478"> </a>
<a name="ln9479">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln9480">    const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9481">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9482">      maxcount = tv_get_number_chk(&amp;argvars[1], &amp;typeerr);</a>
<a name="ln9483">      if (maxcount &lt;= 0) {</a>
<a name="ln9484">        goto f_spellsuggest_return;</a>
<a name="ln9485">      }</a>
<a name="ln9486">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9487">        need_capital = tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9488">        if (typeerr) {</a>
<a name="ln9489">          goto f_spellsuggest_return;</a>
<a name="ln9490">        }</a>
<a name="ln9491">      }</a>
<a name="ln9492">    } else {</a>
<a name="ln9493">      maxcount = 25;</a>
<a name="ln9494">    }</a>
<a name="ln9495"> </a>
<a name="ln9496">    spell_suggest_list(&amp;ga, (char_u *)str, maxcount, need_capital, false);</a>
<a name="ln9497">  }</a>
<a name="ln9498"> </a>
<a name="ln9499">f_spellsuggest_return:</a>
<a name="ln9500">  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);</a>
<a name="ln9501">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln9502">    char *const p = ((char **)ga.ga_data)[i];</a>
<a name="ln9503">    tv_list_append_allocated_string(rettv-&gt;vval.v_list, p);</a>
<a name="ln9504">  }</a>
<a name="ln9505">  ga_clear(&amp;ga);</a>
<a name="ln9506">}</a>
<a name="ln9507"> </a>
<a name="ln9508">static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9509">{</a>
<a name="ln9510">  char_u      *save_cpo;</a>
<a name="ln9511">  int match;</a>
<a name="ln9512">  colnr_T col = 0;</a>
<a name="ln9513">  bool keepempty = false;</a>
<a name="ln9514">  bool typeerr = false;</a>
<a name="ln9515"> </a>
<a name="ln9516">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln9517">  save_cpo = p_cpo;</a>
<a name="ln9518">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln9519"> </a>
<a name="ln9520">  const char *str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9521">  const char *pat = NULL;</a>
<a name="ln9522">  char patbuf[NUMBUFLEN];</a>
<a name="ln9523">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9524">    pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln9525">    if (pat == NULL) {</a>
<a name="ln9526">      typeerr = true;</a>
<a name="ln9527">    }</a>
<a name="ln9528">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9529">      keepempty = (bool)tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9530">    }</a>
<a name="ln9531">  }</a>
<a name="ln9532">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln9533">    pat = &quot;[\\x01- ]\\+&quot;;</a>
<a name="ln9534">  }</a>
<a name="ln9535"> </a>
<a name="ln9536">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9537"> </a>
<a name="ln9538">  if (typeerr) {</a>
<a name="ln9539">    goto theend;</a>
<a name="ln9540">  }</a>
<a name="ln9541"> </a>
<a name="ln9542">  regmatch_T regmatch = {</a>
<a name="ln9543">    .regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING),</a>
<a name="ln9544">    .startp = { NULL },</a>
<a name="ln9545">    .endp = { NULL },</a>
<a name="ln9546">    .rm_ic = false,</a>
<a name="ln9547">  };</a>
<a name="ln9548">  if (regmatch.regprog != NULL) {</a>
<a name="ln9549">    while (*str != NUL || keepempty) {</a>
<a name="ln9550">      if (*str == NUL) {</a>
<a name="ln9551">        match = false;  // Empty item at the end.</a>
<a name="ln9552">      } else {</a>
<a name="ln9553">        match = vim_regexec_nl(&amp;regmatch, (char_u *)str, col);</a>
<a name="ln9554">      }</a>
<a name="ln9555">      const char *end;</a>
<a name="ln9556">      if (match) {</a>
<a name="ln9557">        end = (const char *)regmatch.startp[0];</a>
<a name="ln9558">      } else {</a>
<a name="ln9559">        end = str + strlen(str);</a>
<a name="ln9560">      }</a>
<a name="ln9561">      if (keepempty || end &gt; str || (tv_list_len(rettv-&gt;vval.v_list) &gt; 0</a>
<a name="ln9562">                                     &amp;&amp; *str != NUL</a>
<a name="ln9563">                                     &amp;&amp; match</a>
<a name="ln9564">                                     &amp;&amp; end &lt; (const char *)regmatch.endp[0])) {</a>
<a name="ln9565">        tv_list_append_string(rettv-&gt;vval.v_list, str, end - str);</a>
<a name="ln9566">      }</a>
<a name="ln9567">      if (!match) {</a>
<a name="ln9568">        break;</a>
<a name="ln9569">      }</a>
<a name="ln9570">      // Advance to just after the match.</a>
<a name="ln9571">      if (regmatch.endp[0] &gt; (char_u *)str) {</a>
<a name="ln9572">        col = 0;</a>
<a name="ln9573">      } else {</a>
<a name="ln9574">        // Don't get stuck at the same match.</a>
<a name="ln9575">        col = (*mb_ptr2len)(regmatch.endp[0]);</a>
<a name="ln9576">      }</a>
<a name="ln9577">      str = (const char *)regmatch.endp[0];</a>
<a name="ln9578">    }</a>
<a name="ln9579"> </a>
<a name="ln9580">    vim_regfree(regmatch.regprog);</a>
<a name="ln9581">  }</a>
<a name="ln9582"> </a>
<a name="ln9583">theend:</a>
<a name="ln9584">  p_cpo = save_cpo;</a>
<a name="ln9585">}</a>
<a name="ln9586"> </a>
<a name="ln9587">/// &quot;stdpath(type)&quot; function</a>
<a name="ln9588">static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9589">{</a>
<a name="ln9590">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9591">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln9592"> </a>
<a name="ln9593">  const char *const p = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9594">  if (p == NULL) {</a>
<a name="ln9595">    return;  // Type error; errmsg already given.</a>
<a name="ln9596">  }</a>
<a name="ln9597"> </a>
<a name="ln9598">  if (strequal(p, &quot;config&quot;)) {</a>
<a name="ln9599">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);</a>
<a name="ln9600">  } else if (strequal(p, &quot;data&quot;)) {</a>
<a name="ln9601">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);</a>
<a name="ln9602">  } else if (strequal(p, &quot;cache&quot;)) {</a>
<a name="ln9603">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);</a>
<a name="ln9604">  } else if (strequal(p, &quot;config_dirs&quot;)) {</a>
<a name="ln9605">    get_xdg_var_list(kXDGConfigDirs, rettv);</a>
<a name="ln9606">  } else if (strequal(p, &quot;data_dirs&quot;)) {</a>
<a name="ln9607">    get_xdg_var_list(kXDGDataDirs, rettv);</a>
<a name="ln9608">  } else {</a>
<a name="ln9609">    EMSG2(_(&quot;E6100: \&quot;%s\&quot; is not a valid stdpath&quot;), p);</a>
<a name="ln9610">  }</a>
<a name="ln9611">}</a>
<a name="ln9612"> </a>
<a name="ln9613">/*</a>
<a name="ln9614"> * &quot;str2float()&quot; function</a>
<a name="ln9615"> */</a>
<a name="ln9616">static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9617">{</a>
<a name="ln9618">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9619">  bool isneg = (*p == '-');</a>
<a name="ln9620"> </a>
<a name="ln9621">  if (*p == '+' || *p == '-') {</a>
<a name="ln9622">    p = skipwhite(p + 1);</a>
<a name="ln9623">  }</a>
<a name="ln9624">  (void)string2float((char *)p, &amp;rettv-&gt;vval.v_float);</a>
<a name="ln9625">  if (isneg) {</a>
<a name="ln9626">    rettv-&gt;vval.v_float *= -1;</a>
<a name="ln9627">  }</a>
<a name="ln9628">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9629">}</a>
<a name="ln9630"> </a>
<a name="ln9631">// &quot;str2list()&quot; function</a>
<a name="ln9632">static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9633">{</a>
<a name="ln9634">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln9635">  const char_u *p = (const char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9636"> </a>
<a name="ln9637">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln9638">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln9639">  }</a>
<a name="ln9640">}</a>
<a name="ln9641"> </a>
<a name="ln9642">// &quot;str2nr()&quot; function</a>
<a name="ln9643">static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9644">{</a>
<a name="ln9645">  int base = 10;</a>
<a name="ln9646">  varnumber_T n;</a>
<a name="ln9647">  int what;</a>
<a name="ln9648"> </a>
<a name="ln9649">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9650">    base = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9651">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln9652">      EMSG(_(e_invarg));</a>
<a name="ln9653">      return;</a>
<a name="ln9654">    }</a>
<a name="ln9655">  }</a>
<a name="ln9656"> </a>
<a name="ln9657">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9658">  bool isneg = (*p == '-');</a>
<a name="ln9659">  if (*p == '+' || *p == '-') {</a>
<a name="ln9660">    p = skipwhite(p + 1);</a>
<a name="ln9661">  }</a>
<a name="ln9662">  switch (base) {</a>
<a name="ln9663">    case 2: {</a>
<a name="ln9664">      what = STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln9665">      break;</a>
<a name="ln9666">    }</a>
<a name="ln9667">    case 8: {</a>
<a name="ln9668">      what = STR2NR_OCT | STR2NR_FORCE;</a>
<a name="ln9669">      break;</a>
<a name="ln9670">    }</a>
<a name="ln9671">    case 16: {</a>
<a name="ln9672">      what = STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln9673">      break;</a>
<a name="ln9674">    }</a>
<a name="ln9675">    default: {</a>
<a name="ln9676">      what = 0;</a>
<a name="ln9677">    }</a>
<a name="ln9678">  }</a>
<a name="ln9679">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0);</a>
<a name="ln9680">  if (isneg) {</a>
<a name="ln9681">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln9682">  } else {</a>
<a name="ln9683">    rettv-&gt;vval.v_number = n;</a>
<a name="ln9684">  }</a>
<a name="ln9685">}</a>
<a name="ln9686"> </a>
<a name="ln9687">/*</a>
<a name="ln9688"> * &quot;strftime({format}[, {time}])&quot; function</a>
<a name="ln9689"> */</a>
<a name="ln9690">static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9691">{</a>
<a name="ln9692">  time_t seconds;</a>
<a name="ln9693"> </a>
<a name="ln9694">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9695"> </a>
<a name="ln9696">  char *p = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9697">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9698">    seconds = time(NULL);</a>
<a name="ln9699">  } else {</a>
<a name="ln9700">    seconds = (time_t)tv_get_number(&amp;argvars[1]);</a>
<a name="ln9701">  }</a>
<a name="ln9702"> </a>
<a name="ln9703">  struct tm curtime;</a>
<a name="ln9704">  struct tm *curtime_ptr = os_localtime_r(&amp;seconds, &amp;curtime);</a>
<a name="ln9705">  // MSVC returns NULL for an invalid value of seconds.</a>
<a name="ln9706">  if (curtime_ptr == NULL) {</a>
<a name="ln9707">    rettv-&gt;vval.v_string = vim_strsave((char_u *)_(&quot;(Invalid)&quot;));</a>
<a name="ln9708">  } else {</a>
<a name="ln9709">    vimconv_T conv;</a>
<a name="ln9710">    char_u      *enc;</a>
<a name="ln9711"> </a>
<a name="ln9712">    conv.vc_type = CONV_NONE;</a>
<a name="ln9713">    enc = enc_locale();</a>
<a name="ln9714">    convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln9715">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9716">      p = (char *)string_convert(&amp;conv, (char_u *)p, NULL);</a>
<a name="ln9717">    }</a>
<a name="ln9718">    char result_buf[256];</a>
<a name="ln9719">    if (p != NULL) {</a>
<a name="ln9720">      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);</a>
<a name="ln9721">    } else {</a>
<a name="ln9722">      result_buf[0] = NUL;</a>
<a name="ln9723">    }</a>
<a name="ln9724"> </a>
<a name="ln9725">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9726">      xfree(p);</a>
<a name="ln9727">    }</a>
<a name="ln9728">    convert_setup(&amp;conv, enc, p_enc);</a>
<a name="ln9729">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9730">      rettv-&gt;vval.v_string = string_convert(&amp;conv, (char_u *)result_buf, NULL);</a>
<a name="ln9731">    } else {</a>
<a name="ln9732">      rettv-&gt;vval.v_string = (char_u *)xstrdup(result_buf);</a>
<a name="ln9733">    }</a>
<a name="ln9734"> </a>
<a name="ln9735">    // Release conversion descriptors.</a>
<a name="ln9736">    convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln9737">    xfree(enc);</a>
<a name="ln9738">  }</a>
<a name="ln9739">}</a>
<a name="ln9740"> </a>
<a name="ln9741">// &quot;strgetchar()&quot; function</a>
<a name="ln9742">static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9743">{</a>
<a name="ln9744">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9745"> </a>
<a name="ln9746">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9747">  if (str == NULL) {</a>
<a name="ln9748">    return;</a>
<a name="ln9749">  }</a>
<a name="ln9750">  bool error = false;</a>
<a name="ln9751">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9752">  if (error) {</a>
<a name="ln9753">    return;</a>
<a name="ln9754">  }</a>
<a name="ln9755"> </a>
<a name="ln9756">  const size_t len = STRLEN(str);</a>
<a name="ln9757">  size_t byteidx = 0;</a>
<a name="ln9758"> </a>
<a name="ln9759">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln9760">    if (charidx == 0) {</a>
<a name="ln9761">      rettv-&gt;vval.v_number = utf_ptr2char((const char_u *)str + byteidx);</a>
<a name="ln9762">      break;</a>
<a name="ln9763">    }</a>
<a name="ln9764">    charidx--;</a>
<a name="ln9765">    byteidx += MB_CPTR2LEN((const char_u *)str + byteidx);</a>
<a name="ln9766">  }</a>
<a name="ln9767">}</a>
<a name="ln9768"> </a>
<a name="ln9769">/*</a>
<a name="ln9770"> * &quot;stridx()&quot; function</a>
<a name="ln9771"> */</a>
<a name="ln9772">static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9773">{</a>
<a name="ln9774">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9775"> </a>
<a name="ln9776">  char buf[NUMBUFLEN];</a>
<a name="ln9777">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9778">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln9779">  const char *const haystack_start = haystack;</a>
<a name="ln9780">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln9781">    return;  // Type error; errmsg already given.</a>
<a name="ln9782">  }</a>
<a name="ln9783"> </a>
<a name="ln9784">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9785">    bool error = false;</a>
<a name="ln9786"> </a>
<a name="ln9787">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln9788">                                                             &amp;error);</a>
<a name="ln9789">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln9790">      return;</a>
<a name="ln9791">    }</a>
<a name="ln9792">    if (start_idx &gt;= 0) {</a>
<a name="ln9793">      haystack += start_idx;</a>
<a name="ln9794">    }</a>
<a name="ln9795">  }</a>
<a name="ln9796"> </a>
<a name="ln9797">  const char *pos = strstr(haystack, needle);</a>
<a name="ln9798">  if (pos != NULL) {</a>
<a name="ln9799">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln9800">  }</a>
<a name="ln9801">}</a>
<a name="ln9802"> </a>
<a name="ln9803">/*</a>
<a name="ln9804"> * &quot;string()&quot; function</a>
<a name="ln9805"> */</a>
<a name="ln9806">void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9807">{</a>
<a name="ln9808">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9809">  rettv-&gt;vval.v_string = (char_u *)encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln9810">}</a>
<a name="ln9811"> </a>
<a name="ln9812">/*</a>
<a name="ln9813"> * &quot;strlen()&quot; function</a>
<a name="ln9814"> */</a>
<a name="ln9815">static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9816">{</a>
<a name="ln9817">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln9818">}</a>
<a name="ln9819"> </a>
<a name="ln9820">/*</a>
<a name="ln9821"> * &quot;strchars()&quot; function</a>
<a name="ln9822"> */</a>
<a name="ln9823">static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9824">{</a>
<a name="ln9825">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9826">  int skipcc = 0;</a>
<a name="ln9827">  varnumber_T len = 0;</a>
<a name="ln9828">  int (*func_mb_ptr2char_adv)(const char_u **pp);</a>
<a name="ln9829"> </a>
<a name="ln9830">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9831">    skipcc = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln9832">  }</a>
<a name="ln9833">  if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln9834">    EMSG(_(e_invarg));</a>
<a name="ln9835">  } else {</a>
<a name="ln9836">    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln9837">    while (*s != NUL) {</a>
<a name="ln9838">      func_mb_ptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln9839">      len++;</a>
<a name="ln9840">    }</a>
<a name="ln9841">    rettv-&gt;vval.v_number = len;</a>
<a name="ln9842">  }</a>
<a name="ln9843">}</a>
<a name="ln9844"> </a>
<a name="ln9845">/*</a>
<a name="ln9846"> * &quot;strdisplaywidth()&quot; function</a>
<a name="ln9847"> */</a>
<a name="ln9848">static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9849">{</a>
<a name="ln9850">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9851">  int col = 0;</a>
<a name="ln9852"> </a>
<a name="ln9853">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9854">    col = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9855">  }</a>
<a name="ln9856"> </a>
<a name="ln9857">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);</a>
<a name="ln9858">}</a>
<a name="ln9859"> </a>
<a name="ln9860">/*</a>
<a name="ln9861"> * &quot;strwidth()&quot; function</a>
<a name="ln9862"> */</a>
<a name="ln9863">static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9864">{</a>
<a name="ln9865">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9866"> </a>
<a name="ln9867">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);</a>
<a name="ln9868">}</a>
<a name="ln9869"> </a>
<a name="ln9870">// &quot;strcharpart()&quot; function</a>
<a name="ln9871">static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9872">{</a>
<a name="ln9873">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9874">  const size_t slen = STRLEN(p);</a>
<a name="ln9875"> </a>
<a name="ln9876">  int nbyte = 0;</a>
<a name="ln9877">  bool error = false;</a>
<a name="ln9878">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9879">  if (!error) {</a>
<a name="ln9880">    if (nchar &gt; 0) {</a>
<a name="ln9881">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln9882">        nbyte += MB_CPTR2LEN((const char_u *)p + nbyte);</a>
<a name="ln9883">        nchar--;</a>
<a name="ln9884">      }</a>
<a name="ln9885">    } else {</a>
<a name="ln9886">      nbyte = nchar;</a>
<a name="ln9887">    }</a>
<a name="ln9888">  }</a>
<a name="ln9889">  int len = 0;</a>
<a name="ln9890">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9891">    int charlen = tv_get_number(&amp;argvars[2]);</a>
<a name="ln9892">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln9893">      int off = nbyte + len;</a>
<a name="ln9894"> </a>
<a name="ln9895">      if (off &lt; 0) {</a>
<a name="ln9896">        len += 1;</a>
<a name="ln9897">      } else {</a>
<a name="ln9898">        len += (size_t)MB_CPTR2LEN((const char_u *)p + off);</a>
<a name="ln9899">      }</a>
<a name="ln9900">      charlen--;</a>
<a name="ln9901">    }</a>
<a name="ln9902">  } else {</a>
<a name="ln9903">    len = slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln9904">  }</a>
<a name="ln9905"> </a>
<a name="ln9906">  // Only return the overlap between the specified part and the actual</a>
<a name="ln9907">  // string.</a>
<a name="ln9908">  if (nbyte &lt; 0) {</a>
<a name="ln9909">    len += nbyte;</a>
<a name="ln9910">    nbyte = 0;</a>
<a name="ln9911">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln9912">    nbyte = slen;</a>
<a name="ln9913">  }</a>
<a name="ln9914">  if (len &lt; 0) {</a>
<a name="ln9915">    len = 0;</a>
<a name="ln9916">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln9917">    len = slen - nbyte;</a>
<a name="ln9918">  }</a>
<a name="ln9919"> </a>
<a name="ln9920">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9921">  rettv-&gt;vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln9922">}</a>
<a name="ln9923"> </a>
<a name="ln9924">/*</a>
<a name="ln9925"> * &quot;strpart()&quot; function</a>
<a name="ln9926"> */</a>
<a name="ln9927">static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9928">{</a>
<a name="ln9929">  bool error = false;</a>
<a name="ln9930"> </a>
<a name="ln9931">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9932">  const size_t slen = strlen(p);</a>
<a name="ln9933"> </a>
<a name="ln9934">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9935">  varnumber_T len;</a>
<a name="ln9936">  if (error) {</a>
<a name="ln9937">    len = 0;</a>
<a name="ln9938">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9939">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln9940">  } else {</a>
<a name="ln9941">    len = slen - n;  // Default len: all bytes that are available.</a>
<a name="ln9942">  }</a>
<a name="ln9943"> </a>
<a name="ln9944">  // Only return the overlap between the specified part and the actual</a>
<a name="ln9945">  // string.</a>
<a name="ln9946">  if (n &lt; 0) {</a>
<a name="ln9947">    len += n;</a>
<a name="ln9948">    n = 0;</a>
<a name="ln9949">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln9950">    n = slen;</a>
<a name="ln9951">  }</a>
<a name="ln9952">  if (len &lt; 0) {</a>
<a name="ln9953">    len = 0;</a>
<a name="ln9954">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln9955">    len = slen - n;</a>
<a name="ln9956">  }</a>
<a name="ln9957"> </a>
<a name="ln9958">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln9959">    int off;</a>
<a name="ln9960"> </a>
<a name="ln9961">    // length in characters</a>
<a name="ln9962">    for (off = n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln9963">      off += utfc_ptr2len((char_u *)p + off);</a>
<a name="ln9964">    }</a>
<a name="ln9965">    len = off - n;</a>
<a name="ln9966">  }</a>
<a name="ln9967"> </a>
<a name="ln9968">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9969">  rettv-&gt;vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);</a>
<a name="ln9970">}</a>
<a name="ln9971"> </a>
<a name="ln9972">/*</a>
<a name="ln9973"> * &quot;strridx()&quot; function</a>
<a name="ln9974"> */</a>
<a name="ln9975">static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9976">{</a>
<a name="ln9977">  char buf[NUMBUFLEN];</a>
<a name="ln9978">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9979">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln9980"> </a>
<a name="ln9981">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9982">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln9983">    return;  // Type error; errmsg already given.</a>
<a name="ln9984">  }</a>
<a name="ln9985"> </a>
<a name="ln9986">  const size_t haystack_len = STRLEN(haystack);</a>
<a name="ln9987">  ptrdiff_t end_idx;</a>
<a name="ln9988">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9989">    // Third argument: upper limit for index.</a>
<a name="ln9990">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln9991">    if (end_idx &lt; 0) {</a>
<a name="ln9992">      return;  // Can never find a match.</a>
<a name="ln9993">    }</a>
<a name="ln9994">  } else {</a>
<a name="ln9995">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln9996">  }</a>
<a name="ln9997"> </a>
<a name="ln9998">  const char *lastmatch = NULL;</a>
<a name="ln9999">  if (*needle == NUL) {</a>
<a name="ln10000">    // Empty string matches past the end.</a>
<a name="ln10001">    lastmatch = haystack + end_idx;</a>
<a name="ln10002">  } else {</a>
<a name="ln10003">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln10004">      rest = strstr(rest, needle);</a>
<a name="ln10005">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln10006">        break;</a>
<a name="ln10007">      }</a>
<a name="ln10008">      lastmatch = rest;</a>
<a name="ln10009">    }</a>
<a name="ln10010">  }</a>
<a name="ln10011"> </a>
<a name="ln10012">  if (lastmatch != NULL) {</a>
<a name="ln10013">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln10014">  }</a>
<a name="ln10015">}</a>
<a name="ln10016"> </a>
<a name="ln10017">/*</a>
<a name="ln10018"> * &quot;strtrans()&quot; function</a>
<a name="ln10019"> */</a>
<a name="ln10020">static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10021">{</a>
<a name="ln10022">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10023">  rettv-&gt;vval.v_string = (char_u *)transstr(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10024">}</a>
<a name="ln10025"> </a>
<a name="ln10026">/*</a>
<a name="ln10027"> * &quot;submatch()&quot; function</a>
<a name="ln10028"> */</a>
<a name="ln10029">static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10030">{</a>
<a name="ln10031">  bool error = false;</a>
<a name="ln10032">  int no = (int)tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln10033">  if (error) {</a>
<a name="ln10034">    return;</a>
<a name="ln10035">  }</a>
<a name="ln10036"> </a>
<a name="ln10037">  if (no &lt; 0 || no &gt;= NSUBEXP) {</a>
<a name="ln10038">    emsgf(_(&quot;E935: invalid submatch number: %d&quot;), no);</a>
<a name="ln10039">    return;</a>
<a name="ln10040">  }</a>
<a name="ln10041">  int retList = 0;</a>
<a name="ln10042"> </a>
<a name="ln10043">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10044">    retList = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10045">    if (error) {</a>
<a name="ln10046">      return;</a>
<a name="ln10047">    }</a>
<a name="ln10048">  }</a>
<a name="ln10049"> </a>
<a name="ln10050">  if (retList == 0) {</a>
<a name="ln10051">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10052">    rettv-&gt;vval.v_string = reg_submatch(no);</a>
<a name="ln10053">  } else {</a>
<a name="ln10054">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln10055">    rettv-&gt;vval.v_list = reg_submatch_list(no);</a>
<a name="ln10056">  }</a>
<a name="ln10057">}</a>
<a name="ln10058"> </a>
<a name="ln10059">/*</a>
<a name="ln10060"> * &quot;substitute()&quot; function</a>
<a name="ln10061"> */</a>
<a name="ln10062">static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10063">{</a>
<a name="ln10064">  char patbuf[NUMBUFLEN];</a>
<a name="ln10065">  char subbuf[NUMBUFLEN];</a>
<a name="ln10066">  char flagsbuf[NUMBUFLEN];</a>
<a name="ln10067"> </a>
<a name="ln10068">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10069">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln10070">  const char *sub = NULL;</a>
<a name="ln10071">  const char *const flg = tv_get_string_buf_chk(&amp;argvars[3], flagsbuf);</a>
<a name="ln10072"> </a>
<a name="ln10073">  typval_T *expr = NULL;</a>
<a name="ln10074">  if (tv_is_func(argvars[2])) {</a>
<a name="ln10075">    expr = &amp;argvars[2];</a>
<a name="ln10076">  } else {</a>
<a name="ln10077">    sub = tv_get_string_buf_chk(&amp;argvars[2], subbuf);</a>
<a name="ln10078">  }</a>
<a name="ln10079"> </a>
<a name="ln10080">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10081">  if (str == NULL || pat == NULL || (sub == NULL &amp;&amp; expr == NULL)</a>
<a name="ln10082">      || flg == NULL) {</a>
<a name="ln10083">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10084">  } else {</a>
<a name="ln10085">    rettv-&gt;vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,</a>
<a name="ln10086">                                         (char_u *)sub, expr, (char_u *)flg);</a>
<a name="ln10087">  }</a>
<a name="ln10088">}</a>
<a name="ln10089"> </a>
<a name="ln10090">/// &quot;swapinfo(swap_filename)&quot; function</a>
<a name="ln10091">static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10092">{</a>
<a name="ln10093">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10094">  get_b0_dict(tv_get_string(argvars), rettv-&gt;vval.v_dict);</a>
<a name="ln10095">}</a>
<a name="ln10096"> </a>
<a name="ln10097">/// &quot;swapname(expr)&quot; function</a>
<a name="ln10098">static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10099">{</a>
<a name="ln10100">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10101">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln10102">  if (buf == NULL</a>
<a name="ln10103">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln10104">      || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln10105">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10106">  } else {</a>
<a name="ln10107">    rettv-&gt;vval.v_string = vim_strsave(buf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln10108">  }</a>
<a name="ln10109">}</a>
<a name="ln10110"> </a>
<a name="ln10111">/// &quot;synID(lnum, col, trans)&quot; function</a>
<a name="ln10112">static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10113">{</a>
<a name="ln10114">  // -1 on type error (both)</a>
<a name="ln10115">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10116">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10117"> </a>
<a name="ln10118">  bool transerr = false;</a>
<a name="ln10119">  const int trans = tv_get_number_chk(&amp;argvars[2], &amp;transerr);</a>
<a name="ln10120"> </a>
<a name="ln10121">  int id = 0;</a>
<a name="ln10122">  if (!transerr &amp;&amp; lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10123">      &amp;&amp; col &gt;= 0 &amp;&amp; (size_t)col &lt; STRLEN(ml_get(lnum))) {</a>
<a name="ln10124">    id = syn_get_id(curwin, lnum, col, trans, NULL, false);</a>
<a name="ln10125">  }</a>
<a name="ln10126"> </a>
<a name="ln10127">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10128">}</a>
<a name="ln10129"> </a>
<a name="ln10130">/*</a>
<a name="ln10131"> * &quot;synIDattr(id, what [, mode])&quot; function</a>
<a name="ln10132"> */</a>
<a name="ln10133">static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10134">{</a>
<a name="ln10135">  const int id = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln10136">  const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10137">  int modec;</a>
<a name="ln10138">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10139">    char modebuf[NUMBUFLEN];</a>
<a name="ln10140">    const char *const mode = tv_get_string_buf(&amp;argvars[2], modebuf);</a>
<a name="ln10141">    modec = TOLOWER_ASC(mode[0]);</a>
<a name="ln10142">    if (modec != 'c' &amp;&amp; modec != 'g') {</a>
<a name="ln10143">      modec = 0;  // Replace invalid with current.</a>
<a name="ln10144">    }</a>
<a name="ln10145">  } else if (ui_rgb_attached()) {</a>
<a name="ln10146">    modec = 'g';</a>
<a name="ln10147">  } else {</a>
<a name="ln10148">    modec = 'c';</a>
<a name="ln10149">  }</a>
<a name="ln10150"> </a>
<a name="ln10151"> </a>
<a name="ln10152">  const char *p = NULL;</a>
<a name="ln10153">  switch (TOLOWER_ASC(what[0])) {</a>
<a name="ln10154">    case 'b': {</a>
<a name="ln10155">      if (TOLOWER_ASC(what[1]) == 'g') {  // bg[#]</a>
<a name="ln10156">        p = highlight_color(id, what, modec);</a>
<a name="ln10157">      } else {  // bold</a>
<a name="ln10158">        p = highlight_has_attr(id, HL_BOLD, modec);</a>
<a name="ln10159">      }</a>
<a name="ln10160">      break;</a>
<a name="ln10161">    }</a>
<a name="ln10162">    case 'f': {  // fg[#] or font</a>
<a name="ln10163">      p = highlight_color(id, what, modec);</a>
<a name="ln10164">      break;</a>
<a name="ln10165">    }</a>
<a name="ln10166">    case 'i': {</a>
<a name="ln10167">      if (TOLOWER_ASC(what[1]) == 'n') {  // inverse</a>
<a name="ln10168">        p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10169">      } else {  // italic</a>
<a name="ln10170">        p = highlight_has_attr(id, HL_ITALIC, modec);</a>
<a name="ln10171">      }</a>
<a name="ln10172">      break;</a>
<a name="ln10173">    }</a>
<a name="ln10174">    case 'n': {  // name</a>
<a name="ln10175">      p = get_highlight_name_ext(NULL, id - 1, false);</a>
<a name="ln10176">      break;</a>
<a name="ln10177">    }</a>
<a name="ln10178">    case 'r': {  // reverse</a>
<a name="ln10179">      p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10180">      break;</a>
<a name="ln10181">    }</a>
<a name="ln10182">    case 's': {</a>
<a name="ln10183">      if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]</a>
<a name="ln10184">        p = highlight_color(id, what, modec);</a>
<a name="ln10185">      } else if (TOLOWER_ASC(what[1]) == 't'</a>
<a name="ln10186">                 &amp;&amp; TOLOWER_ASC(what[2]) == 'r') {  // strikethrough</a>
<a name="ln10187">        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);</a>
<a name="ln10188">      } else {  // standout</a>
<a name="ln10189">        p = highlight_has_attr(id, HL_STANDOUT, modec);</a>
<a name="ln10190">      }</a>
<a name="ln10191">      break;</a>
<a name="ln10192">    }</a>
<a name="ln10193">    case 'u': {</a>
<a name="ln10194">      if (STRLEN(what) &lt;= 5 || TOLOWER_ASC(what[5]) != 'c') {  // underline</a>
<a name="ln10195">        p = highlight_has_attr(id, HL_UNDERLINE, modec);</a>
<a name="ln10196">      } else {  // undercurl</a>
<a name="ln10197">        p = highlight_has_attr(id, HL_UNDERCURL, modec);</a>
<a name="ln10198">      }</a>
<a name="ln10199">      break;</a>
<a name="ln10200">    }</a>
<a name="ln10201">  }</a>
<a name="ln10202"> </a>
<a name="ln10203">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10204">  rettv-&gt;vval.v_string = (char_u *)(p == NULL ? p : xstrdup(p));</a>
<a name="ln10205">}</a>
<a name="ln10206"> </a>
<a name="ln10207">/*</a>
<a name="ln10208"> * &quot;synIDtrans(id)&quot; function</a>
<a name="ln10209"> */</a>
<a name="ln10210">static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10211">{</a>
<a name="ln10212">  int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln10213"> </a>
<a name="ln10214">  if (id &gt; 0) {</a>
<a name="ln10215">    id = syn_get_final_id(id);</a>
<a name="ln10216">  } else {</a>
<a name="ln10217">    id = 0;</a>
<a name="ln10218">  }</a>
<a name="ln10219"> </a>
<a name="ln10220">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10221">}</a>
<a name="ln10222"> </a>
<a name="ln10223">/*</a>
<a name="ln10224"> * &quot;synconcealed(lnum, col)&quot; function</a>
<a name="ln10225"> */</a>
<a name="ln10226">static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10227">{</a>
<a name="ln10228">  int syntax_flags = 0;</a>
<a name="ln10229">  int cchar;</a>
<a name="ln10230">  int matchid = 0;</a>
<a name="ln10231">  char_u str[NUMBUFLEN];</a>
<a name="ln10232"> </a>
<a name="ln10233">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10234"> </a>
<a name="ln10235">  // -1 on type error (both)</a>
<a name="ln10236">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10237">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10238"> </a>
<a name="ln10239">  memset(str, NUL, sizeof(str));</a>
<a name="ln10240"> </a>
<a name="ln10241">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; col &gt;= 0</a>
<a name="ln10242">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum)) &amp;&amp; curwin-&gt;w_p_cole &gt; 0) {</a>
<a name="ln10243">    (void)syn_get_id(curwin, lnum, col, false, NULL, false);</a>
<a name="ln10244">    syntax_flags = get_syntax_info(&amp;matchid);</a>
<a name="ln10245"> </a>
<a name="ln10246">    // get the conceal character</a>
<a name="ln10247">    if ((syntax_flags &amp; HL_CONCEAL) &amp;&amp; curwin-&gt;w_p_cole &lt; 3) {</a>
<a name="ln10248">      cchar = syn_get_sub_char();</a>
<a name="ln10249">      if (cchar == NUL &amp;&amp; curwin-&gt;w_p_cole == 1) {</a>
<a name="ln10250">        cchar = (curwin-&gt;w_p_lcs_chars.conceal == NUL)</a>
<a name="ln10251">          ? ' '</a>
<a name="ln10252">          : curwin-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln10253">      }</a>
<a name="ln10254">      if (cchar != NUL) {</a>
<a name="ln10255">        utf_char2bytes(cchar, str);</a>
<a name="ln10256">      }</a>
<a name="ln10257">    }</a>
<a name="ln10258">  }</a>
<a name="ln10259"> </a>
<a name="ln10260">  tv_list_alloc_ret(rettv, 3);</a>
<a name="ln10261">  tv_list_append_number(rettv-&gt;vval.v_list, (syntax_flags &amp; HL_CONCEAL) != 0);</a>
<a name="ln10262">  // -1 to auto-determine strlen</a>
<a name="ln10263">  tv_list_append_string(rettv-&gt;vval.v_list, (const char *)str, -1);</a>
<a name="ln10264">  tv_list_append_number(rettv-&gt;vval.v_list, matchid);</a>
<a name="ln10265">}</a>
<a name="ln10266"> </a>
<a name="ln10267">/*</a>
<a name="ln10268"> * &quot;synstack(lnum, col)&quot; function</a>
<a name="ln10269"> */</a>
<a name="ln10270">static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10271">{</a>
<a name="ln10272">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10273"> </a>
<a name="ln10274">  // -1 on type error (both)</a>
<a name="ln10275">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10276">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10277"> </a>
<a name="ln10278">  if (lnum &gt;= 1</a>
<a name="ln10279">      &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10280">      &amp;&amp; col &gt;= 0</a>
<a name="ln10281">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum))) {</a>
<a name="ln10282">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10283">    (void)syn_get_id(curwin, lnum, col, false, NULL, true);</a>
<a name="ln10284"> </a>
<a name="ln10285">    int id;</a>
<a name="ln10286">    int i = 0;</a>
<a name="ln10287">    while ((id = syn_get_stack_item(i++)) &gt;= 0) {</a>
<a name="ln10288">      tv_list_append_number(rettv-&gt;vval.v_list, id);</a>
<a name="ln10289">    }</a>
<a name="ln10290">  }</a>
<a name="ln10291">}</a>
<a name="ln10292"> </a>
<a name="ln10293">/// f_system - the VimL system() function</a>
<a name="ln10294">static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10295">{</a>
<a name="ln10296">  get_system_output_as_rettv(argvars, rettv, false);</a>
<a name="ln10297">}</a>
<a name="ln10298"> </a>
<a name="ln10299">static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10300">{</a>
<a name="ln10301">  get_system_output_as_rettv(argvars, rettv, true);</a>
<a name="ln10302">}</a>
<a name="ln10303"> </a>
<a name="ln10304"> </a>
<a name="ln10305">/*</a>
<a name="ln10306"> * &quot;tabpagebuflist()&quot; function</a>
<a name="ln10307"> */</a>
<a name="ln10308">static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10309">{</a>
<a name="ln10310">  win_T       *wp = NULL;</a>
<a name="ln10311"> </a>
<a name="ln10312">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln10313">    wp = firstwin;</a>
<a name="ln10314">  } else {</a>
<a name="ln10315">    tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10316">    if (tp != NULL) {</a>
<a name="ln10317">      wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10318">    }</a>
<a name="ln10319">  }</a>
<a name="ln10320">  if (wp != NULL) {</a>
<a name="ln10321">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10322">    while (wp != NULL) {</a>
<a name="ln10323">      tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln10324">      wp = wp-&gt;w_next;</a>
<a name="ln10325">    }</a>
<a name="ln10326">  }</a>
<a name="ln10327">}</a>
<a name="ln10328"> </a>
<a name="ln10329">/*</a>
<a name="ln10330"> * &quot;tabpagenr()&quot; function</a>
<a name="ln10331"> */</a>
<a name="ln10332">static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10333">{</a>
<a name="ln10334">  int nr = 1;</a>
<a name="ln10335"> </a>
<a name="ln10336">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10337">    const char *const arg = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10338">    nr = 0;</a>
<a name="ln10339">    if (arg != NULL) {</a>
<a name="ln10340">      if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10341">        nr = tabpage_index(NULL) - 1;</a>
<a name="ln10342">      } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10343">        nr = valid_tabpage(lastused_tabpage)</a>
<a name="ln10344">             ? tabpage_index(lastused_tabpage)</a>
<a name="ln10345">             : nr;</a>
<a name="ln10346">      } else {</a>
<a name="ln10347">        EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10348">      }</a>
<a name="ln10349">    }</a>
<a name="ln10350">  } else {</a>
<a name="ln10351">    nr = tabpage_index(curtab);</a>
<a name="ln10352">  }</a>
<a name="ln10353">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10354">}</a>
<a name="ln10355"> </a>
<a name="ln10356"> </a>
<a name="ln10357"> </a>
<a name="ln10358">/*</a>
<a name="ln10359"> * Common code for tabpagewinnr() and winnr().</a>
<a name="ln10360"> */</a>
<a name="ln10361">static int get_winnr(tabpage_T *tp, typval_T *argvar)</a>
<a name="ln10362">{</a>
<a name="ln10363">  win_T       *twin;</a>
<a name="ln10364">  int nr = 1;</a>
<a name="ln10365">  win_T       *wp;</a>
<a name="ln10366"> </a>
<a name="ln10367">  twin = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln10368">  if (argvar-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln10369">    bool invalid_arg = false;</a>
<a name="ln10370">    const char *const arg = tv_get_string_chk(argvar);</a>
<a name="ln10371">    if (arg == NULL) {</a>
<a name="ln10372">      nr = 0;  // Type error; errmsg already given.</a>
<a name="ln10373">    } else if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10374">      twin = (tp == curtab) ? lastwin : tp-&gt;tp_lastwin;</a>
<a name="ln10375">    } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10376">      twin = (tp == curtab) ? prevwin : tp-&gt;tp_prevwin;</a>
<a name="ln10377">      if (twin == NULL) {</a>
<a name="ln10378">        nr = 0;</a>
<a name="ln10379">      }</a>
<a name="ln10380">    } else {</a>
<a name="ln10381">      // Extract the window count (if specified). e.g. winnr('3j')</a>
<a name="ln10382">      char_u *endp;</a>
<a name="ln10383">      long count = strtol((char *)arg, (char **)&amp;endp, 10);</a>
<a name="ln10384">      if (count &lt;= 0) {</a>
<a name="ln10385">        // if count is not specified, default to 1</a>
<a name="ln10386">        count = 1;</a>
<a name="ln10387">      }</a>
<a name="ln10388">      if (endp != NULL &amp;&amp; *endp != '\0') {</a>
<a name="ln10389">        if (strequal((char *)endp, &quot;j&quot;)) {</a>
<a name="ln10390">          twin = win_vert_neighbor(tp, twin, false, count);</a>
<a name="ln10391">        } else if (strequal((char *)endp, &quot;k&quot;)) {</a>
<a name="ln10392">          twin = win_vert_neighbor(tp, twin, true, count);</a>
<a name="ln10393">        } else if (strequal((char *)endp, &quot;h&quot;)) {</a>
<a name="ln10394">          twin = win_horz_neighbor(tp, twin, true, count);</a>
<a name="ln10395">        } else if (strequal((char *)endp, &quot;l&quot;)) {</a>
<a name="ln10396">          twin = win_horz_neighbor(tp, twin, false, count);</a>
<a name="ln10397">        } else {</a>
<a name="ln10398">          invalid_arg = true;</a>
<a name="ln10399">        }</a>
<a name="ln10400">      } else {</a>
<a name="ln10401">        invalid_arg = true;</a>
<a name="ln10402">      }</a>
<a name="ln10403">    }</a>
<a name="ln10404"> </a>
<a name="ln10405">    if (invalid_arg) {</a>
<a name="ln10406">      EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10407">      nr = 0;</a>
<a name="ln10408">    }</a>
<a name="ln10409">  }</a>
<a name="ln10410"> </a>
<a name="ln10411">  if (nr &gt; 0)</a>
<a name="ln10412">    for (wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10413">         wp != twin; wp = wp-&gt;w_next) {</a>
<a name="ln10414">      if (wp == NULL) {</a>
<a name="ln10415">        // didn't find it in this tabpage</a>
<a name="ln10416">        nr = 0;</a>
<a name="ln10417">        break;</a>
<a name="ln10418">      }</a>
<a name="ln10419">      ++nr;</a>
<a name="ln10420">    }</a>
<a name="ln10421">  return nr;</a>
<a name="ln10422">}</a>
<a name="ln10423"> </a>
<a name="ln10424">/*</a>
<a name="ln10425"> * &quot;tabpagewinnr()&quot; function</a>
<a name="ln10426"> */</a>
<a name="ln10427">static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10428">{</a>
<a name="ln10429">  int nr = 1;</a>
<a name="ln10430">  tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10431">  if (tp == NULL) {</a>
<a name="ln10432">    nr = 0;</a>
<a name="ln10433">  } else {</a>
<a name="ln10434">    nr = get_winnr(tp, &amp;argvars[1]);</a>
<a name="ln10435">  }</a>
<a name="ln10436">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10437">}</a>
<a name="ln10438"> </a>
<a name="ln10439">/*</a>
<a name="ln10440"> * &quot;tagfiles()&quot; function</a>
<a name="ln10441"> */</a>
<a name="ln10442">static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10443">{</a>
<a name="ln10444">  char *fname;</a>
<a name="ln10445">  tagname_T tn;</a>
<a name="ln10446"> </a>
<a name="ln10447">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln10448">  fname = xmalloc(MAXPATHL);</a>
<a name="ln10449"> </a>
<a name="ln10450">  bool first = true;</a>
<a name="ln10451">  while (get_tagfname(&amp;tn, first, (char_u *)fname) == OK) {</a>
<a name="ln10452">    tv_list_append_string(rettv-&gt;vval.v_list, fname, -1);</a>
<a name="ln10453">    first = false;</a>
<a name="ln10454">  }</a>
<a name="ln10455"> </a>
<a name="ln10456">  tagname_free(&amp;tn);</a>
<a name="ln10457">  xfree(fname);</a>
<a name="ln10458">}</a>
<a name="ln10459"> </a>
<a name="ln10460">/*</a>
<a name="ln10461"> * &quot;taglist()&quot; function</a>
<a name="ln10462"> */</a>
<a name="ln10463">static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10464">{</a>
<a name="ln10465">  const char *const tag_pattern = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10466"> </a>
<a name="ln10467">  rettv-&gt;vval.v_number = false;</a>
<a name="ln10468">  if (*tag_pattern == NUL) {</a>
<a name="ln10469">    return;</a>
<a name="ln10470">  }</a>
<a name="ln10471"> </a>
<a name="ln10472">  const char *fname = NULL;</a>
<a name="ln10473">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10474">    fname = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10475">  }</a>
<a name="ln10476">  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),</a>
<a name="ln10477">                 (char_u *)tag_pattern, (char_u *)fname);</a>
<a name="ln10478">}</a>
<a name="ln10479"> </a>
<a name="ln10480">/*</a>
<a name="ln10481"> * &quot;tempname()&quot; function</a>
<a name="ln10482"> */</a>
<a name="ln10483">static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10484">{</a>
<a name="ln10485">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10486">  rettv-&gt;vval.v_string = vim_tempname();</a>
<a name="ln10487">}</a>
<a name="ln10488"> </a>
<a name="ln10489">// &quot;termopen(cmd[, cwd])&quot; function</a>
<a name="ln10490">static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10491">{</a>
<a name="ln10492">  if (check_secure()) {</a>
<a name="ln10493">    return;</a>
<a name="ln10494">  }</a>
<a name="ln10495"> </a>
<a name="ln10496">  if (curbuf-&gt;b_changed) {</a>
<a name="ln10497">    EMSG(_(&quot;Can only call this function in an unmodified buffer&quot;));</a>
<a name="ln10498">    return;</a>
<a name="ln10499">  }</a>
<a name="ln10500"> </a>
<a name="ln10501">  const char *cmd;</a>
<a name="ln10502">  bool executable = true;</a>
<a name="ln10503">  char **argv = tv_to_argv(&amp;argvars[0], &amp;cmd, &amp;executable);</a>
<a name="ln10504">  if (!argv) {</a>
<a name="ln10505">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln10506">    return;  // Did error message in tv_to_argv.</a>
<a name="ln10507">  }</a>
<a name="ln10508"> </a>
<a name="ln10509">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10510">    // Wrong argument type</a>
<a name="ln10511">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln10512">    shell_free_argv(argv);</a>
<a name="ln10513">    return;</a>
<a name="ln10514">  }</a>
<a name="ln10515"> </a>
<a name="ln10516">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln10517">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln10518">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln10519">  dict_T *job_opts = NULL;</a>
<a name="ln10520">  const char *cwd = &quot;.&quot;;</a>
<a name="ln10521">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln10522">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln10523"> </a>
<a name="ln10524">    const char *const new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln10525">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln10526">      cwd = new_cwd;</a>
<a name="ln10527">      // The new cwd must be a directory.</a>
<a name="ln10528">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln10529">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln10530">        shell_free_argv(argv);</a>
<a name="ln10531">        return;</a>
<a name="ln10532">      }</a>
<a name="ln10533">    }</a>
<a name="ln10534"> </a>
<a name="ln10535">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln10536">      shell_free_argv(argv);</a>
<a name="ln10537">      return;</a>
<a name="ln10538">    }</a>
<a name="ln10539">  }</a>
<a name="ln10540"> </a>
<a name="ln10541">  uint16_t term_width = MAX(0, curwin-&gt;w_width_inner - win_col_off(curwin));</a>
<a name="ln10542">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,</a>
<a name="ln10543">                                    true, false, false, false, cwd,</a>
<a name="ln10544">                                    term_width, curwin-&gt;w_height_inner,</a>
<a name="ln10545">                                    xstrdup(&quot;xterm-256color&quot;), NULL,</a>
<a name="ln10546">                                    &amp;rettv-&gt;vval.v_number);</a>
<a name="ln10547">  if (rettv-&gt;vval.v_number &lt;= 0) {</a>
<a name="ln10548">    return;</a>
<a name="ln10549">  }</a>
<a name="ln10550"> </a>
<a name="ln10551">  int pid = chan-&gt;stream.pty.process.pid;</a>
<a name="ln10552"> </a>
<a name="ln10553">  // &quot;./…&quot; =&gt; &quot;/home/foo/…&quot;</a>
<a name="ln10554">  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), false);</a>
<a name="ln10555">  // &quot;/home/foo/…&quot; =&gt; &quot;~/…&quot;</a>
<a name="ln10556">  size_t len = home_replace(NULL, NameBuff, IObuff, sizeof(IObuff), true);</a>
<a name="ln10557">  // Trim slash.</a>
<a name="ln10558">  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {</a>
<a name="ln10559">    IObuff[len - 1] = '\0';</a>
<a name="ln10560">  }</a>
<a name="ln10561"> </a>
<a name="ln10562">  // Terminal URI: &quot;term://$CWD//$PID:$CMD&quot;</a>
<a name="ln10563">  snprintf((char *)NameBuff, sizeof(NameBuff), &quot;term://%s//%d:%s&quot;,</a>
<a name="ln10564">           (char *)IObuff, pid, cmd);</a>
<a name="ln10565">  // at this point the buffer has no terminal instance associated yet, so unset</a>
<a name="ln10566">  // the 'swapfile' option to ensure no swap file will be created</a>
<a name="ln10567">  curbuf-&gt;b_p_swf = false;</a>
<a name="ln10568">  (void)setfname(curbuf, NameBuff, NULL, true);</a>
<a name="ln10569">  // Save the job id and pid in b:terminal_job_{id,pid}</a>
<a name="ln10570">  Error err = ERROR_INIT;</a>
<a name="ln10571">  // deprecated: use 'channel' buffer option</a>
<a name="ln10572">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_id&quot;),</a>
<a name="ln10573">               INTEGER_OBJ(chan-&gt;id), false, false, &amp;err);</a>
<a name="ln10574">  api_clear_error(&amp;err);</a>
<a name="ln10575">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_pid&quot;),</a>
<a name="ln10576">               INTEGER_OBJ(pid), false, false, &amp;err);</a>
<a name="ln10577">  api_clear_error(&amp;err);</a>
<a name="ln10578"> </a>
<a name="ln10579">  channel_terminal_open(chan);</a>
<a name="ln10580">  channel_create_event(chan, NULL);</a>
<a name="ln10581">}</a>
<a name="ln10582"> </a>
<a name="ln10583">// &quot;test_garbagecollect_now()&quot; function</a>
<a name="ln10584">static void f_test_garbagecollect_now(typval_T *argvars,</a>
<a name="ln10585">                                      typval_T *rettv, FunPtr fptr)</a>
<a name="ln10586">{</a>
<a name="ln10587">  // This is dangerous, any Lists and Dicts used internally may be freed</a>
<a name="ln10588">  // while still in use.</a>
<a name="ln10589">  garbage_collect(true);</a>
<a name="ln10590">}</a>
<a name="ln10591"> </a>
<a name="ln10592">// &quot;test_write_list_log()&quot; function</a>
<a name="ln10593">static void f_test_write_list_log(typval_T *const argvars,</a>
<a name="ln10594">                                  typval_T *const rettv,</a>
<a name="ln10595">                                  FunPtr fptr)</a>
<a name="ln10596">{</a>
<a name="ln10597">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10598">  if (fname == NULL) {</a>
<a name="ln10599">    return;</a>
<a name="ln10600">  }</a>
<a name="ln10601">  list_write_log(fname);</a>
<a name="ln10602">}</a>
<a name="ln10603"> </a>
<a name="ln10604">/// &quot;timer_info([timer])&quot; function</a>
<a name="ln10605">static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10606">{</a>
<a name="ln10607">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10608">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10609">      EMSG(_(e_number_exp));</a>
<a name="ln10610">      return;</a>
<a name="ln10611">    }</a>
<a name="ln10612">    tv_list_alloc_ret(rettv, 1);</a>
<a name="ln10613">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10614">    if (timer != NULL &amp;&amp; !timer-&gt;stopped) {</a>
<a name="ln10615">      add_timer_info(rettv, timer);</a>
<a name="ln10616">    }</a>
<a name="ln10617">  } else {</a>
<a name="ln10618">    add_timer_info_all(rettv);</a>
<a name="ln10619">  }</a>
<a name="ln10620">}</a>
<a name="ln10621"> </a>
<a name="ln10622">/// &quot;timer_pause(timer, paused)&quot; function</a>
<a name="ln10623">static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10624">{</a>
<a name="ln10625">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10626">    EMSG(_(e_number_exp));</a>
<a name="ln10627">    return;</a>
<a name="ln10628">  }</a>
<a name="ln10629">  int paused = (bool)tv_get_number(&amp;argvars[1]);</a>
<a name="ln10630">  timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10631">  if (timer != NULL) {</a>
<a name="ln10632">    if (!timer-&gt;paused &amp;&amp; paused) {</a>
<a name="ln10633">      time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln10634">    } else if (timer-&gt;paused &amp;&amp; !paused) {</a>
<a name="ln10635">      time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timer-&gt;timeout,</a>
<a name="ln10636">                         timer-&gt;timeout);</a>
<a name="ln10637">    }</a>
<a name="ln10638">    timer-&gt;paused = paused;</a>
<a name="ln10639">  }</a>
<a name="ln10640">}</a>
<a name="ln10641"> </a>
<a name="ln10642">/// &quot;timer_start(timeout, callback, opts)&quot; function</a>
<a name="ln10643">static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10644">{</a>
<a name="ln10645">  int repeat = 1;</a>
<a name="ln10646">  dict_T *dict;</a>
<a name="ln10647"> </a>
<a name="ln10648">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10649"> </a>
<a name="ln10650">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10651">    if (argvars[2].v_type != VAR_DICT</a>
<a name="ln10652">        || (dict = argvars[2].vval.v_dict) == NULL) {</a>
<a name="ln10653">      EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10654">      return;</a>
<a name="ln10655">    }</a>
<a name="ln10656">    dictitem_T *const di = tv_dict_find(dict, S_LEN(&quot;repeat&quot;));</a>
<a name="ln10657">    if (di != NULL) {</a>
<a name="ln10658">      repeat = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln10659">      if (repeat == 0) {</a>
<a name="ln10660">        repeat = 1;</a>
<a name="ln10661">      }</a>
<a name="ln10662">    }</a>
<a name="ln10663">  }</a>
<a name="ln10664"> </a>
<a name="ln10665">  Callback callback;</a>
<a name="ln10666">  if (!callback_from_typval(&amp;callback, &amp;argvars[1])) {</a>
<a name="ln10667">    return;</a>
<a name="ln10668">  }</a>
<a name="ln10669">  rettv-&gt;vval.v_number =</a>
<a name="ln10670">      timer_start(tv_get_number(&amp;argvars[0]), repeat, &amp;callback);</a>
<a name="ln10671">}</a>
<a name="ln10672"> </a>
<a name="ln10673"> </a>
<a name="ln10674">// &quot;timer_stop(timerid)&quot; function</a>
<a name="ln10675">static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10676">{</a>
<a name="ln10677">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10678">        EMSG(_(e_number_exp));</a>
<a name="ln10679">        return;</a>
<a name="ln10680">    }</a>
<a name="ln10681"> </a>
<a name="ln10682">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10683">    if (timer == NULL) {</a>
<a name="ln10684">      return;</a>
<a name="ln10685">    }</a>
<a name="ln10686"> </a>
<a name="ln10687">    timer_stop(timer);</a>
<a name="ln10688">}</a>
<a name="ln10689"> </a>
<a name="ln10690">static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10691">{</a>
<a name="ln10692">  timer_stop_all();</a>
<a name="ln10693">}</a>
<a name="ln10694"> </a>
<a name="ln10695">/*</a>
<a name="ln10696"> * &quot;tolower(string)&quot; function</a>
<a name="ln10697"> */</a>
<a name="ln10698">static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10699">{</a>
<a name="ln10700">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10701">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10702">                                                false);</a>
<a name="ln10703">}</a>
<a name="ln10704"> </a>
<a name="ln10705">/*</a>
<a name="ln10706"> * &quot;toupper(string)&quot; function</a>
<a name="ln10707"> */</a>
<a name="ln10708">static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10709">{</a>
<a name="ln10710">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10711">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10712">                                                true);</a>
<a name="ln10713">}</a>
<a name="ln10714"> </a>
<a name="ln10715">/*</a>
<a name="ln10716"> * &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln10717"> */</a>
<a name="ln10718">static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10719">{</a>
<a name="ln10720">  char buf[NUMBUFLEN];</a>
<a name="ln10721">  char buf2[NUMBUFLEN];</a>
<a name="ln10722"> </a>
<a name="ln10723">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10724">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln10725">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln10726"> </a>
<a name="ln10727">  // Default return value: empty string.</a>
<a name="ln10728">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10729">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10730">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln10731">    return;  // Type error; errmsg already given.</a>
<a name="ln10732">  }</a>
<a name="ln10733">  garray_T ga;</a>
<a name="ln10734">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln10735"> </a>
<a name="ln10736">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln10737">  bool first = true;</a>
<a name="ln10738">  while (*in_str != NUL) {</a>
<a name="ln10739">    const char *cpstr = in_str;</a>
<a name="ln10740">    const int inlen = utfc_ptr2len((const char_u *)in_str);</a>
<a name="ln10741">    int cplen = inlen;</a>
<a name="ln10742">    int idx = 0;</a>
<a name="ln10743">    int fromlen;</a>
<a name="ln10744">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln10745">      fromlen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10746">      if (fromlen == inlen &amp;&amp; STRNCMP(in_str, p, inlen) == 0) {</a>
<a name="ln10747">        int tolen;</a>
<a name="ln10748">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10749">          tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10750">          if (idx-- == 0) {</a>
<a name="ln10751">            cplen = tolen;</a>
<a name="ln10752">            cpstr = (char *)p;</a>
<a name="ln10753">            break;</a>
<a name="ln10754">          }</a>
<a name="ln10755">        }</a>
<a name="ln10756">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln10757">          goto error;</a>
<a name="ln10758">        }</a>
<a name="ln10759">        break;</a>
<a name="ln10760">      }</a>
<a name="ln10761">      idx++;</a>
<a name="ln10762">    }</a>
<a name="ln10763"> </a>
<a name="ln10764">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln10765">      // Check that fromstr and tostr have the same number of</a>
<a name="ln10766">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln10767">      // of in_str doesn't appear in fromstr.</a>
<a name="ln10768">      first = false;</a>
<a name="ln10769">      int tolen;</a>
<a name="ln10770">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10771">        tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln10772">        idx--;</a>
<a name="ln10773">      }</a>
<a name="ln10774">      if (idx != 0) {</a>
<a name="ln10775">        goto error;</a>
<a name="ln10776">      }</a>
<a name="ln10777">    }</a>
<a name="ln10778"> </a>
<a name="ln10779">    ga_grow(&amp;ga, cplen);</a>
<a name="ln10780">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln10781">    ga.ga_len += cplen;</a>
<a name="ln10782"> </a>
<a name="ln10783">    in_str += inlen;</a>
<a name="ln10784">  }</a>
<a name="ln10785"> </a>
<a name="ln10786">  // add a terminating NUL</a>
<a name="ln10787">  ga_append(&amp;ga, NUL);</a>
<a name="ln10788"> </a>
<a name="ln10789">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln10790">  return;</a>
<a name="ln10791">error:</a>
<a name="ln10792">  EMSG2(_(e_invarg2), fromstr);</a>
<a name="ln10793">  ga_clear(&amp;ga);</a>
<a name="ln10794">  return;</a>
<a name="ln10795">}</a>
<a name="ln10796"> </a>
<a name="ln10797">// &quot;trim({expr})&quot; function</a>
<a name="ln10798">static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10799">{</a>
<a name="ln10800">  char buf1[NUMBUFLEN];</a>
<a name="ln10801">  char buf2[NUMBUFLEN];</a>
<a name="ln10802">  const char_u *head = (const char_u *)tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln10803">  const char_u *mask = NULL;</a>
<a name="ln10804">  const char_u *tail;</a>
<a name="ln10805">  const char_u *prev;</a>
<a name="ln10806">  const char_u *p;</a>
<a name="ln10807">  int c1;</a>
<a name="ln10808">  int dir = 0;</a>
<a name="ln10809"> </a>
<a name="ln10810">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10811">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10812">  if (head == NULL) {</a>
<a name="ln10813">    return;</a>
<a name="ln10814">  }</a>
<a name="ln10815"> </a>
<a name="ln10816">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln10817">    mask = (const char_u *)tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln10818">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10819">      bool error = false;</a>
<a name="ln10820">      // leading or trailing characters to trim</a>
<a name="ln10821">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln10822">      if (error) {</a>
<a name="ln10823">        return;</a>
<a name="ln10824">      }</a>
<a name="ln10825">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln10826">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10827">        return;</a>
<a name="ln10828">      }</a>
<a name="ln10829">    }</a>
<a name="ln10830">  }</a>
<a name="ln10831"> </a>
<a name="ln10832">  if (dir == 0 || dir == 1) {</a>
<a name="ln10833">    // Trim leading characters</a>
<a name="ln10834">    while (*head != NUL) {</a>
<a name="ln10835">      c1 = PTR2CHAR(head);</a>
<a name="ln10836">      if (mask == NULL) {</a>
<a name="ln10837">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln10838">          break;</a>
<a name="ln10839">        }</a>
<a name="ln10840">      } else {</a>
<a name="ln10841">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln10842">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln10843">            break;</a>
<a name="ln10844">          }</a>
<a name="ln10845">        }</a>
<a name="ln10846">        if (*p == NUL) {</a>
<a name="ln10847">          break;</a>
<a name="ln10848">        }</a>
<a name="ln10849">      }</a>
<a name="ln10850">      MB_PTR_ADV(head);</a>
<a name="ln10851">    }</a>
<a name="ln10852">  }</a>
<a name="ln10853"> </a>
<a name="ln10854">  tail = head + STRLEN(head);</a>
<a name="ln10855">  if (dir == 0 || dir == 2) {</a>
<a name="ln10856">    // Trim trailing characters</a>
<a name="ln10857">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln10858">      prev = tail;</a>
<a name="ln10859">      MB_PTR_BACK(head, prev);</a>
<a name="ln10860">      c1 = PTR2CHAR(prev);</a>
<a name="ln10861">      if (mask == NULL) {</a>
<a name="ln10862">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln10863">          break;</a>
<a name="ln10864">        }</a>
<a name="ln10865">      } else {</a>
<a name="ln10866">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln10867">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln10868">            break;</a>
<a name="ln10869">          }</a>
<a name="ln10870">        }</a>
<a name="ln10871">        if (*p == NUL) {</a>
<a name="ln10872">          break;</a>
<a name="ln10873">        }</a>
<a name="ln10874">      }</a>
<a name="ln10875">    }</a>
<a name="ln10876">  }</a>
<a name="ln10877">  rettv-&gt;vval.v_string = vim_strnsave(head, tail - head);</a>
<a name="ln10878">}</a>
<a name="ln10879"> </a>
<a name="ln10880">/*</a>
<a name="ln10881"> * &quot;type(expr)&quot; function</a>
<a name="ln10882"> */</a>
<a name="ln10883">static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10884">{</a>
<a name="ln10885">  int n = -1;</a>
<a name="ln10886"> </a>
<a name="ln10887">  switch (argvars[0].v_type) {</a>
<a name="ln10888">    case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;</a>
<a name="ln10889">    case VAR_STRING: n = VAR_TYPE_STRING; break;</a>
<a name="ln10890">    case VAR_PARTIAL:</a>
<a name="ln10891">    case VAR_FUNC:   n = VAR_TYPE_FUNC; break;</a>
<a name="ln10892">    case VAR_LIST:   n = VAR_TYPE_LIST; break;</a>
<a name="ln10893">    case VAR_DICT:   n = VAR_TYPE_DICT; break;</a>
<a name="ln10894">    case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;</a>
<a name="ln10895">    case VAR_BOOL:   n = VAR_TYPE_BOOL; break;</a>
<a name="ln10896">    case VAR_SPECIAL:n = VAR_TYPE_SPECIAL; break;</a>
<a name="ln10897">    case VAR_UNKNOWN: {</a>
<a name="ln10898">      internal_error(&quot;f_type(UNKNOWN)&quot;);</a>
<a name="ln10899">      break;</a>
<a name="ln10900">    }</a>
<a name="ln10901">  }</a>
<a name="ln10902">  rettv-&gt;vval.v_number = n;</a>
<a name="ln10903">}</a>
<a name="ln10904"> </a>
<a name="ln10905">/*</a>
<a name="ln10906"> * &quot;undofile(name)&quot; function</a>
<a name="ln10907"> */</a>
<a name="ln10908">static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10909">{</a>
<a name="ln10910">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10911">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10912"> </a>
<a name="ln10913">  if (*fname == NUL) {</a>
<a name="ln10914">    // If there is no file name there will be no undo file.</a>
<a name="ln10915">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10916">  } else {</a>
<a name="ln10917">    char *ffname = FullName_save(fname, true);</a>
<a name="ln10918"> </a>
<a name="ln10919">    if (ffname != NULL) {</a>
<a name="ln10920">      rettv-&gt;vval.v_string = (char_u *)u_get_undo_file_name(ffname, false);</a>
<a name="ln10921">    }</a>
<a name="ln10922">    xfree(ffname);</a>
<a name="ln10923">  }</a>
<a name="ln10924">}</a>
<a name="ln10925"> </a>
<a name="ln10926">/*</a>
<a name="ln10927"> * &quot;undotree()&quot; function</a>
<a name="ln10928"> */</a>
<a name="ln10929">static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10930">{</a>
<a name="ln10931">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10932"> </a>
<a name="ln10933">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln10934"> </a>
<a name="ln10935">  tv_dict_add_nr(dict, S_LEN(&quot;synced&quot;), (varnumber_T)curbuf-&gt;b_u_synced);</a>
<a name="ln10936">  tv_dict_add_nr(dict, S_LEN(&quot;seq_last&quot;), (varnumber_T)curbuf-&gt;b_u_seq_last);</a>
<a name="ln10937">  tv_dict_add_nr(dict, S_LEN(&quot;save_last&quot;),</a>
<a name="ln10938">                 (varnumber_T)curbuf-&gt;b_u_save_nr_last);</a>
<a name="ln10939">  tv_dict_add_nr(dict, S_LEN(&quot;seq_cur&quot;), (varnumber_T)curbuf-&gt;b_u_seq_cur);</a>
<a name="ln10940">  tv_dict_add_nr(dict, S_LEN(&quot;time_cur&quot;), (varnumber_T)curbuf-&gt;b_u_time_cur);</a>
<a name="ln10941">  tv_dict_add_nr(dict, S_LEN(&quot;save_cur&quot;), (varnumber_T)curbuf-&gt;b_u_save_nr_cur);</a>
<a name="ln10942"> </a>
<a name="ln10943">  tv_dict_add_list(dict, S_LEN(&quot;entries&quot;), u_eval_tree(curbuf-&gt;b_u_oldhead));</a>
<a name="ln10944">}</a>
<a name="ln10945"> </a>
<a name="ln10946">/*</a>
<a name="ln10947"> * &quot;values(dict)&quot; function</a>
<a name="ln10948"> */</a>
<a name="ln10949">static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10950">{</a>
<a name="ln10951">  dict_list(argvars, rettv, 1);</a>
<a name="ln10952">}</a>
<a name="ln10953"> </a>
<a name="ln10954">/*</a>
<a name="ln10955"> * &quot;virtcol(string)&quot; function</a>
<a name="ln10956"> */</a>
<a name="ln10957">static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10958">{</a>
<a name="ln10959">  colnr_T vcol = 0;</a>
<a name="ln10960">  pos_T       *fp;</a>
<a name="ln10961">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln10962"> </a>
<a name="ln10963">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln10964">  if (fp != NULL &amp;&amp; fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10965">      &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln10966">    // Limit the column to a valid value, getvvcol() doesn't check.</a>
<a name="ln10967">    if (fp-&gt;col &lt; 0) {</a>
<a name="ln10968">      fp-&gt;col = 0;</a>
<a name="ln10969">    } else {</a>
<a name="ln10970">      const size_t len = STRLEN(ml_get(fp-&gt;lnum));</a>
<a name="ln10971">      if (fp-&gt;col &gt; (colnr_T)len) {</a>
<a name="ln10972">        fp-&gt;col = (colnr_T)len;</a>
<a name="ln10973">      }</a>
<a name="ln10974">    }</a>
<a name="ln10975">    getvvcol(curwin, fp, NULL, NULL, &amp;vcol);</a>
<a name="ln10976">    ++vcol;</a>
<a name="ln10977">  }</a>
<a name="ln10978"> </a>
<a name="ln10979">  rettv-&gt;vval.v_number = vcol;</a>
<a name="ln10980">}</a>
<a name="ln10981"> </a>
<a name="ln10982">/*</a>
<a name="ln10983"> * &quot;visualmode()&quot; function</a>
<a name="ln10984"> */</a>
<a name="ln10985">static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10986">{</a>
<a name="ln10987">  char_u str[2];</a>
<a name="ln10988"> </a>
<a name="ln10989">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10990">  str[0] = curbuf-&gt;b_visual_mode_eval;</a>
<a name="ln10991">  str[1] = NUL;</a>
<a name="ln10992">  rettv-&gt;vval.v_string = vim_strsave(str);</a>
<a name="ln10993"> </a>
<a name="ln10994">  // A non-zero number or non-empty string argument: reset mode.</a>
<a name="ln10995">  if (non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln10996">    curbuf-&gt;b_visual_mode_eval = NUL;</a>
<a name="ln10997">  }</a>
<a name="ln10998">}</a>
<a name="ln10999"> </a>
<a name="ln11000">/*</a>
<a name="ln11001"> * &quot;wildmenumode()&quot; function</a>
<a name="ln11002"> */</a>
<a name="ln11003">static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11004">{</a>
<a name="ln11005">  if (wild_menu_showing || ((State &amp; CMDLINE) &amp;&amp; pum_visible())) {</a>
<a name="ln11006">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln11007">  }</a>
<a name="ln11008">}</a>
<a name="ln11009"> </a>
<a name="ln11010">/// &quot;win_findbuf()&quot; function</a>
<a name="ln11011">static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11012">{</a>
<a name="ln11013">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln11014">  win_findbuf(argvars, rettv-&gt;vval.v_list);</a>
<a name="ln11015">}</a>
<a name="ln11016"> </a>
<a name="ln11017">/// &quot;win_getid()&quot; function</a>
<a name="ln11018">static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11019">{</a>
<a name="ln11020">  rettv-&gt;vval.v_number = win_getid(argvars);</a>
<a name="ln11021">}</a>
<a name="ln11022"> </a>
<a name="ln11023">/// &quot;win_gettype(nr)&quot; function</a>
<a name="ln11024">static void f_win_gettype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11025">{</a>
<a name="ln11026">  win_T *wp = curwin;</a>
<a name="ln11027"> </a>
<a name="ln11028">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11029">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11030">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln11031">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11032">    if (wp == NULL) {</a>
<a name="ln11033">      rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;unknown&quot;);</a>
<a name="ln11034">      return;</a>
<a name="ln11035">    }</a>
<a name="ln11036">  }</a>
<a name="ln11037">  if (wp == aucmd_win) {</a>
<a name="ln11038">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;autocmd&quot;);</a>
<a name="ln11039">  } else if (wp-&gt;w_p_pvw) {</a>
<a name="ln11040">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;preview&quot;);</a>
<a name="ln11041">  } else if (wp-&gt;w_floating) {</a>
<a name="ln11042">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;popup&quot;);</a>
<a name="ln11043">  } else if (wp == curwin &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln11044">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;command&quot;);</a>
<a name="ln11045">  }</a>
<a name="ln11046">}</a>
<a name="ln11047"> </a>
<a name="ln11048">/// &quot;win_gotoid()&quot; function</a>
<a name="ln11049">static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11050">{</a>
<a name="ln11051">  rettv-&gt;vval.v_number = win_gotoid(argvars);</a>
<a name="ln11052">}</a>
<a name="ln11053"> </a>
<a name="ln11054">/// &quot;win_id2tabwin()&quot; function</a>
<a name="ln11055">static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11056">{</a>
<a name="ln11057">  win_id2tabwin(argvars, rettv);</a>
<a name="ln11058">}</a>
<a name="ln11059"> </a>
<a name="ln11060">/// &quot;win_id2win()&quot; function</a>
<a name="ln11061">static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11062">{</a>
<a name="ln11063">  rettv-&gt;vval.v_number = win_id2win(argvars);</a>
<a name="ln11064">}</a>
<a name="ln11065"> </a>
<a name="ln11066">/// &quot;winbufnr(nr)&quot; function</a>
<a name="ln11067">static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11068">{</a>
<a name="ln11069">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11070">  if (wp == NULL) {</a>
<a name="ln11071">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11072">  } else {</a>
<a name="ln11073">    rettv-&gt;vval.v_number = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln11074">  }</a>
<a name="ln11075">}</a>
<a name="ln11076"> </a>
<a name="ln11077">/*</a>
<a name="ln11078"> * &quot;wincol()&quot; function</a>
<a name="ln11079"> */</a>
<a name="ln11080">static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11081">{</a>
<a name="ln11082">  validate_cursor();</a>
<a name="ln11083">  rettv-&gt;vval.v_number = curwin-&gt;w_wcol + 1;</a>
<a name="ln11084">}</a>
<a name="ln11085"> </a>
<a name="ln11086">/// &quot;winheight(nr)&quot; function</a>
<a name="ln11087">static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11088">{</a>
<a name="ln11089">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11090">  if (wp == NULL) {</a>
<a name="ln11091">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11092">  } else {</a>
<a name="ln11093">    rettv-&gt;vval.v_number = wp-&gt;w_height;</a>
<a name="ln11094">  }</a>
<a name="ln11095">}</a>
<a name="ln11096"> </a>
<a name="ln11097">// &quot;winlayout()&quot; function</a>
<a name="ln11098">static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11099">{</a>
<a name="ln11100">  tabpage_T *tp;</a>
<a name="ln11101"> </a>
<a name="ln11102">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln11103"> </a>
<a name="ln11104">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln11105">    tp = curtab;</a>
<a name="ln11106">  } else {</a>
<a name="ln11107">    tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln11108">    if (tp == NULL) {</a>
<a name="ln11109">      return;</a>
<a name="ln11110">    }</a>
<a name="ln11111">  }</a>
<a name="ln11112"> </a>
<a name="ln11113">  get_framelayout(tp-&gt;tp_topframe, rettv-&gt;vval.v_list, true);</a>
<a name="ln11114">}</a>
<a name="ln11115"> </a>
<a name="ln11116">/*</a>
<a name="ln11117"> * &quot;winline()&quot; function</a>
<a name="ln11118"> */</a>
<a name="ln11119">static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11120">{</a>
<a name="ln11121">  validate_cursor();</a>
<a name="ln11122">  rettv-&gt;vval.v_number = curwin-&gt;w_wrow + 1;</a>
<a name="ln11123">}</a>
<a name="ln11124"> </a>
<a name="ln11125">/*</a>
<a name="ln11126"> * &quot;winnr()&quot; function</a>
<a name="ln11127"> */</a>
<a name="ln11128">static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11129">{</a>
<a name="ln11130">  int nr = 1;</a>
<a name="ln11131"> </a>
<a name="ln11132">  nr = get_winnr(curtab, &amp;argvars[0]);</a>
<a name="ln11133">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln11134">}</a>
<a name="ln11135"> </a>
<a name="ln11136">/*</a>
<a name="ln11137"> * &quot;winrestcmd()&quot; function</a>
<a name="ln11138"> */</a>
<a name="ln11139">static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11140">{</a>
<a name="ln11141">  int winnr = 1;</a>
<a name="ln11142">  garray_T ga;</a>
<a name="ln11143">  char_u buf[50];</a>
<a name="ln11144"> </a>
<a name="ln11145">  ga_init(&amp;ga, (int)sizeof(char), 70);</a>
<a name="ln11146">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln11147">    sprintf((char *)buf, &quot;%dresize %d|&quot;, winnr, wp-&gt;w_height);</a>
<a name="ln11148">    ga_concat(&amp;ga, buf);</a>
<a name="ln11149">    sprintf((char *)buf, &quot;vert %dresize %d|&quot;, winnr, wp-&gt;w_width);</a>
<a name="ln11150">    ga_concat(&amp;ga, buf);</a>
<a name="ln11151">    ++winnr;</a>
<a name="ln11152">  }</a>
<a name="ln11153">  ga_append(&amp;ga, NUL);</a>
<a name="ln11154"> </a>
<a name="ln11155">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11156">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11157">}</a>
<a name="ln11158"> </a>
<a name="ln11159">/*</a>
<a name="ln11160"> * &quot;winrestview()&quot; function</a>
<a name="ln11161"> */</a>
<a name="ln11162">static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11163">{</a>
<a name="ln11164">  dict_T *dict;</a>
<a name="ln11165"> </a>
<a name="ln11166">  if (argvars[0].v_type != VAR_DICT</a>
<a name="ln11167">      || (dict = argvars[0].vval.v_dict) == NULL) {</a>
<a name="ln11168">    EMSG(_(e_invarg));</a>
<a name="ln11169">  } else {</a>
<a name="ln11170">    dictitem_T *di;</a>
<a name="ln11171">    if ((di = tv_dict_find(dict, S_LEN(&quot;lnum&quot;))) != NULL) {</a>
<a name="ln11172">      curwin-&gt;w_cursor.lnum = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11173">    }</a>
<a name="ln11174">    if ((di = tv_dict_find(dict, S_LEN(&quot;col&quot;))) != NULL) {</a>
<a name="ln11175">      curwin-&gt;w_cursor.col = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11176">    }</a>
<a name="ln11177">    if ((di = tv_dict_find(dict, S_LEN(&quot;coladd&quot;))) != NULL) {</a>
<a name="ln11178">      curwin-&gt;w_cursor.coladd = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11179">    }</a>
<a name="ln11180">    if ((di = tv_dict_find(dict, S_LEN(&quot;curswant&quot;))) != NULL) {</a>
<a name="ln11181">      curwin-&gt;w_curswant = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11182">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln11183">    }</a>
<a name="ln11184">    if ((di = tv_dict_find(dict, S_LEN(&quot;topline&quot;))) != NULL) {</a>
<a name="ln11185">      set_topline(curwin, tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln11186">    }</a>
<a name="ln11187">    if ((di = tv_dict_find(dict, S_LEN(&quot;topfill&quot;))) != NULL) {</a>
<a name="ln11188">      curwin-&gt;w_topfill = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11189">    }</a>
<a name="ln11190">    if ((di = tv_dict_find(dict, S_LEN(&quot;leftcol&quot;))) != NULL) {</a>
<a name="ln11191">      curwin-&gt;w_leftcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11192">    }</a>
<a name="ln11193">    if ((di = tv_dict_find(dict, S_LEN(&quot;skipcol&quot;))) != NULL) {</a>
<a name="ln11194">      curwin-&gt;w_skipcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11195">    }</a>
<a name="ln11196"> </a>
<a name="ln11197">    check_cursor();</a>
<a name="ln11198">    win_new_height(curwin, curwin-&gt;w_height);</a>
<a name="ln11199">    win_new_width(curwin, curwin-&gt;w_width);</a>
<a name="ln11200">    changed_window_setting();</a>
<a name="ln11201"> </a>
<a name="ln11202">    if (curwin-&gt;w_topline &lt;= 0)</a>
<a name="ln11203">      curwin-&gt;w_topline = 1;</a>
<a name="ln11204">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln11205">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln11206">    check_topfill(curwin, true);</a>
<a name="ln11207">  }</a>
<a name="ln11208">}</a>
<a name="ln11209"> </a>
<a name="ln11210">/*</a>
<a name="ln11211"> * &quot;winsaveview()&quot; function</a>
<a name="ln11212"> */</a>
<a name="ln11213">static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11214">{</a>
<a name="ln11215">  dict_T      *dict;</a>
<a name="ln11216"> </a>
<a name="ln11217">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11218">  dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11219"> </a>
<a name="ln11220">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)curwin-&gt;w_cursor.lnum);</a>
<a name="ln11221">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)curwin-&gt;w_cursor.col);</a>
<a name="ln11222">  tv_dict_add_nr(dict, S_LEN(&quot;coladd&quot;), (varnumber_T)curwin-&gt;w_cursor.coladd);</a>
<a name="ln11223">  update_curswant();</a>
<a name="ln11224">  tv_dict_add_nr(dict, S_LEN(&quot;curswant&quot;), (varnumber_T)curwin-&gt;w_curswant);</a>
<a name="ln11225"> </a>
<a name="ln11226">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), (varnumber_T)curwin-&gt;w_topline);</a>
<a name="ln11227">  tv_dict_add_nr(dict, S_LEN(&quot;topfill&quot;), (varnumber_T)curwin-&gt;w_topfill);</a>
<a name="ln11228">  tv_dict_add_nr(dict, S_LEN(&quot;leftcol&quot;), (varnumber_T)curwin-&gt;w_leftcol);</a>
<a name="ln11229">  tv_dict_add_nr(dict, S_LEN(&quot;skipcol&quot;), (varnumber_T)curwin-&gt;w_skipcol);</a>
<a name="ln11230">}</a>
<a name="ln11231"> </a>
<a name="ln11232">/// &quot;winwidth(nr)&quot; function</a>
<a name="ln11233">static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11234">{</a>
<a name="ln11235">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11236">  if (wp == NULL) {</a>
<a name="ln11237">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11238">  } else {</a>
<a name="ln11239">    rettv-&gt;vval.v_number = wp-&gt;w_width;</a>
<a name="ln11240">  }</a>
<a name="ln11241">}</a>
<a name="ln11242"> </a>
<a name="ln11243">// &quot;windowsversion()&quot; function</a>
<a name="ln11244">static void f_windowsversion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11245">{</a>
<a name="ln11246">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11247">  rettv-&gt;vval.v_string = (char_u *)xstrdup(windowsVersion);</a>
<a name="ln11248">}</a>
<a name="ln11249"> </a>
<a name="ln11250">/// &quot;wordcount()&quot; function</a>
<a name="ln11251">static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11252">{</a>
<a name="ln11253">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11254">  cursor_pos_info(rettv-&gt;vval.v_dict);</a>
<a name="ln11255">}</a>
<a name="ln11256"> </a>
<a name="ln11257">/// &quot;writefile()&quot; function</a>
<a name="ln11258">static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11259">{</a>
<a name="ln11260">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln11261"> </a>
<a name="ln11262">  if (check_secure()) {</a>
<a name="ln11263">    return;</a>
<a name="ln11264">  }</a>
<a name="ln11265"> </a>
<a name="ln11266">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln11267">    EMSG2(_(e_listarg), &quot;writefile()&quot;);</a>
<a name="ln11268">    return;</a>
<a name="ln11269">  }</a>
<a name="ln11270">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln11271">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln11272">    if (!tv_check_str_or_nr(TV_LIST_ITEM_TV(li))) {</a>
<a name="ln11273">      return;</a>
<a name="ln11274">    }</a>
<a name="ln11275">  });</a>
<a name="ln11276"> </a>
<a name="ln11277">  bool binary = false;</a>
<a name="ln11278">  bool append = false;</a>
<a name="ln11279">  bool do_fsync = !!p_fs;</a>
<a name="ln11280">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11281">    const char *const flags = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln11282">    if (flags == NULL) {</a>
<a name="ln11283">      return;</a>
<a name="ln11284">    }</a>
<a name="ln11285">    for (const char *p = flags; *p; p++) {</a>
<a name="ln11286">      switch (*p) {</a>
<a name="ln11287">        case 'b': { binary = true; break; }</a>
<a name="ln11288">        case 'a': { append = true; break; }</a>
<a name="ln11289">        case 's': { do_fsync = true; break; }</a>
<a name="ln11290">        case 'S': { do_fsync = false; break; }</a>
<a name="ln11291">        default: {</a>
<a name="ln11292">          // Using %s, p and not %c, *p to preserve multibyte characters</a>
<a name="ln11293">          emsgf(_(&quot;E5060: Unknown flag: %s&quot;), p);</a>
<a name="ln11294">          return;</a>
<a name="ln11295">        }</a>
<a name="ln11296">      }</a>
<a name="ln11297">    }</a>
<a name="ln11298">  }</a>
<a name="ln11299"> </a>
<a name="ln11300">  char buf[NUMBUFLEN];</a>
<a name="ln11301">  const char *const fname = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11302">  if (fname == NULL) {</a>
<a name="ln11303">    return;</a>
<a name="ln11304">  }</a>
<a name="ln11305">  FileDescriptor fp;</a>
<a name="ln11306">  int error;</a>
<a name="ln11307">  if (*fname == NUL) {</a>
<a name="ln11308">    EMSG(_(&quot;E482: Can't open file with an empty name&quot;));</a>
<a name="ln11309">  } else if ((error = file_open(&amp;fp, fname,</a>
<a name="ln11310">                                ((append ? kFileAppend : kFileTruncate)</a>
<a name="ln11311">                                 | kFileCreate), 0666)) != 0) {</a>
<a name="ln11312">    emsgf(_(&quot;E482: Can't open file %s for writing: %s&quot;),</a>
<a name="ln11313">          fname, os_strerror(error));</a>
<a name="ln11314">  } else {</a>
<a name="ln11315">    if (write_list(&amp;fp, list, binary)) {</a>
<a name="ln11316">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln11317">    }</a>
<a name="ln11318">    if ((error = file_close(&amp;fp, do_fsync)) != 0) {</a>
<a name="ln11319">      emsgf(_(&quot;E80: Error when closing file %s: %s&quot;),</a>
<a name="ln11320">            fname, os_strerror(error));</a>
<a name="ln11321">    }</a>
<a name="ln11322">  }</a>
<a name="ln11323">}</a>
<a name="ln11324">/*</a>
<a name="ln11325"> * &quot;xor(expr, expr)&quot; function</a>
<a name="ln11326"> */</a>
<a name="ln11327">static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11328">{</a>
<a name="ln11329">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln11330">                         ^ tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln11331">}</a>

</code></pre>
<div class="balloon" rel="1778"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="2475"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: mods != NULL.</p></div>
<div class="balloon" rel="3706"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="8092"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>funcs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;float.h&gt;</a>
<a name="ln5">#include &lt;math.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln12">#include &quot;nvim/change.h&quot;</a>
<a name="ln13">#include &quot;nvim/channel.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/context.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/diff.h&quot;</a>
<a name="ln18">#include &quot;nvim/edit.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln32">#include &quot;nvim/indent.h&quot;</a>
<a name="ln33">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln34">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln35">#include &quot;nvim/macros.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/math.h&quot;</a>
<a name="ln38">#include &quot;nvim/memline.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln41">#include &quot;nvim/move.h&quot;</a>
<a name="ln42">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln43">#include &quot;nvim/msgpack_rpc/server.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/dl.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln49">#include &quot;nvim/path.h&quot;</a>
<a name="ln50">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln51">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln52">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln53">#include &quot;nvim/screen.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/version.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">/// Describe data to return from find_some_match()</a>
<a name="ln68">typedef enum {</a>
<a name="ln69">  kSomeMatch,  ///&lt; Data for match().</a>
<a name="ln70">  kSomeMatchEnd,  ///&lt; Data for matchend().</a>
<a name="ln71">  kSomeMatchList,  ///&lt; Data for matchlist().</a>
<a name="ln72">  kSomeMatchStr,  ///&lt; Data for matchstr().</a>
<a name="ln73">  kSomeMatchStrPos,  ///&lt; Data for matchstrpos().</a>
<a name="ln74">} SomeMatchType;</a>
<a name="ln75"> </a>
<a name="ln76">KHASH_MAP_INIT_STR(functions, VimLFuncDef)</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln80"># include &quot;eval/funcs.c.generated.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef _MSC_VER</a>
<a name="ln83">// This prevents MSVC from replacing the functions with intrinsics,</a>
<a name="ln84">// and causing errors when trying to get their addresses in funcs.generated.h</a>
<a name="ln85">#pragma function(ceil)</a>
<a name="ln86">#pragma function(floor)</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES</a>
<a name="ln90">PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH</a>
<a name="ln91">#include &quot;funcs.generated.h&quot;</a>
<a name="ln92">PRAGMA_DIAG_POP</a>
<a name="ln93">PRAGMA_DIAG_POP</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static char *e_listarg = N_(&quot;E686: Argument of %s must be a List&quot;);</a>
<a name="ln98">static char *e_stringreq = N_(&quot;E928: String required&quot;);</a>
<a name="ln99">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln100"> </a>
<a name="ln101">/// Dummy va_list for passing to vim_snprintf</a>
<a name="ln102">///</a>
<a name="ln103">/// Used because:</a>
<a name="ln104">/// - passing a NULL pointer doesn't work when va_list isn't a pointer</a>
<a name="ln105">/// - locally in the function results in a &quot;used before set&quot; warning</a>
<a name="ln106">/// - using va_start() to initialize it gives &quot;function with fixed args&quot; error</a>
<a name="ln107">static va_list dummy_ap;</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">/// Function given to ExpandGeneric() to obtain the list of internal</a>
<a name="ln111">/// or user defined function names.</a>
<a name="ln112">char_u *get_function_name(expand_T *xp, int idx)</a>
<a name="ln113">{</a>
<a name="ln114">  static int intidx = -1;</a>
<a name="ln115">  char_u *name;</a>
<a name="ln116"> </a>
<a name="ln117">  if (idx == 0)</a>
<a name="ln118">    intidx = -1;</a>
<a name="ln119">  if (intidx &lt; 0) {</a>
<a name="ln120">    name = get_user_func_name(xp, idx);</a>
<a name="ln121">    if (name != NULL)</a>
<a name="ln122">      return name;</a>
<a name="ln123">  }</a>
<a name="ln124">  while ((size_t)++intidx &lt; ARRAY_SIZE(functions)</a>
<a name="ln125">         &amp;&amp; functions[intidx].name[0] == '\0') {</a>
<a name="ln126">  }</a>
<a name="ln127"> </a>
<a name="ln128">  if ((size_t)intidx &gt;= ARRAY_SIZE(functions)) {</a>
<a name="ln129">    return NULL;</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  const char *const key = functions[intidx].name;</a>
<a name="ln133">  const size_t key_len = strlen(key);</a>
<a name="ln134">  memcpy(IObuff, key, key_len);</a>
<a name="ln135">  IObuff[key_len] = '(';</a>
<a name="ln136">  if (functions[intidx].max_argc == 0) {</a>
<a name="ln137">    IObuff[key_len + 1] = ')';</a>
<a name="ln138">    IObuff[key_len + 2] = NUL;</a>
<a name="ln139">  } else {</a>
<a name="ln140">    IObuff[key_len + 1] = NUL;</a>
<a name="ln141">  }</a>
<a name="ln142">  return IObuff;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">/// Function given to ExpandGeneric() to obtain the list of internal or</a>
<a name="ln146">/// user defined variable or function names.</a>
<a name="ln147">char_u *get_expr_name(expand_T *xp, int idx)</a>
<a name="ln148">{</a>
<a name="ln149">  static int intidx = -1;</a>
<a name="ln150">  char_u *name;</a>
<a name="ln151"> </a>
<a name="ln152">  if (idx == 0)</a>
<a name="ln153">    intidx = -1;</a>
<a name="ln154">  if (intidx &lt; 0) {</a>
<a name="ln155">    name = get_function_name(xp, idx);</a>
<a name="ln156">    if (name != NULL)</a>
<a name="ln157">      return name;</a>
<a name="ln158">  }</a>
<a name="ln159">  return get_user_var_name(xp, ++intidx);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/// Find internal function in hash functions</a>
<a name="ln163">///</a>
<a name="ln164">/// @param[in]  name  Name of the function.</a>
<a name="ln165">///</a>
<a name="ln166">/// Returns pointer to the function definition or NULL if not found.</a>
<a name="ln167">const VimLFuncDef *find_internal_func(const char *const name)</a>
<a name="ln168">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln169">{</a>
<a name="ln170">  size_t len = strlen(name);</a>
<a name="ln171">  return find_internal_func_gperf(name, len);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/*</a>
<a name="ln175"> * Return TRUE for a non-zero Number and a non-empty String.</a>
<a name="ln176"> */</a>
<a name="ln177">static int non_zero_arg(typval_T *argvars)</a>
<a name="ln178">{</a>
<a name="ln179">  return ((argvars[0].v_type == VAR_NUMBER</a>
<a name="ln180">           &amp;&amp; argvars[0].vval.v_number != 0)</a>
<a name="ln181">          || (argvars[0].v_type == VAR_BOOL</a>
<a name="ln182">              &amp;&amp; argvars[0].vval.v_bool == kBoolVarTrue)</a>
<a name="ln183">          || (argvars[0].v_type == VAR_STRING</a>
<a name="ln184">              &amp;&amp; argvars[0].vval.v_string != NULL</a>
<a name="ln185">              &amp;&amp; *argvars[0].vval.v_string != NUL));</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">// Apply a floating point C function on a typval with one float_T.</a>
<a name="ln189">//</a>
<a name="ln190">// Some versions of glibc on i386 have an optimization that makes it harder to</a>
<a name="ln191">// call math functions indirectly from inside an inlined function, causing</a>
<a name="ln192">// compile-time errors. Avoid `inline` in that case. #3072</a>
<a name="ln193">static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln194">{</a>
<a name="ln195">  float_T f;</a>
<a name="ln196">  float_T (*function)(float_T) = (float_T (*)(float_T))fptr;</a>
<a name="ln197"> </a>
<a name="ln198">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln199">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln200">    rettv-&gt;vval.v_float = function(f);</a>
<a name="ln201">  } else {</a>
<a name="ln202">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln203">  }</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln207">{</a>
<a name="ln208">  if (check_restricted() || check_secure()) {</a>
<a name="ln209">    return;</a>
<a name="ln210">  }</a>
<a name="ln211"> </a>
<a name="ln212">  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;</a>
<a name="ln213"> </a>
<a name="ln214">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln215"> </a>
<a name="ln216">  for (typval_T *tv = argvars; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln217">    ADD(args, vim_to_object(tv));</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  Error err = ERROR_INIT;</a>
<a name="ln221">  Object result = fn(VIML_INTERNAL_CALL, args, &amp;err);</a>
<a name="ln222"> </a>
<a name="ln223">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln224">    emsgf_multiline((const char *)e_api_error, err.msg);</a>
<a name="ln225">    goto end;</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln229">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">end:</a>
<a name="ln233">  api_free_array(args);</a>
<a name="ln234">  api_free_object(result);</a>
<a name="ln235">  api_clear_error(&amp;err);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">/*</a>
<a name="ln239"> * &quot;abs(expr)&quot; function</a>
<a name="ln240"> */</a>
<a name="ln241">static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln242">{</a>
<a name="ln243">  if (argvars[0].v_type == VAR_FLOAT) {</a>
<a name="ln244">    float_op_wrapper(argvars, rettv, (FunPtr)&amp;fabs);</a>
<a name="ln245">  } else {</a>
<a name="ln246">    varnumber_T n;</a>
<a name="ln247">    bool error = false;</a>
<a name="ln248"> </a>
<a name="ln249">    n = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln250">    if (error) {</a>
<a name="ln251">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln252">    } else if (n &gt; 0) {</a>
<a name="ln253">      rettv-&gt;vval.v_number = n;</a>
<a name="ln254">    } else {</a>
<a name="ln255">      rettv-&gt;vval.v_number = -n;</a>
<a name="ln256">    }</a>
<a name="ln257">  }</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">/*</a>
<a name="ln261"> * &quot;add(list, item)&quot; function</a>
<a name="ln262"> */</a>
<a name="ln263">static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln264">{</a>
<a name="ln265">  rettv-&gt;vval.v_number = 1;  // Default: failed.</a>
<a name="ln266">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln267">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln268">    if (!tv_check_lock(tv_list_locked(l), N_(&quot;add() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln269">      tv_list_append_tv(l, &amp;argvars[1]);</a>
<a name="ln270">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln271">    }</a>
<a name="ln272">  } else {</a>
<a name="ln273">    EMSG(_(e_listreq));</a>
<a name="ln274">  }</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">/*</a>
<a name="ln278"> * &quot;and(expr, expr)&quot; function</a>
<a name="ln279"> */</a>
<a name="ln280">static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln281">{</a>
<a name="ln282">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln283">                         &amp; tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">/// &quot;api_info()&quot; function</a>
<a name="ln288">static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln289">{</a>
<a name="ln290">  Dictionary metadata = api_metadata();</a>
<a name="ln291">  (void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);</a>
<a name="ln292">  api_free_dictionary(metadata);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">// &quot;append(lnum, string/list)&quot; function</a>
<a name="ln296">static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln297">{</a>
<a name="ln298">  const linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln299"> </a>
<a name="ln300">  set_buffer_lines(curbuf, lnum, true, &amp;argvars[1], rettv);</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">// &quot;appendbufline(buf, lnum, string/list)&quot; function</a>
<a name="ln304">static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln305">{</a>
<a name="ln306">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln307">  if (buf == NULL) {</a>
<a name="ln308">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln309">  } else {</a>
<a name="ln310">    const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln311">    set_buffer_lines(buf, lnum, true, &amp;argvars[2], rettv);</a>
<a name="ln312">  }</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln316">{</a>
<a name="ln317">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln318">    // use the current window</a>
<a name="ln319">    rettv-&gt;vval.v_number = ARGCOUNT;</a>
<a name="ln320">  } else if (argvars[0].v_type == VAR_NUMBER</a>
<a name="ln321">             &amp;&amp; tv_get_number(&amp;argvars[0]) == -1) {</a>
<a name="ln322">    // use the global argument list</a>
<a name="ln323">    rettv-&gt;vval.v_number = GARGCOUNT;</a>
<a name="ln324">  } else {</a>
<a name="ln325">    // use the argument list of the specified window</a>
<a name="ln326">    win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln327">    if (wp != NULL) {</a>
<a name="ln328">      rettv-&gt;vval.v_number = WARGCOUNT(wp);</a>
<a name="ln329">    } else {</a>
<a name="ln330">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln331">    }</a>
<a name="ln332">  }</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">/*</a>
<a name="ln336"> * &quot;argidx()&quot; function</a>
<a name="ln337"> */</a>
<a name="ln338">static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln339">{</a>
<a name="ln340">  rettv-&gt;vval.v_number = curwin-&gt;w_arg_idx;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">/// &quot;arglistid&quot; function</a>
<a name="ln344">static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln345">{</a>
<a name="ln346">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln347">  win_T *wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln348">  if (wp != NULL) {</a>
<a name="ln349">    rettv-&gt;vval.v_number = wp-&gt;w_alist-&gt;id;</a>
<a name="ln350">  }</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">/*</a>
<a name="ln354"> * &quot;argv(nr)&quot; function</a>
<a name="ln355"> */</a>
<a name="ln356">static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln357">{</a>
<a name="ln358">  aentry_T *arglist = NULL;</a>
<a name="ln359">  int argcount = -1;</a>
<a name="ln360"> </a>
<a name="ln361">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln362">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln363">      arglist = ARGLIST;</a>
<a name="ln364">      argcount = ARGCOUNT;</a>
<a name="ln365">    } else if (argvars[1].v_type == VAR_NUMBER</a>
<a name="ln366">               &amp;&amp; tv_get_number(&amp;argvars[1]) == -1) {</a>
<a name="ln367">      arglist = GARGLIST;</a>
<a name="ln368">      argcount = GARGCOUNT;</a>
<a name="ln369">    } else {</a>
<a name="ln370">      win_T *wp = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln371">      if (wp != NULL) {</a>
<a name="ln372">        // Use the argument list of the specified window</a>
<a name="ln373">        arglist = WARGLIST(wp);</a>
<a name="ln374">        argcount = WARGCOUNT(wp);</a>
<a name="ln375">      }</a>
<a name="ln376">    }</a>
<a name="ln377">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln378">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln379">    int idx = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln380">    if (arglist != NULL &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; argcount) {</a>
<a name="ln381">      rettv-&gt;vval.v_string = (char_u *)xstrdup(</a>
<a name="ln382">          (const char *)alist_name(&amp;arglist[idx]));</a>
<a name="ln383">    } else if (idx == -1) {</a>
<a name="ln384">      get_arglist_as_rettv(arglist, argcount, rettv);</a>
<a name="ln385">    }</a>
<a name="ln386">  } else {</a>
<a name="ln387">    get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);</a>
<a name="ln388">  }</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln392">{</a>
<a name="ln393">  const char *const cmd = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln394">  garray_T ga;</a>
<a name="ln395">  int ret = 0;</a>
<a name="ln396"> </a>
<a name="ln397">  called_vim_beep = false;</a>
<a name="ln398">  suppress_errthrow = true;</a>
<a name="ln399">  emsg_silent = false;</a>
<a name="ln400">  do_cmdline_cmd(cmd);</a>
<a name="ln401">  if (!called_vim_beep) {</a>
<a name="ln402">    prepare_assert_error(&amp;ga);</a>
<a name="ln403">    ga_concat(&amp;ga, (const char_u *)&quot;command did not beep: &quot;);</a>
<a name="ln404">    ga_concat(&amp;ga, (const char_u *)cmd);</a>
<a name="ln405">    assert_error(&amp;ga);</a>
<a name="ln406">    ga_clear(&amp;ga);</a>
<a name="ln407">    ret = 1;</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  suppress_errthrow = false;</a>
<a name="ln411">  emsg_on_display = false;</a>
<a name="ln412">  rettv-&gt;vval.v_number = ret;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">// &quot;assert_equal(expected, actual[, msg])&quot; function</a>
<a name="ln416">static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln417">{</a>
<a name="ln418">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">// &quot;assert_equalfile(fname-one, fname-two[, msg])&quot; function</a>
<a name="ln422">static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln423">{</a>
<a name="ln424">  rettv-&gt;vval.v_number = assert_equalfile(argvars);</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">// &quot;assert_notequal(expected, actual[, msg])&quot; function</a>
<a name="ln428">static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln429">{</a>
<a name="ln430">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">/// &quot;assert_report(msg)</a>
<a name="ln434">static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln435">{</a>
<a name="ln436">    garray_T ga;</a>
<a name="ln437"> </a>
<a name="ln438">    prepare_assert_error(&amp;ga);</a>
<a name="ln439">    ga_concat(&amp;ga, (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln440">    assert_error(&amp;ga);</a>
<a name="ln441">    ga_clear(&amp;ga);</a>
<a name="ln442">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/// &quot;assert_exception(string[, msg])&quot; function</a>
<a name="ln446">static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln447">{</a>
<a name="ln448">  rettv-&gt;vval.v_number = assert_exception(argvars);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">/// &quot;assert_fails(cmd [, error [, msg]])&quot; function</a>
<a name="ln452">static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln453">{</a>
<a name="ln454">  rettv-&gt;vval.v_number = assert_fails(argvars);</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">// &quot;assert_false(actual[, msg])&quot; function</a>
<a name="ln458">static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln459">{</a>
<a name="ln460">  rettv-&gt;vval.v_number = assert_bool(argvars, false);</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">/// &quot;assert_inrange(lower, upper[, msg])&quot; function</a>
<a name="ln464">static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln465">{</a>
<a name="ln466">  rettv-&gt;vval.v_number = assert_inrange(argvars);</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">/// &quot;assert_match(pattern, actual[, msg])&quot; function</a>
<a name="ln470">static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln471">{</a>
<a name="ln472">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_MATCH);</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">/// &quot;assert_notmatch(pattern, actual[, msg])&quot; function</a>
<a name="ln476">static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln477">{</a>
<a name="ln478">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">// &quot;assert_true(actual[, msg])&quot; function</a>
<a name="ln482">static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln483">{</a>
<a name="ln484">  rettv-&gt;vval.v_number = assert_bool(argvars, true);</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/*</a>
<a name="ln488"> * &quot;atan2()&quot; function</a>
<a name="ln489"> */</a>
<a name="ln490">static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln491">{</a>
<a name="ln492">  float_T fx;</a>
<a name="ln493">  float_T fy;</a>
<a name="ln494"> </a>
<a name="ln495">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln496">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln497">    rettv-&gt;vval.v_float = atan2(fx, fy);</a>
<a name="ln498">  } else {</a>
<a name="ln499">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln500">  }</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/*</a>
<a name="ln504"> * &quot;browse(save, title, initdir, default)&quot; function</a>
<a name="ln505"> */</a>
<a name="ln506">static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln507">{</a>
<a name="ln508">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln509">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/*</a>
<a name="ln513"> * &quot;browsedir(title, initdir)&quot; function</a>
<a name="ln514"> */</a>
<a name="ln515">static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln516">{</a>
<a name="ln517">  f_browse(argvars, rettv, NULL);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">/*</a>
<a name="ln522"> * Find a buffer by number or exact name.</a>
<a name="ln523"> */</a>
<a name="ln524">static buf_T *find_buffer(typval_T *avar)</a>
<a name="ln525">{</a>
<a name="ln526">  buf_T       *buf = NULL;</a>
<a name="ln527"> </a>
<a name="ln528">  if (avar-&gt;v_type == VAR_NUMBER)</a>
<a name="ln529">    buf = buflist_findnr((int)avar-&gt;vval.v_number);</a>
<a name="ln530">  else if (avar-&gt;v_type == VAR_STRING &amp;&amp; avar-&gt;vval.v_string != NULL) {</a>
<a name="ln531">    buf = buflist_findname_exp(avar-&gt;vval.v_string);</a>
<a name="ln532">    if (buf == NULL) {</a>
<a name="ln533">      /* No full path name match, try a match with a URL or a &quot;nofile&quot;</a>
<a name="ln534">       * buffer, these don't use the full path. */</a>
<a name="ln535">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln536">        if (bp-&gt;b_fname != NULL</a>
<a name="ln537">            &amp;&amp; (path_with_url((char *)bp-&gt;b_fname)</a>
<a name="ln538">                || bt_nofile(bp)</a>
<a name="ln539">                )</a>
<a name="ln540">            &amp;&amp; STRCMP(bp-&gt;b_fname, avar-&gt;vval.v_string) == 0) {</a>
<a name="ln541">          buf = bp;</a>
<a name="ln542">          break;</a>
<a name="ln543">        }</a>
<a name="ln544">      }</a>
<a name="ln545">    }</a>
<a name="ln546">  }</a>
<a name="ln547">  return buf;</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">// &quot;bufadd(expr)&quot; function</a>
<a name="ln551">static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln552">{</a>
<a name="ln553">  char_u *name = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln554"> </a>
<a name="ln555">  rettv-&gt;vval.v_number = buflist_add(*name == NUL ? NULL : name, 0);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/*</a>
<a name="ln559"> * &quot;bufexists(expr)&quot; function</a>
<a name="ln560"> */</a>
<a name="ln561">static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln562">{</a>
<a name="ln563">  rettv-&gt;vval.v_number = (find_buffer(&amp;argvars[0]) != NULL);</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">/*</a>
<a name="ln567"> * &quot;buflisted(expr)&quot; function</a>
<a name="ln568"> */</a>
<a name="ln569">static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln570">{</a>
<a name="ln571">  buf_T       *buf;</a>
<a name="ln572"> </a>
<a name="ln573">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln574">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_p_bl);</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">// &quot;bufload(expr)&quot; function</a>
<a name="ln578">static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln579">{</a>
<a name="ln580">  buf_T *buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln581"> </a>
<a name="ln582">  if (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln583">    aco_save_T aco;</a>
<a name="ln584"> </a>
<a name="ln585">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln586">    swap_exists_action = SEA_NONE;</a>
<a name="ln587">    open_buffer(false, NULL, 0);</a>
<a name="ln588">    aucmd_restbuf(&amp;aco);</a>
<a name="ln589">  }</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/*</a>
<a name="ln593"> * &quot;bufloaded(expr)&quot; function</a>
<a name="ln594"> */</a>
<a name="ln595">static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln596">{</a>
<a name="ln597">  buf_T       *buf;</a>
<a name="ln598"> </a>
<a name="ln599">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln600">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">/*</a>
<a name="ln604"> * &quot;bufname(expr)&quot; function</a>
<a name="ln605"> */</a>
<a name="ln606">static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln607">{</a>
<a name="ln608">  const buf_T *buf;</a>
<a name="ln609">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln610">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln611">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln612">    buf = curbuf;</a>
<a name="ln613">  } else {</a>
<a name="ln614">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln615">      return;</a>
<a name="ln616">    }</a>
<a name="ln617">    emsg_off++;</a>
<a name="ln618">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln619">    emsg_off--;</a>
<a name="ln620">  }</a>
<a name="ln621">  if (buf != NULL &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln622">    rettv-&gt;vval.v_string = (char_u *)xstrdup((char *)buf-&gt;b_fname);</a>
<a name="ln623">  }</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">/*</a>
<a name="ln627"> * &quot;bufnr(expr)&quot; function</a>
<a name="ln628"> */</a>
<a name="ln629">static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln630">{</a>
<a name="ln631">  const buf_T *buf;</a>
<a name="ln632">  bool error = false;</a>
<a name="ln633"> </a>
<a name="ln634">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln635"> </a>
<a name="ln636">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln637">    buf = curbuf;</a>
<a name="ln638">  } else {</a>
<a name="ln639">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln640">      return;</a>
<a name="ln641">    }</a>
<a name="ln642">    emsg_off++;</a>
<a name="ln643">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln644">    emsg_off--;</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  // If the buffer isn't found and the second argument is not zero create a</a>
<a name="ln648">  // new buffer.</a>
<a name="ln649">  const char *name;</a>
<a name="ln650">  if (buf == NULL</a>
<a name="ln651">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln652">      &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error) != 0</a>
<a name="ln653">      &amp;&amp; !error</a>
<a name="ln654">      &amp;&amp; (name = tv_get_string_chk(&amp;argvars[0])) != NULL) {</a>
<a name="ln655">    buf = buflist_new((char_u *)name, NULL, 1, 0);</a>
<a name="ln656">  }</a>
<a name="ln657"> </a>
<a name="ln658">  if (buf != NULL) {</a>
<a name="ln659">    rettv-&gt;vval.v_number = buf-&gt;b_fnum;</a>
<a name="ln660">  }</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr)</a>
<a name="ln664">{</a>
<a name="ln665">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln666">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln667">    return;</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  emsg_off++;</a>
<a name="ln671">  buf_T *buf = tv_get_buf(&amp;argvars[0], true);</a>
<a name="ln672">  if (buf == NULL) {  // no need to search if buffer was not found</a>
<a name="ln673">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln674">    goto end;</a>
<a name="ln675">  }</a>
<a name="ln676"> </a>
<a name="ln677">  int winnr = 0;</a>
<a name="ln678">  int winid;</a>
<a name="ln679">  bool found_buf = false;</a>
<a name="ln680">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln681">    winnr++;</a>
<a name="ln682">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln683">      found_buf = true;</a>
<a name="ln684">      winid = wp-&gt;handle;</a>
<a name="ln685">      break;</a>
<a name="ln686">    }</a>
<a name="ln687">  }</a>
<a name="ln688">  rettv-&gt;vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);</a>
<a name="ln689">end:</a>
<a name="ln690">  emsg_off--;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">/// &quot;bufwinid(nr)&quot; function</a>
<a name="ln694">static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {</a>
<a name="ln695">  buf_win_common(argvars, rettv, false);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/// &quot;bufwinnr(nr)&quot; function</a>
<a name="ln699">static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln700">{</a>
<a name="ln701">  buf_win_common(argvars, rettv, true);</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">/*</a>
<a name="ln705"> * Get buffer by number or pattern.</a>
<a name="ln706"> */</a>
<a name="ln707">buf_T *tv_get_buf(typval_T *tv, int curtab_only)</a>
<a name="ln708">{</a>
<a name="ln709">  char_u      *name = tv-&gt;vval.v_string;</a>
<a name="ln710">  int save_magic;</a>
<a name="ln711">  char_u      *save_cpo;</a>
<a name="ln712">  buf_T       *buf;</a>
<a name="ln713"> </a>
<a name="ln714">  if (tv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln715">    return buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln716">  if (tv-&gt;v_type != VAR_STRING)</a>
<a name="ln717">    return NULL;</a>
<a name="ln718">  if (name == NULL || *name == NUL)</a>
<a name="ln719">    return curbuf;</a>
<a name="ln720">  if (name[0] == '$' &amp;&amp; name[1] == NUL)</a>
<a name="ln721">    return lastbuf;</a>
<a name="ln722"> </a>
<a name="ln723">  // Ignore 'magic' and 'cpoptions' here to make scripts portable</a>
<a name="ln724">  save_magic = p_magic;</a>
<a name="ln725">  p_magic = TRUE;</a>
<a name="ln726">  save_cpo = p_cpo;</a>
<a name="ln727">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln728"> </a>
<a name="ln729">  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),</a>
<a name="ln730">                                       TRUE, FALSE, curtab_only));</a>
<a name="ln731"> </a>
<a name="ln732">  p_magic = save_magic;</a>
<a name="ln733">  p_cpo = save_cpo;</a>
<a name="ln734"> </a>
<a name="ln735">  // If not found, try expanding the name, like done for bufexists().</a>
<a name="ln736">  if (buf == NULL) {</a>
<a name="ln737">    buf = find_buffer(tv);</a>
<a name="ln738">  }</a>
<a name="ln739"> </a>
<a name="ln740">  return buf;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// Get the buffer from &quot;arg&quot; and give an error and return NULL if it is not</a>
<a name="ln744">/// valid.</a>
<a name="ln745">buf_T * get_buf_arg(typval_T *arg)</a>
<a name="ln746">{</a>
<a name="ln747">  buf_T *buf;</a>
<a name="ln748"> </a>
<a name="ln749">  emsg_off++;</a>
<a name="ln750">  buf = tv_get_buf(arg, false);</a>
<a name="ln751">  emsg_off--;</a>
<a name="ln752">  if (buf == NULL) {</a>
<a name="ln753">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), tv_get_string(arg));</a>
<a name="ln754">  }</a>
<a name="ln755">  return buf;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">/*</a>
<a name="ln759"> * &quot;byte2line(byte)&quot; function</a>
<a name="ln760"> */</a>
<a name="ln761">static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln762">{</a>
<a name="ln763">  long boff = tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln764">  if (boff &lt; 0) {</a>
<a name="ln765">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln766">  } else {</a>
<a name="ln767">    rettv-&gt;vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,</a>
<a name="ln768">                                                               &amp;boff, false);</a>
<a name="ln769">  }</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">static void byteidx(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln773">{</a>
<a name="ln774">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln775">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln776">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln777">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln778">    return;</a>
<a name="ln779">  }</a>
<a name="ln780"> </a>
<a name="ln781">  const char *t = str;</a>
<a name="ln782">  for (; idx &gt; 0; idx--) {</a>
<a name="ln783">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln784">      return;</a>
<a name="ln785">    }</a>
<a name="ln786">    if (enc_utf8 &amp;&amp; comp) {</a>
<a name="ln787">      t += utf_ptr2len((const char_u *)t);</a>
<a name="ln788">    } else {</a>
<a name="ln789">      t += (*mb_ptr2len)((const char_u *)t);</a>
<a name="ln790">    }</a>
<a name="ln791">  }</a>
<a name="ln792">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">/*</a>
<a name="ln796"> * &quot;byteidx()&quot; function</a>
<a name="ln797"> */</a>
<a name="ln798">static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln799">{</a>
<a name="ln800">  byteidx(argvars, rettv, FALSE);</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/*</a>
<a name="ln804"> * &quot;byteidxcomp()&quot; function</a>
<a name="ln805"> */</a>
<a name="ln806">static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln807">{</a>
<a name="ln808">  byteidx(argvars, rettv, TRUE);</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">/// &quot;call(func, arglist [, dict])&quot; function</a>
<a name="ln812">static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln813">{</a>
<a name="ln814">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln815">    EMSG(_(e_listreq));</a>
<a name="ln816">    return;</a>
<a name="ln817">  }</a>
<a name="ln818">  if (argvars[1].vval.v_list == NULL) {</a>
<a name="ln819">    return;</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  char_u      *func;</a>
<a name="ln823">  partial_T   *partial = NULL;</a>
<a name="ln824">  dict_T      *selfdict = NULL;</a>
<a name="ln825">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln826">    func = argvars[0].vval.v_string;</a>
<a name="ln827">  } else if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln828">    partial = argvars[0].vval.v_partial;</a>
<a name="ln829">    func = partial_name(partial);</a>
<a name="ln830">  } else if (nlua_is_table_from_lua(&amp;argvars[0])) {</a>
<a name="ln831">    func = nlua_register_table_as_callable(&amp;argvars[0]);</a>
<a name="ln832">  } else {</a>
<a name="ln833">    func = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  if (*func == NUL) {</a>
<a name="ln837">    return;             // type error or empty name</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln841">    if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln842">      EMSG(_(e_dictreq));</a>
<a name="ln843">      return;</a>
<a name="ln844">    }</a>
<a name="ln845">    selfdict = argvars[2].vval.v_dict;</a>
<a name="ln846">  }</a>
<a name="ln847"> </a>
<a name="ln848">  func_call(func, &amp;argvars[1], partial, selfdict, rettv);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">/*</a>
<a name="ln852"> * &quot;changenr()&quot; function</a>
<a name="ln853"> */</a>
<a name="ln854">static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln855">{</a>
<a name="ln856">  rettv-&gt;vval.v_number = curbuf-&gt;b_u_seq_cur;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">// &quot;chanclose(id[, stream])&quot; function</a>
<a name="ln860">static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln861">{</a>
<a name="ln862">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln863">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln864"> </a>
<a name="ln865">  if (check_restricted() || check_secure()) {</a>
<a name="ln866">    return;</a>
<a name="ln867">  }</a>
<a name="ln868"> </a>
<a name="ln869">  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING</a>
<a name="ln870">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln871">    EMSG(_(e_invarg));</a>
<a name="ln872">    return;</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875">  ChannelPart part = kChannelPartAll;</a>
<a name="ln876">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln877">    char *stream = (char *)argvars[1].vval.v_string;</a>
<a name="ln878">    if (!strcmp(stream, &quot;stdin&quot;)) {</a>
<a name="ln879">      part = kChannelPartStdin;</a>
<a name="ln880">    } else if (!strcmp(stream, &quot;stdout&quot;)) {</a>
<a name="ln881">      part = kChannelPartStdout;</a>
<a name="ln882">    } else if (!strcmp(stream, &quot;stderr&quot;)) {</a>
<a name="ln883">      part = kChannelPartStderr;</a>
<a name="ln884">    } else if (!strcmp(stream, &quot;rpc&quot;)) {</a>
<a name="ln885">      part = kChannelPartRpc;</a>
<a name="ln886">    } else {</a>
<a name="ln887">      EMSG2(_(&quot;Invalid channel stream \&quot;%s\&quot;&quot;), stream);</a>
<a name="ln888">      return;</a>
<a name="ln889">    }</a>
<a name="ln890">  }</a>
<a name="ln891">  const char *error;</a>
<a name="ln892">  rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number, part, &amp;error);</a>
<a name="ln893">  if (!rettv-&gt;vval.v_number) {</a>
<a name="ln894">    EMSG(error);</a>
<a name="ln895">  }</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">// &quot;chansend(id, data)&quot; function</a>
<a name="ln899">static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln900">{</a>
<a name="ln901">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln902">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln903"> </a>
<a name="ln904">  if (check_restricted() || check_secure()) {</a>
<a name="ln905">    return;</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln909">    // First argument is the channel id and second is the data to write</a>
<a name="ln910">    EMSG(_(e_invarg));</a>
<a name="ln911">    return;</a>
<a name="ln912">  }</a>
<a name="ln913"> </a>
<a name="ln914">  ptrdiff_t input_len = 0;</a>
<a name="ln915">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln916">  if (!input) {</a>
<a name="ln917">    // Either the error has been handled by save_tv_as_string(),</a>
<a name="ln918">    // or there is no input to send.</a>
<a name="ln919">    return;</a>
<a name="ln920">  }</a>
<a name="ln921">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln922">  const char *error = NULL;</a>
<a name="ln923">  rettv-&gt;vval.v_number = channel_send(id, input, input_len, &amp;error);</a>
<a name="ln924">  if (error) {</a>
<a name="ln925">    EMSG(error);</a>
<a name="ln926">  }</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929">/*</a>
<a name="ln930"> * &quot;char2nr(string)&quot; function</a>
<a name="ln931"> */</a>
<a name="ln932">static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln933">{</a>
<a name="ln934">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln935">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln936">      return;</a>
<a name="ln937">    }</a>
<a name="ln938">  }</a>
<a name="ln939"> </a>
<a name="ln940">  rettv-&gt;vval.v_number = utf_ptr2char(</a>
<a name="ln941">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">/*</a>
<a name="ln945"> * &quot;cindent(lnum)&quot; function</a>
<a name="ln946"> */</a>
<a name="ln947">static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln948">{</a>
<a name="ln949">  pos_T pos;</a>
<a name="ln950">  linenr_T lnum;</a>
<a name="ln951"> </a>
<a name="ln952">  pos = curwin-&gt;w_cursor;</a>
<a name="ln953">  lnum = tv_get_lnum(argvars);</a>
<a name="ln954">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln955">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln956">    rettv-&gt;vval.v_number = get_c_indent();</a>
<a name="ln957">    curwin-&gt;w_cursor = pos;</a>
<a name="ln958">  } else</a>
<a name="ln959">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">static win_T * get_optional_window(typval_T *argvars, int idx)</a>
<a name="ln963">{</a>
<a name="ln964">  win_T *win = curwin;</a>
<a name="ln965"> </a>
<a name="ln966">  if (argvars[idx].v_type != VAR_UNKNOWN) {</a>
<a name="ln967">    win = find_win_by_nr_or_id(&amp;argvars[idx]);</a>
<a name="ln968">    if (win == NULL) {</a>
<a name="ln969">      EMSG(_(e_invalwindow));</a>
<a name="ln970">      return NULL;</a>
<a name="ln971">    }</a>
<a name="ln972">  }</a>
<a name="ln973">  return win;</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">/*</a>
<a name="ln977"> * &quot;clearmatches()&quot; function</a>
<a name="ln978"> */</a>
<a name="ln979">static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln980">{</a>
<a name="ln981">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln982"> </a>
<a name="ln983">  if (win != NULL) {</a>
<a name="ln984">    clear_matches(win);</a>
<a name="ln985">  }</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/*</a>
<a name="ln989"> * &quot;col(string)&quot; function</a>
<a name="ln990"> */</a>
<a name="ln991">static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln992">{</a>
<a name="ln993">  colnr_T col = 0;</a>
<a name="ln994">  pos_T       *fp;</a>
<a name="ln995">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln996"> </a>
<a name="ln997">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln998">  if (fp != NULL &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln999">    if (fp-&gt;col == MAXCOL) {</a>
<a name="ln1000">      // '&gt; can be MAXCOL, get the length of the line then</a>
<a name="ln1001">      if (fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1002">        col = (colnr_T)STRLEN(ml_get(fp-&gt;lnum)) + 1;</a>
<a name="ln1003">      } else {</a>
<a name="ln1004">        col = MAXCOL;</a>
<a name="ln1005">      }</a>
<a name="ln1006">    } else {</a>
<a name="ln1007">      col = fp-&gt;col + 1;</a>
<a name="ln1008">      // col(&quot;.&quot;) when the cursor is on the NUL at the end of the line</a>
<a name="ln1009">      // because of &quot;coladd&quot; can be seen as an extra column.</a>
<a name="ln1010">      if (virtual_active() &amp;&amp; fp == &amp;curwin-&gt;w_cursor) {</a>
<a name="ln1011">        char_u  *p = get_cursor_pos_ptr();</a>
<a name="ln1012"> </a>
<a name="ln1013">        if (curwin-&gt;w_cursor.coladd &gt;= (colnr_T)chartabsize(p,</a>
<a name="ln1014">                curwin-&gt;w_virtcol - curwin-&gt;w_cursor.coladd)) {</a>
<a name="ln1015">          int l;</a>
<a name="ln1016"> </a>
<a name="ln1017">          if (*p != NUL &amp;&amp; p[(l = (*mb_ptr2len)(p))] == NUL)</a>
<a name="ln1018">            col += l;</a>
<a name="ln1019">        }</a>
<a name="ln1020">      }</a>
<a name="ln1021">    }</a>
<a name="ln1022">  }</a>
<a name="ln1023">  rettv-&gt;vval.v_number = col;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">/*</a>
<a name="ln1027"> * &quot;complete()&quot; function</a>
<a name="ln1028"> */</a>
<a name="ln1029">static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1030">{</a>
<a name="ln1031">  if ((State &amp; INSERT) == 0) {</a>
<a name="ln1032">    EMSG(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln1033">    return;</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  /* Check for undo allowed here, because if something was already inserted</a>
<a name="ln1037">   * the line was already saved for undo and this check isn't done. */</a>
<a name="ln1038">  if (!undo_allowed())</a>
<a name="ln1039">    return;</a>
<a name="ln1040"> </a>
<a name="ln1041">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln1042">    EMSG(_(e_invarg));</a>
<a name="ln1043">    return;</a>
<a name="ln1044">  }</a>
<a name="ln1045"> </a>
<a name="ln1046">  const colnr_T startcol = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln1047">  if (startcol &lt;= 0) {</a>
<a name="ln1048">    return;</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">/*</a>
<a name="ln1055"> * &quot;complete_add()&quot; function</a>
<a name="ln1056"> */</a>
<a name="ln1057">static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1058">{</a>
<a name="ln1059">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0);</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">/*</a>
<a name="ln1063"> * &quot;complete_check()&quot; function</a>
<a name="ln1064"> */</a>
<a name="ln1065">static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1066">{</a>
<a name="ln1067">  int saved = RedrawingDisabled;</a>
<a name="ln1068"> </a>
<a name="ln1069">  RedrawingDisabled = 0;</a>
<a name="ln1070">  ins_compl_check_keys(0, true);</a>
<a name="ln1071">  rettv-&gt;vval.v_number = compl_interrupted;</a>
<a name="ln1072">  RedrawingDisabled = saved;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">// &quot;complete_info()&quot; function</a>
<a name="ln1076">static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1077">{</a>
<a name="ln1078">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1079"> </a>
<a name="ln1080">  list_T *what_list = NULL;</a>
<a name="ln1081"> </a>
<a name="ln1082">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1083">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1084">      EMSG(_(e_listreq));</a>
<a name="ln1085">      return;</a>
<a name="ln1086">    }</a>
<a name="ln1087">    what_list = argvars[0].vval.v_list;</a>
<a name="ln1088">  }</a>
<a name="ln1089">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">/*</a>
<a name="ln1093"> * &quot;confirm(message, buttons[, default [, type]])&quot; function</a>
<a name="ln1094"> */</a>
<a name="ln1095">static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1096">{</a>
<a name="ln1097">  char buf[NUMBUFLEN];</a>
<a name="ln1098">  char buf2[NUMBUFLEN];</a>
<a name="ln1099">  const char *message;</a>
<a name="ln1100">  const char *buttons = NULL;</a>
<a name="ln1101">  int def = 1;</a>
<a name="ln1102">  int type = VIM_GENERIC;</a>
<a name="ln1103">  const char *typestr;</a>
<a name="ln1104">  bool error = false;</a>
<a name="ln1105"> </a>
<a name="ln1106">  message = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1107">  if (message == NULL) {</a>
<a name="ln1108">    error = true;</a>
<a name="ln1109">  }</a>
<a name="ln1110">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1111">    buttons = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1112">    if (buttons == NULL) {</a>
<a name="ln1113">      error = true;</a>
<a name="ln1114">    }</a>
<a name="ln1115">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1116">      def = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1117">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1118">        typestr = tv_get_string_buf_chk(&amp;argvars[3], buf2);</a>
<a name="ln1119">        if (typestr == NULL) {</a>
<a name="ln1120">          error = true;</a>
<a name="ln1121">        } else {</a>
<a name="ln1122">          switch (TOUPPER_ASC(*typestr)) {</a>
<a name="ln1123">            case 'E': type = VIM_ERROR; break;</a>
<a name="ln1124">            case 'Q': type = VIM_QUESTION; break;</a>
<a name="ln1125">            case 'I': type = VIM_INFO; break;</a>
<a name="ln1126">            case 'W': type = VIM_WARNING; break;</a>
<a name="ln1127">            case 'G': type = VIM_GENERIC; break;</a>
<a name="ln1128">          }</a>
<a name="ln1129">        }</a>
<a name="ln1130">      }</a>
<a name="ln1131">    }</a>
<a name="ln1132">  }</a>
<a name="ln1133"> </a>
<a name="ln1134">  if (buttons == NULL || *buttons == NUL) {</a>
<a name="ln1135">    buttons = _(&quot;&amp;Ok&quot;);</a>
<a name="ln1136">  }</a>
<a name="ln1137"> </a>
<a name="ln1138">  if (!error) {</a>
<a name="ln1139">    rettv-&gt;vval.v_number = do_dialog(</a>
<a name="ln1140">        type, NULL, (char_u *)message, (char_u *)buttons, def, NULL, false);</a>
<a name="ln1141">  }</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">/*</a>
<a name="ln1145"> * &quot;copy()&quot; function</a>
<a name="ln1146"> */</a>
<a name="ln1147">static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1148">{</a>
<a name="ln1149">  var_item_copy(NULL, &amp;argvars[0], rettv, false, 0);</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">/*</a>
<a name="ln1153"> * &quot;count()&quot; function</a>
<a name="ln1154"> */</a>
<a name="ln1155">static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1156">{</a>
<a name="ln1157">  long n = 0;</a>
<a name="ln1158">  int ic = 0;</a>
<a name="ln1159">  bool error = false;</a>
<a name="ln1160"> </a>
<a name="ln1161">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1162">    ic = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1163">  }</a>
<a name="ln1164"> </a>
<a name="ln1165">  if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln1166">    const char_u *expr = (char_u *)tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1167">    const char_u *p = argvars[0].vval.v_string;</a>
<a name="ln1168"> </a>
<a name="ln1169">    if (!error &amp;&amp; expr != NULL &amp;&amp; *expr != NUL &amp;&amp; p != NULL) {</a>
<a name="ln1170">      if (ic) {</a>
<a name="ln1171">        const size_t len = STRLEN(expr);</a>
<a name="ln1172"> </a>
<a name="ln1173">        while (*p != NUL) {</a>
<a name="ln1174">          if (mb_strnicmp(p, expr, len) == 0) {</a>
<a name="ln1175">            n++;</a>
<a name="ln1176">            p += len;</a>
<a name="ln1177">          } else {</a>
<a name="ln1178">            MB_PTR_ADV(p);</a>
<a name="ln1179">          }</a>
<a name="ln1180">        }</a>
<a name="ln1181">      } else {</a>
<a name="ln1182">        char_u *next;</a>
<a name="ln1183">        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != NULL) {</a>
<a name="ln1184">          n++;</a>
<a name="ln1185">          p = next + STRLEN(expr);</a>
<a name="ln1186">        }</a>
<a name="ln1187">      }</a>
<a name="ln1188">    }</a>
<a name="ln1189">  } else if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1190">    listitem_T      *li;</a>
<a name="ln1191">    list_T          *l;</a>
<a name="ln1192">    long idx;</a>
<a name="ln1193"> </a>
<a name="ln1194">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln1195">      li = tv_list_first(l);</a>
<a name="ln1196">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1197">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1198">          idx = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1199">          if (!error) {</a>
<a name="ln1200">            li = tv_list_find(l, idx);</a>
<a name="ln1201">            if (li == NULL) {</a>
<a name="ln1202">              EMSGN(_(e_listidx), idx);</a>
<a name="ln1203">            }</a>
<a name="ln1204">          }</a>
<a name="ln1205">        }</a>
<a name="ln1206">        if (error)</a>
<a name="ln1207">          li = NULL;</a>
<a name="ln1208">      }</a>
<a name="ln1209"> </a>
<a name="ln1210">      for (; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1211">        if (tv_equal(TV_LIST_ITEM_TV(li), &amp;argvars[1], ic, false)) {</a>
<a name="ln1212">          n++;</a>
<a name="ln1213">        }</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln1217">    int todo;</a>
<a name="ln1218">    dict_T          *d;</a>
<a name="ln1219">    hashitem_T      *hi;</a>
<a name="ln1220"> </a>
<a name="ln1221">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln1222">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1223">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1224">          EMSG(_(e_invarg));</a>
<a name="ln1225">        }</a>
<a name="ln1226">      }</a>
<a name="ln1227"> </a>
<a name="ln1228">      todo = error ? 0 : (int)d-&gt;dv_hashtab.ht_used;</a>
<a name="ln1229">      for (hi = d-&gt;dv_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln1230">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1231">          todo--;</a>
<a name="ln1232">          if (tv_equal(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, &amp;argvars[1], ic, false)) {</a>
<a name="ln1233">            n++;</a>
<a name="ln1234">          }</a>
<a name="ln1235">        }</a>
<a name="ln1236">      }</a>
<a name="ln1237">    }</a>
<a name="ln1238">  } else {</a>
<a name="ln1239">    EMSG2(_(e_listdictarg), &quot;count()&quot;);</a>
<a name="ln1240">  }</a>
<a name="ln1241">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">/*</a>
<a name="ln1245"> * &quot;cscope_connection([{num} , {dbpath} [, {prepend}]])&quot; function</a>
<a name="ln1246"> *</a>
<a name="ln1247"> * Checks the existence of a cscope connection.</a>
<a name="ln1248"> */</a>
<a name="ln1249">static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1250">{</a>
<a name="ln1251">  int num = 0;</a>
<a name="ln1252">  const char *dbpath = NULL;</a>
<a name="ln1253">  const char *prepend = NULL;</a>
<a name="ln1254">  char buf[NUMBUFLEN];</a>
<a name="ln1255"> </a>
<a name="ln1256">  if (argvars[0].v_type != VAR_UNKNOWN</a>
<a name="ln1257">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1258">    num = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1259">    dbpath = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1260">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1261">      prepend = tv_get_string_buf(&amp;argvars[2], buf);</a>
<a name="ln1262">    }</a>
<a name="ln1263">  }</a>
<a name="ln1264"> </a>
<a name="ln1265">  rettv-&gt;vval.v_number = cs_connection(num, (char_u *)dbpath,</a>
<a name="ln1266">                                       (char_u *)prepend);</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269">/// &quot;ctxget([{index}])&quot; function</a>
<a name="ln1270">static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1271">{</a>
<a name="ln1272">  size_t index = 0;</a>
<a name="ln1273">  if (argvars[0].v_type == VAR_NUMBER) {</a>
<a name="ln1274">    index = argvars[0].vval.v_number;</a>
<a name="ln1275">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1276">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as an argument&quot;);</a>
<a name="ln1277">    return;</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  Context *ctx = ctx_get(index);</a>
<a name="ln1281">  if (ctx == NULL) {</a>
<a name="ln1282">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1283">    return;</a>
<a name="ln1284">  }</a>
<a name="ln1285"> </a>
<a name="ln1286">  Dictionary ctx_dict = ctx_to_dict(ctx);</a>
<a name="ln1287">  Error err = ERROR_INIT;</a>
<a name="ln1288">  object_to_vim(DICTIONARY_OBJ(ctx_dict), rettv, &amp;err);</a>
<a name="ln1289">  api_free_dictionary(ctx_dict);</a>
<a name="ln1290">  api_clear_error(&amp;err);</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">/// &quot;ctxpop()&quot; function</a>
<a name="ln1294">static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1295">{</a>
<a name="ln1296">  if (!ctx_restore(NULL, kCtxAll)) {</a>
<a name="ln1297">    EMSG(_(&quot;Context stack is empty&quot;));</a>
<a name="ln1298">  }</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">/// &quot;ctxpush([{types}])&quot; function</a>
<a name="ln1302">static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1303">{</a>
<a name="ln1304">  int types = kCtxAll;</a>
<a name="ln1305">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1306">    types = 0;</a>
<a name="ln1307">    TV_LIST_ITER(argvars[0].vval.v_list, li, {</a>
<a name="ln1308">      typval_T *tv_li = TV_LIST_ITEM_TV(li);</a>
<a name="ln1309">      if (tv_li-&gt;v_type == VAR_STRING) {</a>
<a name="ln1310">        if (strequal((char *)tv_li-&gt;vval.v_string, &quot;regs&quot;)) {</a>
<a name="ln1311">          types |= kCtxRegs;</a>
<a name="ln1312">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;jumps&quot;)) {</a>
<a name="ln1313">          types |= kCtxJumps;</a>
<a name="ln1314">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;bufs&quot;)) {</a>
<a name="ln1315">          types |= kCtxBufs;</a>
<a name="ln1316">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;gvars&quot;)) {</a>
<a name="ln1317">          types |= kCtxGVars;</a>
<a name="ln1318">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;sfuncs&quot;)) {</a>
<a name="ln1319">          types |= kCtxSFuncs;</a>
<a name="ln1320">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;funcs&quot;)) {</a>
<a name="ln1321">          types |= kCtxFuncs;</a>
<a name="ln1322">        }</a>
<a name="ln1323">      }</a>
<a name="ln1324">    });</a>
<a name="ln1325">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1326">    EMSG2(_(e_invarg2), &quot;expected nothing or a List as an argument&quot;);</a>
<a name="ln1327">    return;</a>
<a name="ln1328">  }</a>
<a name="ln1329">  ctx_save(NULL, types);</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">/// &quot;ctxset({context}[, {index}])&quot; function</a>
<a name="ln1333">static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1334">{</a>
<a name="ln1335">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1336">    EMSG2(_(e_invarg2), &quot;expected dictionary as first argument&quot;);</a>
<a name="ln1337">    return;</a>
<a name="ln1338">  }</a>
<a name="ln1339"> </a>
<a name="ln1340">  size_t index = 0;</a>
<a name="ln1341">  if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln1342">    index = argvars[1].vval.v_number;</a>
<a name="ln1343">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1344">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as second argument&quot;);</a>
<a name="ln1345">    return;</a>
<a name="ln1346">  }</a>
<a name="ln1347"> </a>
<a name="ln1348">  Context *ctx = ctx_get(index);</a>
<a name="ln1349">  if (ctx == NULL) {</a>
<a name="ln1350">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1351">    return;</a>
<a name="ln1352">  }</a>
<a name="ln1353"> </a>
<a name="ln1354">  int save_did_emsg = did_emsg;</a>
<a name="ln1355">  did_emsg = false;</a>
<a name="ln1356"> </a>
<a name="ln1357">  Dictionary dict = vim_to_object(&amp;argvars[0]).data.dictionary;</a>
<a name="ln1358">  Context tmp = CONTEXT_INIT;</a>
<a name="ln1359">  ctx_from_dict(dict, &amp;tmp);</a>
<a name="ln1360"> </a>
<a name="ln1361">  if (did_emsg) {</a>
<a name="ln1362">    ctx_free(&amp;tmp);</a>
<a name="ln1363">  } else {</a>
<a name="ln1364">    ctx_free(ctx);</a>
<a name="ln1365">    *ctx = tmp;</a>
<a name="ln1366">  }</a>
<a name="ln1367"> </a>
<a name="ln1368">  api_free_dictionary(dict);</a>
<a name="ln1369">  did_emsg = save_did_emsg;</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">/// &quot;ctxsize()&quot; function</a>
<a name="ln1373">static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1374">{</a>
<a name="ln1375">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1376">  rettv-&gt;vval.v_number = ctx_size();</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379">/// &quot;cursor(lnum, col)&quot; function, or</a>
<a name="ln1380">/// &quot;cursor(list)&quot;</a>
<a name="ln1381">///</a>
<a name="ln1382">/// Moves the cursor to the specified line and column.</a>
<a name="ln1383">///</a>
<a name="ln1384">/// @returns 0 when the position could be set, -1 otherwise.</a>
<a name="ln1385">static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1386">{</a>
<a name="ln1387">  long line, col;</a>
<a name="ln1388">  long coladd = 0;</a>
<a name="ln1389">  bool set_curswant = true;</a>
<a name="ln1390"> </a>
<a name="ln1391">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1392">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1393">    pos_T pos;</a>
<a name="ln1394">    colnr_T curswant = -1;</a>
<a name="ln1395"> </a>
<a name="ln1396">    if (list2fpos(argvars, &amp;pos, NULL, &amp;curswant) == FAIL) {</a>
<a name="ln1397">      EMSG(_(e_invarg));</a>
<a name="ln1398">      return;</a>
<a name="ln1399">    }</a>
<a name="ln1400"> </a>
<a name="ln1401">    line = pos.lnum;</a>
<a name="ln1402">    col = pos.col;</a>
<a name="ln1403">    coladd = pos.coladd;</a>
<a name="ln1404">    if (curswant &gt;= 0) {</a>
<a name="ln1405">      curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln1406">      set_curswant = false;</a>
<a name="ln1407">    }</a>
<a name="ln1408">  } else {</a>
<a name="ln1409">    line = tv_get_lnum(argvars);</a>
<a name="ln1410">    col = (long)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1411">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1412">      coladd = (long)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1413">    }</a>
<a name="ln1414">  }</a>
<a name="ln1415">  if (line &lt; 0 || col &lt; 0</a>
<a name="ln1416">      || coladd &lt; 0) {</a>
<a name="ln1417">    return;             // type error; errmsg already given</a>
<a name="ln1418">  }</a>
<a name="ln1419">  if (line &gt; 0) {</a>
<a name="ln1420">    curwin-&gt;w_cursor.lnum = line;</a>
<a name="ln1421">  }</a>
<a name="ln1422">  if (col &gt; 0) {</a>
<a name="ln1423">    curwin-&gt;w_cursor.col = col - 1;</a>
<a name="ln1424">  }</a>
<a name="ln1425">  curwin-&gt;w_cursor.coladd = coladd;</a>
<a name="ln1426"> </a>
<a name="ln1427">  // Make sure the cursor is in a valid position.</a>
<a name="ln1428">  check_cursor();</a>
<a name="ln1429">  // Correct cursor for multi-byte character.</a>
<a name="ln1430">  if (has_mbyte) {</a>
<a name="ln1431">    mb_adjust_cursor();</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  curwin-&gt;w_set_curswant = set_curswant;</a>
<a name="ln1435">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">// &quot;debugbreak()&quot; function</a>
<a name="ln1439">static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1440">{</a>
<a name="ln1441">  int pid;</a>
<a name="ln1442"> </a>
<a name="ln1443">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln1444">  pid = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1445">  if (pid == 0) {</a>
<a name="ln1446">    EMSG(_(e_invarg));</a>
<a name="ln1447">  } else {</a>
<a name="ln1448">#ifdef WIN32</a>
<a name="ln1449">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);</a>
<a name="ln1450"> </a>
<a name="ln1451">    if (hProcess != NULL) {</a>
<a name="ln1452">      DebugBreakProcess(hProcess);</a>
<a name="ln1453">      CloseHandle(hProcess);</a>
<a name="ln1454">      rettv-&gt;vval.v_number = OK;</a>
<a name="ln1455">    }</a>
<a name="ln1456">#else</a>
<a name="ln1457">    uv_kill(pid, SIGINT);</a>
<a name="ln1458">#endif</a>
<a name="ln1459">  }</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">// &quot;deepcopy()&quot; function</a>
<a name="ln1463">static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1464">{</a>
<a name="ln1465">  int noref = 0;</a>
<a name="ln1466"> </a>
<a name="ln1467">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1468">    noref = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1469">  }</a>
<a name="ln1470">  if (noref &lt; 0 || noref &gt; 1) {</a>
<a name="ln1471">    EMSG(_(e_invarg));</a>
<a name="ln1472">  } else {</a>
<a name="ln1473">    var_item_copy(NULL, &amp;argvars[0], rettv, true, (noref == 0</a>
<a name="ln1474">                                                   ? get_copyID()</a>
<a name="ln1475">                                                   : 0));</a>
<a name="ln1476">  }</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">// &quot;delete()&quot; function</a>
<a name="ln1480">static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1481">{</a>
<a name="ln1482">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1483">  if (check_restricted() || check_secure()) {</a>
<a name="ln1484">    return;</a>
<a name="ln1485">  }</a>
<a name="ln1486"> </a>
<a name="ln1487">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1488">  if (*name == NUL) {</a>
<a name="ln1489">    EMSG(_(e_invarg));</a>
<a name="ln1490">    return;</a>
<a name="ln1491">  }</a>
<a name="ln1492"> </a>
<a name="ln1493">  char nbuf[NUMBUFLEN];</a>
<a name="ln1494">  const char *flags;</a>
<a name="ln1495">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1496">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln1497">  } else {</a>
<a name="ln1498">    flags = &quot;&quot;;</a>
<a name="ln1499">  }</a>
<a name="ln1500"> </a>
<a name="ln1501">  if (*flags == NUL) {</a>
<a name="ln1502">    // delete a file</a>
<a name="ln1503">    rettv-&gt;vval.v_number = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln1504">  } else if (strcmp(flags, &quot;d&quot;) == 0) {</a>
<a name="ln1505">    // delete an empty directory</a>
<a name="ln1506">    rettv-&gt;vval.v_number = os_rmdir(name) == 0 ? 0 : -1;</a>
<a name="ln1507">  } else if (strcmp(flags, &quot;rf&quot;) == 0) {</a>
<a name="ln1508">    // delete a directory recursively</a>
<a name="ln1509">    rettv-&gt;vval.v_number = delete_recursive(name);</a>
<a name="ln1510">  } else {</a>
<a name="ln1511">    emsgf(_(e_invexpr2), flags);</a>
<a name="ln1512">  }</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">// dictwatcheradd(dict, key, funcref) function</a>
<a name="ln1516">static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1517">{</a>
<a name="ln1518">  if (check_restricted() || check_secure()) {</a>
<a name="ln1519">    return;</a>
<a name="ln1520">  }</a>
<a name="ln1521"> </a>
<a name="ln1522">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1523">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1524">    return;</a>
<a name="ln1525">  } else if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln1526">    const char *const arg_errmsg = _(&quot;dictwatcheradd() argument&quot;);</a>
<a name="ln1527">    const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1528">    emsgf(_(e_readonlyvar), (int)arg_errmsg_len, arg_errmsg);</a>
<a name="ln1529">    return;</a>
<a name="ln1530">  }</a>
<a name="ln1531"> </a>
<a name="ln1532">  if (argvars[1].v_type != VAR_STRING &amp;&amp; argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1533">    emsgf(_(e_invarg2), &quot;key&quot;);</a>
<a name="ln1534">    return;</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1538">  if (key_pattern == NULL) {</a>
<a name="ln1539">    return;</a>
<a name="ln1540">  }</a>
<a name="ln1541">  const size_t key_pattern_len = strlen(key_pattern);</a>
<a name="ln1542"> </a>
<a name="ln1543">  Callback callback;</a>
<a name="ln1544">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1545">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1546">    return;</a>
<a name="ln1547">  }</a>
<a name="ln1548"> </a>
<a name="ln1549">  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,</a>
<a name="ln1550">                      callback);</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">// dictwatcherdel(dict, key, funcref) function</a>
<a name="ln1554">static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1555">{</a>
<a name="ln1556">  if (check_restricted() || check_secure()) {</a>
<a name="ln1557">    return;</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1561">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1562">    return;</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  if (argvars[2].v_type != VAR_FUNC &amp;&amp; argvars[2].v_type != VAR_STRING) {</a>
<a name="ln1566">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1567">    return;</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1571">  if (key_pattern == NULL) {</a>
<a name="ln1572">    return;</a>
<a name="ln1573">  }</a>
<a name="ln1574"> </a>
<a name="ln1575">  Callback callback;</a>
<a name="ln1576">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1577">    return;</a>
<a name="ln1578">  }</a>
<a name="ln1579"> </a>
<a name="ln1580">  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,</a>
<a name="ln1581">                              strlen(key_pattern), callback)) {</a>
<a name="ln1582">    EMSG(&quot;Couldn't find a watcher matching key and callback&quot;);</a>
<a name="ln1583">  }</a>
<a name="ln1584"> </a>
<a name="ln1585">  callback_free(&amp;callback);</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">/// &quot;deletebufline()&quot; function</a>
<a name="ln1589">static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1590">{</a>
<a name="ln1591">  linenr_T last;</a>
<a name="ln1592">  buf_T *curbuf_save = NULL;</a>
<a name="ln1593">  win_T *curwin_save = NULL;</a>
<a name="ln1594"> </a>
<a name="ln1595">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln1596">  if (buf == NULL) {</a>
<a name="ln1597">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1598">    return;</a>
<a name="ln1599">  }</a>
<a name="ln1600">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln1601"> </a>
<a name="ln1602">  const linenr_T first = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln1603">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1604">    last = tv_get_lnum_buf(&amp;argvars[2], buf);</a>
<a name="ln1605">  } else {</a>
<a name="ln1606">    last = first;</a>
<a name="ln1607">  }</a>
<a name="ln1608"> </a>
<a name="ln1609">  if (buf-&gt;b_ml.ml_mfp == NULL || first &lt; 1</a>
<a name="ln1610">      || first &gt; buf-&gt;b_ml.ml_line_count || last &lt; first) {</a>
<a name="ln1611">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1612">    return;</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  if (!is_curbuf) {</a>
<a name="ln1616">    curbuf_save = curbuf;</a>
<a name="ln1617">    curwin_save = curwin;</a>
<a name="ln1618">    curbuf = buf;</a>
<a name="ln1619">    find_win_for_curbuf();</a>
<a name="ln1620">  }</a>
<a name="ln1621">  if (last &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1622">    last = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1623">  }</a>
<a name="ln1624">  const long count = last - first + 1;</a>
<a name="ln1625"> </a>
<a name="ln1626">  // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln1627">  // undone separately from what was previously inserted.</a>
<a name="ln1628">  if (u_sync_once == 2) {</a>
<a name="ln1629">    u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln1630">    u_sync(true);</a>
<a name="ln1631">  }</a>
<a name="ln1632"> </a>
<a name="ln1633">  if (u_save(first - 1, last + 1) == FAIL) {</a>
<a name="ln1634">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1635">    return;</a>
<a name="ln1636">  }</a>
<a name="ln1637"> </a>
<a name="ln1638">  for (linenr_T lnum = first; lnum &lt;= last; lnum++) {</a>
<a name="ln1639">    ml_delete(first, true);</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1643">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1644">      if (wp-&gt;w_cursor.lnum &gt; last) {</a>
<a name="ln1645">        wp-&gt;w_cursor.lnum -= count;</a>
<a name="ln1646">      } else if (wp-&gt;w_cursor.lnum&gt; first) {</a>
<a name="ln1647">        wp-&gt;w_cursor.lnum = first;</a>
<a name="ln1648">      }</a>
<a name="ln1649">      if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1650">        wp-&gt;w_cursor.lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1651">      }</a>
<a name="ln1652">    }</a>
<a name="ln1653">  }</a>
<a name="ln1654">  check_cursor_col();</a>
<a name="ln1655">  deleted_lines_mark(first, count);</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (!is_curbuf) {</a>
<a name="ln1658">    curbuf = curbuf_save;</a>
<a name="ln1659">    curwin = curwin_save;</a>
<a name="ln1660">  }</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">/*</a>
<a name="ln1664"> * &quot;did_filetype()&quot; function</a>
<a name="ln1665"> */</a>
<a name="ln1666">static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1667">{</a>
<a name="ln1668">  rettv-&gt;vval.v_number = did_filetype;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">/*</a>
<a name="ln1672"> * &quot;diff_filler()&quot; function</a>
<a name="ln1673"> */</a>
<a name="ln1674">static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1675">{</a>
<a name="ln1676">  rettv-&gt;vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">/*</a>
<a name="ln1680"> * &quot;diff_hlID()&quot; function</a>
<a name="ln1681"> */</a>
<a name="ln1682">static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1683">{</a>
<a name="ln1684">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln1685">  static linenr_T prev_lnum = 0;</a>
<a name="ln1686">  static int changedtick = 0;</a>
<a name="ln1687">  static int fnum = 0;</a>
<a name="ln1688">  static int change_start = 0;</a>
<a name="ln1689">  static int change_end = 0;</a>
<a name="ln1690">  static hlf_T hlID = (hlf_T)0;</a>
<a name="ln1691">  int filler_lines;</a>
<a name="ln1692">  int col;</a>
<a name="ln1693"> </a>
<a name="ln1694">  if (lnum &lt; 0) {       // ignore type error in {lnum} arg</a>
<a name="ln1695">    lnum = 0;</a>
<a name="ln1696">  }</a>
<a name="ln1697">  if (lnum != prev_lnum</a>
<a name="ln1698">      || changedtick != buf_get_changedtick(curbuf)</a>
<a name="ln1699">      || fnum != curbuf-&gt;b_fnum) {</a>
<a name="ln1700">    // New line, buffer, change: need to get the values.</a>
<a name="ln1701">    filler_lines = diff_check(curwin, lnum);</a>
<a name="ln1702">    if (filler_lines &lt; 0) {</a>
<a name="ln1703">      if (filler_lines == -1) {</a>
<a name="ln1704">        change_start = MAXCOL;</a>
<a name="ln1705">        change_end = -1;</a>
<a name="ln1706">        if (diff_find_change(curwin, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln1707">          hlID = HLF_ADD;               // added line</a>
<a name="ln1708">        } else {</a>
<a name="ln1709">          hlID = HLF_CHD;               // changed line</a>
<a name="ln1710">        }</a>
<a name="ln1711">      } else {</a>
<a name="ln1712">        hlID = HLF_ADD;         // added line</a>
<a name="ln1713">      }</a>
<a name="ln1714">    } else {</a>
<a name="ln1715">      hlID = (hlf_T)0;</a>
<a name="ln1716">    }</a>
<a name="ln1717">    prev_lnum = lnum;</a>
<a name="ln1718">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1719">    fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1720">  }</a>
<a name="ln1721"> </a>
<a name="ln1722">  if (hlID == HLF_CHD || hlID == HLF_TXD) {</a>
<a name="ln1723">    col = tv_get_number(&amp;argvars[1]) - 1;  // Ignore type error in {col}.</a>
<a name="ln1724">    if (col &gt;= change_start &amp;&amp; col &lt;= change_end) {</a>
<a name="ln1725">      hlID = HLF_TXD;  // Changed text.</a>
<a name="ln1726">    } else {</a>
<a name="ln1727">      hlID = HLF_CHD;  // Changed line.</a>
<a name="ln1728">    }</a>
<a name="ln1729">  }</a>
<a name="ln1730">  rettv-&gt;vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">/*</a>
<a name="ln1734"> * &quot;empty({expr})&quot; function</a>
<a name="ln1735"> */</a>
<a name="ln1736">static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1737">{</a>
<a name="ln1738">  bool n = true;</a>
<a name="ln1739"> </a>
<a name="ln1740">  switch (argvars[0].v_type) {</a>
<a name="ln1741">    case VAR_STRING:</a>
<a name="ln1742">    case VAR_FUNC: {</a>
<a name="ln1743">      n = argvars[0].vval.v_string == NULL</a>
<a name="ln1744">          || *argvars[0].vval.v_string == NUL;</a>
<a name="ln1745">      break;</a>
<a name="ln1746">    }</a>
<a name="ln1747">    case VAR_PARTIAL: {</a>
<a name="ln1748">      n = false;</a>
<a name="ln1749">      break;</a>
<a name="ln1750">    }</a>
<a name="ln1751">    case VAR_NUMBER: {</a>
<a name="ln1752">      n = argvars[0].vval.v_number == 0;</a>
<a name="ln1753">      break;</a>
<a name="ln1754">    }</a>
<a name="ln1755">    case VAR_FLOAT: {</a>
<a name="ln1756">      n = argvars[0].vval.v_float == 0.0;</a>
<a name="ln1757">      break;</a>
<a name="ln1758">    }</a>
<a name="ln1759">    case VAR_LIST: {</a>
<a name="ln1760">      n = (tv_list_len(argvars[0].vval.v_list) == 0);</a>
<a name="ln1761">      break;</a>
<a name="ln1762">    }</a>
<a name="ln1763">    case VAR_DICT: {</a>
<a name="ln1764">      n = (tv_dict_len(argvars[0].vval.v_dict) == 0);</a>
<a name="ln1765">      break;</a>
<a name="ln1766">    }</a>
<a name="ln1767">    case VAR_BOOL: {</a>
<a name="ln1768">      switch (argvars[0].vval.v_bool) {</a>
<a name="ln1769">        case kBoolVarTrue: {</a>
<a name="ln1770">          n = false;</a>
<a name="ln1771">          break;</a>
<a name="ln1772">        }</a>
<a name="ln1773">        case kBoolVarFalse: {</a>
<a name="ln1774">          n = true;</a>
<a name="ln1775">          break;</a>
<a name="ln1776">        }</a>
<a name="ln1777">      }</a>
<a name="ln1778">      break;</a>
<a name="ln1779">    }</a>
<a name="ln1780">    case VAR_SPECIAL: {</a>
<a name="ln1781">      n = argvars[0].vval.v_special == kSpecialVarNull;</a>
<a name="ln1782">      break;</a>
<a name="ln1783">    }</a>
<a name="ln1784">    case VAR_UNKNOWN: {</a>
<a name="ln1785">      internal_error(&quot;f_empty(UNKNOWN)&quot;);</a>
<a name="ln1786">      break;</a>
<a name="ln1787">    }</a>
<a name="ln1788">  }</a>
<a name="ln1789"> </a>
<a name="ln1790">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793">/// &quot;environ()&quot; function</a>
<a name="ln1794">static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1795">{</a>
<a name="ln1796">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1797"> </a>
<a name="ln1798">  size_t env_size = os_get_fullenv_size();</a>
<a name="ln1799">  char **env = xmalloc(sizeof(*env) * (env_size + 1));</a>
<a name="ln1800">  env[env_size] = NULL;</a>
<a name="ln1801"> </a>
<a name="ln1802">  os_copy_fullenv(env, env_size);</a>
<a name="ln1803"> </a>
<a name="ln1804">  for (size_t i = 0; i &lt; env_size; i++) {</a>
<a name="ln1805">    const char * str = env[i];</a>
<a name="ln1806">    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),</a>
<a name="ln1807">                                    '=');</a>
<a name="ln1808">    assert(end != NULL);</a>
<a name="ln1809">    ptrdiff_t len = end - str;</a>
<a name="ln1810">    assert(len &gt; 0);</a>
<a name="ln1811">    const char * value = str + len + 1;</a>
<a name="ln1812">    tv_dict_add_str(rettv-&gt;vval.v_dict,</a>
<a name="ln1813">                    str, len,</a>
<a name="ln1814">                    value);</a>
<a name="ln1815">  }</a>
<a name="ln1816">  os_free_fullenv(env);</a>
<a name="ln1817">}</a>
<a name="ln1818"> </a>
<a name="ln1819">/*</a>
<a name="ln1820"> * &quot;escape({string}, {chars})&quot; function</a>
<a name="ln1821"> */</a>
<a name="ln1822">static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1823">{</a>
<a name="ln1824">  char buf[NUMBUFLEN];</a>
<a name="ln1825"> </a>
<a name="ln1826">  rettv-&gt;vval.v_string = vim_strsave_escaped(</a>
<a name="ln1827">      (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln1828">      (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln1829">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">/// &quot;getenv()&quot; function</a>
<a name="ln1833">static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1834">{</a>
<a name="ln1835">  char_u *p = (char_u *)vim_getenv(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1836"> </a>
<a name="ln1837">  if (p == NULL) {</a>
<a name="ln1838">    rettv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1839">    rettv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1840">    return;</a>
<a name="ln1841">  }</a>
<a name="ln1842">  rettv-&gt;vval.v_string = p;</a>
<a name="ln1843">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">/*</a>
<a name="ln1847"> * &quot;eval()&quot; function</a>
<a name="ln1848"> */</a>
<a name="ln1849">static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1850">{</a>
<a name="ln1851">  const char *s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1852">  if (s != NULL) {</a>
<a name="ln1853">    s = (const char *)skipwhite((const char_u *)s);</a>
<a name="ln1854">  }</a>
<a name="ln1855"> </a>
<a name="ln1856">  const char *const expr_start = s;</a>
<a name="ln1857">  if (s == NULL || eval1((char_u **)&amp;s, rettv, true) == FAIL) {</a>
<a name="ln1858">    if (expr_start != NULL &amp;&amp; !aborting()) {</a>
<a name="ln1859">      EMSG2(_(e_invexpr2), expr_start);</a>
<a name="ln1860">    }</a>
<a name="ln1861">    need_clr_eos = FALSE;</a>
<a name="ln1862">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1863">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1864">  } else if (*s != NUL) {</a>
<a name="ln1865">    EMSG(_(e_trailing));</a>
<a name="ln1866">  }</a>
<a name="ln1867">}</a>
<a name="ln1868"> </a>
<a name="ln1869">/*</a>
<a name="ln1870"> * &quot;eventhandler()&quot; function</a>
<a name="ln1871"> */</a>
<a name="ln1872">static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1873">{</a>
<a name="ln1874">  rettv-&gt;vval.v_number = vgetc_busy;</a>
<a name="ln1875">}</a>
<a name="ln1876"> </a>
<a name="ln1877">/*</a>
<a name="ln1878"> * &quot;executable()&quot; function</a>
<a name="ln1879"> */</a>
<a name="ln1880">static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1881">{</a>
<a name="ln1882">  const char *name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1883"> </a>
<a name="ln1884">  // Check in $PATH and also check directly if there is a directory name</a>
<a name="ln1885">  rettv-&gt;vval.v_number = os_can_exe(name, NULL, true);</a>
<a name="ln1886">}</a>
<a name="ln1887"> </a>
<a name="ln1888">typedef struct {</a>
<a name="ln1889">  const list_T *const l;</a>
<a name="ln1890">  const listitem_T *li;</a>
<a name="ln1891">} GetListLineCookie;</a>
<a name="ln1892"> </a>
<a name="ln1893">static char_u *get_list_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln1894">{</a>
<a name="ln1895">  GetListLineCookie *const p = (GetListLineCookie *)cookie;</a>
<a name="ln1896"> </a>
<a name="ln1897">  const listitem_T *const item = p-&gt;li;</a>
<a name="ln1898">  if (item == NULL) {</a>
<a name="ln1899">    return NULL;</a>
<a name="ln1900">  }</a>
<a name="ln1901">  char buf[NUMBUFLEN];</a>
<a name="ln1902">  const char *const s = tv_get_string_buf_chk(TV_LIST_ITEM_TV(item), buf);</a>
<a name="ln1903">  p-&gt;li = TV_LIST_ITEM_NEXT(p-&gt;l, item);</a>
<a name="ln1904">  return (char_u *)(s == NULL ? NULL : xstrdup(s));</a>
<a name="ln1905">}</a>
<a name="ln1906"> </a>
<a name="ln1907">// &quot;execute(command)&quot; function</a>
<a name="ln1908">static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1909">{</a>
<a name="ln1910">  const int save_msg_silent = msg_silent;</a>
<a name="ln1911">  const int save_emsg_silent = emsg_silent;</a>
<a name="ln1912">  const bool save_emsg_noredir = emsg_noredir;</a>
<a name="ln1913">  const bool save_redir_off = redir_off;</a>
<a name="ln1914">  garray_T *const save_capture_ga = capture_ga;</a>
<a name="ln1915">  const int save_msg_col = msg_col;</a>
<a name="ln1916">  bool echo_output = false;</a>
<a name="ln1917"> </a>
<a name="ln1918">  if (check_secure()) {</a>
<a name="ln1919">    return;</a>
<a name="ln1920">  }</a>
<a name="ln1921"> </a>
<a name="ln1922">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1923">    char buf[NUMBUFLEN];</a>
<a name="ln1924">    const char *const s = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1925"> </a>
<a name="ln1926">    if (s == NULL) {</a>
<a name="ln1927">      return;</a>
<a name="ln1928">    }</a>
<a name="ln1929">    if (*s == NUL) {</a>
<a name="ln1930">      echo_output = true;</a>
<a name="ln1931">    }</a>
<a name="ln1932">    if (strncmp(s, &quot;silent&quot;, 6) == 0) {</a>
<a name="ln1933">      msg_silent++;</a>
<a name="ln1934">    }</a>
<a name="ln1935">    if (strcmp(s, &quot;silent!&quot;) == 0) {</a>
<a name="ln1936">      emsg_silent = true;</a>
<a name="ln1937">      emsg_noredir = true;</a>
<a name="ln1938">    }</a>
<a name="ln1939">  } else {</a>
<a name="ln1940">    msg_silent++;</a>
<a name="ln1941">  }</a>
<a name="ln1942"> </a>
<a name="ln1943">  garray_T capture_local;</a>
<a name="ln1944">  ga_init(&amp;capture_local, (int)sizeof(char), 80);</a>
<a name="ln1945">  capture_ga = &amp;capture_local;</a>
<a name="ln1946">  redir_off = false;</a>
<a name="ln1947">  if (!echo_output) {</a>
<a name="ln1948">    msg_col = 0;  // prevent leading spaces</a>
<a name="ln1949">  }</a>
<a name="ln1950"> </a>
<a name="ln1951">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1952">    do_cmdline_cmd(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1953">  } else if (argvars[0].vval.v_list != NULL) {</a>
<a name="ln1954">    list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln1955">    tv_list_ref(list);</a>
<a name="ln1956">    GetListLineCookie cookie = {</a>
<a name="ln1957">      .l = list,</a>
<a name="ln1958">      .li = tv_list_first(list),</a>
<a name="ln1959">    };</a>
<a name="ln1960">    do_cmdline(NULL, get_list_line, (void *)&amp;cookie,</a>
<a name="ln1961">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);</a>
<a name="ln1962">    tv_list_unref(list);</a>
<a name="ln1963">  }</a>
<a name="ln1964">  msg_silent = save_msg_silent;</a>
<a name="ln1965">  emsg_silent = save_emsg_silent;</a>
<a name="ln1966">  emsg_noredir = save_emsg_noredir;</a>
<a name="ln1967">  redir_off = save_redir_off;</a>
<a name="ln1968">  // &quot;silent reg&quot; or &quot;silent echo x&quot; leaves msg_col somewhere in the line.</a>
<a name="ln1969">  if (echo_output) {</a>
<a name="ln1970">    // When not working silently: put it in column zero.  A following</a>
<a name="ln1971">    // &quot;echon&quot; will overwrite the message, unavoidably.</a>
<a name="ln1972">    msg_col = 0;</a>
<a name="ln1973">  } else {</a>
<a name="ln1974">    // When working silently: Put it back where it was, since nothing</a>
<a name="ln1975">    // should have been written.</a>
<a name="ln1976">    msg_col = save_msg_col;</a>
<a name="ln1977">  }</a>
<a name="ln1978"> </a>
<a name="ln1979">  ga_append(capture_ga, NUL);</a>
<a name="ln1980">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1981">  rettv-&gt;vval.v_string = capture_ga-&gt;ga_data;</a>
<a name="ln1982"> </a>
<a name="ln1983">  capture_ga = save_capture_ga;</a>
<a name="ln1984">}</a>
<a name="ln1985"> </a>
<a name="ln1986">/// &quot;exepath()&quot; function</a>
<a name="ln1987">static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1988">{</a>
<a name="ln1989">  const char *arg = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1990">  char *path = NULL;</a>
<a name="ln1991"> </a>
<a name="ln1992">  (void)os_can_exe(arg, &amp;path, true);</a>
<a name="ln1993"> </a>
<a name="ln1994">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1995">  rettv-&gt;vval.v_string = (char_u *)path;</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/*</a>
<a name="ln1999"> * &quot;exists()&quot; function</a>
<a name="ln2000"> */</a>
<a name="ln2001">static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2002">{</a>
<a name="ln2003">  int n = false;</a>
<a name="ln2004">  int len = 0;</a>
<a name="ln2005"> </a>
<a name="ln2006">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2007">  if (*p == '$') {  // Environment variable.</a>
<a name="ln2008">    // First try &quot;normal&quot; environment variables (fast).</a>
<a name="ln2009">    if (os_env_exists(p + 1)) {</a>
<a name="ln2010">      n = true;</a>
<a name="ln2011">    } else {</a>
<a name="ln2012">      // Try expanding things like $VIM and ${HOME}.</a>
<a name="ln2013">      char_u *const exp = expand_env_save((char_u *)p);</a>
<a name="ln2014">      if (exp != NULL &amp;&amp; *exp != '$') {</a>
<a name="ln2015">        n = true;</a>
<a name="ln2016">      }</a>
<a name="ln2017">      xfree(exp);</a>
<a name="ln2018">    }</a>
<a name="ln2019">  } else if (*p == '&amp;' || *p == '+') {  // Option.</a>
<a name="ln2020">    n = (get_option_tv(&amp;p, NULL, true) == OK);</a>
<a name="ln2021">    if (*skipwhite((const char_u *)p) != NUL) {</a>
<a name="ln2022">      n = false;  // Trailing garbage.</a>
<a name="ln2023">    }</a>
<a name="ln2024">  } else if (*p == '*') {  // Internal or user defined function.</a>
<a name="ln2025">    n = function_exists(p + 1, false);</a>
<a name="ln2026">  } else if (*p == ':') {</a>
<a name="ln2027">    n = cmd_exists(p + 1);</a>
<a name="ln2028">  } else if (*p == '#') {</a>
<a name="ln2029">    if (p[1] == '#') {</a>
<a name="ln2030">      n = autocmd_supported(p + 2);</a>
<a name="ln2031">    } else {</a>
<a name="ln2032">      n = au_exists(p + 1);</a>
<a name="ln2033">    }</a>
<a name="ln2034">  } else {  // Internal variable.</a>
<a name="ln2035">    typval_T tv;</a>
<a name="ln2036"> </a>
<a name="ln2037">    // get_name_len() takes care of expanding curly braces</a>
<a name="ln2038">    const char *name = p;</a>
<a name="ln2039">    char *tofree;</a>
<a name="ln2040">    len = get_name_len((const char **)&amp;p, &amp;tofree, true, false);</a>
<a name="ln2041">    if (len &gt; 0) {</a>
<a name="ln2042">      if (tofree != NULL) {</a>
<a name="ln2043">        name = tofree;</a>
<a name="ln2044">      }</a>
<a name="ln2045">      n = (get_var_tv(name, len, &amp;tv, NULL, false, true) == OK);</a>
<a name="ln2046">      if (n) {</a>
<a name="ln2047">        // Handle d.key, l[idx], f(expr).</a>
<a name="ln2048">        n = (handle_subscript(&amp;p, &amp;tv, true, false) == OK);</a>
<a name="ln2049">        if (n) {</a>
<a name="ln2050">          tv_clear(&amp;tv);</a>
<a name="ln2051">        }</a>
<a name="ln2052">      }</a>
<a name="ln2053">    }</a>
<a name="ln2054">    if (*p != NUL)</a>
<a name="ln2055">      n = FALSE;</a>
<a name="ln2056"> </a>
<a name="ln2057">    xfree(tofree);</a>
<a name="ln2058">  }</a>
<a name="ln2059"> </a>
<a name="ln2060">  rettv-&gt;vval.v_number = n;</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">/*</a>
<a name="ln2064"> * &quot;expand()&quot; function</a>
<a name="ln2065"> */</a>
<a name="ln2066">static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2067">{</a>
<a name="ln2068">  size_t len;</a>
<a name="ln2069">  char_u      *errormsg;</a>
<a name="ln2070">  int options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;</a>
<a name="ln2071">  expand_T xpc;</a>
<a name="ln2072">  bool error = false;</a>
<a name="ln2073">  char_u *result;</a>
<a name="ln2074">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2075">  char_u *p_csl_save = p_csl;</a>
<a name="ln2076"> </a>
<a name="ln2077">  // avoid using 'completeslash' here</a>
<a name="ln2078">  p_csl = empty_option;</a>
<a name="ln2079">#endif</a>
<a name="ln2080"> </a>
<a name="ln2081">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2082">  if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2083">      &amp;&amp; argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2084">      &amp;&amp; tv_get_number_chk(&amp;argvars[2], &amp;error)</a>
<a name="ln2085">      &amp;&amp; !error) {</a>
<a name="ln2086">    tv_list_set_ret(rettv, NULL);</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2090">  if (*s == '%' || *s == '#' || *s == '&lt;') {</a>
<a name="ln2091">    emsg_off++;</a>
<a name="ln2092">    result = eval_vars((char_u *)s, (char_u *)s, &amp;len, NULL, &amp;errormsg, NULL);</a>
<a name="ln2093">    emsg_off--;</a>
<a name="ln2094">    if (rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2095">      tv_list_alloc_ret(rettv, (result != NULL));</a>
<a name="ln2096">      if (result != NULL) {</a>
<a name="ln2097">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)result, -1);</a>
<a name="ln2098">      }</a>
<a name="ln2099">      XFREE_CLEAR(result);</a>
<a name="ln2100">    } else {</a>
<a name="ln2101">      rettv-&gt;vval.v_string = result;</a>
<a name="ln2102">    }</a>
<a name="ln2103">  } else {</a>
<a name="ln2104">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln2105">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln2106">    if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2107">        &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln2108">      options |= WILD_KEEP_ALL;</a>
<a name="ln2109">    }</a>
<a name="ln2110">    if (!error) {</a>
<a name="ln2111">      ExpandInit(&amp;xpc);</a>
<a name="ln2112">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln2113">      if (p_wic) {</a>
<a name="ln2114">        options += WILD_ICASE;</a>
<a name="ln2115">      }</a>
<a name="ln2116">      if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln2117">        rettv-&gt;vval.v_string = ExpandOne(&amp;xpc, (char_u *)s, NULL, options,</a>
<a name="ln2118">                                         WILD_ALL);</a>
<a name="ln2119">      } else {</a>
<a name="ln2120">        ExpandOne(&amp;xpc, (char_u *)s, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln2121">        tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln2122">        for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln2123">          tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2124">                                (const char *)xpc.xp_files[i], -1);</a>
<a name="ln2125">        }</a>
<a name="ln2126">        ExpandCleanup(&amp;xpc);</a>
<a name="ln2127">      }</a>
<a name="ln2128">    } else {</a>
<a name="ln2129">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2130">    }</a>
<a name="ln2131">  }</a>
<a name="ln2132">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2133">  p_csl = p_csl_save;</a>
<a name="ln2134">#endif</a>
<a name="ln2135">}</a>
<a name="ln2136"> </a>
<a name="ln2137"> </a>
<a name="ln2138">/// &quot;menu_get(path [, modes])&quot; function</a>
<a name="ln2139">static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2140">{</a>
<a name="ln2141">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2142">  int modes = MENU_ALL_MODES;</a>
<a name="ln2143">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2144">    const char_u *const strmodes = (char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln2145">    modes = get_menu_cmd_modes(strmodes, false, NULL, NULL);</a>
<a name="ln2146">  }</a>
<a name="ln2147">  menu_get((char_u *)tv_get_string(&amp;argvars[0]), modes, rettv-&gt;vval.v_list);</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">// &quot;expandcmd()&quot; function</a>
<a name="ln2151">// Expand all the special characters in a command string.</a>
<a name="ln2152">static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2153">{</a>
<a name="ln2154">  char_u *errormsg = NULL;</a>
<a name="ln2155"> </a>
<a name="ln2156">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2157">  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2158"> </a>
<a name="ln2159">  exarg_T eap = {</a>
<a name="ln2160">    .cmd = cmdstr,</a>
<a name="ln2161">    .arg = cmdstr,</a>
<a name="ln2162">    .usefilter = false,</a>
<a name="ln2163">    .nextcmd = NULL,</a>
<a name="ln2164">    .cmdidx = CMD_USER,</a>
<a name="ln2165">  };</a>
<a name="ln2166">  eap.argt |= NOSPC;</a>
<a name="ln2167"> </a>
<a name="ln2168">  expand_filename(&amp;eap, &amp;cmdstr, &amp;errormsg);</a>
<a name="ln2169">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln2170">    EMSG(errormsg);</a>
<a name="ln2171">  }</a>
<a name="ln2172">  rettv-&gt;vval.v_string = cmdstr;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175"> </a>
<a name="ln2176">/// &quot;flatten(list[, {maxdepth}])&quot; function</a>
<a name="ln2177">static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2178">{</a>
<a name="ln2179">  list_T *list;</a>
<a name="ln2180">  long maxdepth;</a>
<a name="ln2181">  bool error = false;</a>
<a name="ln2182"> </a>
<a name="ln2183">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2184">    EMSG2(_(e_listarg), &quot;flatten()&quot;);</a>
<a name="ln2185">    return;</a>
<a name="ln2186">  }</a>
<a name="ln2187"> </a>
<a name="ln2188">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln2189">    maxdepth = 999999;</a>
<a name="ln2190">  } else {</a>
<a name="ln2191">    maxdepth = (long)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2192">    if (error) {</a>
<a name="ln2193">      return;</a>
<a name="ln2194">    }</a>
<a name="ln2195">    if (maxdepth &lt; 0) {</a>
<a name="ln2196">      EMSG(_(&quot;E900: maxdepth must be non-negative number&quot;));</a>
<a name="ln2197">      return;</a>
<a name="ln2198">    }</a>
<a name="ln2199">  }</a>
<a name="ln2200"> </a>
<a name="ln2201">  list = argvars[0].vval.v_list;</a>
<a name="ln2202">  if (list != NULL</a>
<a name="ln2203">      &amp;&amp; !tv_check_lock(tv_list_locked(list),</a>
<a name="ln2204">                        N_(&quot;flatten() argument&quot;),</a>
<a name="ln2205">                        TV_TRANSLATE)</a>
<a name="ln2206">      &amp;&amp; tv_list_flatten(list, maxdepth) == OK) {</a>
<a name="ln2207">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2208">  }</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">/*</a>
<a name="ln2212"> * &quot;extend(list, list [, idx])&quot; function</a>
<a name="ln2213"> * &quot;extend(dict, dict [, action])&quot; function</a>
<a name="ln2214"> */</a>
<a name="ln2215">static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2216">{</a>
<a name="ln2217">  const char *const arg_errmsg = N_(&quot;extend() argument&quot;);</a>
<a name="ln2218"> </a>
<a name="ln2219">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_LIST) {</a>
<a name="ln2220">    long before;</a>
<a name="ln2221">    bool error = false;</a>
<a name="ln2222"> </a>
<a name="ln2223">    list_T *const l1 = argvars[0].vval.v_list;</a>
<a name="ln2224">    list_T *const l2 = argvars[1].vval.v_list;</a>
<a name="ln2225">    if (!tv_check_lock(tv_list_locked(l1), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2226">      listitem_T *item;</a>
<a name="ln2227">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2228">        before = (long)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2229">        if (error) {</a>
<a name="ln2230">          return;  // Type error; errmsg already given.</a>
<a name="ln2231">        }</a>
<a name="ln2232"> </a>
<a name="ln2233">        if (before == tv_list_len(l1)) {</a>
<a name="ln2234">          item = NULL;</a>
<a name="ln2235">        } else {</a>
<a name="ln2236">          item = tv_list_find(l1, before);</a>
<a name="ln2237">          if (item == NULL) {</a>
<a name="ln2238">            EMSGN(_(e_listidx), before);</a>
<a name="ln2239">            return;</a>
<a name="ln2240">          }</a>
<a name="ln2241">        }</a>
<a name="ln2242">      } else {</a>
<a name="ln2243">        item = NULL;</a>
<a name="ln2244">      }</a>
<a name="ln2245">      tv_list_extend(l1, l2, item);</a>
<a name="ln2246"> </a>
<a name="ln2247">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2248">    }</a>
<a name="ln2249">  } else if (argvars[0].v_type == VAR_DICT &amp;&amp; argvars[1].v_type ==</a>
<a name="ln2250">             VAR_DICT) {</a>
<a name="ln2251">    dict_T *const d1 = argvars[0].vval.v_dict;</a>
<a name="ln2252">    dict_T *const d2 = argvars[1].vval.v_dict;</a>
<a name="ln2253">    if (d1 == NULL) {</a>
<a name="ln2254">      const bool locked = tv_check_lock(VAR_FIXED, arg_errmsg, TV_TRANSLATE);</a>
<a name="ln2255">      (void)locked;</a>
<a name="ln2256">      assert(locked == true);</a>
<a name="ln2257">    } else if (d2 == NULL) {</a>
<a name="ln2258">      // Do nothing</a>
<a name="ln2259">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2260">    } else if (!tv_check_lock(d1-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2261">      const char *action = &quot;force&quot;;</a>
<a name="ln2262">      // Check the third argument.</a>
<a name="ln2263">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2264">        const char *const av[] = { &quot;keep&quot;, &quot;force&quot;, &quot;error&quot; };</a>
<a name="ln2265"> </a>
<a name="ln2266">        action = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln2267">        if (action == NULL) {</a>
<a name="ln2268">          return;  // Type error; error message already given.</a>
<a name="ln2269">        }</a>
<a name="ln2270">        size_t i;</a>
<a name="ln2271">        for (i = 0; i &lt; ARRAY_SIZE(av); i++) {</a>
<a name="ln2272">          if (strcmp(action, av[i]) == 0) {</a>
<a name="ln2273">            break;</a>
<a name="ln2274">          }</a>
<a name="ln2275">        }</a>
<a name="ln2276">        if (i == 3) {</a>
<a name="ln2277">          EMSG2(_(e_invarg2), action);</a>
<a name="ln2278">          return;</a>
<a name="ln2279">        }</a>
<a name="ln2280">      }</a>
<a name="ln2281"> </a>
<a name="ln2282">      tv_dict_extend(d1, d2, action);</a>
<a name="ln2283"> </a>
<a name="ln2284">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2285">    }</a>
<a name="ln2286">  } else {</a>
<a name="ln2287">    EMSG2(_(e_listdictarg), &quot;extend()&quot;);</a>
<a name="ln2288">  }</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">/*</a>
<a name="ln2292"> * &quot;feedkeys()&quot; function</a>
<a name="ln2293"> */</a>
<a name="ln2294">static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2295">{</a>
<a name="ln2296">  // This is not allowed in the sandbox.  If the commands would still be</a>
<a name="ln2297">  // executed in the sandbox it would be OK, but it probably happens later,</a>
<a name="ln2298">  // when &quot;sandbox&quot; is no longer set.</a>
<a name="ln2299">  if (check_secure()) {</a>
<a name="ln2300">    return;</a>
<a name="ln2301">  }</a>
<a name="ln2302"> </a>
<a name="ln2303">  const char *const keys = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2304">  char nbuf[NUMBUFLEN];</a>
<a name="ln2305">  const char *flags = NULL;</a>
<a name="ln2306">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2307">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln2308">  }</a>
<a name="ln2309"> </a>
<a name="ln2310">  nvim_feedkeys(cstr_as_string((char *)keys),</a>
<a name="ln2311">                cstr_as_string((char *)flags), true);</a>
<a name="ln2312">}</a>
<a name="ln2313"> </a>
<a name="ln2314">/// &quot;filereadable()&quot; function</a>
<a name="ln2315">static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2316">{</a>
<a name="ln2317">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2318">  rettv-&gt;vval.v_number =</a>
<a name="ln2319">    (*p &amp;&amp; !os_isdir((const char_u *)p) &amp;&amp; os_file_is_readable(p));</a>
<a name="ln2320">}</a>
<a name="ln2321"> </a>
<a name="ln2322">/*</a>
<a name="ln2323"> * Return 0 for not writable, 1 for writable file, 2 for a dir which we have</a>
<a name="ln2324"> * rights to write into.</a>
<a name="ln2325"> */</a>
<a name="ln2326">static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2327">{</a>
<a name="ln2328">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2329">  rettv-&gt;vval.v_number = os_file_is_writable(filename);</a>
<a name="ln2330">}</a>
<a name="ln2331"> </a>
<a name="ln2332"> </a>
<a name="ln2333">static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)</a>
<a name="ln2334">{</a>
<a name="ln2335">  char_u *fresult = NULL;</a>
<a name="ln2336">  char_u *path = *curbuf-&gt;b_p_path == NUL ? p_path : curbuf-&gt;b_p_path;</a>
<a name="ln2337">  int count = 1;</a>
<a name="ln2338">  bool first = true;</a>
<a name="ln2339">  bool error = false;</a>
<a name="ln2340"> </a>
<a name="ln2341">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2342">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2343"> </a>
<a name="ln2344">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2345"> </a>
<a name="ln2346">  char pathbuf[NUMBUFLEN];</a>
<a name="ln2347">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2348">    const char *p = tv_get_string_buf_chk(&amp;argvars[1], pathbuf);</a>
<a name="ln2349">    if (p == NULL) {</a>
<a name="ln2350">      error = true;</a>
<a name="ln2351">    } else {</a>
<a name="ln2352">      if (*p != NUL) {</a>
<a name="ln2353">        path = (char_u *)p;</a>
<a name="ln2354">      }</a>
<a name="ln2355"> </a>
<a name="ln2356">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2357">        count = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2358">      }</a>
<a name="ln2359">    }</a>
<a name="ln2360">  }</a>
<a name="ln2361"> </a>
<a name="ln2362">  if (count &lt; 0) {</a>
<a name="ln2363">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2364">  }</a>
<a name="ln2365"> </a>
<a name="ln2366">  if (*fname != NUL &amp;&amp; !error) {</a>
<a name="ln2367">    do {</a>
<a name="ln2368">      if (rettv-&gt;v_type == VAR_STRING || rettv-&gt;v_type == VAR_LIST)</a>
<a name="ln2369">        xfree(fresult);</a>
<a name="ln2370">      fresult = find_file_in_path_option(first ? (char_u *)fname : NULL,</a>
<a name="ln2371">                                         first ? strlen(fname) : 0,</a>
<a name="ln2372">                                         0, first, path,</a>
<a name="ln2373">                                         find_what, curbuf-&gt;b_ffname,</a>
<a name="ln2374">                                         (find_what == FINDFILE_DIR</a>
<a name="ln2375">                                          ? (char_u *)&quot;&quot;</a>
<a name="ln2376">                                          : curbuf-&gt;b_p_sua));</a>
<a name="ln2377">      first = false;</a>
<a name="ln2378"> </a>
<a name="ln2379">      if (fresult != NULL &amp;&amp; rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2380">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)fresult, -1);</a>
<a name="ln2381">      }</a>
<a name="ln2382">    } while ((rettv-&gt;v_type == VAR_LIST || --count &gt; 0) &amp;&amp; fresult != NULL);</a>
<a name="ln2383">  }</a>
<a name="ln2384"> </a>
<a name="ln2385">  if (rettv-&gt;v_type == VAR_STRING)</a>
<a name="ln2386">    rettv-&gt;vval.v_string = fresult;</a>
<a name="ln2387">}</a>
<a name="ln2388"> </a>
<a name="ln2389"> </a>
<a name="ln2390">/*</a>
<a name="ln2391"> * &quot;filter()&quot; function</a>
<a name="ln2392"> */</a>
<a name="ln2393">static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2394">{</a>
<a name="ln2395">  filter_map(argvars, rettv, FALSE);</a>
<a name="ln2396">}</a>
<a name="ln2397"> </a>
<a name="ln2398">/*</a>
<a name="ln2399"> * &quot;finddir({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2400"> */</a>
<a name="ln2401">static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2402">{</a>
<a name="ln2403">  findfilendir(argvars, rettv, FINDFILE_DIR);</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406">/*</a>
<a name="ln2407"> * &quot;findfile({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2408"> */</a>
<a name="ln2409">static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2410">{</a>
<a name="ln2411">  findfilendir(argvars, rettv, FINDFILE_FILE);</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">/*</a>
<a name="ln2415"> * &quot;float2nr({float})&quot; function</a>
<a name="ln2416"> */</a>
<a name="ln2417">static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2418">{</a>
<a name="ln2419">  float_T f;</a>
<a name="ln2420"> </a>
<a name="ln2421">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln2422">    if (f &lt;= (float_T)-VARNUMBER_MAX + DBL_EPSILON) {</a>
<a name="ln2423">      rettv-&gt;vval.v_number = -VARNUMBER_MAX;</a>
<a name="ln2424">    } else if (f &gt;= (float_T)VARNUMBER_MAX - DBL_EPSILON) {</a>
<a name="ln2425">      rettv-&gt;vval.v_number = VARNUMBER_MAX;</a>
<a name="ln2426">    } else {</a>
<a name="ln2427">      rettv-&gt;vval.v_number = (varnumber_T)f;</a>
<a name="ln2428">    }</a>
<a name="ln2429">  }</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432">/*</a>
<a name="ln2433"> * &quot;fmod()&quot; function</a>
<a name="ln2434"> */</a>
<a name="ln2435">static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2436">{</a>
<a name="ln2437">  float_T fx;</a>
<a name="ln2438">  float_T fy;</a>
<a name="ln2439"> </a>
<a name="ln2440">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2441">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln2442">    rettv-&gt;vval.v_float = fmod(fx, fy);</a>
<a name="ln2443">  } else {</a>
<a name="ln2444">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln2445">  }</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448">/*</a>
<a name="ln2449"> * &quot;fnameescape({string})&quot; function</a>
<a name="ln2450"> */</a>
<a name="ln2451">static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2452">{</a>
<a name="ln2453">  rettv-&gt;vval.v_string = (char_u *)vim_strsave_fnameescape(</a>
<a name="ln2454">      tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2455">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2456">}</a>
<a name="ln2457"> </a>
<a name="ln2458">/*</a>
<a name="ln2459"> * &quot;fnamemodify({fname}, {mods})&quot; function</a>
<a name="ln2460"> */</a>
<a name="ln2461">static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2462">{</a>
<a name="ln2463">  char_u *fbuf = NULL;</a>
<a name="ln2464">  size_t len;</a>
<a name="ln2465">  char buf[NUMBUFLEN];</a>
<a name="ln2466">  const char *fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2467">  const char *const mods = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2468">  if (fname == NULL || mods == NULL) {</a>
<a name="ln2469">    fname = NULL;</a>
<a name="ln2470">  } else {</a>
<a name="ln2471">    len = strlen(fname);</a>
<a name="ln2472">    size_t usedlen = 0;</a>
<a name="ln2473">    (void)modify_fname((char_u *)mods, false, &amp;usedlen,</a>
<a name="ln2474">                       (char_u **)&amp;fname, &amp;fbuf, &amp;len);</a>
<a name="ln2475">  }</a>
<a name="ln2476"> </a>
<a name="ln2477">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2478">  if (fname == NULL) {</a>
<a name="ln2479">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2480">  } else {</a>
<a name="ln2481">    rettv-&gt;vval.v_string = (char_u *)xmemdupz(fname, len);</a>
<a name="ln2482">  }</a>
<a name="ln2483">  xfree(fbuf);</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486"> </a>
<a name="ln2487">/*</a>
<a name="ln2488"> * &quot;foldclosed()&quot; function</a>
<a name="ln2489"> */</a>
<a name="ln2490">static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)</a>
<a name="ln2491">{</a>
<a name="ln2492">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2493">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2494">    linenr_T first;</a>
<a name="ln2495">    linenr_T last;</a>
<a name="ln2496">    if (hasFoldingWin(curwin, lnum, &amp;first, &amp;last, false, NULL)) {</a>
<a name="ln2497">      if (end) {</a>
<a name="ln2498">        rettv-&gt;vval.v_number = (varnumber_T)last;</a>
<a name="ln2499">      } else {</a>
<a name="ln2500">        rettv-&gt;vval.v_number = (varnumber_T)first;</a>
<a name="ln2501">      }</a>
<a name="ln2502">      return;</a>
<a name="ln2503">    }</a>
<a name="ln2504">  }</a>
<a name="ln2505">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/*</a>
<a name="ln2509"> * &quot;foldclosed()&quot; function</a>
<a name="ln2510"> */</a>
<a name="ln2511">static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2512">{</a>
<a name="ln2513">  foldclosed_both(argvars, rettv, FALSE);</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">/*</a>
<a name="ln2517"> * &quot;foldclosedend()&quot; function</a>
<a name="ln2518"> */</a>
<a name="ln2519">static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2520">{</a>
<a name="ln2521">  foldclosed_both(argvars, rettv, TRUE);</a>
<a name="ln2522">}</a>
<a name="ln2523"> </a>
<a name="ln2524">/*</a>
<a name="ln2525"> * &quot;foldlevel()&quot; function</a>
<a name="ln2526"> */</a>
<a name="ln2527">static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2528">{</a>
<a name="ln2529">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2530">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2531">    rettv-&gt;vval.v_number = foldLevel(lnum);</a>
<a name="ln2532">  }</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535">/*</a>
<a name="ln2536"> * &quot;foldtext()&quot; function</a>
<a name="ln2537"> */</a>
<a name="ln2538">static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2539">{</a>
<a name="ln2540">  linenr_T    foldstart;</a>
<a name="ln2541">  linenr_T    foldend;</a>
<a name="ln2542">  char_u      *dashes;</a>
<a name="ln2543">  linenr_T    lnum;</a>
<a name="ln2544">  char_u      *s;</a>
<a name="ln2545">  char_u      *r;</a>
<a name="ln2546">  int         len;</a>
<a name="ln2547">  char        *txt;</a>
<a name="ln2548"> </a>
<a name="ln2549">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2550">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2551"> </a>
<a name="ln2552">  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);</a>
<a name="ln2553">  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);</a>
<a name="ln2554">  dashes = get_vim_var_str(VV_FOLDDASHES);</a>
<a name="ln2555">  if (foldstart &gt; 0 &amp;&amp; foldend &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2556">    // Find first non-empty line in the fold.</a>
<a name="ln2557">    for (lnum = foldstart; lnum &lt; foldend; lnum++) {</a>
<a name="ln2558">      if (!linewhite(lnum)) {</a>
<a name="ln2559">        break;</a>
<a name="ln2560">      }</a>
<a name="ln2561">    }</a>
<a name="ln2562"> </a>
<a name="ln2563">    // Find interesting text in this line.</a>
<a name="ln2564">    s = skipwhite(ml_get(lnum));</a>
<a name="ln2565">    // skip C comment-start</a>
<a name="ln2566">    if (s[0] == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln2567">      s = skipwhite(s + 2);</a>
<a name="ln2568">      if (*skipwhite(s) == NUL &amp;&amp; lnum + 1 &lt; foldend) {</a>
<a name="ln2569">        s = skipwhite(ml_get(lnum + 1));</a>
<a name="ln2570">        if (*s == '*')</a>
<a name="ln2571">          s = skipwhite(s + 1);</a>
<a name="ln2572">      }</a>
<a name="ln2573">    }</a>
<a name="ln2574">    unsigned long count = (unsigned long)(foldend - foldstart + 1);</a>
<a name="ln2575">    txt = NGETTEXT(&quot;+-%s%3ld line: &quot;, &quot;+-%s%3ld lines: &quot;, count);</a>
<a name="ln2576">    r = xmalloc(STRLEN(txt)</a>
<a name="ln2577">                + STRLEN(dashes)  // for %s</a>
<a name="ln2578">                + 20              // for %3ld</a>
<a name="ln2579">                + STRLEN(s));     // concatenated</a>
<a name="ln2580">    sprintf((char *)r, txt, dashes, count);</a>
<a name="ln2581">    len = (int)STRLEN(r);</a>
<a name="ln2582">    STRCAT(r, s);</a>
<a name="ln2583">    // remove 'foldmarker' and 'commentstring'</a>
<a name="ln2584">    foldtext_cleanup(r + len);</a>
<a name="ln2585">    rettv-&gt;vval.v_string = r;</a>
<a name="ln2586">  }</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">/*</a>
<a name="ln2590"> * &quot;foldtextresult(lnum)&quot; function</a>
<a name="ln2591"> */</a>
<a name="ln2592">static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2593">{</a>
<a name="ln2594">  char_u      *text;</a>
<a name="ln2595">  char_u buf[FOLD_TEXT_LEN];</a>
<a name="ln2596">  static bool entered = false;</a>
<a name="ln2597"> </a>
<a name="ln2598">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2599">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2600">  if (entered) {</a>
<a name="ln2601">    return;  // reject recursive use</a>
<a name="ln2602">  }</a>
<a name="ln2603">  entered = true;</a>
<a name="ln2604">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2605">  // Treat illegal types and illegal string values for {lnum} the same.</a>
<a name="ln2606">  if (lnum &lt; 0) {</a>
<a name="ln2607">    lnum = 0;</a>
<a name="ln2608">  }</a>
<a name="ln2609"> </a>
<a name="ln2610">  foldinfo_T info = fold_info(curwin, lnum);</a>
<a name="ln2611">  if (info.fi_lines &gt; 0) {</a>
<a name="ln2612">    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);</a>
<a name="ln2613">    if (text == buf) {</a>
<a name="ln2614">      text = vim_strsave(text);</a>
<a name="ln2615">    }</a>
<a name="ln2616">    rettv-&gt;vval.v_string = text;</a>
<a name="ln2617">  }</a>
<a name="ln2618"> </a>
<a name="ln2619">  entered = false;</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">/*</a>
<a name="ln2623"> * &quot;foreground()&quot; function</a>
<a name="ln2624"> */</a>
<a name="ln2625">static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2626">{</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2630">{</a>
<a name="ln2631">  common_function(argvars, rettv, true, fptr);</a>
<a name="ln2632">}</a>
<a name="ln2633"> </a>
<a name="ln2634">static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2635">{</a>
<a name="ln2636">  common_function(argvars, rettv, false, fptr);</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639">/// &quot;garbagecollect()&quot; function</a>
<a name="ln2640">static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2641">{</a>
<a name="ln2642">  // This is postponed until we are back at the toplevel, because we may be</a>
<a name="ln2643">  // using Lists and Dicts internally.  E.g.: &quot;:echo [garbagecollect()]&quot;.</a>
<a name="ln2644">  want_garbage_collect = true;</a>
<a name="ln2645"> </a>
<a name="ln2646">  if (argvars[0].v_type != VAR_UNKNOWN &amp;&amp; tv_get_number(&amp;argvars[0]) == 1) {</a>
<a name="ln2647">    garbage_collect_at_exit = true;</a>
<a name="ln2648">  }</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">/*</a>
<a name="ln2652"> * &quot;get()&quot; function</a>
<a name="ln2653"> */</a>
<a name="ln2654">static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2655">{</a>
<a name="ln2656">  listitem_T  *li;</a>
<a name="ln2657">  list_T      *l;</a>
<a name="ln2658">  dictitem_T  *di;</a>
<a name="ln2659">  dict_T      *d;</a>
<a name="ln2660">  typval_T    *tv = NULL;</a>
<a name="ln2661">  bool what_is_dict = false;</a>
<a name="ln2662"> </a>
<a name="ln2663">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln2664">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln2665">      bool error = false;</a>
<a name="ln2666"> </a>
<a name="ln2667">      li = tv_list_find(l, tv_get_number_chk(&amp;argvars[1], &amp;error));</a>
<a name="ln2668">      if (!error &amp;&amp; li != NULL) {</a>
<a name="ln2669">        tv = TV_LIST_ITEM_TV(li);</a>
<a name="ln2670">      }</a>
<a name="ln2671">    }</a>
<a name="ln2672">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2673">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln2674">      di = tv_dict_find(d, tv_get_string(&amp;argvars[1]), -1);</a>
<a name="ln2675">      if (di != NULL) {</a>
<a name="ln2676">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln2677">      }</a>
<a name="ln2678">    }</a>
<a name="ln2679">  } else if (tv_is_func(argvars[0])) {</a>
<a name="ln2680">    partial_T *pt;</a>
<a name="ln2681">    partial_T fref_pt;</a>
<a name="ln2682"> </a>
<a name="ln2683">    if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln2684">      pt = argvars[0].vval.v_partial;</a>
<a name="ln2685">    } else {</a>
<a name="ln2686">      memset(&amp;fref_pt, 0, sizeof(fref_pt));</a>
<a name="ln2687">      fref_pt.pt_name = argvars[0].vval.v_string;</a>
<a name="ln2688">      pt = &amp;fref_pt;</a>
<a name="ln2689">    }</a>
<a name="ln2690"> </a>
<a name="ln2691">    if (pt != NULL) {</a>
<a name="ln2692">      const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2693"> </a>
<a name="ln2694">      if (strcmp(what, &quot;func&quot;) == 0 || strcmp(what, &quot;name&quot;) == 0) {</a>
<a name="ln2695">        rettv-&gt;v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);</a>
<a name="ln2696">        const char *const n = (const char *)partial_name(pt);</a>
<a name="ln2697">        assert(n != NULL);</a>
<a name="ln2698">        rettv-&gt;vval.v_string = (char_u *)xstrdup(n);</a>
<a name="ln2699">        if (rettv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2700">          func_ref(rettv-&gt;vval.v_string);</a>
<a name="ln2701">        }</a>
<a name="ln2702">      } else if (strcmp(what, &quot;dict&quot;) == 0) {</a>
<a name="ln2703">        what_is_dict = true;</a>
<a name="ln2704">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln2705">          tv_dict_set_ret(rettv, pt-&gt;pt_dict);</a>
<a name="ln2706">        }</a>
<a name="ln2707">      } else if (strcmp(what, &quot;args&quot;) == 0) {</a>
<a name="ln2708">        rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln2709">        if (tv_list_alloc_ret(rettv, pt-&gt;pt_argc) != NULL) {</a>
<a name="ln2710">          for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln2711">            tv_list_append_tv(rettv-&gt;vval.v_list, &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln2712">          }</a>
<a name="ln2713">        }</a>
<a name="ln2714">      } else {</a>
<a name="ln2715">        EMSG2(_(e_invarg2), what);</a>
<a name="ln2716">      }</a>
<a name="ln2717"> </a>
<a name="ln2718">      // When {what} == &quot;dict&quot; and pt-&gt;pt_dict == NULL, evaluate the</a>
<a name="ln2719">      // third argument</a>
<a name="ln2720">      if (!what_is_dict) {</a>
<a name="ln2721">        return;</a>
<a name="ln2722">      }</a>
<a name="ln2723">    }</a>
<a name="ln2724">  } else {</a>
<a name="ln2725">    EMSG2(_(e_listdictarg), &quot;get()&quot;);</a>
<a name="ln2726">  }</a>
<a name="ln2727"> </a>
<a name="ln2728">  if (tv == NULL) {</a>
<a name="ln2729">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2730">      tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2731">    }</a>
<a name="ln2732">  } else {</a>
<a name="ln2733">    tv_copy(tv, rettv);</a>
<a name="ln2734">  }</a>
<a name="ln2735">}</a>
<a name="ln2736"> </a>
<a name="ln2737">/// &quot;getbufinfo()&quot; function</a>
<a name="ln2738">static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2739">{</a>
<a name="ln2740">  buf_T *argbuf = NULL;</a>
<a name="ln2741">  bool filtered = false;</a>
<a name="ln2742">  bool sel_buflisted = false;</a>
<a name="ln2743">  bool sel_bufloaded = false;</a>
<a name="ln2744">  bool sel_bufmodified = false;</a>
<a name="ln2745"> </a>
<a name="ln2746">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2747"> </a>
<a name="ln2748">  // List of all the buffers or selected buffers</a>
<a name="ln2749">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2750">    dict_T *sel_d = argvars[0].vval.v_dict;</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (sel_d != NULL) {</a>
<a name="ln2753">      dictitem_T *di;</a>
<a name="ln2754"> </a>
<a name="ln2755">      filtered = true;</a>
<a name="ln2756"> </a>
<a name="ln2757">      di = tv_dict_find(sel_d, S_LEN(&quot;buflisted&quot;));</a>
<a name="ln2758">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2759">        sel_buflisted = true;</a>
<a name="ln2760">      }</a>
<a name="ln2761"> </a>
<a name="ln2762">      di = tv_dict_find(sel_d, S_LEN(&quot;bufloaded&quot;));</a>
<a name="ln2763">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2764">        sel_bufloaded = true;</a>
<a name="ln2765">      }</a>
<a name="ln2766">      di = tv_dict_find(sel_d, S_LEN(&quot;bufmodified&quot;));</a>
<a name="ln2767">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2768">        sel_bufmodified = true;</a>
<a name="ln2769">      }</a>
<a name="ln2770">    }</a>
<a name="ln2771">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2772">    // Information about one buffer.  Argument specifies the buffer</a>
<a name="ln2773">    if (tv_check_num(&amp;argvars[0])) {  // issue errmsg if type error</a>
<a name="ln2774">      emsg_off++;</a>
<a name="ln2775">      argbuf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2776">      emsg_off--;</a>
<a name="ln2777">      if (argbuf == NULL) {</a>
<a name="ln2778">        return;</a>
<a name="ln2779">      }</a>
<a name="ln2780">    }</a>
<a name="ln2781">  }</a>
<a name="ln2782"> </a>
<a name="ln2783">  // Return information about all the buffers or a specified buffer</a>
<a name="ln2784">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2785">    if (argbuf != NULL &amp;&amp; argbuf != buf) {</a>
<a name="ln2786">      continue;</a>
<a name="ln2787">    }</a>
<a name="ln2788">    if (filtered &amp;&amp; ((sel_bufloaded &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2789">                     || (sel_buflisted &amp;&amp; !buf-&gt;b_p_bl)</a>
<a name="ln2790">                     || (sel_bufmodified &amp;&amp; !buf-&gt;b_changed))) {</a>
<a name="ln2791">      continue;</a>
<a name="ln2792">    }</a>
<a name="ln2793"> </a>
<a name="ln2794">    dict_T *const d = get_buffer_info(buf);</a>
<a name="ln2795">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln2796">    if (argbuf != NULL) {</a>
<a name="ln2797">      return;</a>
<a name="ln2798">    }</a>
<a name="ln2799">  }</a>
<a name="ln2800">}</a>
<a name="ln2801"> </a>
<a name="ln2802">/*</a>
<a name="ln2803"> * Get line or list of lines from buffer &quot;buf&quot; into &quot;rettv&quot;.</a>
<a name="ln2804"> * Return a range (from start to end) of lines in rettv from the specified</a>
<a name="ln2805"> * buffer.</a>
<a name="ln2806"> * If 'retlist' is TRUE, then the lines are returned as a Vim List.</a>
<a name="ln2807"> */</a>
<a name="ln2808">static void get_buffer_lines(buf_T *buf,</a>
<a name="ln2809">                             linenr_T start,</a>
<a name="ln2810">                             linenr_T end,</a>
<a name="ln2811">                             int retlist,</a>
<a name="ln2812">                             typval_T *rettv)</a>
<a name="ln2813">{</a>
<a name="ln2814">  rettv-&gt;v_type = (retlist ? VAR_LIST : VAR_STRING);</a>
<a name="ln2815">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2816"> </a>
<a name="ln2817">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL || start &lt; 0 || end &lt; start) {</a>
<a name="ln2818">    if (retlist) {</a>
<a name="ln2819">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln2820">    }</a>
<a name="ln2821">    return;</a>
<a name="ln2822">  }</a>
<a name="ln2823"> </a>
<a name="ln2824">  if (retlist) {</a>
<a name="ln2825">    if (start &lt; 1) {</a>
<a name="ln2826">      start = 1;</a>
<a name="ln2827">    }</a>
<a name="ln2828">    if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2829">      end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2830">    }</a>
<a name="ln2831">    tv_list_alloc_ret(rettv, end - start + 1);</a>
<a name="ln2832">    while (start &lt;= end) {</a>
<a name="ln2833">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2834">                            (const char *)ml_get_buf(buf, start++, false), -1);</a>
<a name="ln2835">    }</a>
<a name="ln2836">  } else {</a>
<a name="ln2837">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2838">    rettv-&gt;vval.v_string = ((start &gt;= 1 &amp;&amp; start &lt;= buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2839">                            ? vim_strsave(ml_get_buf(buf, start, false))</a>
<a name="ln2840">                            : NULL);</a>
<a name="ln2841">  }</a>
<a name="ln2842">}</a>
<a name="ln2843"> </a>
<a name="ln2844">/*</a>
<a name="ln2845"> * &quot;getbufline()&quot; function</a>
<a name="ln2846"> */</a>
<a name="ln2847">static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2848">{</a>
<a name="ln2849">  buf_T *buf = NULL;</a>
<a name="ln2850"> </a>
<a name="ln2851">  if (tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2852">    emsg_off++;</a>
<a name="ln2853">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2854">    emsg_off--;</a>
<a name="ln2855">  }</a>
<a name="ln2856"> </a>
<a name="ln2857">  const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln2858">  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN</a>
<a name="ln2859">                        ? lnum</a>
<a name="ln2860">                        : tv_get_lnum_buf(&amp;argvars[2], buf));</a>
<a name="ln2861"> </a>
<a name="ln2862">  get_buffer_lines(buf, lnum, end, true, rettv);</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865">/*</a>
<a name="ln2866"> * &quot;getbufvar()&quot; function</a>
<a name="ln2867"> */</a>
<a name="ln2868">static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2869">{</a>
<a name="ln2870">  bool done = false;</a>
<a name="ln2871"> </a>
<a name="ln2872">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2873">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2874"> </a>
<a name="ln2875">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2876">    goto f_getbufvar_end;</a>
<a name="ln2877">  }</a>
<a name="ln2878"> </a>
<a name="ln2879">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2880">  emsg_off++;</a>
<a name="ln2881">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2882"> </a>
<a name="ln2883">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln2884">    if (*varname == '&amp;') {  // buffer-local-option</a>
<a name="ln2885">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln2886"> </a>
<a name="ln2887">      // set curbuf to be our buf, temporarily</a>
<a name="ln2888">      curbuf = buf;</a>
<a name="ln2889"> </a>
<a name="ln2890">      if (varname[1] == NUL) {</a>
<a name="ln2891">        // get all buffer-local options in a dict</a>
<a name="ln2892">        dict_T *opts = get_winbuf_options(true);</a>
<a name="ln2893"> </a>
<a name="ln2894">        if (opts != NULL) {</a>
<a name="ln2895">          tv_dict_set_ret(rettv, opts);</a>
<a name="ln2896">          done = true;</a>
<a name="ln2897">        }</a>
<a name="ln2898">      } else if (get_option_tv(&amp;varname, rettv, true) == OK) {</a>
<a name="ln2899">        // buffer-local-option</a>
<a name="ln2900">        done = true;</a>
<a name="ln2901">      }</a>
<a name="ln2902"> </a>
<a name="ln2903">      // restore previous notion of curbuf</a>
<a name="ln2904">      curbuf = save_curbuf;</a>
<a name="ln2905">    } else {</a>
<a name="ln2906">      // Look up the variable.</a>
<a name="ln2907">      // Let getbufvar({nr}, &quot;&quot;) return the &quot;b:&quot; dictionary.</a>
<a name="ln2908">      dictitem_T *const v = *varname == NUL</a>
<a name="ln2909">        ? (dictitem_T *)&amp;buf-&gt;b_bufvar</a>
<a name="ln2910">        : find_var_in_ht(&amp;buf-&gt;b_vars-&gt;dv_hashtab, 'b',</a>
<a name="ln2911">                         varname, strlen(varname), false);</a>
<a name="ln2912">      if (v != NULL) {</a>
<a name="ln2913">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln2914">        done = true;</a>
<a name="ln2915">      }</a>
<a name="ln2916">    }</a>
<a name="ln2917">  }</a>
<a name="ln2918">  emsg_off--;</a>
<a name="ln2919"> </a>
<a name="ln2920">f_getbufvar_end:</a>
<a name="ln2921">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2922">    // use the default value</a>
<a name="ln2923">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2924">  }</a>
<a name="ln2925">}</a>
<a name="ln2926"> </a>
<a name="ln2927">// &quot;getchangelist()&quot; function</a>
<a name="ln2928">static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2929">{</a>
<a name="ln2930">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln2931">  vim_ignored = tv_get_number(&amp;argvars[0]);  // issue errmsg if type error</a>
<a name="ln2932">  emsg_off++;</a>
<a name="ln2933">  const buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2934">  emsg_off--;</a>
<a name="ln2935">  if (buf == NULL) {</a>
<a name="ln2936">    return;</a>
<a name="ln2937">  }</a>
<a name="ln2938"> </a>
<a name="ln2939">  list_T *const l = tv_list_alloc(buf-&gt;b_changelistlen);</a>
<a name="ln2940">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln2941">  // The current window change list index tracks only the position in the</a>
<a name="ln2942">  // current buffer change list. For other buffers, use the change list</a>
<a name="ln2943">  // length as the current index.</a>
<a name="ln2944">  tv_list_append_number(rettv-&gt;vval.v_list,</a>
<a name="ln2945">                        (buf == curwin-&gt;w_buffer)</a>
<a name="ln2946">                        ? curwin-&gt;w_changelistidx</a>
<a name="ln2947">                        : buf-&gt;b_changelistlen);</a>
<a name="ln2948"> </a>
<a name="ln2949">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln2950">    if (buf-&gt;b_changelist[i].mark.lnum == 0) {</a>
<a name="ln2951">      continue;</a>
<a name="ln2952">    }</a>
<a name="ln2953">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln2954">    tv_list_append_dict(l, d);</a>
<a name="ln2955">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), buf-&gt;b_changelist[i].mark.lnum);</a>
<a name="ln2956">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), buf-&gt;b_changelist[i].mark.col);</a>
<a name="ln2957">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), buf-&gt;b_changelist[i].mark.coladd);</a>
<a name="ln2958">  }</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">/*</a>
<a name="ln2962"> * &quot;getchar()&quot; function</a>
<a name="ln2963"> */</a>
<a name="ln2964">static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2965">{</a>
<a name="ln2966">  varnumber_T n;</a>
<a name="ln2967">  bool error = false;</a>
<a name="ln2968"> </a>
<a name="ln2969">  no_mapping++;</a>
<a name="ln2970">  for (;; ) {</a>
<a name="ln2971">    // Position the cursor.  Needed after a message that ends in a space,</a>
<a name="ln2972">    // or if event processing caused a redraw.</a>
<a name="ln2973">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln2974"> </a>
<a name="ln2975">    if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln2976">      // getchar(): blocking wait.</a>
<a name="ln2977">      if (!(char_avail() || using_script() || input_available())) {</a>
<a name="ln2978">        (void)os_inchar(NULL, 0, -1, 0, main_loop.events);</a>
<a name="ln2979">        if (!multiqueue_empty(main_loop.events)) {</a>
<a name="ln2980">          multiqueue_process_events(main_loop.events);</a>
<a name="ln2981">          continue;</a>
<a name="ln2982">        }</a>
<a name="ln2983">      }</a>
<a name="ln2984">      n = safe_vgetc();</a>
<a name="ln2985">    } else if (tv_get_number_chk(&amp;argvars[0], &amp;error) == 1) {</a>
<a name="ln2986">      // getchar(1): only check if char avail</a>
<a name="ln2987">      n = vpeekc_any();</a>
<a name="ln2988">    } else if (error || vpeekc_any() == NUL) {</a>
<a name="ln2989">      // illegal argument or getchar(0) and no char avail: return zero</a>
<a name="ln2990">      n = 0;</a>
<a name="ln2991">    } else {</a>
<a name="ln2992">      // getchar(0) and char avail: return char</a>
<a name="ln2993">      n = safe_vgetc();</a>
<a name="ln2994">    }</a>
<a name="ln2995"> </a>
<a name="ln2996">    if (n == K_IGNORE) {</a>
<a name="ln2997">      continue;</a>
<a name="ln2998">    }</a>
<a name="ln2999">    break;</a>
<a name="ln3000">  }</a>
<a name="ln3001">  no_mapping--;</a>
<a name="ln3002"> </a>
<a name="ln3003">  set_vim_var_nr(VV_MOUSE_WIN, 0);</a>
<a name="ln3004">  set_vim_var_nr(VV_MOUSE_WINID, 0);</a>
<a name="ln3005">  set_vim_var_nr(VV_MOUSE_LNUM, 0);</a>
<a name="ln3006">  set_vim_var_nr(VV_MOUSE_COL, 0);</a>
<a name="ln3007"> </a>
<a name="ln3008">  rettv-&gt;vval.v_number = n;</a>
<a name="ln3009">  if (IS_SPECIAL(n) || mod_mask != 0) {</a>
<a name="ln3010">    char_u temp[10];                // modifier: 3, mbyte-char: 6, NUL: 1</a>
<a name="ln3011">    int i = 0;</a>
<a name="ln3012"> </a>
<a name="ln3013">    // Turn a special key into three bytes, plus modifier.</a>
<a name="ln3014">    if (mod_mask != 0) {</a>
<a name="ln3015">      temp[i++] = K_SPECIAL;</a>
<a name="ln3016">      temp[i++] = KS_MODIFIER;</a>
<a name="ln3017">      temp[i++] = mod_mask;</a>
<a name="ln3018">    }</a>
<a name="ln3019">    if (IS_SPECIAL(n)) {</a>
<a name="ln3020">      temp[i++] = K_SPECIAL;</a>
<a name="ln3021">      temp[i++] = K_SECOND(n);</a>
<a name="ln3022">      temp[i++] = K_THIRD(n);</a>
<a name="ln3023">    } else {</a>
<a name="ln3024">      i += utf_char2bytes(n, temp + i);</a>
<a name="ln3025">    }</a>
<a name="ln3026">    temp[i++] = NUL;</a>
<a name="ln3027">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3028">    rettv-&gt;vval.v_string = vim_strsave(temp);</a>
<a name="ln3029"> </a>
<a name="ln3030">    if (is_mouse_key(n)) {</a>
<a name="ln3031">      int row = mouse_row;</a>
<a name="ln3032">      int col = mouse_col;</a>
<a name="ln3033">      int grid = mouse_grid;</a>
<a name="ln3034">      win_T       *win;</a>
<a name="ln3035">      linenr_T lnum;</a>
<a name="ln3036">      win_T       *wp;</a>
<a name="ln3037">      int winnr = 1;</a>
<a name="ln3038"> </a>
<a name="ln3039">      if (row &gt;= 0 &amp;&amp; col &gt;= 0) {</a>
<a name="ln3040">        /* Find the window at the mouse coordinates and compute the</a>
<a name="ln3041">         * text position. */</a>
<a name="ln3042">        win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3043">        if (win == NULL) {</a>
<a name="ln3044">          return;</a>
<a name="ln3045">        }</a>
<a name="ln3046">        (void)mouse_comp_pos(win, &amp;row, &amp;col, &amp;lnum);</a>
<a name="ln3047">        for (wp = firstwin; wp != win; wp = wp-&gt;w_next)</a>
<a name="ln3048">          ++winnr;</a>
<a name="ln3049">        set_vim_var_nr(VV_MOUSE_WIN, winnr);</a>
<a name="ln3050">        set_vim_var_nr(VV_MOUSE_WINID, wp-&gt;handle);</a>
<a name="ln3051">        set_vim_var_nr(VV_MOUSE_LNUM, lnum);</a>
<a name="ln3052">        set_vim_var_nr(VV_MOUSE_COL, col + 1);</a>
<a name="ln3053">      }</a>
<a name="ln3054">    }</a>
<a name="ln3055">  }</a>
<a name="ln3056">}</a>
<a name="ln3057"> </a>
<a name="ln3058">/*</a>
<a name="ln3059"> * &quot;getcharmod()&quot; function</a>
<a name="ln3060"> */</a>
<a name="ln3061">static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3062">{</a>
<a name="ln3063">  rettv-&gt;vval.v_number = mod_mask;</a>
<a name="ln3064">}</a>
<a name="ln3065"> </a>
<a name="ln3066">/*</a>
<a name="ln3067"> * &quot;getcharsearch()&quot; function</a>
<a name="ln3068"> */</a>
<a name="ln3069">static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3070">{</a>
<a name="ln3071">  tv_dict_alloc_ret(rettv);</a>
<a name="ln3072"> </a>
<a name="ln3073">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln3074"> </a>
<a name="ln3075">  tv_dict_add_str(dict, S_LEN(&quot;char&quot;), last_csearch());</a>
<a name="ln3076">  tv_dict_add_nr(dict, S_LEN(&quot;forward&quot;), last_csearch_forward());</a>
<a name="ln3077">  tv_dict_add_nr(dict, S_LEN(&quot;until&quot;), last_csearch_until());</a>
<a name="ln3078">}</a>
<a name="ln3079"> </a>
<a name="ln3080">/*</a>
<a name="ln3081"> * &quot;getcmdline()&quot; function</a>
<a name="ln3082"> */</a>
<a name="ln3083">static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3084">{</a>
<a name="ln3085">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3086">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089">/*</a>
<a name="ln3090"> * &quot;getcmdpos()&quot; function</a>
<a name="ln3091"> */</a>
<a name="ln3092">static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3093">{</a>
<a name="ln3094">  rettv-&gt;vval.v_number = get_cmdline_pos() + 1;</a>
<a name="ln3095">}</a>
<a name="ln3096"> </a>
<a name="ln3097">/*</a>
<a name="ln3098"> * &quot;getcmdtype()&quot; function</a>
<a name="ln3099"> */</a>
<a name="ln3100">static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3101">{</a>
<a name="ln3102">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3103">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3104">  rettv-&gt;vval.v_string[0] = get_cmdline_type();</a>
<a name="ln3105">}</a>
<a name="ln3106"> </a>
<a name="ln3107">/*</a>
<a name="ln3108"> * &quot;getcmdwintype()&quot; function</a>
<a name="ln3109"> */</a>
<a name="ln3110">static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3111">{</a>
<a name="ln3112">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3113">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3114">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3115">  rettv-&gt;vval.v_string[0] = cmdwin_type;</a>
<a name="ln3116">}</a>
<a name="ln3117"> </a>
<a name="ln3118">// &quot;getcompletion()&quot; function</a>
<a name="ln3119">static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3120">{</a>
<a name="ln3121">  char_u        *pat;</a>
<a name="ln3122">  expand_T      xpc;</a>
<a name="ln3123">  bool          filtered = false;</a>
<a name="ln3124">  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH</a>
<a name="ln3125">          | WILD_NO_BEEP;</a>
<a name="ln3126"> </a>
<a name="ln3127">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3128">    filtered = (bool)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln3129">  }</a>
<a name="ln3130"> </a>
<a name="ln3131">  if (p_wic) {</a>
<a name="ln3132">    options |= WILD_ICASE;</a>
<a name="ln3133">  }</a>
<a name="ln3134"> </a>
<a name="ln3135">  // For filtered results, 'wildignore' is used</a>
<a name="ln3136">  if (!filtered) {</a>
<a name="ln3137">    options |= WILD_KEEP_ALL;</a>
<a name="ln3138">  }</a>
<a name="ln3139"> </a>
<a name="ln3140">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln3141">    EMSG(_(e_invarg));</a>
<a name="ln3142">    return;</a>
<a name="ln3143">  }</a>
<a name="ln3144"> </a>
<a name="ln3145">  if (strcmp(tv_get_string(&amp;argvars[1]), &quot;cmdline&quot;) == 0) {</a>
<a name="ln3146">    set_one_cmd_context(&amp;xpc, tv_get_string(&amp;argvars[0]));</a>
<a name="ln3147">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3148">    goto theend;</a>
<a name="ln3149">  }</a>
<a name="ln3150"> </a>
<a name="ln3151">  ExpandInit(&amp;xpc);</a>
<a name="ln3152">  xpc.xp_pattern = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3153">  xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3154">  xpc.xp_context = cmdcomplete_str_to_type(</a>
<a name="ln3155">      (char_u *)tv_get_string(&amp;argvars[1]));</a>
<a name="ln3156">  if (xpc.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3157">    EMSG2(_(e_invarg2), argvars[1].vval.v_string);</a>
<a name="ln3158">    return;</a>
<a name="ln3159">  }</a>
<a name="ln3160"> </a>
<a name="ln3161">  if (xpc.xp_context == EXPAND_MENUS) {</a>
<a name="ln3162">    set_context_in_menu_cmd(&amp;xpc, (char_u *)&quot;menu&quot;, xpc.xp_pattern, false);</a>
<a name="ln3163">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3164">  }</a>
<a name="ln3165"> </a>
<a name="ln3166">  if (xpc.xp_context == EXPAND_CSCOPE) {</a>
<a name="ln3167">    set_context_in_cscope_cmd(&amp;xpc, (const char *)xpc.xp_pattern, CMD_cscope);</a>
<a name="ln3168">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3169">  }</a>
<a name="ln3170"> </a>
<a name="ln3171">  if (xpc.xp_context == EXPAND_SIGN) {</a>
<a name="ln3172">    set_context_in_sign_cmd(&amp;xpc, xpc.xp_pattern);</a>
<a name="ln3173">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3174">  }</a>
<a name="ln3175"> </a>
<a name="ln3176">theend:</a>
<a name="ln3177">  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);</a>
<a name="ln3178">  ExpandOne(&amp;xpc, pat, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln3179">  tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3180"> </a>
<a name="ln3181">  for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3182">    tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3183">                          -1);</a>
<a name="ln3184">  }</a>
<a name="ln3185">  xfree(pat);</a>
<a name="ln3186">  ExpandCleanup(&amp;xpc);</a>
<a name="ln3187">}</a>
<a name="ln3188"> </a>
<a name="ln3189">/// `getcwd([{win}[, {tab}]])` function</a>
<a name="ln3190">///</a>
<a name="ln3191">/// Every scope not specified implies the currently selected scope object.</a>
<a name="ln3192">///</a>
<a name="ln3193">/// @pre  The arguments must be of type number.</a>
<a name="ln3194">/// @pre  There may not be more than two arguments.</a>
<a name="ln3195">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln3196">///</a>
<a name="ln3197">/// @post  The return value will be a string.</a>
<a name="ln3198">static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3199">{</a>
<a name="ln3200">  // Possible scope of working directory to return.</a>
<a name="ln3201">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln3202"> </a>
<a name="ln3203">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln3204">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln3205">  int scope_number[] = {</a>
<a name="ln3206">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln3207">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln3208">  };</a>
<a name="ln3209"> </a>
<a name="ln3210">  char_u *cwd  = NULL;  // Current working directory to print</a>
<a name="ln3211">  char_u *from = NULL;  // The original string to copy</a>
<a name="ln3212"> </a>
<a name="ln3213">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln3214">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln3215"> </a>
<a name="ln3216">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3217">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3218"> </a>
<a name="ln3219">  // Pre-conditions and scope extraction together</a>
<a name="ln3220">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln3221">    // If there is no argument there are no more scopes after it, break out.</a>
<a name="ln3222">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln3223">      break;</a>
<a name="ln3224">    }</a>
<a name="ln3225">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln3226">      EMSG(_(e_invarg));</a>
<a name="ln3227">      return;</a>
<a name="ln3228">    }</a>
<a name="ln3229">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln3230">    // It is an error for the scope number to be less than `-1`.</a>
<a name="ln3231">    if (scope_number[i] &lt; -1) {</a>
<a name="ln3232">      EMSG(_(e_invarg));</a>
<a name="ln3233">      return;</a>
<a name="ln3234">    }</a>
<a name="ln3235">    // Use the narrowest scope the user requested</a>
<a name="ln3236">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln3237">      // The scope is the current iteration step.</a>
<a name="ln3238">      scope = i;</a>
<a name="ln3239">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln3240">      scope = i + 1;</a>
<a name="ln3241">    }</a>
<a name="ln3242">  }</a>
<a name="ln3243"> </a>
<a name="ln3244">  // If the user didn't specify anything, default to window scope</a>
<a name="ln3245">  if (scope == kCdScopeInvalid) {</a>
<a name="ln3246">    scope = MIN_CD_SCOPE;</a>
<a name="ln3247">  }</a>
<a name="ln3248"> </a>
<a name="ln3249">  // Find the tabpage by number</a>
<a name="ln3250">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln3251">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln3252">    if (!tp) {</a>
<a name="ln3253">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln3254">      return;</a>
<a name="ln3255">    }</a>
<a name="ln3256">  }</a>
<a name="ln3257"> </a>
<a name="ln3258">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln3259">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln3260">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln3261">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln3262">      return;</a>
<a name="ln3263">    }</a>
<a name="ln3264"> </a>
<a name="ln3265">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln3266">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln3267">      if (!win) {</a>
<a name="ln3268">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln3269">        return;</a>
<a name="ln3270">      }</a>
<a name="ln3271">    }</a>
<a name="ln3272">  }</a>
<a name="ln3273"> </a>
<a name="ln3274">  cwd = xmalloc(MAXPATHL);</a>
<a name="ln3275"> </a>
<a name="ln3276">  switch (scope) {</a>
<a name="ln3277">    case kCdScopeWindow:</a>
<a name="ln3278">      assert(win);</a>
<a name="ln3279">      from = win-&gt;w_localdir;</a>
<a name="ln3280">      if (from) {</a>
<a name="ln3281">        break;</a>
<a name="ln3282">      }</a>
<a name="ln3283">      FALLTHROUGH;</a>
<a name="ln3284">    case kCdScopeTab:</a>
<a name="ln3285">      assert(tp);</a>
<a name="ln3286">      from = tp-&gt;tp_localdir;</a>
<a name="ln3287">      if (from) {</a>
<a name="ln3288">        break;</a>
<a name="ln3289">      }</a>
<a name="ln3290">      FALLTHROUGH;</a>
<a name="ln3291">    case kCdScopeGlobal:</a>
<a name="ln3292">      if (globaldir) {        // `globaldir` is not always set.</a>
<a name="ln3293">        from = globaldir;</a>
<a name="ln3294">      } else if (os_dirname(cwd, MAXPATHL) == FAIL) {  // Get the OS CWD.</a>
<a name="ln3295">        from = (char_u *)&quot;&quot;;  // Return empty string on failure.</a>
<a name="ln3296">      }</a>
<a name="ln3297">      break;</a>
<a name="ln3298">    case kCdScopeInvalid:     // We should never get here</a>
<a name="ln3299">      assert(false);</a>
<a name="ln3300">  }</a>
<a name="ln3301"> </a>
<a name="ln3302">  if (from) {</a>
<a name="ln3303">    xstrlcpy((char *)cwd, (char *)from, MAXPATHL);</a>
<a name="ln3304">  }</a>
<a name="ln3305"> </a>
<a name="ln3306">  rettv-&gt;vval.v_string = vim_strsave(cwd);</a>
<a name="ln3307">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3308">  slash_adjust(rettv-&gt;vval.v_string);</a>
<a name="ln3309">#endif</a>
<a name="ln3310"> </a>
<a name="ln3311">  xfree(cwd);</a>
<a name="ln3312">}</a>
<a name="ln3313"> </a>
<a name="ln3314">/*</a>
<a name="ln3315"> * &quot;getfontname()&quot; function</a>
<a name="ln3316"> */</a>
<a name="ln3317">static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3318">{</a>
<a name="ln3319">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3320">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3321">}</a>
<a name="ln3322"> </a>
<a name="ln3323">/*</a>
<a name="ln3324"> * &quot;getfperm({fname})&quot; function</a>
<a name="ln3325"> */</a>
<a name="ln3326">static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3327">{</a>
<a name="ln3328">  char *perm = NULL;</a>
<a name="ln3329">  char_u flags[] = &quot;rwx&quot;;</a>
<a name="ln3330"> </a>
<a name="ln3331">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3332">  int32_t file_perm = os_getperm(filename);</a>
<a name="ln3333">  if (file_perm &gt;= 0) {</a>
<a name="ln3334">    perm = xstrdup(&quot;---------&quot;);</a>
<a name="ln3335">    for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln3336">      if (file_perm &amp; (1 &lt;&lt; (8 - i))) {</a>
<a name="ln3337">        perm[i] = flags[i % 3];</a>
<a name="ln3338">      }</a>
<a name="ln3339">    }</a>
<a name="ln3340">  }</a>
<a name="ln3341">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3342">  rettv-&gt;vval.v_string = (char_u *)perm;</a>
<a name="ln3343">}</a>
<a name="ln3344"> </a>
<a name="ln3345">/*</a>
<a name="ln3346"> * &quot;getfsize({fname})&quot; function</a>
<a name="ln3347"> */</a>
<a name="ln3348">static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3349">{</a>
<a name="ln3350">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3351"> </a>
<a name="ln3352">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3353"> </a>
<a name="ln3354">  FileInfo file_info;</a>
<a name="ln3355">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3356">    uint64_t filesize = os_fileinfo_size(&amp;file_info);</a>
<a name="ln3357">    if (os_isdir((const char_u *)fname)) {</a>
<a name="ln3358">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln3359">    } else {</a>
<a name="ln3360">      rettv-&gt;vval.v_number = (varnumber_T)filesize;</a>
<a name="ln3361"> </a>
<a name="ln3362">      // non-perfect check for overflow</a>
<a name="ln3363">      if ((uint64_t)rettv-&gt;vval.v_number != filesize) {</a>
<a name="ln3364">        rettv-&gt;vval.v_number = -2;</a>
<a name="ln3365">      }</a>
<a name="ln3366">    }</a>
<a name="ln3367">  } else {</a>
<a name="ln3368">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3369">  }</a>
<a name="ln3370">}</a>
<a name="ln3371"> </a>
<a name="ln3372">/*</a>
<a name="ln3373"> * &quot;getftime({fname})&quot; function</a>
<a name="ln3374"> */</a>
<a name="ln3375">static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3376">{</a>
<a name="ln3377">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3378"> </a>
<a name="ln3379">  FileInfo file_info;</a>
<a name="ln3380">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3381">    rettv-&gt;vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3382">  } else {</a>
<a name="ln3383">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3384">  }</a>
<a name="ln3385">}</a>
<a name="ln3386"> </a>
<a name="ln3387">/*</a>
<a name="ln3388"> * &quot;getftype({fname})&quot; function</a>
<a name="ln3389"> */</a>
<a name="ln3390">static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3391">{</a>
<a name="ln3392">  char_u      *type = NULL;</a>
<a name="ln3393">  char        *t;</a>
<a name="ln3394"> </a>
<a name="ln3395">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3396"> </a>
<a name="ln3397">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3398">  FileInfo file_info;</a>
<a name="ln3399">  if (os_fileinfo_link(fname, &amp;file_info)) {</a>
<a name="ln3400">    uint64_t mode = file_info.stat.st_mode;</a>
<a name="ln3401">    if (S_ISREG(mode)) {</a>
<a name="ln3402">      t = &quot;file&quot;;</a>
<a name="ln3403">    } else if (S_ISDIR(mode)) {</a>
<a name="ln3404">      t = &quot;dir&quot;;</a>
<a name="ln3405">    } else if (S_ISLNK(mode)) {</a>
<a name="ln3406">      t = &quot;link&quot;;</a>
<a name="ln3407">    } else if (S_ISBLK(mode)) {</a>
<a name="ln3408">      t = &quot;bdev&quot;;</a>
<a name="ln3409">    } else if (S_ISCHR(mode)) {</a>
<a name="ln3410">      t = &quot;cdev&quot;;</a>
<a name="ln3411">    } else if (S_ISFIFO(mode)) {</a>
<a name="ln3412">      t = &quot;fifo&quot;;</a>
<a name="ln3413">    } else if (S_ISSOCK(mode)) {</a>
<a name="ln3414">      t = &quot;socket&quot;;</a>
<a name="ln3415">    } else {</a>
<a name="ln3416">      t = &quot;other&quot;;</a>
<a name="ln3417">    }</a>
<a name="ln3418">    type = vim_strsave((char_u *)t);</a>
<a name="ln3419">  }</a>
<a name="ln3420">  rettv-&gt;vval.v_string = type;</a>
<a name="ln3421">}</a>
<a name="ln3422"> </a>
<a name="ln3423">// &quot;getjumplist()&quot; function</a>
<a name="ln3424">static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3425">{</a>
<a name="ln3426">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3427">  win_T *const wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln3428">  if (wp == NULL) {</a>
<a name="ln3429">    return;</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  cleanup_jumplist(wp, true);</a>
<a name="ln3433"> </a>
<a name="ln3434">  list_T *const l = tv_list_alloc(wp-&gt;w_jumplistlen);</a>
<a name="ln3435">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3436">  tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_jumplistidx);</a>
<a name="ln3437"> </a>
<a name="ln3438">  for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln3439">    if (wp-&gt;w_jumplist[i].fmark.mark.lnum == 0) {</a>
<a name="ln3440">      continue;</a>
<a name="ln3441">    }</a>
<a name="ln3442">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3443">    tv_list_append_dict(l, d);</a>
<a name="ln3444">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), wp-&gt;w_jumplist[i].fmark.mark.lnum);</a>
<a name="ln3445">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), wp-&gt;w_jumplist[i].fmark.mark.col);</a>
<a name="ln3446">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), wp-&gt;w_jumplist[i].fmark.mark.coladd);</a>
<a name="ln3447">    tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), wp-&gt;w_jumplist[i].fmark.fnum);</a>
<a name="ln3448">    if (wp-&gt;w_jumplist[i].fname != NULL) {</a>
<a name="ln3449">      tv_dict_add_str(d, S_LEN(&quot;filename&quot;), (char *)wp-&gt;w_jumplist[i].fname);</a>
<a name="ln3450">    }</a>
<a name="ln3451">  }</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454">/*</a>
<a name="ln3455"> * &quot;getline(lnum, [end])&quot; function</a>
<a name="ln3456"> */</a>
<a name="ln3457">static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3458">{</a>
<a name="ln3459">  linenr_T end;</a>
<a name="ln3460">  bool retlist;</a>
<a name="ln3461"> </a>
<a name="ln3462">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln3463">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln3464">    end = lnum;</a>
<a name="ln3465">    retlist = false;</a>
<a name="ln3466">  } else {</a>
<a name="ln3467">    end = tv_get_lnum(&amp;argvars[1]);</a>
<a name="ln3468">    retlist = true;</a>
<a name="ln3469">  }</a>
<a name="ln3470"> </a>
<a name="ln3471">  get_buffer_lines(curbuf, lnum, end, retlist, rettv);</a>
<a name="ln3472">}</a>
<a name="ln3473"> </a>
<a name="ln3474">/// &quot;getloclist()&quot; function</a>
<a name="ln3475">static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3476">{</a>
<a name="ln3477">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3478">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">/*</a>
<a name="ln3482"> * &quot;getmatches()&quot; function</a>
<a name="ln3483"> */</a>
<a name="ln3484">static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3485">{</a>
<a name="ln3486">  matchitem_T *cur;</a>
<a name="ln3487">  int i;</a>
<a name="ln3488">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln3489"> </a>
<a name="ln3490">  if (win == NULL) {</a>
<a name="ln3491">    return;</a>
<a name="ln3492">  }</a>
<a name="ln3493"> </a>
<a name="ln3494">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3495">  cur = win-&gt;w_match_head;</a>
<a name="ln3496">  while (cur != NULL) {</a>
<a name="ln3497">    dict_T *dict = tv_dict_alloc();</a>
<a name="ln3498">    if (cur-&gt;match.regprog == NULL) {</a>
<a name="ln3499">      // match added with matchaddpos()</a>
<a name="ln3500">      for (i = 0; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln3501">        llpos_T   *llpos;</a>
<a name="ln3502">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln3503"> </a>
<a name="ln3504">        llpos = &amp;cur-&gt;pos.pos[i];</a>
<a name="ln3505">        if (llpos-&gt;lnum == 0) {</a>
<a name="ln3506">          break;</a>
<a name="ln3507">        }</a>
<a name="ln3508">        list_T *const l = tv_list_alloc(1 + (llpos-&gt;col &gt; 0 ? 2 : 0));</a>
<a name="ln3509">        tv_list_append_number(l, (varnumber_T)llpos-&gt;lnum);</a>
<a name="ln3510">        if (llpos-&gt;col &gt; 0) {</a>
<a name="ln3511">          tv_list_append_number(l, (varnumber_T)llpos-&gt;col);</a>
<a name="ln3512">          tv_list_append_number(l, (varnumber_T)llpos-&gt;len);</a>
<a name="ln3513">        }</a>
<a name="ln3514">        int len = snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i + 1);</a>
<a name="ln3515">        assert((size_t)len &lt; sizeof(buf));</a>
<a name="ln3516">        tv_dict_add_list(dict, buf, (size_t)len, l);</a>
<a name="ln3517">      }</a>
<a name="ln3518">    } else {</a>
<a name="ln3519">      tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (const char *)cur-&gt;pattern);</a>
<a name="ln3520">    }</a>
<a name="ln3521">    tv_dict_add_str(dict, S_LEN(&quot;group&quot;),</a>
<a name="ln3522">                    (const char *)syn_id2name(cur-&gt;hlg_id));</a>
<a name="ln3523">    tv_dict_add_nr(dict, S_LEN(&quot;priority&quot;), (varnumber_T)cur-&gt;priority);</a>
<a name="ln3524">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), (varnumber_T)cur-&gt;id);</a>
<a name="ln3525"> </a>
<a name="ln3526">    if (cur-&gt;conceal_char) {</a>
<a name="ln3527">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln3528"> </a>
<a name="ln3529">      buf[utf_char2bytes((int)cur-&gt;conceal_char, (char_u *)buf)] = NUL;</a>
<a name="ln3530">      tv_dict_add_str(dict, S_LEN(&quot;conceal&quot;), buf);</a>
<a name="ln3531">    }</a>
<a name="ln3532"> </a>
<a name="ln3533">    tv_list_append_dict(rettv-&gt;vval.v_list, dict);</a>
<a name="ln3534">    cur = cur-&gt;next;</a>
<a name="ln3535">  }</a>
<a name="ln3536">}</a>
<a name="ln3537"> </a>
<a name="ln3538">/*</a>
<a name="ln3539"> * &quot;getpid()&quot; function</a>
<a name="ln3540"> */</a>
<a name="ln3541">static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3542">{</a>
<a name="ln3543">  rettv-&gt;vval.v_number = os_get_pid();</a>
<a name="ln3544">}</a>
<a name="ln3545"> </a>
<a name="ln3546">static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)</a>
<a name="ln3547">{</a>
<a name="ln3548">  pos_T *fp;</a>
<a name="ln3549">  int fnum = -1;</a>
<a name="ln3550"> </a>
<a name="ln3551">  if (getcurpos) {</a>
<a name="ln3552">    fp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln3553">  } else {</a>
<a name="ln3554">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln3555">  }</a>
<a name="ln3556"> </a>
<a name="ln3557">  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));</a>
<a name="ln3558">  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);</a>
<a name="ln3559">  tv_list_append_number(l, ((fp != NULL)</a>
<a name="ln3560">                            ? (varnumber_T)fp-&gt;lnum</a>
<a name="ln3561">                            : (varnumber_T)0));</a>
<a name="ln3562">  tv_list_append_number(</a>
<a name="ln3563">      l, ((fp != NULL)</a>
<a name="ln3564">          ? (varnumber_T)(fp-&gt;col == MAXCOL ? MAXCOL : fp-&gt;col + 1)</a>
<a name="ln3565">          : (varnumber_T)0));</a>
<a name="ln3566">  tv_list_append_number(</a>
<a name="ln3567">      l, (fp != NULL) ? (varnumber_T)fp-&gt;coladd : (varnumber_T)0);</a>
<a name="ln3568">  if (getcurpos) {</a>
<a name="ln3569">    const int save_set_curswant = curwin-&gt;w_set_curswant;</a>
<a name="ln3570">    const colnr_T save_curswant = curwin-&gt;w_curswant;</a>
<a name="ln3571">    const colnr_T save_virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln3572"> </a>
<a name="ln3573">    update_curswant();</a>
<a name="ln3574">    tv_list_append_number(l, (curwin-&gt;w_curswant == MAXCOL</a>
<a name="ln3575">                              ? (varnumber_T)MAXCOL</a>
<a name="ln3576">                              : (varnumber_T)curwin-&gt;w_curswant + 1));</a>
<a name="ln3577"> </a>
<a name="ln3578">    // Do not change &quot;curswant&quot;, as it is unexpected that a get</a>
<a name="ln3579">    // function has a side effect.</a>
<a name="ln3580">    if (save_set_curswant) {</a>
<a name="ln3581">      curwin-&gt;w_set_curswant = save_set_curswant;</a>
<a name="ln3582">      curwin-&gt;w_curswant = save_curswant;</a>
<a name="ln3583">      curwin-&gt;w_virtcol = save_virtcol;</a>
<a name="ln3584">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln3585">    }</a>
<a name="ln3586">  }</a>
<a name="ln3587">}</a>
<a name="ln3588"> </a>
<a name="ln3589">/*</a>
<a name="ln3590"> * &quot;getcurpos(string)&quot; function</a>
<a name="ln3591"> */</a>
<a name="ln3592">static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3593">{</a>
<a name="ln3594">  getpos_both(argvars, rettv, true);</a>
<a name="ln3595">}</a>
<a name="ln3596"> </a>
<a name="ln3597">/*</a>
<a name="ln3598"> * &quot;getpos(string)&quot; function</a>
<a name="ln3599"> */</a>
<a name="ln3600">static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3601">{</a>
<a name="ln3602">  getpos_both(argvars, rettv, false);</a>
<a name="ln3603">}</a>
<a name="ln3604"> </a>
<a name="ln3605">/// &quot;getqflist()&quot; functions</a>
<a name="ln3606">static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3607">{</a>
<a name="ln3608">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln3609">}</a>
<a name="ln3610"> </a>
<a name="ln3611">/// &quot;getreg()&quot; function</a>
<a name="ln3612">static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3613">{</a>
<a name="ln3614">  const char *strregname;</a>
<a name="ln3615">  int arg2 = false;</a>
<a name="ln3616">  bool return_list = false;</a>
<a name="ln3617">  bool error = false;</a>
<a name="ln3618"> </a>
<a name="ln3619">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3620">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3621">    error = strregname == NULL;</a>
<a name="ln3622">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3623">      arg2 = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln3624">      if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3625">        return_list = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3626">      }</a>
<a name="ln3627">    }</a>
<a name="ln3628">  } else {</a>
<a name="ln3629">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3630">  }</a>
<a name="ln3631"> </a>
<a name="ln3632">  if (error) {</a>
<a name="ln3633">    return;</a>
<a name="ln3634">  }</a>
<a name="ln3635"> </a>
<a name="ln3636">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3637">  if (regname == 0) {</a>
<a name="ln3638">    regname = '&quot;';</a>
<a name="ln3639">  }</a>
<a name="ln3640"> </a>
<a name="ln3641">  if (return_list) {</a>
<a name="ln3642">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln3643">    rettv-&gt;vval.v_list =</a>
<a name="ln3644">      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);</a>
<a name="ln3645">    if (rettv-&gt;vval.v_list == NULL) {</a>
<a name="ln3646">      rettv-&gt;vval.v_list = tv_list_alloc(0);</a>
<a name="ln3647">    }</a>
<a name="ln3648">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln3649">  } else {</a>
<a name="ln3650">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3651">    rettv-&gt;vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);</a>
<a name="ln3652">  }</a>
<a name="ln3653">}</a>
<a name="ln3654"> </a>
<a name="ln3655">/*</a>
<a name="ln3656"> * &quot;getregtype()&quot; function</a>
<a name="ln3657"> */</a>
<a name="ln3658">static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3659">{</a>
<a name="ln3660">  const char *strregname;</a>
<a name="ln3661"> </a>
<a name="ln3662">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3663">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3664">    if (strregname == NULL) {  // Type error; errmsg already given.</a>
<a name="ln3665">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3666">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3667">      return;</a>
<a name="ln3668">    }</a>
<a name="ln3669">  } else {</a>
<a name="ln3670">    // Default to v:register.</a>
<a name="ln3671">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3672">  }</a>
<a name="ln3673"> </a>
<a name="ln3674">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3675">  if (regname == 0) {</a>
<a name="ln3676">    regname = '&quot;';</a>
<a name="ln3677">  }</a>
<a name="ln3678"> </a>
<a name="ln3679">  colnr_T reglen = 0;</a>
<a name="ln3680">  char buf[NUMBUFLEN + 2];</a>
<a name="ln3681">  MotionType reg_type = get_reg_type(regname, &amp;reglen);</a>
<a name="ln3682">  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));</a>
<a name="ln3683"> </a>
<a name="ln3684">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3685">  rettv-&gt;vval.v_string = (char_u *)xstrdup(buf);</a>
<a name="ln3686">}</a>
<a name="ln3687"> </a>
<a name="ln3688">/// &quot;gettabinfo()&quot; function</a>
<a name="ln3689">static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3690">{</a>
<a name="ln3691">  tabpage_T *tparg = NULL;</a>
<a name="ln3692"> </a>
<a name="ln3693">  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN</a>
<a name="ln3694">                            ? 1</a>
<a name="ln3695">                            : kListLenMayKnow));</a>
<a name="ln3696"> </a>
<a name="ln3697">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3698">    // Information about one tab page</a>
<a name="ln3699">    tparg = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3700">    if (tparg == NULL) {</a>
<a name="ln3701">      return;</a>
<a name="ln3702">    }</a>
<a name="ln3703">  }</a>
<a name="ln3704"> </a>
<a name="ln3705">  // Get information about a specific tab page or all tab pages</a>
<a name="ln3706">  int tpnr = 0;</a>
<a name="ln3707">  FOR_ALL_TABS(tp) {</a>
<a name="ln3708">    tpnr++;</a>
<a name="ln3709">    if (tparg != NULL &amp;&amp; tp != tparg) {</a>
<a name="ln3710">      continue;</a>
<a name="ln3711">    }</a>
<a name="ln3712">    dict_T *const d = get_tabpage_info(tp, tpnr);</a>
<a name="ln3713">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3714">    if (tparg != NULL) {</a>
<a name="ln3715">      return;</a>
<a name="ln3716">    }</a>
<a name="ln3717">  }</a>
<a name="ln3718">}</a>
<a name="ln3719"> </a>
<a name="ln3720">/*</a>
<a name="ln3721"> * &quot;gettabvar()&quot; function</a>
<a name="ln3722"> */</a>
<a name="ln3723">static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3724">{</a>
<a name="ln3725">  win_T *oldcurwin;</a>
<a name="ln3726">  tabpage_T *oldtabpage;</a>
<a name="ln3727">  bool done = false;</a>
<a name="ln3728"> </a>
<a name="ln3729">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3730">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3731"> </a>
<a name="ln3732">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3733">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3734">  if (tp != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln3735">    // Set tp to be our tabpage, temporarily.  Also set the window to the</a>
<a name="ln3736">    // first window in the tabpage, otherwise the window is not valid.</a>
<a name="ln3737">    win_T *const window = tp == curtab || tp-&gt;tp_firstwin == NULL</a>
<a name="ln3738">        ? firstwin</a>
<a name="ln3739">        : tp-&gt;tp_firstwin;</a>
<a name="ln3740">    if (switch_win(&amp;oldcurwin, &amp;oldtabpage, window, tp, true) == OK) {</a>
<a name="ln3741">      // look up the variable</a>
<a name="ln3742">      // Let gettabvar({nr}, &quot;&quot;) return the &quot;t:&quot; dictionary.</a>
<a name="ln3743">      const dictitem_T *const v = find_var_in_ht(&amp;tp-&gt;tp_vars-&gt;dv_hashtab, 't',</a>
<a name="ln3744">                                                 varname, strlen(varname),</a>
<a name="ln3745">                                                 false);</a>
<a name="ln3746">      if (v != NULL) {</a>
<a name="ln3747">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln3748">        done = true;</a>
<a name="ln3749">      }</a>
<a name="ln3750">    }</a>
<a name="ln3751"> </a>
<a name="ln3752">    // restore previous notion of curwin</a>
<a name="ln3753">    restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln3754">  }</a>
<a name="ln3755"> </a>
<a name="ln3756">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3757">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln3758">  }</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">/*</a>
<a name="ln3762"> * &quot;gettabwinvar()&quot; function</a>
<a name="ln3763"> */</a>
<a name="ln3764">static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3765">{</a>
<a name="ln3766">  getwinvar(argvars, rettv, 1);</a>
<a name="ln3767">}</a>
<a name="ln3768"> </a>
<a name="ln3769">// &quot;gettagstack()&quot; function</a>
<a name="ln3770">static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3771">{</a>
<a name="ln3772">    win_T        *wp = curwin;                  // default is current window</a>
<a name="ln3773"> </a>
<a name="ln3774">    tv_dict_alloc_ret(rettv);</a>
<a name="ln3775"> </a>
<a name="ln3776">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3777">        wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3778">        if (wp == NULL) {</a>
<a name="ln3779">          return;</a>
<a name="ln3780">        }</a>
<a name="ln3781">    }</a>
<a name="ln3782"> </a>
<a name="ln3783">    get_tagstack(wp, rettv-&gt;vval.v_dict);</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/// &quot;getwininfo()&quot; function</a>
<a name="ln3787">static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3788">{</a>
<a name="ln3789">  win_T *wparg = NULL;</a>
<a name="ln3790"> </a>
<a name="ln3791">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3792"> </a>
<a name="ln3793">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3794">    wparg = win_id2wp(argvars);</a>
<a name="ln3795">    if (wparg == NULL) {</a>
<a name="ln3796">      return;</a>
<a name="ln3797">    }</a>
<a name="ln3798">  }</a>
<a name="ln3799"> </a>
<a name="ln3800">  // Collect information about either all the windows across all the tab</a>
<a name="ln3801">  // pages or one particular window.</a>
<a name="ln3802">  int16_t tabnr = 0;</a>
<a name="ln3803">  FOR_ALL_TABS(tp) {</a>
<a name="ln3804">    tabnr++;</a>
<a name="ln3805">    int16_t winnr = 0;</a>
<a name="ln3806">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3807">      winnr++;</a>
<a name="ln3808">      if (wparg != NULL &amp;&amp; wp != wparg) {</a>
<a name="ln3809">        continue;</a>
<a name="ln3810">      }</a>
<a name="ln3811">      dict_T *const d = get_win_info(wp, tabnr, winnr);</a>
<a name="ln3812">      tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3813">      if (wparg != NULL) {</a>
<a name="ln3814">        // found information about a specific window</a>
<a name="ln3815">        return;</a>
<a name="ln3816">      }</a>
<a name="ln3817">    }</a>
<a name="ln3818">  }</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821">// Dummy timer callback. Used by f_wait().</a>
<a name="ln3822">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3823">{</a>
<a name="ln3824">}</a>
<a name="ln3825"> </a>
<a name="ln3826">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln3827">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3828">{</a>
<a name="ln3829">  xfree(tw);</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">/// &quot;wait(timeout, condition[, interval])&quot; function</a>
<a name="ln3833">static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3834">{</a>
<a name="ln3835">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3836">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3837"> </a>
<a name="ln3838">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln3839">    EMSG2(_(e_invargval), &quot;1&quot;);</a>
<a name="ln3840">    return;</a>
<a name="ln3841">  }</a>
<a name="ln3842">  if ((argvars[2].v_type != VAR_NUMBER &amp;&amp; argvars[2].v_type != VAR_UNKNOWN)</a>
<a name="ln3843">      || (argvars[2].v_type == VAR_NUMBER &amp;&amp; argvars[2].vval.v_number &lt;= 0)) {</a>
<a name="ln3844">    EMSG2(_(e_invargval), &quot;3&quot;);</a>
<a name="ln3845">    return;</a>
<a name="ln3846">  }</a>
<a name="ln3847"> </a>
<a name="ln3848">  int timeout = argvars[0].vval.v_number;</a>
<a name="ln3849">  typval_T expr = argvars[1];</a>
<a name="ln3850">  int interval = argvars[2].v_type == VAR_NUMBER</a>
<a name="ln3851">    ? argvars[2].vval.v_number</a>
<a name="ln3852">    : 200;  // Default.</a>
<a name="ln3853">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln3854"> </a>
<a name="ln3855">  // Start dummy timer.</a>
<a name="ln3856">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln3857">  tw-&gt;events = main_loop.events;</a>
<a name="ln3858">  tw-&gt;blockable = true;</a>
<a name="ln3859">  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);</a>
<a name="ln3860"> </a>
<a name="ln3861">  typval_T argv = TV_INITIAL_VALUE;</a>
<a name="ln3862">  typval_T exprval = TV_INITIAL_VALUE;</a>
<a name="ln3863">  bool error = false;</a>
<a name="ln3864">  int save_called_emsg = called_emsg;</a>
<a name="ln3865">  called_emsg = false;</a>
<a name="ln3866"> </a>
<a name="ln3867">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, timeout,</a>
<a name="ln3868">                            eval_expr_typval(&amp;expr, &amp;argv, 0, &amp;exprval) != OK</a>
<a name="ln3869">                            || tv_get_number_chk(&amp;exprval, &amp;error)</a>
<a name="ln3870">                            || called_emsg || error || got_int);</a>
<a name="ln3871"> </a>
<a name="ln3872">  if (called_emsg || error) {</a>
<a name="ln3873">    rettv-&gt;vval.v_number = -3;</a>
<a name="ln3874">  } else if (got_int) {</a>
<a name="ln3875">    got_int = false;</a>
<a name="ln3876">    vgetc();</a>
<a name="ln3877">    rettv-&gt;vval.v_number = -2;</a>
<a name="ln3878">  } else if (tv_get_number_chk(&amp;exprval, &amp;error)) {</a>
<a name="ln3879">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln3880">  }</a>
<a name="ln3881"> </a>
<a name="ln3882">  called_emsg = save_called_emsg;</a>
<a name="ln3883"> </a>
<a name="ln3884">  // Stop dummy timer</a>
<a name="ln3885">  time_watcher_stop(tw);</a>
<a name="ln3886">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889">// &quot;win_screenpos()&quot; function</a>
<a name="ln3890">static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3891">{</a>
<a name="ln3892">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3893">  const win_T *const wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3894">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_winrow + 1);</a>
<a name="ln3895">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_wincol + 1);</a>
<a name="ln3896">}</a>
<a name="ln3897"> </a>
<a name="ln3898">// &quot;getwinpos({timeout})&quot; function</a>
<a name="ln3899">static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3900">{</a>
<a name="ln3901">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3902">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln3903">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln3904">}</a>
<a name="ln3905"> </a>
<a name="ln3906">/*</a>
<a name="ln3907"> * &quot;getwinposx()&quot; function</a>
<a name="ln3908"> */</a>
<a name="ln3909">static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3910">{</a>
<a name="ln3911">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3912">}</a>
<a name="ln3913"> </a>
<a name="ln3914">/*</a>
<a name="ln3915"> * &quot;getwinposy()&quot; function</a>
<a name="ln3916"> */</a>
<a name="ln3917">static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3918">{</a>
<a name="ln3919">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3920">}</a>
<a name="ln3921"> </a>
<a name="ln3922">/// &quot;getwinvar()&quot; function</a>
<a name="ln3923">static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3924">{</a>
<a name="ln3925">  getwinvar(argvars, rettv, 0);</a>
<a name="ln3926">}</a>
<a name="ln3927"> </a>
<a name="ln3928">/*</a>
<a name="ln3929"> * &quot;glob()&quot; function</a>
<a name="ln3930"> */</a>
<a name="ln3931">static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3932">{</a>
<a name="ln3933">  int options = WILD_SILENT|WILD_USE_NL;</a>
<a name="ln3934">  expand_T xpc;</a>
<a name="ln3935">  bool error = false;</a>
<a name="ln3936"> </a>
<a name="ln3937">  /* When the optional second argument is non-zero, don't remove matches</a>
<a name="ln3938">  * for 'wildignore' and don't put matches for 'suffixes' at the end. */</a>
<a name="ln3939">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3940">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3941">    if (tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln3942">      options |= WILD_KEEP_ALL;</a>
<a name="ln3943">    }</a>
<a name="ln3944">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3945">      if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln3946">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln3947">      }</a>
<a name="ln3948">      if (argvars[3].v_type != VAR_UNKNOWN</a>
<a name="ln3949">          &amp;&amp; tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln3950">        options |= WILD_ALLLINKS;</a>
<a name="ln3951">      }</a>
<a name="ln3952">    }</a>
<a name="ln3953">  }</a>
<a name="ln3954">  if (!error) {</a>
<a name="ln3955">    ExpandInit(&amp;xpc);</a>
<a name="ln3956">    xpc.xp_context = EXPAND_FILES;</a>
<a name="ln3957">    if (p_wic)</a>
<a name="ln3958">      options += WILD_ICASE;</a>
<a name="ln3959">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln3960">      rettv-&gt;vval.v_string = ExpandOne(</a>
<a name="ln3961">          &amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options, WILD_ALL);</a>
<a name="ln3962">    } else {</a>
<a name="ln3963">      ExpandOne(&amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options,</a>
<a name="ln3964">                WILD_ALL_KEEP);</a>
<a name="ln3965">      tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3966">      for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3967">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3968">                              -1);</a>
<a name="ln3969">      }</a>
<a name="ln3970">      ExpandCleanup(&amp;xpc);</a>
<a name="ln3971">    }</a>
<a name="ln3972">  } else</a>
<a name="ln3973">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3974">}</a>
<a name="ln3975"> </a>
<a name="ln3976">/// &quot;globpath()&quot; function</a>
<a name="ln3977">static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3978">{</a>
<a name="ln3979">  int flags = WILD_IGNORE_COMPLETESLASH;  // Flags for globpath.</a>
<a name="ln3980">  bool error = false;</a>
<a name="ln3981"> </a>
<a name="ln3982">  // Return a string, or a list if the optional third argument is non-zero.</a>
<a name="ln3983">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3984"> </a>
<a name="ln3985">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3986">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln3987">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln3988">    if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln3989">      flags |= WILD_KEEP_ALL;</a>
<a name="ln3990">    }</a>
<a name="ln3991"> </a>
<a name="ln3992">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln3993">      if (tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln3994">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln3995">      }</a>
<a name="ln3996">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln3997">          &amp;&amp; tv_get_number_chk(&amp;argvars[4], &amp;error)) {</a>
<a name="ln3998">        flags |= WILD_ALLLINKS;</a>
<a name="ln3999">      }</a>
<a name="ln4000">    }</a>
<a name="ln4001">  }</a>
<a name="ln4002"> </a>
<a name="ln4003">  char buf1[NUMBUFLEN];</a>
<a name="ln4004">  const char *const file = tv_get_string_buf_chk(&amp;argvars[1], buf1);</a>
<a name="ln4005">  if (file != NULL &amp;&amp; !error) {</a>
<a name="ln4006">    garray_T ga;</a>
<a name="ln4007">    ga_init(&amp;ga, (int)sizeof(char_u *), 10);</a>
<a name="ln4008">    globpath((char_u *)tv_get_string(&amp;argvars[0]), (char_u *)file, &amp;ga, flags);</a>
<a name="ln4009"> </a>
<a name="ln4010">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4011">      rettv-&gt;vval.v_string = ga_concat_strings_sep(&amp;ga, &quot;\n&quot;);</a>
<a name="ln4012">    } else {</a>
<a name="ln4013">      tv_list_alloc_ret(rettv, ga.ga_len);</a>
<a name="ln4014">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln4015">        tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln4016">                              ((const char **)(ga.ga_data))[i], -1);</a>
<a name="ln4017">      }</a>
<a name="ln4018">    }</a>
<a name="ln4019"> </a>
<a name="ln4020">    ga_clear_strings(&amp;ga);</a>
<a name="ln4021">  } else {</a>
<a name="ln4022">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4023">  }</a>
<a name="ln4024">}</a>
<a name="ln4025"> </a>
<a name="ln4026">// &quot;glob2regpat()&quot; function</a>
<a name="ln4027">static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4028">{</a>
<a name="ln4029">  const char *const pat = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4030"> </a>
<a name="ln4031">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4032">  rettv-&gt;vval.v_string = ((pat == NULL)</a>
<a name="ln4033">                          ? NULL</a>
<a name="ln4034">                          : file_pat_to_reg_pat((char_u *)pat, NULL, NULL,</a>
<a name="ln4035">                                                false));</a>
<a name="ln4036">}</a>
<a name="ln4037"> </a>
<a name="ln4038">/// &quot;has()&quot; function</a>
<a name="ln4039">static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4040">{</a>
<a name="ln4041">  static const char *const has_list[] = {</a>
<a name="ln4042">#if defined(BSD) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln4043">    &quot;bsd&quot;,</a>
<a name="ln4044">#endif</a>
<a name="ln4045">#ifdef UNIX</a>
<a name="ln4046">    &quot;unix&quot;,</a>
<a name="ln4047">#endif</a>
<a name="ln4048">#if defined(WIN32)</a>
<a name="ln4049">    &quot;win32&quot;,</a>
<a name="ln4050">#endif</a>
<a name="ln4051">#if defined(WIN64) || defined(_WIN64)</a>
<a name="ln4052">    &quot;win64&quot;,</a>
<a name="ln4053">#endif</a>
<a name="ln4054">    &quot;fname_case&quot;,</a>
<a name="ln4055">#ifdef HAVE_ACL</a>
<a name="ln4056">    &quot;acl&quot;,</a>
<a name="ln4057">#endif</a>
<a name="ln4058">    &quot;autochdir&quot;,</a>
<a name="ln4059">    &quot;arabic&quot;,</a>
<a name="ln4060">    &quot;autocmd&quot;,</a>
<a name="ln4061">    &quot;browsefilter&quot;,</a>
<a name="ln4062">    &quot;byte_offset&quot;,</a>
<a name="ln4063">    &quot;cindent&quot;,</a>
<a name="ln4064">    &quot;cmdline_compl&quot;,</a>
<a name="ln4065">    &quot;cmdline_hist&quot;,</a>
<a name="ln4066">    &quot;comments&quot;,</a>
<a name="ln4067">    &quot;conceal&quot;,</a>
<a name="ln4068">    &quot;cscope&quot;,</a>
<a name="ln4069">    &quot;cursorbind&quot;,</a>
<a name="ln4070">    &quot;cursorshape&quot;,</a>
<a name="ln4071">#ifdef DEBUG</a>
<a name="ln4072">    &quot;debug&quot;,</a>
<a name="ln4073">#endif</a>
<a name="ln4074">    &quot;dialog_con&quot;,</a>
<a name="ln4075">    &quot;diff&quot;,</a>
<a name="ln4076">    &quot;digraphs&quot;,</a>
<a name="ln4077">    &quot;eval&quot;,         // always present, of course!</a>
<a name="ln4078">    &quot;ex_extra&quot;,</a>
<a name="ln4079">    &quot;extra_search&quot;,</a>
<a name="ln4080">    &quot;file_in_path&quot;,</a>
<a name="ln4081">    &quot;filterpipe&quot;,</a>
<a name="ln4082">    &quot;find_in_path&quot;,</a>
<a name="ln4083">    &quot;float&quot;,</a>
<a name="ln4084">    &quot;folding&quot;,</a>
<a name="ln4085">#if defined(UNIX)</a>
<a name="ln4086">    &quot;fork&quot;,</a>
<a name="ln4087">#endif</a>
<a name="ln4088">    &quot;gettext&quot;,</a>
<a name="ln4089">#if defined(HAVE_ICONV)</a>
<a name="ln4090">    &quot;iconv&quot;,</a>
<a name="ln4091">#endif</a>
<a name="ln4092">    &quot;insert_expand&quot;,</a>
<a name="ln4093">    &quot;jumplist&quot;,</a>
<a name="ln4094">    &quot;keymap&quot;,</a>
<a name="ln4095">    &quot;lambda&quot;,</a>
<a name="ln4096">    &quot;langmap&quot;,</a>
<a name="ln4097">    &quot;libcall&quot;,</a>
<a name="ln4098">    &quot;linebreak&quot;,</a>
<a name="ln4099">    &quot;lispindent&quot;,</a>
<a name="ln4100">    &quot;listcmds&quot;,</a>
<a name="ln4101">    &quot;localmap&quot;,</a>
<a name="ln4102">#ifdef __APPLE__</a>
<a name="ln4103">    &quot;mac&quot;,</a>
<a name="ln4104">    &quot;macunix&quot;,</a>
<a name="ln4105">    &quot;osx&quot;,</a>
<a name="ln4106">    &quot;osxdarwin&quot;,</a>
<a name="ln4107">#endif</a>
<a name="ln4108">    &quot;menu&quot;,</a>
<a name="ln4109">    &quot;mksession&quot;,</a>
<a name="ln4110">    &quot;modify_fname&quot;,</a>
<a name="ln4111">    &quot;mouse&quot;,</a>
<a name="ln4112">    &quot;multi_byte&quot;,</a>
<a name="ln4113">    &quot;multi_lang&quot;,</a>
<a name="ln4114">    &quot;num64&quot;,</a>
<a name="ln4115">    &quot;packages&quot;,</a>
<a name="ln4116">    &quot;path_extra&quot;,</a>
<a name="ln4117">    &quot;persistent_undo&quot;,</a>
<a name="ln4118">    &quot;postscript&quot;,</a>
<a name="ln4119">    &quot;printer&quot;,</a>
<a name="ln4120">    &quot;profile&quot;,</a>
<a name="ln4121">    &quot;pythonx&quot;,</a>
<a name="ln4122">    &quot;reltime&quot;,</a>
<a name="ln4123">    &quot;quickfix&quot;,</a>
<a name="ln4124">    &quot;rightleft&quot;,</a>
<a name="ln4125">    &quot;scrollbind&quot;,</a>
<a name="ln4126">    &quot;showcmd&quot;,</a>
<a name="ln4127">    &quot;cmdline_info&quot;,</a>
<a name="ln4128">    &quot;shada&quot;,</a>
<a name="ln4129">    &quot;signs&quot;,</a>
<a name="ln4130">    &quot;smartindent&quot;,</a>
<a name="ln4131">    &quot;startuptime&quot;,</a>
<a name="ln4132">    &quot;statusline&quot;,</a>
<a name="ln4133">    &quot;spell&quot;,</a>
<a name="ln4134">    &quot;syntax&quot;,</a>
<a name="ln4135">#if !defined(UNIX)</a>
<a name="ln4136">    &quot;system&quot;,  // TODO(SplinterOfChaos): This IS defined for UNIX!</a>
<a name="ln4137">#endif</a>
<a name="ln4138">    &quot;tablineat&quot;,</a>
<a name="ln4139">    &quot;tag_binary&quot;,</a>
<a name="ln4140">    &quot;termguicolors&quot;,</a>
<a name="ln4141">    &quot;termresponse&quot;,</a>
<a name="ln4142">    &quot;textobjects&quot;,</a>
<a name="ln4143">    &quot;timers&quot;,</a>
<a name="ln4144">    &quot;title&quot;,</a>
<a name="ln4145">    &quot;user-commands&quot;,        // was accidentally included in 5.4</a>
<a name="ln4146">    &quot;user_commands&quot;,</a>
<a name="ln4147">    &quot;vertsplit&quot;,</a>
<a name="ln4148">    &quot;virtualedit&quot;,</a>
<a name="ln4149">    &quot;visual&quot;,</a>
<a name="ln4150">    &quot;visualextra&quot;,</a>
<a name="ln4151">    &quot;vreplace&quot;,</a>
<a name="ln4152">    &quot;wildignore&quot;,</a>
<a name="ln4153">    &quot;wildmenu&quot;,</a>
<a name="ln4154">    &quot;windows&quot;,</a>
<a name="ln4155">    &quot;winaltkeys&quot;,</a>
<a name="ln4156">    &quot;writebackup&quot;,</a>
<a name="ln4157">#if defined(HAVE_WSL)</a>
<a name="ln4158">    &quot;wsl&quot;,</a>
<a name="ln4159">#endif</a>
<a name="ln4160">    &quot;nvim&quot;,</a>
<a name="ln4161">  };</a>
<a name="ln4162"> </a>
<a name="ln4163">  bool n = false;</a>
<a name="ln4164">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4165">  for (size_t i = 0; i &lt; ARRAY_SIZE(has_list); i++) {</a>
<a name="ln4166">    if (STRICMP(name, has_list[i]) == 0) {</a>
<a name="ln4167">      n = true;</a>
<a name="ln4168">      break;</a>
<a name="ln4169">    }</a>
<a name="ln4170">  }</a>
<a name="ln4171"> </a>
<a name="ln4172">  if (!n) {</a>
<a name="ln4173">    if (STRNICMP(name, &quot;patch&quot;, 5) == 0) {</a>
<a name="ln4174">      if (name[5] == '-'</a>
<a name="ln4175">          &amp;&amp; strlen(name) &gt;= 11</a>
<a name="ln4176">          &amp;&amp; ascii_isdigit(name[6])</a>
<a name="ln4177">          &amp;&amp; ascii_isdigit(name[8])</a>
<a name="ln4178">          &amp;&amp; ascii_isdigit(name[10])) {</a>
<a name="ln4179">        int major = atoi(name + 6);</a>
<a name="ln4180">        int minor = atoi(name + 8);</a>
<a name="ln4181"> </a>
<a name="ln4182">        // Expect &quot;patch-9.9.01234&quot;.</a>
<a name="ln4183">        n = (major &lt; VIM_VERSION_MAJOR</a>
<a name="ln4184">             || (major == VIM_VERSION_MAJOR</a>
<a name="ln4185">                 &amp;&amp; (minor &lt; VIM_VERSION_MINOR</a>
<a name="ln4186">                     || (minor == VIM_VERSION_MINOR</a>
<a name="ln4187">                         &amp;&amp; has_vim_patch(atoi(name + 10))))));</a>
<a name="ln4188">      } else {</a>
<a name="ln4189">        n = has_vim_patch(atoi(name + 5));</a>
<a name="ln4190">      }</a>
<a name="ln4191">    } else if (STRNICMP(name, &quot;nvim-&quot;, 5) == 0) {</a>
<a name="ln4192">      // Expect &quot;nvim-x.y.z&quot;</a>
<a name="ln4193">      n = has_nvim_version(name + 5);</a>
<a name="ln4194">    } else if (STRICMP(name, &quot;vim_starting&quot;) == 0) {</a>
<a name="ln4195">      n = (starting != 0);</a>
<a name="ln4196">    } else if (STRICMP(name, &quot;ttyin&quot;) == 0) {</a>
<a name="ln4197">      n = stdin_isatty;</a>
<a name="ln4198">    } else if (STRICMP(name, &quot;ttyout&quot;) == 0) {</a>
<a name="ln4199">      n = stdout_isatty;</a>
<a name="ln4200">    } else if (STRICMP(name, &quot;multi_byte_encoding&quot;) == 0) {</a>
<a name="ln4201">      n = has_mbyte != 0;</a>
<a name="ln4202">    } else if (STRICMP(name, &quot;syntax_items&quot;) == 0) {</a>
<a name="ln4203">      n = syntax_present(curwin);</a>
<a name="ln4204">#ifdef UNIX</a>
<a name="ln4205">    } else if (STRICMP(name, &quot;unnamedplus&quot;) == 0) {</a>
<a name="ln4206">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4207">#endif</a>
<a name="ln4208">    }</a>
<a name="ln4209">  }</a>
<a name="ln4210"> </a>
<a name="ln4211">  if (!n &amp;&amp; eval_has_provider(name)) {</a>
<a name="ln4212">    n = true;</a>
<a name="ln4213">  }</a>
<a name="ln4214"> </a>
<a name="ln4215">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4216">}</a>
<a name="ln4217"> </a>
<a name="ln4218">/*</a>
<a name="ln4219"> * &quot;has_key()&quot; function</a>
<a name="ln4220"> */</a>
<a name="ln4221">static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4222">{</a>
<a name="ln4223">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln4224">    EMSG(_(e_dictreq));</a>
<a name="ln4225">    return;</a>
<a name="ln4226">  }</a>
<a name="ln4227">  if (argvars[0].vval.v_dict == NULL)</a>
<a name="ln4228">    return;</a>
<a name="ln4229"> </a>
<a name="ln4230">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln4231">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln4232">                                      -1) != NULL;</a>
<a name="ln4233">}</a>
<a name="ln4234"> </a>
<a name="ln4235">/// `haslocaldir([{win}[, {tab}]])` function</a>
<a name="ln4236">///</a>
<a name="ln4237">/// Returns `1` if the scope object has a local directory, `0` otherwise. If a</a>
<a name="ln4238">/// scope object is not specified the current one is implied. This function</a>
<a name="ln4239">/// share a lot of code with `f_getcwd`.</a>
<a name="ln4240">///</a>
<a name="ln4241">/// @pre  The arguments must be of type number.</a>
<a name="ln4242">/// @pre  There may not be more than two arguments.</a>
<a name="ln4243">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln4244">///</a>
<a name="ln4245">/// @post  The return value will be either the number `1` or `0`.</a>
<a name="ln4246">static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4247">{</a>
<a name="ln4248">  // Possible scope of working directory to return.</a>
<a name="ln4249">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln4250"> </a>
<a name="ln4251">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln4252">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln4253">  int scope_number[] = {</a>
<a name="ln4254">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln4255">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln4256">  };</a>
<a name="ln4257"> </a>
<a name="ln4258">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln4259">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln4260"> </a>
<a name="ln4261">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4262">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4263"> </a>
<a name="ln4264">  // Pre-conditions and scope extraction together</a>
<a name="ln4265">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln4266">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln4267">      break;</a>
<a name="ln4268">    }</a>
<a name="ln4269">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln4270">      EMSG(_(e_invarg));</a>
<a name="ln4271">      return;</a>
<a name="ln4272">    }</a>
<a name="ln4273">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln4274">    if (scope_number[i] &lt; -1) {</a>
<a name="ln4275">      EMSG(_(e_invarg));</a>
<a name="ln4276">      return;</a>
<a name="ln4277">    }</a>
<a name="ln4278">    // Use the narrowest scope the user requested</a>
<a name="ln4279">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln4280">      // The scope is the current iteration step.</a>
<a name="ln4281">      scope = i;</a>
<a name="ln4282">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln4283">      scope = i + 1;</a>
<a name="ln4284">    }</a>
<a name="ln4285">  }</a>
<a name="ln4286"> </a>
<a name="ln4287">  // If the user didn't specify anything, default to window scope</a>
<a name="ln4288">  if (scope == kCdScopeInvalid) {</a>
<a name="ln4289">    scope = MIN_CD_SCOPE;</a>
<a name="ln4290">  }</a>
<a name="ln4291"> </a>
<a name="ln4292">  // Find the tabpage by number</a>
<a name="ln4293">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln4294">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln4295">    if (!tp) {</a>
<a name="ln4296">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln4297">      return;</a>
<a name="ln4298">    }</a>
<a name="ln4299">  }</a>
<a name="ln4300"> </a>
<a name="ln4301">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln4302">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln4303">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln4304">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln4305">      return;</a>
<a name="ln4306">    }</a>
<a name="ln4307"> </a>
<a name="ln4308">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln4309">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln4310">      if (!win) {</a>
<a name="ln4311">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln4312">        return;</a>
<a name="ln4313">      }</a>
<a name="ln4314">    }</a>
<a name="ln4315">  }</a>
<a name="ln4316"> </a>
<a name="ln4317">  switch (scope) {</a>
<a name="ln4318">    case kCdScopeWindow:</a>
<a name="ln4319">      assert(win);</a>
<a name="ln4320">      rettv-&gt;vval.v_number = win-&gt;w_localdir ? 1 : 0;</a>
<a name="ln4321">      break;</a>
<a name="ln4322">    case kCdScopeTab:</a>
<a name="ln4323">      assert(tp);</a>
<a name="ln4324">      rettv-&gt;vval.v_number = tp-&gt;tp_localdir ? 1 : 0;</a>
<a name="ln4325">      break;</a>
<a name="ln4326">    case kCdScopeGlobal:</a>
<a name="ln4327">      // The global scope never has a local directory</a>
<a name="ln4328">      break;</a>
<a name="ln4329">    case kCdScopeInvalid:</a>
<a name="ln4330">      // We should never get here</a>
<a name="ln4331">      assert(false);</a>
<a name="ln4332">  }</a>
<a name="ln4333">}</a>
<a name="ln4334"> </a>
<a name="ln4335">/*</a>
<a name="ln4336"> * &quot;hasmapto()&quot; function</a>
<a name="ln4337"> */</a>
<a name="ln4338">static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4339">{</a>
<a name="ln4340">  const char *mode;</a>
<a name="ln4341">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4342">  bool abbr = false;</a>
<a name="ln4343">  char buf[NUMBUFLEN];</a>
<a name="ln4344">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4345">    mode = &quot;nvo&quot;;</a>
<a name="ln4346">  } else {</a>
<a name="ln4347">    mode = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4348">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4349">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln4350">    }</a>
<a name="ln4351">  }</a>
<a name="ln4352"> </a>
<a name="ln4353">  if (map_to_exists(name, mode, abbr)) {</a>
<a name="ln4354">    rettv-&gt;vval.v_number = true;</a>
<a name="ln4355">  } else {</a>
<a name="ln4356">    rettv-&gt;vval.v_number = false;</a>
<a name="ln4357">  }</a>
<a name="ln4358">}</a>
<a name="ln4359"> </a>
<a name="ln4360">/*</a>
<a name="ln4361"> * &quot;histadd()&quot; function</a>
<a name="ln4362"> */</a>
<a name="ln4363">static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4364">{</a>
<a name="ln4365">  HistoryType histype;</a>
<a name="ln4366"> </a>
<a name="ln4367">  rettv-&gt;vval.v_number = false;</a>
<a name="ln4368">  if (check_secure()) {</a>
<a name="ln4369">    return;</a>
<a name="ln4370">  }</a>
<a name="ln4371">  const char *str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4372">  histype = str != NULL ? get_histtype(str, strlen(str), false) : HIST_INVALID;</a>
<a name="ln4373">  if (histype != HIST_INVALID) {</a>
<a name="ln4374">    char buf[NUMBUFLEN];</a>
<a name="ln4375">    str = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4376">    if (*str != NUL) {</a>
<a name="ln4377">      init_history();</a>
<a name="ln4378">      add_to_history(histype, (char_u *)str, false, NUL);</a>
<a name="ln4379">      rettv-&gt;vval.v_number = true;</a>
<a name="ln4380">      return;</a>
<a name="ln4381">    }</a>
<a name="ln4382">  }</a>
<a name="ln4383">}</a>
<a name="ln4384"> </a>
<a name="ln4385">/*</a>
<a name="ln4386"> * &quot;histdel()&quot; function</a>
<a name="ln4387"> */</a>
<a name="ln4388">static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4389">{</a>
<a name="ln4390">  int n;</a>
<a name="ln4391">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4392">  if (str == NULL) {</a>
<a name="ln4393">    n = 0;</a>
<a name="ln4394">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4395">    // only one argument: clear entire history</a>
<a name="ln4396">    n = clr_history(get_histtype(str, strlen(str), false));</a>
<a name="ln4397">  } else if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln4398">    // index given: remove that entry</a>
<a name="ln4399">    n = del_history_idx(get_histtype(str, strlen(str), false),</a>
<a name="ln4400">                        (int)tv_get_number(&amp;argvars[1]));</a>
<a name="ln4401">  } else {</a>
<a name="ln4402">    // string given: remove all matching entries</a>
<a name="ln4403">    char buf[NUMBUFLEN];</a>
<a name="ln4404">    n = del_history_entry(get_histtype(str, strlen(str), false),</a>
<a name="ln4405">                          (char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln4406">  }</a>
<a name="ln4407">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4408">}</a>
<a name="ln4409"> </a>
<a name="ln4410">/*</a>
<a name="ln4411"> * &quot;histget()&quot; function</a>
<a name="ln4412"> */</a>
<a name="ln4413">static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4414">{</a>
<a name="ln4415">  HistoryType type;</a>
<a name="ln4416">  int idx;</a>
<a name="ln4417"> </a>
<a name="ln4418">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4419">  if (str == NULL) {</a>
<a name="ln4420">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4421">  } else {</a>
<a name="ln4422">    type = get_histtype(str, strlen(str), false);</a>
<a name="ln4423">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4424">      idx = get_history_idx(type);</a>
<a name="ln4425">    } else {</a>
<a name="ln4426">      idx = (int)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln4427">    }</a>
<a name="ln4428">    // -1 on type error</a>
<a name="ln4429">    rettv-&gt;vval.v_string = vim_strsave(get_history_entry(type, idx));</a>
<a name="ln4430">  }</a>
<a name="ln4431">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4432">}</a>
<a name="ln4433"> </a>
<a name="ln4434">/*</a>
<a name="ln4435"> * &quot;histnr()&quot; function</a>
<a name="ln4436"> */</a>
<a name="ln4437">static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4438">{</a>
<a name="ln4439">  const char *const history = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln4440">  HistoryType i = history == NULL</a>
<a name="ln4441">    ? HIST_INVALID</a>
<a name="ln4442">    : get_histtype(history, strlen(history), false);</a>
<a name="ln4443">  if (i != HIST_INVALID) {</a>
<a name="ln4444">    i = get_history_idx(i);</a>
<a name="ln4445">  }</a>
<a name="ln4446">  rettv-&gt;vval.v_number = i;</a>
<a name="ln4447">}</a>
<a name="ln4448"> </a>
<a name="ln4449">/*</a>
<a name="ln4450"> * &quot;highlightID(name)&quot; function</a>
<a name="ln4451"> */</a>
<a name="ln4452">static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4453">{</a>
<a name="ln4454">  rettv-&gt;vval.v_number = syn_name2id(</a>
<a name="ln4455">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4456">}</a>
<a name="ln4457"> </a>
<a name="ln4458">/*</a>
<a name="ln4459"> * &quot;highlight_exists()&quot; function</a>
<a name="ln4460"> */</a>
<a name="ln4461">static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4462">{</a>
<a name="ln4463">  rettv-&gt;vval.v_number = highlight_exists(</a>
<a name="ln4464">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4465">}</a>
<a name="ln4466"> </a>
<a name="ln4467">/*</a>
<a name="ln4468"> * &quot;hostname()&quot; function</a>
<a name="ln4469"> */</a>
<a name="ln4470">static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4471">{</a>
<a name="ln4472">  char hostname[256];</a>
<a name="ln4473"> </a>
<a name="ln4474">  os_get_hostname(hostname, 256);</a>
<a name="ln4475">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4476">  rettv-&gt;vval.v_string = vim_strsave((char_u *)hostname);</a>
<a name="ln4477">}</a>
<a name="ln4478"> </a>
<a name="ln4479">/*</a>
<a name="ln4480"> * iconv() function</a>
<a name="ln4481"> */</a>
<a name="ln4482">static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4483">{</a>
<a name="ln4484">  vimconv_T vimconv;</a>
<a name="ln4485"> </a>
<a name="ln4486">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4487">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4488"> </a>
<a name="ln4489">  const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4490">  char buf1[NUMBUFLEN];</a>
<a name="ln4491">  char_u *const from = enc_canonize(enc_skip(</a>
<a name="ln4492">      (char_u *)tv_get_string_buf(&amp;argvars[1], buf1)));</a>
<a name="ln4493">  char buf2[NUMBUFLEN];</a>
<a name="ln4494">  char_u *const to = enc_canonize(enc_skip(</a>
<a name="ln4495">      (char_u *)tv_get_string_buf(&amp;argvars[2], buf2)));</a>
<a name="ln4496">  vimconv.vc_type = CONV_NONE;</a>
<a name="ln4497">  convert_setup(&amp;vimconv, from, to);</a>
<a name="ln4498"> </a>
<a name="ln4499">  // If the encodings are equal, no conversion needed.</a>
<a name="ln4500">  if (vimconv.vc_type == CONV_NONE) {</a>
<a name="ln4501">    rettv-&gt;vval.v_string = (char_u *)xstrdup(str);</a>
<a name="ln4502">  } else {</a>
<a name="ln4503">    rettv-&gt;vval.v_string = string_convert(&amp;vimconv, (char_u *)str, NULL);</a>
<a name="ln4504">  }</a>
<a name="ln4505"> </a>
<a name="ln4506">  convert_setup(&amp;vimconv, NULL, NULL);</a>
<a name="ln4507">  xfree(from);</a>
<a name="ln4508">  xfree(to);</a>
<a name="ln4509">}</a>
<a name="ln4510"> </a>
<a name="ln4511">/*</a>
<a name="ln4512"> * &quot;indent()&quot; function</a>
<a name="ln4513"> */</a>
<a name="ln4514">static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4515">{</a>
<a name="ln4516">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln4517">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4518">    rettv-&gt;vval.v_number = get_indent_lnum(lnum);</a>
<a name="ln4519">  } else {</a>
<a name="ln4520">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4521">  }</a>
<a name="ln4522">}</a>
<a name="ln4523"> </a>
<a name="ln4524">/*</a>
<a name="ln4525"> * &quot;index()&quot; function</a>
<a name="ln4526"> */</a>
<a name="ln4527">static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4528">{</a>
<a name="ln4529">  long idx = 0;</a>
<a name="ln4530">  bool ic = false;</a>
<a name="ln4531"> </a>
<a name="ln4532">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4533">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4534">    EMSG(_(e_listreq));</a>
<a name="ln4535">    return;</a>
<a name="ln4536">  }</a>
<a name="ln4537">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln4538">  if (l != NULL) {</a>
<a name="ln4539">    listitem_T *item = tv_list_first(l);</a>
<a name="ln4540">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4541">      bool error = false;</a>
<a name="ln4542"> </a>
<a name="ln4543">      // Start at specified item.</a>
<a name="ln4544">      idx = tv_list_uidx(l, tv_get_number_chk(&amp;argvars[2], &amp;error));</a>
<a name="ln4545">      if (error || idx == -1) {</a>
<a name="ln4546">        item = NULL;</a>
<a name="ln4547">      } else {</a>
<a name="ln4548">        item = tv_list_find(l, idx);</a>
<a name="ln4549">        assert(item != NULL);</a>
<a name="ln4550">      }</a>
<a name="ln4551">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4552">        ic = !!tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln4553">        if (error) {</a>
<a name="ln4554">          item = NULL;</a>
<a name="ln4555">        }</a>
<a name="ln4556">      }</a>
<a name="ln4557">    }</a>
<a name="ln4558"> </a>
<a name="ln4559">    for (; item != NULL; item = TV_LIST_ITEM_NEXT(l, item), idx++) {</a>
<a name="ln4560">      if (tv_equal(TV_LIST_ITEM_TV(item), &amp;argvars[1], ic, false)) {</a>
<a name="ln4561">        rettv-&gt;vval.v_number = idx;</a>
<a name="ln4562">        break;</a>
<a name="ln4563">      }</a>
<a name="ln4564">    }</a>
<a name="ln4565">  }</a>
<a name="ln4566">}</a>
<a name="ln4567"> </a>
<a name="ln4568">static bool inputsecret_flag = false;</a>
<a name="ln4569"> </a>
<a name="ln4570">/*</a>
<a name="ln4571"> * &quot;input()&quot; function</a>
<a name="ln4572"> *     Also handles inputsecret() when inputsecret is set.</a>
<a name="ln4573"> */</a>
<a name="ln4574">static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4575">{</a>
<a name="ln4576">  get_user_input(argvars, rettv, FALSE, inputsecret_flag);</a>
<a name="ln4577">}</a>
<a name="ln4578"> </a>
<a name="ln4579">/*</a>
<a name="ln4580"> * &quot;inputdialog()&quot; function</a>
<a name="ln4581"> */</a>
<a name="ln4582">static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4583">{</a>
<a name="ln4584">  get_user_input(argvars, rettv, TRUE, inputsecret_flag);</a>
<a name="ln4585">}</a>
<a name="ln4586"> </a>
<a name="ln4587">/*</a>
<a name="ln4588"> * &quot;inputlist()&quot; function</a>
<a name="ln4589"> */</a>
<a name="ln4590">static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4591">{</a>
<a name="ln4592">  int selected;</a>
<a name="ln4593">  int mouse_used;</a>
<a name="ln4594"> </a>
<a name="ln4595">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4596">    EMSG2(_(e_listarg), &quot;inputlist()&quot;);</a>
<a name="ln4597">    return;</a>
<a name="ln4598">  }</a>
<a name="ln4599"> </a>
<a name="ln4600">  msg_start();</a>
<a name="ln4601">  msg_row = Rows - 1;   // for when 'cmdheight' &gt; 1</a>
<a name="ln4602">  lines_left = Rows;    // avoid more prompt</a>
<a name="ln4603">  msg_scroll = true;</a>
<a name="ln4604">  msg_clr_eos();</a>
<a name="ln4605"> </a>
<a name="ln4606">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln4607">    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4608">    msg_putchar('\n');</a>
<a name="ln4609">  });</a>
<a name="ln4610"> </a>
<a name="ln4611">  // Ask for choice.</a>
<a name="ln4612">  selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln4613">  if (mouse_used) {</a>
<a name="ln4614">    selected -= lines_left;</a>
<a name="ln4615">  }</a>
<a name="ln4616"> </a>
<a name="ln4617">  rettv-&gt;vval.v_number = selected;</a>
<a name="ln4618">}</a>
<a name="ln4619"> </a>
<a name="ln4620"> </a>
<a name="ln4621">static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, NULL };</a>
<a name="ln4622"> </a>
<a name="ln4623">/// &quot;inputrestore()&quot; function</a>
<a name="ln4624">static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4625">{</a>
<a name="ln4626">  if (!GA_EMPTY(&amp;ga_userinput)) {</a>
<a name="ln4627">    ga_userinput.ga_len--;</a>
<a name="ln4628">    restore_typeahead((tasave_T *)(ga_userinput.ga_data)</a>
<a name="ln4629">                      + ga_userinput.ga_len);</a>
<a name="ln4630">    // default return is zero == OK</a>
<a name="ln4631">  } else if (p_verbose &gt; 1) {</a>
<a name="ln4632">    verb_msg(_(&quot;called inputrestore() more often than inputsave()&quot;));</a>
<a name="ln4633">    rettv-&gt;vval.v_number = 1;  // Failed</a>
<a name="ln4634">  }</a>
<a name="ln4635">}</a>
<a name="ln4636"> </a>
<a name="ln4637">/// &quot;inputsave()&quot; function</a>
<a name="ln4638">static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4639">{</a>
<a name="ln4640">  // Add an entry to the stack of typeahead storage.</a>
<a name="ln4641">  tasave_T *p = GA_APPEND_VIA_PTR(tasave_T, &amp;ga_userinput);</a>
<a name="ln4642">  save_typeahead(p);</a>
<a name="ln4643">}</a>
<a name="ln4644"> </a>
<a name="ln4645">/// &quot;inputsecret()&quot; function</a>
<a name="ln4646">static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4647">{</a>
<a name="ln4648">  cmdline_star++;</a>
<a name="ln4649">  inputsecret_flag = true;</a>
<a name="ln4650">  f_input(argvars, rettv, NULL);</a>
<a name="ln4651">  cmdline_star--;</a>
<a name="ln4652">  inputsecret_flag = false;</a>
<a name="ln4653">}</a>
<a name="ln4654"> </a>
<a name="ln4655">/*</a>
<a name="ln4656"> * &quot;insert()&quot; function</a>
<a name="ln4657"> */</a>
<a name="ln4658">static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4659">{</a>
<a name="ln4660">  list_T *l;</a>
<a name="ln4661">  bool error = false;</a>
<a name="ln4662"> </a>
<a name="ln4663">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4664">    EMSG2(_(e_listarg), &quot;insert()&quot;);</a>
<a name="ln4665">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln4666">                            N_(&quot;insert() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln4667">    long before = 0;</a>
<a name="ln4668">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4669">      before = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln4670">    }</a>
<a name="ln4671">    if (error) {</a>
<a name="ln4672">      // type error; errmsg already given</a>
<a name="ln4673">      return;</a>
<a name="ln4674">    }</a>
<a name="ln4675"> </a>
<a name="ln4676">    listitem_T *item = NULL;</a>
<a name="ln4677">    if (before != tv_list_len(l)) {</a>
<a name="ln4678">      item = tv_list_find(l, before);</a>
<a name="ln4679">      if (item == NULL) {</a>
<a name="ln4680">        EMSGN(_(e_listidx), before);</a>
<a name="ln4681">        l = NULL;</a>
<a name="ln4682">      }</a>
<a name="ln4683">    }</a>
<a name="ln4684">    if (l != NULL) {</a>
<a name="ln4685">      tv_list_insert_tv(l, &amp;argvars[1], item);</a>
<a name="ln4686">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln4687">    }</a>
<a name="ln4688">  }</a>
<a name="ln4689">}</a>
<a name="ln4690"> </a>
<a name="ln4691">// &quot;interrupt()&quot; function</a>
<a name="ln4692">static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED,</a>
<a name="ln4693">                        typval_T *rettv FUNC_ATTR_UNUSED,</a>
<a name="ln4694">                        FunPtr fptr FUNC_ATTR_UNUSED)</a>
<a name="ln4695">{</a>
<a name="ln4696">  got_int = true;</a>
<a name="ln4697">}</a>
<a name="ln4698"> </a>
<a name="ln4699">/*</a>
<a name="ln4700"> * &quot;invert(expr)&quot; function</a>
<a name="ln4701"> */</a>
<a name="ln4702">static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4703">{</a>
<a name="ln4704">  rettv-&gt;vval.v_number = ~tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln4705">}</a>
<a name="ln4706"> </a>
<a name="ln4707">/*</a>
<a name="ln4708"> * &quot;isdirectory()&quot; function</a>
<a name="ln4709"> */</a>
<a name="ln4710">static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4711">{</a>
<a name="ln4712">  rettv-&gt;vval.v_number = os_isdir((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4713">}</a>
<a name="ln4714"> </a>
<a name="ln4715">/*</a>
<a name="ln4716"> * &quot;islocked()&quot; function</a>
<a name="ln4717"> */</a>
<a name="ln4718">static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4719">{</a>
<a name="ln4720">  lval_T lv;</a>
<a name="ln4721">  dictitem_T  *di;</a>
<a name="ln4722"> </a>
<a name="ln4723">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4724">  const char_u *const end = get_lval((char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln4725">                                     NULL,</a>
<a name="ln4726">                                     &amp;lv, false, false,</a>
<a name="ln4727">                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,</a>
<a name="ln4728">                                     FNE_CHECK_START);</a>
<a name="ln4729">  if (end != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln4730">    if (*end != NUL) {</a>
<a name="ln4731">      EMSG(_(e_trailing));</a>
<a name="ln4732">    } else {</a>
<a name="ln4733">      if (lv.ll_tv == NULL) {</a>
<a name="ln4734">        di = find_var((const char *)lv.ll_name, lv.ll_name_len, NULL, true);</a>
<a name="ln4735">        if (di != NULL) {</a>
<a name="ln4736">          // Consider a variable locked when:</a>
<a name="ln4737">          // 1. the variable itself is locked</a>
<a name="ln4738">          // 2. the value of the variable is locked.</a>
<a name="ln4739">          // 3. the List or Dict value is locked.</a>
<a name="ln4740">          rettv-&gt;vval.v_number = ((di-&gt;di_flags &amp; DI_FLAGS_LOCK)</a>
<a name="ln4741">                                  || tv_islocked(&amp;di-&gt;di_tv));</a>
<a name="ln4742">        }</a>
<a name="ln4743">      } else if (lv.ll_range) {</a>
<a name="ln4744">        EMSG(_(&quot;E786: Range not allowed&quot;));</a>
<a name="ln4745">      } else if (lv.ll_newkey != NULL) {</a>
<a name="ln4746">        EMSG2(_(e_dictkey), lv.ll_newkey);</a>
<a name="ln4747">      } else if (lv.ll_list != NULL) {</a>
<a name="ln4748">        // List item.</a>
<a name="ln4749">        rettv-&gt;vval.v_number = tv_islocked(TV_LIST_ITEM_TV(lv.ll_li));</a>
<a name="ln4750">      } else {</a>
<a name="ln4751">        // Dictionary item.</a>
<a name="ln4752">        rettv-&gt;vval.v_number = tv_islocked(&amp;lv.ll_di-&gt;di_tv);</a>
<a name="ln4753">      }</a>
<a name="ln4754">    }</a>
<a name="ln4755">  }</a>
<a name="ln4756"> </a>
<a name="ln4757">  clear_lval(&amp;lv);</a>
<a name="ln4758">}</a>
<a name="ln4759"> </a>
<a name="ln4760">// &quot;isinf()&quot; function</a>
<a name="ln4761">static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4762">{</a>
<a name="ln4763">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4764">      &amp;&amp; xisinf(argvars[0].vval.v_float)) {</a>
<a name="ln4765">    rettv-&gt;vval.v_number = argvars[0].vval.v_float &gt; 0.0 ? 1 : -1;</a>
<a name="ln4766">  }</a>
<a name="ln4767">}</a>
<a name="ln4768"> </a>
<a name="ln4769">// &quot;isnan()&quot; function</a>
<a name="ln4770">static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4771">{</a>
<a name="ln4772">  rettv-&gt;vval.v_number = argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4773">    &amp;&amp; xisnan(argvars[0].vval.v_float);</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776">/// &quot;id()&quot; function</a>
<a name="ln4777">static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4778">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4779">{</a>
<a name="ln4780">  const int len = vim_vsnprintf_typval(NULL, 0, &quot;%p&quot;, dummy_ap, argvars);</a>
<a name="ln4781">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4782">  rettv-&gt;vval.v_string = xmalloc(len + 1);</a>
<a name="ln4783">  vim_vsnprintf_typval((char *)rettv-&gt;vval.v_string, len + 1, &quot;%p&quot;,</a>
<a name="ln4784">                       dummy_ap, argvars);</a>
<a name="ln4785">}</a>
<a name="ln4786"> </a>
<a name="ln4787">/*</a>
<a name="ln4788"> * &quot;items(dict)&quot; function</a>
<a name="ln4789"> */</a>
<a name="ln4790">static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4791">{</a>
<a name="ln4792">  dict_list(argvars, rettv, 2);</a>
<a name="ln4793">}</a>
<a name="ln4794"> </a>
<a name="ln4795">// &quot;jobpid(id)&quot; function</a>
<a name="ln4796">static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4797">{</a>
<a name="ln4798">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4799">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4800"> </a>
<a name="ln4801">  if (check_restricted() || check_secure()) {</a>
<a name="ln4802">    return;</a>
<a name="ln4803">  }</a>
<a name="ln4804"> </a>
<a name="ln4805">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4806">    EMSG(_(e_invarg));</a>
<a name="ln4807">    return;</a>
<a name="ln4808">  }</a>
<a name="ln4809"> </a>
<a name="ln4810">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4811">  if (!data) {</a>
<a name="ln4812">    return;</a>
<a name="ln4813">  }</a>
<a name="ln4814"> </a>
<a name="ln4815">  Process *proc = (Process *)&amp;data-&gt;stream.proc;</a>
<a name="ln4816">  rettv-&gt;vval.v_number = proc-&gt;pid;</a>
<a name="ln4817">}</a>
<a name="ln4818"> </a>
<a name="ln4819">// &quot;jobresize(job, width, height)&quot; function</a>
<a name="ln4820">static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4821">{</a>
<a name="ln4822">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4823">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4824"> </a>
<a name="ln4825">  if (check_restricted() || check_secure()) {</a>
<a name="ln4826">    return;</a>
<a name="ln4827">  }</a>
<a name="ln4828"> </a>
<a name="ln4829">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln4830">      || argvars[2].v_type != VAR_NUMBER) {</a>
<a name="ln4831">    // job id, width, height</a>
<a name="ln4832">    EMSG(_(e_invarg));</a>
<a name="ln4833">    return;</a>
<a name="ln4834">  }</a>
<a name="ln4835"> </a>
<a name="ln4836"> </a>
<a name="ln4837">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4838">  if (!data) {</a>
<a name="ln4839">    return;</a>
<a name="ln4840">  }</a>
<a name="ln4841"> </a>
<a name="ln4842">  if (data-&gt;stream.proc.type != kProcessTypePty) {</a>
<a name="ln4843">    EMSG(_(e_channotpty));</a>
<a name="ln4844">    return;</a>
<a name="ln4845">  }</a>
<a name="ln4846"> </a>
<a name="ln4847">  pty_process_resize(&amp;data-&gt;stream.pty, argvars[1].vval.v_number,</a>
<a name="ln4848">                     argvars[2].vval.v_number);</a>
<a name="ln4849">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln4850">}</a>
<a name="ln4851"> </a>
<a name="ln4852">// &quot;jobstart()&quot; function</a>
<a name="ln4853">static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4854">{</a>
<a name="ln4855">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4856">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4857"> </a>
<a name="ln4858">  if (check_restricted() || check_secure()) {</a>
<a name="ln4859">    return;</a>
<a name="ln4860">  }</a>
<a name="ln4861"> </a>
<a name="ln4862">  bool executable = true;</a>
<a name="ln4863">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln4864">  char **env = NULL;</a>
<a name="ln4865">  if (!argv) {</a>
<a name="ln4866">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln4867">    return;  // Did error message in tv_to_argv.</a>
<a name="ln4868">  }</a>
<a name="ln4869"> </a>
<a name="ln4870">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4871">    // Wrong argument types</a>
<a name="ln4872">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln4873">    shell_free_argv(argv);</a>
<a name="ln4874">    return;</a>
<a name="ln4875">  }</a>
<a name="ln4876"> </a>
<a name="ln4877"> </a>
<a name="ln4878">  dict_T *job_opts = NULL;</a>
<a name="ln4879">  bool detach = false;</a>
<a name="ln4880">  bool rpc = false;</a>
<a name="ln4881">  bool pty = false;</a>
<a name="ln4882">  bool clear_env = false;</a>
<a name="ln4883">  bool overlapped = false;</a>
<a name="ln4884">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln4885">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln4886">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln4887">  char *cwd = NULL;</a>
<a name="ln4888">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln4889">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln4890"> </a>
<a name="ln4891">    detach = tv_dict_get_number(job_opts, &quot;detach&quot;) != 0;</a>
<a name="ln4892">    rpc = tv_dict_get_number(job_opts, &quot;rpc&quot;) != 0;</a>
<a name="ln4893">    pty = tv_dict_get_number(job_opts, &quot;pty&quot;) != 0;</a>
<a name="ln4894">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln4895">    overlapped = tv_dict_get_number(job_opts, &quot;overlapped&quot;) != 0;</a>
<a name="ln4896"> </a>
<a name="ln4897">    if (pty &amp;&amp; rpc) {</a>
<a name="ln4898">      EMSG2(_(e_invarg2), &quot;job cannot have both 'pty' and 'rpc' options set&quot;);</a>
<a name="ln4899">      shell_free_argv(argv);</a>
<a name="ln4900">      return;</a>
<a name="ln4901">    }</a>
<a name="ln4902"> </a>
<a name="ln4903">#ifdef WIN32</a>
<a name="ln4904">    if (pty &amp;&amp; overlapped) {</a>
<a name="ln4905">      EMSG2(_(e_invarg2),</a>
<a name="ln4906">            &quot;job cannot have both 'pty' and 'overlapped' options set&quot;);</a>
<a name="ln4907">      shell_free_argv(argv);</a>
<a name="ln4908">      return;</a>
<a name="ln4909">    }</a>
<a name="ln4910">#endif</a>
<a name="ln4911"> </a>
<a name="ln4912">    char *new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln4913">    if (new_cwd &amp;&amp; strlen(new_cwd) &gt; 0) {</a>
<a name="ln4914">      cwd = new_cwd;</a>
<a name="ln4915">      // The new cwd must be a directory.</a>
<a name="ln4916">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln4917">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln4918">        shell_free_argv(argv);</a>
<a name="ln4919">        return;</a>
<a name="ln4920">      }</a>
<a name="ln4921">    }</a>
<a name="ln4922">    dictitem_T *job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln4923">    if (job_env) {</a>
<a name="ln4924">      if (job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln4925">        EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln4926">        shell_free_argv(argv);</a>
<a name="ln4927">        return;</a>
<a name="ln4928">      }</a>
<a name="ln4929"> </a>
<a name="ln4930">      size_t custom_env_size = (size_t)tv_dict_len(job_env-&gt;di_tv.vval.v_dict);</a>
<a name="ln4931">      size_t i = 0;</a>
<a name="ln4932">      size_t env_size = 0;</a>
<a name="ln4933"> </a>
<a name="ln4934">      if (clear_env) {</a>
<a name="ln4935">        // + 1 for last null entry</a>
<a name="ln4936">        env = xmalloc((custom_env_size + 1) * sizeof(*env));</a>
<a name="ln4937">        env_size = 0;</a>
<a name="ln4938">      } else {</a>
<a name="ln4939">        env_size = os_get_fullenv_size();</a>
<a name="ln4940"> </a>
<a name="ln4941">        env = xmalloc((custom_env_size + env_size + 1) * sizeof(*env));</a>
<a name="ln4942"> </a>
<a name="ln4943">        os_copy_fullenv(env, env_size);</a>
<a name="ln4944">        i = env_size;</a>
<a name="ln4945">      }</a>
<a name="ln4946">      assert(env);  // env must be allocated at this point</a>
<a name="ln4947"> </a>
<a name="ln4948">      TV_DICT_ITER(job_env-&gt;di_tv.vval.v_dict, var, {</a>
<a name="ln4949">        const char *str = tv_get_string(&amp;var-&gt;di_tv);</a>
<a name="ln4950">        assert(str);</a>
<a name="ln4951">        size_t len = STRLEN(var-&gt;di_key) + strlen(str) + strlen(&quot;=&quot;) + 1;</a>
<a name="ln4952">        env[i] = xmalloc(len);</a>
<a name="ln4953">        snprintf(env[i], len, &quot;%s=%s&quot;, (char *)var-&gt;di_key, str);</a>
<a name="ln4954">        i++;</a>
<a name="ln4955">      });</a>
<a name="ln4956"> </a>
<a name="ln4957">      // must be null terminated</a>
<a name="ln4958">      env[env_size + custom_env_size] = NULL;</a>
<a name="ln4959">    }</a>
<a name="ln4960"> </a>
<a name="ln4961"> </a>
<a name="ln4962">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln4963">      shell_free_argv(argv);</a>
<a name="ln4964">      return;</a>
<a name="ln4965">    }</a>
<a name="ln4966">  }</a>
<a name="ln4967"> </a>
<a name="ln4968">  uint16_t width = 0, height = 0;</a>
<a name="ln4969">  char *term_name = NULL;</a>
<a name="ln4970"> </a>
<a name="ln4971">  if (pty) {</a>
<a name="ln4972">    width = (uint16_t)tv_dict_get_number(job_opts, &quot;width&quot;);</a>
<a name="ln4973">    height = (uint16_t)tv_dict_get_number(job_opts, &quot;height&quot;);</a>
<a name="ln4974">    term_name = tv_dict_get_string(job_opts, &quot;TERM&quot;, true);</a>
<a name="ln4975">  }</a>
<a name="ln4976"> </a>
<a name="ln4977">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,</a>
<a name="ln4978">                                    rpc, overlapped, detach, cwd, width, height,</a>
<a name="ln4979">                                    term_name, env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln4980">  if (chan) {</a>
<a name="ln4981">    channel_create_event(chan, NULL);</a>
<a name="ln4982">  }</a>
<a name="ln4983">}</a>
<a name="ln4984"> </a>
<a name="ln4985">// &quot;jobstop()&quot; function</a>
<a name="ln4986">static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4987">{</a>
<a name="ln4988">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4989">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4990"> </a>
<a name="ln4991">  if (check_restricted() || check_secure()) {</a>
<a name="ln4992">    return;</a>
<a name="ln4993">  }</a>
<a name="ln4994"> </a>
<a name="ln4995">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4996">    // Only argument is the job id</a>
<a name="ln4997">    EMSG(_(e_invarg));</a>
<a name="ln4998">    return;</a>
<a name="ln4999">  }</a>
<a name="ln5000"> </a>
<a name="ln5001">  Channel *data = find_job(argvars[0].vval.v_number, false);</a>
<a name="ln5002">  if (!data) {</a>
<a name="ln5003">    return;</a>
<a name="ln5004">  }</a>
<a name="ln5005"> </a>
<a name="ln5006">  const char *error = NULL;</a>
<a name="ln5007">  if (data-&gt;is_rpc) {</a>
<a name="ln5008">    // Ignore return code, but show error later.</a>
<a name="ln5009">    (void)channel_close(data-&gt;id, kChannelPartRpc, &amp;error);</a>
<a name="ln5010">  }</a>
<a name="ln5011">  process_stop((Process *)&amp;data-&gt;stream.proc);</a>
<a name="ln5012">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5013">  if (error) {</a>
<a name="ln5014">    EMSG(error);</a>
<a name="ln5015">  }</a>
<a name="ln5016">}</a>
<a name="ln5017"> </a>
<a name="ln5018">// &quot;jobwait(ids[, timeout])&quot; function</a>
<a name="ln5019">static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5020">{</a>
<a name="ln5021">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5022">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5023"> </a>
<a name="ln5024">  if (check_restricted() || check_secure()) {</a>
<a name="ln5025">    return;</a>
<a name="ln5026">  }</a>
<a name="ln5027">  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5028">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln5029">    EMSG(_(e_invarg));</a>
<a name="ln5030">    return;</a>
<a name="ln5031">  }</a>
<a name="ln5032"> </a>
<a name="ln5033">  ui_busy_start();</a>
<a name="ln5034">  list_T *args = argvars[0].vval.v_list;</a>
<a name="ln5035">  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));</a>
<a name="ln5036">  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &amp;main_loop);</a>
<a name="ln5037"> </a>
<a name="ln5038">  // Validate, prepare jobs for waiting.</a>
<a name="ln5039">  int i = 0;</a>
<a name="ln5040">  TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln5041">    Channel *chan = NULL;</a>
<a name="ln5042">    if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_NUMBER</a>
<a name="ln5043">        || !(chan = find_job(TV_LIST_ITEM_TV(arg)-&gt;vval.v_number, false))) {</a>
<a name="ln5044">      jobs[i] = NULL;  // Invalid job.</a>
<a name="ln5045">    } else {</a>
<a name="ln5046">      jobs[i] = chan;</a>
<a name="ln5047">      channel_incref(chan);</a>
<a name="ln5048">      if (chan-&gt;stream.proc.status &lt; 0) {</a>
<a name="ln5049">        // Process any pending events on the job's queue before temporarily</a>
<a name="ln5050">        // replacing it.</a>
<a name="ln5051">        multiqueue_process_events(chan-&gt;events);</a>
<a name="ln5052">        multiqueue_replace_parent(chan-&gt;events, waiting_jobs);</a>
<a name="ln5053">      }</a>
<a name="ln5054">    }</a>
<a name="ln5055">    i++;</a>
<a name="ln5056">  });</a>
<a name="ln5057"> </a>
<a name="ln5058">  int remaining = -1;</a>
<a name="ln5059">  uint64_t before = 0;</a>
<a name="ln5060">  if (argvars[1].v_type == VAR_NUMBER &amp;&amp; argvars[1].vval.v_number &gt;= 0) {</a>
<a name="ln5061">    remaining = argvars[1].vval.v_number;</a>
<a name="ln5062">    before = os_hrtime();</a>
<a name="ln5063">  }</a>
<a name="ln5064"> </a>
<a name="ln5065">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5066">    if (remaining == 0) {</a>
<a name="ln5067">      break;  // Timeout.</a>
<a name="ln5068">    }</a>
<a name="ln5069">    if (jobs[i] == NULL) {</a>
<a name="ln5070">      continue;  // Invalid job, will assign status=-3 below.</a>
<a name="ln5071">    }</a>
<a name="ln5072">    int status = process_wait(&amp;jobs[i]-&gt;stream.proc, remaining,</a>
<a name="ln5073">                              waiting_jobs);</a>
<a name="ln5074">    if (status &lt; 0) {</a>
<a name="ln5075">      break;  // Interrupted (CTRL-C) or timeout, skip remaining jobs.</a>
<a name="ln5076">    }</a>
<a name="ln5077">    if (remaining &gt; 0) {</a>
<a name="ln5078">      uint64_t now = os_hrtime();</a>
<a name="ln5079">      remaining = MIN(0, remaining - (int)((now - before) / 1000000));</a>
<a name="ln5080">      before = now;</a>
<a name="ln5081">    }</a>
<a name="ln5082">  }</a>
<a name="ln5083"> </a>
<a name="ln5084">  list_T *const rv = tv_list_alloc(tv_list_len(args));</a>
<a name="ln5085"> </a>
<a name="ln5086">  // For each job:</a>
<a name="ln5087">  //  * Restore its parent queue if the job is still alive.</a>
<a name="ln5088">  //  * Append its status to the output list, or:</a>
<a name="ln5089">  //       -3 for &quot;invalid job id&quot;</a>
<a name="ln5090">  //       -2 for &quot;interrupted&quot; (user hit CTRL-C)</a>
<a name="ln5091">  //       -1 for jobs that were skipped or timed out</a>
<a name="ln5092">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5093">    if (jobs[i] == NULL) {</a>
<a name="ln5094">      tv_list_append_number(rv, -3);</a>
<a name="ln5095">      continue;</a>
<a name="ln5096">    }</a>
<a name="ln5097">    multiqueue_process_events(jobs[i]-&gt;events);</a>
<a name="ln5098">    multiqueue_replace_parent(jobs[i]-&gt;events, main_loop.events);</a>
<a name="ln5099"> </a>
<a name="ln5100">    tv_list_append_number(rv, jobs[i]-&gt;stream.proc.status);</a>
<a name="ln5101">    channel_decref(jobs[i]);</a>
<a name="ln5102">  }</a>
<a name="ln5103"> </a>
<a name="ln5104">  multiqueue_free(waiting_jobs);</a>
<a name="ln5105">  xfree(jobs);</a>
<a name="ln5106">  ui_busy_stop();</a>
<a name="ln5107">  tv_list_ref(rv);</a>
<a name="ln5108">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5109">  rettv-&gt;vval.v_list = rv;</a>
<a name="ln5110">}</a>
<a name="ln5111"> </a>
<a name="ln5112">/*</a>
<a name="ln5113"> * &quot;join()&quot; function</a>
<a name="ln5114"> */</a>
<a name="ln5115">static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5116">{</a>
<a name="ln5117">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5118">    EMSG(_(e_listreq));</a>
<a name="ln5119">    return;</a>
<a name="ln5120">  }</a>
<a name="ln5121">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln5122">                           ? &quot; &quot;</a>
<a name="ln5123">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln5124"> </a>
<a name="ln5125">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5126"> </a>
<a name="ln5127">  if (sep != NULL) {</a>
<a name="ln5128">    garray_T ga;</a>
<a name="ln5129">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5130">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln5131">    ga_append(&amp;ga, NUL);</a>
<a name="ln5132">    rettv-&gt;vval.v_string = (char_u *)ga.ga_data;</a>
<a name="ln5133">  } else {</a>
<a name="ln5134">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5135">  }</a>
<a name="ln5136">}</a>
<a name="ln5137"> </a>
<a name="ln5138">/// json_decode() function</a>
<a name="ln5139">static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5140">{</a>
<a name="ln5141">  char numbuf[NUMBUFLEN];</a>
<a name="ln5142">  const char *s = NULL;</a>
<a name="ln5143">  char *tofree = NULL;</a>
<a name="ln5144">  size_t len;</a>
<a name="ln5145">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5146">    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &amp;len, &amp;tofree)) {</a>
<a name="ln5147">      EMSG(_(&quot;E474: Failed to convert list to string&quot;));</a>
<a name="ln5148">      return;</a>
<a name="ln5149">    }</a>
<a name="ln5150">    s = tofree;</a>
<a name="ln5151">    if (s == NULL) {</a>
<a name="ln5152">      assert(len == 0);</a>
<a name="ln5153">      s = &quot;&quot;;</a>
<a name="ln5154">    }</a>
<a name="ln5155">  } else {</a>
<a name="ln5156">    s = tv_get_string_buf_chk(&amp;argvars[0], numbuf);</a>
<a name="ln5157">    if (s) {</a>
<a name="ln5158">      len = strlen(s);</a>
<a name="ln5159">    } else {</a>
<a name="ln5160">      return;</a>
<a name="ln5161">    }</a>
<a name="ln5162">  }</a>
<a name="ln5163">  if (json_decode_string(s, len, rettv) == FAIL) {</a>
<a name="ln5164">    emsgf(_(&quot;E474: Failed to parse %.*s&quot;), (int)len, s);</a>
<a name="ln5165">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5166">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln5167">  }</a>
<a name="ln5168">  assert(rettv-&gt;v_type != VAR_UNKNOWN);</a>
<a name="ln5169">  xfree(tofree);</a>
<a name="ln5170">}</a>
<a name="ln5171"> </a>
<a name="ln5172">/// json_encode() function</a>
<a name="ln5173">static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5174">{</a>
<a name="ln5175">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5176">  rettv-&gt;vval.v_string = (char_u *)encode_tv2json(&amp;argvars[0], NULL);</a>
<a name="ln5177">}</a>
<a name="ln5178"> </a>
<a name="ln5179">/*</a>
<a name="ln5180"> * &quot;keys()&quot; function</a>
<a name="ln5181"> */</a>
<a name="ln5182">static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5183">{</a>
<a name="ln5184">  dict_list(argvars, rettv, 0);</a>
<a name="ln5185">}</a>
<a name="ln5186"> </a>
<a name="ln5187">/*</a>
<a name="ln5188"> * &quot;last_buffer_nr()&quot; function.</a>
<a name="ln5189"> */</a>
<a name="ln5190">static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5191">{</a>
<a name="ln5192">  int n = 0;</a>
<a name="ln5193"> </a>
<a name="ln5194">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5195">    if (n &lt; buf-&gt;b_fnum) {</a>
<a name="ln5196">      n = buf-&gt;b_fnum;</a>
<a name="ln5197">    }</a>
<a name="ln5198">  }</a>
<a name="ln5199"> </a>
<a name="ln5200">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5201">}</a>
<a name="ln5202"> </a>
<a name="ln5203">/*</a>
<a name="ln5204"> * &quot;len()&quot; function</a>
<a name="ln5205"> */</a>
<a name="ln5206">static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5207">{</a>
<a name="ln5208">  switch (argvars[0].v_type) {</a>
<a name="ln5209">    case VAR_STRING:</a>
<a name="ln5210">    case VAR_NUMBER: {</a>
<a name="ln5211">      rettv-&gt;vval.v_number = (varnumber_T)strlen(</a>
<a name="ln5212">          tv_get_string(&amp;argvars[0]));</a>
<a name="ln5213">      break;</a>
<a name="ln5214">    }</a>
<a name="ln5215">    case VAR_LIST: {</a>
<a name="ln5216">      rettv-&gt;vval.v_number = tv_list_len(argvars[0].vval.v_list);</a>
<a name="ln5217">      break;</a>
<a name="ln5218">    }</a>
<a name="ln5219">    case VAR_DICT: {</a>
<a name="ln5220">      rettv-&gt;vval.v_number = tv_dict_len(argvars[0].vval.v_dict);</a>
<a name="ln5221">      break;</a>
<a name="ln5222">    }</a>
<a name="ln5223">    case VAR_UNKNOWN:</a>
<a name="ln5224">    case VAR_BOOL:</a>
<a name="ln5225">    case VAR_SPECIAL:</a>
<a name="ln5226">    case VAR_FLOAT:</a>
<a name="ln5227">    case VAR_PARTIAL:</a>
<a name="ln5228">    case VAR_FUNC: {</a>
<a name="ln5229">      EMSG(_(&quot;E701: Invalid type for len()&quot;));</a>
<a name="ln5230">      break;</a>
<a name="ln5231">    }</a>
<a name="ln5232">  }</a>
<a name="ln5233">}</a>
<a name="ln5234"> </a>
<a name="ln5235">static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)</a>
<a name="ln5236">{</a>
<a name="ln5237">  rettv-&gt;v_type = out_type;</a>
<a name="ln5238">  if (out_type != VAR_NUMBER) {</a>
<a name="ln5239">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5240">  }</a>
<a name="ln5241"> </a>
<a name="ln5242">  if (check_restricted() || check_secure()) {</a>
<a name="ln5243">    return;</a>
<a name="ln5244">  }</a>
<a name="ln5245"> </a>
<a name="ln5246">  // The first two args (libname and funcname) must be strings</a>
<a name="ln5247">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln5248">    return;</a>
<a name="ln5249">  }</a>
<a name="ln5250"> </a>
<a name="ln5251">  const char *libname = (char *)argvars[0].vval.v_string;</a>
<a name="ln5252">  const char *funcname = (char *)argvars[1].vval.v_string;</a>
<a name="ln5253"> </a>
<a name="ln5254">  VarType in_type = argvars[2].v_type;</a>
<a name="ln5255"> </a>
<a name="ln5256">  // input variables</a>
<a name="ln5257">  char *str_in = (in_type == VAR_STRING)</a>
<a name="ln5258">      ? (char *)argvars[2].vval.v_string : NULL;</a>
<a name="ln5259">  int int_in = argvars[2].vval.v_number;</a>
<a name="ln5260"> </a>
<a name="ln5261">  // output variables</a>
<a name="ln5262">  char **str_out = (out_type == VAR_STRING)</a>
<a name="ln5263">      ? (char **)&amp;rettv-&gt;vval.v_string : NULL;</a>
<a name="ln5264">  int int_out = 0;</a>
<a name="ln5265"> </a>
<a name="ln5266">  bool success = os_libcall(libname, funcname,</a>
<a name="ln5267">                            str_in, int_in,</a>
<a name="ln5268">                            str_out, &amp;int_out);</a>
<a name="ln5269"> </a>
<a name="ln5270">  if (!success) {</a>
<a name="ln5271">    EMSG2(_(e_libcall), funcname);</a>
<a name="ln5272">    return;</a>
<a name="ln5273">  }</a>
<a name="ln5274"> </a>
<a name="ln5275">  if (out_type == VAR_NUMBER) {</a>
<a name="ln5276">     rettv-&gt;vval.v_number = (varnumber_T)int_out;</a>
<a name="ln5277">  }</a>
<a name="ln5278">}</a>
<a name="ln5279"> </a>
<a name="ln5280">/*</a>
<a name="ln5281"> * &quot;libcall()&quot; function</a>
<a name="ln5282"> */</a>
<a name="ln5283">static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5284">{</a>
<a name="ln5285">  libcall_common(argvars, rettv, VAR_STRING);</a>
<a name="ln5286">}</a>
<a name="ln5287"> </a>
<a name="ln5288">/*</a>
<a name="ln5289"> * &quot;libcallnr()&quot; function</a>
<a name="ln5290"> */</a>
<a name="ln5291">static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5292">{</a>
<a name="ln5293">  libcall_common(argvars, rettv, VAR_NUMBER);</a>
<a name="ln5294">}</a>
<a name="ln5295"> </a>
<a name="ln5296">/*</a>
<a name="ln5297"> * &quot;line(string)&quot; function</a>
<a name="ln5298"> */</a>
<a name="ln5299">static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5300">{</a>
<a name="ln5301">  linenr_T lnum = 0;</a>
<a name="ln5302">  pos_T       *fp;</a>
<a name="ln5303">  int fnum;</a>
<a name="ln5304"> </a>
<a name="ln5305">  fp = var2fpos(&amp;argvars[0], TRUE, &amp;fnum);</a>
<a name="ln5306">  if (fp != NULL)</a>
<a name="ln5307">    lnum = fp-&gt;lnum;</a>
<a name="ln5308">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln5309">}</a>
<a name="ln5310"> </a>
<a name="ln5311">/*</a>
<a name="ln5312"> * &quot;line2byte(lnum)&quot; function</a>
<a name="ln5313"> */</a>
<a name="ln5314">static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5315">{</a>
<a name="ln5316">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5317">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5318">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5319">  } else {</a>
<a name="ln5320">    rettv-&gt;vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL, false);</a>
<a name="ln5321">  }</a>
<a name="ln5322">  if (rettv-&gt;vval.v_number &gt;= 0) {</a>
<a name="ln5323">    rettv-&gt;vval.v_number++;</a>
<a name="ln5324">  }</a>
<a name="ln5325">}</a>
<a name="ln5326"> </a>
<a name="ln5327">/*</a>
<a name="ln5328"> * &quot;lispindent(lnum)&quot; function</a>
<a name="ln5329"> */</a>
<a name="ln5330">static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5331">{</a>
<a name="ln5332">  const pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5333">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5334">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5335">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5336">    rettv-&gt;vval.v_number = get_lisp_indent();</a>
<a name="ln5337">    curwin-&gt;w_cursor = pos;</a>
<a name="ln5338">  } else {</a>
<a name="ln5339">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5340">  }</a>
<a name="ln5341">}</a>
<a name="ln5342"> </a>
<a name="ln5343">// &quot;list2str()&quot; function</a>
<a name="ln5344">static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5345">{</a>
<a name="ln5346">  garray_T ga;</a>
<a name="ln5347"> </a>
<a name="ln5348">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5349">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5350">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5351">    EMSG(_(e_invarg));</a>
<a name="ln5352">    return;</a>
<a name="ln5353">  }</a>
<a name="ln5354"> </a>
<a name="ln5355">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln5356">  if (l == NULL) {</a>
<a name="ln5357">    return;  // empty list results in empty string</a>
<a name="ln5358">  }</a>
<a name="ln5359"> </a>
<a name="ln5360">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln5361">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5362"> </a>
<a name="ln5363">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln5364">    buf[utf_char2bytes(tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln5365">    ga_concat(&amp;ga, buf);</a>
<a name="ln5366">  });</a>
<a name="ln5367">  ga_append(&amp;ga, NUL);</a>
<a name="ln5368"> </a>
<a name="ln5369">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5370">}</a>
<a name="ln5371"> </a>
<a name="ln5372">/*</a>
<a name="ln5373"> * &quot;localtime()&quot; function</a>
<a name="ln5374"> */</a>
<a name="ln5375">static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5376">{</a>
<a name="ln5377">  rettv-&gt;vval.v_number = (varnumber_T)time(NULL);</a>
<a name="ln5378">}</a>
<a name="ln5379"> </a>
<a name="ln5380"> </a>
<a name="ln5381">static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)</a>
<a name="ln5382">{</a>
<a name="ln5383">  char_u *keys_buf = NULL;</a>
<a name="ln5384">  char_u *rhs;</a>
<a name="ln5385">  int mode;</a>
<a name="ln5386">  int abbr = FALSE;</a>
<a name="ln5387">  int get_dict = FALSE;</a>
<a name="ln5388">  mapblock_T  *mp;</a>
<a name="ln5389">  int buffer_local;</a>
<a name="ln5390"> </a>
<a name="ln5391">  // Return empty string for failure.</a>
<a name="ln5392">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5393">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5394"> </a>
<a name="ln5395">  char_u *keys = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5396">  if (*keys == NUL) {</a>
<a name="ln5397">    return;</a>
<a name="ln5398">  }</a>
<a name="ln5399"> </a>
<a name="ln5400">  char buf[NUMBUFLEN];</a>
<a name="ln5401">  const char *which;</a>
<a name="ln5402">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5403">    which = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5404">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5405">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln5406">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5407">        get_dict = tv_get_number(&amp;argvars[3]);</a>
<a name="ln5408">      }</a>
<a name="ln5409">    }</a>
<a name="ln5410">  } else {</a>
<a name="ln5411">    which = &quot;&quot;;</a>
<a name="ln5412">  }</a>
<a name="ln5413">  if (which == NULL) {</a>
<a name="ln5414">    return;</a>
<a name="ln5415">  }</a>
<a name="ln5416"> </a>
<a name="ln5417">  mode = get_map_mode((char_u **)&amp;which, 0);</a>
<a name="ln5418"> </a>
<a name="ln5419">  keys = replace_termcodes(keys, STRLEN(keys), &amp;keys_buf, true, true, true,</a>
<a name="ln5420">                           CPO_TO_CPO_FLAGS);</a>
<a name="ln5421">  rhs = check_map(keys, mode, exact, false, abbr, &amp;mp, &amp;buffer_local);</a>
<a name="ln5422">  xfree(keys_buf);</a>
<a name="ln5423"> </a>
<a name="ln5424">  if (!get_dict) {</a>
<a name="ln5425">    // Return a string.</a>
<a name="ln5426">    if (rhs != NULL) {</a>
<a name="ln5427">      if (*rhs == NUL) {</a>
<a name="ln5428">        rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;&lt;Nop&gt;&quot;);</a>
<a name="ln5429">      } else {</a>
<a name="ln5430">        rettv-&gt;vval.v_string = (char_u *)str2special_save(</a>
<a name="ln5431">            (char *)rhs, false, false);</a>
<a name="ln5432">      }</a>
<a name="ln5433">    }</a>
<a name="ln5434"> </a>
<a name="ln5435">  } else {</a>
<a name="ln5436">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5437">    if (rhs != NULL) {</a>
<a name="ln5438">      // Return a dictionary.</a>
<a name="ln5439">      mapblock_fill_dict(rettv-&gt;vval.v_dict, mp, buffer_local, true);</a>
<a name="ln5440">    }</a>
<a name="ln5441">  }</a>
<a name="ln5442">}</a>
<a name="ln5443"> </a>
<a name="ln5444">/// luaeval() function implementation</a>
<a name="ln5445">static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5446">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5447">{</a>
<a name="ln5448">  const char *const str = (const char *)tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5449">  if (str == NULL) {</a>
<a name="ln5450">    return;</a>
<a name="ln5451">  }</a>
<a name="ln5452"> </a>
<a name="ln5453">  nlua_typval_eval(cstr_as_string((char *)str), &amp;argvars[1], rettv);</a>
<a name="ln5454">}</a>
<a name="ln5455"> </a>
<a name="ln5456">/*</a>
<a name="ln5457"> * &quot;map()&quot; function</a>
<a name="ln5458"> */</a>
<a name="ln5459">static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5460">{</a>
<a name="ln5461">  filter_map(argvars, rettv, TRUE);</a>
<a name="ln5462">}</a>
<a name="ln5463"> </a>
<a name="ln5464">/*</a>
<a name="ln5465"> * &quot;maparg()&quot; function</a>
<a name="ln5466"> */</a>
<a name="ln5467">static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5468">{</a>
<a name="ln5469">  get_maparg(argvars, rettv, TRUE);</a>
<a name="ln5470">}</a>
<a name="ln5471"> </a>
<a name="ln5472">/*</a>
<a name="ln5473"> * &quot;mapcheck()&quot; function</a>
<a name="ln5474"> */</a>
<a name="ln5475">static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5476">{</a>
<a name="ln5477">  get_maparg(argvars, rettv, FALSE);</a>
<a name="ln5478">}</a>
<a name="ln5479"> </a>
<a name="ln5480"> </a>
<a name="ln5481">static void find_some_match(typval_T *const argvars, typval_T *const rettv,</a>
<a name="ln5482">                            const SomeMatchType type)</a>
<a name="ln5483">{</a>
<a name="ln5484">  char_u      *str = NULL;</a>
<a name="ln5485">  long        len = 0;</a>
<a name="ln5486">  char_u      *expr = NULL;</a>
<a name="ln5487">  regmatch_T regmatch;</a>
<a name="ln5488">  char_u      *save_cpo;</a>
<a name="ln5489">  long start = 0;</a>
<a name="ln5490">  long nth = 1;</a>
<a name="ln5491">  colnr_T startcol = 0;</a>
<a name="ln5492">  bool match = false;</a>
<a name="ln5493">  list_T      *l = NULL;</a>
<a name="ln5494">  listitem_T  *li = NULL;</a>
<a name="ln5495">  long idx = 0;</a>
<a name="ln5496">  char_u      *tofree = NULL;</a>
<a name="ln5497"> </a>
<a name="ln5498">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln5499">  save_cpo = p_cpo;</a>
<a name="ln5500">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5501"> </a>
<a name="ln5502">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5503">  switch (type) {</a>
<a name="ln5504">    // matchlist(): return empty list when there are no matches.</a>
<a name="ln5505">    case kSomeMatchList: {</a>
<a name="ln5506">      tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln5507">      break;</a>
<a name="ln5508">    }</a>
<a name="ln5509">    // matchstrpos(): return [&quot;&quot;, -1, -1, -1]</a>
<a name="ln5510">    case kSomeMatchStrPos: {</a>
<a name="ln5511">      tv_list_alloc_ret(rettv, 4);</a>
<a name="ln5512">      tv_list_append_string(rettv-&gt;vval.v_list, &quot;&quot;, 0);</a>
<a name="ln5513">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5514">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5515">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5516">      break;</a>
<a name="ln5517">    }</a>
<a name="ln5518">    case kSomeMatchStr: {</a>
<a name="ln5519">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5520">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5521">      break;</a>
<a name="ln5522">    }</a>
<a name="ln5523">    case kSomeMatch:</a>
<a name="ln5524">    case kSomeMatchEnd: {</a>
<a name="ln5525">      // Do nothing: zero is default.</a>
<a name="ln5526">      break;</a>
<a name="ln5527">    }</a>
<a name="ln5528">  }</a>
<a name="ln5529"> </a>
<a name="ln5530">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5531">    if ((l = argvars[0].vval.v_list) == NULL) {</a>
<a name="ln5532">      goto theend;</a>
<a name="ln5533">    }</a>
<a name="ln5534">    li = tv_list_first(l);</a>
<a name="ln5535">  } else {</a>
<a name="ln5536">    expr = str = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5537">    len = (long)STRLEN(str);</a>
<a name="ln5538">  }</a>
<a name="ln5539"> </a>
<a name="ln5540">  char patbuf[NUMBUFLEN];</a>
<a name="ln5541">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5542">  if (pat == NULL) {</a>
<a name="ln5543">    goto theend;</a>
<a name="ln5544">  }</a>
<a name="ln5545"> </a>
<a name="ln5546">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5547">    bool error = false;</a>
<a name="ln5548"> </a>
<a name="ln5549">    start = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5550">    if (error) {</a>
<a name="ln5551">      goto theend;</a>
<a name="ln5552">    }</a>
<a name="ln5553">    if (l != NULL) {</a>
<a name="ln5554">      idx = tv_list_uidx(l, start);</a>
<a name="ln5555">      if (idx == -1) {</a>
<a name="ln5556">        goto theend;</a>
<a name="ln5557">      }</a>
<a name="ln5558">      li = tv_list_find(l, idx);</a>
<a name="ln5559">    } else {</a>
<a name="ln5560">      if (start &lt; 0)</a>
<a name="ln5561">        start = 0;</a>
<a name="ln5562">      if (start &gt; len)</a>
<a name="ln5563">        goto theend;</a>
<a name="ln5564">      // When &quot;count&quot; argument is there ignore matches before &quot;start&quot;,</a>
<a name="ln5565">      // otherwise skip part of the string.  Differs when pattern is &quot;^&quot;</a>
<a name="ln5566">      // or &quot;\&lt;&quot;.</a>
<a name="ln5567">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5568">        startcol = start;</a>
<a name="ln5569">      } else {</a>
<a name="ln5570">        str += start;</a>
<a name="ln5571">        len -= start;</a>
<a name="ln5572">      }</a>
<a name="ln5573">    }</a>
<a name="ln5574"> </a>
<a name="ln5575">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5576">      nth = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5577">    }</a>
<a name="ln5578">    if (error) {</a>
<a name="ln5579">      goto theend;</a>
<a name="ln5580">    }</a>
<a name="ln5581">  }</a>
<a name="ln5582"> </a>
<a name="ln5583">  regmatch.regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING);</a>
<a name="ln5584">  if (regmatch.regprog != NULL) {</a>
<a name="ln5585">    regmatch.rm_ic = p_ic;</a>
<a name="ln5586"> </a>
<a name="ln5587">    for (;; ) {</a>
<a name="ln5588">      if (l != NULL) {</a>
<a name="ln5589">        if (li == NULL) {</a>
<a name="ln5590">          match = false;</a>
<a name="ln5591">          break;</a>
<a name="ln5592">        }</a>
<a name="ln5593">        xfree(tofree);</a>
<a name="ln5594">        tofree = expr = str = (char_u *)encode_tv2echo(TV_LIST_ITEM_TV(li),</a>
<a name="ln5595">                                                       NULL);</a>
<a name="ln5596">        if (str == NULL) {</a>
<a name="ln5597">          break;</a>
<a name="ln5598">        }</a>
<a name="ln5599">      }</a>
<a name="ln5600"> </a>
<a name="ln5601">      match = vim_regexec_nl(&amp;regmatch, str, (colnr_T)startcol);</a>
<a name="ln5602"> </a>
<a name="ln5603">      if (match &amp;&amp; --nth &lt;= 0)</a>
<a name="ln5604">        break;</a>
<a name="ln5605">      if (l == NULL &amp;&amp; !match)</a>
<a name="ln5606">        break;</a>
<a name="ln5607"> </a>
<a name="ln5608">      // Advance to just after the match.</a>
<a name="ln5609">      if (l != NULL) {</a>
<a name="ln5610">        li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5611">        idx++;</a>
<a name="ln5612">      } else {</a>
<a name="ln5613">        startcol = (colnr_T)(regmatch.startp[0]</a>
<a name="ln5614">                             + (*mb_ptr2len)(regmatch.startp[0]) - str);</a>
<a name="ln5615">        if (startcol &gt; (colnr_T)len || str + startcol &lt;= regmatch.startp[0]) {</a>
<a name="ln5616">            match = false;</a>
<a name="ln5617">            break;</a>
<a name="ln5618">        }</a>
<a name="ln5619">      }</a>
<a name="ln5620">    }</a>
<a name="ln5621"> </a>
<a name="ln5622">    if (match) {</a>
<a name="ln5623">      switch (type) {</a>
<a name="ln5624">        case kSomeMatchStrPos: {</a>
<a name="ln5625">          list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5626">          listitem_T *li1 = tv_list_first(ret_l);</a>
<a name="ln5627">          listitem_T *li2 = TV_LIST_ITEM_NEXT(ret_l, li1);</a>
<a name="ln5628">          listitem_T *li3 = TV_LIST_ITEM_NEXT(ret_l, li2);</a>
<a name="ln5629">          listitem_T *li4 = TV_LIST_ITEM_NEXT(ret_l, li3);</a>
<a name="ln5630">          xfree(TV_LIST_ITEM_TV(li1)-&gt;vval.v_string);</a>
<a name="ln5631"> </a>
<a name="ln5632">          const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);</a>
<a name="ln5633">          TV_LIST_ITEM_TV(li1)-&gt;vval.v_string = xmemdupz(</a>
<a name="ln5634">              (const char *)regmatch.startp[0], rd);</a>
<a name="ln5635">          TV_LIST_ITEM_TV(li3)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5636">              regmatch.startp[0] - expr);</a>
<a name="ln5637">          TV_LIST_ITEM_TV(li4)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5638">              regmatch.endp[0] - expr);</a>
<a name="ln5639">          if (l != NULL) {</a>
<a name="ln5640">            TV_LIST_ITEM_TV(li2)-&gt;vval.v_number = (varnumber_T)idx;</a>
<a name="ln5641">          }</a>
<a name="ln5642">          break;</a>
<a name="ln5643">        }</a>
<a name="ln5644">        case kSomeMatchList: {</a>
<a name="ln5645">          // Return list with matched string and submatches.</a>
<a name="ln5646">          for (int i = 0; i &lt; NSUBEXP; i++) {</a>
<a name="ln5647">            if (regmatch.endp[i] == NULL) {</a>
<a name="ln5648">              tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5649">            } else {</a>
<a name="ln5650">              tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5651">                                    (const char *)regmatch.startp[i],</a>
<a name="ln5652">                                    (regmatch.endp[i] - regmatch.startp[i]));</a>
<a name="ln5653">            }</a>
<a name="ln5654">          }</a>
<a name="ln5655">          break;</a>
<a name="ln5656">        }</a>
<a name="ln5657">        case kSomeMatchStr: {</a>
<a name="ln5658">          // Return matched string.</a>
<a name="ln5659">          if (l != NULL) {</a>
<a name="ln5660">            tv_copy(TV_LIST_ITEM_TV(li), rettv);</a>
<a name="ln5661">          } else {</a>
<a name="ln5662">            rettv-&gt;vval.v_string = (char_u *)xmemdupz(</a>
<a name="ln5663">                (const char *)regmatch.startp[0],</a>
<a name="ln5664">                (size_t)(regmatch.endp[0] - regmatch.startp[0]));</a>
<a name="ln5665">          }</a>
<a name="ln5666">          break;</a>
<a name="ln5667">        }</a>
<a name="ln5668">        case kSomeMatch:</a>
<a name="ln5669">        case kSomeMatchEnd: {</a>
<a name="ln5670">          if (l != NULL) {</a>
<a name="ln5671">            rettv-&gt;vval.v_number = idx;</a>
<a name="ln5672">          } else {</a>
<a name="ln5673">            if (type == kSomeMatch) {</a>
<a name="ln5674">              rettv-&gt;vval.v_number =</a>
<a name="ln5675">                (varnumber_T)(regmatch.startp[0] - str);</a>
<a name="ln5676">            } else {</a>
<a name="ln5677">              rettv-&gt;vval.v_number =</a>
<a name="ln5678">                (varnumber_T)(regmatch.endp[0] - str);</a>
<a name="ln5679">            }</a>
<a name="ln5680">            rettv-&gt;vval.v_number += (varnumber_T)(str - expr);</a>
<a name="ln5681">          }</a>
<a name="ln5682">          break;</a>
<a name="ln5683">        }</a>
<a name="ln5684">      }</a>
<a name="ln5685">    }</a>
<a name="ln5686">    vim_regfree(regmatch.regprog);</a>
<a name="ln5687">  }</a>
<a name="ln5688"> </a>
<a name="ln5689">theend:</a>
<a name="ln5690">  if (type == kSomeMatchStrPos &amp;&amp; l == NULL &amp;&amp; rettv-&gt;vval.v_list != NULL) {</a>
<a name="ln5691">    // matchstrpos() without a list: drop the second item</a>
<a name="ln5692">    list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5693">    tv_list_item_remove(ret_l, TV_LIST_ITEM_NEXT(ret_l, tv_list_first(ret_l)));</a>
<a name="ln5694">  }</a>
<a name="ln5695"> </a>
<a name="ln5696">  xfree(tofree);</a>
<a name="ln5697">  p_cpo = save_cpo;</a>
<a name="ln5698">}</a>
<a name="ln5699"> </a>
<a name="ln5700">/*</a>
<a name="ln5701"> * &quot;match()&quot; function</a>
<a name="ln5702"> */</a>
<a name="ln5703">static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5704">{</a>
<a name="ln5705">  find_some_match(argvars, rettv, kSomeMatch);</a>
<a name="ln5706">}</a>
<a name="ln5707"> </a>
<a name="ln5708">/*</a>
<a name="ln5709"> * &quot;matchadd()&quot; function</a>
<a name="ln5710"> */</a>
<a name="ln5711">static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5712">{</a>
<a name="ln5713">  char grpbuf[NUMBUFLEN];</a>
<a name="ln5714">  char patbuf[NUMBUFLEN];</a>
<a name="ln5715">  // group</a>
<a name="ln5716">  const char *const grp = tv_get_string_buf_chk(&amp;argvars[0], grpbuf);</a>
<a name="ln5717">  // pattern</a>
<a name="ln5718">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5719">  // default priority</a>
<a name="ln5720">  int prio = 10;</a>
<a name="ln5721">  int id = -1;</a>
<a name="ln5722">  bool error = false;</a>
<a name="ln5723">  const char *conceal_char = NULL;</a>
<a name="ln5724">  win_T *win = curwin;</a>
<a name="ln5725"> </a>
<a name="ln5726">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5727"> </a>
<a name="ln5728">  if (grp == NULL || pat == NULL) {</a>
<a name="ln5729">    return;</a>
<a name="ln5730">  }</a>
<a name="ln5731">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5732">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5733">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5734">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5735">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5736">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5737">        return;</a>
<a name="ln5738">      }</a>
<a name="ln5739">    }</a>
<a name="ln5740">  }</a>
<a name="ln5741">  if (error) {</a>
<a name="ln5742">    return;</a>
<a name="ln5743">  }</a>
<a name="ln5744">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln5745">    EMSGN(_(&quot;E798: ID is reserved for \&quot;:match\&quot;: %&quot; PRId64), id);</a>
<a name="ln5746">    return;</a>
<a name="ln5747">  }</a>
<a name="ln5748"> </a>
<a name="ln5749">  rettv-&gt;vval.v_number = match_add(win, grp, pat, prio, id, NULL, conceal_char);</a>
<a name="ln5750">}</a>
<a name="ln5751"> </a>
<a name="ln5752">static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5753">{</a>
<a name="ln5754">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5755"> </a>
<a name="ln5756">  char buf[NUMBUFLEN];</a>
<a name="ln5757">  const char *const group = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln5758">  if (group == NULL) {</a>
<a name="ln5759">    return;</a>
<a name="ln5760">  }</a>
<a name="ln5761"> </a>
<a name="ln5762">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln5763">    EMSG2(_(e_listarg), &quot;matchaddpos()&quot;);</a>
<a name="ln5764">    return;</a>
<a name="ln5765">  }</a>
<a name="ln5766"> </a>
<a name="ln5767">  list_T *l;</a>
<a name="ln5768">  l = argvars[1].vval.v_list;</a>
<a name="ln5769">  if (l == NULL) {</a>
<a name="ln5770">    return;</a>
<a name="ln5771">  }</a>
<a name="ln5772"> </a>
<a name="ln5773">  bool error = false;</a>
<a name="ln5774">  int prio = 10;</a>
<a name="ln5775">  int id = -1;</a>
<a name="ln5776">  const char *conceal_char = NULL;</a>
<a name="ln5777">  win_T *win = curwin;</a>
<a name="ln5778"> </a>
<a name="ln5779">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5780">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5781">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5782">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5783">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln5784">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln5785">        return;</a>
<a name="ln5786">      }</a>
<a name="ln5787">    }</a>
<a name="ln5788">  }</a>
<a name="ln5789">  if (error == true) {</a>
<a name="ln5790">    return;</a>
<a name="ln5791">  }</a>
<a name="ln5792"> </a>
<a name="ln5793">  // id == 3 is ok because matchaddpos() is supposed to substitute :3match</a>
<a name="ln5794">  if (id == 1 || id == 2) {</a>
<a name="ln5795">    EMSGN(_(&quot;E798: ID is reserved for \&quot;match\&quot;: %&quot; PRId64), id);</a>
<a name="ln5796">    return;</a>
<a name="ln5797">  }</a>
<a name="ln5798"> </a>
<a name="ln5799">  rettv-&gt;vval.v_number = match_add(win, group, NULL, prio, id, l, conceal_char);</a>
<a name="ln5800">}</a>
<a name="ln5801"> </a>
<a name="ln5802">/*</a>
<a name="ln5803"> * &quot;matcharg()&quot; function</a>
<a name="ln5804"> */</a>
<a name="ln5805">static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5806">{</a>
<a name="ln5807">  const int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln5808"> </a>
<a name="ln5809">  tv_list_alloc_ret(rettv, (id &gt;= 1 &amp;&amp; id &lt;= 3</a>
<a name="ln5810">                            ? 2</a>
<a name="ln5811">                            : 0));</a>
<a name="ln5812"> </a>
<a name="ln5813">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln5814">    matchitem_T *const m = (matchitem_T *)get_match(curwin, id);</a>
<a name="ln5815"> </a>
<a name="ln5816">    if (m != NULL) {</a>
<a name="ln5817">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5818">                            (const char *)syn_id2name(m-&gt;hlg_id), -1);</a>
<a name="ln5819">      tv_list_append_string(rettv-&gt;vval.v_list, (const char *)m-&gt;pattern, -1);</a>
<a name="ln5820">    } else {</a>
<a name="ln5821">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5822">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5823">    }</a>
<a name="ln5824">  }</a>
<a name="ln5825">}</a>
<a name="ln5826"> </a>
<a name="ln5827">/*</a>
<a name="ln5828"> * &quot;matchdelete()&quot; function</a>
<a name="ln5829"> */</a>
<a name="ln5830">static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5831">{</a>
<a name="ln5832">  win_T   *win = get_optional_window(argvars, 1);</a>
<a name="ln5833">  if (win == NULL) {</a>
<a name="ln5834">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5835">  } else {</a>
<a name="ln5836">    rettv-&gt;vval.v_number = match_delete(win,</a>
<a name="ln5837">                                        (int)tv_get_number(&amp;argvars[0]), true);</a>
<a name="ln5838">  }</a>
<a name="ln5839">}</a>
<a name="ln5840"> </a>
<a name="ln5841">/*</a>
<a name="ln5842"> * &quot;matchend()&quot; function</a>
<a name="ln5843"> */</a>
<a name="ln5844">static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5845">{</a>
<a name="ln5846">  find_some_match(argvars, rettv, kSomeMatchEnd);</a>
<a name="ln5847">}</a>
<a name="ln5848"> </a>
<a name="ln5849">/*</a>
<a name="ln5850"> * &quot;matchlist()&quot; function</a>
<a name="ln5851"> */</a>
<a name="ln5852">static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5853">{</a>
<a name="ln5854">  find_some_match(argvars, rettv, kSomeMatchList);</a>
<a name="ln5855">}</a>
<a name="ln5856"> </a>
<a name="ln5857">/*</a>
<a name="ln5858"> * &quot;matchstr()&quot; function</a>
<a name="ln5859"> */</a>
<a name="ln5860">static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5861">{</a>
<a name="ln5862">  find_some_match(argvars, rettv, kSomeMatchStr);</a>
<a name="ln5863">}</a>
<a name="ln5864"> </a>
<a name="ln5865">/// &quot;matchstrpos()&quot; function</a>
<a name="ln5866">static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5867">{</a>
<a name="ln5868">  find_some_match(argvars, rettv, kSomeMatchStrPos);</a>
<a name="ln5869">}</a>
<a name="ln5870"> </a>
<a name="ln5871">/// Get maximal/minimal number value in a list or dictionary</a>
<a name="ln5872">///</a>
<a name="ln5873">/// @param[in]  tv  List or dictionary to work with. If it contains something</a>
<a name="ln5874">///                 that is not an integer number (or cannot be coerced to</a>
<a name="ln5875">///                 it) error is given.</a>
<a name="ln5876">/// @param[out]  rettv  Location where result will be saved. Only assigns</a>
<a name="ln5877">///                     vval.v_number, type is not touched. Returns zero for</a>
<a name="ln5878">///                     empty lists/dictionaries.</a>
<a name="ln5879">/// @param[in]  domax  Determines whether maximal or minimal value is desired.</a>
<a name="ln5880">static void max_min(const typval_T *const tv, typval_T *const rettv,</a>
<a name="ln5881">                    const bool domax)</a>
<a name="ln5882">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5883">{</a>
<a name="ln5884">  bool error = false;</a>
<a name="ln5885"> </a>
<a name="ln5886">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5887">  varnumber_T n = (domax ? VARNUMBER_MIN : VARNUMBER_MAX);</a>
<a name="ln5888">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln5889">    if (tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln5890">      return;</a>
<a name="ln5891">    }</a>
<a name="ln5892">    TV_LIST_ITER_CONST(tv-&gt;vval.v_list, li, {</a>
<a name="ln5893">      const varnumber_T i = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln5894">      if (error) {</a>
<a name="ln5895">        return;</a>
<a name="ln5896">      }</a>
<a name="ln5897">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln5898">        n = i;</a>
<a name="ln5899">      }</a>
<a name="ln5900">    });</a>
<a name="ln5901">  } else if (tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln5902">    if (tv_dict_len(tv-&gt;vval.v_dict) == 0) {</a>
<a name="ln5903">      return;</a>
<a name="ln5904">    }</a>
<a name="ln5905">    TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln5906">      const varnumber_T i = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln5907">      if (error) {</a>
<a name="ln5908">        return;</a>
<a name="ln5909">      }</a>
<a name="ln5910">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln5911">        n = i;</a>
<a name="ln5912">      }</a>
<a name="ln5913">    });</a>
<a name="ln5914">  } else {</a>
<a name="ln5915">    EMSG2(_(e_listdictarg), domax ? &quot;max()&quot; : &quot;min()&quot;);</a>
<a name="ln5916">    return;</a>
<a name="ln5917">  }</a>
<a name="ln5918">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5919">}</a>
<a name="ln5920"> </a>
<a name="ln5921">/*</a>
<a name="ln5922"> * &quot;max()&quot; function</a>
<a name="ln5923"> */</a>
<a name="ln5924">static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5925">{</a>
<a name="ln5926">  max_min(argvars, rettv, TRUE);</a>
<a name="ln5927">}</a>
<a name="ln5928"> </a>
<a name="ln5929">/*</a>
<a name="ln5930"> * &quot;min()&quot; function</a>
<a name="ln5931"> */</a>
<a name="ln5932">static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5933">{</a>
<a name="ln5934">  max_min(argvars, rettv, FALSE);</a>
<a name="ln5935">}</a>
<a name="ln5936"> </a>
<a name="ln5937">/*</a>
<a name="ln5938"> * &quot;mkdir()&quot; function</a>
<a name="ln5939"> */</a>
<a name="ln5940">static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5941">{</a>
<a name="ln5942">  int prot = 0755;  // -V536</a>
<a name="ln5943"> </a>
<a name="ln5944">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln5945">  if (check_restricted() || check_secure())</a>
<a name="ln5946">    return;</a>
<a name="ln5947"> </a>
<a name="ln5948">  char buf[NUMBUFLEN];</a>
<a name="ln5949">  const char *const dir = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln5950">  if (*dir == NUL) {</a>
<a name="ln5951">    return;</a>
<a name="ln5952">  }</a>
<a name="ln5953"> </a>
<a name="ln5954">  if (*path_tail((char_u *)dir) == NUL) {</a>
<a name="ln5955">    // Remove trailing slashes.</a>
<a name="ln5956">    *path_tail_with_sep((char_u *)dir) = NUL;</a>
<a name="ln5957">  }</a>
<a name="ln5958"> </a>
<a name="ln5959">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5960">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5961">      prot = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln5962">      if (prot == -1) {</a>
<a name="ln5963">        return;</a>
<a name="ln5964">      }</a>
<a name="ln5965">    }</a>
<a name="ln5966">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;p&quot;) == 0) {</a>
<a name="ln5967">      char *failed_dir;</a>
<a name="ln5968">      int ret = os_mkdir_recurse(dir, prot, &amp;failed_dir);</a>
<a name="ln5969">      if (ret != 0) {</a>
<a name="ln5970">        EMSG3(_(e_mkdir), failed_dir, os_strerror(ret));</a>
<a name="ln5971">        xfree(failed_dir);</a>
<a name="ln5972">        rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln5973">        return;</a>
<a name="ln5974">      } else {</a>
<a name="ln5975">        rettv-&gt;vval.v_number = OK;</a>
<a name="ln5976">        return;</a>
<a name="ln5977">      }</a>
<a name="ln5978">    }</a>
<a name="ln5979">  }</a>
<a name="ln5980">  rettv-&gt;vval.v_number = vim_mkdir_emsg(dir, prot);</a>
<a name="ln5981">}</a>
<a name="ln5982"> </a>
<a name="ln5983">/// &quot;mode()&quot; function</a>
<a name="ln5984">static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5985">{</a>
<a name="ln5986">  char *mode = get_mode();</a>
<a name="ln5987"> </a>
<a name="ln5988">  // Clear out the minor mode when the argument is not a non-zero number or</a>
<a name="ln5989">  // non-empty string.</a>
<a name="ln5990">  if (!non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln5991">    mode[1] = NUL;</a>
<a name="ln5992">  }</a>
<a name="ln5993"> </a>
<a name="ln5994">  rettv-&gt;vval.v_string = (char_u *)mode;</a>
<a name="ln5995">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5996">}</a>
<a name="ln5997"> </a>
<a name="ln5998">/// &quot;msgpackdump()&quot; function</a>
<a name="ln5999">static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6000">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6001">{</a>
<a name="ln6002">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6003">    EMSG2(_(e_listarg), &quot;msgpackdump()&quot;);</a>
<a name="ln6004">    return;</a>
<a name="ln6005">  }</a>
<a name="ln6006">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6007">  list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6008">  msgpack_packer *lpacker = msgpack_packer_new(ret_list, &amp;encode_list_write);</a>
<a name="ln6009">  const char *const msg = _(&quot;msgpackdump() argument, index %i&quot;);</a>
<a name="ln6010">  // Assume that translation will not take more then 4 times more space</a>
<a name="ln6011">  char msgbuf[sizeof(&quot;msgpackdump() argument, index &quot;) * 4 + NUMBUFLEN];</a>
<a name="ln6012">  int idx = 0;</a>
<a name="ln6013">  TV_LIST_ITER(list, li, {</a>
<a name="ln6014">    vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx);</a>
<a name="ln6015">    idx++;</a>
<a name="ln6016">    if (encode_vim_to_msgpack(lpacker, TV_LIST_ITEM_TV(li), msgbuf) == FAIL) {</a>
<a name="ln6017">      break;</a>
<a name="ln6018">    }</a>
<a name="ln6019">  });</a>
<a name="ln6020">  msgpack_packer_free(lpacker);</a>
<a name="ln6021">}</a>
<a name="ln6022"> </a>
<a name="ln6023">/// &quot;msgpackparse&quot; function</a>
<a name="ln6024">static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6025">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6026">{</a>
<a name="ln6027">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6028">    EMSG2(_(e_listarg), &quot;msgpackparse()&quot;);</a>
<a name="ln6029">    return;</a>
<a name="ln6030">  }</a>
<a name="ln6031">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6032">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6033">  if (tv_list_len(list) == 0) {</a>
<a name="ln6034">    return;</a>
<a name="ln6035">  }</a>
<a name="ln6036">  if (TV_LIST_ITEM_TV(tv_list_first(list))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6037">    EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6038">    return;</a>
<a name="ln6039">  }</a>
<a name="ln6040">  ListReaderState lrstate = encode_init_lrstate(list);</a>
<a name="ln6041">  msgpack_unpacker *const unpacker = msgpack_unpacker_new(IOSIZE);</a>
<a name="ln6042">  if (unpacker == NULL) {</a>
<a name="ln6043">    EMSG(_(e_outofmem));</a>
<a name="ln6044">    return;</a>
<a name="ln6045">  }</a>
<a name="ln6046">  msgpack_unpacked unpacked;</a>
<a name="ln6047">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln6048">  do {</a>
<a name="ln6049">    if (!msgpack_unpacker_reserve_buffer(unpacker, IOSIZE)) {</a>
<a name="ln6050">      EMSG(_(e_outofmem));</a>
<a name="ln6051">      goto f_msgpackparse_exit;</a>
<a name="ln6052">    }</a>
<a name="ln6053">    size_t read_bytes;</a>
<a name="ln6054">    const int rlret = encode_read_from_list(</a>
<a name="ln6055">        &amp;lrstate, msgpack_unpacker_buffer(unpacker), IOSIZE, &amp;read_bytes);</a>
<a name="ln6056">    if (rlret == FAIL) {</a>
<a name="ln6057">      EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6058">      goto f_msgpackparse_exit;</a>
<a name="ln6059">    }</a>
<a name="ln6060">    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);</a>
<a name="ln6061">    if (read_bytes == 0) {</a>
<a name="ln6062">      break;</a>
<a name="ln6063">    }</a>
<a name="ln6064">    while (unpacker-&gt;off &lt; unpacker-&gt;used) {</a>
<a name="ln6065">      const msgpack_unpack_return result = msgpack_unpacker_next(unpacker,</a>
<a name="ln6066">                                                                 &amp;unpacked);</a>
<a name="ln6067">      if (result == MSGPACK_UNPACK_PARSE_ERROR) {</a>
<a name="ln6068">        EMSG2(_(e_invarg2), &quot;Failed to parse msgpack string&quot;);</a>
<a name="ln6069">        goto f_msgpackparse_exit;</a>
<a name="ln6070">      }</a>
<a name="ln6071">      if (result == MSGPACK_UNPACK_NOMEM_ERROR) {</a>
<a name="ln6072">        EMSG(_(e_outofmem));</a>
<a name="ln6073">        goto f_msgpackparse_exit;</a>
<a name="ln6074">      }</a>
<a name="ln6075">      if (result == MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln6076">        typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6077">        if (msgpack_to_vim(unpacked.data, &amp;tv) == FAIL) {</a>
<a name="ln6078">          EMSG2(_(e_invarg2), &quot;Failed to convert msgpack string&quot;);</a>
<a name="ln6079">          goto f_msgpackparse_exit;</a>
<a name="ln6080">        }</a>
<a name="ln6081">        tv_list_append_owned_tv(ret_list, tv);</a>
<a name="ln6082">      }</a>
<a name="ln6083">      if (result == MSGPACK_UNPACK_CONTINUE) {</a>
<a name="ln6084">        if (rlret == OK) {</a>
<a name="ln6085">          EMSG2(_(e_invarg2), &quot;Incomplete msgpack string&quot;);</a>
<a name="ln6086">        }</a>
<a name="ln6087">        break;</a>
<a name="ln6088">      }</a>
<a name="ln6089">    }</a>
<a name="ln6090">    if (rlret == OK) {</a>
<a name="ln6091">      break;</a>
<a name="ln6092">    }</a>
<a name="ln6093">  } while (true);</a>
<a name="ln6094"> </a>
<a name="ln6095">f_msgpackparse_exit:</a>
<a name="ln6096">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln6097">  msgpack_unpacker_free(unpacker);</a>
<a name="ln6098">  return;</a>
<a name="ln6099">}</a>
<a name="ln6100"> </a>
<a name="ln6101">/*</a>
<a name="ln6102"> * &quot;nextnonblank()&quot; function</a>
<a name="ln6103"> */</a>
<a name="ln6104">static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6105">{</a>
<a name="ln6106">  linenr_T lnum;</a>
<a name="ln6107"> </a>
<a name="ln6108">  for (lnum = tv_get_lnum(argvars);; lnum++) {</a>
<a name="ln6109">    if (lnum &lt; 0 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6110">      lnum = 0;</a>
<a name="ln6111">      break;</a>
<a name="ln6112">    }</a>
<a name="ln6113">    if (*skipwhite(ml_get(lnum)) != NUL) {</a>
<a name="ln6114">      break;</a>
<a name="ln6115">    }</a>
<a name="ln6116">  }</a>
<a name="ln6117">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6118">}</a>
<a name="ln6119"> </a>
<a name="ln6120">/*</a>
<a name="ln6121"> * &quot;nr2char()&quot; function</a>
<a name="ln6122"> */</a>
<a name="ln6123">static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6124">{</a>
<a name="ln6125">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6126">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln6127">      return;</a>
<a name="ln6128">    }</a>
<a name="ln6129">  }</a>
<a name="ln6130"> </a>
<a name="ln6131">  bool error = false;</a>
<a name="ln6132">  const varnumber_T num = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6133">  if (error) {</a>
<a name="ln6134">    return;</a>
<a name="ln6135">  }</a>
<a name="ln6136">  if (num &lt; 0) {</a>
<a name="ln6137">    EMSG(_(&quot;E5070: Character number must not be less than zero&quot;));</a>
<a name="ln6138">    return;</a>
<a name="ln6139">  }</a>
<a name="ln6140">  if (num &gt; INT_MAX) {</a>
<a name="ln6141">    emsgf(_(&quot;E5071: Character number must not be greater than INT_MAX (%i)&quot;),</a>
<a name="ln6142">          INT_MAX);</a>
<a name="ln6143">    return;</a>
<a name="ln6144">  }</a>
<a name="ln6145"> </a>
<a name="ln6146">  char buf[MB_MAXBYTES];</a>
<a name="ln6147">  const int len = utf_char2bytes((int)num, (char_u *)buf);</a>
<a name="ln6148"> </a>
<a name="ln6149">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6150">  rettv-&gt;vval.v_string = xmemdupz(buf, (size_t)len);</a>
<a name="ln6151">}</a>
<a name="ln6152"> </a>
<a name="ln6153">/*</a>
<a name="ln6154"> * &quot;or(expr, expr)&quot; function</a>
<a name="ln6155"> */</a>
<a name="ln6156">static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6157">{</a>
<a name="ln6158">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln6159">                         | tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln6160">}</a>
<a name="ln6161"> </a>
<a name="ln6162">/*</a>
<a name="ln6163"> * &quot;pathshorten()&quot; function</a>
<a name="ln6164"> */</a>
<a name="ln6165">static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6166">{</a>
<a name="ln6167">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6168">  const char *const s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln6169">  if (!s) {</a>
<a name="ln6170">    return;</a>
<a name="ln6171">  }</a>
<a name="ln6172">  rettv-&gt;vval.v_string = shorten_dir((char_u *)xstrdup(s));</a>
<a name="ln6173">}</a>
<a name="ln6174"> </a>
<a name="ln6175">/*</a>
<a name="ln6176"> * &quot;pow()&quot; function</a>
<a name="ln6177"> */</a>
<a name="ln6178">static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6179">{</a>
<a name="ln6180">  float_T fx;</a>
<a name="ln6181">  float_T fy;</a>
<a name="ln6182"> </a>
<a name="ln6183">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln6184">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln6185">    rettv-&gt;vval.v_float = pow(fx, fy);</a>
<a name="ln6186">  } else {</a>
<a name="ln6187">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln6188">  }</a>
<a name="ln6189">}</a>
<a name="ln6190"> </a>
<a name="ln6191">/*</a>
<a name="ln6192"> * &quot;prevnonblank()&quot; function</a>
<a name="ln6193"> */</a>
<a name="ln6194">static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6195">{</a>
<a name="ln6196">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln6197">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6198">    lnum = 0;</a>
<a name="ln6199">  } else {</a>
<a name="ln6200">    while (lnum &gt;= 1 &amp;&amp; *skipwhite(ml_get(lnum)) == NUL) {</a>
<a name="ln6201">      lnum--;</a>
<a name="ln6202">    }</a>
<a name="ln6203">  }</a>
<a name="ln6204">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6205">}</a>
<a name="ln6206"> </a>
<a name="ln6207">/*</a>
<a name="ln6208"> * &quot;printf()&quot; function</a>
<a name="ln6209"> */</a>
<a name="ln6210">static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6211">{</a>
<a name="ln6212">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6213">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6214">  {</a>
<a name="ln6215">    int len;</a>
<a name="ln6216">    int saved_did_emsg = did_emsg;</a>
<a name="ln6217"> </a>
<a name="ln6218">    // Get the required length, allocate the buffer and do it for real.</a>
<a name="ln6219">    did_emsg = false;</a>
<a name="ln6220">    char buf[NUMBUFLEN];</a>
<a name="ln6221">    const char *fmt = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6222">    len = vim_vsnprintf_typval(NULL, 0, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6223">    if (!did_emsg) {</a>
<a name="ln6224">      char *s = xmalloc(len + 1);</a>
<a name="ln6225">      rettv-&gt;vval.v_string = (char_u *)s;</a>
<a name="ln6226">      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6227">    }</a>
<a name="ln6228">    did_emsg |= saved_did_emsg;</a>
<a name="ln6229">  }</a>
<a name="ln6230">}</a>
<a name="ln6231"> </a>
<a name="ln6232">// &quot;prompt_setcallback({buffer}, {callback})&quot; function</a>
<a name="ln6233">static void f_prompt_setcallback(typval_T *argvars,</a>
<a name="ln6234">                                 typval_T *rettv, FunPtr fptr)</a>
<a name="ln6235">{</a>
<a name="ln6236">    buf_T *buf;</a>
<a name="ln6237">    Callback prompt_callback = { .type = kCallbackNone };</a>
<a name="ln6238"> </a>
<a name="ln6239">    if (check_secure()) {</a>
<a name="ln6240">      return;</a>
<a name="ln6241">    }</a>
<a name="ln6242">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6243">    if (buf == NULL) {</a>
<a name="ln6244">      return;</a>
<a name="ln6245">    }</a>
<a name="ln6246"> </a>
<a name="ln6247">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6248">      if (!callback_from_typval(&amp;prompt_callback, &amp;argvars[1])) {</a>
<a name="ln6249">        return;</a>
<a name="ln6250">      }</a>
<a name="ln6251">    }</a>
<a name="ln6252"> </a>
<a name="ln6253">    callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln6254">    buf-&gt;b_prompt_callback = prompt_callback;</a>
<a name="ln6255">}</a>
<a name="ln6256"> </a>
<a name="ln6257">// &quot;prompt_setinterrupt({buffer}, {callback})&quot; function</a>
<a name="ln6258">static void f_prompt_setinterrupt(typval_T *argvars,</a>
<a name="ln6259">                                  typval_T *rettv, FunPtr fptr)</a>
<a name="ln6260">{</a>
<a name="ln6261">    buf_T *buf;</a>
<a name="ln6262">    Callback interrupt_callback = { .type = kCallbackNone };</a>
<a name="ln6263"> </a>
<a name="ln6264">    if (check_secure()) {</a>
<a name="ln6265">      return;</a>
<a name="ln6266">    }</a>
<a name="ln6267">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6268">    if (buf == NULL) {</a>
<a name="ln6269">      return;</a>
<a name="ln6270">    }</a>
<a name="ln6271"> </a>
<a name="ln6272">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6273">      if (!callback_from_typval(&amp;interrupt_callback, &amp;argvars[1])) {</a>
<a name="ln6274">        return;</a>
<a name="ln6275">      }</a>
<a name="ln6276">    }</a>
<a name="ln6277"> </a>
<a name="ln6278">    callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln6279">    buf-&gt;b_prompt_interrupt= interrupt_callback;</a>
<a name="ln6280">}</a>
<a name="ln6281"> </a>
<a name="ln6282">// &quot;prompt_setprompt({buffer}, {text})&quot; function</a>
<a name="ln6283">static void f_prompt_setprompt(typval_T *argvars,</a>
<a name="ln6284">                               typval_T *rettv, FunPtr fptr)</a>
<a name="ln6285">{</a>
<a name="ln6286">    buf_T *buf;</a>
<a name="ln6287">    const char_u *text;</a>
<a name="ln6288"> </a>
<a name="ln6289">    if (check_secure()) {</a>
<a name="ln6290">      return;</a>
<a name="ln6291">    }</a>
<a name="ln6292">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6293">    if (buf == NULL) {</a>
<a name="ln6294">      return;</a>
<a name="ln6295">    }</a>
<a name="ln6296"> </a>
<a name="ln6297">    text = (const char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln6298">    xfree(buf-&gt;b_prompt_text);</a>
<a name="ln6299">    buf-&gt;b_prompt_text = vim_strsave(text);</a>
<a name="ln6300">}</a>
<a name="ln6301"> </a>
<a name="ln6302">// &quot;pum_getpos()&quot; function</a>
<a name="ln6303">static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6304">{</a>
<a name="ln6305">  tv_dict_alloc_ret(rettv);</a>
<a name="ln6306">  pum_set_event_info(rettv-&gt;vval.v_dict);</a>
<a name="ln6307">}</a>
<a name="ln6308"> </a>
<a name="ln6309">/*</a>
<a name="ln6310"> * &quot;pumvisible()&quot; function</a>
<a name="ln6311"> */</a>
<a name="ln6312">static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6313">{</a>
<a name="ln6314">  if (pum_visible())</a>
<a name="ln6315">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318">/*</a>
<a name="ln6319"> * &quot;pyeval()&quot; function</a>
<a name="ln6320"> */</a>
<a name="ln6321">static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6322">{</a>
<a name="ln6323">  script_host_eval(&quot;python&quot;, argvars, rettv);</a>
<a name="ln6324">}</a>
<a name="ln6325"> </a>
<a name="ln6326">/*</a>
<a name="ln6327"> * &quot;py3eval()&quot; function</a>
<a name="ln6328"> */</a>
<a name="ln6329">static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6330">{</a>
<a name="ln6331">  script_host_eval(&quot;python3&quot;, argvars, rettv);</a>
<a name="ln6332">}</a>
<a name="ln6333"> </a>
<a name="ln6334">// &quot;pyxeval()&quot; function</a>
<a name="ln6335">static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6336">{</a>
<a name="ln6337">  init_pyxversion();</a>
<a name="ln6338">  if (p_pyx == 2) {</a>
<a name="ln6339">    f_pyeval(argvars, rettv, NULL);</a>
<a name="ln6340">  } else {</a>
<a name="ln6341">    f_py3eval(argvars, rettv, NULL);</a>
<a name="ln6342">  }</a>
<a name="ln6343">}</a>
<a name="ln6344"> </a>
<a name="ln6345">///</a>
<a name="ln6346">/// &quot;perleval()&quot; function</a>
<a name="ln6347">///</a>
<a name="ln6348">static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6349">{</a>
<a name="ln6350">  script_host_eval(&quot;perl&quot;, argvars, rettv);</a>
<a name="ln6351">}</a>
<a name="ln6352"> </a>
<a name="ln6353">// &quot;rubyeval()&quot; function</a>
<a name="ln6354">static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6355">{</a>
<a name="ln6356">  script_host_eval(&quot;ruby&quot;, argvars, rettv);</a>
<a name="ln6357">}</a>
<a name="ln6358"> </a>
<a name="ln6359">/*</a>
<a name="ln6360"> * &quot;range()&quot; function</a>
<a name="ln6361"> */</a>
<a name="ln6362">static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6363">{</a>
<a name="ln6364">  varnumber_T start;</a>
<a name="ln6365">  varnumber_T end;</a>
<a name="ln6366">  varnumber_T stride = 1;</a>
<a name="ln6367">  varnumber_T i;</a>
<a name="ln6368">  bool error = false;</a>
<a name="ln6369"> </a>
<a name="ln6370">  start = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6371">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6372">    end = start - 1;</a>
<a name="ln6373">    start = 0;</a>
<a name="ln6374">  } else {</a>
<a name="ln6375">    end = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6376">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6377">      stride = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6378">    }</a>
<a name="ln6379">  }</a>
<a name="ln6380"> </a>
<a name="ln6381">  if (error) {</a>
<a name="ln6382">    return;  // Type error; errmsg already given.</a>
<a name="ln6383">  }</a>
<a name="ln6384">  if (stride == 0) {</a>
<a name="ln6385">    EMSG(_(&quot;E726: Stride is zero&quot;));</a>
<a name="ln6386">  } else if (stride &gt; 0 ? end + 1 &lt; start : end - 1 &gt; start) {</a>
<a name="ln6387">    EMSG(_(&quot;E727: Start past end&quot;));</a>
<a name="ln6388">  } else {</a>
<a name="ln6389">    tv_list_alloc_ret(rettv, (end - start) / stride);</a>
<a name="ln6390">    for (i = start; stride &gt; 0 ? i &lt;= end : i &gt;= end; i += stride) {</a>
<a name="ln6391">      tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)i);</a>
<a name="ln6392">    }</a>
<a name="ln6393">  }</a>
<a name="ln6394">}</a>
<a name="ln6395"> </a>
<a name="ln6396">// Evaluate &quot;expr&quot; for readdir().</a>
<a name="ln6397">static varnumber_T readdir_checkitem(typval_T *expr, const char *name)</a>
<a name="ln6398">{</a>
<a name="ln6399">  typval_T save_val;</a>
<a name="ln6400">  typval_T rettv;</a>
<a name="ln6401">  typval_T argv[2];</a>
<a name="ln6402">  varnumber_T retval = 0;</a>
<a name="ln6403">  bool error = false;</a>
<a name="ln6404"> </a>
<a name="ln6405">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6406">  set_vim_var_string(VV_VAL, name, -1);</a>
<a name="ln6407">  argv[0].v_type = VAR_STRING;</a>
<a name="ln6408">  argv[0].vval.v_string = (char_u *)name;</a>
<a name="ln6409"> </a>
<a name="ln6410">  if (eval_expr_typval(expr, argv, 1, &amp;rettv) == FAIL) {</a>
<a name="ln6411">    goto theend;</a>
<a name="ln6412">  }</a>
<a name="ln6413"> </a>
<a name="ln6414">  retval = tv_get_number_chk(&amp;rettv, &amp;error);</a>
<a name="ln6415">  if (error) {</a>
<a name="ln6416">    retval = -1;</a>
<a name="ln6417">  }</a>
<a name="ln6418"> </a>
<a name="ln6419">  tv_clear(&amp;rettv);</a>
<a name="ln6420"> </a>
<a name="ln6421">theend:</a>
<a name="ln6422">  set_vim_var_string(VV_VAL, NULL, 0);</a>
<a name="ln6423">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6424">  return retval;</a>
<a name="ln6425">}</a>
<a name="ln6426"> </a>
<a name="ln6427">// &quot;readdir()&quot; function</a>
<a name="ln6428">static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6429">{</a>
<a name="ln6430">  typval_T *expr;</a>
<a name="ln6431">  const char *path;</a>
<a name="ln6432">  garray_T ga;</a>
<a name="ln6433">  Directory dir;</a>
<a name="ln6434"> </a>
<a name="ln6435">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6436">  path = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6437">  expr = &amp;argvars[1];</a>
<a name="ln6438">  ga_init(&amp;ga, (int)sizeof(char *), 20);</a>
<a name="ln6439"> </a>
<a name="ln6440">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln6441">    smsg(_(e_notopen), path);</a>
<a name="ln6442">  } else {</a>
<a name="ln6443">    for (;;) {</a>
<a name="ln6444">      bool ignore;</a>
<a name="ln6445"> </a>
<a name="ln6446">      path = os_scandir_next(&amp;dir);</a>
<a name="ln6447">      if (path == NULL) {</a>
<a name="ln6448">        break;</a>
<a name="ln6449">      }</a>
<a name="ln6450"> </a>
<a name="ln6451">      ignore = (path[0] == '.'</a>
<a name="ln6452">                &amp;&amp; (path[1] == NUL || (path[1] == '.' &amp;&amp; path[2] == NUL)));</a>
<a name="ln6453">      if (!ignore &amp;&amp; expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6454">        varnumber_T r = readdir_checkitem(expr, path);</a>
<a name="ln6455"> </a>
<a name="ln6456">        if (r &lt; 0) {</a>
<a name="ln6457">          break;</a>
<a name="ln6458">        }</a>
<a name="ln6459">        if (r == 0) {</a>
<a name="ln6460">          ignore = true;</a>
<a name="ln6461">        }</a>
<a name="ln6462">      }</a>
<a name="ln6463"> </a>
<a name="ln6464">      if (!ignore) {</a>
<a name="ln6465">        ga_grow(&amp;ga, 1);</a>
<a name="ln6466">        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);</a>
<a name="ln6467">      }</a>
<a name="ln6468">    }</a>
<a name="ln6469"> </a>
<a name="ln6470">    os_closedir(&amp;dir);</a>
<a name="ln6471">  }</a>
<a name="ln6472"> </a>
<a name="ln6473">  if (rettv-&gt;vval.v_list != NULL &amp;&amp; ga.ga_len &gt; 0) {</a>
<a name="ln6474">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln6475">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln6476">      path = ((const char **)ga.ga_data)[i];</a>
<a name="ln6477">      tv_list_append_string(rettv-&gt;vval.v_list, path, -1);</a>
<a name="ln6478">    }</a>
<a name="ln6479">  }</a>
<a name="ln6480">  ga_clear_strings(&amp;ga);</a>
<a name="ln6481">}</a>
<a name="ln6482"> </a>
<a name="ln6483">/*</a>
<a name="ln6484"> * &quot;readfile()&quot; function</a>
<a name="ln6485"> */</a>
<a name="ln6486">static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6487">{</a>
<a name="ln6488">  bool binary = false;</a>
<a name="ln6489">  FILE        *fd;</a>
<a name="ln6490">  char_u buf[(IOSIZE/256) * 256];       // rounded to avoid odd + 1</a>
<a name="ln6491">  int io_size = sizeof(buf);</a>
<a name="ln6492">  int readlen;                          // size of last fread()</a>
<a name="ln6493">  char_u      *prev    = NULL;          // previously read bytes, if any</a>
<a name="ln6494">  long prevlen  = 0;                    // length of data in prev</a>
<a name="ln6495">  long prevsize = 0;                    // size of prev buffer</a>
<a name="ln6496">  long maxline  = MAXLNUM;</a>
<a name="ln6497"> </a>
<a name="ln6498">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6499">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;b&quot;) == 0) {</a>
<a name="ln6500">      binary = true;</a>
<a name="ln6501">    }</a>
<a name="ln6502">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6503">      maxline = tv_get_number(&amp;argvars[2]);</a>
<a name="ln6504">    }</a>
<a name="ln6505">  }</a>
<a name="ln6506"> </a>
<a name="ln6507">  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6508"> </a>
<a name="ln6509">  // Always open the file in binary mode, library functions have a mind of</a>
<a name="ln6510">  // their own about CR-LF conversion.</a>
<a name="ln6511">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6512">  if (*fname == NUL || (fd = os_fopen(fname, READBIN)) == NULL) {</a>
<a name="ln6513">    EMSG2(_(e_notopen), *fname == NUL ? _(&quot;&lt;empty&gt;&quot;) : fname);</a>
<a name="ln6514">    return;</a>
<a name="ln6515">  }</a>
<a name="ln6516"> </a>
<a name="ln6517">  while (maxline &lt; 0 || tv_list_len(l) &lt; maxline) {</a>
<a name="ln6518">    readlen = (int)fread(buf, 1, io_size, fd);</a>
<a name="ln6519"> </a>
<a name="ln6520">    // This for loop processes what was read, but is also entered at end</a>
<a name="ln6521">    // of file so that either:</a>
<a name="ln6522">    // - an incomplete line gets written</a>
<a name="ln6523">    // - a &quot;binary&quot; file gets an empty line at the end if it ends in a</a>
<a name="ln6524">    //   newline.</a>
<a name="ln6525">    char_u *p;  // Position in buf.</a>
<a name="ln6526">    char_u *start;  // Start of current line.</a>
<a name="ln6527">    for (p = buf, start = buf;</a>
<a name="ln6528">         p &lt; buf + readlen || (readlen &lt;= 0 &amp;&amp; (prevlen &gt; 0 || binary));</a>
<a name="ln6529">         p++) {</a>
<a name="ln6530">      if (*p == '\n' || readlen &lt;= 0) {</a>
<a name="ln6531">        char_u      *s  = NULL;</a>
<a name="ln6532">        size_t len = p - start;</a>
<a name="ln6533"> </a>
<a name="ln6534">        // Finished a line.  Remove CRs before NL.</a>
<a name="ln6535">        if (readlen &gt; 0 &amp;&amp; !binary) {</a>
<a name="ln6536">          while (len &gt; 0 &amp;&amp; start[len - 1] == '\r') {</a>
<a name="ln6537">            len--;</a>
<a name="ln6538">          }</a>
<a name="ln6539">          // removal may cross back to the &quot;prev&quot; string</a>
<a name="ln6540">          if (len == 0) {</a>
<a name="ln6541">            while (prevlen &gt; 0 &amp;&amp; prev[prevlen - 1] == '\r') {</a>
<a name="ln6542">              prevlen--;</a>
<a name="ln6543">            }</a>
<a name="ln6544">          }</a>
<a name="ln6545">        }</a>
<a name="ln6546">        if (prevlen == 0) {</a>
<a name="ln6547">          assert(len &lt; INT_MAX);</a>
<a name="ln6548">          s = vim_strnsave(start, (int)len);</a>
<a name="ln6549">        } else {</a>
<a name="ln6550">          /* Change &quot;prev&quot; buffer to be the right size.  This way</a>
<a name="ln6551">           * the bytes are only copied once, and very long lines are</a>
<a name="ln6552">           * allocated only once.  */</a>
<a name="ln6553">          s = xrealloc(prev, prevlen + len + 1);</a>
<a name="ln6554">          memcpy(s + prevlen, start, len);</a>
<a name="ln6555">          s[prevlen + len] = NUL;</a>
<a name="ln6556">          prev = NULL;             // the list will own the string</a>
<a name="ln6557">          prevlen = prevsize = 0;</a>
<a name="ln6558">        }</a>
<a name="ln6559"> </a>
<a name="ln6560">        tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln6561">          .v_type = VAR_STRING,</a>
<a name="ln6562">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6563">          .vval.v_string = s,</a>
<a name="ln6564">        });</a>
<a name="ln6565"> </a>
<a name="ln6566">        start = p + 1;  // Step over newline.</a>
<a name="ln6567">        if (maxline &lt; 0) {</a>
<a name="ln6568">          if (tv_list_len(l) &gt; -maxline) {</a>
<a name="ln6569">            assert(tv_list_len(l) == 1 + (-maxline));</a>
<a name="ln6570">            tv_list_item_remove(l, tv_list_first(l));</a>
<a name="ln6571">          }</a>
<a name="ln6572">        } else if (tv_list_len(l) &gt;= maxline) {</a>
<a name="ln6573">          assert(tv_list_len(l) == maxline);</a>
<a name="ln6574">          break;</a>
<a name="ln6575">        }</a>
<a name="ln6576">        if (readlen &lt;= 0) {</a>
<a name="ln6577">          break;</a>
<a name="ln6578">        }</a>
<a name="ln6579">      } else if (*p == NUL) {</a>
<a name="ln6580">        *p = '\n';</a>
<a name="ln6581">      // Check for utf8 &quot;bom&quot;; U+FEFF is encoded as EF BB BF.  Do this</a>
<a name="ln6582">      // when finding the BF and check the previous two bytes.</a>
<a name="ln6583">      } else if (*p == 0xbf &amp;&amp; !binary) {</a>
<a name="ln6584">        // Find the two bytes before the 0xbf.  If p is at buf, or buf + 1,</a>
<a name="ln6585">        // these may be in the &quot;prev&quot; string.</a>
<a name="ln6586">        char_u back1 = p &gt;= buf + 1 ? p[-1]</a>
<a name="ln6587">                       : prevlen &gt;= 1 ? prev[prevlen - 1] : NUL;</a>
<a name="ln6588">        char_u back2 = p &gt;= buf + 2 ? p[-2]</a>
<a name="ln6589">                       : p == buf + 1 &amp;&amp; prevlen &gt;= 1 ? prev[prevlen - 1]</a>
<a name="ln6590">                       : prevlen &gt;= 2 ? prev[prevlen - 2] : NUL;</a>
<a name="ln6591"> </a>
<a name="ln6592">        if (back2 == 0xef &amp;&amp; back1 == 0xbb) {</a>
<a name="ln6593">          char_u *dest = p - 2;</a>
<a name="ln6594"> </a>
<a name="ln6595">          // Usually a BOM is at the beginning of a file, and so at</a>
<a name="ln6596">          // the beginning of a line; then we can just step over it.</a>
<a name="ln6597">          if (start == dest) {</a>
<a name="ln6598">            start = p + 1;</a>
<a name="ln6599">          } else {</a>
<a name="ln6600">            // have to shuffle buf to close gap</a>
<a name="ln6601">            int adjust_prevlen = 0;</a>
<a name="ln6602"> </a>
<a name="ln6603">            if (dest &lt; buf) {  // -V782</a>
<a name="ln6604">              adjust_prevlen = (int)(buf - dest);  // -V782</a>
<a name="ln6605">              // adjust_prevlen must be 1 or 2.</a>
<a name="ln6606">              dest = buf;</a>
<a name="ln6607">            }</a>
<a name="ln6608">            if (readlen &gt; p - buf + 1)</a>
<a name="ln6609">              memmove(dest, p + 1, readlen - (p - buf) - 1);</a>
<a name="ln6610">            readlen -= 3 - adjust_prevlen;</a>
<a name="ln6611">            prevlen -= adjust_prevlen;</a>
<a name="ln6612">            p = dest - 1;</a>
<a name="ln6613">          }</a>
<a name="ln6614">        }</a>
<a name="ln6615">      }</a>
<a name="ln6616">    }     // for</a>
<a name="ln6617"> </a>
<a name="ln6618">    if ((maxline &gt;= 0 &amp;&amp; tv_list_len(l) &gt;= maxline) || readlen &lt;= 0) {</a>
<a name="ln6619">      break;</a>
<a name="ln6620">    }</a>
<a name="ln6621">    if (start &lt; p) {</a>
<a name="ln6622">      // There's part of a line in buf, store it in &quot;prev&quot;.</a>
<a name="ln6623">      if (p - start + prevlen &gt;= prevsize) {</a>
<a name="ln6624">        /* A common use case is ordinary text files and &quot;prev&quot; gets a</a>
<a name="ln6625">         * fragment of a line, so the first allocation is made</a>
<a name="ln6626">         * small, to avoid repeatedly 'allocing' large and</a>
<a name="ln6627">         * 'reallocing' small. */</a>
<a name="ln6628">        if (prevsize == 0)</a>
<a name="ln6629">          prevsize = (long)(p - start);</a>
<a name="ln6630">        else {</a>
<a name="ln6631">          long grow50pc = (prevsize * 3) / 2;</a>
<a name="ln6632">          long growmin  = (long)((p - start) * 2 + prevlen);</a>
<a name="ln6633">          prevsize = grow50pc &gt; growmin ? grow50pc : growmin;</a>
<a name="ln6634">        }</a>
<a name="ln6635">        prev = xrealloc(prev, prevsize);</a>
<a name="ln6636">      }</a>
<a name="ln6637">      // Add the line part to end of &quot;prev&quot;.</a>
<a name="ln6638">      memmove(prev + prevlen, start, p - start);</a>
<a name="ln6639">      prevlen += (long)(p - start);</a>
<a name="ln6640">    }</a>
<a name="ln6641">  }   // while</a>
<a name="ln6642"> </a>
<a name="ln6643">  xfree(prev);</a>
<a name="ln6644">  fclose(fd);</a>
<a name="ln6645">}</a>
<a name="ln6646"> </a>
<a name="ln6647">// &quot;reg_executing()&quot; function</a>
<a name="ln6648">static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6649">{</a>
<a name="ln6650">  return_register(reg_executing, rettv);</a>
<a name="ln6651">}</a>
<a name="ln6652"> </a>
<a name="ln6653">// &quot;reg_recording()&quot; function</a>
<a name="ln6654">static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6655">{</a>
<a name="ln6656">  return_register(reg_recording, rettv);</a>
<a name="ln6657">}</a>
<a name="ln6658"> </a>
<a name="ln6659">/// list2proftime - convert a List to proftime_T</a>
<a name="ln6660">///</a>
<a name="ln6661">/// @param arg The input list, must be of type VAR_LIST and have</a>
<a name="ln6662">///            exactly 2 items</a>
<a name="ln6663">/// @param[out] tm The proftime_T representation of `arg`</a>
<a name="ln6664">/// @return OK In case of success, FAIL in case of error</a>
<a name="ln6665">static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6666">{</a>
<a name="ln6667">  if (arg-&gt;v_type != VAR_LIST || tv_list_len(arg-&gt;vval.v_list) != 2) {</a>
<a name="ln6668">    return FAIL;</a>
<a name="ln6669">  }</a>
<a name="ln6670"> </a>
<a name="ln6671">  bool error = false;</a>
<a name="ln6672">  varnumber_T n1 = tv_list_find_nr(arg-&gt;vval.v_list, 0L, &amp;error);</a>
<a name="ln6673">  varnumber_T n2 = tv_list_find_nr(arg-&gt;vval.v_list, 1L, &amp;error);</a>
<a name="ln6674">  if (error) {</a>
<a name="ln6675">    return FAIL;</a>
<a name="ln6676">  }</a>
<a name="ln6677"> </a>
<a name="ln6678">  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit</a>
<a name="ln6679">  // values, now we combine them again.</a>
<a name="ln6680">  union {</a>
<a name="ln6681">    struct { int32_t low, high; } split;</a>
<a name="ln6682">    proftime_T prof;</a>
<a name="ln6683">  } u = { .split.high = n1, .split.low = n2 };</a>
<a name="ln6684"> </a>
<a name="ln6685">  *tm = u.prof;</a>
<a name="ln6686"> </a>
<a name="ln6687">  return OK;</a>
<a name="ln6688">}</a>
<a name="ln6689"> </a>
<a name="ln6690">/// f_reltime - return an item that represents a time value</a>
<a name="ln6691">///</a>
<a name="ln6692">/// @param[out] rettv Without an argument it returns the current time. With</a>
<a name="ln6693">///             one argument it returns the time passed since the argument.</a>
<a name="ln6694">///             With two arguments it returns the time passed between</a>
<a name="ln6695">///             the two arguments.</a>
<a name="ln6696">static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6697">{</a>
<a name="ln6698">  proftime_T res;</a>
<a name="ln6699">  proftime_T start;</a>
<a name="ln6700"> </a>
<a name="ln6701">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln6702">    // no arguments: get current time.</a>
<a name="ln6703">    res = profile_start();</a>
<a name="ln6704">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6705">    if (list2proftime(&amp;argvars[0], &amp;res) == FAIL) {</a>
<a name="ln6706">      return;</a>
<a name="ln6707">    }</a>
<a name="ln6708">    res = profile_end(res);</a>
<a name="ln6709">  } else {</a>
<a name="ln6710">    // two arguments: compute the difference.</a>
<a name="ln6711">    if (list2proftime(&amp;argvars[0], &amp;start) == FAIL</a>
<a name="ln6712">        || list2proftime(&amp;argvars[1], &amp;res) == FAIL) {</a>
<a name="ln6713">      return;</a>
<a name="ln6714">    }</a>
<a name="ln6715">    res = profile_sub(res, start);</a>
<a name="ln6716">  }</a>
<a name="ln6717"> </a>
<a name="ln6718">  // we have to store the 64-bit proftime_T inside of a list of int's</a>
<a name="ln6719">  // (varnumber_T is defined as int). For all our supported platforms, int's</a>
<a name="ln6720">  // are at least 32-bits wide. So we'll use two 32-bit values to store it.</a>
<a name="ln6721">  union {</a>
<a name="ln6722">    struct { int32_t low, high; } split;</a>
<a name="ln6723">    proftime_T prof;</a>
<a name="ln6724">  } u = { .prof = res };</a>
<a name="ln6725"> </a>
<a name="ln6726">  // statically assert that the union type conv will provide the correct</a>
<a name="ln6727">  // results, if varnumber_T or proftime_T change, the union cast will need</a>
<a name="ln6728">  // to be revised.</a>
<a name="ln6729">  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) &amp;&amp; sizeof(u.split) == sizeof(u),</a>
<a name="ln6730">      &quot;type punning will produce incorrect results on this platform&quot;);</a>
<a name="ln6731"> </a>
<a name="ln6732">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln6733">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.high);</a>
<a name="ln6734">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.low);</a>
<a name="ln6735">}</a>
<a name="ln6736"> </a>
<a name="ln6737">/// &quot;reltimestr()&quot; function</a>
<a name="ln6738">static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6739">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6740">{</a>
<a name="ln6741">  proftime_T tm;</a>
<a name="ln6742"> </a>
<a name="ln6743">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6744">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6745">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln6746">    rettv-&gt;vval.v_string = (char_u *)xstrdup(profile_msg(tm));</a>
<a name="ln6747">  }</a>
<a name="ln6748">}</a>
<a name="ln6749"> </a>
<a name="ln6750">/*</a>
<a name="ln6751"> * &quot;remove()&quot; function</a>
<a name="ln6752"> */</a>
<a name="ln6753">static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6754">{</a>
<a name="ln6755">  list_T      *l;</a>
<a name="ln6756">  listitem_T  *item, *item2;</a>
<a name="ln6757">  listitem_T  *li;</a>
<a name="ln6758">  long idx;</a>
<a name="ln6759">  long end;</a>
<a name="ln6760">  dict_T      *d;</a>
<a name="ln6761">  dictitem_T  *di;</a>
<a name="ln6762">  const char *const arg_errmsg = N_(&quot;remove() argument&quot;);</a>
<a name="ln6763"> </a>
<a name="ln6764">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln6765">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6766">      EMSG2(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln6767">    } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln6768">               &amp;&amp; !tv_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6769">      const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln6770">      if (key != NULL) {</a>
<a name="ln6771">        di = tv_dict_find(d, key, -1);</a>
<a name="ln6772">        if (di == NULL) {</a>
<a name="ln6773">          EMSG2(_(e_dictkey), key);</a>
<a name="ln6774">        } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln6775">                   &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6776">          *rettv = di-&gt;di_tv;</a>
<a name="ln6777">          di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln6778">          tv_dict_item_remove(d, di);</a>
<a name="ln6779">          if (tv_dict_is_watched(d)) {</a>
<a name="ln6780">            tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln6781">          }</a>
<a name="ln6782">        }</a>
<a name="ln6783">      }</a>
<a name="ln6784">    }</a>
<a name="ln6785">  } else if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6786">    EMSG2(_(e_listdictarg), &quot;remove()&quot;);</a>
<a name="ln6787">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln6788">                            arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6789">    bool error = false;</a>
<a name="ln6790"> </a>
<a name="ln6791">    idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6792">    if (error) {</a>
<a name="ln6793">      // Type error: do nothing, errmsg already given.</a>
<a name="ln6794">    } else if ((item = tv_list_find(l, idx)) == NULL) {</a>
<a name="ln6795">      EMSGN(_(e_listidx), idx);</a>
<a name="ln6796">    } else {</a>
<a name="ln6797">      if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln6798">        // Remove one item, return its value.</a>
<a name="ln6799">        tv_list_drop_items(l, item, item);</a>
<a name="ln6800">        *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln6801">        xfree(item);</a>
<a name="ln6802">      } else {</a>
<a name="ln6803">        // Remove range of items, return list with values.</a>
<a name="ln6804">        end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6805">        if (error) {</a>
<a name="ln6806">          // Type error: do nothing.</a>
<a name="ln6807">        } else if ((item2 = tv_list_find(l, end)) == NULL) {</a>
<a name="ln6808">          EMSGN(_(e_listidx), end);</a>
<a name="ln6809">        } else {</a>
<a name="ln6810">          int cnt = 0;</a>
<a name="ln6811"> </a>
<a name="ln6812">          for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln6813">            cnt++;</a>
<a name="ln6814">            if (li == item2) {</a>
<a name="ln6815">              break;</a>
<a name="ln6816">            }</a>
<a name="ln6817">          }</a>
<a name="ln6818">          if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln6819">            EMSG(_(e_invrange));</a>
<a name="ln6820">          } else {</a>
<a name="ln6821">            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln6822">                               cnt);</a>
<a name="ln6823">          }</a>
<a name="ln6824">        }</a>
<a name="ln6825">      }</a>
<a name="ln6826">    }</a>
<a name="ln6827">  }</a>
<a name="ln6828">}</a>
<a name="ln6829"> </a>
<a name="ln6830">/*</a>
<a name="ln6831"> * &quot;rename({from}, {to})&quot; function</a>
<a name="ln6832"> */</a>
<a name="ln6833">static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6834">{</a>
<a name="ln6835">  if (check_restricted() || check_secure()) {</a>
<a name="ln6836">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln6837">  } else {</a>
<a name="ln6838">    char buf[NUMBUFLEN];</a>
<a name="ln6839">    rettv-&gt;vval.v_number = vim_rename(</a>
<a name="ln6840">        (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln6841">        (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln6842">  }</a>
<a name="ln6843">}</a>
<a name="ln6844"> </a>
<a name="ln6845">/*</a>
<a name="ln6846"> * &quot;repeat()&quot; function</a>
<a name="ln6847"> */</a>
<a name="ln6848">static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6849">{</a>
<a name="ln6850">  varnumber_T n = tv_get_number(&amp;argvars[1]);</a>
<a name="ln6851">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln6852">    tv_list_alloc_ret(rettv, (n &gt; 0) * n * tv_list_len(argvars[0].vval.v_list));</a>
<a name="ln6853">    while (n-- &gt; 0) {</a>
<a name="ln6854">      tv_list_extend(rettv-&gt;vval.v_list, argvars[0].vval.v_list, NULL);</a>
<a name="ln6855">    }</a>
<a name="ln6856">  } else {</a>
<a name="ln6857">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6858">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6859">    if (n &lt;= 0) {</a>
<a name="ln6860">      return;</a>
<a name="ln6861">    }</a>
<a name="ln6862"> </a>
<a name="ln6863">    const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6864"> </a>
<a name="ln6865">    const size_t slen = strlen(p);</a>
<a name="ln6866">    if (slen == 0) {</a>
<a name="ln6867">      return;</a>
<a name="ln6868">    }</a>
<a name="ln6869">    const size_t len = slen * n;</a>
<a name="ln6870">    // Detect overflow.</a>
<a name="ln6871">    if (len / n != slen) {</a>
<a name="ln6872">      return;</a>
<a name="ln6873">    }</a>
<a name="ln6874"> </a>
<a name="ln6875">    char *const r = xmallocz(len);</a>
<a name="ln6876">    for (varnumber_T i = 0; i &lt; n; i++) {</a>
<a name="ln6877">      memmove(r + i * slen, p, slen);</a>
<a name="ln6878">    }</a>
<a name="ln6879"> </a>
<a name="ln6880">    rettv-&gt;vval.v_string = (char_u *)r;</a>
<a name="ln6881">  }</a>
<a name="ln6882">}</a>
<a name="ln6883"> </a>
<a name="ln6884">/*</a>
<a name="ln6885"> * &quot;resolve()&quot; function</a>
<a name="ln6886"> */</a>
<a name="ln6887">static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6888">{</a>
<a name="ln6889">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6890">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6891">#ifdef WIN32</a>
<a name="ln6892">  char *v = os_resolve_shortcut(fname);</a>
<a name="ln6893">  if (v == NULL) {</a>
<a name="ln6894">    if (os_is_reparse_point_include(fname)) {</a>
<a name="ln6895">      v = os_realpath(fname, v);</a>
<a name="ln6896">    }</a>
<a name="ln6897">  }</a>
<a name="ln6898">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln6899">#else</a>
<a name="ln6900"># ifdef HAVE_READLINK</a>
<a name="ln6901">  {</a>
<a name="ln6902">    bool is_relative_to_current = false;</a>
<a name="ln6903">    bool has_trailing_pathsep = false;</a>
<a name="ln6904">    int limit = 100;</a>
<a name="ln6905"> </a>
<a name="ln6906">    char *p = xstrdup(fname);</a>
<a name="ln6907"> </a>
<a name="ln6908">    if (p[0] == '.' &amp;&amp; (vim_ispathsep(p[1])</a>
<a name="ln6909">                        || (p[1] == '.' &amp;&amp; (vim_ispathsep(p[2]))))) {</a>
<a name="ln6910">      is_relative_to_current = true;</a>
<a name="ln6911">    }</a>
<a name="ln6912"> </a>
<a name="ln6913">    ptrdiff_t len = (ptrdiff_t)strlen(p);</a>
<a name="ln6914">    if (len &gt; 1 &amp;&amp; after_pathsep(p, p + len)) {</a>
<a name="ln6915">      has_trailing_pathsep = true;</a>
<a name="ln6916">      p[len - 1] = NUL;  // The trailing slash breaks readlink().</a>
<a name="ln6917">    }</a>
<a name="ln6918"> </a>
<a name="ln6919">    char *q = (char *)path_next_component(p);</a>
<a name="ln6920">    char *remain = NULL;</a>
<a name="ln6921">    if (*q != NUL) {</a>
<a name="ln6922">      // Separate the first path component in &quot;p&quot;, and keep the</a>
<a name="ln6923">      // remainder (beginning with the path separator).</a>
<a name="ln6924">      remain = xstrdup(q - 1);</a>
<a name="ln6925">      q[-1] = NUL;</a>
<a name="ln6926">    }</a>
<a name="ln6927"> </a>
<a name="ln6928">    char *const buf = xmallocz(MAXPATHL);</a>
<a name="ln6929"> </a>
<a name="ln6930">    char *cpy;</a>
<a name="ln6931">    for (;; ) {</a>
<a name="ln6932">      for (;; ) {</a>
<a name="ln6933">        len = readlink(p, buf, MAXPATHL);</a>
<a name="ln6934">        if (len &lt;= 0) {</a>
<a name="ln6935">          break;</a>
<a name="ln6936">        }</a>
<a name="ln6937">        buf[len] = NUL;</a>
<a name="ln6938"> </a>
<a name="ln6939">        if (limit-- == 0) {</a>
<a name="ln6940">          xfree(p);</a>
<a name="ln6941">          xfree(remain);</a>
<a name="ln6942">          EMSG(_(&quot;E655: Too many symbolic links (cycle?)&quot;));</a>
<a name="ln6943">          rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6944">          xfree(buf);</a>
<a name="ln6945">          return;</a>
<a name="ln6946">        }</a>
<a name="ln6947"> </a>
<a name="ln6948">        // Ensure that the result will have a trailing path separator</a>
<a name="ln6949">        // if the argument has one. */</a>
<a name="ln6950">        if (remain == NULL &amp;&amp; has_trailing_pathsep) {</a>
<a name="ln6951">          add_pathsep(buf);</a>
<a name="ln6952">        }</a>
<a name="ln6953"> </a>
<a name="ln6954">        // Separate the first path component in the link value and</a>
<a name="ln6955">        // concatenate the remainders. */</a>
<a name="ln6956">        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);</a>
<a name="ln6957">        if (*q != NUL) {</a>
<a name="ln6958">          cpy = remain;</a>
<a name="ln6959">          remain = (remain</a>
<a name="ln6960">                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)</a>
<a name="ln6961">                    : xstrdup(q - 1));</a>
<a name="ln6962">          xfree(cpy);</a>
<a name="ln6963">          q[-1] = NUL;</a>
<a name="ln6964">        }</a>
<a name="ln6965"> </a>
<a name="ln6966">        q = (char *)path_tail((char_u *)p);</a>
<a name="ln6967">        if (q &gt; p &amp;&amp; *q == NUL) {</a>
<a name="ln6968">          // Ignore trailing path separator.</a>
<a name="ln6969">          q[-1] = NUL;</a>
<a name="ln6970">          q = (char *)path_tail((char_u *)p);</a>
<a name="ln6971">        }</a>
<a name="ln6972">        if (q &gt; p &amp;&amp; !path_is_absolute((const char_u *)buf)) {</a>
<a name="ln6973">          // Symlink is relative to directory of argument. Replace the</a>
<a name="ln6974">          // symlink with the resolved name in the same directory.</a>
<a name="ln6975">          const size_t p_len = strlen(p);</a>
<a name="ln6976">          const size_t buf_len = strlen(buf);</a>
<a name="ln6977">          p = xrealloc(p, p_len + buf_len + 1);</a>
<a name="ln6978">          memcpy(path_tail((char_u *)p), buf, buf_len + 1);</a>
<a name="ln6979">        } else {</a>
<a name="ln6980">          xfree(p);</a>
<a name="ln6981">          p = xstrdup(buf);</a>
<a name="ln6982">        }</a>
<a name="ln6983">      }</a>
<a name="ln6984"> </a>
<a name="ln6985">      if (remain == NULL) {</a>
<a name="ln6986">        break;</a>
<a name="ln6987">      }</a>
<a name="ln6988"> </a>
<a name="ln6989">      // Append the first path component of &quot;remain&quot; to &quot;p&quot;.</a>
<a name="ln6990">      q = (char *)path_next_component(remain + 1);</a>
<a name="ln6991">      len = q - remain - (*q != NUL);</a>
<a name="ln6992">      const size_t p_len = strlen(p);</a>
<a name="ln6993">      cpy = xmallocz(p_len + len);</a>
<a name="ln6994">      memcpy(cpy, p, p_len + 1);</a>
<a name="ln6995">      xstrlcat(cpy + p_len, remain, len + 1);</a>
<a name="ln6996">      xfree(p);</a>
<a name="ln6997">      p = cpy;</a>
<a name="ln6998"> </a>
<a name="ln6999">      // Shorten &quot;remain&quot;.</a>
<a name="ln7000">      if (*q != NUL) {</a>
<a name="ln7001">        STRMOVE(remain, q - 1);</a>
<a name="ln7002">      } else {</a>
<a name="ln7003">        XFREE_CLEAR(remain);</a>
<a name="ln7004">      }</a>
<a name="ln7005">    }</a>
<a name="ln7006"> </a>
<a name="ln7007">    // If the result is a relative path name, make it explicitly relative to</a>
<a name="ln7008">    // the current directory if and only if the argument had this form.</a>
<a name="ln7009">    if (!vim_ispathsep(*p)) {</a>
<a name="ln7010">      if (is_relative_to_current</a>
<a name="ln7011">          &amp;&amp; *p != NUL</a>
<a name="ln7012">          &amp;&amp; !(p[0] == '.'</a>
<a name="ln7013">               &amp;&amp; (p[1] == NUL</a>
<a name="ln7014">                   || vim_ispathsep(p[1])</a>
<a name="ln7015">                   || (p[1] == '.'</a>
<a name="ln7016">                       &amp;&amp; (p[2] == NUL</a>
<a name="ln7017">                           || vim_ispathsep(p[2])))))) {</a>
<a name="ln7018">        // Prepend &quot;./&quot;.</a>
<a name="ln7019">        cpy = (char *)concat_str((const char_u *)&quot;./&quot;, (const char_u *)p);</a>
<a name="ln7020">        xfree(p);</a>
<a name="ln7021">        p = cpy;</a>
<a name="ln7022">      } else if (!is_relative_to_current) {</a>
<a name="ln7023">        // Strip leading &quot;./&quot;.</a>
<a name="ln7024">        q = p;</a>
<a name="ln7025">        while (q[0] == '.' &amp;&amp; vim_ispathsep(q[1])) {</a>
<a name="ln7026">          q += 2;</a>
<a name="ln7027">        }</a>
<a name="ln7028">        if (q &gt; p) {</a>
<a name="ln7029">          STRMOVE(p, p + 2);</a>
<a name="ln7030">        }</a>
<a name="ln7031">      }</a>
<a name="ln7032">    }</a>
<a name="ln7033"> </a>
<a name="ln7034">    // Ensure that the result will have no trailing path separator</a>
<a name="ln7035">    // if the argument had none.  But keep &quot;/&quot; or &quot;//&quot;.</a>
<a name="ln7036">    if (!has_trailing_pathsep) {</a>
<a name="ln7037">      q = p + strlen(p);</a>
<a name="ln7038">      if (after_pathsep(p, q)) {</a>
<a name="ln7039">        *path_tail_with_sep((char_u *)p) = NUL;</a>
<a name="ln7040">      }</a>
<a name="ln7041">    }</a>
<a name="ln7042"> </a>
<a name="ln7043">    rettv-&gt;vval.v_string = (char_u *)p;</a>
<a name="ln7044">    xfree(buf);</a>
<a name="ln7045">  }</a>
<a name="ln7046"># else</a>
<a name="ln7047">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln7048"># endif</a>
<a name="ln7049">#endif</a>
<a name="ln7050"> </a>
<a name="ln7051">  simplify_filename(rettv-&gt;vval.v_string);</a>
<a name="ln7052">}</a>
<a name="ln7053"> </a>
<a name="ln7054">/*</a>
<a name="ln7055"> * &quot;reverse({list})&quot; function</a>
<a name="ln7056"> */</a>
<a name="ln7057">static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7058">{</a>
<a name="ln7059">  list_T *l;</a>
<a name="ln7060">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7061">    EMSG2(_(e_listarg), &quot;reverse()&quot;);</a>
<a name="ln7062">  } else if (!tv_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7063">                            N_(&quot;reverse() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln7064">    tv_list_reverse(l);</a>
<a name="ln7065">    tv_list_set_ret(rettv, l);</a>
<a name="ln7066">  }</a>
<a name="ln7067">}</a>
<a name="ln7068"> </a>
<a name="ln7069">#define SP_NOMOVE       0x01        ///&lt; don't move cursor</a>
<a name="ln7070">#define SP_REPEAT       0x02        ///&lt; repeat to find outer pair</a>
<a name="ln7071">#define SP_RETCOUNT     0x04        ///&lt; return matchcount</a>
<a name="ln7072">#define SP_SETPCMARK    0x08        ///&lt; set previous context mark</a>
<a name="ln7073">#define SP_START        0x10        ///&lt; accept match at start position</a>
<a name="ln7074">#define SP_SUBPAT       0x20        ///&lt; return nr of matching sub-pattern</a>
<a name="ln7075">#define SP_END          0x40        ///&lt; leave cursor at end of match</a>
<a name="ln7076">#define SP_COLUMN       0x80        ///&lt; start at cursor column</a>
<a name="ln7077"> </a>
<a name="ln7078">/*</a>
<a name="ln7079"> * Get flags for a search function.</a>
<a name="ln7080"> * Possibly sets &quot;p_ws&quot;.</a>
<a name="ln7081"> * Returns BACKWARD, FORWARD or zero (for an error).</a>
<a name="ln7082"> */</a>
<a name="ln7083">static int get_search_arg(typval_T *varp, int *flagsp)</a>
<a name="ln7084">{</a>
<a name="ln7085">  int dir = FORWARD;</a>
<a name="ln7086">  int mask;</a>
<a name="ln7087"> </a>
<a name="ln7088">  if (varp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln7089">    char nbuf[NUMBUFLEN];</a>
<a name="ln7090">    const char *flags = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7091">    if (flags == NULL) {</a>
<a name="ln7092">      return 0;  // Type error; errmsg already given.</a>
<a name="ln7093">    }</a>
<a name="ln7094">    while (*flags != NUL) {</a>
<a name="ln7095">      switch (*flags) {</a>
<a name="ln7096">        case 'b': dir = BACKWARD; break;</a>
<a name="ln7097">        case 'w': p_ws = true; break;</a>
<a name="ln7098">        case 'W': p_ws = false; break;</a>
<a name="ln7099">        default: {</a>
<a name="ln7100">          mask = 0;</a>
<a name="ln7101">          if (flagsp != NULL) {</a>
<a name="ln7102">            switch (*flags) {</a>
<a name="ln7103">              case 'c': mask = SP_START; break;</a>
<a name="ln7104">              case 'e': mask = SP_END; break;</a>
<a name="ln7105">              case 'm': mask = SP_RETCOUNT; break;</a>
<a name="ln7106">              case 'n': mask = SP_NOMOVE; break;</a>
<a name="ln7107">              case 'p': mask = SP_SUBPAT; break;</a>
<a name="ln7108">              case 'r': mask = SP_REPEAT; break;</a>
<a name="ln7109">              case 's': mask = SP_SETPCMARK; break;</a>
<a name="ln7110">              case 'z': mask = SP_COLUMN; break;</a>
<a name="ln7111">            }</a>
<a name="ln7112">          }</a>
<a name="ln7113">          if (mask == 0) {</a>
<a name="ln7114">            emsgf(_(e_invarg2), flags);</a>
<a name="ln7115">            dir = 0;</a>
<a name="ln7116">          } else {</a>
<a name="ln7117">            *flagsp |= mask;</a>
<a name="ln7118">          }</a>
<a name="ln7119">        }</a>
<a name="ln7120">      }</a>
<a name="ln7121">      if (dir == 0) {</a>
<a name="ln7122">        break;</a>
<a name="ln7123">      }</a>
<a name="ln7124">      flags++;</a>
<a name="ln7125">    }</a>
<a name="ln7126">  }</a>
<a name="ln7127">  return dir;</a>
<a name="ln7128">}</a>
<a name="ln7129"> </a>
<a name="ln7130">// Shared by search() and searchpos() functions.</a>
<a name="ln7131">static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)</a>
<a name="ln7132">{</a>
<a name="ln7133">  int flags;</a>
<a name="ln7134">  pos_T pos;</a>
<a name="ln7135">  pos_T save_cursor;</a>
<a name="ln7136">  bool save_p_ws = p_ws;</a>
<a name="ln7137">  int dir;</a>
<a name="ln7138">  int retval = 0;               // default: FAIL</a>
<a name="ln7139">  long lnum_stop = 0;</a>
<a name="ln7140">  proftime_T tm;</a>
<a name="ln7141">  long time_limit = 0;</a>
<a name="ln7142">  int options = SEARCH_KEEP;</a>
<a name="ln7143">  int subpatnum;</a>
<a name="ln7144">  searchit_arg_T sia;</a>
<a name="ln7145"> </a>
<a name="ln7146">  const char *const pat = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7147">  dir = get_search_arg(&amp;argvars[1], flagsp);  // May set p_ws.</a>
<a name="ln7148">  if (dir == 0) {</a>
<a name="ln7149">    goto theend;</a>
<a name="ln7150">  }</a>
<a name="ln7151">  flags = *flagsp;</a>
<a name="ln7152">  if (flags &amp; SP_START) {</a>
<a name="ln7153">    options |= SEARCH_START;</a>
<a name="ln7154">  }</a>
<a name="ln7155">  if (flags &amp; SP_END) {</a>
<a name="ln7156">    options |= SEARCH_END;</a>
<a name="ln7157">  }</a>
<a name="ln7158">  if (flags &amp; SP_COLUMN) {</a>
<a name="ln7159">    options |= SEARCH_COL;</a>
<a name="ln7160">  }</a>
<a name="ln7161"> </a>
<a name="ln7162">  // Optional arguments: line number to stop searching and timeout.</a>
<a name="ln7163">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7164">    lnum_stop = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln7165">    if (lnum_stop &lt; 0) {</a>
<a name="ln7166">      goto theend;</a>
<a name="ln7167">    }</a>
<a name="ln7168">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln7169">      time_limit = tv_get_number_chk(&amp;argvars[3], NULL);</a>
<a name="ln7170">      if (time_limit &lt; 0) {</a>
<a name="ln7171">        goto theend;</a>
<a name="ln7172">      }</a>
<a name="ln7173">    }</a>
<a name="ln7174">  }</a>
<a name="ln7175"> </a>
<a name="ln7176">  // Set the time limit, if there is one.</a>
<a name="ln7177">  tm = profile_setlimit(time_limit);</a>
<a name="ln7178"> </a>
<a name="ln7179">  /*</a>
<a name="ln7180">   * This function does not accept SP_REPEAT and SP_RETCOUNT flags.</a>
<a name="ln7181">   * Check to make sure only those flags are set.</a>
<a name="ln7182">   * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both</a>
<a name="ln7183">   * flags cannot be set. Check for that condition also.</a>
<a name="ln7184">   */</a>
<a name="ln7185">  if (((flags &amp; (SP_REPEAT | SP_RETCOUNT)) != 0)</a>
<a name="ln7186">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7187">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[1]));</a>
<a name="ln7188">    goto theend;</a>
<a name="ln7189">  }</a>
<a name="ln7190"> </a>
<a name="ln7191">  pos = save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7192">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7193">  sia.sa_stop_lnum = (linenr_T)lnum_stop;</a>
<a name="ln7194">  sia.sa_tm = &amp;tm;</a>
<a name="ln7195">  subpatnum = searchit(curwin, curbuf, &amp;pos, NULL, dir, (char_u *)pat, 1,</a>
<a name="ln7196">                       options, RE_SEARCH, &amp;sia);</a>
<a name="ln7197">  if (subpatnum != FAIL) {</a>
<a name="ln7198">    if (flags &amp; SP_SUBPAT)</a>
<a name="ln7199">      retval = subpatnum;</a>
<a name="ln7200">    else</a>
<a name="ln7201">      retval = pos.lnum;</a>
<a name="ln7202">    if (flags &amp; SP_SETPCMARK)</a>
<a name="ln7203">      setpcmark();</a>
<a name="ln7204">    curwin-&gt;w_cursor = pos;</a>
<a name="ln7205">    if (match_pos != NULL) {</a>
<a name="ln7206">      // Store the match cursor position</a>
<a name="ln7207">      match_pos-&gt;lnum = pos.lnum;</a>
<a name="ln7208">      match_pos-&gt;col = pos.col + 1;</a>
<a name="ln7209">    }</a>
<a name="ln7210">    // &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln7211">    // correct that here</a>
<a name="ln7212">    check_cursor();</a>
<a name="ln7213">  }</a>
<a name="ln7214"> </a>
<a name="ln7215">  // If 'n' flag is used: restore cursor position.</a>
<a name="ln7216">  if (flags &amp; SP_NOMOVE) {</a>
<a name="ln7217">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7218">  } else {</a>
<a name="ln7219">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7220">  }</a>
<a name="ln7221">theend:</a>
<a name="ln7222">  p_ws = save_p_ws;</a>
<a name="ln7223"> </a>
<a name="ln7224">  return retval;</a>
<a name="ln7225">}</a>
<a name="ln7226"> </a>
<a name="ln7227">// &quot;rpcnotify()&quot; function</a>
<a name="ln7228">static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7229">{</a>
<a name="ln7230">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7231">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7232"> </a>
<a name="ln7233">  if (check_restricted() || check_secure()) {</a>
<a name="ln7234">    return;</a>
<a name="ln7235">  }</a>
<a name="ln7236"> </a>
<a name="ln7237">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt; 0) {</a>
<a name="ln7238">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7239">    return;</a>
<a name="ln7240">  }</a>
<a name="ln7241"> </a>
<a name="ln7242">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7243">    EMSG2(_(e_invarg2), &quot;Event type must be a string&quot;);</a>
<a name="ln7244">    return;</a>
<a name="ln7245">  }</a>
<a name="ln7246"> </a>
<a name="ln7247">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7248"> </a>
<a name="ln7249">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7250">    ADD(args, vim_to_object(tv));</a>
<a name="ln7251">  }</a>
<a name="ln7252"> </a>
<a name="ln7253">  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,</a>
<a name="ln7254">                      tv_get_string(&amp;argvars[1]), args)) {</a>
<a name="ln7255">    EMSG2(_(e_invarg2), &quot;Channel doesn't exist&quot;);</a>
<a name="ln7256">    return;</a>
<a name="ln7257">  }</a>
<a name="ln7258"> </a>
<a name="ln7259">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln7260">}</a>
<a name="ln7261"> </a>
<a name="ln7262">// &quot;rpcrequest()&quot; function</a>
<a name="ln7263">static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7264">{</a>
<a name="ln7265">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7266">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7267">  const int l_provider_call_nesting = provider_call_nesting;</a>
<a name="ln7268"> </a>
<a name="ln7269">  if (check_restricted() || check_secure()) {</a>
<a name="ln7270">    return;</a>
<a name="ln7271">  }</a>
<a name="ln7272"> </a>
<a name="ln7273">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt;= 0) {</a>
<a name="ln7274">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7275">    return;</a>
<a name="ln7276">  }</a>
<a name="ln7277"> </a>
<a name="ln7278">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7279">    EMSG2(_(e_invarg2), &quot;Method name must be a string&quot;);</a>
<a name="ln7280">    return;</a>
<a name="ln7281">  }</a>
<a name="ln7282"> </a>
<a name="ln7283">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7284"> </a>
<a name="ln7285">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7286">    ADD(args, vim_to_object(tv));</a>
<a name="ln7287">  }</a>
<a name="ln7288"> </a>
<a name="ln7289">  sctx_T save_current_sctx;</a>
<a name="ln7290">  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;</a>
<a name="ln7291">  linenr_T save_sourcing_lnum;</a>
<a name="ln7292">  int save_autocmd_bufnr;</a>
<a name="ln7293">  funccal_entry_T funccal_entry;</a>
<a name="ln7294"> </a>
<a name="ln7295">  if (l_provider_call_nesting) {</a>
<a name="ln7296">    // If this is called from a provider function, restore the scope</a>
<a name="ln7297">    // information of the caller.</a>
<a name="ln7298">    save_current_sctx = current_sctx;</a>
<a name="ln7299">    save_sourcing_name = sourcing_name;</a>
<a name="ln7300">    save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln7301">    save_autocmd_fname = autocmd_fname;</a>
<a name="ln7302">    save_autocmd_match = autocmd_match;</a>
<a name="ln7303">    save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln7304">    save_funccal(&amp;funccal_entry);</a>
<a name="ln7305"> </a>
<a name="ln7306">    current_sctx = provider_caller_scope.script_ctx;</a>
<a name="ln7307">    sourcing_name = provider_caller_scope.sourcing_name;</a>
<a name="ln7308">    sourcing_lnum = provider_caller_scope.sourcing_lnum;</a>
<a name="ln7309">    autocmd_fname = provider_caller_scope.autocmd_fname;</a>
<a name="ln7310">    autocmd_match = provider_caller_scope.autocmd_match;</a>
<a name="ln7311">    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;</a>
<a name="ln7312">    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));</a>
<a name="ln7313">  }</a>
<a name="ln7314"> </a>
<a name="ln7315"> </a>
<a name="ln7316">  Error err = ERROR_INIT;</a>
<a name="ln7317"> </a>
<a name="ln7318">  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;</a>
<a name="ln7319">  const char *method = tv_get_string(&amp;argvars[1]);</a>
<a name="ln7320"> </a>
<a name="ln7321">  Object result = rpc_send_call(chan_id, method, args, &amp;err);</a>
<a name="ln7322"> </a>
<a name="ln7323">  if (l_provider_call_nesting) {</a>
<a name="ln7324">    current_sctx = save_current_sctx;</a>
<a name="ln7325">    sourcing_name = save_sourcing_name;</a>
<a name="ln7326">    sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7327">    autocmd_fname = save_autocmd_fname;</a>
<a name="ln7328">    autocmd_match = save_autocmd_match;</a>
<a name="ln7329">    autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7330">    restore_funccal();</a>
<a name="ln7331">  }</a>
<a name="ln7332"> </a>
<a name="ln7333">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7334">    const char *name = NULL;</a>
<a name="ln7335">    Channel *chan = find_channel(chan_id);</a>
<a name="ln7336">    if (chan) {</a>
<a name="ln7337">      name = rpc_client_name(chan);</a>
<a name="ln7338">    }</a>
<a name="ln7339">    msg_ext_set_kind(&quot;rpc_error&quot;);</a>
<a name="ln7340">    if (name) {</a>
<a name="ln7341">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot; (%s):\n%s&quot;,</a>
<a name="ln7342">                      method, chan_id, name, err.msg);</a>
<a name="ln7343">    } else {</a>
<a name="ln7344">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot;:\n%s&quot;,</a>
<a name="ln7345">                      method, chan_id, err.msg);</a>
<a name="ln7346">    }</a>
<a name="ln7347"> </a>
<a name="ln7348">    goto end;</a>
<a name="ln7349">  }</a>
<a name="ln7350"> </a>
<a name="ln7351">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln7352">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln7353">  }</a>
<a name="ln7354"> </a>
<a name="ln7355">end:</a>
<a name="ln7356">  api_free_object(result);</a>
<a name="ln7357">  api_clear_error(&amp;err);</a>
<a name="ln7358">}</a>
<a name="ln7359"> </a>
<a name="ln7360">// &quot;rpcstart()&quot; function (DEPRECATED)</a>
<a name="ln7361">static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7362">{</a>
<a name="ln7363">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7364">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7365"> </a>
<a name="ln7366">  if (check_restricted() || check_secure()) {</a>
<a name="ln7367">    return;</a>
<a name="ln7368">  }</a>
<a name="ln7369"> </a>
<a name="ln7370">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln7371">      || (argvars[1].v_type != VAR_LIST &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln7372">    // Wrong argument types</a>
<a name="ln7373">    EMSG(_(e_invarg));</a>
<a name="ln7374">    return;</a>
<a name="ln7375">  }</a>
<a name="ln7376"> </a>
<a name="ln7377">  list_T *args = NULL;</a>
<a name="ln7378">  int argsl = 0;</a>
<a name="ln7379">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln7380">    args = argvars[1].vval.v_list;</a>
<a name="ln7381">    argsl = tv_list_len(args);</a>
<a name="ln7382">    // Assert that all list items are strings</a>
<a name="ln7383">    int i = 0;</a>
<a name="ln7384">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7385">      if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_STRING) {</a>
<a name="ln7386">        emsgf(_(&quot;E5010: List item %d of the second argument is not a string&quot;),</a>
<a name="ln7387">              i);</a>
<a name="ln7388">        return;</a>
<a name="ln7389">      }</a>
<a name="ln7390">      i++;</a>
<a name="ln7391">    });</a>
<a name="ln7392">  }</a>
<a name="ln7393"> </a>
<a name="ln7394">  if (argvars[0].vval.v_string == NULL || argvars[0].vval.v_string[0] == NUL) {</a>
<a name="ln7395">    EMSG(_(e_api_spawn_failed));</a>
<a name="ln7396">    return;</a>
<a name="ln7397">  }</a>
<a name="ln7398"> </a>
<a name="ln7399">  // Allocate extra memory for the argument vector and the NULL pointer</a>
<a name="ln7400">  int argvl = argsl + 2;</a>
<a name="ln7401">  char **argv = xmalloc(sizeof(char_u *) * argvl);</a>
<a name="ln7402"> </a>
<a name="ln7403">  // Copy program name</a>
<a name="ln7404">  argv[0] = xstrdup((char *)argvars[0].vval.v_string);</a>
<a name="ln7405"> </a>
<a name="ln7406">  int i = 1;</a>
<a name="ln7407">  // Copy arguments to the vector</a>
<a name="ln7408">  if (argsl &gt; 0) {</a>
<a name="ln7409">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7410">      argv[i++] = xstrdup(tv_get_string(TV_LIST_ITEM_TV(arg)));</a>
<a name="ln7411">    });</a>
<a name="ln7412">  }</a>
<a name="ln7413"> </a>
<a name="ln7414">  // The last item of argv must be NULL</a>
<a name="ln7415">  argv[i] = NULL;</a>
<a name="ln7416"> </a>
<a name="ln7417">  Channel *chan = channel_job_start(argv, CALLBACK_READER_INIT,</a>
<a name="ln7418">                                    CALLBACK_READER_INIT, CALLBACK_NONE,</a>
<a name="ln7419">                                    false, true, false, false, NULL, 0, 0,</a>
<a name="ln7420">                                    NULL, NULL, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln7421">  if (chan) {</a>
<a name="ln7422">    channel_create_event(chan, NULL);</a>
<a name="ln7423">  }</a>
<a name="ln7424">}</a>
<a name="ln7425"> </a>
<a name="ln7426">// &quot;rpcstop()&quot; function</a>
<a name="ln7427">static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7428">{</a>
<a name="ln7429">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7430">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7431"> </a>
<a name="ln7432">  if (check_restricted() || check_secure()) {</a>
<a name="ln7433">    return;</a>
<a name="ln7434">  }</a>
<a name="ln7435"> </a>
<a name="ln7436">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln7437">    // Wrong argument types</a>
<a name="ln7438">    EMSG(_(e_invarg));</a>
<a name="ln7439">    return;</a>
<a name="ln7440">  }</a>
<a name="ln7441"> </a>
<a name="ln7442">  // if called with a job, stop it, else closes the channel</a>
<a name="ln7443">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln7444">  if (find_job(id, false)) {</a>
<a name="ln7445">    f_jobstop(argvars, rettv, NULL);</a>
<a name="ln7446">  } else {</a>
<a name="ln7447">    const char *error;</a>
<a name="ln7448">    rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number,</a>
<a name="ln7449">                                         kChannelPartRpc, &amp;error);</a>
<a name="ln7450">    if (!rettv-&gt;vval.v_number) {</a>
<a name="ln7451">      EMSG(error);</a>
<a name="ln7452">    }</a>
<a name="ln7453">  }</a>
<a name="ln7454">}</a>
<a name="ln7455"> </a>
<a name="ln7456">/*</a>
<a name="ln7457"> * &quot;screenattr()&quot; function</a>
<a name="ln7458"> */</a>
<a name="ln7459">static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7460">{</a>
<a name="ln7461">  int c;</a>
<a name="ln7462"> </a>
<a name="ln7463">  int row = (int)tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7464">  int col = (int)tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7465">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7466">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7467">    c = -1;</a>
<a name="ln7468">  } else {</a>
<a name="ln7469">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7470">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7471">    c = grid-&gt;attrs[grid-&gt;line_offset[row] + col];</a>
<a name="ln7472">  }</a>
<a name="ln7473">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7474">}</a>
<a name="ln7475"> </a>
<a name="ln7476">/*</a>
<a name="ln7477"> * &quot;screenchar()&quot; function</a>
<a name="ln7478"> */</a>
<a name="ln7479">static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7480">{</a>
<a name="ln7481">  int c;</a>
<a name="ln7482"> </a>
<a name="ln7483">  int row = tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7484">  int col = tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7485">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7486">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7487">    c = -1;</a>
<a name="ln7488">  } else {</a>
<a name="ln7489">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7490">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7491">    c = utf_ptr2char(grid-&gt;chars[grid-&gt;line_offset[row] + col]);</a>
<a name="ln7492">  }</a>
<a name="ln7493">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7494">}</a>
<a name="ln7495"> </a>
<a name="ln7496">/*</a>
<a name="ln7497"> * &quot;screencol()&quot; function</a>
<a name="ln7498"> *</a>
<a name="ln7499"> * First column is 1 to be consistent with virtcol().</a>
<a name="ln7500"> */</a>
<a name="ln7501">static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7502">{</a>
<a name="ln7503">  rettv-&gt;vval.v_number = ui_current_col() + 1;</a>
<a name="ln7504">}</a>
<a name="ln7505"> </a>
<a name="ln7506">/// &quot;screenpos({winid}, {lnum}, {col})&quot; function</a>
<a name="ln7507">static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7508">{</a>
<a name="ln7509">  pos_T pos;</a>
<a name="ln7510">  int row = 0;</a>
<a name="ln7511">  int scol = 0, ccol = 0, ecol = 0;</a>
<a name="ln7512"> </a>
<a name="ln7513">  tv_dict_alloc_ret(rettv);</a>
<a name="ln7514">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln7515"> </a>
<a name="ln7516">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7517">  if (wp == NULL) {</a>
<a name="ln7518">    return;</a>
<a name="ln7519">  }</a>
<a name="ln7520"> </a>
<a name="ln7521">  pos.lnum = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7522">  pos.col = tv_get_number(&amp;argvars[2]) - 1;</a>
<a name="ln7523">  pos.coladd = 0;</a>
<a name="ln7524">  textpos2screenpos(wp, &amp;pos, &amp;row, &amp;scol, &amp;ccol, &amp;ecol, false);</a>
<a name="ln7525"> </a>
<a name="ln7526">  tv_dict_add_nr(dict, S_LEN(&quot;row&quot;), row);</a>
<a name="ln7527">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), scol);</a>
<a name="ln7528">  tv_dict_add_nr(dict, S_LEN(&quot;curscol&quot;), ccol);</a>
<a name="ln7529">  tv_dict_add_nr(dict, S_LEN(&quot;endcol&quot;), ecol);</a>
<a name="ln7530">}</a>
<a name="ln7531"> </a>
<a name="ln7532">/*</a>
<a name="ln7533"> * &quot;screenrow()&quot; function</a>
<a name="ln7534"> */</a>
<a name="ln7535">static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7536">{</a>
<a name="ln7537">  rettv-&gt;vval.v_number = ui_current_row() + 1;</a>
<a name="ln7538">}</a>
<a name="ln7539"> </a>
<a name="ln7540">/*</a>
<a name="ln7541"> * &quot;search()&quot; function</a>
<a name="ln7542"> */</a>
<a name="ln7543">static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7544">{</a>
<a name="ln7545">  int flags = 0;</a>
<a name="ln7546"> </a>
<a name="ln7547">  rettv-&gt;vval.v_number = search_cmn(argvars, NULL, &amp;flags);</a>
<a name="ln7548">}</a>
<a name="ln7549"> </a>
<a name="ln7550">/*</a>
<a name="ln7551"> * &quot;searchdecl()&quot; function</a>
<a name="ln7552"> */</a>
<a name="ln7553">static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7554">{</a>
<a name="ln7555">  int locally = 1;</a>
<a name="ln7556">  int thisblock = 0;</a>
<a name="ln7557">  bool error = false;</a>
<a name="ln7558"> </a>
<a name="ln7559">  rettv-&gt;vval.v_number = 1;     // default: FAIL</a>
<a name="ln7560"> </a>
<a name="ln7561">  const char *const name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7562">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln7563">    locally = tv_get_number_chk(&amp;argvars[1], &amp;error) == 0;</a>
<a name="ln7564">    if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7565">      thisblock = tv_get_number_chk(&amp;argvars[2], &amp;error) != 0;</a>
<a name="ln7566">    }</a>
<a name="ln7567">  }</a>
<a name="ln7568">  if (!error &amp;&amp; name != NULL) {</a>
<a name="ln7569">    rettv-&gt;vval.v_number = find_decl((char_u *)name, strlen(name), locally,</a>
<a name="ln7570">                                     thisblock, SEARCH_KEEP) == FAIL;</a>
<a name="ln7571">  }</a>
<a name="ln7572">}</a>
<a name="ln7573"> </a>
<a name="ln7574">/*</a>
<a name="ln7575"> * Used by searchpair() and searchpairpos()</a>
<a name="ln7576"> */</a>
<a name="ln7577">static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)</a>
<a name="ln7578">{</a>
<a name="ln7579">  bool save_p_ws = p_ws;</a>
<a name="ln7580">  int dir;</a>
<a name="ln7581">  int flags = 0;</a>
<a name="ln7582">  int retval = 0;  // default: FAIL</a>
<a name="ln7583">  long lnum_stop = 0;</a>
<a name="ln7584">  long time_limit = 0;</a>
<a name="ln7585"> </a>
<a name="ln7586">  // Get the three pattern arguments: start, middle, end. Will result in an</a>
<a name="ln7587">  // error if not a valid argument.</a>
<a name="ln7588">  char nbuf1[NUMBUFLEN];</a>
<a name="ln7589">  char nbuf2[NUMBUFLEN];</a>
<a name="ln7590">  const char *spat = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7591">  const char *mpat = tv_get_string_buf_chk(&amp;argvars[1], nbuf1);</a>
<a name="ln7592">  const char *epat = tv_get_string_buf_chk(&amp;argvars[2], nbuf2);</a>
<a name="ln7593">  if (spat == NULL || mpat == NULL || epat == NULL) {</a>
<a name="ln7594">    goto theend;  // Type error.</a>
<a name="ln7595">  }</a>
<a name="ln7596"> </a>
<a name="ln7597">  // Handle the optional fourth argument: flags.</a>
<a name="ln7598">  dir = get_search_arg(&amp;argvars[3], &amp;flags);   // may set p_ws.</a>
<a name="ln7599">  if (dir == 0) {</a>
<a name="ln7600">    goto theend;</a>
<a name="ln7601">  }</a>
<a name="ln7602"> </a>
<a name="ln7603">  // Don't accept SP_END or SP_SUBPAT.</a>
<a name="ln7604">  // Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.</a>
<a name="ln7605">  if ((flags &amp; (SP_END | SP_SUBPAT)) != 0</a>
<a name="ln7606">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7607">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[3]));</a>
<a name="ln7608">    goto theend;</a>
<a name="ln7609">  }</a>
<a name="ln7610"> </a>
<a name="ln7611">  // Using 'r' implies 'W', otherwise it doesn't work.</a>
<a name="ln7612">  if (flags &amp; SP_REPEAT) {</a>
<a name="ln7613">    p_ws = false;</a>
<a name="ln7614">  }</a>
<a name="ln7615"> </a>
<a name="ln7616">  // Optional fifth argument: skip expression.</a>
<a name="ln7617">  const typval_T *skip;</a>
<a name="ln7618">  if (argvars[3].v_type == VAR_UNKNOWN</a>
<a name="ln7619">      || argvars[4].v_type == VAR_UNKNOWN) {</a>
<a name="ln7620">    skip = NULL;</a>
<a name="ln7621">  } else {</a>
<a name="ln7622">    skip = &amp;argvars[4];</a>
<a name="ln7623">    if (skip-&gt;v_type != VAR_FUNC</a>
<a name="ln7624">        &amp;&amp; skip-&gt;v_type != VAR_PARTIAL</a>
<a name="ln7625">        &amp;&amp; skip-&gt;v_type != VAR_STRING) {</a>
<a name="ln7626">      emsgf(_(e_invarg2), tv_get_string(&amp;argvars[4]));</a>
<a name="ln7627">      goto theend;  // Type error.</a>
<a name="ln7628">    }</a>
<a name="ln7629">    if (argvars[5].v_type != VAR_UNKNOWN) {</a>
<a name="ln7630">      lnum_stop = tv_get_number_chk(&amp;argvars[5], NULL);</a>
<a name="ln7631">      if (lnum_stop &lt; 0) {</a>
<a name="ln7632">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[5]));</a>
<a name="ln7633">        goto theend;</a>
<a name="ln7634">      }</a>
<a name="ln7635">      if (argvars[6].v_type != VAR_UNKNOWN) {</a>
<a name="ln7636">        time_limit = tv_get_number_chk(&amp;argvars[6], NULL);</a>
<a name="ln7637">        if (time_limit &lt; 0) {</a>
<a name="ln7638">          emsgf(_(e_invarg2), tv_get_string(&amp;argvars[6]));</a>
<a name="ln7639">          goto theend;</a>
<a name="ln7640">        }</a>
<a name="ln7641">      }</a>
<a name="ln7642">    }</a>
<a name="ln7643">  }</a>
<a name="ln7644"> </a>
<a name="ln7645">  retval = do_searchpair(</a>
<a name="ln7646">      spat, mpat, epat, dir, skip,</a>
<a name="ln7647">      flags, match_pos, lnum_stop, time_limit);</a>
<a name="ln7648"> </a>
<a name="ln7649">theend:</a>
<a name="ln7650">  p_ws = save_p_ws;</a>
<a name="ln7651"> </a>
<a name="ln7652">  return retval;</a>
<a name="ln7653">}</a>
<a name="ln7654"> </a>
<a name="ln7655">/*</a>
<a name="ln7656"> * &quot;searchpair()&quot; function</a>
<a name="ln7657"> */</a>
<a name="ln7658">static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7659">{</a>
<a name="ln7660">  rettv-&gt;vval.v_number = searchpair_cmn(argvars, NULL);</a>
<a name="ln7661">}</a>
<a name="ln7662"> </a>
<a name="ln7663">/*</a>
<a name="ln7664"> * &quot;searchpairpos()&quot; function</a>
<a name="ln7665"> */</a>
<a name="ln7666">static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7667">{</a>
<a name="ln7668">  pos_T match_pos;</a>
<a name="ln7669">  int lnum = 0;</a>
<a name="ln7670">  int col = 0;</a>
<a name="ln7671"> </a>
<a name="ln7672">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7673"> </a>
<a name="ln7674">  if (searchpair_cmn(argvars, &amp;match_pos) &gt; 0) {</a>
<a name="ln7675">    lnum = match_pos.lnum;</a>
<a name="ln7676">    col = match_pos.col;</a>
<a name="ln7677">  }</a>
<a name="ln7678"> </a>
<a name="ln7679">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7680">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7681">}</a>
<a name="ln7682"> </a>
<a name="ln7683">/*</a>
<a name="ln7684"> * Search for a start/middle/end thing.</a>
<a name="ln7685"> * Used by searchpair(), see its documentation for the details.</a>
<a name="ln7686"> * Returns 0 or -1 for no match,</a>
<a name="ln7687"> */</a>
<a name="ln7688">long</a>
<a name="ln7689">do_searchpair(</a>
<a name="ln7690">    const char *spat,      // start pattern</a>
<a name="ln7691">    const char *mpat,      // middle pattern</a>
<a name="ln7692">    const char *epat,      // end pattern</a>
<a name="ln7693">    int dir,               // BACKWARD or FORWARD</a>
<a name="ln7694">    const typval_T *skip,  // skip expression</a>
<a name="ln7695">    int flags,             // SP_SETPCMARK and other SP_ values</a>
<a name="ln7696">    pos_T *match_pos,</a>
<a name="ln7697">    linenr_T lnum_stop,    // stop at this line if not zero</a>
<a name="ln7698">    long time_limit        // stop after this many msec</a>
<a name="ln7699">)</a>
<a name="ln7700">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln7701">{</a>
<a name="ln7702">  char_u      *save_cpo;</a>
<a name="ln7703">  char_u      *pat, *pat2 = NULL, *pat3 = NULL;</a>
<a name="ln7704">  long retval = 0;</a>
<a name="ln7705">  pos_T pos;</a>
<a name="ln7706">  pos_T firstpos;</a>
<a name="ln7707">  pos_T foundpos;</a>
<a name="ln7708">  pos_T save_cursor;</a>
<a name="ln7709">  pos_T save_pos;</a>
<a name="ln7710">  int n;</a>
<a name="ln7711">  int nest = 1;</a>
<a name="ln7712">  bool use_skip = false;</a>
<a name="ln7713">  int options = SEARCH_KEEP;</a>
<a name="ln7714">  proftime_T tm;</a>
<a name="ln7715"> </a>
<a name="ln7716">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln7717">  save_cpo = p_cpo;</a>
<a name="ln7718">  p_cpo = empty_option;</a>
<a name="ln7719"> </a>
<a name="ln7720">  // Set the time limit, if there is one.</a>
<a name="ln7721">  tm = profile_setlimit(time_limit);</a>
<a name="ln7722"> </a>
<a name="ln7723">  // Make two search patterns: start/end (pat2, for in nested pairs) and</a>
<a name="ln7724">  // start/middle/end (pat3, for the top pair).</a>
<a name="ln7725">  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;</a>
<a name="ln7726">  pat2 = xmalloc(pat2_len);</a>
<a name="ln7727">  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;</a>
<a name="ln7728">  pat3 = xmalloc(pat3_len);</a>
<a name="ln7729">  snprintf((char *)pat2, pat2_len, &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat);</a>
<a name="ln7730">  if (*mpat == NUL) {</a>
<a name="ln7731">    STRCPY(pat3, pat2);</a>
<a name="ln7732">  } else {</a>
<a name="ln7733">    snprintf((char *)pat3, pat3_len,</a>
<a name="ln7734">             &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat, mpat);</a>
<a name="ln7735">  }</a>
<a name="ln7736">  if (flags &amp; SP_START) {</a>
<a name="ln7737">    options |= SEARCH_START;</a>
<a name="ln7738">  }</a>
<a name="ln7739"> </a>
<a name="ln7740">  if (skip != NULL) {</a>
<a name="ln7741">    // Empty string means to not use the skip expression.</a>
<a name="ln7742">    if (skip-&gt;v_type == VAR_STRING || skip-&gt;v_type == VAR_FUNC) {</a>
<a name="ln7743">      use_skip = skip-&gt;vval.v_string != NULL &amp;&amp; *skip-&gt;vval.v_string != NUL;</a>
<a name="ln7744">    }</a>
<a name="ln7745">  }</a>
<a name="ln7746"> </a>
<a name="ln7747">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7748">  pos = curwin-&gt;w_cursor;</a>
<a name="ln7749">  clearpos(&amp;firstpos);</a>
<a name="ln7750">  clearpos(&amp;foundpos);</a>
<a name="ln7751">  pat = pat3;</a>
<a name="ln7752">  for (;; ) {</a>
<a name="ln7753">    searchit_arg_T sia;</a>
<a name="ln7754">    memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7755">    sia.sa_stop_lnum = lnum_stop;</a>
<a name="ln7756">    sia.sa_tm = &amp;tm;</a>
<a name="ln7757"> </a>
<a name="ln7758">    n = searchit(curwin, curbuf, &amp;pos, NULL, dir, pat, 1L,</a>
<a name="ln7759">                 options, RE_SEARCH, &amp;sia);</a>
<a name="ln7760">    if (n == FAIL || (firstpos.lnum != 0 &amp;&amp; equalpos(pos, firstpos))) {</a>
<a name="ln7761">      // didn't find it or found the first match again: FAIL</a>
<a name="ln7762">      break;</a>
<a name="ln7763">    }</a>
<a name="ln7764"> </a>
<a name="ln7765">    if (firstpos.lnum == 0)</a>
<a name="ln7766">      firstpos = pos;</a>
<a name="ln7767">    if (equalpos(pos, foundpos)) {</a>
<a name="ln7768">      // Found the same position again.  Can happen with a pattern that</a>
<a name="ln7769">      // has &quot;\zs&quot; at the end and searching backwards.  Advance one</a>
<a name="ln7770">      // character and try again.</a>
<a name="ln7771">      if (dir == BACKWARD) {</a>
<a name="ln7772">        decl(&amp;pos);</a>
<a name="ln7773">      } else {</a>
<a name="ln7774">        incl(&amp;pos);</a>
<a name="ln7775">      }</a>
<a name="ln7776">    }</a>
<a name="ln7777">    foundpos = pos;</a>
<a name="ln7778"> </a>
<a name="ln7779">    // clear the start flag to avoid getting stuck here</a>
<a name="ln7780">    options &amp;= ~SEARCH_START;</a>
<a name="ln7781"> </a>
<a name="ln7782">    // If the skip pattern matches, ignore this match.</a>
<a name="ln7783">    if (use_skip) {</a>
<a name="ln7784">      save_pos = curwin-&gt;w_cursor;</a>
<a name="ln7785">      curwin-&gt;w_cursor = pos;</a>
<a name="ln7786">      bool err = false;</a>
<a name="ln7787">      const bool r = eval_expr_to_bool(skip, &amp;err);</a>
<a name="ln7788">      curwin-&gt;w_cursor = save_pos;</a>
<a name="ln7789">      if (err) {</a>
<a name="ln7790">        // Evaluating {skip} caused an error, break here.</a>
<a name="ln7791">        curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7792">        retval = -1;</a>
<a name="ln7793">        break;</a>
<a name="ln7794">      }</a>
<a name="ln7795">      if (r)</a>
<a name="ln7796">        continue;</a>
<a name="ln7797">    }</a>
<a name="ln7798"> </a>
<a name="ln7799">    if ((dir == BACKWARD &amp;&amp; n == 3) || (dir == FORWARD &amp;&amp; n == 2)) {</a>
<a name="ln7800">      // Found end when searching backwards or start when searching</a>
<a name="ln7801">      // forward: nested pair.</a>
<a name="ln7802">      nest++;</a>
<a name="ln7803">      pat = pat2;               // nested, don't search for middle</a>
<a name="ln7804">    } else {</a>
<a name="ln7805">      // Found end when searching forward or start when searching</a>
<a name="ln7806">      // backward: end of (nested) pair; or found middle in outer pair.</a>
<a name="ln7807">      if (--nest == 1) {</a>
<a name="ln7808">        pat = pat3;             // outer level, search for middle</a>
<a name="ln7809">      }</a>
<a name="ln7810">    }</a>
<a name="ln7811"> </a>
<a name="ln7812">    if (nest == 0) {</a>
<a name="ln7813">      // Found the match: return matchcount or line number.</a>
<a name="ln7814">      if (flags &amp; SP_RETCOUNT) {</a>
<a name="ln7815">        retval++;</a>
<a name="ln7816">      } else {</a>
<a name="ln7817">        retval = pos.lnum;</a>
<a name="ln7818">      }</a>
<a name="ln7819">      if (flags &amp; SP_SETPCMARK) {</a>
<a name="ln7820">        setpcmark();</a>
<a name="ln7821">      }</a>
<a name="ln7822">      curwin-&gt;w_cursor = pos;</a>
<a name="ln7823">      if (!(flags &amp; SP_REPEAT))</a>
<a name="ln7824">        break;</a>
<a name="ln7825">      nest = 1;             // search for next unmatched</a>
<a name="ln7826">    }</a>
<a name="ln7827">  }</a>
<a name="ln7828"> </a>
<a name="ln7829">  if (match_pos != NULL) {</a>
<a name="ln7830">    // Store the match cursor position</a>
<a name="ln7831">    match_pos-&gt;lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln7832">    match_pos-&gt;col = curwin-&gt;w_cursor.col + 1;</a>
<a name="ln7833">  }</a>
<a name="ln7834"> </a>
<a name="ln7835">  // If 'n' flag is used or search failed: restore cursor position.</a>
<a name="ln7836">  if ((flags &amp; SP_NOMOVE) || retval == 0) {</a>
<a name="ln7837">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7838">  }</a>
<a name="ln7839"> </a>
<a name="ln7840">  xfree(pat2);</a>
<a name="ln7841">  xfree(pat3);</a>
<a name="ln7842">  if (p_cpo == empty_option) {</a>
<a name="ln7843">    p_cpo = save_cpo;</a>
<a name="ln7844">  } else {</a>
<a name="ln7845">    // Darn, evaluating the {skip} expression changed the value.</a>
<a name="ln7846">    free_string_option(save_cpo);</a>
<a name="ln7847">  }</a>
<a name="ln7848"> </a>
<a name="ln7849">  return retval;</a>
<a name="ln7850">}</a>
<a name="ln7851"> </a>
<a name="ln7852">/*</a>
<a name="ln7853"> * &quot;searchpos()&quot; function</a>
<a name="ln7854"> */</a>
<a name="ln7855">static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7856">{</a>
<a name="ln7857">  pos_T match_pos;</a>
<a name="ln7858">  int flags = 0;</a>
<a name="ln7859"> </a>
<a name="ln7860">  const int n = search_cmn(argvars, &amp;match_pos, &amp;flags);</a>
<a name="ln7861"> </a>
<a name="ln7862">  tv_list_alloc_ret(rettv, 2 + (!!(flags &amp; SP_SUBPAT)));</a>
<a name="ln7863"> </a>
<a name="ln7864">  const int lnum = (n &gt; 0 ? match_pos.lnum : 0);</a>
<a name="ln7865">  const int col = (n &gt; 0 ? match_pos.col : 0);</a>
<a name="ln7866"> </a>
<a name="ln7867">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7868">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7869">  if (flags &amp; SP_SUBPAT) {</a>
<a name="ln7870">    tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)n);</a>
<a name="ln7871">  }</a>
<a name="ln7872">}</a>
<a name="ln7873"> </a>
<a name="ln7874">/// &quot;serverlist()&quot; function</a>
<a name="ln7875">static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7876">{</a>
<a name="ln7877">  size_t n;</a>
<a name="ln7878">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln7879"> </a>
<a name="ln7880">  // Copy addrs into a linked list.</a>
<a name="ln7881">  list_T *const l = tv_list_alloc_ret(rettv, n);</a>
<a name="ln7882">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln7883">    tv_list_append_allocated_string(l, addrs[i]);</a>
<a name="ln7884">  }</a>
<a name="ln7885">  xfree(addrs);</a>
<a name="ln7886">}</a>
<a name="ln7887"> </a>
<a name="ln7888">/// &quot;serverstart()&quot; function</a>
<a name="ln7889">static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7890">{</a>
<a name="ln7891">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7892">  rettv-&gt;vval.v_string = NULL;  // Address of the new server</a>
<a name="ln7893"> </a>
<a name="ln7894">  if (check_restricted() || check_secure()) {</a>
<a name="ln7895">    return;</a>
<a name="ln7896">  }</a>
<a name="ln7897"> </a>
<a name="ln7898">  char *address;</a>
<a name="ln7899">  // If the user supplied an address, use it, otherwise use a temp.</a>
<a name="ln7900">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln7901">    if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln7902">      EMSG(_(e_invarg));</a>
<a name="ln7903">      return;</a>
<a name="ln7904">    } else {</a>
<a name="ln7905">      address = xstrdup(tv_get_string(argvars));</a>
<a name="ln7906">    }</a>
<a name="ln7907">  } else {</a>
<a name="ln7908">    address = server_address_new();</a>
<a name="ln7909">  }</a>
<a name="ln7910"> </a>
<a name="ln7911">  int result = server_start(address);</a>
<a name="ln7912">  xfree(address);</a>
<a name="ln7913"> </a>
<a name="ln7914">  if (result != 0) {</a>
<a name="ln7915">    EMSG2(&quot;Failed to start server: %s&quot;,</a>
<a name="ln7916">          result &gt; 0 ? &quot;Unknown system error&quot; : uv_strerror(result));</a>
<a name="ln7917">    return;</a>
<a name="ln7918">  }</a>
<a name="ln7919"> </a>
<a name="ln7920">  // Since it's possible server_start adjusted the given {address} (e.g.,</a>
<a name="ln7921">  // &quot;localhost:&quot; will now have a port), return the final value to the user.</a>
<a name="ln7922">  size_t n;</a>
<a name="ln7923">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln7924">  rettv-&gt;vval.v_string = (char_u *)addrs[n - 1];</a>
<a name="ln7925"> </a>
<a name="ln7926">  n--;</a>
<a name="ln7927">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln7928">    xfree(addrs[i]);</a>
<a name="ln7929">  }</a>
<a name="ln7930">  xfree(addrs);</a>
<a name="ln7931">}</a>
<a name="ln7932"> </a>
<a name="ln7933">/// &quot;serverstop()&quot; function</a>
<a name="ln7934">static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7935">{</a>
<a name="ln7936">  if (check_restricted() || check_secure()) {</a>
<a name="ln7937">    return;</a>
<a name="ln7938">  }</a>
<a name="ln7939"> </a>
<a name="ln7940">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln7941">    EMSG(_(e_invarg));</a>
<a name="ln7942">    return;</a>
<a name="ln7943">  }</a>
<a name="ln7944"> </a>
<a name="ln7945">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7946">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7947">  if (argvars[0].vval.v_string) {</a>
<a name="ln7948">    bool rv = server_stop((char *)argvars[0].vval.v_string);</a>
<a name="ln7949">    rettv-&gt;vval.v_number = (rv ? 1 : 0);</a>
<a name="ln7950">  }</a>
<a name="ln7951">}</a>
<a name="ln7952"> </a>
<a name="ln7953">/// &quot;setbufline()&quot; function</a>
<a name="ln7954">static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7955">{</a>
<a name="ln7956">    linenr_T lnum;</a>
<a name="ln7957">    buf_T    *buf;</a>
<a name="ln7958"> </a>
<a name="ln7959">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln7960">    if (buf == NULL) {</a>
<a name="ln7961">      rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln7962">    } else {</a>
<a name="ln7963">      lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln7964">      set_buffer_lines(buf, lnum, false, &amp;argvars[2], rettv);</a>
<a name="ln7965">    }</a>
<a name="ln7966">}</a>
<a name="ln7967"> </a>
<a name="ln7968">/*</a>
<a name="ln7969"> * &quot;setbufvar()&quot; function</a>
<a name="ln7970"> */</a>
<a name="ln7971">static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7972">{</a>
<a name="ln7973">  if (check_secure()</a>
<a name="ln7974">      || !tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln7975">    return;</a>
<a name="ln7976">  }</a>
<a name="ln7977">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln7978">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln7979">  typval_T *varp = &amp;argvars[2];</a>
<a name="ln7980"> </a>
<a name="ln7981">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln7982">    if (*varname == '&amp;') {</a>
<a name="ln7983">      long numval;</a>
<a name="ln7984">      bool error = false;</a>
<a name="ln7985">      aco_save_T aco;</a>
<a name="ln7986"> </a>
<a name="ln7987">      // set curbuf to be our buf, temporarily</a>
<a name="ln7988">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln7989"> </a>
<a name="ln7990">      varname++;</a>
<a name="ln7991">      numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln7992">      char nbuf[NUMBUFLEN];</a>
<a name="ln7993">      const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7994">      if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln7995">        set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln7996">      }</a>
<a name="ln7997"> </a>
<a name="ln7998">      // reset notion of buffer</a>
<a name="ln7999">      aucmd_restbuf(&amp;aco);</a>
<a name="ln8000">    } else {</a>
<a name="ln8001">      const size_t varname_len = STRLEN(varname);</a>
<a name="ln8002">      char *const bufvarname = xmalloc(varname_len + 3);</a>
<a name="ln8003">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln8004">      curbuf = buf;</a>
<a name="ln8005">      memcpy(bufvarname, &quot;b:&quot;, 2);</a>
<a name="ln8006">      memcpy(bufvarname + 2, varname, varname_len + 1);</a>
<a name="ln8007">      set_var(bufvarname, varname_len + 2, varp, true);</a>
<a name="ln8008">      xfree(bufvarname);</a>
<a name="ln8009">      curbuf = save_curbuf;</a>
<a name="ln8010">    }</a>
<a name="ln8011">  }</a>
<a name="ln8012">}</a>
<a name="ln8013"> </a>
<a name="ln8014">static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8015">{</a>
<a name="ln8016">  dict_T        *d;</a>
<a name="ln8017">  dictitem_T        *di;</a>
<a name="ln8018"> </a>
<a name="ln8019">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln8020">    EMSG(_(e_dictreq));</a>
<a name="ln8021">    return;</a>
<a name="ln8022">  }</a>
<a name="ln8023"> </a>
<a name="ln8024">  if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln8025">    char_u *const csearch = (char_u *)tv_dict_get_string(d, &quot;char&quot;, false);</a>
<a name="ln8026">    if (csearch != NULL) {</a>
<a name="ln8027">      if (enc_utf8) {</a>
<a name="ln8028">        int pcc[MAX_MCO];</a>
<a name="ln8029">        int c = utfc_ptr2char(csearch, pcc);</a>
<a name="ln8030">        set_last_csearch(c, csearch, utfc_ptr2len(csearch));</a>
<a name="ln8031">      }</a>
<a name="ln8032">      else</a>
<a name="ln8033">        set_last_csearch(PTR2CHAR(csearch),</a>
<a name="ln8034">                         csearch, utfc_ptr2len(csearch));</a>
<a name="ln8035">    }</a>
<a name="ln8036"> </a>
<a name="ln8037">    di = tv_dict_find(d, S_LEN(&quot;forward&quot;));</a>
<a name="ln8038">    if (di != NULL) {</a>
<a name="ln8039">      set_csearch_direction(tv_get_number(&amp;di-&gt;di_tv) ? FORWARD : BACKWARD);</a>
<a name="ln8040">    }</a>
<a name="ln8041"> </a>
<a name="ln8042">    di = tv_dict_find(d, S_LEN(&quot;until&quot;));</a>
<a name="ln8043">    if (di != NULL) {</a>
<a name="ln8044">      set_csearch_until(!!tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln8045">    }</a>
<a name="ln8046">  }</a>
<a name="ln8047">}</a>
<a name="ln8048"> </a>
<a name="ln8049">/*</a>
<a name="ln8050"> * &quot;setcmdpos()&quot; function</a>
<a name="ln8051"> */</a>
<a name="ln8052">static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8053">{</a>
<a name="ln8054">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln8055"> </a>
<a name="ln8056">  if (pos &gt;= 0) {</a>
<a name="ln8057">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln8058">  }</a>
<a name="ln8059">}</a>
<a name="ln8060"> </a>
<a name="ln8061">/// &quot;setenv()&quot; function</a>
<a name="ln8062">static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8063">{</a>
<a name="ln8064">  char namebuf[NUMBUFLEN];</a>
<a name="ln8065">  char valbuf[NUMBUFLEN];</a>
<a name="ln8066">  const char *name = tv_get_string_buf(&amp;argvars[0], namebuf);</a>
<a name="ln8067"> </a>
<a name="ln8068">  if (argvars[1].v_type == VAR_SPECIAL</a>
<a name="ln8069">      &amp;&amp; argvars[1].vval.v_special == kSpecialVarNull) {</a>
<a name="ln8070">    os_unsetenv(name);</a>
<a name="ln8071">  } else {</a>
<a name="ln8072">    os_setenv(name, tv_get_string_buf(&amp;argvars[1], valbuf), 1);</a>
<a name="ln8073">  }</a>
<a name="ln8074">}</a>
<a name="ln8075"> </a>
<a name="ln8076">/// &quot;setfperm({fname}, {mode})&quot; function</a>
<a name="ln8077">static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8078">{</a>
<a name="ln8079">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8080"> </a>
<a name="ln8081">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8082">  if (fname == NULL) {</a>
<a name="ln8083">    return;</a>
<a name="ln8084">  }</a>
<a name="ln8085"> </a>
<a name="ln8086">  char modebuf[NUMBUFLEN];</a>
<a name="ln8087">  const char *const mode_str = tv_get_string_buf_chk(&amp;argvars[1], modebuf);</a>
<a name="ln8088">  if (mode_str == NULL) {</a>
<a name="ln8089">    return;</a>
<a name="ln8090">  }</a>
<a name="ln8091">  if (strlen(mode_str) != 9) {</a>
<a name="ln8092">    EMSG2(_(e_invarg2), mode_str);</a>
<a name="ln8093">    return;</a>
<a name="ln8094">  }</a>
<a name="ln8095"> </a>
<a name="ln8096">  int mask = 1;</a>
<a name="ln8097">  int mode = 0;</a>
<a name="ln8098">  for (int i = 8; i &gt;= 0; i--) {</a>
<a name="ln8099">    if (mode_str[i] != '-') {</a>
<a name="ln8100">      mode |= mask;</a>
<a name="ln8101">    }</a>
<a name="ln8102">    mask = mask &lt;&lt; 1;</a>
<a name="ln8103">  }</a>
<a name="ln8104">  rettv-&gt;vval.v_number = os_setperm(fname, mode) == OK;</a>
<a name="ln8105">}</a>
<a name="ln8106"> </a>
<a name="ln8107">/*</a>
<a name="ln8108"> * &quot;setline()&quot; function</a>
<a name="ln8109"> */</a>
<a name="ln8110">static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8111">{</a>
<a name="ln8112">  linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln8113">  set_buffer_lines(curbuf, lnum, false, &amp;argvars[1], rettv);</a>
<a name="ln8114">}</a>
<a name="ln8115"> </a>
<a name="ln8116">/// Create quickfix/location list from VimL values</a>
<a name="ln8117">///</a>
<a name="ln8118">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln8119">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln8120">///</a>
<a name="ln8121">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln8122">///                     which case quickfix list will be created.</a>
<a name="ln8123">/// @param[in]  args  [list, action, what]</a>
<a name="ln8124">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln8125">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln8126">///                      append to an existing list, replace its content,</a>
<a name="ln8127">///                      or create a new one.</a>
<a name="ln8128">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln8129">///                      Defaults to caller function name.</a>
<a name="ln8130">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln8131">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln8132">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8133">{</a>
<a name="ln8134">  static char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln8135">  const char *title = NULL;</a>
<a name="ln8136">  int action = ' ';</a>
<a name="ln8137">  static int recursive = 0;</a>
<a name="ln8138">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8139">  dict_T *what = NULL;</a>
<a name="ln8140"> </a>
<a name="ln8141">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln8142">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln8143">    EMSG(_(e_listreq));</a>
<a name="ln8144">    return;</a>
<a name="ln8145">  } else if (recursive != 0) {</a>
<a name="ln8146">    EMSG(_(e_au_recursive));</a>
<a name="ln8147">    return;</a>
<a name="ln8148">  }</a>
<a name="ln8149"> </a>
<a name="ln8150">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln8151">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8152">    // Option argument was not given.</a>
<a name="ln8153">    goto skip_args;</a>
<a name="ln8154">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln8155">    EMSG(_(e_stringreq));</a>
<a name="ln8156">    return;</a>
<a name="ln8157">  }</a>
<a name="ln8158">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln8159">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln8160">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln8161">    action = *act;</a>
<a name="ln8162">  } else {</a>
<a name="ln8163">    EMSG2(_(e_invact), act);</a>
<a name="ln8164">    return;</a>
<a name="ln8165">  }</a>
<a name="ln8166"> </a>
<a name="ln8167">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln8168">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8169">    // Option argument was not given.</a>
<a name="ln8170">    goto skip_args;</a>
<a name="ln8171">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln8172">    title = tv_get_string_chk(what_arg);</a>
<a name="ln8173">    if (!title) {</a>
<a name="ln8174">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln8175">      return;</a>
<a name="ln8176">    }</a>
<a name="ln8177">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln8178">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln8179">  } else {</a>
<a name="ln8180">    EMSG(_(e_dictreq));</a>
<a name="ln8181">    return;</a>
<a name="ln8182">  }</a>
<a name="ln8183"> </a>
<a name="ln8184">skip_args:</a>
<a name="ln8185">  if (!title) {</a>
<a name="ln8186">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln8187">  }</a>
<a name="ln8188"> </a>
<a name="ln8189">  recursive++;</a>
<a name="ln8190">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln8191">  if (set_errorlist(wp, l, action, (char_u *)title, what) == OK) {</a>
<a name="ln8192">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8193">  }</a>
<a name="ln8194">  recursive--;</a>
<a name="ln8195">}</a>
<a name="ln8196"> </a>
<a name="ln8197">/*</a>
<a name="ln8198"> * &quot;setloclist()&quot; function</a>
<a name="ln8199"> */</a>
<a name="ln8200">static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8201">{</a>
<a name="ln8202">  win_T       *win;</a>
<a name="ln8203"> </a>
<a name="ln8204">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8205"> </a>
<a name="ln8206">  win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8207">  if (win != NULL) {</a>
<a name="ln8208">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln8209">  }</a>
<a name="ln8210">}</a>
<a name="ln8211"> </a>
<a name="ln8212">/*</a>
<a name="ln8213"> * &quot;setmatches()&quot; function</a>
<a name="ln8214"> */</a>
<a name="ln8215">static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8216">{</a>
<a name="ln8217">  dict_T *d;</a>
<a name="ln8218">  list_T *s = NULL;</a>
<a name="ln8219">  win_T *win = get_optional_window(argvars, 1);</a>
<a name="ln8220"> </a>
<a name="ln8221">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8222">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln8223">    EMSG(_(e_listreq));</a>
<a name="ln8224">    return;</a>
<a name="ln8225">  }</a>
<a name="ln8226">  if (win == NULL) {</a>
<a name="ln8227">    return;</a>
<a name="ln8228">  }</a>
<a name="ln8229"> </a>
<a name="ln8230">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln8231">  // To some extent make sure that we are dealing with a list from</a>
<a name="ln8232">  // &quot;getmatches()&quot;.</a>
<a name="ln8233">  int li_idx = 0;</a>
<a name="ln8234">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8235">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT</a>
<a name="ln8236">        || (d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict) == NULL) {</a>
<a name="ln8237">      emsgf(_(&quot;E474: List item %d is either not a dictionary &quot;</a>
<a name="ln8238">              &quot;or an empty one&quot;), li_idx);</a>
<a name="ln8239">      return;</a>
<a name="ln8240">    }</a>
<a name="ln8241">    if (!(tv_dict_find(d, S_LEN(&quot;group&quot;)) != NULL</a>
<a name="ln8242">          &amp;&amp; (tv_dict_find(d, S_LEN(&quot;pattern&quot;)) != NULL</a>
<a name="ln8243">              || tv_dict_find(d, S_LEN(&quot;pos1&quot;)) != NULL)</a>
<a name="ln8244">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;priority&quot;)) != NULL</a>
<a name="ln8245">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;id&quot;)) != NULL)) {</a>
<a name="ln8246">      emsgf(_(&quot;E474: List item %d is missing one of the required keys&quot;),</a>
<a name="ln8247">            li_idx);</a>
<a name="ln8248">      return;</a>
<a name="ln8249">    }</a>
<a name="ln8250">    li_idx++;</a>
<a name="ln8251">  });</a>
<a name="ln8252"> </a>
<a name="ln8253">  clear_matches(win);</a>
<a name="ln8254">  bool match_add_failed = false;</a>
<a name="ln8255">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8256">    int i = 0;</a>
<a name="ln8257"> </a>
<a name="ln8258">    d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln8259">    dictitem_T *const di = tv_dict_find(d, S_LEN(&quot;pattern&quot;));</a>
<a name="ln8260">    if (di == NULL) {</a>
<a name="ln8261">      if (s == NULL) {</a>
<a name="ln8262">        s = tv_list_alloc(9);</a>
<a name="ln8263">      }</a>
<a name="ln8264"> </a>
<a name="ln8265">      // match from matchaddpos()</a>
<a name="ln8266">      for (i = 1; i &lt; 9; i++) {</a>
<a name="ln8267">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln8268">        snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i);</a>
<a name="ln8269">        dictitem_T *const pos_di = tv_dict_find(d, buf, -1);</a>
<a name="ln8270">        if (pos_di != NULL) {</a>
<a name="ln8271">          if (pos_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln8272">            return;</a>
<a name="ln8273">          }</a>
<a name="ln8274"> </a>
<a name="ln8275">          tv_list_append_tv(s, &amp;pos_di-&gt;di_tv);</a>
<a name="ln8276">          tv_list_ref(s);</a>
<a name="ln8277">        } else {</a>
<a name="ln8278">          break;</a>
<a name="ln8279">        }</a>
<a name="ln8280">      }</a>
<a name="ln8281">    }</a>
<a name="ln8282"> </a>
<a name="ln8283">    // Note: there are three number buffers involved:</a>
<a name="ln8284">    // - group_buf below.</a>
<a name="ln8285">    // - numbuf in tv_dict_get_string().</a>
<a name="ln8286">    // - mybuf in tv_get_string().</a>
<a name="ln8287">    //</a>
<a name="ln8288">    // If you change this code make sure that buffers will not get</a>
<a name="ln8289">    // accidentally reused.</a>
<a name="ln8290">    char group_buf[NUMBUFLEN];</a>
<a name="ln8291">    const char *const group = tv_dict_get_string_buf(d, &quot;group&quot;, group_buf);</a>
<a name="ln8292">    const int priority = (int)tv_dict_get_number(d, &quot;priority&quot;);</a>
<a name="ln8293">    const int id = (int)tv_dict_get_number(d, &quot;id&quot;);</a>
<a name="ln8294">    dictitem_T *const conceal_di = tv_dict_find(d, S_LEN(&quot;conceal&quot;));</a>
<a name="ln8295">    const char *const conceal = (conceal_di != NULL</a>
<a name="ln8296">                                 ? tv_get_string(&amp;conceal_di-&gt;di_tv)</a>
<a name="ln8297">                                 : NULL);</a>
<a name="ln8298">    if (i == 0) {</a>
<a name="ln8299">      if (match_add(win, group,</a>
<a name="ln8300">                    tv_dict_get_string(d, &quot;pattern&quot;, false),</a>
<a name="ln8301">                    priority, id, NULL, conceal) != id) {</a>
<a name="ln8302">        match_add_failed = true;</a>
<a name="ln8303">      }</a>
<a name="ln8304">    } else {</a>
<a name="ln8305">      if (match_add(win, group, NULL, priority, id, s, conceal) != id) {</a>
<a name="ln8306">        match_add_failed = true;</a>
<a name="ln8307">      }</a>
<a name="ln8308">      tv_list_unref(s);</a>
<a name="ln8309">      s = NULL;</a>
<a name="ln8310">    }</a>
<a name="ln8311">  });</a>
<a name="ln8312">  if (!match_add_failed) {</a>
<a name="ln8313">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8314">  }</a>
<a name="ln8315">}</a>
<a name="ln8316"> </a>
<a name="ln8317">/*</a>
<a name="ln8318"> * &quot;setpos()&quot; function</a>
<a name="ln8319"> */</a>
<a name="ln8320">static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8321">{</a>
<a name="ln8322">  pos_T pos;</a>
<a name="ln8323">  int fnum;</a>
<a name="ln8324">  colnr_T     curswant = -1;</a>
<a name="ln8325"> </a>
<a name="ln8326">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8327">  const char *const name = tv_get_string_chk(argvars);</a>
<a name="ln8328">  if (name != NULL) {</a>
<a name="ln8329">    if (list2fpos(&amp;argvars[1], &amp;pos, &amp;fnum, &amp;curswant) == OK) {</a>
<a name="ln8330">      if (pos.col != MAXCOL &amp;&amp; --pos.col &lt; 0) {</a>
<a name="ln8331">        pos.col = 0;</a>
<a name="ln8332">      }</a>
<a name="ln8333">      if (name[0] == '.' &amp;&amp; name[1] == NUL) {</a>
<a name="ln8334">        // set cursor; &quot;fnum&quot; is ignored</a>
<a name="ln8335">        curwin-&gt;w_cursor = pos;</a>
<a name="ln8336">        if (curswant &gt;= 0) {</a>
<a name="ln8337">          curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln8338">          curwin-&gt;w_set_curswant = false;</a>
<a name="ln8339">        }</a>
<a name="ln8340">        check_cursor();</a>
<a name="ln8341">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8342">      } else if (name[0] == '\'' &amp;&amp; name[1] != NUL &amp;&amp; name[2] == NUL)   {</a>
<a name="ln8343">        // set mark</a>
<a name="ln8344">        if (setmark_pos((uint8_t)name[1], &amp;pos, fnum) == OK) {</a>
<a name="ln8345">          rettv-&gt;vval.v_number = 0;</a>
<a name="ln8346">        }</a>
<a name="ln8347">      } else {</a>
<a name="ln8348">        EMSG(_(e_invarg));</a>
<a name="ln8349">      }</a>
<a name="ln8350">    }</a>
<a name="ln8351">  }</a>
<a name="ln8352">}</a>
<a name="ln8353"> </a>
<a name="ln8354">/*</a>
<a name="ln8355"> * &quot;setqflist()&quot; function</a>
<a name="ln8356"> */</a>
<a name="ln8357">static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8358">{</a>
<a name="ln8359">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln8360">}</a>
<a name="ln8361"> </a>
<a name="ln8362">/*</a>
<a name="ln8363"> * &quot;setreg()&quot; function</a>
<a name="ln8364"> */</a>
<a name="ln8365">static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8366">{</a>
<a name="ln8367">  int regname;</a>
<a name="ln8368">  bool append = false;</a>
<a name="ln8369">  MotionType yank_type;</a>
<a name="ln8370">  long block_len;</a>
<a name="ln8371"> </a>
<a name="ln8372">  block_len = -1;</a>
<a name="ln8373">  yank_type = kMTUnknown;</a>
<a name="ln8374"> </a>
<a name="ln8375">  rettv-&gt;vval.v_number = 1;  // FAIL is default.</a>
<a name="ln8376"> </a>
<a name="ln8377">  const char *const strregname = tv_get_string_chk(argvars);</a>
<a name="ln8378">  if (strregname == NULL) {</a>
<a name="ln8379">    return;  // Type error; errmsg already given.</a>
<a name="ln8380">  }</a>
<a name="ln8381">  regname = (uint8_t)(*strregname);</a>
<a name="ln8382">  if (regname == 0 || regname == '@') {</a>
<a name="ln8383">    regname = '&quot;';</a>
<a name="ln8384">  }</a>
<a name="ln8385"> </a>
<a name="ln8386">  bool set_unnamed = false;</a>
<a name="ln8387">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8388">    const char *stropt = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8389">    if (stropt == NULL) {</a>
<a name="ln8390">      return;  // Type error.</a>
<a name="ln8391">    }</a>
<a name="ln8392">    for (; *stropt != NUL; stropt++) {</a>
<a name="ln8393">      switch (*stropt) {</a>
<a name="ln8394">        case 'a': case 'A': {  // append</a>
<a name="ln8395">          append = true;</a>
<a name="ln8396">          break;</a>
<a name="ln8397">        }</a>
<a name="ln8398">        case 'v': case 'c': {  // character-wise selection</a>
<a name="ln8399">          yank_type = kMTCharWise;</a>
<a name="ln8400">          break;</a>
<a name="ln8401">        }</a>
<a name="ln8402">        case 'V': case 'l': {  // line-wise selection</a>
<a name="ln8403">          yank_type = kMTLineWise;</a>
<a name="ln8404">          break;</a>
<a name="ln8405">        }</a>
<a name="ln8406">        case 'b': case Ctrl_V: {  // block-wise selection</a>
<a name="ln8407">          yank_type = kMTBlockWise;</a>
<a name="ln8408">          if (ascii_isdigit(stropt[1])) {</a>
<a name="ln8409">            stropt++;</a>
<a name="ln8410">            block_len = getdigits_long((char_u **)&amp;stropt, true, 0) - 1;</a>
<a name="ln8411">            stropt--;</a>
<a name="ln8412">          }</a>
<a name="ln8413">          break;</a>
<a name="ln8414">        }</a>
<a name="ln8415">        case 'u': case '&quot;': {  // unnamed register</a>
<a name="ln8416">          set_unnamed = true;</a>
<a name="ln8417">          break;</a>
<a name="ln8418">        }</a>
<a name="ln8419">      }</a>
<a name="ln8420">    }</a>
<a name="ln8421">  }</a>
<a name="ln8422"> </a>
<a name="ln8423">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln8424">    list_T *ll = argvars[1].vval.v_list;</a>
<a name="ln8425">    // If the list is NULL handle like an empty list.</a>
<a name="ln8426">    const int len = tv_list_len(ll);</a>
<a name="ln8427"> </a>
<a name="ln8428">    // First half: use for pointers to result lines; second half: use for</a>
<a name="ln8429">    // pointers to allocated copies.</a>
<a name="ln8430">    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));</a>
<a name="ln8431">    const char **curval = (const char **)lstval;</a>
<a name="ln8432">    char **allocval = lstval + len + 2;</a>
<a name="ln8433">    char **curallocval = allocval;</a>
<a name="ln8434"> </a>
<a name="ln8435">    TV_LIST_ITER_CONST(ll, li, {</a>
<a name="ln8436">      char buf[NUMBUFLEN];</a>
<a name="ln8437">      *curval = tv_get_string_buf_chk(TV_LIST_ITEM_TV(li), buf);</a>
<a name="ln8438">      if (*curval == NULL) {</a>
<a name="ln8439">        goto free_lstval;</a>
<a name="ln8440">      }</a>
<a name="ln8441">      if (*curval == buf) {</a>
<a name="ln8442">        // Need to make a copy,</a>
<a name="ln8443">        // next tv_get_string_buf_chk() will overwrite the string.</a>
<a name="ln8444">        *curallocval = xstrdup(*curval);</a>
<a name="ln8445">        *curval = *curallocval;</a>
<a name="ln8446">        curallocval++;</a>
<a name="ln8447">      }</a>
<a name="ln8448">      curval++;</a>
<a name="ln8449">    });</a>
<a name="ln8450">    *curval++ = NULL;</a>
<a name="ln8451"> </a>
<a name="ln8452">    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,</a>
<a name="ln8453">                           block_len);</a>
<a name="ln8454"> </a>
<a name="ln8455">free_lstval:</a>
<a name="ln8456">    while (curallocval &gt; allocval) {</a>
<a name="ln8457">      xfree(*--curallocval);</a>
<a name="ln8458">    }</a>
<a name="ln8459">    xfree(lstval);</a>
<a name="ln8460">  } else {</a>
<a name="ln8461">    const char *strval = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8462">    if (strval == NULL) {</a>
<a name="ln8463">      return;</a>
<a name="ln8464">    }</a>
<a name="ln8465">    write_reg_contents_ex(regname, (const char_u *)strval, STRLEN(strval),</a>
<a name="ln8466">                          append, yank_type, block_len);</a>
<a name="ln8467">  }</a>
<a name="ln8468">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8469"> </a>
<a name="ln8470">  if (set_unnamed) {</a>
<a name="ln8471">    // Discard the result. We already handle the error case.</a>
<a name="ln8472">    if (op_reg_set_previous(regname)) { }</a>
<a name="ln8473">  }</a>
<a name="ln8474">}</a>
<a name="ln8475"> </a>
<a name="ln8476">/*</a>
<a name="ln8477"> * &quot;settabvar()&quot; function</a>
<a name="ln8478"> */</a>
<a name="ln8479">static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8480">{</a>
<a name="ln8481">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8482"> </a>
<a name="ln8483">  if (check_secure()) {</a>
<a name="ln8484">    return;</a>
<a name="ln8485">  }</a>
<a name="ln8486"> </a>
<a name="ln8487">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln8488">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8489">  typval_T *const varp = &amp;argvars[2];</a>
<a name="ln8490"> </a>
<a name="ln8491">  if (varname != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln8492">    tabpage_T *const save_curtab = curtab;</a>
<a name="ln8493">    goto_tabpage_tp(tp, false, false);</a>
<a name="ln8494"> </a>
<a name="ln8495">    const size_t varname_len = strlen(varname);</a>
<a name="ln8496">    char *const tabvarname = xmalloc(varname_len + 3);</a>
<a name="ln8497">    memcpy(tabvarname, &quot;t:&quot;, 2);</a>
<a name="ln8498">    memcpy(tabvarname + 2, varname, varname_len + 1);</a>
<a name="ln8499">    set_var(tabvarname, varname_len + 2, varp, true);</a>
<a name="ln8500">    xfree(tabvarname);</a>
<a name="ln8501"> </a>
<a name="ln8502">    // Restore current tabpage.</a>
<a name="ln8503">    if (valid_tabpage(save_curtab)) {</a>
<a name="ln8504">      goto_tabpage_tp(save_curtab, false, false);</a>
<a name="ln8505">    }</a>
<a name="ln8506">  }</a>
<a name="ln8507">}</a>
<a name="ln8508"> </a>
<a name="ln8509">/*</a>
<a name="ln8510"> * &quot;settabwinvar()&quot; function</a>
<a name="ln8511"> */</a>
<a name="ln8512">static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8513">{</a>
<a name="ln8514">  setwinvar(argvars, rettv, 1);</a>
<a name="ln8515">}</a>
<a name="ln8516"> </a>
<a name="ln8517">// &quot;settagstack()&quot; function</a>
<a name="ln8518">static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8519">{</a>
<a name="ln8520">    static char *e_invact2 = N_(&quot;E962: Invalid action: '%s'&quot;);</a>
<a name="ln8521">    win_T       *wp;</a>
<a name="ln8522">    dict_T      *d;</a>
<a name="ln8523">    int         action = 'r';</a>
<a name="ln8524"> </a>
<a name="ln8525">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln8526"> </a>
<a name="ln8527">    // first argument: window number or id</a>
<a name="ln8528">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8529">    if (wp == NULL) {</a>
<a name="ln8530">      return;</a>
<a name="ln8531">    }</a>
<a name="ln8532"> </a>
<a name="ln8533">    // second argument: dict with items to set in the tag stack</a>
<a name="ln8534">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8535">        EMSG(_(e_dictreq));</a>
<a name="ln8536">        return;</a>
<a name="ln8537">    }</a>
<a name="ln8538">    d = argvars[1].vval.v_dict;</a>
<a name="ln8539">    if (d == NULL) {</a>
<a name="ln8540">      return;</a>
<a name="ln8541">    }</a>
<a name="ln8542"> </a>
<a name="ln8543">    // third argument: action - 'a' for append and 'r' for replace.</a>
<a name="ln8544">    // default is to replace the stack.</a>
<a name="ln8545">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln8546">      action = 'r';</a>
<a name="ln8547">    } else if (argvars[2].v_type == VAR_STRING) {</a>
<a name="ln8548">        const char *actstr;</a>
<a name="ln8549">        actstr = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8550">        if (actstr == NULL) {</a>
<a name="ln8551">          return;</a>
<a name="ln8552">        }</a>
<a name="ln8553">        if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')</a>
<a name="ln8554">            &amp;&amp; actstr[1] == NUL) {</a>
<a name="ln8555">          action = *actstr;</a>
<a name="ln8556">        } else {</a>
<a name="ln8557">            EMSG2(_(e_invact2), actstr);</a>
<a name="ln8558">            return;</a>
<a name="ln8559">        }</a>
<a name="ln8560">    } else {</a>
<a name="ln8561">        EMSG(_(e_stringreq));</a>
<a name="ln8562">        return;</a>
<a name="ln8563">    }</a>
<a name="ln8564"> </a>
<a name="ln8565">    if (set_tagstack(wp, d, action) == OK) {</a>
<a name="ln8566">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8567">    } else {</a>
<a name="ln8568">      EMSG(_(e_listreq));</a>
<a name="ln8569">    }</a>
<a name="ln8570">}</a>
<a name="ln8571"> </a>
<a name="ln8572">/*</a>
<a name="ln8573"> * &quot;setwinvar()&quot; function</a>
<a name="ln8574"> */</a>
<a name="ln8575">static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8576">{</a>
<a name="ln8577">  setwinvar(argvars, rettv, 0);</a>
<a name="ln8578">}</a>
<a name="ln8579"> </a>
<a name="ln8580">/// f_sha256 - sha256({string}) function</a>
<a name="ln8581">static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8582">{</a>
<a name="ln8583">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8584">  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p) , NULL, 0);</a>
<a name="ln8585"> </a>
<a name="ln8586">  // make a copy of the hash (sha256_bytes returns a static buffer)</a>
<a name="ln8587">  rettv-&gt;vval.v_string = (char_u *)xstrdup(hash);</a>
<a name="ln8588">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8589">}</a>
<a name="ln8590"> </a>
<a name="ln8591">/*</a>
<a name="ln8592"> * &quot;shellescape({string})&quot; function</a>
<a name="ln8593"> */</a>
<a name="ln8594">static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8595">{</a>
<a name="ln8596">  const bool do_special = non_zero_arg(&amp;argvars[1]);</a>
<a name="ln8597"> </a>
<a name="ln8598">  rettv-&gt;vval.v_string = vim_strsave_shellescape(</a>
<a name="ln8599">      (const char_u *)tv_get_string(&amp;argvars[0]), do_special, do_special);</a>
<a name="ln8600">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8601">}</a>
<a name="ln8602"> </a>
<a name="ln8603">/*</a>
<a name="ln8604"> * shiftwidth() function</a>
<a name="ln8605"> */</a>
<a name="ln8606">static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8607">{</a>
<a name="ln8608">  rettv-&gt;vval.v_number = get_sw_value(curbuf);</a>
<a name="ln8609">}</a>
<a name="ln8610"> </a>
<a name="ln8611">/// &quot;sign_define()&quot; function</a>
<a name="ln8612">static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8613">{</a>
<a name="ln8614">  const char *name;</a>
<a name="ln8615">  dict_T *dict;</a>
<a name="ln8616">  char *icon = NULL;</a>
<a name="ln8617">  char *linehl = NULL;</a>
<a name="ln8618">  char *text = NULL;</a>
<a name="ln8619">  char *texthl = NULL;</a>
<a name="ln8620">  char *numhl = NULL;</a>
<a name="ln8621"> </a>
<a name="ln8622">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8623"> </a>
<a name="ln8624">  name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8625">  if (name == NULL) {</a>
<a name="ln8626">    return;</a>
<a name="ln8627">  }</a>
<a name="ln8628"> </a>
<a name="ln8629">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8630">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8631">      EMSG(_(e_dictreq));</a>
<a name="ln8632">      return;</a>
<a name="ln8633">    }</a>
<a name="ln8634"> </a>
<a name="ln8635">    // sign attributes</a>
<a name="ln8636">    dict = argvars[1].vval.v_dict;</a>
<a name="ln8637">    if (tv_dict_find(dict, &quot;icon&quot;, -1) != NULL) {</a>
<a name="ln8638">      icon = tv_dict_get_string(dict, &quot;icon&quot;, true);</a>
<a name="ln8639">    }</a>
<a name="ln8640">    if (tv_dict_find(dict, &quot;linehl&quot;, -1) != NULL) {</a>
<a name="ln8641">      linehl = tv_dict_get_string(dict, &quot;linehl&quot;, true);</a>
<a name="ln8642">    }</a>
<a name="ln8643">    if (tv_dict_find(dict, &quot;text&quot;, -1) != NULL) {</a>
<a name="ln8644">      text = tv_dict_get_string(dict, &quot;text&quot;, true);</a>
<a name="ln8645">    }</a>
<a name="ln8646">    if (tv_dict_find(dict, &quot;texthl&quot;, -1) != NULL) {</a>
<a name="ln8647">      texthl = tv_dict_get_string(dict, &quot;texthl&quot;, true);</a>
<a name="ln8648">    }</a>
<a name="ln8649">    if (tv_dict_find(dict, &quot;numhl&quot;, -1) != NULL) {</a>
<a name="ln8650">      numhl = tv_dict_get_string(dict, &quot;numhl&quot;, true);</a>
<a name="ln8651">    }</a>
<a name="ln8652">  }</a>
<a name="ln8653"> </a>
<a name="ln8654">  if (sign_define_by_name((char_u *)name, (char_u *)icon, (char_u *)linehl,</a>
<a name="ln8655">                          (char_u *)text, (char_u *)texthl, (char_u *)numhl)</a>
<a name="ln8656">      == OK) {</a>
<a name="ln8657">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8658">  }</a>
<a name="ln8659"> </a>
<a name="ln8660">  xfree(icon);</a>
<a name="ln8661">  xfree(linehl);</a>
<a name="ln8662">  xfree(text);</a>
<a name="ln8663">  xfree(texthl);</a>
<a name="ln8664">  xfree(numhl);</a>
<a name="ln8665">}</a>
<a name="ln8666"> </a>
<a name="ln8667">/// &quot;sign_getdefined()&quot; function</a>
<a name="ln8668">static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8669">{</a>
<a name="ln8670">  const char *name = NULL;</a>
<a name="ln8671"> </a>
<a name="ln8672">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8673"> </a>
<a name="ln8674">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8675">    name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8676">  }</a>
<a name="ln8677"> </a>
<a name="ln8678">  sign_getlist((const char_u *)name, rettv-&gt;vval.v_list);</a>
<a name="ln8679">}</a>
<a name="ln8680"> </a>
<a name="ln8681">/// &quot;sign_getplaced()&quot; function</a>
<a name="ln8682">static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8683">{</a>
<a name="ln8684">  buf_T *buf = NULL;</a>
<a name="ln8685">  dict_T *dict;</a>
<a name="ln8686">  dictitem_T *di;</a>
<a name="ln8687">  linenr_T lnum = 0;</a>
<a name="ln8688">  int sign_id = 0;</a>
<a name="ln8689">  const char *group = NULL;</a>
<a name="ln8690">  bool notanum = false;</a>
<a name="ln8691"> </a>
<a name="ln8692">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8693"> </a>
<a name="ln8694">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8695">    // get signs placed in the specified buffer</a>
<a name="ln8696">    buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln8697">    if (buf == NULL) {</a>
<a name="ln8698">      return;</a>
<a name="ln8699">    }</a>
<a name="ln8700"> </a>
<a name="ln8701">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8702">      if (argvars[1].v_type != VAR_DICT</a>
<a name="ln8703">          || ((dict = argvars[1].vval.v_dict) == NULL)) {</a>
<a name="ln8704">        EMSG(_(e_dictreq));</a>
<a name="ln8705">        return;</a>
<a name="ln8706">      }</a>
<a name="ln8707">      if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln8708">        // get signs placed at this line</a>
<a name="ln8709">        lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8710">        if (notanum) {</a>
<a name="ln8711">          return;</a>
<a name="ln8712">        }</a>
<a name="ln8713">        (void)lnum;</a>
<a name="ln8714">        lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln8715">      }</a>
<a name="ln8716">      if ((di = tv_dict_find(dict, &quot;id&quot;, -1)) != NULL) {</a>
<a name="ln8717">        // get sign placed with this identifier</a>
<a name="ln8718">        sign_id = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8719">        if (notanum) {</a>
<a name="ln8720">          return;</a>
<a name="ln8721">        }</a>
<a name="ln8722">      }</a>
<a name="ln8723">      if ((di = tv_dict_find(dict, &quot;group&quot;, -1)) != NULL) {</a>
<a name="ln8724">        group = tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln8725">        if (group == NULL) {</a>
<a name="ln8726">          return;</a>
<a name="ln8727">        }</a>
<a name="ln8728">        if (*group == '\0') {  // empty string means global group</a>
<a name="ln8729">          group = NULL;</a>
<a name="ln8730">        }</a>
<a name="ln8731">      }</a>
<a name="ln8732">    }</a>
<a name="ln8733">  }</a>
<a name="ln8734"> </a>
<a name="ln8735">  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,</a>
<a name="ln8736">                  rettv-&gt;vval.v_list);</a>
<a name="ln8737">}</a>
<a name="ln8738"> </a>
<a name="ln8739">/// &quot;sign_jump()&quot; function</a>
<a name="ln8740">static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8741">{</a>
<a name="ln8742">  int sign_id;</a>
<a name="ln8743">  char *sign_group = NULL;</a>
<a name="ln8744">  buf_T *buf;</a>
<a name="ln8745">  bool notanum = false;</a>
<a name="ln8746"> </a>
<a name="ln8747">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8748"> </a>
<a name="ln8749">  // Sign identifer</a>
<a name="ln8750">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln8751">  if (notanum) {</a>
<a name="ln8752">    return;</a>
<a name="ln8753">  }</a>
<a name="ln8754">  if (sign_id &lt;= 0) {</a>
<a name="ln8755">    EMSG(_(e_invarg));</a>
<a name="ln8756">    return;</a>
<a name="ln8757">  }</a>
<a name="ln8758"> </a>
<a name="ln8759">  // Sign group</a>
<a name="ln8760">  const char * sign_group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8761">  if (sign_group_chk == NULL) {</a>
<a name="ln8762">    return;</a>
<a name="ln8763">  }</a>
<a name="ln8764">  if (sign_group_chk[0] == '\0') {</a>
<a name="ln8765">    sign_group = NULL;  // global sign group</a>
<a name="ln8766">  } else {</a>
<a name="ln8767">    sign_group = xstrdup(sign_group_chk);</a>
<a name="ln8768">  }</a>
<a name="ln8769"> </a>
<a name="ln8770">  // Buffer to place the sign</a>
<a name="ln8771">  buf = get_buf_arg(&amp;argvars[2]);</a>
<a name="ln8772">  if (buf == NULL) {</a>
<a name="ln8773">    goto cleanup;</a>
<a name="ln8774">  }</a>
<a name="ln8775"> </a>
<a name="ln8776">  rettv-&gt;vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);</a>
<a name="ln8777"> </a>
<a name="ln8778">cleanup:</a>
<a name="ln8779">  xfree(sign_group);</a>
<a name="ln8780">}</a>
<a name="ln8781"> </a>
<a name="ln8782">/// &quot;sign_place()&quot; function</a>
<a name="ln8783">static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8784">{</a>
<a name="ln8785">  int sign_id;</a>
<a name="ln8786">  char_u *group = NULL;</a>
<a name="ln8787">  const char *sign_name;</a>
<a name="ln8788">  buf_T *buf;</a>
<a name="ln8789">  dict_T *dict;</a>
<a name="ln8790">  dictitem_T *di;</a>
<a name="ln8791">  linenr_T lnum = 0;</a>
<a name="ln8792">  int prio = SIGN_DEF_PRIO;</a>
<a name="ln8793">  bool notanum = false;</a>
<a name="ln8794"> </a>
<a name="ln8795">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8796"> </a>
<a name="ln8797">  // Sign identifer</a>
<a name="ln8798">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln8799">  if (notanum) {</a>
<a name="ln8800">    return;</a>
<a name="ln8801">  }</a>
<a name="ln8802">  if (sign_id &lt; 0) {</a>
<a name="ln8803">    EMSG(_(e_invarg));</a>
<a name="ln8804">    return;</a>
<a name="ln8805">  }</a>
<a name="ln8806"> </a>
<a name="ln8807">  // Sign group</a>
<a name="ln8808">  const char *group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8809">  if (group_chk == NULL) {</a>
<a name="ln8810">    return;</a>
<a name="ln8811">  }</a>
<a name="ln8812">  if (group_chk[0] == '\0') {</a>
<a name="ln8813">    group = NULL;  // global sign group</a>
<a name="ln8814">  } else {</a>
<a name="ln8815">    group = vim_strsave((const char_u *)group_chk);</a>
<a name="ln8816">  }</a>
<a name="ln8817"> </a>
<a name="ln8818">  // Sign name</a>
<a name="ln8819">  sign_name = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8820">  if (sign_name == NULL) {</a>
<a name="ln8821">    goto cleanup;</a>
<a name="ln8822">  }</a>
<a name="ln8823"> </a>
<a name="ln8824">  // Buffer to place the sign</a>
<a name="ln8825">  buf = get_buf_arg(&amp;argvars[3]);</a>
<a name="ln8826">  if (buf == NULL) {</a>
<a name="ln8827">    goto cleanup;</a>
<a name="ln8828">  }</a>
<a name="ln8829"> </a>
<a name="ln8830">  if (argvars[4].v_type != VAR_UNKNOWN) {</a>
<a name="ln8831">    if (argvars[4].v_type != VAR_DICT</a>
<a name="ln8832">        || ((dict = argvars[4].vval.v_dict) == NULL)) {</a>
<a name="ln8833">      EMSG(_(e_dictreq));</a>
<a name="ln8834">      goto cleanup;</a>
<a name="ln8835">    }</a>
<a name="ln8836"> </a>
<a name="ln8837">    // Line number where the sign is to be placed</a>
<a name="ln8838">    if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln8839">      lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8840">      if (notanum) {</a>
<a name="ln8841">        goto cleanup;</a>
<a name="ln8842">      }</a>
<a name="ln8843">      (void)lnum;</a>
<a name="ln8844">      lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln8845">    }</a>
<a name="ln8846">    if ((di = tv_dict_find(dict, &quot;priority&quot;, -1)) != NULL) {</a>
<a name="ln8847">      // Sign priority</a>
<a name="ln8848">      prio = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln8849">      if (notanum) {</a>
<a name="ln8850">        goto cleanup;</a>
<a name="ln8851">      }</a>
<a name="ln8852">    }</a>
<a name="ln8853">  }</a>
<a name="ln8854"> </a>
<a name="ln8855">  if (sign_place(&amp;sign_id, group, (const char_u *)sign_name, buf, lnum, prio)</a>
<a name="ln8856">      == OK) {</a>
<a name="ln8857">    rettv-&gt;vval.v_number = sign_id;</a>
<a name="ln8858">  }</a>
<a name="ln8859"> </a>
<a name="ln8860">cleanup:</a>
<a name="ln8861">  xfree(group);</a>
<a name="ln8862">}</a>
<a name="ln8863"> </a>
<a name="ln8864">/// &quot;sign_undefine()&quot; function</a>
<a name="ln8865">static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8866">{</a>
<a name="ln8867">  const char *name;</a>
<a name="ln8868"> </a>
<a name="ln8869">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8870"> </a>
<a name="ln8871">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln8872">    // Free all the signs</a>
<a name="ln8873">    free_signs();</a>
<a name="ln8874">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8875">  } else {</a>
<a name="ln8876">    // Free only the specified sign</a>
<a name="ln8877">    name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8878">    if (name == NULL) {</a>
<a name="ln8879">      return;</a>
<a name="ln8880">    }</a>
<a name="ln8881"> </a>
<a name="ln8882">    if (sign_undefine_by_name((const char_u *)name) == OK) {</a>
<a name="ln8883">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8884">    }</a>
<a name="ln8885">  }</a>
<a name="ln8886">}</a>
<a name="ln8887"> </a>
<a name="ln8888">/// &quot;sign_unplace()&quot; function</a>
<a name="ln8889">static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8890">{</a>
<a name="ln8891">  dict_T *dict;</a>
<a name="ln8892">  dictitem_T *di;</a>
<a name="ln8893">  int sign_id = 0;</a>
<a name="ln8894">  buf_T *buf = NULL;</a>
<a name="ln8895">  char_u *group = NULL;</a>
<a name="ln8896"> </a>
<a name="ln8897">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8898"> </a>
<a name="ln8899">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8900">    EMSG(_(e_invarg));</a>
<a name="ln8901">    return;</a>
<a name="ln8902">  }</a>
<a name="ln8903"> </a>
<a name="ln8904">  const char *group_chk = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8905">  if (group_chk[0] == '\0') {</a>
<a name="ln8906">    group = NULL;  // global sign group</a>
<a name="ln8907">  } else {</a>
<a name="ln8908">    group = vim_strsave((const char_u *)group_chk);</a>
<a name="ln8909">  }</a>
<a name="ln8910"> </a>
<a name="ln8911">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8912">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8913">      EMSG(_(e_dictreq));</a>
<a name="ln8914">      goto cleanup;</a>
<a name="ln8915">    }</a>
<a name="ln8916">    dict = argvars[1].vval.v_dict;</a>
<a name="ln8917"> </a>
<a name="ln8918">    if ((di = tv_dict_find(dict, &quot;buffer&quot;, -1)) != NULL) {</a>
<a name="ln8919">      buf = get_buf_arg(&amp;di-&gt;di_tv);</a>
<a name="ln8920">      if (buf == NULL) {</a>
<a name="ln8921">        goto cleanup;</a>
<a name="ln8922">      }</a>
<a name="ln8923">    }</a>
<a name="ln8924">    if (tv_dict_find(dict, &quot;id&quot;, -1) != NULL) {</a>
<a name="ln8925">      sign_id = tv_dict_get_number(dict, &quot;id&quot;);</a>
<a name="ln8926">    }</a>
<a name="ln8927">  }</a>
<a name="ln8928"> </a>
<a name="ln8929">  if (buf == NULL) {</a>
<a name="ln8930">    // Delete the sign in all the buffers</a>
<a name="ln8931">    FOR_ALL_BUFFERS(cbuf) {</a>
<a name="ln8932">      if (sign_unplace(sign_id, group, cbuf, 0) == OK) {</a>
<a name="ln8933">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8934">      }</a>
<a name="ln8935">    }</a>
<a name="ln8936">  } else {</a>
<a name="ln8937">    if (sign_unplace(sign_id, group, buf, 0) == OK) {</a>
<a name="ln8938">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8939">    }</a>
<a name="ln8940">  }</a>
<a name="ln8941"> </a>
<a name="ln8942">cleanup:</a>
<a name="ln8943">  xfree(group);</a>
<a name="ln8944">}</a>
<a name="ln8945"> </a>
<a name="ln8946">/*</a>
<a name="ln8947"> * &quot;simplify()&quot; function</a>
<a name="ln8948"> */</a>
<a name="ln8949">static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8950">{</a>
<a name="ln8951">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8952">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln8953">  simplify_filename(rettv-&gt;vval.v_string);  // Simplify in place.</a>
<a name="ln8954">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8955">}</a>
<a name="ln8956"> </a>
<a name="ln8957">/// &quot;sockconnect()&quot; function</a>
<a name="ln8958">static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8959">{</a>
<a name="ln8960">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln8961">    EMSG(_(e_invarg));</a>
<a name="ln8962">    return;</a>
<a name="ln8963">  }</a>
<a name="ln8964">  if (argvars[2].v_type != VAR_DICT &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8965">    // Wrong argument types</a>
<a name="ln8966">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln8967">    return;</a>
<a name="ln8968">  }</a>
<a name="ln8969"> </a>
<a name="ln8970">  const char *mode = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8971">  const char *address = tv_get_string(&amp;argvars[1]);</a>
<a name="ln8972"> </a>
<a name="ln8973">  bool tcp;</a>
<a name="ln8974">  if (strcmp(mode, &quot;tcp&quot;) == 0) {</a>
<a name="ln8975">    tcp = true;</a>
<a name="ln8976">  } else if (strcmp(mode, &quot;pipe&quot;) == 0) {</a>
<a name="ln8977">    tcp = false;</a>
<a name="ln8978">  } else {</a>
<a name="ln8979">    EMSG2(_(e_invarg2), &quot;invalid mode&quot;);</a>
<a name="ln8980">    return;</a>
<a name="ln8981">  }</a>
<a name="ln8982"> </a>
<a name="ln8983">  bool rpc = false;</a>
<a name="ln8984">  CallbackReader on_data = CALLBACK_READER_INIT;</a>
<a name="ln8985">  if (argvars[2].v_type == VAR_DICT) {</a>
<a name="ln8986">    dict_T *opts = argvars[2].vval.v_dict;</a>
<a name="ln8987">    rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln8988"> </a>
<a name="ln8989">    if (!tv_dict_get_callback(opts, S_LEN(&quot;on_data&quot;), &amp;on_data.cb)) {</a>
<a name="ln8990">      return;</a>
<a name="ln8991">    }</a>
<a name="ln8992">    on_data.buffered = tv_dict_get_number(opts, &quot;data_buffered&quot;);</a>
<a name="ln8993">    if (on_data.buffered &amp;&amp; on_data.cb.type == kCallbackNone) {</a>
<a name="ln8994">      on_data.self = opts;</a>
<a name="ln8995">    }</a>
<a name="ln8996">  }</a>
<a name="ln8997"> </a>
<a name="ln8998">  const char *error = NULL;</a>
<a name="ln8999">  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &amp;error);</a>
<a name="ln9000"> </a>
<a name="ln9001">  if (error) {</a>
<a name="ln9002">    EMSG2(_(&quot;connection failed: %s&quot;), error);</a>
<a name="ln9003">  }</a>
<a name="ln9004"> </a>
<a name="ln9005">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9006">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9007">}</a>
<a name="ln9008"> </a>
<a name="ln9009">/// struct storing information about current sort</a>
<a name="ln9010">typedef struct {</a>
<a name="ln9011">  int item_compare_ic;</a>
<a name="ln9012">  bool item_compare_numeric;</a>
<a name="ln9013">  bool item_compare_numbers;</a>
<a name="ln9014">  bool item_compare_float;</a>
<a name="ln9015">  const char *item_compare_func;</a>
<a name="ln9016">  partial_T *item_compare_partial;</a>
<a name="ln9017">  dict_T *item_compare_selfdict;</a>
<a name="ln9018">  bool item_compare_func_err;</a>
<a name="ln9019">} sortinfo_T;</a>
<a name="ln9020">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln9021"> </a>
<a name="ln9022">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln9023"> </a>
<a name="ln9024">/*</a>
<a name="ln9025"> * Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln9026"> */</a>
<a name="ln9027">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9028">{</a>
<a name="ln9029">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln9030">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln9031"> </a>
<a name="ln9032">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln9033">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln9034"> </a>
<a name="ln9035">  int res;</a>
<a name="ln9036"> </a>
<a name="ln9037">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln9038">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln9039">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln9040"> </a>
<a name="ln9041">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9042">    goto item_compare_end;</a>
<a name="ln9043">  }</a>
<a name="ln9044"> </a>
<a name="ln9045">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln9046">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln9047">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln9048"> </a>
<a name="ln9049">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9050">    goto item_compare_end;</a>
<a name="ln9051">  }</a>
<a name="ln9052"> </a>
<a name="ln9053">  char *tofree1 = NULL;</a>
<a name="ln9054">  char *tofree2 = NULL;</a>
<a name="ln9055">  char *p1;</a>
<a name="ln9056">  char *p2;</a>
<a name="ln9057"> </a>
<a name="ln9058">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln9059">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln9060">  // a non-string to do what the docs promise.</a>
<a name="ln9061">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln9062">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9063">      p1 = &quot;'&quot;;</a>
<a name="ln9064">    } else {</a>
<a name="ln9065">      p1 = (char *)tv1-&gt;vval.v_string;</a>
<a name="ln9066">    }</a>
<a name="ln9067">  } else {</a>
<a name="ln9068">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln9069">  }</a>
<a name="ln9070">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln9071">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9072">      p2 = &quot;'&quot;;</a>
<a name="ln9073">    } else {</a>
<a name="ln9074">      p2 = (char *)tv2-&gt;vval.v_string;</a>
<a name="ln9075">    }</a>
<a name="ln9076">  } else {</a>
<a name="ln9077">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln9078">  }</a>
<a name="ln9079">  if (p1 == NULL) {</a>
<a name="ln9080">    p1 = &quot;&quot;;</a>
<a name="ln9081">  }</a>
<a name="ln9082">  if (p2 == NULL) {</a>
<a name="ln9083">    p2 = &quot;&quot;;</a>
<a name="ln9084">  }</a>
<a name="ln9085">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9086">    if (sortinfo-&gt;item_compare_ic) {</a>
<a name="ln9087">      res = STRICMP(p1, p2);</a>
<a name="ln9088">    } else {</a>
<a name="ln9089">      res = STRCMP(p1, p2);</a>
<a name="ln9090">    }</a>
<a name="ln9091">  } else {</a>
<a name="ln9092">    double n1, n2;</a>
<a name="ln9093">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln9094">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln9095">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln9096">  }</a>
<a name="ln9097"> </a>
<a name="ln9098">  xfree(tofree1);</a>
<a name="ln9099">  xfree(tofree2);</a>
<a name="ln9100"> </a>
<a name="ln9101">item_compare_end:</a>
<a name="ln9102">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln9103">  // sort stable.</a>
<a name="ln9104">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9105">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9106">    // indexes are there.</a>
<a name="ln9107">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9108">  }</a>
<a name="ln9109">  return res;</a>
<a name="ln9110">}</a>
<a name="ln9111"> </a>
<a name="ln9112">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9113">{</a>
<a name="ln9114">  return item_compare(s1, s2, true);</a>
<a name="ln9115">}</a>
<a name="ln9116"> </a>
<a name="ln9117">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9118">{</a>
<a name="ln9119">  return item_compare(s1, s2, false);</a>
<a name="ln9120">}</a>
<a name="ln9121"> </a>
<a name="ln9122">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9123">{</a>
<a name="ln9124">  ListSortItem *si1, *si2;</a>
<a name="ln9125">  int res;</a>
<a name="ln9126">  typval_T rettv;</a>
<a name="ln9127">  typval_T argv[3];</a>
<a name="ln9128">  int dummy;</a>
<a name="ln9129">  const char *func_name;</a>
<a name="ln9130">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln9131"> </a>
<a name="ln9132">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln9133">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9134">    return 0;</a>
<a name="ln9135">  }</a>
<a name="ln9136"> </a>
<a name="ln9137">  si1 = (ListSortItem *)s1;</a>
<a name="ln9138">  si2 = (ListSortItem *)s2;</a>
<a name="ln9139"> </a>
<a name="ln9140">  if (partial == NULL) {</a>
<a name="ln9141">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln9142">  } else {</a>
<a name="ln9143">    func_name = (const char *)partial_name(partial);</a>
<a name="ln9144">  }</a>
<a name="ln9145"> </a>
<a name="ln9146">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln9147">  // in the copy without changing the original list items.</a>
<a name="ln9148">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln9149">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln9150"> </a>
<a name="ln9151">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln9152">  res = call_func((const char_u *)func_name,</a>
<a name="ln9153">                  -1,</a>
<a name="ln9154">                  &amp;rettv, 2, argv, NULL, 0L, 0L, &amp;dummy, true,</a>
<a name="ln9155">                  partial, sortinfo-&gt;item_compare_selfdict);</a>
<a name="ln9156">  tv_clear(&amp;argv[0]);</a>
<a name="ln9157">  tv_clear(&amp;argv[1]);</a>
<a name="ln9158"> </a>
<a name="ln9159">  if (res == FAIL) {</a>
<a name="ln9160">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln9161">  } else {</a>
<a name="ln9162">    res = tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln9163">  }</a>
<a name="ln9164">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9165">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln9166">  }</a>
<a name="ln9167">  tv_clear(&amp;rettv);</a>
<a name="ln9168"> </a>
<a name="ln9169">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln9170">  // the sort stable.</a>
<a name="ln9171">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9172">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9173">    // indexes are there.</a>
<a name="ln9174">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9175">  }</a>
<a name="ln9176"> </a>
<a name="ln9177">  return res;</a>
<a name="ln9178">}</a>
<a name="ln9179"> </a>
<a name="ln9180">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9181">{</a>
<a name="ln9182">  return item_compare2(s1, s2, true);</a>
<a name="ln9183">}</a>
<a name="ln9184"> </a>
<a name="ln9185">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9186">{</a>
<a name="ln9187">  return item_compare2(s1, s2, false);</a>
<a name="ln9188">}</a>
<a name="ln9189"> </a>
<a name="ln9190">/*</a>
<a name="ln9191"> * &quot;sort({list})&quot; function</a>
<a name="ln9192"> */</a>
<a name="ln9193">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln9194">{</a>
<a name="ln9195">  ListSortItem  *ptrs;</a>
<a name="ln9196">  long len;</a>
<a name="ln9197">  long i;</a>
<a name="ln9198"> </a>
<a name="ln9199">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln9200">  // the current one for nested calls.</a>
<a name="ln9201">  sortinfo_T info;</a>
<a name="ln9202">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln9203">  sortinfo = &amp;info;</a>
<a name="ln9204"> </a>
<a name="ln9205">  const char *const arg_errmsg = (sort</a>
<a name="ln9206">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln9207">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln9208"> </a>
<a name="ln9209">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9210">    EMSG2(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln9211">  } else {</a>
<a name="ln9212">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln9213">    if (tv_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln9214">      goto theend;</a>
<a name="ln9215">    }</a>
<a name="ln9216">    tv_list_set_ret(rettv, l);</a>
<a name="ln9217"> </a>
<a name="ln9218">    len = tv_list_len(l);</a>
<a name="ln9219">    if (len &lt;= 1) {</a>
<a name="ln9220">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln9221">    }</a>
<a name="ln9222"> </a>
<a name="ln9223">    info.item_compare_ic = false;</a>
<a name="ln9224">    info.item_compare_numeric = false;</a>
<a name="ln9225">    info.item_compare_numbers = false;</a>
<a name="ln9226">    info.item_compare_float = false;</a>
<a name="ln9227">    info.item_compare_func = NULL;</a>
<a name="ln9228">    info.item_compare_partial = NULL;</a>
<a name="ln9229">    info.item_compare_selfdict = NULL;</a>
<a name="ln9230"> </a>
<a name="ln9231">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9232">      // optional second argument: {func}</a>
<a name="ln9233">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln9234">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln9235">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln9236">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln9237">      } else {</a>
<a name="ln9238">        bool error = false;</a>
<a name="ln9239"> </a>
<a name="ln9240">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9241">        if (error) {</a>
<a name="ln9242">          goto theend;  // type error; errmsg already given</a>
<a name="ln9243">        }</a>
<a name="ln9244">        if (i == 1) {</a>
<a name="ln9245">          info.item_compare_ic = true;</a>
<a name="ln9246">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln9247">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9248">        } else if (i != 0) {</a>
<a name="ln9249">          EMSG(_(e_invarg));</a>
<a name="ln9250">          goto theend;</a>
<a name="ln9251">        }</a>
<a name="ln9252">        if (info.item_compare_func != NULL) {</a>
<a name="ln9253">          if (*info.item_compare_func == NUL) {</a>
<a name="ln9254">            // empty string means default sort</a>
<a name="ln9255">            info.item_compare_func = NULL;</a>
<a name="ln9256">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln9257">            info.item_compare_func = NULL;</a>
<a name="ln9258">            info.item_compare_numeric = true;</a>
<a name="ln9259">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln9260">            info.item_compare_func = NULL;</a>
<a name="ln9261">            info.item_compare_numbers = true;</a>
<a name="ln9262">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln9263">            info.item_compare_func = NULL;</a>
<a name="ln9264">            info.item_compare_float = true;</a>
<a name="ln9265">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln9266">            info.item_compare_func = NULL;</a>
<a name="ln9267">            info.item_compare_ic = true;</a>
<a name="ln9268">          }</a>
<a name="ln9269">        }</a>
<a name="ln9270">      }</a>
<a name="ln9271"> </a>
<a name="ln9272">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9273">        // optional third argument: {dict}</a>
<a name="ln9274">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln9275">          EMSG(_(e_dictreq));</a>
<a name="ln9276">          goto theend;</a>
<a name="ln9277">        }</a>
<a name="ln9278">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln9279">      }</a>
<a name="ln9280">    }</a>
<a name="ln9281"> </a>
<a name="ln9282">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln9283">    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));</a>
<a name="ln9284"> </a>
<a name="ln9285">    if (sort) {</a>
<a name="ln9286">      info.item_compare_func_err = false;</a>
<a name="ln9287">      tv_list_item_sort(l, ptrs,</a>
<a name="ln9288">                        ((info.item_compare_func == NULL</a>
<a name="ln9289">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln9290">                         ? item_compare_not_keeping_zero</a>
<a name="ln9291">                         : item_compare2_not_keeping_zero),</a>
<a name="ln9292">                        &amp;info.item_compare_func_err);</a>
<a name="ln9293">      if (info.item_compare_func_err) {</a>
<a name="ln9294">        EMSG(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln9295">      }</a>
<a name="ln9296">    } else {</a>
<a name="ln9297">      ListSorter item_compare_func_ptr;</a>
<a name="ln9298"> </a>
<a name="ln9299">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln9300">      info.item_compare_func_err = false;</a>
<a name="ln9301">      if (info.item_compare_func != NULL</a>
<a name="ln9302">          || info.item_compare_partial != NULL) {</a>
<a name="ln9303">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln9304">      } else {</a>
<a name="ln9305">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln9306">      }</a>
<a name="ln9307"> </a>
<a name="ln9308">      int idx = 0;</a>
<a name="ln9309">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln9310">           ; li != NULL;) {</a>
<a name="ln9311">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln9312">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln9313">          if (info.item_compare_func_err) {  // -V547</a>
<a name="ln9314">            EMSG(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln9315">            break;</a>
<a name="ln9316">          }</a>
<a name="ln9317">          li = tv_list_item_remove(l, li);</a>
<a name="ln9318">        } else {</a>
<a name="ln9319">          idx++;</a>
<a name="ln9320">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln9321">        }</a>
<a name="ln9322">      }</a>
<a name="ln9323">    }</a>
<a name="ln9324"> </a>
<a name="ln9325">    xfree(ptrs);</a>
<a name="ln9326">  }</a>
<a name="ln9327"> </a>
<a name="ln9328">theend:</a>
<a name="ln9329">  sortinfo = old_sortinfo;</a>
<a name="ln9330">}</a>
<a name="ln9331"> </a>
<a name="ln9332">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln9333">static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9334">{</a>
<a name="ln9335">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln9336">}</a>
<a name="ln9337"> </a>
<a name="ln9338">/// &quot;stdioopen()&quot; function</a>
<a name="ln9339">static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9340">{</a>
<a name="ln9341">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln9342">    EMSG(_(e_invarg));</a>
<a name="ln9343">    return;</a>
<a name="ln9344">  }</a>
<a name="ln9345"> </a>
<a name="ln9346"> </a>
<a name="ln9347">  bool rpc = false;</a>
<a name="ln9348">  CallbackReader on_stdin = CALLBACK_READER_INIT;</a>
<a name="ln9349">  dict_T *opts = argvars[0].vval.v_dict;</a>
<a name="ln9350">  rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9351"> </a>
<a name="ln9352">  if (!tv_dict_get_callback(opts, S_LEN(&quot;on_stdin&quot;), &amp;on_stdin.cb)) {</a>
<a name="ln9353">    return;</a>
<a name="ln9354">  }</a>
<a name="ln9355">  on_stdin.buffered = tv_dict_get_number(opts, &quot;stdin_buffered&quot;);</a>
<a name="ln9356">  if (on_stdin.buffered &amp;&amp; on_stdin.cb.type == kCallbackNone) {</a>
<a name="ln9357">    on_stdin.self = opts;</a>
<a name="ln9358">  }</a>
<a name="ln9359"> </a>
<a name="ln9360">  const char *error;</a>
<a name="ln9361">  uint64_t id = channel_from_stdio(rpc, on_stdin, &amp;error);</a>
<a name="ln9362">  if (!id) {</a>
<a name="ln9363">    EMSG2(e_stdiochan2, error);</a>
<a name="ln9364">  }</a>
<a name="ln9365"> </a>
<a name="ln9366"> </a>
<a name="ln9367">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9368">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9369">}</a>
<a name="ln9370"> </a>
<a name="ln9371">/// &quot;uniq({list})&quot; function</a>
<a name="ln9372">static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9373">{</a>
<a name="ln9374">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln9375">}</a>
<a name="ln9376"> </a>
<a name="ln9377">// &quot;reltimefloat()&quot; function</a>
<a name="ln9378">static void f_reltimefloat(typval_T *argvars , typval_T *rettv, FunPtr fptr)</a>
<a name="ln9379">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9380">{</a>
<a name="ln9381">  proftime_T tm;</a>
<a name="ln9382"> </a>
<a name="ln9383">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9384">  rettv-&gt;vval.v_float = 0;</a>
<a name="ln9385">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln9386">    rettv-&gt;vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;</a>
<a name="ln9387">  }</a>
<a name="ln9388">}</a>
<a name="ln9389"> </a>
<a name="ln9390">/*</a>
<a name="ln9391"> * &quot;soundfold({word})&quot; function</a>
<a name="ln9392"> */</a>
<a name="ln9393">static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9394">{</a>
<a name="ln9395">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9396">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9397">  rettv-&gt;vval.v_string = (char_u *)eval_soundfold(s);</a>
<a name="ln9398">}</a>
<a name="ln9399"> </a>
<a name="ln9400">/*</a>
<a name="ln9401"> * &quot;spellbadword()&quot; function</a>
<a name="ln9402"> */</a>
<a name="ln9403">static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9404">{</a>
<a name="ln9405">  const char *word = &quot;&quot;;</a>
<a name="ln9406">  hlf_T attr = HLF_COUNT;</a>
<a name="ln9407">  size_t len = 0;</a>
<a name="ln9408"> </a>
<a name="ln9409">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9410">    // Find the start and length of the badly spelled word.</a>
<a name="ln9411">    len = spell_move_to(curwin, FORWARD, true, true, &amp;attr);</a>
<a name="ln9412">    if (len != 0) {</a>
<a name="ln9413">      word = (char *)get_cursor_pos_ptr();</a>
<a name="ln9414">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln9415">    }</a>
<a name="ln9416">  } else if (curwin-&gt;w_p_spell &amp;&amp; *curbuf-&gt;b_s.b_p_spl != NUL) {</a>
<a name="ln9417">    const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9418">    int capcol = -1;</a>
<a name="ln9419"> </a>
<a name="ln9420">    if (str != NULL) {</a>
<a name="ln9421">      // Check the argument for spelling.</a>
<a name="ln9422">      while (*str != NUL) {</a>
<a name="ln9423">        len = spell_check(curwin, (char_u *)str, &amp;attr, &amp;capcol, false);</a>
<a name="ln9424">        if (attr != HLF_COUNT) {</a>
<a name="ln9425">          word = str;</a>
<a name="ln9426">          break;</a>
<a name="ln9427">        }</a>
<a name="ln9428">        str += len;</a>
<a name="ln9429">        capcol -= len;</a>
<a name="ln9430">        len = 0;</a>
<a name="ln9431">      }</a>
<a name="ln9432">    }</a>
<a name="ln9433">  }</a>
<a name="ln9434"> </a>
<a name="ln9435">  assert(len &lt;= INT_MAX);</a>
<a name="ln9436">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln9437">  tv_list_append_string(rettv-&gt;vval.v_list, word, len);</a>
<a name="ln9438">  tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln9439">                        (attr == HLF_SPB ? &quot;bad&quot;</a>
<a name="ln9440">                         : attr == HLF_SPR ? &quot;rare&quot;</a>
<a name="ln9441">                         : attr == HLF_SPL ? &quot;local&quot;</a>
<a name="ln9442">                         : attr == HLF_SPC ? &quot;caps&quot;</a>
<a name="ln9443">                         : NULL), -1);</a>
<a name="ln9444">}</a>
<a name="ln9445"> </a>
<a name="ln9446">/*</a>
<a name="ln9447"> * &quot;spellsuggest()&quot; function</a>
<a name="ln9448"> */</a>
<a name="ln9449">static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9450">{</a>
<a name="ln9451">  bool typeerr = false;</a>
<a name="ln9452">  int maxcount;</a>
<a name="ln9453">  garray_T ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln9454">  bool need_capital = false;</a>
<a name="ln9455"> </a>
<a name="ln9456">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln9457">    const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9458">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9459">      maxcount = tv_get_number_chk(&amp;argvars[1], &amp;typeerr);</a>
<a name="ln9460">      if (maxcount &lt;= 0) {</a>
<a name="ln9461">        goto f_spellsuggest_return;</a>
<a name="ln9462">      }</a>
<a name="ln9463">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9464">        need_capital = tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9465">        if (typeerr) {</a>
<a name="ln9466">          goto f_spellsuggest_return;</a>
<a name="ln9467">        }</a>
<a name="ln9468">      }</a>
<a name="ln9469">    } else {</a>
<a name="ln9470">      maxcount = 25;</a>
<a name="ln9471">    }</a>
<a name="ln9472"> </a>
<a name="ln9473">    spell_suggest_list(&amp;ga, (char_u *)str, maxcount, need_capital, false);</a>
<a name="ln9474">  }</a>
<a name="ln9475"> </a>
<a name="ln9476">f_spellsuggest_return:</a>
<a name="ln9477">  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);</a>
<a name="ln9478">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln9479">    char *const p = ((char **)ga.ga_data)[i];</a>
<a name="ln9480">    tv_list_append_allocated_string(rettv-&gt;vval.v_list, p);</a>
<a name="ln9481">  }</a>
<a name="ln9482">  ga_clear(&amp;ga);</a>
<a name="ln9483">}</a>
<a name="ln9484"> </a>
<a name="ln9485">static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9486">{</a>
<a name="ln9487">  char_u      *save_cpo;</a>
<a name="ln9488">  int match;</a>
<a name="ln9489">  colnr_T col = 0;</a>
<a name="ln9490">  bool keepempty = false;</a>
<a name="ln9491">  bool typeerr = false;</a>
<a name="ln9492"> </a>
<a name="ln9493">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln9494">  save_cpo = p_cpo;</a>
<a name="ln9495">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln9496"> </a>
<a name="ln9497">  const char *str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9498">  const char *pat = NULL;</a>
<a name="ln9499">  char patbuf[NUMBUFLEN];</a>
<a name="ln9500">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9501">    pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln9502">    if (pat == NULL) {</a>
<a name="ln9503">      typeerr = true;</a>
<a name="ln9504">    }</a>
<a name="ln9505">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9506">      keepempty = (bool)tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9507">    }</a>
<a name="ln9508">  }</a>
<a name="ln9509">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln9510">    pat = &quot;[\\x01- ]\\+&quot;;</a>
<a name="ln9511">  }</a>
<a name="ln9512"> </a>
<a name="ln9513">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9514"> </a>
<a name="ln9515">  if (typeerr) {</a>
<a name="ln9516">    goto theend;</a>
<a name="ln9517">  }</a>
<a name="ln9518"> </a>
<a name="ln9519">  regmatch_T regmatch = {</a>
<a name="ln9520">    .regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING),</a>
<a name="ln9521">    .startp = { NULL },</a>
<a name="ln9522">    .endp = { NULL },</a>
<a name="ln9523">    .rm_ic = false,</a>
<a name="ln9524">  };</a>
<a name="ln9525">  if (regmatch.regprog != NULL) {</a>
<a name="ln9526">    while (*str != NUL || keepempty) {</a>
<a name="ln9527">      if (*str == NUL) {</a>
<a name="ln9528">        match = false;  // Empty item at the end.</a>
<a name="ln9529">      } else {</a>
<a name="ln9530">        match = vim_regexec_nl(&amp;regmatch, (char_u *)str, col);</a>
<a name="ln9531">      }</a>
<a name="ln9532">      const char *end;</a>
<a name="ln9533">      if (match) {</a>
<a name="ln9534">        end = (const char *)regmatch.startp[0];</a>
<a name="ln9535">      } else {</a>
<a name="ln9536">        end = str + strlen(str);</a>
<a name="ln9537">      }</a>
<a name="ln9538">      if (keepempty || end &gt; str || (tv_list_len(rettv-&gt;vval.v_list) &gt; 0</a>
<a name="ln9539">                                     &amp;&amp; *str != NUL</a>
<a name="ln9540">                                     &amp;&amp; match</a>
<a name="ln9541">                                     &amp;&amp; end &lt; (const char *)regmatch.endp[0])) {</a>
<a name="ln9542">        tv_list_append_string(rettv-&gt;vval.v_list, str, end - str);</a>
<a name="ln9543">      }</a>
<a name="ln9544">      if (!match) {</a>
<a name="ln9545">        break;</a>
<a name="ln9546">      }</a>
<a name="ln9547">      // Advance to just after the match.</a>
<a name="ln9548">      if (regmatch.endp[0] &gt; (char_u *)str) {</a>
<a name="ln9549">        col = 0;</a>
<a name="ln9550">      } else {</a>
<a name="ln9551">        // Don't get stuck at the same match.</a>
<a name="ln9552">        col = (*mb_ptr2len)(regmatch.endp[0]);</a>
<a name="ln9553">      }</a>
<a name="ln9554">      str = (const char *)regmatch.endp[0];</a>
<a name="ln9555">    }</a>
<a name="ln9556"> </a>
<a name="ln9557">    vim_regfree(regmatch.regprog);</a>
<a name="ln9558">  }</a>
<a name="ln9559"> </a>
<a name="ln9560">theend:</a>
<a name="ln9561">  p_cpo = save_cpo;</a>
<a name="ln9562">}</a>
<a name="ln9563"> </a>
<a name="ln9564">/// &quot;stdpath(type)&quot; function</a>
<a name="ln9565">static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9566">{</a>
<a name="ln9567">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9568">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln9569"> </a>
<a name="ln9570">  const char *const p = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9571">  if (p == NULL) {</a>
<a name="ln9572">    return;  // Type error; errmsg already given.</a>
<a name="ln9573">  }</a>
<a name="ln9574"> </a>
<a name="ln9575">  if (strequal(p, &quot;config&quot;)) {</a>
<a name="ln9576">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);</a>
<a name="ln9577">  } else if (strequal(p, &quot;data&quot;)) {</a>
<a name="ln9578">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);</a>
<a name="ln9579">  } else if (strequal(p, &quot;cache&quot;)) {</a>
<a name="ln9580">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);</a>
<a name="ln9581">  } else if (strequal(p, &quot;config_dirs&quot;)) {</a>
<a name="ln9582">    get_xdg_var_list(kXDGConfigDirs, rettv);</a>
<a name="ln9583">  } else if (strequal(p, &quot;data_dirs&quot;)) {</a>
<a name="ln9584">    get_xdg_var_list(kXDGDataDirs, rettv);</a>
<a name="ln9585">  } else {</a>
<a name="ln9586">    EMSG2(_(&quot;E6100: \&quot;%s\&quot; is not a valid stdpath&quot;), p);</a>
<a name="ln9587">  }</a>
<a name="ln9588">}</a>
<a name="ln9589"> </a>
<a name="ln9590">/*</a>
<a name="ln9591"> * &quot;str2float()&quot; function</a>
<a name="ln9592"> */</a>
<a name="ln9593">static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9594">{</a>
<a name="ln9595">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9596">  bool isneg = (*p == '-');</a>
<a name="ln9597"> </a>
<a name="ln9598">  if (*p == '+' || *p == '-') {</a>
<a name="ln9599">    p = skipwhite(p + 1);</a>
<a name="ln9600">  }</a>
<a name="ln9601">  (void)string2float((char *)p, &amp;rettv-&gt;vval.v_float);</a>
<a name="ln9602">  if (isneg) {</a>
<a name="ln9603">    rettv-&gt;vval.v_float *= -1;</a>
<a name="ln9604">  }</a>
<a name="ln9605">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9606">}</a>
<a name="ln9607"> </a>
<a name="ln9608">// &quot;str2list()&quot; function</a>
<a name="ln9609">static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9610">{</a>
<a name="ln9611">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln9612">  const char_u *p = (const char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9613"> </a>
<a name="ln9614">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln9615">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln9616">  }</a>
<a name="ln9617">}</a>
<a name="ln9618"> </a>
<a name="ln9619">// &quot;str2nr()&quot; function</a>
<a name="ln9620">static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9621">{</a>
<a name="ln9622">  int base = 10;</a>
<a name="ln9623">  varnumber_T n;</a>
<a name="ln9624">  int what;</a>
<a name="ln9625"> </a>
<a name="ln9626">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9627">    base = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9628">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln9629">      EMSG(_(e_invarg));</a>
<a name="ln9630">      return;</a>
<a name="ln9631">    }</a>
<a name="ln9632">  }</a>
<a name="ln9633"> </a>
<a name="ln9634">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9635">  bool isneg = (*p == '-');</a>
<a name="ln9636">  if (*p == '+' || *p == '-') {</a>
<a name="ln9637">    p = skipwhite(p + 1);</a>
<a name="ln9638">  }</a>
<a name="ln9639">  switch (base) {</a>
<a name="ln9640">    case 2: {</a>
<a name="ln9641">      what = STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln9642">      break;</a>
<a name="ln9643">    }</a>
<a name="ln9644">    case 8: {</a>
<a name="ln9645">      what = STR2NR_OCT | STR2NR_FORCE;</a>
<a name="ln9646">      break;</a>
<a name="ln9647">    }</a>
<a name="ln9648">    case 16: {</a>
<a name="ln9649">      what = STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln9650">      break;</a>
<a name="ln9651">    }</a>
<a name="ln9652">    default: {</a>
<a name="ln9653">      what = 0;</a>
<a name="ln9654">    }</a>
<a name="ln9655">  }</a>
<a name="ln9656">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0);</a>
<a name="ln9657">  if (isneg) {</a>
<a name="ln9658">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln9659">  } else {</a>
<a name="ln9660">    rettv-&gt;vval.v_number = n;</a>
<a name="ln9661">  }</a>
<a name="ln9662">}</a>
<a name="ln9663"> </a>
<a name="ln9664">/*</a>
<a name="ln9665"> * &quot;strftime({format}[, {time}])&quot; function</a>
<a name="ln9666"> */</a>
<a name="ln9667">static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9668">{</a>
<a name="ln9669">  time_t seconds;</a>
<a name="ln9670"> </a>
<a name="ln9671">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9672"> </a>
<a name="ln9673">  char *p = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9674">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9675">    seconds = time(NULL);</a>
<a name="ln9676">  } else {</a>
<a name="ln9677">    seconds = (time_t)tv_get_number(&amp;argvars[1]);</a>
<a name="ln9678">  }</a>
<a name="ln9679"> </a>
<a name="ln9680">  struct tm curtime;</a>
<a name="ln9681">  struct tm *curtime_ptr = os_localtime_r(&amp;seconds, &amp;curtime);</a>
<a name="ln9682">  // MSVC returns NULL for an invalid value of seconds.</a>
<a name="ln9683">  if (curtime_ptr == NULL) {</a>
<a name="ln9684">    rettv-&gt;vval.v_string = vim_strsave((char_u *)_(&quot;(Invalid)&quot;));</a>
<a name="ln9685">  } else {</a>
<a name="ln9686">    vimconv_T conv;</a>
<a name="ln9687">    char_u      *enc;</a>
<a name="ln9688"> </a>
<a name="ln9689">    conv.vc_type = CONV_NONE;</a>
<a name="ln9690">    enc = enc_locale();</a>
<a name="ln9691">    convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln9692">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9693">      p = (char *)string_convert(&amp;conv, (char_u *)p, NULL);</a>
<a name="ln9694">    }</a>
<a name="ln9695">    char result_buf[256];</a>
<a name="ln9696">    if (p != NULL) {</a>
<a name="ln9697">      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);</a>
<a name="ln9698">    } else {</a>
<a name="ln9699">      result_buf[0] = NUL;</a>
<a name="ln9700">    }</a>
<a name="ln9701"> </a>
<a name="ln9702">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9703">      xfree(p);</a>
<a name="ln9704">    }</a>
<a name="ln9705">    convert_setup(&amp;conv, enc, p_enc);</a>
<a name="ln9706">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9707">      rettv-&gt;vval.v_string = string_convert(&amp;conv, (char_u *)result_buf, NULL);</a>
<a name="ln9708">    } else {</a>
<a name="ln9709">      rettv-&gt;vval.v_string = (char_u *)xstrdup(result_buf);</a>
<a name="ln9710">    }</a>
<a name="ln9711"> </a>
<a name="ln9712">    // Release conversion descriptors.</a>
<a name="ln9713">    convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln9714">    xfree(enc);</a>
<a name="ln9715">  }</a>
<a name="ln9716">}</a>
<a name="ln9717"> </a>
<a name="ln9718">// &quot;strgetchar()&quot; function</a>
<a name="ln9719">static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9720">{</a>
<a name="ln9721">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9722"> </a>
<a name="ln9723">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9724">  if (str == NULL) {</a>
<a name="ln9725">    return;</a>
<a name="ln9726">  }</a>
<a name="ln9727">  bool error = false;</a>
<a name="ln9728">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9729">  if (error) {</a>
<a name="ln9730">    return;</a>
<a name="ln9731">  }</a>
<a name="ln9732"> </a>
<a name="ln9733">  const size_t len = STRLEN(str);</a>
<a name="ln9734">  size_t byteidx = 0;</a>
<a name="ln9735"> </a>
<a name="ln9736">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln9737">    if (charidx == 0) {</a>
<a name="ln9738">      rettv-&gt;vval.v_number = utf_ptr2char((const char_u *)str + byteidx);</a>
<a name="ln9739">      break;</a>
<a name="ln9740">    }</a>
<a name="ln9741">    charidx--;</a>
<a name="ln9742">    byteidx += MB_CPTR2LEN((const char_u *)str + byteidx);</a>
<a name="ln9743">  }</a>
<a name="ln9744">}</a>
<a name="ln9745"> </a>
<a name="ln9746">/*</a>
<a name="ln9747"> * &quot;stridx()&quot; function</a>
<a name="ln9748"> */</a>
<a name="ln9749">static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9750">{</a>
<a name="ln9751">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9752"> </a>
<a name="ln9753">  char buf[NUMBUFLEN];</a>
<a name="ln9754">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9755">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln9756">  const char *const haystack_start = haystack;</a>
<a name="ln9757">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln9758">    return;  // Type error; errmsg already given.</a>
<a name="ln9759">  }</a>
<a name="ln9760"> </a>
<a name="ln9761">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9762">    bool error = false;</a>
<a name="ln9763"> </a>
<a name="ln9764">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln9765">                                                             &amp;error);</a>
<a name="ln9766">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln9767">      return;</a>
<a name="ln9768">    }</a>
<a name="ln9769">    if (start_idx &gt;= 0) {</a>
<a name="ln9770">      haystack += start_idx;</a>
<a name="ln9771">    }</a>
<a name="ln9772">  }</a>
<a name="ln9773"> </a>
<a name="ln9774">  const char *pos = strstr(haystack, needle);</a>
<a name="ln9775">  if (pos != NULL) {</a>
<a name="ln9776">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln9777">  }</a>
<a name="ln9778">}</a>
<a name="ln9779"> </a>
<a name="ln9780">/*</a>
<a name="ln9781"> * &quot;string()&quot; function</a>
<a name="ln9782"> */</a>
<a name="ln9783">void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9784">{</a>
<a name="ln9785">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9786">  rettv-&gt;vval.v_string = (char_u *)encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln9787">}</a>
<a name="ln9788"> </a>
<a name="ln9789">/*</a>
<a name="ln9790"> * &quot;strlen()&quot; function</a>
<a name="ln9791"> */</a>
<a name="ln9792">static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9793">{</a>
<a name="ln9794">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln9795">}</a>
<a name="ln9796"> </a>
<a name="ln9797">/*</a>
<a name="ln9798"> * &quot;strchars()&quot; function</a>
<a name="ln9799"> */</a>
<a name="ln9800">static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9801">{</a>
<a name="ln9802">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9803">  int skipcc = 0;</a>
<a name="ln9804">  varnumber_T len = 0;</a>
<a name="ln9805">  int (*func_mb_ptr2char_adv)(const char_u **pp);</a>
<a name="ln9806"> </a>
<a name="ln9807">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9808">    skipcc = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln9809">  }</a>
<a name="ln9810">  if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln9811">    EMSG(_(e_invarg));</a>
<a name="ln9812">  } else {</a>
<a name="ln9813">    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln9814">    while (*s != NUL) {</a>
<a name="ln9815">      func_mb_ptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln9816">      len++;</a>
<a name="ln9817">    }</a>
<a name="ln9818">    rettv-&gt;vval.v_number = len;</a>
<a name="ln9819">  }</a>
<a name="ln9820">}</a>
<a name="ln9821"> </a>
<a name="ln9822">/*</a>
<a name="ln9823"> * &quot;strdisplaywidth()&quot; function</a>
<a name="ln9824"> */</a>
<a name="ln9825">static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9826">{</a>
<a name="ln9827">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9828">  int col = 0;</a>
<a name="ln9829"> </a>
<a name="ln9830">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9831">    col = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9832">  }</a>
<a name="ln9833"> </a>
<a name="ln9834">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);</a>
<a name="ln9835">}</a>
<a name="ln9836"> </a>
<a name="ln9837">/*</a>
<a name="ln9838"> * &quot;strwidth()&quot; function</a>
<a name="ln9839"> */</a>
<a name="ln9840">static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9841">{</a>
<a name="ln9842">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9843"> </a>
<a name="ln9844">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);</a>
<a name="ln9845">}</a>
<a name="ln9846"> </a>
<a name="ln9847">// &quot;strcharpart()&quot; function</a>
<a name="ln9848">static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9849">{</a>
<a name="ln9850">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9851">  const size_t slen = STRLEN(p);</a>
<a name="ln9852"> </a>
<a name="ln9853">  int nbyte = 0;</a>
<a name="ln9854">  bool error = false;</a>
<a name="ln9855">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9856">  if (!error) {</a>
<a name="ln9857">    if (nchar &gt; 0) {</a>
<a name="ln9858">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln9859">        nbyte += MB_CPTR2LEN((const char_u *)p + nbyte);</a>
<a name="ln9860">        nchar--;</a>
<a name="ln9861">      }</a>
<a name="ln9862">    } else {</a>
<a name="ln9863">      nbyte = nchar;</a>
<a name="ln9864">    }</a>
<a name="ln9865">  }</a>
<a name="ln9866">  int len = 0;</a>
<a name="ln9867">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9868">    int charlen = tv_get_number(&amp;argvars[2]);</a>
<a name="ln9869">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln9870">      int off = nbyte + len;</a>
<a name="ln9871"> </a>
<a name="ln9872">      if (off &lt; 0) {</a>
<a name="ln9873">        len += 1;</a>
<a name="ln9874">      } else {</a>
<a name="ln9875">        len += (size_t)MB_CPTR2LEN((const char_u *)p + off);</a>
<a name="ln9876">      }</a>
<a name="ln9877">      charlen--;</a>
<a name="ln9878">    }</a>
<a name="ln9879">  } else {</a>
<a name="ln9880">    len = slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln9881">  }</a>
<a name="ln9882"> </a>
<a name="ln9883">  // Only return the overlap between the specified part and the actual</a>
<a name="ln9884">  // string.</a>
<a name="ln9885">  if (nbyte &lt; 0) {</a>
<a name="ln9886">    len += nbyte;</a>
<a name="ln9887">    nbyte = 0;</a>
<a name="ln9888">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln9889">    nbyte = slen;</a>
<a name="ln9890">  }</a>
<a name="ln9891">  if (len &lt; 0) {</a>
<a name="ln9892">    len = 0;</a>
<a name="ln9893">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln9894">    len = slen - nbyte;</a>
<a name="ln9895">  }</a>
<a name="ln9896"> </a>
<a name="ln9897">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9898">  rettv-&gt;vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln9899">}</a>
<a name="ln9900"> </a>
<a name="ln9901">/*</a>
<a name="ln9902"> * &quot;strpart()&quot; function</a>
<a name="ln9903"> */</a>
<a name="ln9904">static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9905">{</a>
<a name="ln9906">  bool error = false;</a>
<a name="ln9907"> </a>
<a name="ln9908">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9909">  const size_t slen = strlen(p);</a>
<a name="ln9910"> </a>
<a name="ln9911">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9912">  varnumber_T len;</a>
<a name="ln9913">  if (error) {</a>
<a name="ln9914">    len = 0;</a>
<a name="ln9915">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9916">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln9917">  } else {</a>
<a name="ln9918">    len = slen - n;  // Default len: all bytes that are available.</a>
<a name="ln9919">  }</a>
<a name="ln9920"> </a>
<a name="ln9921">  // Only return the overlap between the specified part and the actual</a>
<a name="ln9922">  // string.</a>
<a name="ln9923">  if (n &lt; 0) {</a>
<a name="ln9924">    len += n;</a>
<a name="ln9925">    n = 0;</a>
<a name="ln9926">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln9927">    n = slen;</a>
<a name="ln9928">  }</a>
<a name="ln9929">  if (len &lt; 0) {</a>
<a name="ln9930">    len = 0;</a>
<a name="ln9931">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln9932">    len = slen - n;</a>
<a name="ln9933">  }</a>
<a name="ln9934"> </a>
<a name="ln9935">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln9936">    int off;</a>
<a name="ln9937"> </a>
<a name="ln9938">    // length in characters</a>
<a name="ln9939">    for (off = n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln9940">      off += utfc_ptr2len((char_u *)p + off);</a>
<a name="ln9941">    }</a>
<a name="ln9942">    len = off - n;</a>
<a name="ln9943">  }</a>
<a name="ln9944"> </a>
<a name="ln9945">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9946">  rettv-&gt;vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);</a>
<a name="ln9947">}</a>
<a name="ln9948"> </a>
<a name="ln9949">/*</a>
<a name="ln9950"> * &quot;strridx()&quot; function</a>
<a name="ln9951"> */</a>
<a name="ln9952">static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9953">{</a>
<a name="ln9954">  char buf[NUMBUFLEN];</a>
<a name="ln9955">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9956">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln9957"> </a>
<a name="ln9958">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9959">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln9960">    return;  // Type error; errmsg already given.</a>
<a name="ln9961">  }</a>
<a name="ln9962"> </a>
<a name="ln9963">  const size_t haystack_len = STRLEN(haystack);</a>
<a name="ln9964">  ptrdiff_t end_idx;</a>
<a name="ln9965">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9966">    // Third argument: upper limit for index.</a>
<a name="ln9967">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln9968">    if (end_idx &lt; 0) {</a>
<a name="ln9969">      return;  // Can never find a match.</a>
<a name="ln9970">    }</a>
<a name="ln9971">  } else {</a>
<a name="ln9972">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln9973">  }</a>
<a name="ln9974"> </a>
<a name="ln9975">  const char *lastmatch = NULL;</a>
<a name="ln9976">  if (*needle == NUL) {</a>
<a name="ln9977">    // Empty string matches past the end.</a>
<a name="ln9978">    lastmatch = haystack + end_idx;</a>
<a name="ln9979">  } else {</a>
<a name="ln9980">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln9981">      rest = strstr(rest, needle);</a>
<a name="ln9982">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln9983">        break;</a>
<a name="ln9984">      }</a>
<a name="ln9985">      lastmatch = rest;</a>
<a name="ln9986">    }</a>
<a name="ln9987">  }</a>
<a name="ln9988"> </a>
<a name="ln9989">  if (lastmatch != NULL) {</a>
<a name="ln9990">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln9991">  }</a>
<a name="ln9992">}</a>
<a name="ln9993"> </a>
<a name="ln9994">/*</a>
<a name="ln9995"> * &quot;strtrans()&quot; function</a>
<a name="ln9996"> */</a>
<a name="ln9997">static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9998">{</a>
<a name="ln9999">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10000">  rettv-&gt;vval.v_string = (char_u *)transstr(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10001">}</a>
<a name="ln10002"> </a>
<a name="ln10003">/*</a>
<a name="ln10004"> * &quot;submatch()&quot; function</a>
<a name="ln10005"> */</a>
<a name="ln10006">static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10007">{</a>
<a name="ln10008">  bool error = false;</a>
<a name="ln10009">  int no = (int)tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln10010">  if (error) {</a>
<a name="ln10011">    return;</a>
<a name="ln10012">  }</a>
<a name="ln10013"> </a>
<a name="ln10014">  if (no &lt; 0 || no &gt;= NSUBEXP) {</a>
<a name="ln10015">    emsgf(_(&quot;E935: invalid submatch number: %d&quot;), no);</a>
<a name="ln10016">    return;</a>
<a name="ln10017">  }</a>
<a name="ln10018">  int retList = 0;</a>
<a name="ln10019"> </a>
<a name="ln10020">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10021">    retList = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10022">    if (error) {</a>
<a name="ln10023">      return;</a>
<a name="ln10024">    }</a>
<a name="ln10025">  }</a>
<a name="ln10026"> </a>
<a name="ln10027">  if (retList == 0) {</a>
<a name="ln10028">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10029">    rettv-&gt;vval.v_string = reg_submatch(no);</a>
<a name="ln10030">  } else {</a>
<a name="ln10031">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln10032">    rettv-&gt;vval.v_list = reg_submatch_list(no);</a>
<a name="ln10033">  }</a>
<a name="ln10034">}</a>
<a name="ln10035"> </a>
<a name="ln10036">/*</a>
<a name="ln10037"> * &quot;substitute()&quot; function</a>
<a name="ln10038"> */</a>
<a name="ln10039">static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10040">{</a>
<a name="ln10041">  char patbuf[NUMBUFLEN];</a>
<a name="ln10042">  char subbuf[NUMBUFLEN];</a>
<a name="ln10043">  char flagsbuf[NUMBUFLEN];</a>
<a name="ln10044"> </a>
<a name="ln10045">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10046">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln10047">  const char *sub = NULL;</a>
<a name="ln10048">  const char *const flg = tv_get_string_buf_chk(&amp;argvars[3], flagsbuf);</a>
<a name="ln10049"> </a>
<a name="ln10050">  typval_T *expr = NULL;</a>
<a name="ln10051">  if (tv_is_func(argvars[2])) {</a>
<a name="ln10052">    expr = &amp;argvars[2];</a>
<a name="ln10053">  } else {</a>
<a name="ln10054">    sub = tv_get_string_buf_chk(&amp;argvars[2], subbuf);</a>
<a name="ln10055">  }</a>
<a name="ln10056"> </a>
<a name="ln10057">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10058">  if (str == NULL || pat == NULL || (sub == NULL &amp;&amp; expr == NULL)</a>
<a name="ln10059">      || flg == NULL) {</a>
<a name="ln10060">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10061">  } else {</a>
<a name="ln10062">    rettv-&gt;vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,</a>
<a name="ln10063">                                         (char_u *)sub, expr, (char_u *)flg);</a>
<a name="ln10064">  }</a>
<a name="ln10065">}</a>
<a name="ln10066"> </a>
<a name="ln10067">/// &quot;swapinfo(swap_filename)&quot; function</a>
<a name="ln10068">static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10069">{</a>
<a name="ln10070">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10071">  get_b0_dict(tv_get_string(argvars), rettv-&gt;vval.v_dict);</a>
<a name="ln10072">}</a>
<a name="ln10073"> </a>
<a name="ln10074">/// &quot;swapname(expr)&quot; function</a>
<a name="ln10075">static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10076">{</a>
<a name="ln10077">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10078">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln10079">  if (buf == NULL</a>
<a name="ln10080">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln10081">      || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln10082">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10083">  } else {</a>
<a name="ln10084">    rettv-&gt;vval.v_string = vim_strsave(buf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln10085">  }</a>
<a name="ln10086">}</a>
<a name="ln10087"> </a>
<a name="ln10088">/// &quot;synID(lnum, col, trans)&quot; function</a>
<a name="ln10089">static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10090">{</a>
<a name="ln10091">  // -1 on type error (both)</a>
<a name="ln10092">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10093">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10094"> </a>
<a name="ln10095">  bool transerr = false;</a>
<a name="ln10096">  const int trans = tv_get_number_chk(&amp;argvars[2], &amp;transerr);</a>
<a name="ln10097"> </a>
<a name="ln10098">  int id = 0;</a>
<a name="ln10099">  if (!transerr &amp;&amp; lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10100">      &amp;&amp; col &gt;= 0 &amp;&amp; (size_t)col &lt; STRLEN(ml_get(lnum))) {</a>
<a name="ln10101">    id = syn_get_id(curwin, lnum, col, trans, NULL, false);</a>
<a name="ln10102">  }</a>
<a name="ln10103"> </a>
<a name="ln10104">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10105">}</a>
<a name="ln10106"> </a>
<a name="ln10107">/*</a>
<a name="ln10108"> * &quot;synIDattr(id, what [, mode])&quot; function</a>
<a name="ln10109"> */</a>
<a name="ln10110">static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10111">{</a>
<a name="ln10112">  const int id = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln10113">  const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10114">  int modec;</a>
<a name="ln10115">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10116">    char modebuf[NUMBUFLEN];</a>
<a name="ln10117">    const char *const mode = tv_get_string_buf(&amp;argvars[2], modebuf);</a>
<a name="ln10118">    modec = TOLOWER_ASC(mode[0]);</a>
<a name="ln10119">    if (modec != 'c' &amp;&amp; modec != 'g') {</a>
<a name="ln10120">      modec = 0;  // Replace invalid with current.</a>
<a name="ln10121">    }</a>
<a name="ln10122">  } else if (ui_rgb_attached()) {</a>
<a name="ln10123">    modec = 'g';</a>
<a name="ln10124">  } else {</a>
<a name="ln10125">    modec = 'c';</a>
<a name="ln10126">  }</a>
<a name="ln10127"> </a>
<a name="ln10128"> </a>
<a name="ln10129">  const char *p = NULL;</a>
<a name="ln10130">  switch (TOLOWER_ASC(what[0])) {</a>
<a name="ln10131">    case 'b': {</a>
<a name="ln10132">      if (TOLOWER_ASC(what[1]) == 'g') {  // bg[#]</a>
<a name="ln10133">        p = highlight_color(id, what, modec);</a>
<a name="ln10134">      } else {  // bold</a>
<a name="ln10135">        p = highlight_has_attr(id, HL_BOLD, modec);</a>
<a name="ln10136">      }</a>
<a name="ln10137">      break;</a>
<a name="ln10138">    }</a>
<a name="ln10139">    case 'f': {  // fg[#] or font</a>
<a name="ln10140">      p = highlight_color(id, what, modec);</a>
<a name="ln10141">      break;</a>
<a name="ln10142">    }</a>
<a name="ln10143">    case 'i': {</a>
<a name="ln10144">      if (TOLOWER_ASC(what[1]) == 'n') {  // inverse</a>
<a name="ln10145">        p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10146">      } else {  // italic</a>
<a name="ln10147">        p = highlight_has_attr(id, HL_ITALIC, modec);</a>
<a name="ln10148">      }</a>
<a name="ln10149">      break;</a>
<a name="ln10150">    }</a>
<a name="ln10151">    case 'n': {  // name</a>
<a name="ln10152">      p = get_highlight_name_ext(NULL, id - 1, false);</a>
<a name="ln10153">      break;</a>
<a name="ln10154">    }</a>
<a name="ln10155">    case 'r': {  // reverse</a>
<a name="ln10156">      p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10157">      break;</a>
<a name="ln10158">    }</a>
<a name="ln10159">    case 's': {</a>
<a name="ln10160">      if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]</a>
<a name="ln10161">        p = highlight_color(id, what, modec);</a>
<a name="ln10162">      } else if (TOLOWER_ASC(what[1]) == 't'</a>
<a name="ln10163">                 &amp;&amp; TOLOWER_ASC(what[2]) == 'r') {  // strikethrough</a>
<a name="ln10164">        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);</a>
<a name="ln10165">      } else {  // standout</a>
<a name="ln10166">        p = highlight_has_attr(id, HL_STANDOUT, modec);</a>
<a name="ln10167">      }</a>
<a name="ln10168">      break;</a>
<a name="ln10169">    }</a>
<a name="ln10170">    case 'u': {</a>
<a name="ln10171">      if (STRLEN(what) &lt;= 5 || TOLOWER_ASC(what[5]) != 'c') {  // underline</a>
<a name="ln10172">        p = highlight_has_attr(id, HL_UNDERLINE, modec);</a>
<a name="ln10173">      } else {  // undercurl</a>
<a name="ln10174">        p = highlight_has_attr(id, HL_UNDERCURL, modec);</a>
<a name="ln10175">      }</a>
<a name="ln10176">      break;</a>
<a name="ln10177">    }</a>
<a name="ln10178">  }</a>
<a name="ln10179"> </a>
<a name="ln10180">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10181">  rettv-&gt;vval.v_string = (char_u *)(p == NULL ? p : xstrdup(p));</a>
<a name="ln10182">}</a>
<a name="ln10183"> </a>
<a name="ln10184">/*</a>
<a name="ln10185"> * &quot;synIDtrans(id)&quot; function</a>
<a name="ln10186"> */</a>
<a name="ln10187">static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10188">{</a>
<a name="ln10189">  int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln10190"> </a>
<a name="ln10191">  if (id &gt; 0) {</a>
<a name="ln10192">    id = syn_get_final_id(id);</a>
<a name="ln10193">  } else {</a>
<a name="ln10194">    id = 0;</a>
<a name="ln10195">  }</a>
<a name="ln10196"> </a>
<a name="ln10197">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10198">}</a>
<a name="ln10199"> </a>
<a name="ln10200">/*</a>
<a name="ln10201"> * &quot;synconcealed(lnum, col)&quot; function</a>
<a name="ln10202"> */</a>
<a name="ln10203">static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10204">{</a>
<a name="ln10205">  int syntax_flags = 0;</a>
<a name="ln10206">  int cchar;</a>
<a name="ln10207">  int matchid = 0;</a>
<a name="ln10208">  char_u str[NUMBUFLEN];</a>
<a name="ln10209"> </a>
<a name="ln10210">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10211"> </a>
<a name="ln10212">  // -1 on type error (both)</a>
<a name="ln10213">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10214">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10215"> </a>
<a name="ln10216">  memset(str, NUL, sizeof(str));</a>
<a name="ln10217"> </a>
<a name="ln10218">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; col &gt;= 0</a>
<a name="ln10219">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum)) &amp;&amp; curwin-&gt;w_p_cole &gt; 0) {</a>
<a name="ln10220">    (void)syn_get_id(curwin, lnum, col, false, NULL, false);</a>
<a name="ln10221">    syntax_flags = get_syntax_info(&amp;matchid);</a>
<a name="ln10222"> </a>
<a name="ln10223">    // get the conceal character</a>
<a name="ln10224">    if ((syntax_flags &amp; HL_CONCEAL) &amp;&amp; curwin-&gt;w_p_cole &lt; 3) {</a>
<a name="ln10225">      cchar = syn_get_sub_char();</a>
<a name="ln10226">      if (cchar == NUL &amp;&amp; curwin-&gt;w_p_cole == 1) {</a>
<a name="ln10227">        cchar = (curwin-&gt;w_p_lcs_chars.conceal == NUL)</a>
<a name="ln10228">          ? ' '</a>
<a name="ln10229">          : curwin-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln10230">      }</a>
<a name="ln10231">      if (cchar != NUL) {</a>
<a name="ln10232">        utf_char2bytes(cchar, str);</a>
<a name="ln10233">      }</a>
<a name="ln10234">    }</a>
<a name="ln10235">  }</a>
<a name="ln10236"> </a>
<a name="ln10237">  tv_list_alloc_ret(rettv, 3);</a>
<a name="ln10238">  tv_list_append_number(rettv-&gt;vval.v_list, (syntax_flags &amp; HL_CONCEAL) != 0);</a>
<a name="ln10239">  // -1 to auto-determine strlen</a>
<a name="ln10240">  tv_list_append_string(rettv-&gt;vval.v_list, (const char *)str, -1);</a>
<a name="ln10241">  tv_list_append_number(rettv-&gt;vval.v_list, matchid);</a>
<a name="ln10242">}</a>
<a name="ln10243"> </a>
<a name="ln10244">/*</a>
<a name="ln10245"> * &quot;synstack(lnum, col)&quot; function</a>
<a name="ln10246"> */</a>
<a name="ln10247">static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10248">{</a>
<a name="ln10249">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10250"> </a>
<a name="ln10251">  // -1 on type error (both)</a>
<a name="ln10252">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10253">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10254"> </a>
<a name="ln10255">  if (lnum &gt;= 1</a>
<a name="ln10256">      &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10257">      &amp;&amp; col &gt;= 0</a>
<a name="ln10258">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum))) {</a>
<a name="ln10259">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10260">    (void)syn_get_id(curwin, lnum, col, false, NULL, true);</a>
<a name="ln10261"> </a>
<a name="ln10262">    int id;</a>
<a name="ln10263">    int i = 0;</a>
<a name="ln10264">    while ((id = syn_get_stack_item(i++)) &gt;= 0) {</a>
<a name="ln10265">      tv_list_append_number(rettv-&gt;vval.v_list, id);</a>
<a name="ln10266">    }</a>
<a name="ln10267">  }</a>
<a name="ln10268">}</a>
<a name="ln10269"> </a>
<a name="ln10270">/// f_system - the VimL system() function</a>
<a name="ln10271">static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10272">{</a>
<a name="ln10273">  get_system_output_as_rettv(argvars, rettv, false);</a>
<a name="ln10274">}</a>
<a name="ln10275"> </a>
<a name="ln10276">static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10277">{</a>
<a name="ln10278">  get_system_output_as_rettv(argvars, rettv, true);</a>
<a name="ln10279">}</a>
<a name="ln10280"> </a>
<a name="ln10281"> </a>
<a name="ln10282">/*</a>
<a name="ln10283"> * &quot;tabpagebuflist()&quot; function</a>
<a name="ln10284"> */</a>
<a name="ln10285">static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10286">{</a>
<a name="ln10287">  win_T       *wp = NULL;</a>
<a name="ln10288"> </a>
<a name="ln10289">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln10290">    wp = firstwin;</a>
<a name="ln10291">  } else {</a>
<a name="ln10292">    tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10293">    if (tp != NULL) {</a>
<a name="ln10294">      wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10295">    }</a>
<a name="ln10296">  }</a>
<a name="ln10297">  if (wp != NULL) {</a>
<a name="ln10298">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10299">    while (wp != NULL) {</a>
<a name="ln10300">      tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln10301">      wp = wp-&gt;w_next;</a>
<a name="ln10302">    }</a>
<a name="ln10303">  }</a>
<a name="ln10304">}</a>
<a name="ln10305"> </a>
<a name="ln10306">/*</a>
<a name="ln10307"> * &quot;tabpagenr()&quot; function</a>
<a name="ln10308"> */</a>
<a name="ln10309">static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10310">{</a>
<a name="ln10311">  int nr = 1;</a>
<a name="ln10312"> </a>
<a name="ln10313">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10314">    const char *const arg = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10315">    nr = 0;</a>
<a name="ln10316">    if (arg != NULL) {</a>
<a name="ln10317">      if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10318">        nr = tabpage_index(NULL) - 1;</a>
<a name="ln10319">      } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10320">        nr = valid_tabpage(lastused_tabpage)</a>
<a name="ln10321">             ? tabpage_index(lastused_tabpage)</a>
<a name="ln10322">             : nr;</a>
<a name="ln10323">      } else {</a>
<a name="ln10324">        EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10325">      }</a>
<a name="ln10326">    }</a>
<a name="ln10327">  } else {</a>
<a name="ln10328">    nr = tabpage_index(curtab);</a>
<a name="ln10329">  }</a>
<a name="ln10330">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10331">}</a>
<a name="ln10332"> </a>
<a name="ln10333"> </a>
<a name="ln10334"> </a>
<a name="ln10335">/*</a>
<a name="ln10336"> * Common code for tabpagewinnr() and winnr().</a>
<a name="ln10337"> */</a>
<a name="ln10338">static int get_winnr(tabpage_T *tp, typval_T *argvar)</a>
<a name="ln10339">{</a>
<a name="ln10340">  win_T       *twin;</a>
<a name="ln10341">  int nr = 1;</a>
<a name="ln10342">  win_T       *wp;</a>
<a name="ln10343"> </a>
<a name="ln10344">  twin = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln10345">  if (argvar-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln10346">    bool invalid_arg = false;</a>
<a name="ln10347">    const char *const arg = tv_get_string_chk(argvar);</a>
<a name="ln10348">    if (arg == NULL) {</a>
<a name="ln10349">      nr = 0;  // Type error; errmsg already given.</a>
<a name="ln10350">    } else if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10351">      twin = (tp == curtab) ? lastwin : tp-&gt;tp_lastwin;</a>
<a name="ln10352">    } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10353">      twin = (tp == curtab) ? prevwin : tp-&gt;tp_prevwin;</a>
<a name="ln10354">      if (twin == NULL) {</a>
<a name="ln10355">        nr = 0;</a>
<a name="ln10356">      }</a>
<a name="ln10357">    } else {</a>
<a name="ln10358">      // Extract the window count (if specified). e.g. winnr('3j')</a>
<a name="ln10359">      char_u *endp;</a>
<a name="ln10360">      long count = strtol((char *)arg, (char **)&amp;endp, 10);</a>
<a name="ln10361">      if (count &lt;= 0) {</a>
<a name="ln10362">        // if count is not specified, default to 1</a>
<a name="ln10363">        count = 1;</a>
<a name="ln10364">      }</a>
<a name="ln10365">      if (endp != NULL &amp;&amp; *endp != '\0') {</a>
<a name="ln10366">        if (strequal((char *)endp, &quot;j&quot;)) {</a>
<a name="ln10367">          twin = win_vert_neighbor(tp, twin, false, count);</a>
<a name="ln10368">        } else if (strequal((char *)endp, &quot;k&quot;)) {</a>
<a name="ln10369">          twin = win_vert_neighbor(tp, twin, true, count);</a>
<a name="ln10370">        } else if (strequal((char *)endp, &quot;h&quot;)) {</a>
<a name="ln10371">          twin = win_horz_neighbor(tp, twin, true, count);</a>
<a name="ln10372">        } else if (strequal((char *)endp, &quot;l&quot;)) {</a>
<a name="ln10373">          twin = win_horz_neighbor(tp, twin, false, count);</a>
<a name="ln10374">        } else {</a>
<a name="ln10375">          invalid_arg = true;</a>
<a name="ln10376">        }</a>
<a name="ln10377">      } else {</a>
<a name="ln10378">        invalid_arg = true;</a>
<a name="ln10379">      }</a>
<a name="ln10380">    }</a>
<a name="ln10381"> </a>
<a name="ln10382">    if (invalid_arg) {</a>
<a name="ln10383">      EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10384">      nr = 0;</a>
<a name="ln10385">    }</a>
<a name="ln10386">  }</a>
<a name="ln10387"> </a>
<a name="ln10388">  if (nr &gt; 0)</a>
<a name="ln10389">    for (wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10390">         wp != twin; wp = wp-&gt;w_next) {</a>
<a name="ln10391">      if (wp == NULL) {</a>
<a name="ln10392">        // didn't find it in this tabpage</a>
<a name="ln10393">        nr = 0;</a>
<a name="ln10394">        break;</a>
<a name="ln10395">      }</a>
<a name="ln10396">      ++nr;</a>
<a name="ln10397">    }</a>
<a name="ln10398">  return nr;</a>
<a name="ln10399">}</a>
<a name="ln10400"> </a>
<a name="ln10401">/*</a>
<a name="ln10402"> * &quot;tabpagewinnr()&quot; function</a>
<a name="ln10403"> */</a>
<a name="ln10404">static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10405">{</a>
<a name="ln10406">  int nr = 1;</a>
<a name="ln10407">  tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10408">  if (tp == NULL) {</a>
<a name="ln10409">    nr = 0;</a>
<a name="ln10410">  } else {</a>
<a name="ln10411">    nr = get_winnr(tp, &amp;argvars[1]);</a>
<a name="ln10412">  }</a>
<a name="ln10413">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10414">}</a>
<a name="ln10415"> </a>
<a name="ln10416">/*</a>
<a name="ln10417"> * &quot;tagfiles()&quot; function</a>
<a name="ln10418"> */</a>
<a name="ln10419">static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10420">{</a>
<a name="ln10421">  char *fname;</a>
<a name="ln10422">  tagname_T tn;</a>
<a name="ln10423"> </a>
<a name="ln10424">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln10425">  fname = xmalloc(MAXPATHL);</a>
<a name="ln10426"> </a>
<a name="ln10427">  bool first = true;</a>
<a name="ln10428">  while (get_tagfname(&amp;tn, first, (char_u *)fname) == OK) {</a>
<a name="ln10429">    tv_list_append_string(rettv-&gt;vval.v_list, fname, -1);</a>
<a name="ln10430">    first = false;</a>
<a name="ln10431">  }</a>
<a name="ln10432"> </a>
<a name="ln10433">  tagname_free(&amp;tn);</a>
<a name="ln10434">  xfree(fname);</a>
<a name="ln10435">}</a>
<a name="ln10436"> </a>
<a name="ln10437">/*</a>
<a name="ln10438"> * &quot;taglist()&quot; function</a>
<a name="ln10439"> */</a>
<a name="ln10440">static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10441">{</a>
<a name="ln10442">  const char *const tag_pattern = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10443"> </a>
<a name="ln10444">  rettv-&gt;vval.v_number = false;</a>
<a name="ln10445">  if (*tag_pattern == NUL) {</a>
<a name="ln10446">    return;</a>
<a name="ln10447">  }</a>
<a name="ln10448"> </a>
<a name="ln10449">  const char *fname = NULL;</a>
<a name="ln10450">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10451">    fname = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10452">  }</a>
<a name="ln10453">  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),</a>
<a name="ln10454">                 (char_u *)tag_pattern, (char_u *)fname);</a>
<a name="ln10455">}</a>
<a name="ln10456"> </a>
<a name="ln10457">/*</a>
<a name="ln10458"> * &quot;tempname()&quot; function</a>
<a name="ln10459"> */</a>
<a name="ln10460">static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10461">{</a>
<a name="ln10462">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10463">  rettv-&gt;vval.v_string = vim_tempname();</a>
<a name="ln10464">}</a>
<a name="ln10465"> </a>
<a name="ln10466">// &quot;termopen(cmd[, cwd])&quot; function</a>
<a name="ln10467">static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10468">{</a>
<a name="ln10469">  if (check_restricted() || check_secure()) {</a>
<a name="ln10470">    return;</a>
<a name="ln10471">  }</a>
<a name="ln10472"> </a>
<a name="ln10473">  if (curbuf-&gt;b_changed) {</a>
<a name="ln10474">    EMSG(_(&quot;Can only call this function in an unmodified buffer&quot;));</a>
<a name="ln10475">    return;</a>
<a name="ln10476">  }</a>
<a name="ln10477"> </a>
<a name="ln10478">  const char *cmd;</a>
<a name="ln10479">  bool executable = true;</a>
<a name="ln10480">  char **argv = tv_to_argv(&amp;argvars[0], &amp;cmd, &amp;executable);</a>
<a name="ln10481">  if (!argv) {</a>
<a name="ln10482">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln10483">    return;  // Did error message in tv_to_argv.</a>
<a name="ln10484">  }</a>
<a name="ln10485"> </a>
<a name="ln10486">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10487">    // Wrong argument type</a>
<a name="ln10488">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln10489">    shell_free_argv(argv);</a>
<a name="ln10490">    return;</a>
<a name="ln10491">  }</a>
<a name="ln10492"> </a>
<a name="ln10493">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln10494">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln10495">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln10496">  dict_T *job_opts = NULL;</a>
<a name="ln10497">  const char *cwd = &quot;.&quot;;</a>
<a name="ln10498">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln10499">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln10500"> </a>
<a name="ln10501">    const char *const new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln10502">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln10503">      cwd = new_cwd;</a>
<a name="ln10504">      // The new cwd must be a directory.</a>
<a name="ln10505">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln10506">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln10507">        shell_free_argv(argv);</a>
<a name="ln10508">        return;</a>
<a name="ln10509">      }</a>
<a name="ln10510">    }</a>
<a name="ln10511"> </a>
<a name="ln10512">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln10513">      shell_free_argv(argv);</a>
<a name="ln10514">      return;</a>
<a name="ln10515">    }</a>
<a name="ln10516">  }</a>
<a name="ln10517"> </a>
<a name="ln10518">  uint16_t term_width = MAX(0, curwin-&gt;w_width_inner - win_col_off(curwin));</a>
<a name="ln10519">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,</a>
<a name="ln10520">                                    true, false, false, false, cwd,</a>
<a name="ln10521">                                    term_width, curwin-&gt;w_height_inner,</a>
<a name="ln10522">                                    xstrdup(&quot;xterm-256color&quot;), NULL,</a>
<a name="ln10523">                                    &amp;rettv-&gt;vval.v_number);</a>
<a name="ln10524">  if (rettv-&gt;vval.v_number &lt;= 0) {</a>
<a name="ln10525">    return;</a>
<a name="ln10526">  }</a>
<a name="ln10527"> </a>
<a name="ln10528">  int pid = chan-&gt;stream.pty.process.pid;</a>
<a name="ln10529"> </a>
<a name="ln10530">  // &quot;./…&quot; =&gt; &quot;/home/foo/…&quot;</a>
<a name="ln10531">  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), false);</a>
<a name="ln10532">  // &quot;/home/foo/…&quot; =&gt; &quot;~/…&quot;</a>
<a name="ln10533">  size_t len = home_replace(NULL, NameBuff, IObuff, sizeof(IObuff), true);</a>
<a name="ln10534">  // Trim slash.</a>
<a name="ln10535">  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {</a>
<a name="ln10536">    IObuff[len - 1] = '\0';</a>
<a name="ln10537">  }</a>
<a name="ln10538"> </a>
<a name="ln10539">  // Terminal URI: &quot;term://$CWD//$PID:$CMD&quot;</a>
<a name="ln10540">  snprintf((char *)NameBuff, sizeof(NameBuff), &quot;term://%s//%d:%s&quot;,</a>
<a name="ln10541">           (char *)IObuff, pid, cmd);</a>
<a name="ln10542">  // at this point the buffer has no terminal instance associated yet, so unset</a>
<a name="ln10543">  // the 'swapfile' option to ensure no swap file will be created</a>
<a name="ln10544">  curbuf-&gt;b_p_swf = false;</a>
<a name="ln10545">  (void)setfname(curbuf, NameBuff, NULL, true);</a>
<a name="ln10546">  // Save the job id and pid in b:terminal_job_{id,pid}</a>
<a name="ln10547">  Error err = ERROR_INIT;</a>
<a name="ln10548">  // deprecated: use 'channel' buffer option</a>
<a name="ln10549">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_id&quot;),</a>
<a name="ln10550">               INTEGER_OBJ(chan-&gt;id), false, false, &amp;err);</a>
<a name="ln10551">  api_clear_error(&amp;err);</a>
<a name="ln10552">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_pid&quot;),</a>
<a name="ln10553">               INTEGER_OBJ(pid), false, false, &amp;err);</a>
<a name="ln10554">  api_clear_error(&amp;err);</a>
<a name="ln10555"> </a>
<a name="ln10556">  channel_terminal_open(chan);</a>
<a name="ln10557">  channel_create_event(chan, NULL);</a>
<a name="ln10558">}</a>
<a name="ln10559"> </a>
<a name="ln10560">// &quot;test_garbagecollect_now()&quot; function</a>
<a name="ln10561">static void f_test_garbagecollect_now(typval_T *argvars,</a>
<a name="ln10562">                                      typval_T *rettv, FunPtr fptr)</a>
<a name="ln10563">{</a>
<a name="ln10564">  // This is dangerous, any Lists and Dicts used internally may be freed</a>
<a name="ln10565">  // while still in use.</a>
<a name="ln10566">  garbage_collect(true);</a>
<a name="ln10567">}</a>
<a name="ln10568"> </a>
<a name="ln10569">// &quot;test_write_list_log()&quot; function</a>
<a name="ln10570">static void f_test_write_list_log(typval_T *const argvars,</a>
<a name="ln10571">                                  typval_T *const rettv,</a>
<a name="ln10572">                                  FunPtr fptr)</a>
<a name="ln10573">{</a>
<a name="ln10574">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10575">  if (fname == NULL) {</a>
<a name="ln10576">    return;</a>
<a name="ln10577">  }</a>
<a name="ln10578">  list_write_log(fname);</a>
<a name="ln10579">}</a>
<a name="ln10580"> </a>
<a name="ln10581">/// &quot;timer_info([timer])&quot; function</a>
<a name="ln10582">static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10583">{</a>
<a name="ln10584">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10585">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10586">      EMSG(_(e_number_exp));</a>
<a name="ln10587">      return;</a>
<a name="ln10588">    }</a>
<a name="ln10589">    tv_list_alloc_ret(rettv, 1);</a>
<a name="ln10590">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10591">    if (timer != NULL &amp;&amp; !timer-&gt;stopped) {</a>
<a name="ln10592">      add_timer_info(rettv, timer);</a>
<a name="ln10593">    }</a>
<a name="ln10594">  } else {</a>
<a name="ln10595">    add_timer_info_all(rettv);</a>
<a name="ln10596">  }</a>
<a name="ln10597">}</a>
<a name="ln10598"> </a>
<a name="ln10599">/// &quot;timer_pause(timer, paused)&quot; function</a>
<a name="ln10600">static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10601">{</a>
<a name="ln10602">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10603">    EMSG(_(e_number_exp));</a>
<a name="ln10604">    return;</a>
<a name="ln10605">  }</a>
<a name="ln10606">  int paused = (bool)tv_get_number(&amp;argvars[1]);</a>
<a name="ln10607">  timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10608">  if (timer != NULL) {</a>
<a name="ln10609">    if (!timer-&gt;paused &amp;&amp; paused) {</a>
<a name="ln10610">      time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln10611">    } else if (timer-&gt;paused &amp;&amp; !paused) {</a>
<a name="ln10612">      time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timer-&gt;timeout,</a>
<a name="ln10613">                         timer-&gt;timeout);</a>
<a name="ln10614">    }</a>
<a name="ln10615">    timer-&gt;paused = paused;</a>
<a name="ln10616">  }</a>
<a name="ln10617">}</a>
<a name="ln10618"> </a>
<a name="ln10619">/// &quot;timer_start(timeout, callback, opts)&quot; function</a>
<a name="ln10620">static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10621">{</a>
<a name="ln10622">  int repeat = 1;</a>
<a name="ln10623">  dict_T *dict;</a>
<a name="ln10624"> </a>
<a name="ln10625">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10626"> </a>
<a name="ln10627">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10628">    if (argvars[2].v_type != VAR_DICT</a>
<a name="ln10629">        || (dict = argvars[2].vval.v_dict) == NULL) {</a>
<a name="ln10630">      EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10631">      return;</a>
<a name="ln10632">    }</a>
<a name="ln10633">    dictitem_T *const di = tv_dict_find(dict, S_LEN(&quot;repeat&quot;));</a>
<a name="ln10634">    if (di != NULL) {</a>
<a name="ln10635">      repeat = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln10636">      if (repeat == 0) {</a>
<a name="ln10637">        repeat = 1;</a>
<a name="ln10638">      }</a>
<a name="ln10639">    }</a>
<a name="ln10640">  }</a>
<a name="ln10641"> </a>
<a name="ln10642">  Callback callback;</a>
<a name="ln10643">  if (!callback_from_typval(&amp;callback, &amp;argvars[1])) {</a>
<a name="ln10644">    return;</a>
<a name="ln10645">  }</a>
<a name="ln10646">  rettv-&gt;vval.v_number =</a>
<a name="ln10647">      timer_start(tv_get_number(&amp;argvars[0]), repeat, &amp;callback);</a>
<a name="ln10648">}</a>
<a name="ln10649"> </a>
<a name="ln10650"> </a>
<a name="ln10651">// &quot;timer_stop(timerid)&quot; function</a>
<a name="ln10652">static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10653">{</a>
<a name="ln10654">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10655">        EMSG(_(e_number_exp));</a>
<a name="ln10656">        return;</a>
<a name="ln10657">    }</a>
<a name="ln10658"> </a>
<a name="ln10659">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10660">    if (timer == NULL) {</a>
<a name="ln10661">      return;</a>
<a name="ln10662">    }</a>
<a name="ln10663"> </a>
<a name="ln10664">    timer_stop(timer);</a>
<a name="ln10665">}</a>
<a name="ln10666"> </a>
<a name="ln10667">static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10668">{</a>
<a name="ln10669">  timer_stop_all();</a>
<a name="ln10670">}</a>
<a name="ln10671"> </a>
<a name="ln10672">/*</a>
<a name="ln10673"> * &quot;tolower(string)&quot; function</a>
<a name="ln10674"> */</a>
<a name="ln10675">static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10676">{</a>
<a name="ln10677">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10678">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10679">                                                false);</a>
<a name="ln10680">}</a>
<a name="ln10681"> </a>
<a name="ln10682">/*</a>
<a name="ln10683"> * &quot;toupper(string)&quot; function</a>
<a name="ln10684"> */</a>
<a name="ln10685">static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10686">{</a>
<a name="ln10687">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10688">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln10689">                                                true);</a>
<a name="ln10690">}</a>
<a name="ln10691"> </a>
<a name="ln10692">/*</a>
<a name="ln10693"> * &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln10694"> */</a>
<a name="ln10695">static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10696">{</a>
<a name="ln10697">  char buf[NUMBUFLEN];</a>
<a name="ln10698">  char buf2[NUMBUFLEN];</a>
<a name="ln10699"> </a>
<a name="ln10700">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10701">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln10702">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln10703"> </a>
<a name="ln10704">  // Default return value: empty string.</a>
<a name="ln10705">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10706">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10707">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln10708">    return;  // Type error; errmsg already given.</a>
<a name="ln10709">  }</a>
<a name="ln10710">  garray_T ga;</a>
<a name="ln10711">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln10712"> </a>
<a name="ln10713">  if (!has_mbyte) {</a>
<a name="ln10714">    // Not multi-byte: fromstr and tostr must be the same length.</a>
<a name="ln10715">    if (strlen(fromstr) != strlen(tostr)) {</a>
<a name="ln10716">      goto error;</a>
<a name="ln10717">    }</a>
<a name="ln10718">  }</a>
<a name="ln10719"> </a>
<a name="ln10720">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln10721">  bool first = true;</a>
<a name="ln10722">  while (*in_str != NUL) {</a>
<a name="ln10723">    if (has_mbyte) {</a>
<a name="ln10724">      const char *cpstr = in_str;</a>
<a name="ln10725">      const int inlen = (*mb_ptr2len)((const char_u *)in_str);</a>
<a name="ln10726">      int cplen = inlen;</a>
<a name="ln10727">      int idx = 0;</a>
<a name="ln10728">      int fromlen;</a>
<a name="ln10729">      for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln10730">        fromlen = (*mb_ptr2len)((const char_u *)p);</a>
<a name="ln10731">        if (fromlen == inlen &amp;&amp; STRNCMP(in_str, p, inlen) == 0) {</a>
<a name="ln10732">          int tolen;</a>
<a name="ln10733">          for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10734">            tolen = (*mb_ptr2len)((const char_u *)p);</a>
<a name="ln10735">            if (idx-- == 0) {</a>
<a name="ln10736">              cplen = tolen;</a>
<a name="ln10737">              cpstr = (char *)p;</a>
<a name="ln10738">              break;</a>
<a name="ln10739">            }</a>
<a name="ln10740">          }</a>
<a name="ln10741">          if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln10742">            goto error;</a>
<a name="ln10743">          }</a>
<a name="ln10744">          break;</a>
<a name="ln10745">        }</a>
<a name="ln10746">        idx++;</a>
<a name="ln10747">      }</a>
<a name="ln10748"> </a>
<a name="ln10749">      if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln10750">        // Check that fromstr and tostr have the same number of</a>
<a name="ln10751">        // (multi-byte) characters.  Done only once when a character</a>
<a name="ln10752">        // of in_str doesn't appear in fromstr.</a>
<a name="ln10753">        first = false;</a>
<a name="ln10754">        int tolen;</a>
<a name="ln10755">        for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln10756">          tolen = (*mb_ptr2len)((const char_u *)p);</a>
<a name="ln10757">          idx--;</a>
<a name="ln10758">        }</a>
<a name="ln10759">        if (idx != 0) {</a>
<a name="ln10760">          goto error;</a>
<a name="ln10761">        }</a>
<a name="ln10762">      }</a>
<a name="ln10763"> </a>
<a name="ln10764">      ga_grow(&amp;ga, cplen);</a>
<a name="ln10765">      memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln10766">      ga.ga_len += cplen;</a>
<a name="ln10767"> </a>
<a name="ln10768">      in_str += inlen;</a>
<a name="ln10769">    } else {</a>
<a name="ln10770">      // When not using multi-byte chars we can do it faster.</a>
<a name="ln10771">      const char *const p = strchr(fromstr, *in_str);</a>
<a name="ln10772">      if (p != NULL) {</a>
<a name="ln10773">        ga_append(&amp;ga, tostr[p - fromstr]);</a>
<a name="ln10774">      } else {</a>
<a name="ln10775">        ga_append(&amp;ga, *in_str);</a>
<a name="ln10776">      }</a>
<a name="ln10777">      in_str++;</a>
<a name="ln10778">    }</a>
<a name="ln10779">  }</a>
<a name="ln10780"> </a>
<a name="ln10781">  // add a terminating NUL</a>
<a name="ln10782">  ga_append(&amp;ga, NUL);</a>
<a name="ln10783"> </a>
<a name="ln10784">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln10785">  return;</a>
<a name="ln10786">error:</a>
<a name="ln10787">  EMSG2(_(e_invarg2), fromstr);</a>
<a name="ln10788">  ga_clear(&amp;ga);</a>
<a name="ln10789">  return;</a>
<a name="ln10790">}</a>
<a name="ln10791"> </a>
<a name="ln10792">// &quot;trim({expr})&quot; function</a>
<a name="ln10793">static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10794">{</a>
<a name="ln10795">  char buf1[NUMBUFLEN];</a>
<a name="ln10796">  char buf2[NUMBUFLEN];</a>
<a name="ln10797">  const char_u *head = (const char_u *)tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln10798">  const char_u *mask = NULL;</a>
<a name="ln10799">  const char_u *tail;</a>
<a name="ln10800">  const char_u *prev;</a>
<a name="ln10801">  const char_u *p;</a>
<a name="ln10802">  int c1;</a>
<a name="ln10803">  int dir = 0;</a>
<a name="ln10804"> </a>
<a name="ln10805">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10806">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10807">  if (head == NULL) {</a>
<a name="ln10808">    return;</a>
<a name="ln10809">  }</a>
<a name="ln10810"> </a>
<a name="ln10811">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln10812">    mask = (const char_u *)tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln10813">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10814">      bool error = false;</a>
<a name="ln10815">      // leading or trailing characters to trim</a>
<a name="ln10816">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln10817">      if (error) {</a>
<a name="ln10818">        return;</a>
<a name="ln10819">      }</a>
<a name="ln10820">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln10821">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10822">        return;</a>
<a name="ln10823">      }</a>
<a name="ln10824">    }</a>
<a name="ln10825">  }</a>
<a name="ln10826"> </a>
<a name="ln10827">  if (dir == 0 || dir == 1) {</a>
<a name="ln10828">    // Trim leading characters</a>
<a name="ln10829">    while (*head != NUL) {</a>
<a name="ln10830">      c1 = PTR2CHAR(head);</a>
<a name="ln10831">      if (mask == NULL) {</a>
<a name="ln10832">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln10833">          break;</a>
<a name="ln10834">        }</a>
<a name="ln10835">      } else {</a>
<a name="ln10836">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln10837">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln10838">            break;</a>
<a name="ln10839">          }</a>
<a name="ln10840">        }</a>
<a name="ln10841">        if (*p == NUL) {</a>
<a name="ln10842">          break;</a>
<a name="ln10843">        }</a>
<a name="ln10844">      }</a>
<a name="ln10845">      MB_PTR_ADV(head);</a>
<a name="ln10846">    }</a>
<a name="ln10847">  }</a>
<a name="ln10848"> </a>
<a name="ln10849">  tail = head + STRLEN(head);</a>
<a name="ln10850">  if (dir == 0 || dir == 2) {</a>
<a name="ln10851">    // Trim trailing characters</a>
<a name="ln10852">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln10853">      prev = tail;</a>
<a name="ln10854">      MB_PTR_BACK(head, prev);</a>
<a name="ln10855">      c1 = PTR2CHAR(prev);</a>
<a name="ln10856">      if (mask == NULL) {</a>
<a name="ln10857">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln10858">          break;</a>
<a name="ln10859">        }</a>
<a name="ln10860">      } else {</a>
<a name="ln10861">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln10862">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln10863">            break;</a>
<a name="ln10864">          }</a>
<a name="ln10865">        }</a>
<a name="ln10866">        if (*p == NUL) {</a>
<a name="ln10867">          break;</a>
<a name="ln10868">        }</a>
<a name="ln10869">      }</a>
<a name="ln10870">    }</a>
<a name="ln10871">  }</a>
<a name="ln10872">  rettv-&gt;vval.v_string = vim_strnsave(head, (int)(tail - head));</a>
<a name="ln10873">}</a>
<a name="ln10874"> </a>
<a name="ln10875">/*</a>
<a name="ln10876"> * &quot;type(expr)&quot; function</a>
<a name="ln10877"> */</a>
<a name="ln10878">static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10879">{</a>
<a name="ln10880">  int n = -1;</a>
<a name="ln10881"> </a>
<a name="ln10882">  switch (argvars[0].v_type) {</a>
<a name="ln10883">    case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;</a>
<a name="ln10884">    case VAR_STRING: n = VAR_TYPE_STRING; break;</a>
<a name="ln10885">    case VAR_PARTIAL:</a>
<a name="ln10886">    case VAR_FUNC:   n = VAR_TYPE_FUNC; break;</a>
<a name="ln10887">    case VAR_LIST:   n = VAR_TYPE_LIST; break;</a>
<a name="ln10888">    case VAR_DICT:   n = VAR_TYPE_DICT; break;</a>
<a name="ln10889">    case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;</a>
<a name="ln10890">    case VAR_BOOL:   n = VAR_TYPE_BOOL; break;</a>
<a name="ln10891">    case VAR_SPECIAL:n = VAR_TYPE_SPECIAL; break;</a>
<a name="ln10892">    case VAR_UNKNOWN: {</a>
<a name="ln10893">      internal_error(&quot;f_type(UNKNOWN)&quot;);</a>
<a name="ln10894">      break;</a>
<a name="ln10895">    }</a>
<a name="ln10896">  }</a>
<a name="ln10897">  rettv-&gt;vval.v_number = n;</a>
<a name="ln10898">}</a>
<a name="ln10899"> </a>
<a name="ln10900">/*</a>
<a name="ln10901"> * &quot;undofile(name)&quot; function</a>
<a name="ln10902"> */</a>
<a name="ln10903">static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10904">{</a>
<a name="ln10905">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10906">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10907"> </a>
<a name="ln10908">  if (*fname == NUL) {</a>
<a name="ln10909">    // If there is no file name there will be no undo file.</a>
<a name="ln10910">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10911">  } else {</a>
<a name="ln10912">    char *ffname = FullName_save(fname, true);</a>
<a name="ln10913"> </a>
<a name="ln10914">    if (ffname != NULL) {</a>
<a name="ln10915">      rettv-&gt;vval.v_string = (char_u *)u_get_undo_file_name(ffname, false);</a>
<a name="ln10916">    }</a>
<a name="ln10917">    xfree(ffname);</a>
<a name="ln10918">  }</a>
<a name="ln10919">}</a>
<a name="ln10920"> </a>
<a name="ln10921">/*</a>
<a name="ln10922"> * &quot;undotree()&quot; function</a>
<a name="ln10923"> */</a>
<a name="ln10924">static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10925">{</a>
<a name="ln10926">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10927"> </a>
<a name="ln10928">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln10929"> </a>
<a name="ln10930">  tv_dict_add_nr(dict, S_LEN(&quot;synced&quot;), (varnumber_T)curbuf-&gt;b_u_synced);</a>
<a name="ln10931">  tv_dict_add_nr(dict, S_LEN(&quot;seq_last&quot;), (varnumber_T)curbuf-&gt;b_u_seq_last);</a>
<a name="ln10932">  tv_dict_add_nr(dict, S_LEN(&quot;save_last&quot;),</a>
<a name="ln10933">                 (varnumber_T)curbuf-&gt;b_u_save_nr_last);</a>
<a name="ln10934">  tv_dict_add_nr(dict, S_LEN(&quot;seq_cur&quot;), (varnumber_T)curbuf-&gt;b_u_seq_cur);</a>
<a name="ln10935">  tv_dict_add_nr(dict, S_LEN(&quot;time_cur&quot;), (varnumber_T)curbuf-&gt;b_u_time_cur);</a>
<a name="ln10936">  tv_dict_add_nr(dict, S_LEN(&quot;save_cur&quot;), (varnumber_T)curbuf-&gt;b_u_save_nr_cur);</a>
<a name="ln10937"> </a>
<a name="ln10938">  tv_dict_add_list(dict, S_LEN(&quot;entries&quot;), u_eval_tree(curbuf-&gt;b_u_oldhead));</a>
<a name="ln10939">}</a>
<a name="ln10940"> </a>
<a name="ln10941">/*</a>
<a name="ln10942"> * &quot;values(dict)&quot; function</a>
<a name="ln10943"> */</a>
<a name="ln10944">static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10945">{</a>
<a name="ln10946">  dict_list(argvars, rettv, 1);</a>
<a name="ln10947">}</a>
<a name="ln10948"> </a>
<a name="ln10949">/*</a>
<a name="ln10950"> * &quot;virtcol(string)&quot; function</a>
<a name="ln10951"> */</a>
<a name="ln10952">static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10953">{</a>
<a name="ln10954">  colnr_T vcol = 0;</a>
<a name="ln10955">  pos_T       *fp;</a>
<a name="ln10956">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln10957"> </a>
<a name="ln10958">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln10959">  if (fp != NULL &amp;&amp; fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10960">      &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln10961">    // Limit the column to a valid value, getvvcol() doesn't check.</a>
<a name="ln10962">    if (fp-&gt;col &lt; 0) {</a>
<a name="ln10963">      fp-&gt;col = 0;</a>
<a name="ln10964">    } else {</a>
<a name="ln10965">      const size_t len = STRLEN(ml_get(fp-&gt;lnum));</a>
<a name="ln10966">      if (fp-&gt;col &gt; (colnr_T)len) {</a>
<a name="ln10967">        fp-&gt;col = (colnr_T)len;</a>
<a name="ln10968">      }</a>
<a name="ln10969">    }</a>
<a name="ln10970">    getvvcol(curwin, fp, NULL, NULL, &amp;vcol);</a>
<a name="ln10971">    ++vcol;</a>
<a name="ln10972">  }</a>
<a name="ln10973"> </a>
<a name="ln10974">  rettv-&gt;vval.v_number = vcol;</a>
<a name="ln10975">}</a>
<a name="ln10976"> </a>
<a name="ln10977">/*</a>
<a name="ln10978"> * &quot;visualmode()&quot; function</a>
<a name="ln10979"> */</a>
<a name="ln10980">static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10981">{</a>
<a name="ln10982">  char_u str[2];</a>
<a name="ln10983"> </a>
<a name="ln10984">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10985">  str[0] = curbuf-&gt;b_visual_mode_eval;</a>
<a name="ln10986">  str[1] = NUL;</a>
<a name="ln10987">  rettv-&gt;vval.v_string = vim_strsave(str);</a>
<a name="ln10988"> </a>
<a name="ln10989">  // A non-zero number or non-empty string argument: reset mode.</a>
<a name="ln10990">  if (non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln10991">    curbuf-&gt;b_visual_mode_eval = NUL;</a>
<a name="ln10992">  }</a>
<a name="ln10993">}</a>
<a name="ln10994"> </a>
<a name="ln10995">/*</a>
<a name="ln10996"> * &quot;wildmenumode()&quot; function</a>
<a name="ln10997"> */</a>
<a name="ln10998">static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10999">{</a>
<a name="ln11000">  if (wild_menu_showing || ((State &amp; CMDLINE) &amp;&amp; pum_visible())) {</a>
<a name="ln11001">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln11002">  }</a>
<a name="ln11003">}</a>
<a name="ln11004"> </a>
<a name="ln11005">/// &quot;win_findbuf()&quot; function</a>
<a name="ln11006">static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11007">{</a>
<a name="ln11008">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln11009">  win_findbuf(argvars, rettv-&gt;vval.v_list);</a>
<a name="ln11010">}</a>
<a name="ln11011"> </a>
<a name="ln11012">/// &quot;win_getid()&quot; function</a>
<a name="ln11013">static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11014">{</a>
<a name="ln11015">  rettv-&gt;vval.v_number = win_getid(argvars);</a>
<a name="ln11016">}</a>
<a name="ln11017"> </a>
<a name="ln11018">/// &quot;win_gotoid()&quot; function</a>
<a name="ln11019">static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11020">{</a>
<a name="ln11021">  rettv-&gt;vval.v_number = win_gotoid(argvars);</a>
<a name="ln11022">}</a>
<a name="ln11023"> </a>
<a name="ln11024">/// &quot;win_id2tabwin()&quot; function</a>
<a name="ln11025">static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11026">{</a>
<a name="ln11027">  win_id2tabwin(argvars, rettv);</a>
<a name="ln11028">}</a>
<a name="ln11029"> </a>
<a name="ln11030">/// &quot;win_id2win()&quot; function</a>
<a name="ln11031">static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11032">{</a>
<a name="ln11033">  rettv-&gt;vval.v_number = win_id2win(argvars);</a>
<a name="ln11034">}</a>
<a name="ln11035"> </a>
<a name="ln11036">/// &quot;winbufnr(nr)&quot; function</a>
<a name="ln11037">static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11038">{</a>
<a name="ln11039">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11040">  if (wp == NULL) {</a>
<a name="ln11041">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11042">  } else {</a>
<a name="ln11043">    rettv-&gt;vval.v_number = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln11044">  }</a>
<a name="ln11045">}</a>
<a name="ln11046"> </a>
<a name="ln11047">/*</a>
<a name="ln11048"> * &quot;wincol()&quot; function</a>
<a name="ln11049"> */</a>
<a name="ln11050">static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11051">{</a>
<a name="ln11052">  validate_cursor();</a>
<a name="ln11053">  rettv-&gt;vval.v_number = curwin-&gt;w_wcol + 1;</a>
<a name="ln11054">}</a>
<a name="ln11055"> </a>
<a name="ln11056">/// &quot;winheight(nr)&quot; function</a>
<a name="ln11057">static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11058">{</a>
<a name="ln11059">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11060">  if (wp == NULL) {</a>
<a name="ln11061">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11062">  } else {</a>
<a name="ln11063">    rettv-&gt;vval.v_number = wp-&gt;w_height;</a>
<a name="ln11064">  }</a>
<a name="ln11065">}</a>
<a name="ln11066"> </a>
<a name="ln11067">// &quot;winlayout()&quot; function</a>
<a name="ln11068">static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11069">{</a>
<a name="ln11070">  tabpage_T *tp;</a>
<a name="ln11071"> </a>
<a name="ln11072">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln11073"> </a>
<a name="ln11074">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln11075">    tp = curtab;</a>
<a name="ln11076">  } else {</a>
<a name="ln11077">    tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln11078">    if (tp == NULL) {</a>
<a name="ln11079">      return;</a>
<a name="ln11080">    }</a>
<a name="ln11081">  }</a>
<a name="ln11082"> </a>
<a name="ln11083">  get_framelayout(tp-&gt;tp_topframe, rettv-&gt;vval.v_list, true);</a>
<a name="ln11084">}</a>
<a name="ln11085"> </a>
<a name="ln11086">/*</a>
<a name="ln11087"> * &quot;winline()&quot; function</a>
<a name="ln11088"> */</a>
<a name="ln11089">static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11090">{</a>
<a name="ln11091">  validate_cursor();</a>
<a name="ln11092">  rettv-&gt;vval.v_number = curwin-&gt;w_wrow + 1;</a>
<a name="ln11093">}</a>
<a name="ln11094"> </a>
<a name="ln11095">/*</a>
<a name="ln11096"> * &quot;winnr()&quot; function</a>
<a name="ln11097"> */</a>
<a name="ln11098">static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11099">{</a>
<a name="ln11100">  int nr = 1;</a>
<a name="ln11101"> </a>
<a name="ln11102">  nr = get_winnr(curtab, &amp;argvars[0]);</a>
<a name="ln11103">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln11104">}</a>
<a name="ln11105"> </a>
<a name="ln11106">/*</a>
<a name="ln11107"> * &quot;winrestcmd()&quot; function</a>
<a name="ln11108"> */</a>
<a name="ln11109">static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11110">{</a>
<a name="ln11111">  int winnr = 1;</a>
<a name="ln11112">  garray_T ga;</a>
<a name="ln11113">  char_u buf[50];</a>
<a name="ln11114"> </a>
<a name="ln11115">  ga_init(&amp;ga, (int)sizeof(char), 70);</a>
<a name="ln11116">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln11117">    sprintf((char *)buf, &quot;%dresize %d|&quot;, winnr, wp-&gt;w_height);</a>
<a name="ln11118">    ga_concat(&amp;ga, buf);</a>
<a name="ln11119">    sprintf((char *)buf, &quot;vert %dresize %d|&quot;, winnr, wp-&gt;w_width);</a>
<a name="ln11120">    ga_concat(&amp;ga, buf);</a>
<a name="ln11121">    ++winnr;</a>
<a name="ln11122">  }</a>
<a name="ln11123">  ga_append(&amp;ga, NUL);</a>
<a name="ln11124"> </a>
<a name="ln11125">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11126">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11127">}</a>
<a name="ln11128"> </a>
<a name="ln11129">/*</a>
<a name="ln11130"> * &quot;winrestview()&quot; function</a>
<a name="ln11131"> */</a>
<a name="ln11132">static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11133">{</a>
<a name="ln11134">  dict_T *dict;</a>
<a name="ln11135"> </a>
<a name="ln11136">  if (argvars[0].v_type != VAR_DICT</a>
<a name="ln11137">      || (dict = argvars[0].vval.v_dict) == NULL) {</a>
<a name="ln11138">    EMSG(_(e_invarg));</a>
<a name="ln11139">  } else {</a>
<a name="ln11140">    dictitem_T *di;</a>
<a name="ln11141">    if ((di = tv_dict_find(dict, S_LEN(&quot;lnum&quot;))) != NULL) {</a>
<a name="ln11142">      curwin-&gt;w_cursor.lnum = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11143">    }</a>
<a name="ln11144">    if ((di = tv_dict_find(dict, S_LEN(&quot;col&quot;))) != NULL) {</a>
<a name="ln11145">      curwin-&gt;w_cursor.col = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11146">    }</a>
<a name="ln11147">    if ((di = tv_dict_find(dict, S_LEN(&quot;coladd&quot;))) != NULL) {</a>
<a name="ln11148">      curwin-&gt;w_cursor.coladd = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11149">    }</a>
<a name="ln11150">    if ((di = tv_dict_find(dict, S_LEN(&quot;curswant&quot;))) != NULL) {</a>
<a name="ln11151">      curwin-&gt;w_curswant = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11152">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln11153">    }</a>
<a name="ln11154">    if ((di = tv_dict_find(dict, S_LEN(&quot;topline&quot;))) != NULL) {</a>
<a name="ln11155">      set_topline(curwin, tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln11156">    }</a>
<a name="ln11157">    if ((di = tv_dict_find(dict, S_LEN(&quot;topfill&quot;))) != NULL) {</a>
<a name="ln11158">      curwin-&gt;w_topfill = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11159">    }</a>
<a name="ln11160">    if ((di = tv_dict_find(dict, S_LEN(&quot;leftcol&quot;))) != NULL) {</a>
<a name="ln11161">      curwin-&gt;w_leftcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11162">    }</a>
<a name="ln11163">    if ((di = tv_dict_find(dict, S_LEN(&quot;skipcol&quot;))) != NULL) {</a>
<a name="ln11164">      curwin-&gt;w_skipcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11165">    }</a>
<a name="ln11166"> </a>
<a name="ln11167">    check_cursor();</a>
<a name="ln11168">    win_new_height(curwin, curwin-&gt;w_height);</a>
<a name="ln11169">    win_new_width(curwin, curwin-&gt;w_width);</a>
<a name="ln11170">    changed_window_setting();</a>
<a name="ln11171"> </a>
<a name="ln11172">    if (curwin-&gt;w_topline &lt;= 0)</a>
<a name="ln11173">      curwin-&gt;w_topline = 1;</a>
<a name="ln11174">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln11175">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln11176">    check_topfill(curwin, true);</a>
<a name="ln11177">  }</a>
<a name="ln11178">}</a>
<a name="ln11179"> </a>
<a name="ln11180">/*</a>
<a name="ln11181"> * &quot;winsaveview()&quot; function</a>
<a name="ln11182"> */</a>
<a name="ln11183">static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11184">{</a>
<a name="ln11185">  dict_T      *dict;</a>
<a name="ln11186"> </a>
<a name="ln11187">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11188">  dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11189"> </a>
<a name="ln11190">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)curwin-&gt;w_cursor.lnum);</a>
<a name="ln11191">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)curwin-&gt;w_cursor.col);</a>
<a name="ln11192">  tv_dict_add_nr(dict, S_LEN(&quot;coladd&quot;), (varnumber_T)curwin-&gt;w_cursor.coladd);</a>
<a name="ln11193">  update_curswant();</a>
<a name="ln11194">  tv_dict_add_nr(dict, S_LEN(&quot;curswant&quot;), (varnumber_T)curwin-&gt;w_curswant);</a>
<a name="ln11195"> </a>
<a name="ln11196">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), (varnumber_T)curwin-&gt;w_topline);</a>
<a name="ln11197">  tv_dict_add_nr(dict, S_LEN(&quot;topfill&quot;), (varnumber_T)curwin-&gt;w_topfill);</a>
<a name="ln11198">  tv_dict_add_nr(dict, S_LEN(&quot;leftcol&quot;), (varnumber_T)curwin-&gt;w_leftcol);</a>
<a name="ln11199">  tv_dict_add_nr(dict, S_LEN(&quot;skipcol&quot;), (varnumber_T)curwin-&gt;w_skipcol);</a>
<a name="ln11200">}</a>
<a name="ln11201"> </a>
<a name="ln11202">/// &quot;winwidth(nr)&quot; function</a>
<a name="ln11203">static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11204">{</a>
<a name="ln11205">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11206">  if (wp == NULL) {</a>
<a name="ln11207">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11208">  } else {</a>
<a name="ln11209">    rettv-&gt;vval.v_number = wp-&gt;w_width;</a>
<a name="ln11210">  }</a>
<a name="ln11211">}</a>
<a name="ln11212"> </a>
<a name="ln11213">/// &quot;wordcount()&quot; function</a>
<a name="ln11214">static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11215">{</a>
<a name="ln11216">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11217">  cursor_pos_info(rettv-&gt;vval.v_dict);</a>
<a name="ln11218">}</a>
<a name="ln11219"> </a>
<a name="ln11220">/// &quot;writefile()&quot; function</a>
<a name="ln11221">static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11222">{</a>
<a name="ln11223">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln11224"> </a>
<a name="ln11225">  if (check_secure()) {</a>
<a name="ln11226">    return;</a>
<a name="ln11227">  }</a>
<a name="ln11228"> </a>
<a name="ln11229">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln11230">    EMSG2(_(e_listarg), &quot;writefile()&quot;);</a>
<a name="ln11231">    return;</a>
<a name="ln11232">  }</a>
<a name="ln11233">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln11234">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln11235">    if (!tv_check_str_or_nr(TV_LIST_ITEM_TV(li))) {</a>
<a name="ln11236">      return;</a>
<a name="ln11237">    }</a>
<a name="ln11238">  });</a>
<a name="ln11239"> </a>
<a name="ln11240">  bool binary = false;</a>
<a name="ln11241">  bool append = false;</a>
<a name="ln11242">  bool do_fsync = !!p_fs;</a>
<a name="ln11243">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11244">    const char *const flags = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln11245">    if (flags == NULL) {</a>
<a name="ln11246">      return;</a>
<a name="ln11247">    }</a>
<a name="ln11248">    for (const char *p = flags; *p; p++) {</a>
<a name="ln11249">      switch (*p) {</a>
<a name="ln11250">        case 'b': { binary = true; break; }</a>
<a name="ln11251">        case 'a': { append = true; break; }</a>
<a name="ln11252">        case 's': { do_fsync = true; break; }</a>
<a name="ln11253">        case 'S': { do_fsync = false; break; }</a>
<a name="ln11254">        default: {</a>
<a name="ln11255">          // Using %s, p and not %c, *p to preserve multibyte characters</a>
<a name="ln11256">          emsgf(_(&quot;E5060: Unknown flag: %s&quot;), p);</a>
<a name="ln11257">          return;</a>
<a name="ln11258">        }</a>
<a name="ln11259">      }</a>
<a name="ln11260">    }</a>
<a name="ln11261">  }</a>
<a name="ln11262"> </a>
<a name="ln11263">  char buf[NUMBUFLEN];</a>
<a name="ln11264">  const char *const fname = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11265">  if (fname == NULL) {</a>
<a name="ln11266">    return;</a>
<a name="ln11267">  }</a>
<a name="ln11268">  FileDescriptor fp;</a>
<a name="ln11269">  int error;</a>
<a name="ln11270">  if (*fname == NUL) {</a>
<a name="ln11271">    EMSG(_(&quot;E482: Can't open file with an empty name&quot;));</a>
<a name="ln11272">  } else if ((error = file_open(&amp;fp, fname,</a>
<a name="ln11273">                                ((append ? kFileAppend : kFileTruncate)</a>
<a name="ln11274">                                 | kFileCreate), 0666)) != 0) {</a>
<a name="ln11275">    emsgf(_(&quot;E482: Can't open file %s for writing: %s&quot;),</a>
<a name="ln11276">          fname, os_strerror(error));</a>
<a name="ln11277">  } else {</a>
<a name="ln11278">    if (write_list(&amp;fp, list, binary)) {</a>
<a name="ln11279">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln11280">    }</a>
<a name="ln11281">    if ((error = file_close(&amp;fp, do_fsync)) != 0) {</a>
<a name="ln11282">      emsgf(_(&quot;E80: Error when closing file %s: %s&quot;),</a>
<a name="ln11283">            fname, os_strerror(error));</a>
<a name="ln11284">    }</a>
<a name="ln11285">  }</a>
<a name="ln11286">}</a>
<a name="ln11287">/*</a>
<a name="ln11288"> * &quot;xor(expr, expr)&quot; function</a>
<a name="ln11289"> */</a>
<a name="ln11290">static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11291">{</a>
<a name="ln11292">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln11293">                         ^ tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln11294">}</a>

</code></pre>
<div class="balloon" rel="1781"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="3682"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="8069"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>highlight.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// highlight.c: low level code for UI and syntax highlighting</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;nvim/vim.h&quot;</a>
<a name="ln7">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln8">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln9">#include &quot;nvim/map.h&quot;</a>
<a name="ln10">#include &quot;nvim/message.h&quot;</a>
<a name="ln11">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln12">#include &quot;nvim/screen.h&quot;</a>
<a name="ln13">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln14">#include &quot;nvim/ui.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln17">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln20"># include &quot;highlight.c.generated.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22"> </a>
<a name="ln23">static bool hlstate_active = false;</a>
<a name="ln24"> </a>
<a name="ln25">static kvec_t(HlEntry) attr_entries = KV_INITIAL_VALUE;</a>
<a name="ln26"> </a>
<a name="ln27">static Map(HlEntry, int) *attr_entry_ids;</a>
<a name="ln28">static Map(int, int) *combine_attr_entries;</a>
<a name="ln29">static Map(int, int) *blend_attr_entries;</a>
<a name="ln30">static Map(int, int) *blendthrough_attr_entries;</a>
<a name="ln31"> </a>
<a name="ln32">/// highlight entries private to a namespace</a>
<a name="ln33">static Map(ColorKey, ColorItem) *ns_hl;</a>
<a name="ln34"> </a>
<a name="ln35">void highlight_init(void)</a>
<a name="ln36">{</a>
<a name="ln37">  attr_entry_ids = map_new(HlEntry, int)();</a>
<a name="ln38">  combine_attr_entries = map_new(int, int)();</a>
<a name="ln39">  blend_attr_entries = map_new(int, int)();</a>
<a name="ln40">  blendthrough_attr_entries = map_new(int, int)();</a>
<a name="ln41">  ns_hl = map_new(ColorKey, ColorItem)();</a>
<a name="ln42"> </a>
<a name="ln43">  // index 0 is no attribute, add dummy entry:</a>
<a name="ln44">  kv_push(attr_entries, ((HlEntry){ .attr = HLATTRS_INIT, .kind = kHlUnknown,</a>
<a name="ln45">                                    .id1 = 0, .id2 = 0 }));</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">/// @return TRUE if hl table was reset</a>
<a name="ln49">bool highlight_use_hlstate(void)</a>
<a name="ln50">{</a>
<a name="ln51">  if (hlstate_active) {</a>
<a name="ln52">    return false;</a>
<a name="ln53">  }</a>
<a name="ln54">  hlstate_active = true;</a>
<a name="ln55">  // hl tables must now be rebuilt.</a>
<a name="ln56">  clear_hl_tables(true);</a>
<a name="ln57">  return true;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">/// Return the attr number for a set of colors and font, and optionally</a>
<a name="ln61">/// a semantic description (see ext_hlstate documentation).</a>
<a name="ln62">/// Add a new entry to the attr_entries array if the combination is new.</a>
<a name="ln63">/// @return 0 for error.</a>
<a name="ln64">static int get_attr_entry(HlEntry entry)</a>
<a name="ln65">{</a>
<a name="ln66">  if (!hlstate_active) {</a>
<a name="ln67">    // This information will not be used, erase it and reduce the table size.</a>
<a name="ln68">    entry.kind = kHlUnknown;</a>
<a name="ln69">    entry.id1 = 0;</a>
<a name="ln70">    entry.id2 = 0;</a>
<a name="ln71">  }</a>
<a name="ln72"> </a>
<a name="ln73">  int id = map_get(HlEntry, int)(attr_entry_ids, entry);</a>
<a name="ln74">  if (id &gt; 0) {</a>
<a name="ln75">    return id;</a>
<a name="ln76">  }</a>
<a name="ln77"> </a>
<a name="ln78">  static bool recursive = false;</a>
<a name="ln79">  if (kv_size(attr_entries) &gt; MAX_TYPENR) {</a>
<a name="ln80">    // Running out of attribute entries!  remove all attributes, and</a>
<a name="ln81">    // compute new ones for all groups.</a>
<a name="ln82">    // When called recursively, we are really out of numbers.</a>
<a name="ln83">    if (recursive) {</a>
<a name="ln84">      EMSG(_(&quot;E424: Too many different highlighting attributes in use&quot;));</a>
<a name="ln85">      return 0;</a>
<a name="ln86">    }</a>
<a name="ln87">    recursive = true;</a>
<a name="ln88"> </a>
<a name="ln89">    clear_hl_tables(true);</a>
<a name="ln90"> </a>
<a name="ln91">    recursive = false;</a>
<a name="ln92">    if (entry.kind == kHlCombine) {</a>
<a name="ln93">      // This entry is now invalid, don't put it</a>
<a name="ln94">      return 0;</a>
<a name="ln95">    }</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  size_t next_id = kv_size(attr_entries);</a>
<a name="ln99">  if (next_id &gt; INT_MAX) {</a>
<a name="ln100">    ELOG(&quot;The index on attr_entries has overflowed&quot;);</a>
<a name="ln101">    return 0;</a>
<a name="ln102">  }</a>
<a name="ln103">  id = (int)next_id;</a>
<a name="ln104">  kv_push(attr_entries, entry);</a>
<a name="ln105"> </a>
<a name="ln106">  map_put(HlEntry, int)(attr_entry_ids, entry, id);</a>
<a name="ln107"> </a>
<a name="ln108">  Array inspect = hl_inspect(id);</a>
<a name="ln109"> </a>
<a name="ln110">  // Note: internally we don't distinguish between cterm and rgb attributes,</a>
<a name="ln111">  // remote_ui_hl_attr_define will however.</a>
<a name="ln112">  ui_call_hl_attr_define(id, entry.attr, entry.attr, inspect);</a>
<a name="ln113">  api_free_array(inspect);</a>
<a name="ln114">  return id;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">/// When a UI connects, we need to send it the table of highlights used so far.</a>
<a name="ln118">void ui_send_all_hls(UI *ui)</a>
<a name="ln119">{</a>
<a name="ln120">  if (ui-&gt;hl_attr_define) {</a>
<a name="ln121">    for (size_t i = 1; i &lt; kv_size(attr_entries); i++) {</a>
<a name="ln122">      Array inspect = hl_inspect((int)i);</a>
<a name="ln123">      ui-&gt;hl_attr_define(ui, (Integer)i, kv_A(attr_entries, i).attr,</a>
<a name="ln124">                         kv_A(attr_entries, i).attr, inspect);</a>
<a name="ln125">      api_free_array(inspect);</a>
<a name="ln126">    }</a>
<a name="ln127">  }</a>
<a name="ln128">  if (ui-&gt;hl_group_set) {</a>
<a name="ln129">    for (size_t hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln130">      ui-&gt;hl_group_set(ui, cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln131">                       highlight_attr[hlf]);</a>
<a name="ln132">    }</a>
<a name="ln133">  }</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">/// Get attribute code for a syntax group.</a>
<a name="ln137">int hl_get_syn_attr(int ns_id, int idx, HlAttrs at_en)</a>
<a name="ln138">{</a>
<a name="ln139">  // TODO(bfredl): should we do this unconditionally</a>
<a name="ln140">  if (at_en.cterm_fg_color != 0 || at_en.cterm_bg_color != 0</a>
<a name="ln141">      || at_en.rgb_fg_color != -1 || at_en.rgb_bg_color != -1</a>
<a name="ln142">      || at_en.rgb_sp_color != -1 || at_en.cterm_ae_attr != 0</a>
<a name="ln143">      || at_en.rgb_ae_attr != 0 || ns_id != 0) {</a>
<a name="ln144">    return get_attr_entry((HlEntry){ .attr = at_en, .kind = kHlSyntax,</a>
<a name="ln145">                                     .id1 = idx, .id2 = ns_id });</a>
<a name="ln146">  } else {</a>
<a name="ln147">    // If all the fields are cleared, clear the attr field back to default value</a>
<a name="ln148">    return 0;</a>
<a name="ln149">  }</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static ColorKey colored_key(NS ns_id, int syn_id)</a>
<a name="ln153">{</a>
<a name="ln154">  return (ColorKey){ .ns_id = (int)ns_id, .syn_id = syn_id };</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">void ns_hl_def(NS ns_id, int hl_id, HlAttrs attrs, int link_id)</a>
<a name="ln158">{</a>
<a name="ln159">  DecorProvider *p = get_provider(ns_id, true);</a>
<a name="ln160">  int attr_id = link_id &gt; 0 ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln161">  ColorItem it = { .attr_id = attr_id,</a>
<a name="ln162">                   .link_id = link_id,</a>
<a name="ln163">                   .version = p-&gt;hl_valid };</a>
<a name="ln164">  map_put(ColorKey, ColorItem)(ns_hl, colored_key(ns_id, hl_id), it);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">int ns_get_hl(NS ns_id, int hl_id, bool link)</a>
<a name="ln168">{</a>
<a name="ln169">  static int recursive = 0;</a>
<a name="ln170"> </a>
<a name="ln171">  if (ns_id &lt; 0) {</a>
<a name="ln172">    if (ns_hl_active &lt;= 0) {</a>
<a name="ln173">      return -1;</a>
<a name="ln174">    }</a>
<a name="ln175">    ns_id = ns_hl_active;</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  DecorProvider *p = get_provider(ns_id, true);</a>
<a name="ln179">  ColorItem it = map_get(ColorKey, ColorItem)(ns_hl, colored_key(ns_id, hl_id));</a>
<a name="ln180">  // TODO(bfredl): map_ref true even this?</a>
<a name="ln181">  bool valid_cache = it.version &gt;= p-&gt;hl_valid;</a>
<a name="ln182"> </a>
<a name="ln183">  if (!valid_cache &amp;&amp; p-&gt;hl_def != LUA_NOREF &amp;&amp; !recursive) {</a>
<a name="ln184">    FIXED_TEMP_ARRAY(args, 3);</a>
<a name="ln185">    args.items[0] = INTEGER_OBJ((Integer)ns_id);</a>
<a name="ln186">    args.items[1] = STRING_OBJ(cstr_to_string((char *)syn_id2name(hl_id)));</a>
<a name="ln187">    args.items[2] = BOOLEAN_OBJ(link);</a>
<a name="ln188">    // TODO(bfredl): preload the &quot;global&quot; attr dict?</a>
<a name="ln189"> </a>
<a name="ln190">    Error err = ERROR_INIT;</a>
<a name="ln191">    recursive++;</a>
<a name="ln192">    Object ret = nlua_call_ref(p-&gt;hl_def, &quot;hl_def&quot;, args, true, &amp;err);</a>
<a name="ln193">    recursive--;</a>
<a name="ln194"> </a>
<a name="ln195">    // TODO(bfredl): or &quot;inherit&quot;, combine with global value?</a>
<a name="ln196">    bool fallback = true;</a>
<a name="ln197">    int tmp = false;</a>
<a name="ln198">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln199">    if (ret.type == kObjectTypeDictionary) {</a>
<a name="ln200">      Dictionary dict = ret.data.dictionary;</a>
<a name="ln201">      fallback = false;</a>
<a name="ln202">      attrs = dict2hlattrs(dict, true, &amp;it.link_id, &amp;err);</a>
<a name="ln203">      for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln204">        char *key = dict.items[i].key.data;</a>
<a name="ln205">        Object val = dict.items[i].value;</a>
<a name="ln206">        bool truthy = api_object_to_bool(val, key, false, &amp;err);</a>
<a name="ln207"> </a>
<a name="ln208">        if (strequal(key, &quot;fallback&quot;)) {</a>
<a name="ln209">          fallback = truthy;</a>
<a name="ln210">        } else if (strequal(key, &quot;temp&quot;)) {</a>
<a name="ln211">          tmp = truthy;</a>
<a name="ln212">        }</a>
<a name="ln213">      }</a>
<a name="ln214">      if (it.link_id &gt;= 0) {</a>
<a name="ln215">        fallback = true;</a>
<a name="ln216">      }</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    it.attr_id = fallback ? -1 : hl_get_syn_attr((int)ns_id, hl_id, attrs);</a>
<a name="ln220">    it.version = p-&gt;hl_valid-tmp;</a>
<a name="ln221">    map_put(ColorKey, ColorItem)(ns_hl, colored_key(ns_id, hl_id), it);</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  if (link) {</a>
<a name="ln225">    return it.attr_id &gt;= 0 ? -1 : it.link_id;</a>
<a name="ln226">  } else {</a>
<a name="ln227">    return it.attr_id;</a>
<a name="ln228">  }</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">bool win_check_ns_hl(win_T *wp)</a>
<a name="ln233">{</a>
<a name="ln234">  if (ns_hl_changed) {</a>
<a name="ln235">    highlight_changed();</a>
<a name="ln236">    if (wp) {</a>
<a name="ln237">      update_window_hl(wp, true);</a>
<a name="ln238">    }</a>
<a name="ln239">    ns_hl_changed = false;</a>
<a name="ln240">    return true;</a>
<a name="ln241">  }</a>
<a name="ln242">  return false;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">/// Get attribute code for a builtin highlight group.</a>
<a name="ln246">///</a>
<a name="ln247">/// The final syntax group could be modified by hi-link or 'winhighlight'.</a>
<a name="ln248">int hl_get_ui_attr(int idx, int final_id, bool optional)</a>
<a name="ln249">{</a>
<a name="ln250">  HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln251">  bool available = false;</a>
<a name="ln252"> </a>
<a name="ln253">  if (final_id &gt; 0) {</a>
<a name="ln254">    int syn_attr = syn_id2attr(final_id);</a>
<a name="ln255">    if (syn_attr != 0) {</a>
<a name="ln256">      attrs = syn_attr2entry(syn_attr);</a>
<a name="ln257">      available = true;</a>
<a name="ln258">    }</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  if (HLF_PNI &lt;= idx &amp;&amp; idx &lt;= HLF_PST) {</a>
<a name="ln262">    if (attrs.hl_blend == -1 &amp;&amp; p_pb &gt; 0) {</a>
<a name="ln263">      attrs.hl_blend = (int)p_pb;</a>
<a name="ln264">    }</a>
<a name="ln265">    if (pum_drawn()) {</a>
<a name="ln266">      must_redraw_pum = true;</a>
<a name="ln267">    }</a>
<a name="ln268">  } else if (idx == HLF_MSG) {</a>
<a name="ln269">    msg_grid.blending = attrs.hl_blend &gt; -1;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  if (optional &amp;&amp; !available) {</a>
<a name="ln273">    return 0;</a>
<a name="ln274">  }</a>
<a name="ln275">  return get_attr_entry((HlEntry){ .attr = attrs, .kind = kHlUI,</a>
<a name="ln276">                                   .id1 = idx, .id2 = final_id });</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">void update_window_hl(win_T *wp, bool invalid)</a>
<a name="ln280">{</a>
<a name="ln281">  if (!wp-&gt;w_hl_needs_update &amp;&amp; !invalid) {</a>
<a name="ln282">    return;</a>
<a name="ln283">  }</a>
<a name="ln284">  wp-&gt;w_hl_needs_update = false;</a>
<a name="ln285"> </a>
<a name="ln286">  // If a floating window is blending it always have a named</a>
<a name="ln287">  // wp-&gt;w_hl_attr_normal group. HL_ATTR(HLF_NFLOAT) is always named.</a>
<a name="ln288">  bool has_blend = wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl != 0;</a>
<a name="ln289"> </a>
<a name="ln290">  // determine window specific background set in 'winhighlight'</a>
<a name="ln291">  bool float_win = wp-&gt;w_floating &amp;&amp; !wp-&gt;w_float_config.external;</a>
<a name="ln292">  if (wp != curwin &amp;&amp; wp-&gt;w_hl_ids[HLF_INACTIVE] != 0) {</a>
<a name="ln293">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(HLF_INACTIVE,</a>
<a name="ln294">                                          wp-&gt;w_hl_ids[HLF_INACTIVE],</a>
<a name="ln295">                                          !has_blend);</a>
<a name="ln296">  } else if (float_win &amp;&amp; wp-&gt;w_hl_ids[HLF_NFLOAT] != 0) {</a>
<a name="ln297">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(HLF_NFLOAT,</a>
<a name="ln298">                                          wp-&gt;w_hl_ids[HLF_NFLOAT], !has_blend);</a>
<a name="ln299">  } else if (wp-&gt;w_hl_id_normal != 0) {</a>
<a name="ln300">    wp-&gt;w_hl_attr_normal = hl_get_ui_attr(-1, wp-&gt;w_hl_id_normal, !has_blend);</a>
<a name="ln301">  } else {</a>
<a name="ln302">    wp-&gt;w_hl_attr_normal = float_win ? HL_ATTR(HLF_NFLOAT) : 0;</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  // NOOOO! You cannot just pretend that &quot;Normal&quot; is just like any other</a>
<a name="ln306">  // syntax group! It needs at least 10 layers of special casing! Noooooo!</a>
<a name="ln307">  //</a>
<a name="ln308">  // haha, theme engine go brrr</a>
<a name="ln309">  int normality = syn_check_group((const char_u *)S_LEN(&quot;Normal&quot;));</a>
<a name="ln310">  int ns_attr = ns_get_hl(-1, normality, false);</a>
<a name="ln311">  if (ns_attr &gt; 0) {</a>
<a name="ln312">    // TODO(bfredl): hantera NormalNC and so on</a>
<a name="ln313">    wp-&gt;w_hl_attr_normal = ns_attr;</a>
<a name="ln314">  }</a>
<a name="ln315"> </a>
<a name="ln316">  // if blend= attribute is not set, 'winblend' value overrides it.</a>
<a name="ln317">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl &gt; 0) {</a>
<a name="ln318">    HlEntry entry = kv_A(attr_entries, wp-&gt;w_hl_attr_normal);</a>
<a name="ln319">    if (entry.attr.hl_blend == -1) {</a>
<a name="ln320">      entry.attr.hl_blend = (int)wp-&gt;w_p_winbl;</a>
<a name="ln321">      wp-&gt;w_hl_attr_normal = get_attr_entry(entry);</a>
<a name="ln322">    }</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  if (wp != curwin &amp;&amp; wp-&gt;w_hl_ids[HLF_INACTIVE] == 0) {</a>
<a name="ln326">    wp-&gt;w_hl_attr_normal = hl_combine_attr(HL_ATTR(HLF_INACTIVE),</a>
<a name="ln327">                                           wp-&gt;w_hl_attr_normal);</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  for (int hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln331">    int attr;</a>
<a name="ln332">    if (wp-&gt;w_hl_ids[hlf] != 0) {</a>
<a name="ln333">      attr = hl_get_ui_attr(hlf, wp-&gt;w_hl_ids[hlf], false);</a>
<a name="ln334">    } else {</a>
<a name="ln335">      attr = HL_ATTR(hlf);</a>
<a name="ln336">    }</a>
<a name="ln337">    wp-&gt;w_hl_attrs[hlf] = attr;</a>
<a name="ln338">  }</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">/// Gets HL_UNDERLINE highlight.</a>
<a name="ln342">int hl_get_underline(void)</a>
<a name="ln343">{</a>
<a name="ln344">  return get_attr_entry((HlEntry){</a>
<a name="ln345">      .attr = (HlAttrs){</a>
<a name="ln346">          .cterm_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln347">          .cterm_fg_color = 0,</a>
<a name="ln348">          .cterm_bg_color = 0,</a>
<a name="ln349">          .rgb_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln350">          .rgb_fg_color = -1,</a>
<a name="ln351">          .rgb_bg_color = -1,</a>
<a name="ln352">          .rgb_sp_color = -1,</a>
<a name="ln353">          .hl_blend = -1,</a>
<a name="ln354">      },</a>
<a name="ln355">      .kind = kHlUI,</a>
<a name="ln356">      .id1 = 0,</a>
<a name="ln357">      .id2 = 0,</a>
<a name="ln358">  });</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">/// Get attribute code for forwarded :terminal highlights.</a>
<a name="ln362">int hl_get_term_attr(HlAttrs *aep)</a>
<a name="ln363">{</a>
<a name="ln364">  return get_attr_entry((HlEntry){ .attr= *aep, .kind = kHlTerminal,</a>
<a name="ln365">                                   .id1 = 0, .id2 = 0 });</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">/// Clear all highlight tables.</a>
<a name="ln369">void clear_hl_tables(bool reinit)</a>
<a name="ln370">{</a>
<a name="ln371">  if (reinit) {</a>
<a name="ln372">    kv_size(attr_entries) = 1;</a>
<a name="ln373">    map_clear(HlEntry, int)(attr_entry_ids);</a>
<a name="ln374">    map_clear(int, int)(combine_attr_entries);</a>
<a name="ln375">    map_clear(int, int)(blend_attr_entries);</a>
<a name="ln376">    map_clear(int, int)(blendthrough_attr_entries);</a>
<a name="ln377">    memset(highlight_attr_last, -1, sizeof(highlight_attr_last));</a>
<a name="ln378">    highlight_attr_set_all();</a>
<a name="ln379">    highlight_changed();</a>
<a name="ln380">    screen_invalidate_highlights();</a>
<a name="ln381">  } else {</a>
<a name="ln382">    kv_destroy(attr_entries);</a>
<a name="ln383">    map_free(HlEntry, int)(attr_entry_ids);</a>
<a name="ln384">    map_free(int, int)(combine_attr_entries);</a>
<a name="ln385">    map_free(int, int)(blend_attr_entries);</a>
<a name="ln386">    map_free(int, int)(blendthrough_attr_entries);</a>
<a name="ln387">    map_free(ColorKey, ColorItem)(ns_hl);</a>
<a name="ln388">  }</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">void hl_invalidate_blends(void)</a>
<a name="ln392">{</a>
<a name="ln393">  map_clear(int, int)(blend_attr_entries);</a>
<a name="ln394">  map_clear(int, int)(blendthrough_attr_entries);</a>
<a name="ln395">  highlight_changed();</a>
<a name="ln396">  update_window_hl(curwin, true);</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">// Combine special attributes (e.g., for spelling) with other attributes</a>
<a name="ln400">// (e.g., for syntax highlighting).</a>
<a name="ln401">// &quot;prim_attr&quot; overrules &quot;char_attr&quot;.</a>
<a name="ln402">// This creates a new group when required.</a>
<a name="ln403">// Since we expect there to be a lot of spelling mistakes we cache the result.</a>
<a name="ln404">// Return the resulting attributes.</a>
<a name="ln405">int hl_combine_attr(int char_attr, int prim_attr)</a>
<a name="ln406">{</a>
<a name="ln407">  if (char_attr == 0) {</a>
<a name="ln408">    return prim_attr;</a>
<a name="ln409">  } else if (prim_attr == 0) {</a>
<a name="ln410">    return char_attr;</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  // TODO(bfredl): could use a struct for clearer intent.</a>
<a name="ln414">  int combine_tag = (char_attr &lt;&lt; 16) + prim_attr;</a>
<a name="ln415">  int id = map_get(int, int)(combine_attr_entries, combine_tag);</a>
<a name="ln416">  if (id &gt; 0) {</a>
<a name="ln417">    return id;</a>
<a name="ln418">  }</a>
<a name="ln419"> </a>
<a name="ln420">  HlAttrs char_aep = syn_attr2entry(char_attr);</a>
<a name="ln421">  HlAttrs spell_aep = syn_attr2entry(prim_attr);</a>
<a name="ln422"> </a>
<a name="ln423">  // start with low-priority attribute, and override colors if present below.</a>
<a name="ln424">  HlAttrs new_en = char_aep;</a>
<a name="ln425"> </a>
<a name="ln426">  if (spell_aep.cterm_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln427">    new_en.cterm_ae_attr = spell_aep.cterm_ae_attr;</a>
<a name="ln428">  } else {</a>
<a name="ln429">    new_en.cterm_ae_attr |= spell_aep.cterm_ae_attr;</a>
<a name="ln430">  }</a>
<a name="ln431">  if (spell_aep.rgb_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln432">    new_en.rgb_ae_attr = spell_aep.rgb_ae_attr;</a>
<a name="ln433">  } else {</a>
<a name="ln434">    new_en.rgb_ae_attr |= spell_aep.rgb_ae_attr;</a>
<a name="ln435">  }</a>
<a name="ln436"> </a>
<a name="ln437">  if (spell_aep.cterm_fg_color &gt; 0) {</a>
<a name="ln438">    new_en.cterm_fg_color = spell_aep.cterm_fg_color;</a>
<a name="ln439">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln440">                           | (spell_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  if (spell_aep.cterm_bg_color &gt; 0) {</a>
<a name="ln444">    new_en.cterm_bg_color = spell_aep.cterm_bg_color;</a>
<a name="ln445">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln446">                           | (spell_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (spell_aep.rgb_fg_color &gt;= 0) {</a>
<a name="ln450">    new_en.rgb_fg_color = spell_aep.rgb_fg_color;</a>
<a name="ln451">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln452">                           | (spell_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln453">  }</a>
<a name="ln454"> </a>
<a name="ln455">  if (spell_aep.rgb_bg_color &gt;= 0) {</a>
<a name="ln456">    new_en.rgb_bg_color = spell_aep.rgb_bg_color;</a>
<a name="ln457">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln458">                           | (spell_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">  if (spell_aep.rgb_sp_color &gt;= 0) {</a>
<a name="ln462">    new_en.rgb_sp_color = spell_aep.rgb_sp_color;</a>
<a name="ln463">  }</a>
<a name="ln464"> </a>
<a name="ln465">  if (spell_aep.hl_blend &gt;= 0) {</a>
<a name="ln466">    new_en.hl_blend = spell_aep.hl_blend;</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  id = get_attr_entry((HlEntry){ .attr = new_en, .kind = kHlCombine,</a>
<a name="ln470">                                 .id1 = char_attr, .id2 = prim_attr });</a>
<a name="ln471">  if (id &gt; 0) {</a>
<a name="ln472">    map_put(int, int)(combine_attr_entries, combine_tag, id);</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475">  return id;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">/// Get the used rgb colors for an attr group.</a>
<a name="ln479">///</a>
<a name="ln480">/// If colors are unset, use builtin default colors. Never returns -1</a>
<a name="ln481">/// Cterm colors are unchanged.</a>
<a name="ln482">static HlAttrs get_colors_force(int attr)</a>
<a name="ln483">{</a>
<a name="ln484">  HlAttrs attrs = syn_attr2entry(attr);</a>
<a name="ln485">  if (attrs.rgb_bg_color == -1) {</a>
<a name="ln486">    attrs.rgb_bg_color = normal_bg;</a>
<a name="ln487">  }</a>
<a name="ln488">  if (attrs.rgb_fg_color == -1) {</a>
<a name="ln489">    attrs.rgb_fg_color = normal_fg;</a>
<a name="ln490">  }</a>
<a name="ln491">  if (attrs.rgb_sp_color == -1) {</a>
<a name="ln492">    attrs.rgb_sp_color = normal_sp;</a>
<a name="ln493">  }</a>
<a name="ln494">  HL_SET_DEFAULT_COLORS(attrs.rgb_fg_color, attrs.rgb_bg_color,</a>
<a name="ln495">                        attrs.rgb_sp_color);</a>
<a name="ln496"> </a>
<a name="ln497">  if (attrs.rgb_ae_attr &amp; HL_INVERSE) {</a>
<a name="ln498">    int temp = attrs.rgb_bg_color;</a>
<a name="ln499">    attrs.rgb_bg_color = attrs.rgb_fg_color;</a>
<a name="ln500">    attrs.rgb_fg_color = temp;</a>
<a name="ln501">    attrs.rgb_ae_attr &amp;= ~HL_INVERSE;</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  return attrs;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">/// Blend overlay attributes (for popupmenu) with other attributes</a>
<a name="ln508">///</a>
<a name="ln509">/// This creates a new group when required.</a>
<a name="ln510">/// This is called per-cell, so cache the result.</a>
<a name="ln511">///</a>
<a name="ln512">/// @return the resulting attributes.</a>
<a name="ln513">int hl_blend_attrs(int back_attr, int front_attr, bool *through)</a>
<a name="ln514">{</a>
<a name="ln515">  HlAttrs fattrs = get_colors_force(front_attr);</a>
<a name="ln516">  int ratio = fattrs.hl_blend;</a>
<a name="ln517">  if (ratio &lt;= 0) {</a>
<a name="ln518">    *through = false;</a>
<a name="ln519">    return front_attr;</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  int combine_tag = (back_attr &lt;&lt; 16) + front_attr;</a>
<a name="ln523">  Map(int, int) *map = (*through</a>
<a name="ln524">                        ? blendthrough_attr_entries</a>
<a name="ln525">                        : blend_attr_entries);</a>
<a name="ln526">  int id = map_get(int, int)(map, combine_tag);</a>
<a name="ln527">  if (id &gt; 0) {</a>
<a name="ln528">    return id;</a>
<a name="ln529">  }</a>
<a name="ln530"> </a>
<a name="ln531">  HlAttrs battrs = get_colors_force(back_attr);</a>
<a name="ln532">  HlAttrs cattrs;</a>
<a name="ln533"> </a>
<a name="ln534">  if (*through) {</a>
<a name="ln535">    cattrs = battrs;</a>
<a name="ln536">    cattrs.rgb_fg_color = rgb_blend(ratio, battrs.rgb_fg_color,</a>
<a name="ln537">                                    fattrs.rgb_bg_color);</a>
<a name="ln538">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE|HL_UNDERCURL)) {</a>
<a name="ln539">      cattrs.rgb_sp_color = rgb_blend(ratio, battrs.rgb_sp_color,</a>
<a name="ln540">                                      fattrs.rgb_bg_color);</a>
<a name="ln541">    } else {</a>
<a name="ln542">      cattrs.rgb_sp_color = -1;</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">    cattrs.cterm_bg_color = fattrs.cterm_bg_color;</a>
<a name="ln546">    cattrs.cterm_fg_color = cterm_blend(ratio, battrs.cterm_fg_color,</a>
<a name="ln547">                                        fattrs.cterm_bg_color);</a>
<a name="ln548">    cattrs.rgb_ae_attr &amp;= ~(HL_FG_INDEXED | HL_BG_INDEXED);</a>
<a name="ln549">  } else {</a>
<a name="ln550">    cattrs = fattrs;</a>
<a name="ln551">    if (ratio &gt;= 50) {</a>
<a name="ln552">      cattrs.rgb_ae_attr |= battrs.rgb_ae_attr;</a>
<a name="ln553">    }</a>
<a name="ln554">    cattrs.rgb_fg_color = rgb_blend(ratio/2, battrs.rgb_fg_color,</a>
<a name="ln555">                                    fattrs.rgb_fg_color);</a>
<a name="ln556">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE|HL_UNDERCURL)) {</a>
<a name="ln557">      cattrs.rgb_sp_color = rgb_blend(ratio/2, battrs.rgb_bg_color,</a>
<a name="ln558">                                      fattrs.rgb_sp_color);</a>
<a name="ln559">    } else {</a>
<a name="ln560">      cattrs.rgb_sp_color = -1;</a>
<a name="ln561">    }</a>
<a name="ln562"> </a>
<a name="ln563">    cattrs.rgb_ae_attr &amp;= ~HL_BG_INDEXED;</a>
<a name="ln564">  }</a>
<a name="ln565">  cattrs.rgb_bg_color = rgb_blend(ratio, battrs.rgb_bg_color,</a>
<a name="ln566">                                  fattrs.rgb_bg_color);</a>
<a name="ln567"> </a>
<a name="ln568">  cattrs.hl_blend = -1;  // blend property was consumed</a>
<a name="ln569"> </a>
<a name="ln570">  HlKind kind = *through ? kHlBlendThrough : kHlBlend;</a>
<a name="ln571">  id = get_attr_entry((HlEntry){ .attr = cattrs, .kind = kind,</a>
<a name="ln572">                                 .id1 = back_attr, .id2 = front_attr });</a>
<a name="ln573">  if (id &gt; 0) {</a>
<a name="ln574">    map_put(int, int)(map, combine_tag, id);</a>
<a name="ln575">  }</a>
<a name="ln576">  return id;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">static int rgb_blend(int ratio, int rgb1, int rgb2)</a>
<a name="ln580">{</a>
<a name="ln581">  int a = ratio, b = 100-ratio;</a>
<a name="ln582">  int r1 = (rgb1 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln583">  int g1 = (rgb1 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln584">  int b1 = (rgb1 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln585">  int r2 = (rgb2 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln586">  int g2 = (rgb2 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln587">  int b2 = (rgb2 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln588">  int mr = (a * r1 + b * r2)/100;</a>
<a name="ln589">  int mg = (a * g1 + b * g2)/100;</a>
<a name="ln590">  int mb = (a * b1 + b * b2)/100;</a>
<a name="ln591">  return (mr &lt;&lt; 16) + (mg &lt;&lt; 8) + mb;</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">static int cterm_blend(int ratio, int c1, int c2)</a>
<a name="ln595">{</a>
<a name="ln596">  // 1. Convert cterm color numbers to RGB.</a>
<a name="ln597">  // 2. Blend the RGB colors.</a>
<a name="ln598">  // 3. Convert the RGB result to a cterm color.</a>
<a name="ln599">  int rgb1 = hl_cterm2rgb_color(c1);</a>
<a name="ln600">  int rgb2 = hl_cterm2rgb_color(c2);</a>
<a name="ln601">  int rgb_blended = rgb_blend(ratio, rgb1, rgb2);</a>
<a name="ln602">  return hl_rgb2cterm_color(rgb_blended);</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">/// Converts RGB color to 8-bit color (0-255).</a>
<a name="ln606">static int hl_rgb2cterm_color(int rgb)</a>
<a name="ln607">{</a>
<a name="ln608">  int r = (rgb &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln609">  int g = (rgb &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln610">  int b = (rgb &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln611"> </a>
<a name="ln612">  return (r * 6 / 256) * 36 + (g * 6 / 256) * 6 + (b * 6 / 256);</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">/// Converts 8-bit color (0-255) to RGB color.</a>
<a name="ln616">/// This is compatible with xterm.</a>
<a name="ln617">static int hl_cterm2rgb_color(int nr)</a>
<a name="ln618">{</a>
<a name="ln619">  static int cube_value[] = {</a>
<a name="ln620">    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF</a>
<a name="ln621">  };</a>
<a name="ln622">  static int grey_ramp[] = {</a>
<a name="ln623">    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,</a>
<a name="ln624">    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE</a>
<a name="ln625">  };</a>
<a name="ln626">  static char_u ansi_table[16][4] = {</a>
<a name="ln627">    //  R    G    B   idx</a>
<a name="ln628">    {   0,   0,   0,  1 } ,  // black</a>
<a name="ln629">    { 224,   0,   0,  2 } ,  // dark red</a>
<a name="ln630">    {   0, 224,   0,  3 } ,  // dark green</a>
<a name="ln631">    { 224, 224,   0,  4 } ,  // dark yellow / brown</a>
<a name="ln632">    {   0,   0, 224,  5 } ,  // dark blue</a>
<a name="ln633">    { 224,   0, 224,  6 } ,  // dark magenta</a>
<a name="ln634">    {   0, 224, 224,  7 } ,  // dark cyan</a>
<a name="ln635">    { 224, 224, 224,  8 } ,  // light grey</a>
<a name="ln636"> </a>
<a name="ln637">    { 128, 128, 128,  9 } ,  // dark grey</a>
<a name="ln638">    { 255,  64,  64, 10 } ,  // light red</a>
<a name="ln639">    {  64, 255,  64, 11 } ,  // light green</a>
<a name="ln640">    { 255, 255,  64, 12 } ,  // yellow</a>
<a name="ln641">    {  64,  64, 255, 13 } ,  // light blue</a>
<a name="ln642">    { 255,  64, 255, 14 } ,  // light magenta</a>
<a name="ln643">    {  64, 255, 255, 15 } ,  // light cyan</a>
<a name="ln644">    { 255, 255, 255, 16 } ,  // white</a>
<a name="ln645">  };</a>
<a name="ln646"> </a>
<a name="ln647">  int r = 0;</a>
<a name="ln648">  int g = 0;</a>
<a name="ln649">  int b = 0;</a>
<a name="ln650">  int idx;</a>
<a name="ln651">  // *ansi_idx = 0;</a>
<a name="ln652"> </a>
<a name="ln653">  if (nr &lt; 16) {</a>
<a name="ln654">    r = ansi_table[nr][0];</a>
<a name="ln655">    g = ansi_table[nr][1];</a>
<a name="ln656">    b = ansi_table[nr][2];</a>
<a name="ln657">    // *ansi_idx = ansi_table[nr][3];</a>
<a name="ln658">  } else if (nr &lt; 232) {  // 216 color-cube</a>
<a name="ln659">    idx = nr - 16;</a>
<a name="ln660">    r = cube_value[idx / 36 % 6];</a>
<a name="ln661">    g = cube_value[idx / 6  % 6];</a>
<a name="ln662">    b = cube_value[idx      % 6];</a>
<a name="ln663">    // *ansi_idx = -1;</a>
<a name="ln664">  } else if (nr &lt; 256) {  // 24 greyscale ramp</a>
<a name="ln665">    idx = nr - 232;</a>
<a name="ln666">    r = grey_ramp[idx];</a>
<a name="ln667">    g = grey_ramp[idx];</a>
<a name="ln668">    b = grey_ramp[idx];</a>
<a name="ln669">    // *ansi_idx = -1;</a>
<a name="ln670">  }</a>
<a name="ln671">  return (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/// Get highlight attributes for a attribute code</a>
<a name="ln675">HlAttrs syn_attr2entry(int attr)</a>
<a name="ln676">{</a>
<a name="ln677">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln678">    // invalid attribute code, or the tables were cleared</a>
<a name="ln679">    return HLATTRS_INIT;</a>
<a name="ln680">  }</a>
<a name="ln681">  return kv_A(attr_entries, attr).attr;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/// Gets highlight description for id `attr_id` as a map.</a>
<a name="ln685">Dictionary hl_get_attr_by_id(Integer attr_id, Boolean rgb, Error *err)</a>
<a name="ln686">{</a>
<a name="ln687">  Dictionary dic = ARRAY_DICT_INIT;</a>
<a name="ln688"> </a>
<a name="ln689">  if (attr_id == 0) {</a>
<a name="ln690">    return dic;</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  if (attr_id &lt;= 0 || attr_id &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln694">    api_set_error(err, kErrorTypeException,</a>
<a name="ln695">                  &quot;Invalid attribute id: %&quot; PRId64, attr_id);</a>
<a name="ln696">    return dic;</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  return hlattrs2dict(syn_attr2entry((int)attr_id), rgb);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">/// Converts an HlAttrs into Dictionary</a>
<a name="ln703">///</a>
<a name="ln704">/// @param[in] aep data to convert</a>
<a name="ln705">/// @param use_rgb use 'gui*' settings if true, else resorts to 'cterm*'</a>
<a name="ln706">Dictionary hlattrs2dict(HlAttrs ae, bool use_rgb)</a>
<a name="ln707">{</a>
<a name="ln708">  Dictionary hl = ARRAY_DICT_INIT;</a>
<a name="ln709">  int mask  = use_rgb ? ae.rgb_ae_attr : ae.cterm_ae_attr;</a>
<a name="ln710"> </a>
<a name="ln711">  if (mask &amp; HL_BOLD) {</a>
<a name="ln712">    PUT(hl, &quot;bold&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln713">  }</a>
<a name="ln714"> </a>
<a name="ln715">  if (mask &amp; HL_STANDOUT) {</a>
<a name="ln716">    PUT(hl, &quot;standout&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  if (mask &amp; HL_UNDERLINE) {</a>
<a name="ln720">    PUT(hl, &quot;underline&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  if (mask &amp; HL_UNDERCURL) {</a>
<a name="ln724">    PUT(hl, &quot;undercurl&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln725">  }</a>
<a name="ln726"> </a>
<a name="ln727">  if (mask &amp; HL_ITALIC) {</a>
<a name="ln728">    PUT(hl, &quot;italic&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">  if (mask &amp; HL_INVERSE) {</a>
<a name="ln732">    PUT(hl, &quot;reverse&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  if (mask &amp; HL_STRIKETHROUGH) {</a>
<a name="ln736">    PUT(hl, &quot;strikethrough&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">  if (use_rgb) {</a>
<a name="ln740">    if (mask &amp; HL_FG_INDEXED) {</a>
<a name="ln741">      PUT(hl, &quot;fg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln742">    }</a>
<a name="ln743"> </a>
<a name="ln744">    if (mask &amp; HL_BG_INDEXED) {</a>
<a name="ln745">      PUT(hl, &quot;bg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln746">    }</a>
<a name="ln747"> </a>
<a name="ln748">    if (ae.rgb_fg_color != -1) {</a>
<a name="ln749">      PUT(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.rgb_fg_color));</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    if (ae.rgb_bg_color != -1) {</a>
<a name="ln753">      PUT(hl, &quot;background&quot;, INTEGER_OBJ(ae.rgb_bg_color));</a>
<a name="ln754">    }</a>
<a name="ln755"> </a>
<a name="ln756">    if (ae.rgb_sp_color != -1) {</a>
<a name="ln757">      PUT(hl, &quot;special&quot;, INTEGER_OBJ(ae.rgb_sp_color));</a>
<a name="ln758">    }</a>
<a name="ln759">  } else {</a>
<a name="ln760">    if (cterm_normal_fg_color != ae.cterm_fg_color &amp;&amp; ae.cterm_fg_color != 0) {</a>
<a name="ln761">      PUT(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.cterm_fg_color - 1));</a>
<a name="ln762">    }</a>
<a name="ln763"> </a>
<a name="ln764">    if (cterm_normal_bg_color != ae.cterm_bg_color &amp;&amp; ae.cterm_bg_color != 0) {</a>
<a name="ln765">      PUT(hl, &quot;background&quot;, INTEGER_OBJ(ae.cterm_bg_color - 1));</a>
<a name="ln766">    }</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">  if (ae.hl_blend &gt; -1) {</a>
<a name="ln770">      PUT(hl, &quot;blend&quot;, INTEGER_OBJ(ae.hl_blend));</a>
<a name="ln771">  }</a>
<a name="ln772"> </a>
<a name="ln773">  return hl;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">HlAttrs dict2hlattrs(Dictionary dict, bool use_rgb, int *link_id, Error *err)</a>
<a name="ln777">{</a>
<a name="ln778">  HlAttrs hlattrs = HLATTRS_INIT;</a>
<a name="ln779"> </a>
<a name="ln780">  int32_t fg = -1, bg = -1, sp = -1;</a>
<a name="ln781">  int16_t mask = 0;</a>
<a name="ln782">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln783">    char *key = dict.items[i].key.data;</a>
<a name="ln784">    Object val = dict.items[i].value;</a>
<a name="ln785"> </a>
<a name="ln786">    struct {</a>
<a name="ln787">      const char *name;</a>
<a name="ln788">      int16_t flag;</a>
<a name="ln789">    } flags[] = {</a>
<a name="ln790">      { &quot;bold&quot;, HL_BOLD },</a>
<a name="ln791">      { &quot;standout&quot;, HL_STANDOUT },</a>
<a name="ln792">      { &quot;underline&quot;, HL_UNDERLINE },</a>
<a name="ln793">      { &quot;undercurl&quot;, HL_UNDERCURL },</a>
<a name="ln794">      { &quot;italic&quot;, HL_ITALIC },</a>
<a name="ln795">      { &quot;reverse&quot;, HL_INVERSE },</a>
<a name="ln796">      { NULL, 0 },</a>
<a name="ln797">    };</a>
<a name="ln798"> </a>
<a name="ln799">    int j;</a>
<a name="ln800">    for (j = 0; flags[j].name; j++) {</a>
<a name="ln801">      if (strequal(flags[j].name, key)) {</a>
<a name="ln802">        if (api_object_to_bool(val, key, false, err)) {</a>
<a name="ln803">          mask = mask | flags[j].flag;</a>
<a name="ln804">        }</a>
<a name="ln805">        break;</a>
<a name="ln806">      }</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809">    struct {</a>
<a name="ln810">      const char *name;</a>
<a name="ln811">      const char *shortname;</a>
<a name="ln812">      int *dest;</a>
<a name="ln813">    } colors[] = {</a>
<a name="ln814">      { &quot;foreground&quot;, &quot;fg&quot;, &amp;fg },</a>
<a name="ln815">      { &quot;background&quot;, &quot;bg&quot;, &amp;bg },</a>
<a name="ln816">      { &quot;special&quot;, &quot;sp&quot;, &amp;sp },</a>
<a name="ln817">      { NULL, NULL, NULL },</a>
<a name="ln818">    };</a>
<a name="ln819"> </a>
<a name="ln820">    int k;</a>
<a name="ln821">    for (k = 0; (!flags[j].name) &amp;&amp; colors[k].name; k++) {</a>
<a name="ln822">      if (strequal(colors[k].name, key) || strequal(colors[k].shortname, key)) {</a>
<a name="ln823">        if (val.type == kObjectTypeInteger) {</a>
<a name="ln824">          *colors[k].dest = (int)val.data.integer;</a>
<a name="ln825">        } else if (val.type == kObjectTypeString) {</a>
<a name="ln826">          String str = val.data.string;</a>
<a name="ln827">          // TODO(bfredl): be more fancy with &quot;bg&quot;, &quot;fg&quot; etc</a>
<a name="ln828">          if (str.size) {</a>
<a name="ln829">            *colors[k].dest = name_to_color(str.data);</a>
<a name="ln830">          }</a>
<a name="ln831">        } else {</a>
<a name="ln832">          api_set_error(err, kErrorTypeValidation,</a>
<a name="ln833">                        &quot;'%s' must be string or integer&quot;, key);</a>
<a name="ln834">        }</a>
<a name="ln835">        break;</a>
<a name="ln836">      }</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839"> </a>
<a name="ln840">    if (flags[j].name || colors[k].name) {</a>
<a name="ln841">      // handled above</a>
<a name="ln842">    } else if (link_id &amp;&amp; strequal(key, &quot;link&quot;)) {</a>
<a name="ln843">      if (val.type == kObjectTypeString) {</a>
<a name="ln844">        String str = val.data.string;</a>
<a name="ln845">        *link_id = syn_check_group((const char_u *)str.data, (int)str.size);</a>
<a name="ln846">      } else if (val.type == kObjectTypeInteger) {</a>
<a name="ln847">        // TODO(bfredl): validate range?</a>
<a name="ln848">        *link_id = (int)val.data.integer;</a>
<a name="ln849">      } else {</a>
<a name="ln850">        api_set_error(err, kErrorTypeValidation,</a>
<a name="ln851">                      &quot;'link' must be string or integer&quot;);</a>
<a name="ln852">      }</a>
<a name="ln853">    }</a>
<a name="ln854"> </a>
<a name="ln855">    if (ERROR_SET(err)) {</a>
<a name="ln856">      return hlattrs;  // error set, caller should not use retval</a>
<a name="ln857">    }</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  if (use_rgb) {</a>
<a name="ln861">    hlattrs.rgb_ae_attr = mask;</a>
<a name="ln862">    hlattrs.rgb_bg_color = bg;</a>
<a name="ln863">    hlattrs.rgb_fg_color = fg;</a>
<a name="ln864">    hlattrs.rgb_sp_color = sp;</a>
<a name="ln865">  } else {</a>
<a name="ln866">    hlattrs.cterm_ae_attr = mask;</a>
<a name="ln867">    hlattrs.cterm_bg_color = bg == -1 ? cterm_normal_bg_color : bg + 1;</a>
<a name="ln868">    hlattrs.cterm_fg_color = fg == -1 ? cterm_normal_fg_color : fg + 1;</a>
<a name="ln869">  }</a>
<a name="ln870"> </a>
<a name="ln871">  return hlattrs;</a>
<a name="ln872">}</a>
<a name="ln873">Array hl_inspect(int attr)</a>
<a name="ln874">{</a>
<a name="ln875">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln876">  if (hlstate_active) {</a>
<a name="ln877">    hl_inspect_impl(&amp;ret, attr);</a>
<a name="ln878">  }</a>
<a name="ln879">  return ret;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">static void hl_inspect_impl(Array *arr, int attr)</a>
<a name="ln883">{</a>
<a name="ln884">  Dictionary item = ARRAY_DICT_INIT;</a>
<a name="ln885">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln886">    return;</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  HlEntry e = kv_A(attr_entries, attr);</a>
<a name="ln890">  switch (e.kind) {</a>
<a name="ln891">    case kHlSyntax:</a>
<a name="ln892">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;syntax&quot;)));</a>
<a name="ln893">      PUT(item, &quot;hi_name&quot;,</a>
<a name="ln894">          STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id1))));</a>
<a name="ln895">      break;</a>
<a name="ln896"> </a>
<a name="ln897">    case kHlUI:</a>
<a name="ln898">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;ui&quot;)));</a>
<a name="ln899">      const char *ui_name = (e.id1 == -1) ? &quot;Normal&quot; : hlf_names[e.id1];</a>
<a name="ln900">      PUT(item, &quot;ui_name&quot;, STRING_OBJ(cstr_to_string(ui_name)));</a>
<a name="ln901">      PUT(item, &quot;hi_name&quot;,</a>
<a name="ln902">          STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id2))));</a>
<a name="ln903">      break;</a>
<a name="ln904"> </a>
<a name="ln905">    case kHlTerminal:</a>
<a name="ln906">      PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;term&quot;)));</a>
<a name="ln907">      break;</a>
<a name="ln908"> </a>
<a name="ln909">    case kHlCombine:</a>
<a name="ln910">    case kHlBlend:</a>
<a name="ln911">    case kHlBlendThrough:</a>
<a name="ln912">      // attribute combination is associative, so flatten to an array</a>
<a name="ln913">      hl_inspect_impl(arr, e.id1);</a>
<a name="ln914">      hl_inspect_impl(arr, e.id2);</a>
<a name="ln915">      return;</a>
<a name="ln916"> </a>
<a name="ln917">     case kHlUnknown:</a>
<a name="ln918">      return;</a>
<a name="ln919">  }</a>
<a name="ln920">  PUT(item, &quot;id&quot;, INTEGER_OBJ(attr));</a>
<a name="ln921">  ADD(*arr, DICTIONARY_OBJ(item));</a>
<a name="ln922">}</a>

</code></pre>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cattrs.rgb_fg_color' should be checked here.</p></div>
<div class="balloon" rel="556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cattrs.rgb_fg_color' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>input.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">#include &quot;nvim/tui/input.h&quot;</a>
<a name="ln6">#include &quot;nvim/vim.h&quot;</a>
<a name="ln7">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/charset.h&quot;</a>
<a name="ln11">#include &quot;nvim/main.h&quot;</a>
<a name="ln12">#include &quot;nvim/aucmd.h&quot;</a>
<a name="ln13">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln14">#include &quot;nvim/option.h&quot;</a>
<a name="ln15">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln16">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln17">#ifdef WIN32</a>
<a name="ln18"># include &quot;nvim/os/os_win_console.h&quot;</a>
<a name="ln19">#endif</a>
<a name="ln20">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#define KEY_BUFFER_SIZE 0xfff</a>
<a name="ln23"> </a>
<a name="ln24">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln25"># include &quot;tui/input.c.generated.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">void tinput_init(TermInput *input, Loop *loop)</a>
<a name="ln29">{</a>
<a name="ln30">  input-&gt;loop = loop;</a>
<a name="ln31">  input-&gt;paste = 0;</a>
<a name="ln32">  input-&gt;in_fd = STDIN_FILENO;</a>
<a name="ln33">  input-&gt;waiting_for_bg_response = 0;</a>
<a name="ln34">  // The main thread is waiting for the UI thread to call CONTINUE, so it can</a>
<a name="ln35">  // safely access global variables.</a>
<a name="ln36">  input-&gt;ttimeout = (bool)p_ttimeout;</a>
<a name="ln37">  input-&gt;ttimeoutlen = p_ttm;</a>
<a name="ln38">  input-&gt;key_buffer = rbuffer_new(KEY_BUFFER_SIZE);</a>
<a name="ln39">  uv_mutex_init(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln40">  uv_cond_init(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln41"> </a>
<a name="ln42">  // If stdin is not a pty, switch to stderr. For cases like:</a>
<a name="ln43">  //    echo q | nvim -es</a>
<a name="ln44">  //    ls *.md | xargs nvim</a>
<a name="ln45">#ifdef WIN32</a>
<a name="ln46">  if (!os_isatty(input-&gt;in_fd)) {</a>
<a name="ln47">      input-&gt;in_fd = os_get_conin_fd();</a>
<a name="ln48">  }</a>
<a name="ln49">#else</a>
<a name="ln50">  if (!os_isatty(input-&gt;in_fd) &amp;&amp; os_isatty(STDERR_FILENO)) {</a>
<a name="ln51">    input-&gt;in_fd = STDERR_FILENO;</a>
<a name="ln52">  }</a>
<a name="ln53">#endif</a>
<a name="ln54">  input_global_fd_init(input-&gt;in_fd);</a>
<a name="ln55"> </a>
<a name="ln56">  const char *term = os_getenv(&quot;TERM&quot;);</a>
<a name="ln57">  if (!term) {</a>
<a name="ln58">    term = &quot;&quot;;  // termkey_new_abstract assumes non-null (#2745)</a>
<a name="ln59">  }</a>
<a name="ln60"> </a>
<a name="ln61">#if TERMKEY_VERSION_MAJOR &gt; 0 || TERMKEY_VERSION_MINOR &gt; 18</a>
<a name="ln62">  input-&gt;tk = termkey_new_abstract(term,</a>
<a name="ln63">                                   TERMKEY_FLAG_UTF8 | TERMKEY_FLAG_NOSTART);</a>
<a name="ln64">  termkey_hook_terminfo_getstr(input-&gt;tk, input-&gt;tk_ti_hook_fn, NULL);</a>
<a name="ln65">  termkey_start(input-&gt;tk);</a>
<a name="ln66">#else</a>
<a name="ln67">  input-&gt;tk = termkey_new_abstract(term, TERMKEY_FLAG_UTF8);</a>
<a name="ln68">#endif</a>
<a name="ln69"> </a>
<a name="ln70">  int curflags = termkey_get_canonflags(input-&gt;tk);</a>
<a name="ln71">  termkey_set_canonflags(input-&gt;tk, curflags | TERMKEY_CANON_DELBS);</a>
<a name="ln72"> </a>
<a name="ln73">  // setup input handle</a>
<a name="ln74">  rstream_init_fd(loop, &amp;input-&gt;read_stream, input-&gt;in_fd, 0xfff);</a>
<a name="ln75">  // initialize a timer handle for handling ESC with libtermkey</a>
<a name="ln76">  time_watcher_init(loop, &amp;input-&gt;timer_handle, input);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">void tinput_destroy(TermInput *input)</a>
<a name="ln80">{</a>
<a name="ln81">  rbuffer_free(input-&gt;key_buffer);</a>
<a name="ln82">  uv_mutex_destroy(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln83">  uv_cond_destroy(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln84">  time_watcher_close(&amp;input-&gt;timer_handle, NULL);</a>
<a name="ln85">  stream_close(&amp;input-&gt;read_stream, NULL, NULL);</a>
<a name="ln86">  termkey_destroy(input-&gt;tk);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">void tinput_start(TermInput *input)</a>
<a name="ln90">{</a>
<a name="ln91">  rstream_start(&amp;input-&gt;read_stream, tinput_read_cb, input);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">void tinput_stop(TermInput *input)</a>
<a name="ln95">{</a>
<a name="ln96">  rstream_stop(&amp;input-&gt;read_stream);</a>
<a name="ln97">  time_watcher_stop(&amp;input-&gt;timer_handle);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">static void tinput_done_event(void **argv)</a>
<a name="ln101">{</a>
<a name="ln102">  input_done();</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static void tinput_wait_enqueue(void **argv)</a>
<a name="ln106">{</a>
<a name="ln107">  TermInput *input = argv[0];</a>
<a name="ln108">  RBUFFER_UNTIL_EMPTY(input-&gt;key_buffer, buf, len) {</a>
<a name="ln109">    const String keys = { .data = buf, .size = len };</a>
<a name="ln110">    if (input-&gt;paste) {</a>
<a name="ln111">      String copy = copy_string(keys);</a>
<a name="ln112">      multiqueue_put(main_loop.events, tinput_paste_event, 3,</a>
<a name="ln113">                     copy.data, copy.size, (intptr_t)input-&gt;paste);</a>
<a name="ln114">      if (input-&gt;paste == 1) {</a>
<a name="ln115">        // Paste phase: &quot;continue&quot;</a>
<a name="ln116">        input-&gt;paste = 2;</a>
<a name="ln117">      }</a>
<a name="ln118">      rbuffer_consumed(input-&gt;key_buffer, len);</a>
<a name="ln119">      rbuffer_reset(input-&gt;key_buffer);</a>
<a name="ln120">    } else {</a>
<a name="ln121">      const size_t consumed = input_enqueue(keys);</a>
<a name="ln122">      if (consumed) {</a>
<a name="ln123">        rbuffer_consumed(input-&gt;key_buffer, consumed);</a>
<a name="ln124">      }</a>
<a name="ln125">      rbuffer_reset(input-&gt;key_buffer);</a>
<a name="ln126">      if (consumed &lt; len) {</a>
<a name="ln127">        break;</a>
<a name="ln128">      }</a>
<a name="ln129">    }</a>
<a name="ln130">  }</a>
<a name="ln131">  uv_mutex_lock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln132">  input-&gt;waiting = false;</a>
<a name="ln133">  uv_cond_signal(&amp;input-&gt;key_buffer_cond);</a>
<a name="ln134">  uv_mutex_unlock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static void tinput_paste_event(void **argv)</a>
<a name="ln138">{</a>
<a name="ln139">  String keys = { .data = argv[0], .size = (size_t)argv[1] };</a>
<a name="ln140">  intptr_t phase = (intptr_t)argv[2];</a>
<a name="ln141"> </a>
<a name="ln142">  Error err = ERROR_INIT;</a>
<a name="ln143">  nvim_paste(keys, true, phase, &amp;err);</a>
<a name="ln144">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln145">    emsgf(&quot;paste: %s&quot;, err.msg);</a>
<a name="ln146">    api_clear_error(&amp;err);</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  api_free_string(keys);</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static void tinput_flush(TermInput *input, bool wait_until_empty)</a>
<a name="ln153">{</a>
<a name="ln154">  size_t drain_boundary = wait_until_empty ? 0 : 0xff;</a>
<a name="ln155">  do {</a>
<a name="ln156">    uv_mutex_lock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln157">    loop_schedule_fast(&amp;main_loop, event_create(tinput_wait_enqueue, 1, input));</a>
<a name="ln158">    input-&gt;waiting = true;</a>
<a name="ln159">    while (input-&gt;waiting) {</a>
<a name="ln160">      uv_cond_wait(&amp;input-&gt;key_buffer_cond, &amp;input-&gt;key_buffer_mutex);</a>
<a name="ln161">    }</a>
<a name="ln162">    uv_mutex_unlock(&amp;input-&gt;key_buffer_mutex);</a>
<a name="ln163">  } while (rbuffer_size(input-&gt;key_buffer) &gt; drain_boundary);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static void tinput_enqueue(TermInput *input, char *buf, size_t size)</a>
<a name="ln167">{</a>
<a name="ln168">  if (rbuffer_size(input-&gt;key_buffer) &gt;</a>
<a name="ln169">      rbuffer_capacity(input-&gt;key_buffer) - 0xff) {</a>
<a name="ln170">    // don't ever let the buffer get too full or we risk putting incomplete keys</a>
<a name="ln171">    // into it</a>
<a name="ln172">    tinput_flush(input, false);</a>
<a name="ln173">  }</a>
<a name="ln174">  rbuffer_write(input-&gt;key_buffer, buf, size);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">static void forward_simple_utf8(TermInput *input, TermKeyKey *key)</a>
<a name="ln178">{</a>
<a name="ln179">  size_t len = 0;</a>
<a name="ln180">  char buf[64];</a>
<a name="ln181">  char *ptr = key-&gt;utf8;</a>
<a name="ln182"> </a>
<a name="ln183">  while (*ptr) {</a>
<a name="ln184">    if (*ptr == '&lt;') {</a>
<a name="ln185">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;&lt;lt&gt;&quot;);</a>
<a name="ln186">    } else {</a>
<a name="ln187">      buf[len++] = *ptr;</a>
<a name="ln188">    }</a>
<a name="ln189">    ptr++;</a>
<a name="ln190">  }</a>
<a name="ln191"> </a>
<a name="ln192">  tinput_enqueue(input, buf, len);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static void forward_modified_utf8(TermInput *input, TermKeyKey *key)</a>
<a name="ln196">{</a>
<a name="ln197">  size_t len;</a>
<a name="ln198">  char buf[64];</a>
<a name="ln199"> </a>
<a name="ln200">  if (key-&gt;type == TERMKEY_TYPE_KEYSYM</a>
<a name="ln201">      &amp;&amp; key-&gt;code.sym == TERMKEY_SYM_ESCAPE) {</a>
<a name="ln202">    len = (size_t)snprintf(buf, sizeof(buf), &quot;&lt;Esc&gt;&quot;);</a>
<a name="ln203">  } else if (key-&gt;type == TERMKEY_TYPE_KEYSYM</a>
<a name="ln204">      &amp;&amp; key-&gt;code.sym == TERMKEY_SYM_SUSPEND) {</a>
<a name="ln205">    len = (size_t)snprintf(buf, sizeof(buf), &quot;&lt;C-Z&gt;&quot;);</a>
<a name="ln206">  } else {</a>
<a name="ln207">    len = termkey_strfkey(input-&gt;tk, buf, sizeof(buf), key, TERMKEY_FORMAT_VIM);</a>
<a name="ln208">  }</a>
<a name="ln209"> </a>
<a name="ln210">  tinput_enqueue(input, buf, len);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static void forward_mouse_event(TermInput *input, TermKeyKey *key)</a>
<a name="ln214">{</a>
<a name="ln215">  char buf[64];</a>
<a name="ln216">  size_t len = 0;</a>
<a name="ln217">  int button, row, col;</a>
<a name="ln218">  static int last_pressed_button = 0;</a>
<a name="ln219">  TermKeyMouseEvent ev;</a>
<a name="ln220">  termkey_interpret_mouse(input-&gt;tk, key, &amp;ev, &amp;button, &amp;row, &amp;col);</a>
<a name="ln221"> </a>
<a name="ln222">  if ((ev == TERMKEY_MOUSE_RELEASE || ev == TERMKEY_MOUSE_DRAG)</a>
<a name="ln223">      &amp;&amp; button == 0) {</a>
<a name="ln224">    // Some terminals (like urxvt) don't report which button was released.</a>
<a name="ln225">    // libtermkey reports button 0 in this case.</a>
<a name="ln226">    // For drag and release, we can reasonably infer the button to be the last</a>
<a name="ln227">    // pressed one.</a>
<a name="ln228">    button = last_pressed_button;</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  if (button == 0 || (ev != TERMKEY_MOUSE_PRESS &amp;&amp; ev != TERMKEY_MOUSE_DRAG</a>
<a name="ln232">                      &amp;&amp; ev != TERMKEY_MOUSE_RELEASE)) {</a>
<a name="ln233">    return;</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  row--; col--;  // Termkey uses 1-based coordinates</a>
<a name="ln237">  buf[len++] = '&lt;';</a>
<a name="ln238"> </a>
<a name="ln239">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_SHIFT) {</a>
<a name="ln240">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;S-&quot;);</a>
<a name="ln241">  }</a>
<a name="ln242"> </a>
<a name="ln243">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_CTRL) {</a>
<a name="ln244">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;C-&quot;);</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  if (key-&gt;modifiers &amp; TERMKEY_KEYMOD_ALT) {</a>
<a name="ln248">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;A-&quot;);</a>
<a name="ln249">  }</a>
<a name="ln250"> </a>
<a name="ln251">  if (button == 1) {</a>
<a name="ln252">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Left&quot;);</a>
<a name="ln253">  } else if (button == 2) {</a>
<a name="ln254">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Middle&quot;);</a>
<a name="ln255">  } else if (button == 3) {</a>
<a name="ln256">    len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Right&quot;);</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  switch (ev) {</a>
<a name="ln260">    case TERMKEY_MOUSE_PRESS:</a>
<a name="ln261">      if (button == 4) {</a>
<a name="ln262">        len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;ScrollWheelUp&quot;);</a>
<a name="ln263">      } else if (button == 5) {</a>
<a name="ln264">        len += (size_t)snprintf(buf + len, sizeof(buf) - len,</a>
<a name="ln265">                                &quot;ScrollWheelDown&quot;);</a>
<a name="ln266">      } else {</a>
<a name="ln267">        len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Mouse&quot;);</a>
<a name="ln268">        last_pressed_button = button;</a>
<a name="ln269">      }</a>
<a name="ln270">      break;</a>
<a name="ln271">    case TERMKEY_MOUSE_DRAG:</a>
<a name="ln272">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Drag&quot;);</a>
<a name="ln273">      break;</a>
<a name="ln274">    case TERMKEY_MOUSE_RELEASE:</a>
<a name="ln275">      len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;Release&quot;);</a>
<a name="ln276">      break;</a>
<a name="ln277">    case TERMKEY_MOUSE_UNKNOWN:</a>
<a name="ln278">      assert(false);</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  len += (size_t)snprintf(buf + len, sizeof(buf) - len, &quot;&gt;&lt;%d,%d&gt;&quot;, col, row);</a>
<a name="ln282">  tinput_enqueue(input, buf, len);</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">static TermKeyResult tk_getkey(TermKey *tk, TermKeyKey *key, bool force)</a>
<a name="ln286">{</a>
<a name="ln287">  return force ? termkey_getkey_force(tk, key) : termkey_getkey(tk, key);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">static void tinput_timer_cb(TimeWatcher *watcher, void *data);</a>
<a name="ln291"> </a>
<a name="ln292">static void tk_getkeys(TermInput *input, bool force)</a>
<a name="ln293">{</a>
<a name="ln294">  TermKeyKey key;</a>
<a name="ln295">  TermKeyResult result;</a>
<a name="ln296"> </a>
<a name="ln297">  while ((result = tk_getkey(input-&gt;tk, &amp;key, force)) == TERMKEY_RES_KEY) {</a>
<a name="ln298">    if (key.type == TERMKEY_TYPE_UNICODE &amp;&amp; !key.modifiers) {</a>
<a name="ln299">      forward_simple_utf8(input, &amp;key);</a>
<a name="ln300">    } else if (key.type == TERMKEY_TYPE_UNICODE</a>
<a name="ln301">               || key.type == TERMKEY_TYPE_FUNCTION</a>
<a name="ln302">               || key.type == TERMKEY_TYPE_KEYSYM) {</a>
<a name="ln303">      forward_modified_utf8(input, &amp;key);</a>
<a name="ln304">    } else if (key.type == TERMKEY_TYPE_MOUSE) {</a>
<a name="ln305">      forward_mouse_event(input, &amp;key);</a>
<a name="ln306">    }</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  if (result != TERMKEY_RES_AGAIN) {</a>
<a name="ln310">    return;</a>
<a name="ln311">  }</a>
<a name="ln312">  // else: Partial keypress event was found in the buffer, but it does not</a>
<a name="ln313">  // yet contain all the bytes required. `key` structure indicates what</a>
<a name="ln314">  // termkey_getkey_force() would return.</a>
<a name="ln315"> </a>
<a name="ln316">  if (input-&gt;ttimeout &amp;&amp; input-&gt;ttimeoutlen &gt;= 0) {</a>
<a name="ln317">    // Stop the current timer if already running</a>
<a name="ln318">    time_watcher_stop(&amp;input-&gt;timer_handle);</a>
<a name="ln319">    time_watcher_start(&amp;input-&gt;timer_handle, tinput_timer_cb,</a>
<a name="ln320">                       (uint64_t)input-&gt;ttimeoutlen, 0);</a>
<a name="ln321">  } else {</a>
<a name="ln322">    tk_getkeys(input, true);</a>
<a name="ln323">  }</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">static void tinput_timer_cb(TimeWatcher *watcher, void *data)</a>
<a name="ln327">{</a>
<a name="ln328">  tk_getkeys(data, true);</a>
<a name="ln329">  tinput_flush(data, true);</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">/// Handle focus events.</a>
<a name="ln333">///</a>
<a name="ln334">/// If the upcoming sequence of bytes in the input stream matches the termcode</a>
<a name="ln335">/// for &quot;focus gained&quot; or &quot;focus lost&quot;, consume that sequence and schedule an</a>
<a name="ln336">/// event on the main loop.</a>
<a name="ln337">///</a>
<a name="ln338">/// @param input the input stream</a>
<a name="ln339">/// @return true iff handle_focus_event consumed some input</a>
<a name="ln340">static bool handle_focus_event(TermInput *input)</a>
<a name="ln341">{</a>
<a name="ln342">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt; 2</a>
<a name="ln343">      &amp;&amp; (!rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[I&quot;, 3)</a>
<a name="ln344">          || !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[O&quot;, 3))) {</a>
<a name="ln345">    bool focus_gained = *rbuffer_get(input-&gt;read_stream.buffer, 2) == 'I';</a>
<a name="ln346">    // Advance past the sequence</a>
<a name="ln347">    rbuffer_consumed(input-&gt;read_stream.buffer, 3);</a>
<a name="ln348">    aucmd_schedule_focusgained(focus_gained);</a>
<a name="ln349">    return true;</a>
<a name="ln350">  }</a>
<a name="ln351">  return false;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">static bool handle_bracketed_paste(TermInput *input)</a>
<a name="ln355">{</a>
<a name="ln356">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt; 5</a>
<a name="ln357">      &amp;&amp; (!rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[200~&quot;, 6)</a>
<a name="ln358">          || !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b[201~&quot;, 6))) {</a>
<a name="ln359">    bool enable = *rbuffer_get(input-&gt;read_stream.buffer, 4) == '0';</a>
<a name="ln360">    if (input-&gt;paste &amp;&amp; enable) {</a>
<a name="ln361">      return false;  // Pasting &quot;start paste&quot; code literally.</a>
<a name="ln362">    }</a>
<a name="ln363">    // Advance past the sequence</a>
<a name="ln364">    rbuffer_consumed(input-&gt;read_stream.buffer, 6);</a>
<a name="ln365">    if (!!input-&gt;paste == enable) {</a>
<a name="ln366">      return true;  // Spurious &quot;disable paste&quot; code.</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    if (enable) {</a>
<a name="ln370">      // Flush before starting paste.</a>
<a name="ln371">      tinput_flush(input, true);</a>
<a name="ln372">      // Paste phase: &quot;first-chunk&quot;.</a>
<a name="ln373">      input-&gt;paste = 1;</a>
<a name="ln374">    } else if (input-&gt;paste) {</a>
<a name="ln375">      // Paste phase: &quot;last-chunk&quot;.</a>
<a name="ln376">      input-&gt;paste = input-&gt;paste == 2 ? 3 : -1;</a>
<a name="ln377">      tinput_flush(input, true);</a>
<a name="ln378">      // Paste phase: &quot;disabled&quot;.</a>
<a name="ln379">      input-&gt;paste = 0;</a>
<a name="ln380">    }</a>
<a name="ln381">    return true;</a>
<a name="ln382">  }</a>
<a name="ln383">  return false;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">// ESC NUL =&gt; &lt;Esc&gt;</a>
<a name="ln387">static bool handle_forced_escape(TermInput *input)</a>
<a name="ln388">{</a>
<a name="ln389">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt; 1</a>
<a name="ln390">      &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b\x00&quot;, 2)) {</a>
<a name="ln391">    // skip the ESC and NUL and push one &lt;esc&gt; to the input buffer</a>
<a name="ln392">    size_t rcnt;</a>
<a name="ln393">    termkey_push_bytes(input-&gt;tk, rbuffer_read_ptr(input-&gt;read_stream.buffer,</a>
<a name="ln394">          &amp;rcnt), 1);</a>
<a name="ln395">    rbuffer_consumed(input-&gt;read_stream.buffer, 2);</a>
<a name="ln396">    tk_getkeys(input, true);</a>
<a name="ln397">    return true;</a>
<a name="ln398">  }</a>
<a name="ln399">  return false;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static void set_bg_deferred(void **argv)</a>
<a name="ln403">{</a>
<a name="ln404">  char *bgvalue = argv[0];</a>
<a name="ln405">  if (!option_was_set(&quot;bg&quot;) &amp;&amp; !strequal((char *)p_bg, bgvalue)) {</a>
<a name="ln406">    // Value differs, apply it.</a>
<a name="ln407">    if (starting) {</a>
<a name="ln408">      // Wait until after startup, so OptionSet is triggered.</a>
<a name="ln409">      do_cmdline_cmd((bgvalue[0] == 'l')</a>
<a name="ln410">                     ? &quot;autocmd VimEnter * ++once ++nested set bg=light&quot;</a>
<a name="ln411">                     : &quot;autocmd VimEnter * ++once ++nested set bg=dark&quot;);</a>
<a name="ln412">    } else {</a>
<a name="ln413">      set_option_value(&quot;bg&quot;, 0L, bgvalue, 0);</a>
<a name="ln414">      reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln415">    }</a>
<a name="ln416">  }</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">// During startup, tui.c requests the background color (see `ext.get_bg`).</a>
<a name="ln420">//</a>
<a name="ln421">// Here in input.c, we watch for the terminal response `\e]11;COLOR\a`.  If</a>
<a name="ln422">// COLOR matches `rgb:RRRR/GGGG/BBBB/AAAA` where R, G, B, and A are hex digits,</a>
<a name="ln423">// then compute the luminance[1] of the RGB color and classify it as light/dark</a>
<a name="ln424">// accordingly. Note that the color components may have anywhere from one to</a>
<a name="ln425">// four hex digits, and require scaling accordingly as values out of 4, 8, 12,</a>
<a name="ln426">// or 16 bits. Also note the A(lpha) component is optional, and is parsed but</a>
<a name="ln427">// ignored in the calculations.</a>
<a name="ln428">//</a>
<a name="ln429">// [1] https://en.wikipedia.org/wiki/Luma_%28video%29</a>
<a name="ln430">static bool handle_background_color(TermInput *input)</a>
<a name="ln431">{</a>
<a name="ln432">  if (input-&gt;waiting_for_bg_response &lt;= 0) {</a>
<a name="ln433">    return false;</a>
<a name="ln434">  }</a>
<a name="ln435">  size_t count = 0;</a>
<a name="ln436">  size_t component = 0;</a>
<a name="ln437">  size_t header_size = 0;</a>
<a name="ln438">  size_t num_components = 0;</a>
<a name="ln439">  uint16_t rgb[] = { 0, 0, 0 };</a>
<a name="ln440">  uint16_t rgb_max[] = { 0, 0, 0 };</a>
<a name="ln441">  bool eat_backslash = false;</a>
<a name="ln442">  bool done = false;</a>
<a name="ln443">  bool bad = false;</a>
<a name="ln444">  if (rbuffer_size(input-&gt;read_stream.buffer) &gt;= 9</a>
<a name="ln445">      &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b]11;rgb:&quot;, 9)) {</a>
<a name="ln446">    header_size = 9;</a>
<a name="ln447">    num_components = 3;</a>
<a name="ln448">  } else if (rbuffer_size(input-&gt;read_stream.buffer) &gt;= 10</a>
<a name="ln449">             &amp;&amp; !rbuffer_cmp(input-&gt;read_stream.buffer, &quot;\x1b]11;rgba:&quot;, 10)) {</a>
<a name="ln450">    header_size = 10;</a>
<a name="ln451">    num_components = 4;</a>
<a name="ln452">  } else {</a>
<a name="ln453">    input-&gt;waiting_for_bg_response--;</a>
<a name="ln454">    if (input-&gt;waiting_for_bg_response == 0) {</a>
<a name="ln455">      DLOG(&quot;did not get a response for terminal background query&quot;);</a>
<a name="ln456">    }</a>
<a name="ln457">    return false;</a>
<a name="ln458">  }</a>
<a name="ln459">  input-&gt;waiting_for_bg_response = 0;</a>
<a name="ln460">  rbuffer_consumed(input-&gt;read_stream.buffer, header_size);</a>
<a name="ln461">  RBUFFER_EACH(input-&gt;read_stream.buffer, c, i) {</a>
<a name="ln462">    count = i + 1;</a>
<a name="ln463">    if (eat_backslash) {</a>
<a name="ln464">      done = true;</a>
<a name="ln465">      break;</a>
<a name="ln466">    } else if (c == '\x07') {</a>
<a name="ln467">      done = true;</a>
<a name="ln468">      break;</a>
<a name="ln469">    } else if (c == '\x1b') {</a>
<a name="ln470">      eat_backslash = true;</a>
<a name="ln471">    } else if (bad) {</a>
<a name="ln472">      // ignore</a>
<a name="ln473">    } else if ((c == '/') &amp;&amp; (++component &lt; num_components)) {</a>
<a name="ln474">      // work done in condition</a>
<a name="ln475">    } else if (ascii_isxdigit(c)) {</a>
<a name="ln476">      if (component &lt; 3 &amp;&amp; rgb_max[component] != 0xffff) {</a>
<a name="ln477">        rgb_max[component] = (uint16_t)((rgb_max[component] &lt;&lt; 4) | 0xf);</a>
<a name="ln478">        rgb[component] = (uint16_t)((rgb[component] &lt;&lt; 4) | hex2nr(c));</a>
<a name="ln479">      }</a>
<a name="ln480">    } else {</a>
<a name="ln481">      bad = true;</a>
<a name="ln482">    }</a>
<a name="ln483">  }</a>
<a name="ln484">  rbuffer_consumed(input-&gt;read_stream.buffer, count);</a>
<a name="ln485">  if (done &amp;&amp; !bad &amp;&amp; rgb_max[0] &amp;&amp; rgb_max[1] &amp;&amp; rgb_max[2]) {</a>
<a name="ln486">    double r = (double)rgb[0] / (double)rgb_max[0];</a>
<a name="ln487">    double g = (double)rgb[1] / (double)rgb_max[1];</a>
<a name="ln488">    double b = (double)rgb[2] / (double)rgb_max[2];</a>
<a name="ln489">    double luminance = (0.299 * r) + (0.587 * g) + (0.114 * b);  // CCIR 601</a>
<a name="ln490">    char *bgvalue = luminance &lt; 0.5 ? &quot;dark&quot; : &quot;light&quot;;</a>
<a name="ln491">    DLOG(&quot;bg response: %s&quot;, bgvalue);</a>
<a name="ln492">    loop_schedule_deferred(&amp;main_loop,</a>
<a name="ln493">                           event_create(set_bg_deferred, 1, bgvalue));</a>
<a name="ln494">  } else {</a>
<a name="ln495">    DLOG(&quot;failed to parse bg response&quot;);</a>
<a name="ln496">    return false;</a>
<a name="ln497">  }</a>
<a name="ln498">  return true;</a>
<a name="ln499">}</a>
<a name="ln500">#ifdef UNIT_TESTING</a>
<a name="ln501">bool ut_handle_background_color(TermInput *input)</a>
<a name="ln502">{</a>
<a name="ln503">  return handle_background_color(input);</a>
<a name="ln504">}</a>
<a name="ln505">#endif</a>
<a name="ln506"> </a>
<a name="ln507">static void tinput_read_cb(Stream *stream, RBuffer *buf, size_t count_,</a>
<a name="ln508">                           void *data, bool eof)</a>
<a name="ln509">{</a>
<a name="ln510">  TermInput *input = data;</a>
<a name="ln511"> </a>
<a name="ln512">  if (eof) {</a>
<a name="ln513">    loop_schedule_fast(&amp;main_loop, event_create(tinput_done_event, 0));</a>
<a name="ln514">    return;</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  do {</a>
<a name="ln518">    if (handle_focus_event(input)</a>
<a name="ln519">        || handle_bracketed_paste(input)</a>
<a name="ln520">        || handle_forced_escape(input)</a>
<a name="ln521">        || handle_background_color(input)) {</a>
<a name="ln522">      continue;</a>
<a name="ln523">    }</a>
<a name="ln524"> </a>
<a name="ln525">    //</a>
<a name="ln526">    // Find the next ESC and push everything up to it (excluding), so it will</a>
<a name="ln527">    // be the first thing encountered on the next iteration. The `handle_*`</a>
<a name="ln528">    // calls (above) depend on this.</a>
<a name="ln529">    //</a>
<a name="ln530">    size_t count = 0;</a>
<a name="ln531">    RBUFFER_EACH(input-&gt;read_stream.buffer, c, i) {</a>
<a name="ln532">      count = i + 1;</a>
<a name="ln533">      if (c == '\x1b' &amp;&amp; count &gt; 1) {</a>
<a name="ln534">        count--;</a>
<a name="ln535">        break;</a>
<a name="ln536">      }</a>
<a name="ln537">    }</a>
<a name="ln538">    // Push bytes directly (paste).</a>
<a name="ln539">    if (input-&gt;paste) {</a>
<a name="ln540">      RBUFFER_UNTIL_EMPTY(input-&gt;read_stream.buffer, ptr, len) {</a>
<a name="ln541">        size_t consumed = MIN(count, len);</a>
<a name="ln542">        assert(consumed &lt;= input-&gt;read_stream.buffer-&gt;size);</a>
<a name="ln543">        tinput_enqueue(input, ptr, consumed);</a>
<a name="ln544">        rbuffer_consumed(input-&gt;read_stream.buffer, consumed);</a>
<a name="ln545">        if (!(count -= consumed)) {</a>
<a name="ln546">          break;</a>
<a name="ln547">        }</a>
<a name="ln548">      }</a>
<a name="ln549">      continue;</a>
<a name="ln550">    }</a>
<a name="ln551">    // Push through libtermkey (translates to &quot;&lt;keycode&gt;&quot; strings, etc.).</a>
<a name="ln552">    RBUFFER_UNTIL_EMPTY(input-&gt;read_stream.buffer, ptr, len) {</a>
<a name="ln553">      size_t consumed = termkey_push_bytes(input-&gt;tk, ptr, MIN(count, len));</a>
<a name="ln554">      // termkey_push_bytes can return (size_t)-1, so it is possible that</a>
<a name="ln555">      // `consumed &gt; input-&gt;read_stream.buffer-&gt;size`, but since tk_getkeys is</a>
<a name="ln556">      // called soon, it shouldn't happen.</a>
<a name="ln557">      assert(consumed &lt;= input-&gt;read_stream.buffer-&gt;size);</a>
<a name="ln558">      rbuffer_consumed(input-&gt;read_stream.buffer, consumed);</a>
<a name="ln559">      // Process the keys now: there is no guarantee `count` will</a>
<a name="ln560">      // fit into libtermkey's input buffer.</a>
<a name="ln561">      tk_getkeys(input, false);</a>
<a name="ln562">      if (!(count -= consumed)) {</a>
<a name="ln563">        break;</a>
<a name="ln564">      }</a>
<a name="ln565">    }</a>
<a name="ln566">  } while (rbuffer_size(input-&gt;read_stream.buffer));</a>
<a name="ln567">  tinput_flush(input, true);</a>
<a name="ln568">  // Make sure the next input escape sequence fits into the ring buffer without</a>
<a name="ln569">  // wraparound, else it could be misinterpreted (because rbuffer_read_ptr()</a>
<a name="ln570">  // exposes the underlying buffer to callers unaware of the wraparound).</a>
<a name="ln571">  rbuffer_reset(input-&gt;read_stream.buffer);</a>
<a name="ln572">}</a>

</code></pre>
<div class="balloon" rel="540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1044/" target="_blank">V1044</a> Loop break conditions do not depend on the number of iterations.</p></div>
<div class="balloon" rel="552"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1044/" target="_blank">V1044</a> Loop break conditions do not depend on the number of iterations.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

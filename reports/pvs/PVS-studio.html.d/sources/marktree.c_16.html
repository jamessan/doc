
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>marktree.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Tree data structure for storing marks at (row, col) positions and updating</a>
<a name="ln5">// them to arbitrary text changes. Derivative work of kbtree in klib, whose</a>
<a name="ln6">// copyright notice is reproduced below. Also inspired by the design of the</a>
<a name="ln7">// marker tree data structure of the Atom editor, regarding efficient updates</a>
<a name="ln8">// to text changes.</a>
<a name="ln9">//</a>
<a name="ln10">// Marks are inserted using marktree_put. Text changes are processed using</a>
<a name="ln11">// marktree_splice. All read and delete operations use the iterator.</a>
<a name="ln12">// use marktree_itr_get to put an iterator at a given position or</a>
<a name="ln13">// marktree_lookup to lookup a mark by its id (iterator optional in this case).</a>
<a name="ln14">// Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.</a>
<a name="ln15">// marktree_del_itr deletes the current mark of the iterator and implicitly</a>
<a name="ln16">// moves the iterator to the next mark.</a>
<a name="ln17">//</a>
<a name="ln18">// Work is ongoing to fully support ranges (mark pairs).</a>
<a name="ln19"> </a>
<a name="ln20">// Copyright notice for kbtree (included in heavily modified form):</a>
<a name="ln21">//</a>
<a name="ln22">// Copyright 1997-1999, 2001, John-Mark Gurney.</a>
<a name="ln23">//           2008-2009, Attractive Chaos &lt;attractor@live.co.uk&gt;</a>
<a name="ln24">//</a>
<a name="ln25">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln26">// modification, are permitted provided that the following conditions</a>
<a name="ln27">// are met:</a>
<a name="ln28">//</a>
<a name="ln29">// 1. Redistributions of source code must retain the above copyright</a>
<a name="ln30">//    notice, this list of conditions and the following disclaimer.</a>
<a name="ln31">// 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln32">//    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln33">//    documentation and/or other materials provided with the distribution.</a>
<a name="ln34">//</a>
<a name="ln35">// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln36">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln37">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln38">// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln39">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln40">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln41">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln42">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln43">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln44">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln45">// SUCH DAMAGE.</a>
<a name="ln46">//</a>
<a name="ln47">// Changes done by by the neovim project follow the Apache v2 license available</a>
<a name="ln48">// at the repo root.</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;assert.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;nvim/marktree.h&quot;</a>
<a name="ln53">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln54">#include &quot;nvim/garray.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#define T MT_BRANCH_FACTOR</a>
<a name="ln57">#define ILEN (sizeof(mtnode_t)+(2 * T) * sizeof(void *))</a>
<a name="ln58">#define key_t SKRAPET</a>
<a name="ln59"> </a>
<a name="ln60">#define RIGHT_GRAVITY (((uint64_t)1) &lt;&lt; 63)</a>
<a name="ln61">#define ANTIGRAVITY(id) ((id)&amp;(RIGHT_GRAVITY-1))</a>
<a name="ln62">#define IS_RIGHT(id) ((id)&amp;RIGHT_GRAVITY)</a>
<a name="ln63"> </a>
<a name="ln64">#define PAIRED MARKTREE_PAIRED_FLAG</a>
<a name="ln65">#define END_FLAG MARKTREE_END_FLAG</a>
<a name="ln66">#define ID_INCR (((uint64_t)1) &lt;&lt; 2)</a>
<a name="ln67"> </a>
<a name="ln68">#define PROP_MASK (RIGHT_GRAVITY|PAIRED|END_FLAG)</a>
<a name="ln69"> </a>
<a name="ln70">#define rawkey(itr) (itr-&gt;node-&gt;key[itr-&gt;i])</a>
<a name="ln71"> </a>
<a name="ln72">static bool pos_leq(mtpos_t a, mtpos_t b)</a>
<a name="ln73">{</a>
<a name="ln74">  return a.row &lt; b.row || (a.row == b.row &amp;&amp; a.col &lt;= b.col);</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">static void relative(mtpos_t base, mtpos_t *val)</a>
<a name="ln78">{</a>
<a name="ln79">  assert(pos_leq(base, *val));</a>
<a name="ln80">  if (val-&gt;row == base.row) {</a>
<a name="ln81">    val-&gt;row = 0;</a>
<a name="ln82">    val-&gt;col -= base.col;</a>
<a name="ln83">  } else {</a>
<a name="ln84">    val-&gt;row -= base.row;</a>
<a name="ln85">  }</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static void unrelative(mtpos_t base, mtpos_t *val)</a>
<a name="ln89">{</a>
<a name="ln90">  if (val-&gt;row == 0) {</a>
<a name="ln91">    val-&gt;row = base.row;</a>
<a name="ln92">    val-&gt;col += base.col;</a>
<a name="ln93">  } else {</a>
<a name="ln94">    val-&gt;row += base.row;</a>
<a name="ln95">  }</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">static void compose(mtpos_t *base, mtpos_t val)</a>
<a name="ln99">{</a>
<a name="ln100">  if (val.row == 0) {</a>
<a name="ln101">    base-&gt;col += val.col;</a>
<a name="ln102">  } else {</a>
<a name="ln103">    base-&gt;row += val.row;</a>
<a name="ln104">    base-&gt;col = val.col;</a>
<a name="ln105">  }</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln109"># include &quot;marktree.c.generated.h&quot;</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">#define mt_generic_cmp(a, b) (((b) &lt; (a)) - ((a) &lt; (b)))</a>
<a name="ln113">static int key_cmp(mtkey_t a, mtkey_t b)</a>
<a name="ln114">{</a>
<a name="ln115">  int cmp = mt_generic_cmp(a.pos.row, b.pos.row);</a>
<a name="ln116">  if (cmp != 0) {</a>
<a name="ln117">    return cmp;</a>
<a name="ln118">  }</a>
<a name="ln119">  cmp = mt_generic_cmp(a.pos.col, b.pos.col);</a>
<a name="ln120">  if (cmp != 0) {</a>
<a name="ln121">    return cmp;</a>
<a name="ln122">  }</a>
<a name="ln123">  // NB: keeping the events at the same pos sorted by id is actually not</a>
<a name="ln124">  // necessary only make sure that START is before END etc.</a>
<a name="ln125">  return mt_generic_cmp(a.id, b.id);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static inline int marktree_getp_aux(const mtnode_t *x, mtkey_t k, int *r)</a>
<a name="ln129">{</a>
<a name="ln130">  int tr, *rr, begin = 0, end = x-&gt;n;</a>
<a name="ln131">  if (x-&gt;n == 0) {</a>
<a name="ln132">    return -1;</a>
<a name="ln133">  }</a>
<a name="ln134">  rr = r? r : &amp;tr;</a>
<a name="ln135">  while (begin &lt; end) {</a>
<a name="ln136">    int mid = (begin + end) &gt;&gt; 1;</a>
<a name="ln137">    if (key_cmp(x-&gt;key[mid], k) &lt; 0) {</a>
<a name="ln138">      begin = mid + 1;</a>
<a name="ln139">    } else {</a>
<a name="ln140">      end = mid;</a>
<a name="ln141">    }</a>
<a name="ln142">  }</a>
<a name="ln143">  if (begin == x-&gt;n) { *rr = 1; return x-&gt;n - 1; }</a>
<a name="ln144">  if ((*rr = key_cmp(k, x-&gt;key[begin])) &lt; 0) {</a>
<a name="ln145">    begin--;</a>
<a name="ln146">  }</a>
<a name="ln147">  return begin;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static inline void refkey(MarkTree *b, mtnode_t *x, int i)</a>
<a name="ln151">{</a>
<a name="ln152">  pmap_put(uint64_t)(b-&gt;id2node, ANTIGRAVITY(x-&gt;key[i].id), x);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">// put functions</a>
<a name="ln156"> </a>
<a name="ln157">// x must be an internal node, which is not full</a>
<a name="ln158">// x-&gt;ptr[i] should be a full node, i e x-&gt;ptr[i]-&gt;n == 2*T-1</a>
<a name="ln159">static inline void split_node(MarkTree *b, mtnode_t *x, const int i)</a>
<a name="ln160">{</a>
<a name="ln161">  mtnode_t *y = x-&gt;ptr[i];</a>
<a name="ln162">  mtnode_t *z;</a>
<a name="ln163">  z = (mtnode_t *)xcalloc(1, y-&gt;level ? ILEN : sizeof(mtnode_t));</a>
<a name="ln164">  b-&gt;n_nodes++;</a>
<a name="ln165">  z-&gt;level = y-&gt;level;</a>
<a name="ln166">  z-&gt;n = T - 1;</a>
<a name="ln167">  memcpy(z-&gt;key, &amp;y-&gt;key[T], sizeof(mtkey_t) * (T - 1));</a>
<a name="ln168">  for (int j = 0; j &lt; T-1; j++) {</a>
<a name="ln169">    refkey(b, z, j);</a>
<a name="ln170">  }</a>
<a name="ln171">  if (y-&gt;level) {</a>
<a name="ln172">    memcpy(z-&gt;ptr, &amp;y-&gt;ptr[T], sizeof(mtnode_t *) * T);</a>
<a name="ln173">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln174">      z-&gt;ptr[j]-&gt;parent = z;</a>
<a name="ln175">    }</a>
<a name="ln176">  }</a>
<a name="ln177">  y-&gt;n = T - 1;</a>
<a name="ln178">  memmove(&amp;x-&gt;ptr[i + 2], &amp;x-&gt;ptr[i + 1],</a>
<a name="ln179">          sizeof(mtnode_t *) * (size_t)(x-&gt;n - i));</a>
<a name="ln180">  x-&gt;ptr[i + 1] = z;</a>
<a name="ln181">  z-&gt;parent = x;  // == y-&gt;parent</a>
<a name="ln182">  memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i], sizeof(mtkey_t) * (size_t)(x-&gt;n - i));</a>
<a name="ln183"> </a>
<a name="ln184">  // move key to internal layer:</a>
<a name="ln185">  x-&gt;key[i] = y-&gt;key[T - 1];</a>
<a name="ln186">  refkey(b, x, i);</a>
<a name="ln187">  x-&gt;n++;</a>
<a name="ln188"> </a>
<a name="ln189">  for (int j = 0; j &lt; T-1; j++) {</a>
<a name="ln190">    relative(x-&gt;key[i].pos, &amp;z-&gt;key[j].pos);</a>
<a name="ln191">  }</a>
<a name="ln192">  if (i &gt; 0) {</a>
<a name="ln193">    unrelative(x-&gt;key[i-1].pos, &amp;x-&gt;key[i].pos);</a>
<a name="ln194">  }</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">// x must not be a full node (even if there might be internal space)</a>
<a name="ln198">static inline void marktree_putp_aux(MarkTree *b, mtnode_t *x, mtkey_t k)</a>
<a name="ln199">{</a>
<a name="ln200">  int i;</a>
<a name="ln201">  if (x-&gt;level == 0) {</a>
<a name="ln202">    i = marktree_getp_aux(x, k, 0);</a>
<a name="ln203">    if (i != x-&gt;n - 1) {</a>
<a name="ln204">      memmove(&amp;x-&gt;key[i + 2], &amp;x-&gt;key[i + 1],</a>
<a name="ln205">              (size_t)(x-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln206">    }</a>
<a name="ln207">    x-&gt;key[i + 1] = k;</a>
<a name="ln208">    refkey(b, x, i+1);</a>
<a name="ln209">    x-&gt;n++;</a>
<a name="ln210">  } else {</a>
<a name="ln211">    i = marktree_getp_aux(x, k, 0) + 1;</a>
<a name="ln212">    if (x-&gt;ptr[i]-&gt;n == 2 * T - 1) {</a>
<a name="ln213">      split_node(b, x, i);</a>
<a name="ln214">      if (key_cmp(k, x-&gt;key[i]) &gt; 0) {</a>
<a name="ln215">        i++;</a>
<a name="ln216">      }</a>
<a name="ln217">    }</a>
<a name="ln218">    if (i &gt; 0) {</a>
<a name="ln219">      relative(x-&gt;key[i-1].pos, &amp;k.pos);</a>
<a name="ln220">    }</a>
<a name="ln221">    marktree_putp_aux(b, x-&gt;ptr[i], k);</a>
<a name="ln222">  }</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">uint64_t marktree_put(MarkTree *b, int row, int col, bool right_gravity)</a>
<a name="ln226">{</a>
<a name="ln227">  uint64_t id = (b-&gt;next_id+=ID_INCR);</a>
<a name="ln228">  uint64_t keyid = id;</a>
<a name="ln229">  if (right_gravity) {</a>
<a name="ln230">    // order all right gravity keys after the left ones, for effortless</a>
<a name="ln231">    // insertion (but not deletion!)</a>
<a name="ln232">    keyid |= RIGHT_GRAVITY;</a>
<a name="ln233">  }</a>
<a name="ln234">  marktree_put_key(b, row, col, keyid);</a>
<a name="ln235">  return id;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">uint64_t marktree_put_pair(MarkTree *b,</a>
<a name="ln239">                           int start_row, int start_col, bool start_right,</a>
<a name="ln240">                           int end_row, int end_col, bool end_right)</a>
<a name="ln241">{</a>
<a name="ln242">  uint64_t id = (b-&gt;next_id+=ID_INCR)|PAIRED;</a>
<a name="ln243">  uint64_t start_id = id|(start_right?RIGHT_GRAVITY:0);</a>
<a name="ln244">  uint64_t end_id = id|END_FLAG|(end_right?RIGHT_GRAVITY:0);</a>
<a name="ln245">  marktree_put_key(b, start_row, start_col, start_id);</a>
<a name="ln246">  marktree_put_key(b, end_row, end_col, end_id);</a>
<a name="ln247">  return id;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">void marktree_put_key(MarkTree *b, int row, int col, uint64_t id)</a>
<a name="ln251">{</a>
<a name="ln252">  mtkey_t k = { .pos = { .row = row, .col = col }, .id = id };</a>
<a name="ln253"> </a>
<a name="ln254">  if (!b-&gt;root) {</a>
<a name="ln255">    b-&gt;root = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln256">    b-&gt;id2node = pmap_new(uint64_t)();</a>
<a name="ln257">    b-&gt;n_nodes++;</a>
<a name="ln258">  }</a>
<a name="ln259">  mtnode_t *r, *s;</a>
<a name="ln260">  b-&gt;n_keys++;</a>
<a name="ln261">  r = b-&gt;root;</a>
<a name="ln262">  if (r-&gt;n == 2 * T - 1) {</a>
<a name="ln263">    b-&gt;n_nodes++;</a>
<a name="ln264">    s = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln265">    b-&gt;root = s; s-&gt;level = r-&gt;level+1; s-&gt;n = 0;</a>
<a name="ln266">    s-&gt;ptr[0] = r;</a>
<a name="ln267">    r-&gt;parent = s;</a>
<a name="ln268">    split_node(b, s, 0);</a>
<a name="ln269">    r = s;</a>
<a name="ln270">  }</a>
<a name="ln271">  marktree_putp_aux(b, r, k);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">/// INITIATING DELETION PROTOCOL:</a>
<a name="ln275">///</a>
<a name="ln276">/// 1. Construct a valid iterator to the node to delete (argument)</a>
<a name="ln277">/// 2. If an &quot;internal&quot; key. Iterate one step to the left or right,</a>
<a name="ln278">///     which gives an internal key &quot;auxiliary key&quot;.</a>
<a name="ln279">/// 3. Now delete this internal key (intended or auxiliary).</a>
<a name="ln280">///    The leaf node X might become undersized.</a>
<a name="ln281">/// 4. If step two was done: now replace the key that _should_ be</a>
<a name="ln282">///    deleted with the auxiliary key. Adjust relative</a>
<a name="ln283">/// 5. Now &quot;repair&quot; the tree as needed. We always start at a leaf node X.</a>
<a name="ln284">///     - if the node is big enough, terminate</a>
<a name="ln285">///     - if we can steal from the left, steal</a>
<a name="ln286">///     - if we can steal from the right, steal</a>
<a name="ln287">///     - otherwise merge this node with a neighbour. This might make our</a>
<a name="ln288">///       parent undersized. So repeat 5 for the parent.</a>
<a name="ln289">/// 6. If 4 went all the way to the root node. The root node</a>
<a name="ln290">///    might have ended up with size 0. Delete it then.</a>
<a name="ln291">///</a>
<a name="ln292">/// NB: ideally keeps the iterator valid. Like point to the key after this</a>
<a name="ln293">/// if present.</a>
<a name="ln294">///</a>
<a name="ln295">/// @param rev should be true if we plan to iterate _backwards_ and delete</a>
<a name="ln296">///            stuff before this key. Most of the time this is false (the</a>
<a name="ln297">///            recommended strategy is to always iterate forward)</a>
<a name="ln298">void marktree_del_itr(MarkTree *b, MarkTreeIter *itr, bool rev)</a>
<a name="ln299">{</a>
<a name="ln300">  int adjustment = 0;</a>
<a name="ln301"> </a>
<a name="ln302">  mtnode_t *cur = itr-&gt;node;</a>
<a name="ln303">  int curi = itr-&gt;i;</a>
<a name="ln304">  uint64_t id = cur-&gt;key[curi].id;</a>
<a name="ln305">  // fprintf(stderr, &quot;\nDELET %lu\n&quot;, id);</a>
<a name="ln306"> </a>
<a name="ln307">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln308">    if (rev) {</a>
<a name="ln309">      abort();</a>
<a name="ln310">    } else {</a>
<a name="ln311">      // fprintf(stderr, &quot;INTERNAL %d\n&quot;, cur-&gt;level);</a>
<a name="ln312">      // steal previous node</a>
<a name="ln313">      marktree_itr_prev(b, itr);</a>
<a name="ln314">      adjustment = -1;</a>
<a name="ln315">    }</a>
<a name="ln316">  }</a>
<a name="ln317"> </a>
<a name="ln318">  // 3.</a>
<a name="ln319">  mtnode_t *x = itr-&gt;node;</a>
<a name="ln320">  assert(x-&gt;level == 0);</a>
<a name="ln321">  mtkey_t intkey = x-&gt;key[itr-&gt;i];</a>
<a name="ln322">  if (x-&gt;n &gt; itr-&gt;i+1) {</a>
<a name="ln323">    memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i+1],</a>
<a name="ln324">            sizeof(mtkey_t) * (size_t)(x-&gt;n - itr-&gt;i-1));</a>
<a name="ln325">  }</a>
<a name="ln326">  x-&gt;n--;</a>
<a name="ln327"> </a>
<a name="ln328">  // 4.</a>
<a name="ln329">  // if (adjustment == 1) {</a>
<a name="ln330">  //   abort();</a>
<a name="ln331">  // }</a>
<a name="ln332">  if (adjustment == -1) {</a>
<a name="ln333">    int ilvl = itr-&gt;lvl-1;</a>
<a name="ln334">    const mtnode_t *lnode = x;</a>
<a name="ln335">    do {</a>
<a name="ln336">      const mtnode_t *const p = lnode-&gt;parent;</a>
<a name="ln337">      if (ilvl &lt; 0) {</a>
<a name="ln338">        abort();</a>
<a name="ln339">      }</a>
<a name="ln340">      const int i = itr-&gt;s[ilvl].i;</a>
<a name="ln341">      assert(p-&gt;ptr[i] == lnode);</a>
<a name="ln342">      if (i &gt; 0) {</a>
<a name="ln343">        unrelative(p-&gt;key[i-1].pos, &amp;intkey.pos);</a>
<a name="ln344">      }</a>
<a name="ln345">      lnode = p;</a>
<a name="ln346">      ilvl--;</a>
<a name="ln347">    } while (lnode != cur);</a>
<a name="ln348"> </a>
<a name="ln349">    mtkey_t deleted = cur-&gt;key[curi];</a>
<a name="ln350">    cur-&gt;key[curi] = intkey;</a>
<a name="ln351">    refkey(b, cur, curi);</a>
<a name="ln352">    relative(intkey.pos, &amp;deleted.pos);</a>
<a name="ln353">    mtnode_t *y = cur-&gt;ptr[curi+1];</a>
<a name="ln354">    if (deleted.pos.row || deleted.pos.col) {</a>
<a name="ln355">      while (y) {</a>
<a name="ln356">        for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln357">          unrelative(deleted.pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln358">        }</a>
<a name="ln359">        y = y-&gt;level ? y-&gt;ptr[0] : NULL;</a>
<a name="ln360">      }</a>
<a name="ln361">    }</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  b-&gt;n_keys--;</a>
<a name="ln365">  pmap_del(uint64_t)(b-&gt;id2node, ANTIGRAVITY(id));</a>
<a name="ln366"> </a>
<a name="ln367">  // 5.</a>
<a name="ln368">  bool itr_dirty = false;</a>
<a name="ln369">  int rlvl = itr-&gt;lvl-1;</a>
<a name="ln370">  int *lasti = &amp;itr-&gt;i;</a>
<a name="ln371">  while (x != b-&gt;root) {</a>
<a name="ln372">    assert(rlvl &gt;= 0);</a>
<a name="ln373">    mtnode_t *p = x-&gt;parent;</a>
<a name="ln374">    if (x-&gt;n &gt;= T-1) {</a>
<a name="ln375">      // we are done, if this node is fine the rest of the tree will be</a>
<a name="ln376">      break;</a>
<a name="ln377">    }</a>
<a name="ln378">    int pi = itr-&gt;s[rlvl].i;</a>
<a name="ln379">    assert(p-&gt;ptr[pi] == x);</a>
<a name="ln380">    if (pi &gt; 0 &amp;&amp; p-&gt;ptr[pi-1]-&gt;n &gt; T-1) {</a>
<a name="ln381">      *lasti += 1;</a>
<a name="ln382">      itr_dirty = true;</a>
<a name="ln383">      // steal one key from the left neighbour</a>
<a name="ln384">      pivot_right(b, p, pi-1);</a>
<a name="ln385">      break;</a>
<a name="ln386">    } else if (pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi+1]-&gt;n &gt; T-1) {</a>
<a name="ln387">      // steal one key from right neighbour</a>
<a name="ln388">      pivot_left(b, p, pi);</a>
<a name="ln389">      break;</a>
<a name="ln390">    } else if (pi &gt; 0) {</a>
<a name="ln391">      // fprintf(stderr, &quot;LEFT &quot;);</a>
<a name="ln392">      assert(p-&gt;ptr[pi-1]-&gt;n == T-1);</a>
<a name="ln393">      // merge with left neighbour</a>
<a name="ln394">      *lasti += T;</a>
<a name="ln395">      x = merge_node(b, p, pi-1);</a>
<a name="ln396">      if (lasti == &amp;itr-&gt;i) {</a>
<a name="ln397">        // TRICKY: we merged the node the iterator was on</a>
<a name="ln398">        itr-&gt;node = x;</a>
<a name="ln399">      }</a>
<a name="ln400">      itr-&gt;s[rlvl].i--;</a>
<a name="ln401">      itr_dirty = true;</a>
<a name="ln402">    } else {</a>
<a name="ln403">      // fprintf(stderr, &quot;RIGHT &quot;);</a>
<a name="ln404">      assert(pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi+1]-&gt;n == T-1);</a>
<a name="ln405">      merge_node(b, p, pi);</a>
<a name="ln406">      // no iter adjustment needed</a>
<a name="ln407">    }</a>
<a name="ln408">    lasti = &amp;itr-&gt;s[rlvl].i;</a>
<a name="ln409">    rlvl--;</a>
<a name="ln410">    x = p;</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  // 6.</a>
<a name="ln414">  if (b-&gt;root-&gt;n == 0) {</a>
<a name="ln415">    if (itr-&gt;lvl &gt; 0) {</a>
<a name="ln416">      memmove(itr-&gt;s, itr-&gt;s+1, (size_t)(itr-&gt;lvl-1) * sizeof(*itr-&gt;s));</a>
<a name="ln417">      itr-&gt;lvl--;</a>
<a name="ln418">    }</a>
<a name="ln419">    if (b-&gt;root-&gt;level) {</a>
<a name="ln420">      mtnode_t *oldroot = b-&gt;root;</a>
<a name="ln421">      b-&gt;root = b-&gt;root-&gt;ptr[0];</a>
<a name="ln422">      b-&gt;root-&gt;parent = NULL;</a>
<a name="ln423">      xfree(oldroot);</a>
<a name="ln424">    } else {</a>
<a name="ln425">      // no items, nothing for iterator to point to</a>
<a name="ln426">      // not strictly needed, should handle delete right-most mark anyway</a>
<a name="ln427">      itr-&gt;node = NULL;</a>
<a name="ln428">    }</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  if (itr-&gt;node &amp;&amp; itr_dirty) {</a>
<a name="ln432">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  // BONUS STEP: fix the iterator, so that it points to the key afterwards</a>
<a name="ln436">  // TODO(bfredl): with &quot;rev&quot; should point before</a>
<a name="ln437">  // if (adjustment == 1) {</a>
<a name="ln438">  //   abort();</a>
<a name="ln439">  // }</a>
<a name="ln440">  if (adjustment == -1) {</a>
<a name="ln441">    // tricky: we stand at the deleted space in the previous leaf node.</a>
<a name="ln442">    // But the inner key is now the previous key we stole, so we need</a>
<a name="ln443">    // to skip that one as well.</a>
<a name="ln444">    marktree_itr_next(b, itr);</a>
<a name="ln445">    marktree_itr_next(b, itr);</a>
<a name="ln446">  } else {</a>
<a name="ln447">    if (itr-&gt;node &amp;&amp; itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln448">      // we deleted the last key of a leaf node</a>
<a name="ln449">      // go to the inner key after that.</a>
<a name="ln450">      assert(itr-&gt;node-&gt;level == 0);</a>
<a name="ln451">      marktree_itr_next(b, itr);</a>
<a name="ln452">    }</a>
<a name="ln453">  }</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">static mtnode_t *merge_node(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln457">{</a>
<a name="ln458">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln459"> </a>
<a name="ln460">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln461">  refkey(b, x, x-&gt;n);</a>
<a name="ln462">  if (i &gt; 0) {</a>
<a name="ln463">    relative(p-&gt;key[i-1].pos, &amp;x-&gt;key[x-&gt;n].pos);</a>
<a name="ln464">  }</a>
<a name="ln465"> </a>
<a name="ln466">  memmove(&amp;x-&gt;key[x-&gt;n+1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln467">  for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln468">    refkey(b, x, x-&gt;n+1+k);</a>
<a name="ln469">    unrelative(x-&gt;key[x-&gt;n].pos, &amp;x-&gt;key[x-&gt;n+1+k].pos);</a>
<a name="ln470">  }</a>
<a name="ln471">  if (x-&gt;level) {</a>
<a name="ln472">    memmove(&amp;x-&gt;ptr[x-&gt;n+1], y-&gt;ptr, (size_t)(y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln473">    for (int k = 0; k &lt; y-&gt;n+1; k++) {</a>
<a name="ln474">      x-&gt;ptr[x-&gt;n+k+1]-&gt;parent = x;</a>
<a name="ln475">    }</a>
<a name="ln476">  }</a>
<a name="ln477">  x-&gt;n += y-&gt;n+1;</a>
<a name="ln478">  memmove(&amp;p-&gt;key[i], &amp;p-&gt;key[i + 1], (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln479">  memmove(&amp;p-&gt;ptr[i + 1], &amp;p-&gt;ptr[i + 2],</a>
<a name="ln480">          (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t *));</a>
<a name="ln481">  p-&gt;n--;</a>
<a name="ln482">  xfree(y);</a>
<a name="ln483">  b-&gt;n_nodes--;</a>
<a name="ln484">  return x;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">// TODO(bfredl): as a potential &quot;micro&quot; optimization, pivoting should balance</a>
<a name="ln488">// the two nodes instead of stealing just one key</a>
<a name="ln489">static void pivot_right(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln490">{</a>
<a name="ln491">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln492">  memmove(&amp;y-&gt;key[1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln493">  if (y-&gt;level) {</a>
<a name="ln494">    memmove(&amp;y-&gt;ptr[1], y-&gt;ptr, (size_t)(y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln495">  }</a>
<a name="ln496">  y-&gt;key[0] = p-&gt;key[i];</a>
<a name="ln497">  refkey(b, y, 0);</a>
<a name="ln498">  p-&gt;key[i] = x-&gt;key[x-&gt;n - 1];</a>
<a name="ln499">  refkey(b, p, i);</a>
<a name="ln500">  if (x-&gt;level) {</a>
<a name="ln501">    y-&gt;ptr[0] = x-&gt;ptr[x-&gt;n];</a>
<a name="ln502">    y-&gt;ptr[0]-&gt;parent = y;</a>
<a name="ln503">  }</a>
<a name="ln504">  x-&gt;n--;</a>
<a name="ln505">  y-&gt;n++;</a>
<a name="ln506">  if (i &gt; 0) {</a>
<a name="ln507">    unrelative(p-&gt;key[i-1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln508">  }</a>
<a name="ln509">  relative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln510">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln511">    unrelative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln512">  }</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static void pivot_left(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln516">{</a>
<a name="ln517">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i+1];</a>
<a name="ln518"> </a>
<a name="ln519">  // reverse from how we &quot;always&quot; do it. but pivot_left</a>
<a name="ln520">  // is just the inverse of pivot_right, so reverse it literally.</a>
<a name="ln521">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln522">    relative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln523">  }</a>
<a name="ln524">  unrelative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln525">  if (i &gt; 0) {</a>
<a name="ln526">    relative(p-&gt;key[i-1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln530">  refkey(b, x, x-&gt;n);</a>
<a name="ln531">  p-&gt;key[i] = y-&gt;key[0];</a>
<a name="ln532">  refkey(b, p, i);</a>
<a name="ln533">  if (x-&gt;level) {</a>
<a name="ln534">    x-&gt;ptr[x-&gt;n+1] = y-&gt;ptr[0];</a>
<a name="ln535">    x-&gt;ptr[x-&gt;n+1]-&gt;parent = x;</a>
<a name="ln536">  }</a>
<a name="ln537">  memmove(y-&gt;key, &amp;y-&gt;key[1], (size_t)(y-&gt;n-1) * sizeof(mtkey_t));</a>
<a name="ln538">  if (y-&gt;level) {</a>
<a name="ln539">    memmove(y-&gt;ptr, &amp;y-&gt;ptr[1], (size_t)y-&gt;n * sizeof(mtnode_t *));</a>
<a name="ln540">  }</a>
<a name="ln541">  x-&gt;n++;</a>
<a name="ln542">  y-&gt;n--;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/// frees all mem, resets tree to valid empty state</a>
<a name="ln546">void marktree_clear(MarkTree *b)</a>
<a name="ln547">{</a>
<a name="ln548">  if (b-&gt;root) {</a>
<a name="ln549">    marktree_free_node(b-&gt;root);</a>
<a name="ln550">    b-&gt;root = NULL;</a>
<a name="ln551">  }</a>
<a name="ln552">  if (b-&gt;id2node) {</a>
<a name="ln553">    pmap_free(uint64_t)(b-&gt;id2node);</a>
<a name="ln554">    b-&gt;id2node = NULL;</a>
<a name="ln555">  }</a>
<a name="ln556">  b-&gt;n_keys = 0;</a>
<a name="ln557">  b-&gt;n_nodes = 0;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">void marktree_free_node(mtnode_t *x)</a>
<a name="ln561">{</a>
<a name="ln562">  if (x-&gt;level) {</a>
<a name="ln563">    for (int i = 0; i &lt; x-&gt;n+1; i++) {</a>
<a name="ln564">      marktree_free_node(x-&gt;ptr[i]);</a>
<a name="ln565">    }</a>
<a name="ln566">  }</a>
<a name="ln567">  xfree(x);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">/// NB: caller must check not pair!</a>
<a name="ln571">uint64_t marktree_revise(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln572">{</a>
<a name="ln573">  uint64_t old_id = rawkey(itr).id;</a>
<a name="ln574">  pmap_del(uint64_t)(b-&gt;id2node, ANTIGRAVITY(old_id));</a>
<a name="ln575">  uint64_t new_id = (b-&gt;next_id += ID_INCR);</a>
<a name="ln576">  rawkey(itr).id = new_id + (RIGHT_GRAVITY&amp;old_id);</a>
<a name="ln577">  refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln578">  return new_id;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">void marktree_move(MarkTree *b, MarkTreeIter *itr, int row, int col)</a>
<a name="ln582">{</a>
<a name="ln583">  uint64_t old_id = rawkey(itr).id;</a>
<a name="ln584">  // TODO(bfredl): optimize when moving a mark within a leaf without moving it</a>
<a name="ln585">  // across neighbours!</a>
<a name="ln586">  marktree_del_itr(b, itr, false);</a>
<a name="ln587">  marktree_put_key(b, row, col, old_id);</a>
<a name="ln588">  itr-&gt;node = NULL;  // itr might become invalid by put</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">// itr functions</a>
<a name="ln592"> </a>
<a name="ln593">// TODO(bfredl): static inline?</a>
<a name="ln594">bool marktree_itr_get(MarkTree *b, int row, int col, MarkTreeIter *itr)</a>
<a name="ln595">{</a>
<a name="ln596">  return marktree_itr_get_ext(b, (mtpos_t){ row, col },</a>
<a name="ln597">                              itr, false, false, NULL);</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">bool marktree_itr_get_ext(MarkTree *b, mtpos_t p, MarkTreeIter *itr,</a>
<a name="ln601">                          bool last, bool gravity, mtpos_t *oldbase)</a>
<a name="ln602">{</a>
<a name="ln603">  mtkey_t k = { .pos = p, .id = gravity ? RIGHT_GRAVITY : 0 };</a>
<a name="ln604">  if (last &amp;&amp; !gravity) {</a>
<a name="ln605">    k.id = UINT64_MAX;</a>
<a name="ln606">  }</a>
<a name="ln607">  if (b-&gt;n_keys == 0) {</a>
<a name="ln608">    itr-&gt;node = NULL;</a>
<a name="ln609">    return false;</a>
<a name="ln610">  }</a>
<a name="ln611">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln612">  itr-&gt;node = b-&gt;root;</a>
<a name="ln613">  itr-&gt;lvl = 0;</a>
<a name="ln614">  if (oldbase) {</a>
<a name="ln615">    oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln616">  }</a>
<a name="ln617">  while (true) {</a>
<a name="ln618">    itr-&gt;i = marktree_getp_aux(itr-&gt;node, k, 0)+1;</a>
<a name="ln619"> </a>
<a name="ln620">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln621">      break;</a>
<a name="ln622">    }</a>
<a name="ln623"> </a>
<a name="ln624">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln625">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln626"> </a>
<a name="ln627">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln628">      compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln629">      relative(itr-&gt;node-&gt;key[itr-&gt;i-1].pos, &amp;k.pos);</a>
<a name="ln630">    }</a>
<a name="ln631">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln632">    itr-&gt;lvl++;</a>
<a name="ln633">    if (oldbase) {</a>
<a name="ln634">      oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln635">    }</a>
<a name="ln636">  }</a>
<a name="ln637"> </a>
<a name="ln638">  if (last) {</a>
<a name="ln639">    return marktree_itr_prev(b, itr);</a>
<a name="ln640">  } else if (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln641">    return marktree_itr_next(b, itr);</a>
<a name="ln642">  }</a>
<a name="ln643">  return true;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">bool marktree_itr_first(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln647">{</a>
<a name="ln648">  itr-&gt;node = b-&gt;root;</a>
<a name="ln649">  if (b-&gt;n_keys == 0) {</a>
<a name="ln650">    return false;</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  itr-&gt;i = 0;</a>
<a name="ln654">  itr-&gt;lvl = 0;</a>
<a name="ln655">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln656">  while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln657">    itr-&gt;s[itr-&gt;lvl].i = 0;</a>
<a name="ln658">    itr-&gt;s[itr-&gt;lvl].oldcol = 0;</a>
<a name="ln659">    itr-&gt;lvl++;</a>
<a name="ln660">    itr-&gt;node = itr-&gt;node-&gt;ptr[0];</a>
<a name="ln661">  }</a>
<a name="ln662">  return true;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">// gives the first key that is greater or equal to p</a>
<a name="ln666">int marktree_itr_last(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln667">{</a>
<a name="ln668">  if (b-&gt;n_keys == 0) {</a>
<a name="ln669">    itr-&gt;node = NULL;</a>
<a name="ln670">    return false;</a>
<a name="ln671">  }</a>
<a name="ln672">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln673">  itr-&gt;node = b-&gt;root;</a>
<a name="ln674">  itr-&gt;lvl = 0;</a>
<a name="ln675">  while (true) {</a>
<a name="ln676">    itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln677"> </a>
<a name="ln678">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln679">      break;</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln683">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln684"> </a>
<a name="ln685">    assert(itr-&gt;i &gt; 0);</a>
<a name="ln686">    compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln687"> </a>
<a name="ln688">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln689">    itr-&gt;lvl++;</a>
<a name="ln690">  }</a>
<a name="ln691">  itr-&gt;i--;</a>
<a name="ln692">  return true;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">// TODO(bfredl): static inline</a>
<a name="ln696">bool marktree_itr_next(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln697">{</a>
<a name="ln698">  return marktree_itr_next_skip(b, itr, false, NULL);</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">static bool marktree_itr_next_skip(MarkTree *b, MarkTreeIter *itr, bool skip,</a>
<a name="ln702">                                   mtpos_t oldbase[])</a>
<a name="ln703">{</a>
<a name="ln704">  if (!itr-&gt;node) {</a>
<a name="ln705">    return false;</a>
<a name="ln706">  }</a>
<a name="ln707">  itr-&gt;i++;</a>
<a name="ln708">  if (itr-&gt;node-&gt;level == 0 || skip) {</a>
<a name="ln709">    if (itr-&gt;i &lt; itr-&gt;node-&gt;n) {</a>
<a name="ln710">      // TODO(bfredl): this is the common case,</a>
<a name="ln711">      // and could be handled by inline wrapper</a>
<a name="ln712">      return true;</a>
<a name="ln713">    }</a>
<a name="ln714">    // we ran out of non-internal keys. Go up until we find an internal key</a>
<a name="ln715">    while (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln716">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln717">      if (itr-&gt;node == NULL) {</a>
<a name="ln718">        return false;</a>
<a name="ln719">      }</a>
<a name="ln720">      itr-&gt;lvl--;</a>
<a name="ln721">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln722">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln723">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i-1].pos.row;</a>
<a name="ln724">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln725">      }</a>
<a name="ln726">    }</a>
<a name="ln727">  } else {</a>
<a name="ln728">    // we stood at an &quot;internal&quot; key. Go down to the first non-internal</a>
<a name="ln729">    // key after it.</a>
<a name="ln730">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln731">      // internal key, there is always a child after</a>
<a name="ln732">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln733">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln734">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln735">      }</a>
<a name="ln736">      if (oldbase &amp;&amp; itr-&gt;i == 0) {</a>
<a name="ln737">        oldbase[itr-&gt;lvl+1] = oldbase[itr-&gt;lvl];</a>
<a name="ln738">      }</a>
<a name="ln739">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln740">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln741">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln742">      itr-&gt;i = 0;</a>
<a name="ln743">      itr-&gt;lvl++;</a>
<a name="ln744">    }</a>
<a name="ln745">  }</a>
<a name="ln746">  return true;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">bool marktree_itr_prev(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln750">{</a>
<a name="ln751">  if (!itr-&gt;node) {</a>
<a name="ln752">    return false;</a>
<a name="ln753">  }</a>
<a name="ln754">  if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln755">    itr-&gt;i--;</a>
<a name="ln756">    if (itr-&gt;i &gt;= 0) {</a>
<a name="ln757">      // TODO(bfredl): this is the common case,</a>
<a name="ln758">      // and could be handled by inline wrapper</a>
<a name="ln759">      return true;</a>
<a name="ln760">    }</a>
<a name="ln761">    // we ran out of non-internal keys. Go up until we find a non-internal key</a>
<a name="ln762">    while (itr-&gt;i &lt; 0) {</a>
<a name="ln763">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln764">      if (itr-&gt;node == NULL) {</a>
<a name="ln765">        return false;</a>
<a name="ln766">      }</a>
<a name="ln767">      itr-&gt;lvl--;</a>
<a name="ln768">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i-1;</a>
<a name="ln769">      if (itr-&gt;i &gt;= 0) {</a>
<a name="ln770">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i].pos.row;</a>
<a name="ln771">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln772">      }</a>
<a name="ln773">    }</a>
<a name="ln774">  } else {</a>
<a name="ln775">    // we stood at an &quot;internal&quot; key. Go down to the last non-internal</a>
<a name="ln776">    // key before it.</a>
<a name="ln777">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln778">      // internal key, there is always a child before</a>
<a name="ln779">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln780">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln781">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i-1].pos);</a>
<a name="ln782">      }</a>
<a name="ln783">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln784">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln785">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln786">      itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln787">      itr-&gt;lvl++;</a>
<a name="ln788">    }</a>
<a name="ln789">    itr-&gt;i--;</a>
<a name="ln790">  }</a>
<a name="ln791">  return true;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">void marktree_itr_rewind(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln795">{</a>
<a name="ln796">  if (!itr-&gt;node) {</a>
<a name="ln797">    return;</a>
<a name="ln798">  }</a>
<a name="ln799">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln800">    marktree_itr_prev(b, itr);</a>
<a name="ln801">  }</a>
<a name="ln802">  itr-&gt;i = 0;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">bool marktree_itr_node_done(MarkTreeIter *itr)</a>
<a name="ln806">{</a>
<a name="ln807">  return !itr-&gt;node || itr-&gt;i == itr-&gt;node-&gt;n-1;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811">mtpos_t marktree_itr_pos(MarkTreeIter *itr)</a>
<a name="ln812">{</a>
<a name="ln813">  mtpos_t pos = rawkey(itr).pos;</a>
<a name="ln814">  unrelative(itr-&gt;pos, &amp;pos);</a>
<a name="ln815">  return pos;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">mtmark_t marktree_itr_current(MarkTreeIter *itr)</a>
<a name="ln819">{</a>
<a name="ln820">  if (itr-&gt;node) {</a>
<a name="ln821">    uint64_t keyid = rawkey(itr).id;</a>
<a name="ln822">    mtpos_t pos = marktree_itr_pos(itr);</a>
<a name="ln823">    mtmark_t mark = { .row = pos.row,</a>
<a name="ln824">                      .col = pos.col,</a>
<a name="ln825">                       .id = ANTIGRAVITY(keyid),</a>
<a name="ln826">                       .right_gravity = keyid &amp; RIGHT_GRAVITY };</a>
<a name="ln827">    return mark;</a>
<a name="ln828">  }</a>
<a name="ln829">  return (mtmark_t){ -1, -1, 0, false };</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static void swap_id(uint64_t *id1, uint64_t *id2)</a>
<a name="ln833">{</a>
<a name="ln834">  uint64_t temp = *id1;</a>
<a name="ln835">  *id1 = *id2;</a>
<a name="ln836">  *id2 = temp;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">bool marktree_splice(MarkTree *b,</a>
<a name="ln840">                     int start_line, int start_col,</a>
<a name="ln841">                     int old_extent_line, int old_extent_col,</a>
<a name="ln842">                     int new_extent_line, int new_extent_col)</a>
<a name="ln843">{</a>
<a name="ln844">  mtpos_t start = { start_line, start_col };</a>
<a name="ln845">  mtpos_t old_extent = { (int)old_extent_line, old_extent_col };</a>
<a name="ln846">  mtpos_t new_extent = { (int)new_extent_line, new_extent_col };</a>
<a name="ln847"> </a>
<a name="ln848">  bool may_delete = (old_extent.row != 0 || old_extent.col != 0);</a>
<a name="ln849">  bool same_line = old_extent.row == 0 &amp;&amp; new_extent.row == 0;</a>
<a name="ln850">  unrelative(start, &amp;old_extent);</a>
<a name="ln851">  unrelative(start, &amp;new_extent);</a>
<a name="ln852">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln853">  MarkTreeIter enditr[1] = { 0 };</a>
<a name="ln854"> </a>
<a name="ln855">  mtpos_t oldbase[MT_MAX_DEPTH];</a>
<a name="ln856"> </a>
<a name="ln857">  marktree_itr_get_ext(b, start, itr, false, true, oldbase);</a>
<a name="ln858">  if (!itr-&gt;node) {</a>
<a name="ln859">    // den e FÃ„RDIG</a>
<a name="ln860">    return false;</a>
<a name="ln861">  }</a>
<a name="ln862">  mtpos_t delta = { new_extent.row - old_extent.row,</a>
<a name="ln863">                    new_extent.col-old_extent.col };</a>
<a name="ln864"> </a>
<a name="ln865">  if (may_delete) {</a>
<a name="ln866">    mtpos_t ipos = marktree_itr_pos(itr);</a>
<a name="ln867">    if (!pos_leq(old_extent, ipos)</a>
<a name="ln868">        || (old_extent.row == ipos.row &amp;&amp; old_extent.col == ipos.col</a>
<a name="ln869">            &amp;&amp; !IS_RIGHT(rawkey(itr).id))) {</a>
<a name="ln870">      marktree_itr_get_ext(b, old_extent, enditr, true, true, NULL);</a>
<a name="ln871">      assert(enditr-&gt;node);</a>
<a name="ln872">      // &quot;assert&quot; (itr &lt;= enditr)</a>
<a name="ln873">    } else {</a>
<a name="ln874">      may_delete = false;</a>
<a name="ln875">    }</a>
<a name="ln876">  }</a>
<a name="ln877"> </a>
<a name="ln878">  bool past_right = false;</a>
<a name="ln879">  bool moved = false;</a>
<a name="ln880"> </a>
<a name="ln881">  // Follow the general strategy of messing things up and fix them later</a>
<a name="ln882">  // &quot;oldbase&quot; carries the information needed to calculate old position of</a>
<a name="ln883">  // children.</a>
<a name="ln884">  if (may_delete) {</a>
<a name="ln885">    while (itr-&gt;node &amp;&amp; !past_right) {</a>
<a name="ln886">      mtpos_t loc_start = start;</a>
<a name="ln887">      mtpos_t loc_old = old_extent;</a>
<a name="ln888">      relative(itr-&gt;pos, &amp;loc_start);</a>
<a name="ln889"> </a>
<a name="ln890">      relative(oldbase[itr-&gt;lvl], &amp;loc_old);</a>
<a name="ln891"> </a>
<a name="ln892">continue_same_node:</a>
<a name="ln893">      // NB: strictly should be less than the right gravity of loc_old, but</a>
<a name="ln894">      // the iter comparison below will already break on that.</a>
<a name="ln895">      if (!pos_leq(rawkey(itr).pos, loc_old)) {</a>
<a name="ln896">        break;</a>
<a name="ln897">      }</a>
<a name="ln898"> </a>
<a name="ln899">      if (IS_RIGHT(rawkey(itr).id)) {</a>
<a name="ln900">        while (rawkey(itr).id != rawkey(enditr).id</a>
<a name="ln901">               &amp;&amp; IS_RIGHT(rawkey(enditr).id)) {</a>
<a name="ln902">          marktree_itr_prev(b, enditr);</a>
<a name="ln903">        }</a>
<a name="ln904">        if (!IS_RIGHT(rawkey(enditr).id)) {</a>
<a name="ln905">          swap_id(&amp;rawkey(itr).id, &amp;rawkey(enditr).id);</a>
<a name="ln906">          refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln907">          refkey(b, enditr-&gt;node, enditr-&gt;i);</a>
<a name="ln908">        } else {</a>
<a name="ln909">          past_right = true; // NOLINT</a>
<a name="ln910">          break;</a>
<a name="ln911">        }</a>
<a name="ln912">      }</a>
<a name="ln913"> </a>
<a name="ln914">      if (rawkey(itr).id == rawkey(enditr).id) {</a>
<a name="ln915">        // actually, will be past_right after this key</a>
<a name="ln916">        past_right = true;</a>
<a name="ln917">      }</a>
<a name="ln918"> </a>
<a name="ln919">      moved = true;</a>
<a name="ln920">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln921">        oldbase[itr-&gt;lvl+1] = rawkey(itr).pos;</a>
<a name="ln922">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl+1]);</a>
<a name="ln923">        rawkey(itr).pos = loc_start;</a>
<a name="ln924">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln925">      } else {</a>
<a name="ln926">        rawkey(itr).pos = loc_start;</a>
<a name="ln927">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n-1) {</a>
<a name="ln928">          itr-&gt;i++;</a>
<a name="ln929">          if (!past_right) {</a>
<a name="ln930">            goto continue_same_node;</a>
<a name="ln931">          }</a>
<a name="ln932">        } else {</a>
<a name="ln933">          marktree_itr_next(b, itr);</a>
<a name="ln934">        }</a>
<a name="ln935">      }</a>
<a name="ln936">    }</a>
<a name="ln937">    while (itr-&gt;node) {</a>
<a name="ln938">      mtpos_t loc_new = new_extent;</a>
<a name="ln939">      relative(itr-&gt;pos, &amp;loc_new);</a>
<a name="ln940">      mtpos_t limit = old_extent;</a>
<a name="ln941"> </a>
<a name="ln942">      relative(oldbase[itr-&gt;lvl], &amp;limit);</a>
<a name="ln943"> </a>
<a name="ln944">past_continue_same_node:</a>
<a name="ln945"> </a>
<a name="ln946">      if (pos_leq(limit, rawkey(itr).pos)) {</a>
<a name="ln947">        break;</a>
<a name="ln948">      }</a>
<a name="ln949"> </a>
<a name="ln950">      mtpos_t oldpos = rawkey(itr).pos;</a>
<a name="ln951">      rawkey(itr).pos = loc_new;</a>
<a name="ln952">      moved = true;</a>
<a name="ln953">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln954">        oldbase[itr-&gt;lvl+1] = oldpos;</a>
<a name="ln955">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl+1]);</a>
<a name="ln956"> </a>
<a name="ln957">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln958">      } else {</a>
<a name="ln959">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n-1) {</a>
<a name="ln960">          itr-&gt;i++;</a>
<a name="ln961">          goto past_continue_same_node;</a>
<a name="ln962">        } else {</a>
<a name="ln963">          marktree_itr_next(b, itr);</a>
<a name="ln964">        }</a>
<a name="ln965">      }</a>
<a name="ln966">    }</a>
<a name="ln967">  }</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">  while (itr-&gt;node) {</a>
<a name="ln971">    unrelative(oldbase[itr-&gt;lvl], &amp;rawkey(itr).pos);</a>
<a name="ln972">    int realrow = rawkey(itr).pos.row;</a>
<a name="ln973">    assert(realrow &gt;= old_extent.row);</a>
<a name="ln974">    bool done = false;</a>
<a name="ln975">    if (realrow == old_extent.row) {</a>
<a name="ln976">      if (delta.col) {</a>
<a name="ln977">        rawkey(itr).pos.col += delta.col;</a>
<a name="ln978">        moved = true;</a>
<a name="ln979">      }</a>
<a name="ln980">    } else {</a>
<a name="ln981">      if (same_line) {</a>
<a name="ln982">        // optimization: column only adjustment can skip remaining rows</a>
<a name="ln983">        done = true;</a>
<a name="ln984">      }</a>
<a name="ln985">    }</a>
<a name="ln986">    if (delta.row) {</a>
<a name="ln987">      rawkey(itr).pos.row += delta.row;</a>
<a name="ln988">      moved = true;</a>
<a name="ln989">    }</a>
<a name="ln990">    relative(itr-&gt;pos, &amp;rawkey(itr).pos);</a>
<a name="ln991">    if (done) {</a>
<a name="ln992">      break;</a>
<a name="ln993">    }</a>
<a name="ln994">    marktree_itr_next_skip(b, itr, true, NULL);</a>
<a name="ln995">  }</a>
<a name="ln996">  return moved;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">void marktree_move_region(MarkTree *b,</a>
<a name="ln1000">                          int start_row, colnr_T start_col,</a>
<a name="ln1001">                          int extent_row, colnr_T extent_col,</a>
<a name="ln1002">                          int new_row, colnr_T new_col)</a>
<a name="ln1003">{</a>
<a name="ln1004">  mtpos_t start = { start_row, start_col }, size = { extent_row, extent_col };</a>
<a name="ln1005">  mtpos_t end = size;</a>
<a name="ln1006">  unrelative(start, &amp;end);</a>
<a name="ln1007">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln1008">  marktree_itr_get_ext(b, start, itr, false, true, NULL);</a>
<a name="ln1009">  kvec_t(mtkey_t) saved = KV_INITIAL_VALUE;</a>
<a name="ln1010">  while (itr-&gt;node) {</a>
<a name="ln1011">    mtpos_t pos = marktree_itr_pos(itr);</a>
<a name="ln1012">    if (!pos_leq(pos, end) || (pos.row == end.row &amp;&amp; pos.col == end.col</a>
<a name="ln1013">                               &amp;&amp; rawkey(itr).id &amp; RIGHT_GRAVITY)) {</a>
<a name="ln1014">      break;</a>
<a name="ln1015">    }</a>
<a name="ln1016">    relative(start, &amp;pos);</a>
<a name="ln1017">    kv_push(saved, ((mtkey_t){ .pos = pos, .id = rawkey(itr).id }));</a>
<a name="ln1018">    marktree_del_itr(b, itr, false);</a>
<a name="ln1019">  }</a>
<a name="ln1020"> </a>
<a name="ln1021">  marktree_splice(b, start.row, start.col, size.row, size.col, 0, 0);</a>
<a name="ln1022">  mtpos_t new = { new_row, new_col };</a>
<a name="ln1023">  marktree_splice(b, new.row, new.col,</a>
<a name="ln1024">                  0, 0, size.row, size.col);</a>
<a name="ln1025"> </a>
<a name="ln1026">  for (size_t i = 0; i &lt; kv_size(saved); i++) {</a>
<a name="ln1027">    mtkey_t item = kv_A(saved, i);</a>
<a name="ln1028">    unrelative(new, &amp;item.pos);</a>
<a name="ln1029">    marktree_put_key(b, item.pos.row, item.pos.col, item.id);</a>
<a name="ln1030">  }</a>
<a name="ln1031">  kv_destroy(saved);</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1035">mtpos_t marktree_lookup(MarkTree *b, uint64_t id, MarkTreeIter *itr)</a>
<a name="ln1036">{</a>
<a name="ln1037">  mtnode_t *n = pmap_get(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln1038">  if (n == NULL) {</a>
<a name="ln1039">    if (itr) {</a>
<a name="ln1040">      itr-&gt;node = NULL;</a>
<a name="ln1041">    }</a>
<a name="ln1042">    return (mtpos_t){ -1, -1 };</a>
<a name="ln1043">  }</a>
<a name="ln1044">  int i = 0;</a>
<a name="ln1045">  for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1046">    if (ANTIGRAVITY(n-&gt;key[i].id) == id) {</a>
<a name="ln1047">      goto found;</a>
<a name="ln1048">    }</a>
<a name="ln1049">  }</a>
<a name="ln1050">  abort();</a>
<a name="ln1051">found: {}</a>
<a name="ln1052">  mtpos_t pos = n-&gt;key[i].pos;</a>
<a name="ln1053">  if (itr) {</a>
<a name="ln1054">    itr-&gt;i = i;</a>
<a name="ln1055">    itr-&gt;node = n;</a>
<a name="ln1056">    itr-&gt;lvl = b-&gt;root-&gt;level - n-&gt;level;</a>
<a name="ln1057">  }</a>
<a name="ln1058">  while (n-&gt;parent != NULL) {</a>
<a name="ln1059">    mtnode_t *p = n-&gt;parent;</a>
<a name="ln1060">    for (i = 0; i &lt; p-&gt;n+1; i++) {</a>
<a name="ln1061">      if (p-&gt;ptr[i] == n) {</a>
<a name="ln1062">        goto found_node;</a>
<a name="ln1063">      }</a>
<a name="ln1064">    }</a>
<a name="ln1065">    abort();</a>
<a name="ln1066">found_node:</a>
<a name="ln1067">    if (itr) {</a>
<a name="ln1068">      itr-&gt;s[b-&gt;root-&gt;level-p-&gt;level].i = i;</a>
<a name="ln1069">    }</a>
<a name="ln1070">    if (i &gt; 0) {</a>
<a name="ln1071">      unrelative(p-&gt;key[i-1].pos, &amp;pos);</a>
<a name="ln1072">    }</a>
<a name="ln1073">    n = p;</a>
<a name="ln1074">  }</a>
<a name="ln1075">  if (itr) {</a>
<a name="ln1076">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln1077">  }</a>
<a name="ln1078">  return pos;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">static void marktree_itr_fix_pos(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1082">{</a>
<a name="ln1083">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln1084">  mtnode_t *x = b-&gt;root;</a>
<a name="ln1085">  for (int lvl = 0; lvl &lt; itr-&gt;lvl; lvl++) {</a>
<a name="ln1086">    itr-&gt;s[lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1087">    int i = itr-&gt;s[lvl].i;</a>
<a name="ln1088">    if (i &gt; 0) {</a>
<a name="ln1089">      compose(&amp;itr-&gt;pos, x-&gt;key[i-1].pos);</a>
<a name="ln1090">    }</a>
<a name="ln1091">    assert(x-&gt;level);</a>
<a name="ln1092">    x = x-&gt;ptr[i];</a>
<a name="ln1093">  }</a>
<a name="ln1094">  assert(x == itr-&gt;node);</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">void marktree_check(MarkTree *b)</a>
<a name="ln1098">{</a>
<a name="ln1099">#ifndef NDEBUG</a>
<a name="ln1100">  if (b-&gt;root == NULL) {</a>
<a name="ln1101">    assert(b-&gt;n_keys == 0);</a>
<a name="ln1102">    assert(b-&gt;n_nodes == 0);</a>
<a name="ln1103">    assert(b-&gt;id2node == NULL || map_size(b-&gt;id2node) == 0);</a>
<a name="ln1104">    return;</a>
<a name="ln1105">  }</a>
<a name="ln1106"> </a>
<a name="ln1107">  mtpos_t dummy;</a>
<a name="ln1108">  bool last_right = false;</a>
<a name="ln1109">  size_t nkeys = check_node(b, b-&gt;root, &amp;dummy, &amp;last_right);</a>
<a name="ln1110">  assert(b-&gt;n_keys == nkeys);</a>
<a name="ln1111">  assert(b-&gt;n_keys == map_size(b-&gt;id2node));</a>
<a name="ln1112">#else</a>
<a name="ln1113">  // Do nothing, as assertions are required</a>
<a name="ln1114">  (void)b;</a>
<a name="ln1115">#endif</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">#ifndef NDEBUG</a>
<a name="ln1119">static size_t check_node(MarkTree *b, mtnode_t *x,</a>
<a name="ln1120">                         mtpos_t *last, bool *last_right)</a>
<a name="ln1121">{</a>
<a name="ln1122">  assert(x-&gt;n &lt;= 2 * T - 1);</a>
<a name="ln1123">  // TODO(bfredl): too strict if checking &quot;in repair&quot; post-delete tree.</a>
<a name="ln1124">  assert(x-&gt;n &gt;= (x != b-&gt;root ? T-1 : 0));</a>
<a name="ln1125">  size_t n_keys = (size_t)x-&gt;n;</a>
<a name="ln1126"> </a>
<a name="ln1127">  for (int i = 0; i &lt; x-&gt;n; i++) {</a>
<a name="ln1128">    if (x-&gt;level) {</a>
<a name="ln1129">      n_keys += check_node(b, x-&gt;ptr[i], last, last_right);</a>
<a name="ln1130">    } else {</a>
<a name="ln1131">      *last = (mtpos_t) { 0, 0 };</a>
<a name="ln1132">    }</a>
<a name="ln1133">    if (i &gt; 0) {</a>
<a name="ln1134">      unrelative(x-&gt;key[i-1].pos, last);</a>
<a name="ln1135">    }</a>
<a name="ln1136">    if (x-&gt;level) {</a>
<a name="ln1137">    }</a>
<a name="ln1138">    assert(pos_leq(*last, x-&gt;key[i].pos));</a>
<a name="ln1139">    if (last-&gt;row == x-&gt;key[i].pos.row &amp;&amp; last-&gt;col == x-&gt;key[i].pos.col) {</a>
<a name="ln1140">      assert(!*last_right || IS_RIGHT(x-&gt;key[i].id));</a>
<a name="ln1141">    }</a>
<a name="ln1142">    *last_right = IS_RIGHT(x-&gt;key[i].id);</a>
<a name="ln1143">    assert(x-&gt;key[i].pos.col &gt;= 0);</a>
<a name="ln1144">    assert(pmap_get(uint64_t)(b-&gt;id2node, ANTIGRAVITY(x-&gt;key[i].id)) == x);</a>
<a name="ln1145">  }</a>
<a name="ln1146"> </a>
<a name="ln1147">  if (x-&gt;level) {</a>
<a name="ln1148">    n_keys += check_node(b, x-&gt;ptr[x-&gt;n], last, last_right);</a>
<a name="ln1149">    unrelative(x-&gt;key[x-&gt;n-1].pos, last);</a>
<a name="ln1150"> </a>
<a name="ln1151">    for (int i = 0; i &lt; x-&gt;n+1; i++) {</a>
<a name="ln1152">      assert(x-&gt;ptr[i]-&gt;parent == x);</a>
<a name="ln1153">      assert(x-&gt;ptr[i]-&gt;level == x-&gt;level-1);</a>
<a name="ln1154">      // PARANOIA: check no double node ref</a>
<a name="ln1155">      for (int j = 0; j &lt; i; j++) {</a>
<a name="ln1156">        assert(x-&gt;ptr[i] != x-&gt;ptr[j]);</a>
<a name="ln1157">      }</a>
<a name="ln1158">    }</a>
<a name="ln1159">  } else {</a>
<a name="ln1160">    *last = x-&gt;key[x-&gt;n-1].pos;</a>
<a name="ln1161">  }</a>
<a name="ln1162">  return n_keys;</a>
<a name="ln1163">}</a>
<a name="ln1164">#endif</a>
<a name="ln1165"> </a>
<a name="ln1166">char *mt_inspect_rec(MarkTree *b)</a>
<a name="ln1167">{</a>
<a name="ln1168">  garray_T ga;</a>
<a name="ln1169">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln1170">  mtpos_t p = { 0, 0 };</a>
<a name="ln1171">  mt_inspect_node(b, &amp;ga, b-&gt;root, p);</a>
<a name="ln1172">  return ga.ga_data;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">void mt_inspect_node(MarkTree *b, garray_T *ga, mtnode_t *n, mtpos_t off)</a>
<a name="ln1176">{</a>
<a name="ln1177">  static char buf[1024];</a>
<a name="ln1178">#define GA_PUT(x) ga_concat(ga, (char_u *)(x))</a>
<a name="ln1179">  GA_PUT(&quot;[&quot;);</a>
<a name="ln1180">  if (n-&gt;level) {</a>
<a name="ln1181">    mt_inspect_node(b, ga, n-&gt;ptr[0], off);</a>
<a name="ln1182">  }</a>
<a name="ln1183">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1184">    mtpos_t p = n-&gt;key[i].pos;</a>
<a name="ln1185">    unrelative(off, &amp;p);</a>
<a name="ln1186">    snprintf((char *)buf, sizeof(buf), &quot;%d/%d&quot;, p.row, p.col);</a>
<a name="ln1187">    GA_PUT(buf);</a>
<a name="ln1188">    if (n-&gt;level) {</a>
<a name="ln1189">      mt_inspect_node(b, ga, n-&gt;ptr[i+1], p);</a>
<a name="ln1190">    } else {</a>
<a name="ln1191">      GA_PUT(&quot;,&quot;);</a>
<a name="ln1192">    }</a>
<a name="ln1193">  }</a>
<a name="ln1194">  GA_PUT(&quot;]&quot;);</a>
<a name="ln1195">#undef GA_PUT</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>

</code></pre>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'z->key'.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'y->n + 1' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="494"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'y->n + 1' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

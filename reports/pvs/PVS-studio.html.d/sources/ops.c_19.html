
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ops.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,</a>
<a name="ln6"> *        op_change, op_yank, do_put, do_join</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;assert.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/ops.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln21">#include &quot;nvim/assert.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/fold.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/indent.h&quot;</a>
<a name="ln32">#include &quot;nvim/log.h&quot;</a>
<a name="ln33">#include &quot;nvim/mark.h&quot;</a>
<a name="ln34">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln35">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln36">#include &quot;nvim/memline.h&quot;</a>
<a name="ln37">#include &quot;nvim/memory.h&quot;</a>
<a name="ln38">#include &quot;nvim/message.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/move.h&quot;</a>
<a name="ln41">#include &quot;nvim/normal.h&quot;</a>
<a name="ln42">#include &quot;nvim/option.h&quot;</a>
<a name="ln43">#include &quot;nvim/path.h&quot;</a>
<a name="ln44">#include &quot;nvim/screen.h&quot;</a>
<a name="ln45">#include &quot;nvim/search.h&quot;</a>
<a name="ln46">#include &quot;nvim/state.h&quot;</a>
<a name="ln47">#include &quot;nvim/strings.h&quot;</a>
<a name="ln48">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln49">#include &quot;nvim/ui.h&quot;</a>
<a name="ln50">#include &quot;nvim/undo.h&quot;</a>
<a name="ln51">#include &quot;nvim/macros.h&quot;</a>
<a name="ln52">#include &quot;nvim/window.h&quot;</a>
<a name="ln53">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln55">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">static yankreg_T y_regs[NUM_REGISTERS];</a>
<a name="ln58"> </a>
<a name="ln59">static yankreg_T *y_previous = NULL; /* ptr to last written yankreg */</a>
<a name="ln60"> </a>
<a name="ln61">// for behavior between start_batch_changes() and end_batch_changes())</a>
<a name="ln62">static int batch_change_count = 0;           // inside a script</a>
<a name="ln63">static bool clipboard_delay_update = false;  // delay clipboard update</a>
<a name="ln64">static bool clipboard_needs_update = false;  // clipboard was updated</a>
<a name="ln65">static bool clipboard_didwarn = false;</a>
<a name="ln66"> </a>
<a name="ln67">/*</a>
<a name="ln68"> * structure used by block_prep, op_delete and op_yank for blockwise operators</a>
<a name="ln69"> * also op_change, op_shift, op_insert, op_replace - AKelly</a>
<a name="ln70"> */</a>
<a name="ln71">struct block_def {</a>
<a name="ln72">  int startspaces;              /* 'extra' cols before first char */</a>
<a name="ln73">  int endspaces;                /* 'extra' cols after last char */</a>
<a name="ln74">  int textlen;                  /* chars in block */</a>
<a name="ln75">  char_u      *textstart;       /* pointer to 1st char (partially) in block */</a>
<a name="ln76">  colnr_T textcol;              /* index of chars (partially) in block */</a>
<a name="ln77">  colnr_T start_vcol;           /* start col of 1st char wholly inside block */</a>
<a name="ln78">  colnr_T end_vcol;             /* start col of 1st char wholly after block */</a>
<a name="ln79">  int is_short;                 /* TRUE if line is too short to fit in block */</a>
<a name="ln80">  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */</a>
<a name="ln81">  int is_oneChar;               /* TRUE if block within one character */</a>
<a name="ln82">  int pre_whitesp;              /* screen cols of ws before block */</a>
<a name="ln83">  int pre_whitesp_c;            /* chars of ws before block */</a>
<a name="ln84">  colnr_T end_char_vcols;       /* number of vcols of post-block char */</a>
<a name="ln85">  colnr_T start_char_vcols;       /* number of vcols of pre-block char */</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln89"># include &quot;ops.c.generated.h&quot;</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">// Flags for third item in &quot;opchars&quot;.</a>
<a name="ln93">#define OPF_LINES  1  // operator always works on lines</a>
<a name="ln94">#define OPF_CHANGE 2  // operator changes text</a>
<a name="ln95"> </a>
<a name="ln96">/*</a>
<a name="ln97"> * The names of operators.</a>
<a name="ln98"> * IMPORTANT: Index must correspond with defines in vim.h!!!</a>
<a name="ln99"> * The third field indicates whether the operator always works on lines.</a>
<a name="ln100"> */</a>
<a name="ln101">static char opchars[][3] =</a>
<a name="ln102">{</a>
<a name="ln103">  { NUL, NUL, 0 },                       // OP_NOP</a>
<a name="ln104">  { 'd', NUL, OPF_CHANGE },              // OP_DELETE</a>
<a name="ln105">  { 'y', NUL, 0 },                       // OP_YANK</a>
<a name="ln106">  { 'c', NUL, OPF_CHANGE },              // OP_CHANGE</a>
<a name="ln107">  { '&lt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_LSHIFT</a>
<a name="ln108">  { '&gt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_RSHIFT</a>
<a name="ln109">  { '!', NUL, OPF_LINES | OPF_CHANGE },  // OP_FILTER</a>
<a name="ln110">  { 'g', '~', OPF_CHANGE },              // OP_TILDE</a>
<a name="ln111">  { '=', NUL, OPF_LINES | OPF_CHANGE },  // OP_INDENT</a>
<a name="ln112">  { 'g', 'q', OPF_LINES | OPF_CHANGE },  // OP_FORMAT</a>
<a name="ln113">  { ':', NUL, OPF_LINES },               // OP_COLON</a>
<a name="ln114">  { 'g', 'U', OPF_CHANGE },              // OP_UPPER</a>
<a name="ln115">  { 'g', 'u', OPF_CHANGE },              // OP_LOWER</a>
<a name="ln116">  { 'J', NUL, OPF_LINES | OPF_CHANGE },  // DO_JOIN</a>
<a name="ln117">  { 'g', 'J', OPF_LINES | OPF_CHANGE },  // DO_JOIN_NS</a>
<a name="ln118">  { 'g', '?', OPF_CHANGE },              // OP_ROT13</a>
<a name="ln119">  { 'r', NUL, OPF_CHANGE },              // OP_REPLACE</a>
<a name="ln120">  { 'I', NUL, OPF_CHANGE },              // OP_INSERT</a>
<a name="ln121">  { 'A', NUL, OPF_CHANGE },              // OP_APPEND</a>
<a name="ln122">  { 'z', 'f', 0         },               // OP_FOLD</a>
<a name="ln123">  { 'z', 'o', OPF_LINES },               // OP_FOLDOPEN</a>
<a name="ln124">  { 'z', 'O', OPF_LINES },               // OP_FOLDOPENREC</a>
<a name="ln125">  { 'z', 'c', OPF_LINES },               // OP_FOLDCLOSE</a>
<a name="ln126">  { 'z', 'C', OPF_LINES },               // OP_FOLDCLOSEREC</a>
<a name="ln127">  { 'z', 'd', OPF_LINES },               // OP_FOLDDEL</a>
<a name="ln128">  { 'z', 'D', OPF_LINES },               // OP_FOLDDELREC</a>
<a name="ln129">  { 'g', 'w', OPF_LINES | OPF_CHANGE },  // OP_FORMAT2</a>
<a name="ln130">  { 'g', '@', OPF_CHANGE },              // OP_FUNCTION</a>
<a name="ln131">  { Ctrl_A, NUL, OPF_CHANGE },           // OP_NR_ADD</a>
<a name="ln132">  { Ctrl_X, NUL, OPF_CHANGE },           // OP_NR_SUB</a>
<a name="ln133">};</a>
<a name="ln134"> </a>
<a name="ln135">/*</a>
<a name="ln136"> * Translate a command name into an operator type.</a>
<a name="ln137"> * Must only be called with a valid operator name!</a>
<a name="ln138"> */</a>
<a name="ln139">int get_op_type(int char1, int char2)</a>
<a name="ln140">{</a>
<a name="ln141">  int i;</a>
<a name="ln142"> </a>
<a name="ln143">  if (char1 == 'r') {</a>
<a name="ln144">    // ignore second character</a>
<a name="ln145">    return OP_REPLACE;</a>
<a name="ln146">  }</a>
<a name="ln147">  if (char1 == '~') {</a>
<a name="ln148">    // when tilde is an operator</a>
<a name="ln149">    return OP_TILDE;</a>
<a name="ln150">  }</a>
<a name="ln151">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_A) {</a>
<a name="ln152">    // add</a>
<a name="ln153">    return OP_NR_ADD;</a>
<a name="ln154">  }</a>
<a name="ln155">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_X) {</a>
<a name="ln156">    // subtract</a>
<a name="ln157">    return OP_NR_SUB;</a>
<a name="ln158">  }</a>
<a name="ln159">  for (i = 0;; i++) {</a>
<a name="ln160">    if (opchars[i][0] == char1 &amp;&amp; opchars[i][1] == char2) {</a>
<a name="ln161">      break;</a>
<a name="ln162">    }</a>
<a name="ln163">    if (i == (int)(ARRAY_SIZE(opchars) - 1)) {</a>
<a name="ln164">      internal_error(&quot;get_op_type()&quot;);</a>
<a name="ln165">      break;</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168">  return i;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">/*</a>
<a name="ln172"> * Return TRUE if operator &quot;op&quot; always works on whole lines.</a>
<a name="ln173"> */</a>
<a name="ln174">int op_on_lines(int op)</a>
<a name="ln175">{</a>
<a name="ln176">  return opchars[op][2] &amp; OPF_LINES;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">// Return TRUE if operator &quot;op&quot; changes text.</a>
<a name="ln180">int op_is_change(int op)</a>
<a name="ln181">{</a>
<a name="ln182">    return opchars[op][2] &amp; OPF_CHANGE;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/*</a>
<a name="ln186"> * Get first operator command character.</a>
<a name="ln187"> * Returns 'g' or 'z' if there is another command character.</a>
<a name="ln188"> */</a>
<a name="ln189">int get_op_char(int optype)</a>
<a name="ln190">{</a>
<a name="ln191">  return opchars[optype][0];</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/*</a>
<a name="ln195"> * Get second operator command character.</a>
<a name="ln196"> */</a>
<a name="ln197">int get_extra_op_char(int optype)</a>
<a name="ln198">{</a>
<a name="ln199">  return opchars[optype][1];</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">/*</a>
<a name="ln203"> * op_shift - handle a shift operation</a>
<a name="ln204"> */</a>
<a name="ln205">void op_shift(oparg_T *oap, int curs_top, int amount)</a>
<a name="ln206">{</a>
<a name="ln207">  long i;</a>
<a name="ln208">  int first_char;</a>
<a name="ln209">  char_u          *s;</a>
<a name="ln210">  int block_col = 0;</a>
<a name="ln211"> </a>
<a name="ln212">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln213">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln214">    return;</a>
<a name="ln215"> </a>
<a name="ln216">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln217">    block_col = curwin-&gt;w_cursor.col;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  for (i = oap-&gt;line_count - 1; i &gt;= 0; i--) {</a>
<a name="ln221">    first_char = *get_cursor_line_ptr();</a>
<a name="ln222">    if (first_char == NUL) {  // empty line</a>
<a name="ln223">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln224">    } else if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln225">      shift_block(oap, amount);</a>
<a name="ln226">    } else if (first_char != '#' || !preprocs_left()) {</a>
<a name="ln227">      // Move the line right if it doesn't start with '#', 'smartindent'</a>
<a name="ln228">      // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.</a>
<a name="ln229">      shift_line(oap-&gt;op_type == OP_LSHIFT, p_sr, amount, false);</a>
<a name="ln230">    }</a>
<a name="ln231">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln235">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln236">    curwin-&gt;w_cursor.col = block_col;</a>
<a name="ln237">  } else if (curs_top) { /* put cursor on first line, for &quot;&gt;&gt;&quot; */</a>
<a name="ln238">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln239">    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */</a>
<a name="ln240">  } else</a>
<a name="ln241">    --curwin-&gt;w_cursor.lnum;            /* put cursor on last line, for &quot;:&gt;&quot; */</a>
<a name="ln242"> </a>
<a name="ln243">  // The cursor line is not in a closed fold</a>
<a name="ln244">  foldOpenCursor();</a>
<a name="ln245"> </a>
<a name="ln246">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln247">    if (oap-&gt;op_type == OP_RSHIFT)</a>
<a name="ln248">      s = (char_u *)&quot;&gt;&quot;;</a>
<a name="ln249">    else</a>
<a name="ln250">      s = (char_u *)&quot;&lt;&quot;;</a>
<a name="ln251">    if (oap-&gt;line_count == 1) {</a>
<a name="ln252">      if (amount == 1)</a>
<a name="ln253">        sprintf((char *)IObuff, _(&quot;1 line %sed 1 time&quot;), s);</a>
<a name="ln254">      else</a>
<a name="ln255">        sprintf((char *)IObuff, _(&quot;1 line %sed %d times&quot;), s, amount);</a>
<a name="ln256">    } else {</a>
<a name="ln257">      if (amount == 1)</a>
<a name="ln258">        sprintf((char *)IObuff, _(&quot;%&quot; PRId64 &quot; lines %sed 1 time&quot;),</a>
<a name="ln259">            (int64_t)oap-&gt;line_count, s);</a>
<a name="ln260">      else</a>
<a name="ln261">        sprintf((char *)IObuff, _(&quot;%&quot; PRId64 &quot; lines %sed %d times&quot;),</a>
<a name="ln262">            (int64_t)oap-&gt;line_count, s, amount);</a>
<a name="ln263">    }</a>
<a name="ln264">    msg_attr_keep(IObuff, 0, true, false);</a>
<a name="ln265">  }</a>
<a name="ln266"> </a>
<a name="ln267">  /*</a>
<a name="ln268">   * Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln269">   */</a>
<a name="ln270">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln271">  curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln272">  curbuf-&gt;b_op_end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln273">  if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln274">    curbuf-&gt;b_op_end.col--;</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">// Shift the current line one shiftwidth left (if left != 0) or right</a>
<a name="ln281">// leaves cursor on first blank in the line.</a>
<a name="ln282">void shift_line(</a>
<a name="ln283">    int left,</a>
<a name="ln284">    int round,</a>
<a name="ln285">    int amount,</a>
<a name="ln286">    int call_changed_bytes  // call changed_bytes()</a>
<a name="ln287">)</a>
<a name="ln288">{</a>
<a name="ln289">  int count;</a>
<a name="ln290">  int i, j;</a>
<a name="ln291">  int p_sw = get_sw_value(curbuf);</a>
<a name="ln292"> </a>
<a name="ln293">  count = get_indent();  // get current indent</a>
<a name="ln294"> </a>
<a name="ln295">  if (round) {  // round off indent</a>
<a name="ln296">    i = count / p_sw;  // number of p_sw rounded down</a>
<a name="ln297">    j = count % p_sw;  // extra spaces</a>
<a name="ln298">    if (j &amp;&amp; left) {  // first remove extra spaces</a>
<a name="ln299">      amount--;</a>
<a name="ln300">    }</a>
<a name="ln301">    if (left) {</a>
<a name="ln302">      i -= amount;</a>
<a name="ln303">      if (i &lt; 0)</a>
<a name="ln304">        i = 0;</a>
<a name="ln305">    } else</a>
<a name="ln306">      i += amount;</a>
<a name="ln307">    count = i * p_sw;</a>
<a name="ln308">  } else {  // original vi indent</a>
<a name="ln309">    if (left) {</a>
<a name="ln310">      count -= p_sw * amount;</a>
<a name="ln311">      if (count &lt; 0)</a>
<a name="ln312">        count = 0;</a>
<a name="ln313">    } else</a>
<a name="ln314">      count += p_sw * amount;</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  // Set new indent</a>
<a name="ln318">  if (State &amp; VREPLACE_FLAG) {</a>
<a name="ln319">    change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);</a>
<a name="ln320">  } else {</a>
<a name="ln321">    (void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);</a>
<a name="ln322">  }</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">/*</a>
<a name="ln326"> * Shift one line of the current block one shiftwidth right or left.</a>
<a name="ln327"> * Leaves cursor on first character in block.</a>
<a name="ln328"> */</a>
<a name="ln329">static void shift_block(oparg_T *oap, int amount)</a>
<a name="ln330">{</a>
<a name="ln331">  const bool left = (oap-&gt;op_type == OP_LSHIFT);</a>
<a name="ln332">  const int oldstate = State;</a>
<a name="ln333">  char_u *newp;</a>
<a name="ln334">  const int oldcol = curwin-&gt;w_cursor.col;</a>
<a name="ln335">  const int p_sw = get_sw_value(curbuf);</a>
<a name="ln336">  const int p_ts = (int)curbuf-&gt;b_p_ts;</a>
<a name="ln337">  struct block_def bd;</a>
<a name="ln338">  int incr;</a>
<a name="ln339">  int i = 0, j = 0;</a>
<a name="ln340">  const int old_p_ri = p_ri;</a>
<a name="ln341"> </a>
<a name="ln342">  p_ri = 0;                     /* don't want revins in indent */</a>
<a name="ln343"> </a>
<a name="ln344">  State = INSERT;               // don't want REPLACE for State</a>
<a name="ln345">  block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln346">  if (bd.is_short) {</a>
<a name="ln347">    return;</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  // total is number of screen columns to be inserted/removed</a>
<a name="ln351">  int total = (int)((unsigned)amount * (unsigned)p_sw);</a>
<a name="ln352">  if ((total / p_sw) != amount) {</a>
<a name="ln353">    return;   // multiplication overflow</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  char_u *const oldp = get_cursor_line_ptr();</a>
<a name="ln357"> </a>
<a name="ln358">  int startcol, oldlen, newlen;</a>
<a name="ln359"> </a>
<a name="ln360">  if (!left) {</a>
<a name="ln361">    /*</a>
<a name="ln362">     *  1. Get start vcol</a>
<a name="ln363">     *  2. Total ws vcols</a>
<a name="ln364">     *  3. Divvy into TABs &amp; spp</a>
<a name="ln365">     *  4. Construct new string</a>
<a name="ln366">     */</a>
<a name="ln367">    total += bd.pre_whitesp;    // all virtual WS up to &amp; incl a split TAB</a>
<a name="ln368">    colnr_T ws_vcol = bd.start_vcol - bd.pre_whitesp;</a>
<a name="ln369">    char_u * old_textstart = bd.textstart;</a>
<a name="ln370">    if (bd.startspaces) {</a>
<a name="ln371">      if (utfc_ptr2len(bd.textstart) == 1) {</a>
<a name="ln372">        bd.textstart++;</a>
<a name="ln373">      } else {</a>
<a name="ln374">        ws_vcol = 0;</a>
<a name="ln375">        bd.startspaces = 0;</a>
<a name="ln376">      }</a>
<a name="ln377">    }</a>
<a name="ln378">    for (; ascii_iswhite(*bd.textstart); ) {</a>
<a name="ln379">      // TODO: is passing bd.textstart for start of the line OK?</a>
<a name="ln380">      incr = lbr_chartabsize_adv(bd.textstart, &amp;bd.textstart, (colnr_T)(bd.start_vcol));</a>
<a name="ln381">      total += incr;</a>
<a name="ln382">      bd.start_vcol += incr;</a>
<a name="ln383">    }</a>
<a name="ln384">    /* OK, now total=all the VWS reqd, and textstart points at the 1st</a>
<a name="ln385">     * non-ws char in the block. */</a>
<a name="ln386">    if (!curbuf-&gt;b_p_et)</a>
<a name="ln387">      i = ((ws_vcol % p_ts) + total) / p_ts;       /* number of tabs */</a>
<a name="ln388">    if (i)</a>
<a name="ln389">      j = ((ws_vcol % p_ts) + total) % p_ts;       /* number of spp */</a>
<a name="ln390">    else</a>
<a name="ln391">      j = total;</a>
<a name="ln392"> </a>
<a name="ln393">    // if we're splitting a TAB, allow for it</a>
<a name="ln394">    int col_pre = bd.pre_whitesp_c - (bd.startspaces != 0);</a>
<a name="ln395">    bd.textcol -= col_pre;</a>
<a name="ln396">    const int len = (int)STRLEN(bd.textstart) + 1;</a>
<a name="ln397">    int col = bd.textcol + i +j + len;</a>
<a name="ln398">    assert(col &gt;= 0);</a>
<a name="ln399">    newp = (char_u *)xmalloc((size_t)col);</a>
<a name="ln400">    memset(newp, NUL, (size_t)col);</a>
<a name="ln401">    memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln402">    startcol = bd.textcol;</a>
<a name="ln403">    oldlen = (int)(bd.textstart-old_textstart) + col_pre;</a>
<a name="ln404">    newlen = i+j;</a>
<a name="ln405">    memset(newp + bd.textcol, TAB, (size_t)i);</a>
<a name="ln406">    memset(newp + bd.textcol + i, ' ', (size_t)j);</a>
<a name="ln407">    /* the end */</a>
<a name="ln408">    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);</a>
<a name="ln409">  } else {  // left</a>
<a name="ln410">    colnr_T destination_col;      // column to which text in block will</a>
<a name="ln411">                                  // be shifted</a>
<a name="ln412">    char_u *verbatim_copy_end;    // end of the part of the line which is</a>
<a name="ln413">                                  // copied verbatim</a>
<a name="ln414">    colnr_T verbatim_copy_width;  // the (displayed) width of this part</a>
<a name="ln415">                                  // of line</a>
<a name="ln416">    size_t fill;                  // nr of spaces that replace a TAB</a>
<a name="ln417">    size_t new_line_len;          // the length of the line after the</a>
<a name="ln418">                                  // block shift</a>
<a name="ln419">    char_u      *non_white = bd.textstart;</a>
<a name="ln420"> </a>
<a name="ln421">    /*</a>
<a name="ln422">     * Firstly, let's find the first non-whitespace character that is</a>
<a name="ln423">     * displayed after the block's start column and the character's column</a>
<a name="ln424">     * number. Also, let's calculate the width of all the whitespace</a>
<a name="ln425">     * characters that are displayed in the block and precede the searched</a>
<a name="ln426">     * non-whitespace character.</a>
<a name="ln427">     */</a>
<a name="ln428"> </a>
<a name="ln429">    /* If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character,</a>
<a name="ln430">     * the part of which is displayed at the block's beginning. Let's start</a>
<a name="ln431">     * searching from the next character. */</a>
<a name="ln432">    if (bd.startspaces) {</a>
<a name="ln433">      MB_PTR_ADV(non_white);</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    // The character's column is in &quot;bd.start_vcol&quot;.</a>
<a name="ln437">    colnr_T non_white_col = bd.start_vcol;</a>
<a name="ln438"> </a>
<a name="ln439">    while (ascii_iswhite(*non_white)) {</a>
<a name="ln440">      incr = lbr_chartabsize_adv(bd.textstart, &amp;non_white, non_white_col);</a>
<a name="ln441">      non_white_col += incr;</a>
<a name="ln442">    }</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">    const colnr_T block_space_width = non_white_col - oap-&gt;start_vcol;</a>
<a name="ln446">    // We will shift by &quot;total&quot; or &quot;block_space_width&quot;, whichever is less.</a>
<a name="ln447">    const colnr_T shift_amount = block_space_width &lt; total</a>
<a name="ln448">        ? block_space_width</a>
<a name="ln449">        : total;</a>
<a name="ln450">    // The column to which we will shift the text.</a>
<a name="ln451">    destination_col = non_white_col - shift_amount;</a>
<a name="ln452"> </a>
<a name="ln453">    /* Now let's find out how much of the beginning of the line we can</a>
<a name="ln454">     * reuse without modification.  */</a>
<a name="ln455">    verbatim_copy_end = bd.textstart;</a>
<a name="ln456">    verbatim_copy_width = bd.start_vcol;</a>
<a name="ln457"> </a>
<a name="ln458">    /* If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character</a>
<a name="ln459">     * preceding the block. We have to subtract its width to obtain its</a>
<a name="ln460">     * column number.  */</a>
<a name="ln461">    if (bd.startspaces)</a>
<a name="ln462">      verbatim_copy_width -= bd.start_char_vcols;</a>
<a name="ln463">    while (verbatim_copy_width &lt; destination_col) {</a>
<a name="ln464">      char_u *line = verbatim_copy_end;</a>
<a name="ln465"> </a>
<a name="ln466">      // TODO: is passing verbatim_copy_end for start of the line OK?</a>
<a name="ln467">      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);</a>
<a name="ln468">      if (verbatim_copy_width + incr &gt; destination_col)</a>
<a name="ln469">        break;</a>
<a name="ln470">      verbatim_copy_width += incr;</a>
<a name="ln471">      MB_PTR_ADV(verbatim_copy_end);</a>
<a name="ln472">    }</a>
<a name="ln473"> </a>
<a name="ln474">    /* If &quot;destination_col&quot; is different from the width of the initial</a>
<a name="ln475">    * part of the line that will be copied, it means we encountered a tab</a>
<a name="ln476">    * character, which we will have to partly replace with spaces.  */</a>
<a name="ln477">    assert(destination_col - verbatim_copy_width &gt;= 0);</a>
<a name="ln478">    fill = (size_t)(destination_col - verbatim_copy_width);</a>
<a name="ln479"> </a>
<a name="ln480">    assert(verbatim_copy_end - oldp &gt;= 0);</a>
<a name="ln481">    const size_t verbatim_diff = (size_t)(verbatim_copy_end - oldp);</a>
<a name="ln482">    // The replacement line will consist of:</a>
<a name="ln483">    // - the beginning of the original line up to &quot;verbatim_copy_end&quot;,</a>
<a name="ln484">    // - &quot;fill&quot; number of spaces,</a>
<a name="ln485">    // - the rest of the line, pointed to by non_white.</a>
<a name="ln486">    new_line_len = verbatim_diff + fill + STRLEN(non_white) + 1;</a>
<a name="ln487"> </a>
<a name="ln488">    newp = (char_u *)xmalloc(new_line_len);</a>
<a name="ln489">    startcol = (int)verbatim_diff;</a>
<a name="ln490">    oldlen = bd.textcol + (int)(non_white - bd.textstart) - (int)verbatim_diff;</a>
<a name="ln491">    newlen = (int)fill;</a>
<a name="ln492">    memmove(newp, oldp, verbatim_diff);</a>
<a name="ln493">    memset(newp + verbatim_diff, ' ', fill);</a>
<a name="ln494">    STRMOVE(newp + verbatim_diff + fill, non_white);</a>
<a name="ln495">  }</a>
<a name="ln496">  // replace the line</a>
<a name="ln497">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln498">  changed_bytes(curwin-&gt;w_cursor.lnum, (colnr_T)bd.textcol);</a>
<a name="ln499">  extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum-1, startcol,</a>
<a name="ln500">                      oldlen, newlen,</a>
<a name="ln501">                      kExtmarkUndo);</a>
<a name="ln502">  State = oldstate;</a>
<a name="ln503">  curwin-&gt;w_cursor.col = oldcol;</a>
<a name="ln504">  p_ri = old_p_ri;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">/*</a>
<a name="ln508"> * Insert string &quot;s&quot; (b_insert ? before : after) block :AKelly</a>
<a name="ln509"> * Caller must prepare for undo.</a>
<a name="ln510"> */</a>
<a name="ln511">static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)</a>
<a name="ln512">{</a>
<a name="ln513">  int p_ts;</a>
<a name="ln514">  int count = 0;                // extra spaces to replace a cut TAB</a>
<a name="ln515">  int spaces = 0;               // non-zero if cutting a TAB</a>
<a name="ln516">  colnr_T offset;               // pointer along new line</a>
<a name="ln517">  size_t s_len = STRLEN(s);</a>
<a name="ln518">  char_u      *newp, *oldp;     // new, old lines</a>
<a name="ln519">  linenr_T lnum;                // loop var</a>
<a name="ln520">  int oldstate = State;</a>
<a name="ln521">  State = INSERT;               // don't want REPLACE for State</a>
<a name="ln522"> </a>
<a name="ln523">  for (lnum = oap-&gt;start.lnum + 1; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln524">    block_prep(oap, bdp, lnum, true);</a>
<a name="ln525">    if (bdp-&gt;is_short &amp;&amp; b_insert) {</a>
<a name="ln526">      continue;  // OP_INSERT, line ends before block start</a>
<a name="ln527">    }</a>
<a name="ln528"> </a>
<a name="ln529">    oldp = ml_get(lnum);</a>
<a name="ln530"> </a>
<a name="ln531">    if (b_insert) {</a>
<a name="ln532">      p_ts = bdp-&gt;start_char_vcols;</a>
<a name="ln533">      spaces = bdp-&gt;startspaces;</a>
<a name="ln534">      if (spaces != 0)</a>
<a name="ln535">        count = p_ts - 1;         /* we're cutting a TAB */</a>
<a name="ln536">      offset = bdp-&gt;textcol;</a>
<a name="ln537">    } else { /* append */</a>
<a name="ln538">      p_ts = bdp-&gt;end_char_vcols;</a>
<a name="ln539">      if (!bdp-&gt;is_short) {     /* spaces = padding after block */</a>
<a name="ln540">        spaces = (bdp-&gt;endspaces ? p_ts - bdp-&gt;endspaces : 0);</a>
<a name="ln541">        if (spaces != 0)</a>
<a name="ln542">          count = p_ts - 1;           /* we're cutting a TAB */</a>
<a name="ln543">        offset = bdp-&gt;textcol + bdp-&gt;textlen - (spaces != 0);</a>
<a name="ln544">      } else { /* spaces = padding to block edge */</a>
<a name="ln545">                 /* if $ used, just append to EOL (ie spaces==0) */</a>
<a name="ln546">        if (!bdp-&gt;is_MAX)</a>
<a name="ln547">          spaces = (oap-&gt;end_vcol - bdp-&gt;end_vcol) + 1;</a>
<a name="ln548">        count = spaces;</a>
<a name="ln549">        offset = bdp-&gt;textcol + bdp-&gt;textlen;</a>
<a name="ln550">      }</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    if (spaces &gt; 0) {</a>
<a name="ln554">      int off;</a>
<a name="ln555"> </a>
<a name="ln556">      // Avoid starting halfway through a multi-byte character.</a>
<a name="ln557">      if (b_insert) {</a>
<a name="ln558">        off = utf_head_off(oldp, oldp + offset + spaces);</a>
<a name="ln559">      } else {</a>
<a name="ln560">        off = (*mb_off_next)(oldp, oldp + offset);</a>
<a name="ln561">        offset += off;</a>
<a name="ln562">      }</a>
<a name="ln563">      spaces -= off;</a>
<a name="ln564">      count -= off;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    assert(count &gt;= 0);</a>
<a name="ln568">    newp = (char_u *)xmalloc(STRLEN(oldp) + s_len + (size_t)count + 1);</a>
<a name="ln569"> </a>
<a name="ln570">    // copy up to shifted part</a>
<a name="ln571">    memmove(newp, oldp, (size_t)offset);</a>
<a name="ln572">    oldp += offset;</a>
<a name="ln573">    int startcol = offset;</a>
<a name="ln574"> </a>
<a name="ln575">    // insert pre-padding</a>
<a name="ln576">    memset(newp + offset, ' ', (size_t)spaces);</a>
<a name="ln577"> </a>
<a name="ln578">    // copy the new text</a>
<a name="ln579">    memmove(newp + offset + spaces, s, s_len);</a>
<a name="ln580">    offset += (int)s_len;</a>
<a name="ln581"> </a>
<a name="ln582">    int skipped = 0;</a>
<a name="ln583">    if (spaces &amp;&amp; !bdp-&gt;is_short) {</a>
<a name="ln584">      // insert post-padding</a>
<a name="ln585">      memset(newp + offset + spaces, ' ', (size_t)(p_ts - spaces));</a>
<a name="ln586">      // We're splitting a TAB, don't copy it.</a>
<a name="ln587">      oldp++;</a>
<a name="ln588">      // We allowed for that TAB, remember this now</a>
<a name="ln589">      count++;</a>
<a name="ln590">      skipped = 1;</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    if (spaces &gt; 0)</a>
<a name="ln594">      offset += count;</a>
<a name="ln595">    STRMOVE(newp + offset, oldp);</a>
<a name="ln596"> </a>
<a name="ln597">    ml_replace(lnum, newp, false);</a>
<a name="ln598">    extmark_splice_cols(curbuf, (int)lnum-1, startcol,</a>
<a name="ln599">                        skipped, offset-startcol, kExtmarkUndo);</a>
<a name="ln600"> </a>
<a name="ln601">    if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln602">      /* Set &quot;']&quot; mark to the end of the block instead of the end of</a>
<a name="ln603">       * the insert in the first line.  */</a>
<a name="ln604">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln605">      curbuf-&gt;b_op_end.col = offset;</a>
<a name="ln606">    }</a>
<a name="ln607">  }   /* for all lnum */</a>
<a name="ln608"> </a>
<a name="ln609">  changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln610"> </a>
<a name="ln611">  State = oldstate;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">/*</a>
<a name="ln615"> * op_reindent - handle reindenting a block of lines.</a>
<a name="ln616"> */</a>
<a name="ln617">void op_reindent(oparg_T *oap, Indenter how)</a>
<a name="ln618">{</a>
<a name="ln619">  long i;</a>
<a name="ln620">  char_u      *l;</a>
<a name="ln621">  int amount;</a>
<a name="ln622">  linenr_T first_changed = 0;</a>
<a name="ln623">  linenr_T last_changed = 0;</a>
<a name="ln624">  linenr_T start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln625"> </a>
<a name="ln626">  /* Don't even try when 'modifiable' is off. */</a>
<a name="ln627">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln628">    EMSG(_(e_modifiable));</a>
<a name="ln629">    return;</a>
<a name="ln630">  }</a>
<a name="ln631"> </a>
<a name="ln632">  for (i = oap-&gt;line_count - 1; i &gt;= 0 &amp;&amp; !got_int; i--) {</a>
<a name="ln633">    /* it's a slow thing to do, so give feedback so there's no worry that</a>
<a name="ln634">     * the computer's just hung. */</a>
<a name="ln635"> </a>
<a name="ln636">    if (i &gt; 1</a>
<a name="ln637">        &amp;&amp; (i % 50 == 0 || i == oap-&gt;line_count - 1)</a>
<a name="ln638">        &amp;&amp; oap-&gt;line_count &gt; p_report)</a>
<a name="ln639">      smsg(_(&quot;%&quot; PRId64 &quot; lines to indent... &quot;), (int64_t)i);</a>
<a name="ln640"> </a>
<a name="ln641">    /*</a>
<a name="ln642">     * Be vi-compatible: For lisp indenting the first line is not</a>
<a name="ln643">     * indented, unless there is only one line.</a>
<a name="ln644">     */</a>
<a name="ln645">    if (i != oap-&gt;line_count - 1 || oap-&gt;line_count == 1</a>
<a name="ln646">        || how != get_lisp_indent) {</a>
<a name="ln647">      l = skipwhite(get_cursor_line_ptr());</a>
<a name="ln648">      if (*l == NUL)                        /* empty or blank line */</a>
<a name="ln649">        amount = 0;</a>
<a name="ln650">      else</a>
<a name="ln651">        amount = how();                     /* get the indent for this line */</a>
<a name="ln652"> </a>
<a name="ln653">      if (amount &gt;= 0 &amp;&amp; set_indent(amount, SIN_UNDO)) {</a>
<a name="ln654">        // did change the indent, call changed_lines() later</a>
<a name="ln655">        if (first_changed == 0) {</a>
<a name="ln656">          first_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln657">        }</a>
<a name="ln658">        last_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln659">      }</a>
<a name="ln660">    }</a>
<a name="ln661">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln662">    curwin-&gt;w_cursor.col = 0;      /* make sure it's valid */</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  /* put cursor on first non-blank of indented line */</a>
<a name="ln666">  curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln667">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln668"> </a>
<a name="ln669">  /* Mark changed lines so that they will be redrawn.  When Visual</a>
<a name="ln670">   * highlighting was present, need to continue until the last line.  When</a>
<a name="ln671">   * there is no change still need to remove the Visual highlighting. */</a>
<a name="ln672">  if (last_changed != 0) {</a>
<a name="ln673">    changed_lines(first_changed, 0,</a>
<a name="ln674">                  oap-&gt;is_VIsual ? start_lnum + oap-&gt;line_count :</a>
<a name="ln675">                  last_changed + 1, 0L, true);</a>
<a name="ln676">  } else if (oap-&gt;is_VIsual) {</a>
<a name="ln677">    redraw_curbuf_later(INVERTED);</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln681">    i = oap-&gt;line_count - (i + 1);</a>
<a name="ln682">    if (i == 1)</a>
<a name="ln683">      MSG(_(&quot;1 line indented &quot;));</a>
<a name="ln684">    else</a>
<a name="ln685">      smsg(_(&quot;%&quot; PRId64 &quot; lines indented &quot;), (int64_t)i);</a>
<a name="ln686">  }</a>
<a name="ln687">  /* set '[ and '] marks */</a>
<a name="ln688">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln689">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">/*</a>
<a name="ln693"> * Keep the last expression line here, for repeating.</a>
<a name="ln694"> */</a>
<a name="ln695">static char_u   *expr_line = NULL;</a>
<a name="ln696"> </a>
<a name="ln697">/*</a>
<a name="ln698"> * Get an expression for the &quot;\&quot;=expr1&quot; or &quot;CTRL-R =expr1&quot;</a>
<a name="ln699"> * Returns '=' when OK, NUL otherwise.</a>
<a name="ln700"> */</a>
<a name="ln701">int get_expr_register(void)</a>
<a name="ln702">{</a>
<a name="ln703">  char_u      *new_line;</a>
<a name="ln704"> </a>
<a name="ln705">  new_line = getcmdline('=', 0L, 0, true);</a>
<a name="ln706">  if (new_line == NULL) {</a>
<a name="ln707">    return NUL;</a>
<a name="ln708">  }</a>
<a name="ln709">  if (*new_line == NUL) {  // use previous line</a>
<a name="ln710">    xfree(new_line);</a>
<a name="ln711">  } else {</a>
<a name="ln712">    set_expr_line(new_line);</a>
<a name="ln713">  }</a>
<a name="ln714">  return '=';</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">/*</a>
<a name="ln718"> * Set the expression for the '=' register.</a>
<a name="ln719"> * Argument must be an allocated string.</a>
<a name="ln720"> */</a>
<a name="ln721">void set_expr_line(char_u *new_line)</a>
<a name="ln722">{</a>
<a name="ln723">  xfree(expr_line);</a>
<a name="ln724">  expr_line = new_line;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">/*</a>
<a name="ln728"> * Get the result of the '=' register expression.</a>
<a name="ln729"> * Returns a pointer to allocated memory, or NULL for failure.</a>
<a name="ln730"> */</a>
<a name="ln731">char_u *get_expr_line(void)</a>
<a name="ln732">{</a>
<a name="ln733">  char_u      *expr_copy;</a>
<a name="ln734">  char_u      *rv;</a>
<a name="ln735">  static int nested = 0;</a>
<a name="ln736"> </a>
<a name="ln737">  if (expr_line == NULL)</a>
<a name="ln738">    return NULL;</a>
<a name="ln739"> </a>
<a name="ln740">  /* Make a copy of the expression, because evaluating it may cause it to be</a>
<a name="ln741">   * changed. */</a>
<a name="ln742">  expr_copy = vim_strsave(expr_line);</a>
<a name="ln743"> </a>
<a name="ln744">  /* When we are invoked recursively limit the evaluation to 10 levels.</a>
<a name="ln745">   * Then return the string as-is. */</a>
<a name="ln746">  if (nested &gt;= 10)</a>
<a name="ln747">    return expr_copy;</a>
<a name="ln748"> </a>
<a name="ln749">  ++nested;</a>
<a name="ln750">  rv = eval_to_string(expr_copy, NULL, TRUE);</a>
<a name="ln751">  --nested;</a>
<a name="ln752">  xfree(expr_copy);</a>
<a name="ln753">  return rv;</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/*</a>
<a name="ln757"> * Get the '=' register expression itself, without evaluating it.</a>
<a name="ln758"> */</a>
<a name="ln759">char_u *get_expr_line_src(void)</a>
<a name="ln760">{</a>
<a name="ln761">  if (expr_line == NULL)</a>
<a name="ln762">    return NULL;</a>
<a name="ln763">  return vim_strsave(expr_line);</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">/// Returns whether `regname` is a valid name of a yank register.</a>
<a name="ln767">/// Note: There is no check for 0 (default register), caller should do this.</a>
<a name="ln768">/// The black hole register '_' is regarded as valid.</a>
<a name="ln769">///</a>
<a name="ln770">/// @param regname name of register</a>
<a name="ln771">/// @param writing allow only writable registers</a>
<a name="ln772">bool valid_yank_reg(int regname, bool writing)</a>
<a name="ln773">{</a>
<a name="ln774">  if ((regname &gt; 0 &amp;&amp; ASCII_ISALNUM(regname))</a>
<a name="ln775">      || (!writing &amp;&amp; vim_strchr((char_u *) &quot;/.%:=&quot; , regname) != NULL)</a>
<a name="ln776">      || regname == '#'</a>
<a name="ln777">      || regname == '&quot;'</a>
<a name="ln778">      || regname == '-'</a>
<a name="ln779">      || regname == '_'</a>
<a name="ln780">      || regname == '*'</a>
<a name="ln781">      || regname == '+') {</a>
<a name="ln782">    return true;</a>
<a name="ln783">  }</a>
<a name="ln784">  return false;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">typedef enum {</a>
<a name="ln788">  YREG_PASTE,</a>
<a name="ln789">  YREG_YANK,</a>
<a name="ln790">  YREG_PUT,</a>
<a name="ln791">} yreg_mode_t;</a>
<a name="ln792"> </a>
<a name="ln793">/// Return yankreg_T to use, according to the value of `regname`.</a>
<a name="ln794">/// Cannot handle the '_' (black hole) register.</a>
<a name="ln795">/// Must only be called with a valid register name!</a>
<a name="ln796">///</a>
<a name="ln797">/// @param regname The name of the register used or 0 for the unnamed register</a>
<a name="ln798">/// @param mode One of the following three flags:</a>
<a name="ln799">///</a>
<a name="ln800">/// `YREG_PASTE`:</a>
<a name="ln801">/// Prepare for pasting the register `regname`. With no regname specified,</a>
<a name="ln802">/// read from last written register, or from unnamed clipboard (depending on the</a>
<a name="ln803">/// `clipboard=unnamed` option). Queries the clipboard provider if necessary.</a>
<a name="ln804">///</a>
<a name="ln805">/// `YREG_YANK`:</a>
<a name="ln806">/// Preparare for yanking into `regname`. With no regname specified,</a>
<a name="ln807">/// yank into `&quot;0` register. Update `y_previous` for next unnamed paste.</a>
<a name="ln808">///</a>
<a name="ln809">/// `YREG_PUT`:</a>
<a name="ln810">/// Obtain the location that would be read when pasting `regname`.</a>
<a name="ln811">yankreg_T *get_yank_register(int regname, int mode)</a>
<a name="ln812">{</a>
<a name="ln813">  yankreg_T *reg;</a>
<a name="ln814"> </a>
<a name="ln815">  if (mode == YREG_PASTE &amp;&amp; get_clipboard(regname, &amp;reg, false)) {</a>
<a name="ln816">    // reg is set to clipboard contents.</a>
<a name="ln817">    return reg;</a>
<a name="ln818">  } else if (mode != YREG_YANK</a>
<a name="ln819">      &amp;&amp; (regname == 0 || regname == '&quot;' || regname == '*' || regname == '+')</a>
<a name="ln820">      &amp;&amp; y_previous != NULL) {</a>
<a name="ln821">    // in case clipboard not available, paste from previous used register</a>
<a name="ln822">    return y_previous;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  int i = op_reg_index(regname);</a>
<a name="ln826">  // when not 0-9, a-z, A-Z or '-'/'+'/'*': use register 0</a>
<a name="ln827">  if (i == -1) {</a>
<a name="ln828">    i = 0;</a>
<a name="ln829">  }</a>
<a name="ln830">  reg = &amp;y_regs[i];</a>
<a name="ln831"> </a>
<a name="ln832">  if (mode == YREG_YANK) {</a>
<a name="ln833">    // remember the written register for unnamed paste</a>
<a name="ln834">    y_previous = reg;</a>
<a name="ln835">  }</a>
<a name="ln836">  return reg;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">static bool is_append_register(int regname)</a>
<a name="ln840">{</a>
<a name="ln841">  return ASCII_ISUPPER(regname);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">/// @see get_yank_register</a>
<a name="ln845">/// @returns true when register should be inserted literally</a>
<a name="ln846">/// (selection or clipboard)</a>
<a name="ln847">static inline bool is_literal_register(int regname)</a>
<a name="ln848">  FUNC_ATTR_CONST</a>
<a name="ln849">{</a>
<a name="ln850">  return regname == '*' || regname == '+';</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">/// Returns a copy of contents in register `name`</a>
<a name="ln854">/// for use in do_put. Should be freed by caller.</a>
<a name="ln855">yankreg_T *copy_register(int name)</a>
<a name="ln856">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln857">{</a>
<a name="ln858">  yankreg_T *reg = get_yank_register(name, YREG_PASTE);</a>
<a name="ln859"> </a>
<a name="ln860">  yankreg_T *copy = xmalloc(sizeof(yankreg_T));</a>
<a name="ln861">  *copy = *reg;</a>
<a name="ln862">  if (copy-&gt;y_size == 0) {</a>
<a name="ln863">    copy-&gt;y_array = NULL;</a>
<a name="ln864">  } else {</a>
<a name="ln865">    copy-&gt;y_array = xcalloc(copy-&gt;y_size, sizeof(char_u *));</a>
<a name="ln866">    for (size_t i = 0; i &lt; copy-&gt;y_size; i++) {</a>
<a name="ln867">      copy-&gt;y_array[i] = vim_strsave(reg-&gt;y_array[i]);</a>
<a name="ln868">    }</a>
<a name="ln869">  }</a>
<a name="ln870">  return copy;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// check if the current yank register has kMTLineWise register type</a>
<a name="ln874">bool yank_register_mline(int regname)</a>
<a name="ln875">{</a>
<a name="ln876">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln877">    return false;</a>
<a name="ln878">  }</a>
<a name="ln879">  if (regname == '_') {  // black hole is always empty</a>
<a name="ln880">    return false;</a>
<a name="ln881">  }</a>
<a name="ln882">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln883">  return reg-&gt;y_type == kMTLineWise;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">/*</a>
<a name="ln887"> * Start or stop recording into a yank register.</a>
<a name="ln888"> *</a>
<a name="ln889"> * Return FAIL for failure, OK otherwise.</a>
<a name="ln890"> */</a>
<a name="ln891">int do_record(int c)</a>
<a name="ln892">{</a>
<a name="ln893">  char_u          *p;</a>
<a name="ln894">  static int regname;</a>
<a name="ln895">  yankreg_T  *old_y_previous;</a>
<a name="ln896">  int retval;</a>
<a name="ln897"> </a>
<a name="ln898">  if (reg_recording == 0) {</a>
<a name="ln899">    // start recording</a>
<a name="ln900">    // registers 0-9, a-z and &quot; are allowed</a>
<a name="ln901">    if (c &lt; 0 || (!ASCII_ISALNUM(c) &amp;&amp; c != '&quot;')) {</a>
<a name="ln902">      retval = FAIL;</a>
<a name="ln903">    } else {</a>
<a name="ln904">      reg_recording = c;</a>
<a name="ln905">      showmode();</a>
<a name="ln906">      regname = c;</a>
<a name="ln907">      retval = OK;</a>
<a name="ln908">    }</a>
<a name="ln909">  } else {                        /* stop recording */</a>
<a name="ln910">    /*</a>
<a name="ln911">     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this</a>
<a name="ln912">     * needs to be removed again to put it in a register.  exec_reg then</a>
<a name="ln913">     * adds the escaping back later.</a>
<a name="ln914">     */</a>
<a name="ln915">    reg_recording = 0;</a>
<a name="ln916">    if (ui_has(kUIMessages)) {</a>
<a name="ln917">      showmode();</a>
<a name="ln918">    } else {</a>
<a name="ln919">      MSG(&quot;&quot;);</a>
<a name="ln920">    }</a>
<a name="ln921">    p = get_recorded();</a>
<a name="ln922">    if (p == NULL)</a>
<a name="ln923">      retval = FAIL;</a>
<a name="ln924">    else {</a>
<a name="ln925">      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */</a>
<a name="ln926">      vim_unescape_csi(p);</a>
<a name="ln927"> </a>
<a name="ln928">      /*</a>
<a name="ln929">       * We don't want to change the default register here, so save and</a>
<a name="ln930">       * restore the current register name.</a>
<a name="ln931">       */</a>
<a name="ln932">      old_y_previous = y_previous;</a>
<a name="ln933"> </a>
<a name="ln934">      retval = stuff_yank(regname, p);</a>
<a name="ln935"> </a>
<a name="ln936">      y_previous = old_y_previous;</a>
<a name="ln937">    }</a>
<a name="ln938">  }</a>
<a name="ln939">  return retval;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">static void set_yreg_additional_data(yankreg_T *reg, dict_T *additional_data)</a>
<a name="ln943">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln944">{</a>
<a name="ln945">  if (reg-&gt;additional_data == additional_data) {</a>
<a name="ln946">    return;</a>
<a name="ln947">  }</a>
<a name="ln948">  tv_dict_unref(reg-&gt;additional_data);</a>
<a name="ln949">  reg-&gt;additional_data = additional_data;</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/*</a>
<a name="ln953"> * Stuff string &quot;p&quot; into yank register &quot;regname&quot; as a single line (append if</a>
<a name="ln954"> * uppercase). &quot;p&quot; must have been alloced.</a>
<a name="ln955"> *</a>
<a name="ln956"> * return FAIL for failure, OK otherwise</a>
<a name="ln957"> */</a>
<a name="ln958">static int stuff_yank(int regname, char_u *p)</a>
<a name="ln959">{</a>
<a name="ln960">  /* check for read-only register */</a>
<a name="ln961">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, true)) {</a>
<a name="ln962">    xfree(p);</a>
<a name="ln963">    return FAIL;</a>
<a name="ln964">  }</a>
<a name="ln965">  if (regname == '_') {             /* black hole: don't do anything */</a>
<a name="ln966">    xfree(p);</a>
<a name="ln967">    return OK;</a>
<a name="ln968">  }</a>
<a name="ln969">  yankreg_T *reg = get_yank_register(regname, YREG_YANK);</a>
<a name="ln970">  if (is_append_register(regname) &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln971">    char_u **pp = &amp;(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln972">    char_u *lp = xmalloc(STRLEN(*pp) + STRLEN(p) + 1);</a>
<a name="ln973">    STRCPY(lp, *pp);</a>
<a name="ln974">    // TODO(philix): use xstpcpy() in stuff_yank()</a>
<a name="ln975">    STRCAT(lp, p);</a>
<a name="ln976">    xfree(p);</a>
<a name="ln977">    xfree(*pp);</a>
<a name="ln978">    *pp = lp;</a>
<a name="ln979">  } else {</a>
<a name="ln980">    free_register(reg);</a>
<a name="ln981">    set_yreg_additional_data(reg, NULL);</a>
<a name="ln982">    reg-&gt;y_array = (char_u **)xmalloc(sizeof(char_u *));</a>
<a name="ln983">    reg-&gt;y_array[0] = p;</a>
<a name="ln984">    reg-&gt;y_size = 1;</a>
<a name="ln985">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln986">  }</a>
<a name="ln987">  reg-&gt;timestamp = os_time();</a>
<a name="ln988">  return OK;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static int execreg_lastc = NUL;</a>
<a name="ln992"> </a>
<a name="ln993">/// Execute a yank register: copy it into the stuff buffer</a>
<a name="ln994">///</a>
<a name="ln995">/// Return FAIL for failure, OK otherwise</a>
<a name="ln996">int</a>
<a name="ln997">do_execreg(</a>
<a name="ln998">    int regname,</a>
<a name="ln999">    int colon,                      /* insert ':' before each line */</a>
<a name="ln1000">    int addcr,                      /* always add '\n' to end of line */</a>
<a name="ln1001">    int silent                     /* set &quot;silent&quot; flag in typeahead buffer */</a>
<a name="ln1002">)</a>
<a name="ln1003">{</a>
<a name="ln1004">  char_u *p;</a>
<a name="ln1005">  int retval = OK;</a>
<a name="ln1006"> </a>
<a name="ln1007">  if (regname == '@') {                 /* repeat previous one */</a>
<a name="ln1008">    if (execreg_lastc == NUL) {</a>
<a name="ln1009">      EMSG(_(&quot;E748: No previously used register&quot;));</a>
<a name="ln1010">      return FAIL;</a>
<a name="ln1011">    }</a>
<a name="ln1012">    regname = execreg_lastc;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  /* check for valid regname */</a>
<a name="ln1015">  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {</a>
<a name="ln1016">    emsg_invreg(regname);</a>
<a name="ln1017">    return FAIL;</a>
<a name="ln1018">  }</a>
<a name="ln1019">  execreg_lastc = regname;</a>
<a name="ln1020"> </a>
<a name="ln1021">  if (regname == '_')                   /* black hole: don't stuff anything */</a>
<a name="ln1022">    return OK;</a>
<a name="ln1023"> </a>
<a name="ln1024">  if (regname == ':') {                 /* use last command line */</a>
<a name="ln1025">    if (last_cmdline == NULL) {</a>
<a name="ln1026">      EMSG(_(e_nolastcmd));</a>
<a name="ln1027">      return FAIL;</a>
<a name="ln1028">    }</a>
<a name="ln1029">    // don't keep the cmdline containing @:</a>
<a name="ln1030">    XFREE_CLEAR(new_last_cmdline);</a>
<a name="ln1031">    // Escape all control characters with a CTRL-V</a>
<a name="ln1032">    p = vim_strsave_escaped_ext(</a>
<a name="ln1033">        last_cmdline,</a>
<a name="ln1034">        (char_u *)&quot;\001\002\003\004\005\006\007&quot;</a>
<a name="ln1035">        &quot;\010\011\012\013\014\015\016\017&quot;</a>
<a name="ln1036">        &quot;\020\021\022\023\024\025\026\027&quot;</a>
<a name="ln1037">        &quot;\030\031\032\033\034\035\036\037&quot;,</a>
<a name="ln1038">        Ctrl_V, false);</a>
<a name="ln1039">    // When in Visual mode &quot;'&lt;,'&gt;&quot; will be prepended to the command.</a>
<a name="ln1040">    // Remove it when it's already there.</a>
<a name="ln1041">    if (VIsual_active &amp;&amp; STRNCMP(p, &quot;'&lt;,'&gt;&quot;, 5) == 0) {</a>
<a name="ln1042">      retval = put_in_typebuf(p + 5, true, true, silent);</a>
<a name="ln1043">    } else {</a>
<a name="ln1044">      retval = put_in_typebuf(p, true, true, silent);</a>
<a name="ln1045">    }</a>
<a name="ln1046">    xfree(p);</a>
<a name="ln1047">  } else if (regname == '=') {</a>
<a name="ln1048">    p = get_expr_line();</a>
<a name="ln1049">    if (p == NULL)</a>
<a name="ln1050">      return FAIL;</a>
<a name="ln1051">    retval = put_in_typebuf(p, true, colon, silent);</a>
<a name="ln1052">    xfree(p);</a>
<a name="ln1053">  } else if (regname == '.') {        /* use last inserted text */</a>
<a name="ln1054">    p = get_last_insert_save();</a>
<a name="ln1055">    if (p == NULL) {</a>
<a name="ln1056">      EMSG(_(e_noinstext));</a>
<a name="ln1057">      return FAIL;</a>
<a name="ln1058">    }</a>
<a name="ln1059">    retval = put_in_typebuf(p, false, colon, silent);</a>
<a name="ln1060">    xfree(p);</a>
<a name="ln1061">  } else {</a>
<a name="ln1062">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1063">    if (reg-&gt;y_array == NULL)</a>
<a name="ln1064">      return FAIL;</a>
<a name="ln1065"> </a>
<a name="ln1066">    // Disallow remaping for &quot;:@r&quot;.</a>
<a name="ln1067">    int remap = colon ? REMAP_NONE : REMAP_YES;</a>
<a name="ln1068"> </a>
<a name="ln1069">    /*</a>
<a name="ln1070">     * Insert lines into typeahead buffer, from last one to first one.</a>
<a name="ln1071">     */</a>
<a name="ln1072">    put_reedit_in_typebuf(silent);</a>
<a name="ln1073">    char_u *escaped;</a>
<a name="ln1074">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln1075">      // insert NL between lines and after last line if type is kMTLineWise</a>
<a name="ln1076">      if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1 || addcr) {</a>
<a name="ln1077">        if (ins_typebuf((char_u *)&quot;\n&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1078">          return FAIL;</a>
<a name="ln1079">        }</a>
<a name="ln1080">      }</a>
<a name="ln1081">      escaped = vim_strsave_escape_csi(reg-&gt;y_array[i]);</a>
<a name="ln1082">      retval = ins_typebuf(escaped, remap, 0, TRUE, silent);</a>
<a name="ln1083">      xfree(escaped);</a>
<a name="ln1084">      if (retval == FAIL)</a>
<a name="ln1085">        return FAIL;</a>
<a name="ln1086">      if (colon &amp;&amp; ins_typebuf((char_u *)&quot;:&quot;, remap, 0, TRUE, silent)</a>
<a name="ln1087">          == FAIL)</a>
<a name="ln1088">        return FAIL;</a>
<a name="ln1089">    }</a>
<a name="ln1090">    reg_executing = regname == 0 ? '&quot;' : regname;  // disable the 'q' command</a>
<a name="ln1091">  }</a>
<a name="ln1092">  return retval;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">/*</a>
<a name="ln1096"> * If &quot;restart_edit&quot; is not zero, put it in the typeahead buffer, so that it's</a>
<a name="ln1097"> * used only after other typeahead has been processed.</a>
<a name="ln1098"> */</a>
<a name="ln1099">static void put_reedit_in_typebuf(int silent)</a>
<a name="ln1100">{</a>
<a name="ln1101">  char_u buf[3];</a>
<a name="ln1102"> </a>
<a name="ln1103">  if (restart_edit != NUL) {</a>
<a name="ln1104">    if (restart_edit == 'V') {</a>
<a name="ln1105">      buf[0] = 'g';</a>
<a name="ln1106">      buf[1] = 'R';</a>
<a name="ln1107">      buf[2] = NUL;</a>
<a name="ln1108">    } else {</a>
<a name="ln1109">      buf[0] = (char_u)(restart_edit == 'I' ? 'i' : restart_edit);</a>
<a name="ln1110">      buf[1] = NUL;</a>
<a name="ln1111">    }</a>
<a name="ln1112">    if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)</a>
<a name="ln1113">      restart_edit = NUL;</a>
<a name="ln1114">  }</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">/*</a>
<a name="ln1118"> * Insert register contents &quot;s&quot; into the typeahead buffer, so that it will be</a>
<a name="ln1119"> * executed again.</a>
<a name="ln1120"> * When &quot;esc&quot; is TRUE it is to be taken literally: Escape CSI characters and</a>
<a name="ln1121"> * no remapping.</a>
<a name="ln1122"> */</a>
<a name="ln1123">static int put_in_typebuf(</a>
<a name="ln1124">    char_u *s,</a>
<a name="ln1125">    bool esc,</a>
<a name="ln1126">    bool colon,                 // add ':' before the line</a>
<a name="ln1127">    int silent</a>
<a name="ln1128">)</a>
<a name="ln1129">{</a>
<a name="ln1130">  int retval = OK;</a>
<a name="ln1131"> </a>
<a name="ln1132">  put_reedit_in_typebuf(silent);</a>
<a name="ln1133">  if (colon)</a>
<a name="ln1134">    retval = ins_typebuf((char_u *)&quot;\n&quot;, REMAP_NONE, 0, TRUE, silent);</a>
<a name="ln1135">  if (retval == OK) {</a>
<a name="ln1136">    char_u  *p;</a>
<a name="ln1137"> </a>
<a name="ln1138">    if (esc)</a>
<a name="ln1139">      p = vim_strsave_escape_csi(s);</a>
<a name="ln1140">    else</a>
<a name="ln1141">      p = s;</a>
<a name="ln1142">    if (p == NULL)</a>
<a name="ln1143">      retval = FAIL;</a>
<a name="ln1144">    else</a>
<a name="ln1145">      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,</a>
<a name="ln1146">          0, TRUE, silent);</a>
<a name="ln1147">    if (esc)</a>
<a name="ln1148">      xfree(p);</a>
<a name="ln1149">  }</a>
<a name="ln1150">  if (colon &amp;&amp; retval == OK)</a>
<a name="ln1151">    retval = ins_typebuf((char_u *)&quot;:&quot;, REMAP_NONE, 0, TRUE, silent);</a>
<a name="ln1152">  return retval;</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">/*</a>
<a name="ln1156"> * Insert a yank register: copy it into the Read buffer.</a>
<a name="ln1157"> * Used by CTRL-R command and middle mouse button in insert mode.</a>
<a name="ln1158"> *</a>
<a name="ln1159"> * return FAIL for failure, OK otherwise</a>
<a name="ln1160"> */</a>
<a name="ln1161">int insert_reg(</a>
<a name="ln1162">    int regname,</a>
<a name="ln1163">    bool literally_arg            // insert literally, not as if typed</a>
<a name="ln1164">)</a>
<a name="ln1165">{</a>
<a name="ln1166">  int retval = OK;</a>
<a name="ln1167">  bool allocated;</a>
<a name="ln1168">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1169"> </a>
<a name="ln1170">  /*</a>
<a name="ln1171">   * It is possible to get into an endless loop by having CTRL-R a in</a>
<a name="ln1172">   * register a and then, in insert mode, doing CTRL-R a.</a>
<a name="ln1173">   * If you hit CTRL-C, the loop will be broken here.</a>
<a name="ln1174">   */</a>
<a name="ln1175">  os_breakcheck();</a>
<a name="ln1176">  if (got_int)</a>
<a name="ln1177">    return FAIL;</a>
<a name="ln1178"> </a>
<a name="ln1179">  /* check for valid regname */</a>
<a name="ln1180">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false))</a>
<a name="ln1181">    return FAIL;</a>
<a name="ln1182"> </a>
<a name="ln1183">  char_u *arg;</a>
<a name="ln1184">  if (regname == '.') {  // Insert last inserted text.</a>
<a name="ln1185">    retval = stuff_inserted(NUL, 1L, true);</a>
<a name="ln1186">  } else if (get_spec_reg(regname, &amp;arg, &amp;allocated, true)) {</a>
<a name="ln1187">    if (arg == NULL) {</a>
<a name="ln1188">      return FAIL;</a>
<a name="ln1189">    }</a>
<a name="ln1190">    stuffescaped((const char *)arg, literally);</a>
<a name="ln1191">    if (allocated) {</a>
<a name="ln1192">      xfree(arg);</a>
<a name="ln1193">    }</a>
<a name="ln1194">  } else {  // Name or number register.</a>
<a name="ln1195">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1196">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1197">      retval = FAIL;</a>
<a name="ln1198">    } else {</a>
<a name="ln1199">      for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1200">        stuffescaped((const char *)reg-&gt;y_array[i], literally);</a>
<a name="ln1201">        // Insert a newline between lines and after last line if</a>
<a name="ln1202">        // y_type is kMTLineWise.</a>
<a name="ln1203">        if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln1204">          stuffcharReadbuff('\n');</a>
<a name="ln1205">        }</a>
<a name="ln1206">      }</a>
<a name="ln1207">    }</a>
<a name="ln1208">  }</a>
<a name="ln1209"> </a>
<a name="ln1210">  return retval;</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">/*</a>
<a name="ln1214"> * Stuff a string into the typeahead buffer, such that edit() will insert it</a>
<a name="ln1215"> * literally (&quot;literally&quot; TRUE) or interpret is as typed characters.</a>
<a name="ln1216"> */</a>
<a name="ln1217">static void stuffescaped(const char *arg, int literally)</a>
<a name="ln1218">{</a>
<a name="ln1219">  while (*arg != NUL) {</a>
<a name="ln1220">    // Stuff a sequence of normal ASCII characters, that's fast.  Also</a>
<a name="ln1221">    // stuff K_SPECIAL to get the effect of a special key when &quot;literally&quot;</a>
<a name="ln1222">    // is TRUE.</a>
<a name="ln1223">    const char *const start = arg;</a>
<a name="ln1224">    while ((*arg &gt;= ' ' &amp;&amp; *arg &lt; DEL) || ((uint8_t)(*arg) == K_SPECIAL</a>
<a name="ln1225">                                           &amp;&amp; !literally)) {</a>
<a name="ln1226">      arg++;</a>
<a name="ln1227">    }</a>
<a name="ln1228">    if (arg &gt; start) {</a>
<a name="ln1229">      stuffReadbuffLen(start, (long)(arg - start));</a>
<a name="ln1230">    }</a>
<a name="ln1231"> </a>
<a name="ln1232">    /* stuff a single special character */</a>
<a name="ln1233">    if (*arg != NUL) {</a>
<a name="ln1234">      const int c = mb_cptr2char_adv((const char_u **)&amp;arg);</a>
<a name="ln1235">      if (literally &amp;&amp; ((c &lt; ' ' &amp;&amp; c != TAB) || c == DEL)) {</a>
<a name="ln1236">        stuffcharReadbuff(Ctrl_V);</a>
<a name="ln1237">      }</a>
<a name="ln1238">      stuffcharReadbuff(c);</a>
<a name="ln1239">    }</a>
<a name="ln1240">  }</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">// If &quot;regname&quot; is a special register, return true and store a pointer to its</a>
<a name="ln1244">// value in &quot;argp&quot;.</a>
<a name="ln1245">bool get_spec_reg(</a>
<a name="ln1246">    int regname,</a>
<a name="ln1247">    char_u **argp,</a>
<a name="ln1248">    bool *allocated,        // return: true when value was allocated</a>
<a name="ln1249">    bool errmsg             // give error message when failing</a>
<a name="ln1250">)</a>
<a name="ln1251">{</a>
<a name="ln1252">  size_t cnt;</a>
<a name="ln1253"> </a>
<a name="ln1254">  *argp = NULL;</a>
<a name="ln1255">  *allocated = false;</a>
<a name="ln1256">  switch (regname) {</a>
<a name="ln1257">  case '%':                     /* file name */</a>
<a name="ln1258">    if (errmsg)</a>
<a name="ln1259">      check_fname();            /* will give emsg if not set */</a>
<a name="ln1260">    *argp = curbuf-&gt;b_fname;</a>
<a name="ln1261">    return true;</a>
<a name="ln1262"> </a>
<a name="ln1263">  case '#':                       // alternate file name</a>
<a name="ln1264">    *argp = getaltfname(errmsg);  // may give emsg if not set</a>
<a name="ln1265">    return true;</a>
<a name="ln1266"> </a>
<a name="ln1267">  case '=':                     /* result of expression */</a>
<a name="ln1268">    *argp = get_expr_line();</a>
<a name="ln1269">    *allocated = true;</a>
<a name="ln1270">    return true;</a>
<a name="ln1271"> </a>
<a name="ln1272">  case ':':                     /* last command line */</a>
<a name="ln1273">    if (last_cmdline == NULL &amp;&amp; errmsg)</a>
<a name="ln1274">      EMSG(_(e_nolastcmd));</a>
<a name="ln1275">    *argp = last_cmdline;</a>
<a name="ln1276">    return true;</a>
<a name="ln1277"> </a>
<a name="ln1278">  case '/':                     /* last search-pattern */</a>
<a name="ln1279">    if (last_search_pat() == NULL &amp;&amp; errmsg)</a>
<a name="ln1280">      EMSG(_(e_noprevre));</a>
<a name="ln1281">    *argp = last_search_pat();</a>
<a name="ln1282">    return true;</a>
<a name="ln1283"> </a>
<a name="ln1284">  case '.':                     /* last inserted text */</a>
<a name="ln1285">    *argp = get_last_insert_save();</a>
<a name="ln1286">    *allocated = true;</a>
<a name="ln1287">    if (*argp == NULL &amp;&amp; errmsg) {</a>
<a name="ln1288">      EMSG(_(e_noinstext));</a>
<a name="ln1289">    }</a>
<a name="ln1290">    return true;</a>
<a name="ln1291"> </a>
<a name="ln1292">  case Ctrl_F:                  // Filename under cursor</a>
<a name="ln1293">  case Ctrl_P:                  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln1294">    if (!errmsg) {</a>
<a name="ln1295">      return false;</a>
<a name="ln1296">    }</a>
<a name="ln1297">    *argp = file_name_at_cursor(</a>
<a name="ln1298">        FNAME_MESS | FNAME_HYP | (regname == Ctrl_P ? FNAME_EXP : 0),</a>
<a name="ln1299">        1L, NULL);</a>
<a name="ln1300">    *allocated = true;</a>
<a name="ln1301">    return true;</a>
<a name="ln1302"> </a>
<a name="ln1303">  case Ctrl_W:                  // word under cursor</a>
<a name="ln1304">  case Ctrl_A:                  // WORD (mnemonic All) under cursor</a>
<a name="ln1305">    if (!errmsg) {</a>
<a name="ln1306">      return false;</a>
<a name="ln1307">    }</a>
<a name="ln1308">    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W</a>
<a name="ln1309">                                         ? (FIND_IDENT|FIND_STRING)</a>
<a name="ln1310">                                         : FIND_STRING));</a>
<a name="ln1311">    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;</a>
<a name="ln1312">    *allocated = true;</a>
<a name="ln1313">    return true;</a>
<a name="ln1314"> </a>
<a name="ln1315">  case Ctrl_L:                  // Line under cursor</a>
<a name="ln1316">    if (!errmsg) {</a>
<a name="ln1317">      return false;</a>
<a name="ln1318">    }</a>
<a name="ln1319"> </a>
<a name="ln1320">    *argp = ml_get_buf(curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum, false);</a>
<a name="ln1321">    return true;</a>
<a name="ln1322"> </a>
<a name="ln1323">  case '_':                     /* black hole: always empty */</a>
<a name="ln1324">    *argp = (char_u *)&quot;&quot;;</a>
<a name="ln1325">    return true;</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  return false;</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">/// Paste a yank register into the command line.</a>
<a name="ln1332">/// Only for non-special registers.</a>
<a name="ln1333">/// Used by CTRL-R in command-line mode.</a>
<a name="ln1334">/// insert_reg() can't be used here, because special characters from the</a>
<a name="ln1335">/// register contents will be interpreted as commands.</a>
<a name="ln1336">///</a>
<a name="ln1337">/// @param regname   Register name.</a>
<a name="ln1338">/// @param literally_arg Insert text literally instead of &quot;as typed&quot;.</a>
<a name="ln1339">/// @param remcr     When true, don't add CR characters.</a>
<a name="ln1340">///</a>
<a name="ln1341">/// @returns FAIL for failure, OK otherwise</a>
<a name="ln1342">bool cmdline_paste_reg(int regname, bool literally_arg, bool remcr)</a>
<a name="ln1343">{</a>
<a name="ln1344">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1345"> </a>
<a name="ln1346">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1347">  if (reg-&gt;y_array == NULL)</a>
<a name="ln1348">    return FAIL;</a>
<a name="ln1349"> </a>
<a name="ln1350">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1351">    cmdline_paste_str(reg-&gt;y_array[i], literally);</a>
<a name="ln1352"> </a>
<a name="ln1353">    // Insert ^M between lines, unless `remcr` is true.</a>
<a name="ln1354">    if (i &lt; reg-&gt;y_size - 1 &amp;&amp; !remcr) {</a>
<a name="ln1355">      cmdline_paste_str((char_u *)&quot;\r&quot;, literally);</a>
<a name="ln1356">    }</a>
<a name="ln1357"> </a>
<a name="ln1358">    /* Check for CTRL-C, in case someone tries to paste a few thousand</a>
<a name="ln1359">     * lines and gets bored. */</a>
<a name="ln1360">    os_breakcheck();</a>
<a name="ln1361">    if (got_int)</a>
<a name="ln1362">      return FAIL;</a>
<a name="ln1363">  }</a>
<a name="ln1364">  return OK;</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">// Shift the delete registers: &quot;9 is cleared, &quot;8 becomes &quot;9, etc.</a>
<a name="ln1368">static void shift_delete_registers(bool y_append)</a>
<a name="ln1369">{</a>
<a name="ln1370">  free_register(&amp;y_regs[9]);  // free register &quot;9</a>
<a name="ln1371">  for (int n = 9; n &gt; 1; n--) {</a>
<a name="ln1372">    y_regs[n] = y_regs[n - 1];</a>
<a name="ln1373">  }</a>
<a name="ln1374">  if (!y_append) {</a>
<a name="ln1375">    y_previous = &amp;y_regs[1];</a>
<a name="ln1376">  }</a>
<a name="ln1377">  y_regs[1].y_array = NULL;  // set register &quot;1 to empty</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">/*</a>
<a name="ln1381"> * Handle a delete operation.</a>
<a name="ln1382"> *</a>
<a name="ln1383"> * Return FAIL if undo failed, OK otherwise.</a>
<a name="ln1384"> */</a>
<a name="ln1385">int op_delete(oparg_T *oap)</a>
<a name="ln1386">{</a>
<a name="ln1387">  int n;</a>
<a name="ln1388">  linenr_T lnum;</a>
<a name="ln1389">  char_u              *ptr;</a>
<a name="ln1390">  char_u              *newp, *oldp;</a>
<a name="ln1391">  struct block_def bd = { 0 };</a>
<a name="ln1392">  linenr_T old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1393"> </a>
<a name="ln1394">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {  // nothing to do</a>
<a name="ln1395">    return OK;</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  // Nothing to delete, return here. Do prepare undo, for op_change().</a>
<a name="ln1399">  if (oap-&gt;empty) {</a>
<a name="ln1400">    return u_save_cursor();</a>
<a name="ln1401">  }</a>
<a name="ln1402"> </a>
<a name="ln1403">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln1404">    EMSG(_(e_modifiable));</a>
<a name="ln1405">    return FAIL;</a>
<a name="ln1406">  }</a>
<a name="ln1407"> </a>
<a name="ln1408">  mb_adjust_opend(oap);</a>
<a name="ln1409"> </a>
<a name="ln1410">  /*</a>
<a name="ln1411">   * Imitate the strange Vi behaviour: If the delete spans more than one</a>
<a name="ln1412">   * line and motion_type == kMTCharWise and the result is a blank line, make the</a>
<a name="ln1413">   * delete linewise.  Don't do this for the change command or Visual mode.</a>
<a name="ln1414">   */</a>
<a name="ln1415">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln1416">      &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1417">      &amp;&amp; oap-&gt;line_count &gt; 1</a>
<a name="ln1418">      &amp;&amp; oap-&gt;motion_force == NUL</a>
<a name="ln1419">      &amp;&amp; oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1420">    ptr = ml_get(oap-&gt;end.lnum) + oap-&gt;end.col;</a>
<a name="ln1421">    if (*ptr != NUL)</a>
<a name="ln1422">      ptr += oap-&gt;inclusive;</a>
<a name="ln1423">    ptr = skipwhite(ptr);</a>
<a name="ln1424">    if (*ptr == NUL &amp;&amp; inindent(0)) {</a>
<a name="ln1425">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1426">    }</a>
<a name="ln1427">  }</a>
<a name="ln1428"> </a>
<a name="ln1429">  /*</a>
<a name="ln1430">   * Check for trying to delete (e.g. &quot;D&quot;) in an empty line.</a>
<a name="ln1431">   * Note: For the change operator it is ok.</a>
<a name="ln1432">   */</a>
<a name="ln1433">  if (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1434">      &amp;&amp; oap-&gt;line_count == 1</a>
<a name="ln1435">      &amp;&amp; oap-&gt;op_type == OP_DELETE</a>
<a name="ln1436">      &amp;&amp; *ml_get(oap-&gt;start.lnum) == NUL) {</a>
<a name="ln1437">    // It's an error to operate on an empty region, when 'E' included in</a>
<a name="ln1438">    // 'cpoptions' (Vi compatible).</a>
<a name="ln1439">    if (virtual_op) {</a>
<a name="ln1440">      // Virtual editing: Nothing gets deleted, but we set the '[ and ']</a>
<a name="ln1441">      // marks as if it happened.</a>
<a name="ln1442">      goto setmarks;</a>
<a name="ln1443">    }</a>
<a name="ln1444">    if (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL) {</a>
<a name="ln1445">      beep_flush();</a>
<a name="ln1446">    }</a>
<a name="ln1447">    return OK;</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  /*</a>
<a name="ln1451">   * Do a yank of whatever we're about to delete.</a>
<a name="ln1452">   * If a yank register was specified, put the deleted text into that</a>
<a name="ln1453">   * register.  For the black hole register '_' don't yank anything.</a>
<a name="ln1454">   */</a>
<a name="ln1455">  if (oap-&gt;regname != '_') {</a>
<a name="ln1456">    yankreg_T *reg = NULL;</a>
<a name="ln1457">    int did_yank = false;</a>
<a name="ln1458">    if (oap-&gt;regname != 0) {</a>
<a name="ln1459">      // yank without message</a>
<a name="ln1460">      did_yank = op_yank(oap, false, true);</a>
<a name="ln1461">      if (!did_yank) {</a>
<a name="ln1462">        // op_yank failed, don't do anything</a>
<a name="ln1463">        return OK;</a>
<a name="ln1464">      }</a>
<a name="ln1465">    }</a>
<a name="ln1466"> </a>
<a name="ln1467">    /*</a>
<a name="ln1468">     * Put deleted text into register 1 and shift number registers if the</a>
<a name="ln1469">     * delete contains a line break, or when a regname has been specified.</a>
<a name="ln1470">     */</a>
<a name="ln1471">    if (oap-&gt;regname != 0 || oap-&gt;motion_type == kMTLineWise</a>
<a name="ln1472">        || oap-&gt;line_count &gt; 1 || oap-&gt;use_reg_one) {</a>
<a name="ln1473">      shift_delete_registers(is_append_register(oap-&gt;regname));</a>
<a name="ln1474">      reg = &amp;y_regs[1];</a>
<a name="ln1475">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1476">      did_yank = true;</a>
<a name="ln1477">    }</a>
<a name="ln1478"> </a>
<a name="ln1479">    /* Yank into small delete register when no named register specified</a>
<a name="ln1480">     * and the delete is within one line. */</a>
<a name="ln1481">    if (oap-&gt;regname == 0 &amp;&amp; oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1482">        &amp;&amp; oap-&gt;line_count == 1) {</a>
<a name="ln1483">      reg = get_yank_register('-', YREG_YANK);</a>
<a name="ln1484">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1485">      did_yank = true;</a>
<a name="ln1486">    }</a>
<a name="ln1487"> </a>
<a name="ln1488">    if (did_yank || oap-&gt;regname == 0) {</a>
<a name="ln1489">      if (reg == NULL) {</a>
<a name="ln1490">        abort();</a>
<a name="ln1491">      }</a>
<a name="ln1492">      set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln1493">      do_autocmd_textyankpost(oap, reg);</a>
<a name="ln1494">    }</a>
<a name="ln1495"> </a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  /*</a>
<a name="ln1499">   * block mode delete</a>
<a name="ln1500">   */</a>
<a name="ln1501">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1502">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1503">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1504">      return FAIL;</a>
<a name="ln1505">    }</a>
<a name="ln1506"> </a>
<a name="ln1507">    for (lnum = curwin-&gt;w_cursor.lnum; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln1508">      block_prep(oap, &amp;bd, lnum, true);</a>
<a name="ln1509">      if (bd.textlen == 0) {            // nothing to delete</a>
<a name="ln1510">        continue;</a>
<a name="ln1511">      }</a>
<a name="ln1512"> </a>
<a name="ln1513">      /* Adjust cursor position for tab replaced by spaces and 'lbr'. */</a>
<a name="ln1514">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln1515">        curwin-&gt;w_cursor.col = bd.textcol + bd.startspaces;</a>
<a name="ln1516">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1517">      }</a>
<a name="ln1518"> </a>
<a name="ln1519">      // n == number of chars deleted</a>
<a name="ln1520">      // If we delete a TAB, it may be replaced by several characters.</a>
<a name="ln1521">      // Thus the number of characters may increase!</a>
<a name="ln1522">      n = bd.textlen - bd.startspaces - bd.endspaces;</a>
<a name="ln1523">      oldp = ml_get(lnum);</a>
<a name="ln1524">      newp = (char_u *)xmalloc(STRLEN(oldp) - (size_t)n + 1);</a>
<a name="ln1525">      // copy up to deleted part</a>
<a name="ln1526">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1527">      // insert spaces</a>
<a name="ln1528">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces +</a>
<a name="ln1529">             (size_t)bd.endspaces);</a>
<a name="ln1530">      // copy the part after the deleted part</a>
<a name="ln1531">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1532">      STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);</a>
<a name="ln1533">      // replace the line</a>
<a name="ln1534">      ml_replace(lnum, newp, false);</a>
<a name="ln1535"> </a>
<a name="ln1536">      extmark_splice_cols(curbuf, (int)lnum-1, bd.textcol,</a>
<a name="ln1537">                          bd.textlen, bd.startspaces+bd.endspaces,</a>
<a name="ln1538">                          kExtmarkUndo);</a>
<a name="ln1539">    }</a>
<a name="ln1540"> </a>
<a name="ln1541">    check_cursor_col();</a>
<a name="ln1542">    changed_lines(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln1543">                  oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1544">    oap-&gt;line_count = 0;  // no lines deleted</a>
<a name="ln1545">  } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1546">    if (oap-&gt;op_type == OP_CHANGE) {</a>
<a name="ln1547">      // Delete the lines except the first one.  Temporarily move the</a>
<a name="ln1548">      // cursor to the next line.  Save the current line number, if the</a>
<a name="ln1549">      // last line is deleted it may be changed.</a>
<a name="ln1550"> </a>
<a name="ln1551">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1552">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1553">        ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln1554">        del_lines(oap-&gt;line_count - 1, TRUE);</a>
<a name="ln1555">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1556">      }</a>
<a name="ln1557">      if (u_save_cursor() == FAIL)</a>
<a name="ln1558">        return FAIL;</a>
<a name="ln1559">      if (curbuf-&gt;b_p_ai) {                 // don't delete indent</a>
<a name="ln1560">        beginline(BL_WHITE);                // cursor on first non-white</a>
<a name="ln1561">        did_ai = true;                      // delete the indent when ESC hit</a>
<a name="ln1562">        ai_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1563">      } else {</a>
<a name="ln1564">        beginline(0);                       // cursor in column 0</a>
<a name="ln1565">      }</a>
<a name="ln1566"> </a>
<a name="ln1567">      int old_len = (int)STRLEN(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln1568">      truncate_line(false);         // delete the rest of the line</a>
<a name="ln1569"> </a>
<a name="ln1570">      extmark_splice_cols(curbuf,</a>
<a name="ln1571">                          (int)curwin-&gt;w_cursor.lnum-1, curwin-&gt;w_cursor.col,</a>
<a name="ln1572">                          old_len - curwin-&gt;w_cursor.col, 0, kExtmarkUndo);</a>
<a name="ln1573"> </a>
<a name="ln1574">                                    // leave cursor past last char in line</a>
<a name="ln1575">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1576">        u_clearline();              // &quot;U&quot; command not possible after &quot;2cc&quot;</a>
<a name="ln1577">      }</a>
<a name="ln1578">    } else {</a>
<a name="ln1579">      del_lines(oap-&gt;line_count, TRUE);</a>
<a name="ln1580">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln1581">      u_clearline();            /* &quot;U&quot; command not possible after &quot;dd&quot; */</a>
<a name="ln1582">    }</a>
<a name="ln1583">  } else {</a>
<a name="ln1584">    if (virtual_op) {</a>
<a name="ln1585">      int endcol = 0;</a>
<a name="ln1586"> </a>
<a name="ln1587">      /* For virtualedit: break the tabs that are partly included. */</a>
<a name="ln1588">      if (gchar_pos(&amp;oap-&gt;start) == '\t') {</a>
<a name="ln1589">        if (u_save_cursor() == FAIL)            /* save first line for undo */</a>
<a name="ln1590">          return FAIL;</a>
<a name="ln1591">        if (oap-&gt;line_count == 1)</a>
<a name="ln1592">          endcol = getviscol2(oap-&gt;end.col, oap-&gt;end.coladd);</a>
<a name="ln1593">        coladvance_force(getviscol2(oap-&gt;start.col, oap-&gt;start.coladd));</a>
<a name="ln1594">        oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1595">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1596">          coladvance(endcol);</a>
<a name="ln1597">          oap-&gt;end.col = curwin-&gt;w_cursor.col;</a>
<a name="ln1598">          oap-&gt;end.coladd = curwin-&gt;w_cursor.coladd;</a>
<a name="ln1599">          curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1600">        }</a>
<a name="ln1601">      }</a>
<a name="ln1602"> </a>
<a name="ln1603">      /* Break a tab only when it's included in the area. */</a>
<a name="ln1604">      if (gchar_pos(&amp;oap-&gt;end) == '\t'</a>
<a name="ln1605">          &amp;&amp; oap-&gt;end.coladd == 0</a>
<a name="ln1606">          &amp;&amp; oap-&gt;inclusive) {</a>
<a name="ln1607">        /* save last line for undo */</a>
<a name="ln1608">        if (u_save((linenr_T)(oap-&gt;end.lnum - 1),</a>
<a name="ln1609">                (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1610">          return FAIL;</a>
<a name="ln1611">        curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln1612">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd));</a>
<a name="ln1613">        oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln1614">        curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1615">      }</a>
<a name="ln1616">      mb_adjust_opend(oap);</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">    if (oap-&gt;line_count == 1) {         /* delete characters within one line */</a>
<a name="ln1620">      if (u_save_cursor() == FAIL)              /* save line for undo */</a>
<a name="ln1621">        return FAIL;</a>
<a name="ln1622"> </a>
<a name="ln1623">      /* if 'cpoptions' contains '$', display '$' at end of change */</a>
<a name="ln1624">      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL</a>
<a name="ln1625">                     &amp;&amp; oap-&gt;op_type == OP_CHANGE</a>
<a name="ln1626">                     &amp;&amp; oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln1627">                     &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1628">                     )</a>
<a name="ln1629">        display_dollar(oap-&gt;end.col - !oap-&gt;inclusive);</a>
<a name="ln1630"> </a>
<a name="ln1631">      n = oap-&gt;end.col - oap-&gt;start.col + 1 - !oap-&gt;inclusive;</a>
<a name="ln1632"> </a>
<a name="ln1633">      if (virtual_op) {</a>
<a name="ln1634">        /* fix up things for virtualedit-delete:</a>
<a name="ln1635">         * break the tabs which are going to get in our way</a>
<a name="ln1636">         */</a>
<a name="ln1637">        char_u          *curline = get_cursor_line_ptr();</a>
<a name="ln1638">        int len = (int)STRLEN(curline);</a>
<a name="ln1639"> </a>
<a name="ln1640">        if (oap-&gt;end.coladd != 0</a>
<a name="ln1641">            &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1</a>
<a name="ln1642">            &amp;&amp; !(oap-&gt;start.coladd &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1))</a>
<a name="ln1643">          n++;</a>
<a name="ln1644">        /* Delete at least one char (e.g, when on a control char). */</a>
<a name="ln1645">        if (n == 0 &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd)</a>
<a name="ln1646">          n = 1;</a>
<a name="ln1647"> </a>
<a name="ln1648">        /* When deleted a char in the line, reset coladd. */</a>
<a name="ln1649">        if (gchar_cursor() != NUL)</a>
<a name="ln1650">          curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1651">      }</a>
<a name="ln1652"> </a>
<a name="ln1653">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1654">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1655">    } else {</a>
<a name="ln1656">      // delete characters between lines</a>
<a name="ln1657">      pos_T curpos;</a>
<a name="ln1658"> </a>
<a name="ln1659">      /* save deleted and changed lines for undo */</a>
<a name="ln1660">      if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum - 1),</a>
<a name="ln1661">              (linenr_T)(curwin-&gt;w_cursor.lnum + oap-&gt;line_count)) == FAIL)</a>
<a name="ln1662">        return FAIL;</a>
<a name="ln1663"> </a>
<a name="ln1664">      curbuf_splice_pending++;</a>
<a name="ln1665">      pos_T startpos = curwin-&gt;w_cursor;  // start position for delete</a>
<a name="ln1666">      truncate_line(true);        // delete from cursor to end of line</a>
<a name="ln1667"> </a>
<a name="ln1668">      curpos = curwin-&gt;w_cursor;  // remember curwin-&gt;w_cursor</a>
<a name="ln1669">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1670">      del_lines(oap-&gt;line_count - 2, false);</a>
<a name="ln1671">      bcount_t deleted_bytes = (bcount_t)curbuf-&gt;deleted_bytes2 - startpos.col;</a>
<a name="ln1672"> </a>
<a name="ln1673">      // delete from start of line until op_end</a>
<a name="ln1674">      n = (oap-&gt;end.col + 1 - !oap-&gt;inclusive);</a>
<a name="ln1675">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1676">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1677">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1678">      deleted_bytes += n;</a>
<a name="ln1679">      curwin-&gt;w_cursor = curpos;  // restore curwin-&gt;w_cursor</a>
<a name="ln1680">      (void)do_join(2, false, false, false, false);</a>
<a name="ln1681">      curbuf_splice_pending--;</a>
<a name="ln1682">      extmark_splice(curbuf, (int)startpos.lnum-1, startpos.col,</a>
<a name="ln1683">                     (int)oap-&gt;line_count-1, n, deleted_bytes,</a>
<a name="ln1684">                     0, 0, 0, kExtmarkUndo);</a>
<a name="ln1685">    }</a>
<a name="ln1686">  }</a>
<a name="ln1687"> </a>
<a name="ln1688">  msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln1689"> </a>
<a name="ln1690">setmarks:</a>
<a name="ln1691">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1692">    curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln1693">    curbuf-&gt;b_op_end.col = oap-&gt;start.col;</a>
<a name="ln1694">  } else {</a>
<a name="ln1695">    curbuf-&gt;b_op_end = oap-&gt;start;</a>
<a name="ln1696">  }</a>
<a name="ln1697">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1698"> </a>
<a name="ln1699">  return OK;</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">/*</a>
<a name="ln1703"> * Adjust end of operating area for ending on a multi-byte character.</a>
<a name="ln1704"> * Used for deletion.</a>
<a name="ln1705"> */</a>
<a name="ln1706">static void mb_adjust_opend(oparg_T *oap)</a>
<a name="ln1707">{</a>
<a name="ln1708">  char_u      *p;</a>
<a name="ln1709"> </a>
<a name="ln1710">  if (oap-&gt;inclusive) {</a>
<a name="ln1711">    p = ml_get(oap-&gt;end.lnum);</a>
<a name="ln1712">    oap-&gt;end.col += mb_tail_off(p, p + oap-&gt;end.col);</a>
<a name="ln1713">  }</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716">/*</a>
<a name="ln1717"> * Put character 'c' at position 'lp'</a>
<a name="ln1718"> */</a>
<a name="ln1719">static inline void pbyte(pos_T lp, int c)</a>
<a name="ln1720">{</a>
<a name="ln1721">  assert(c &lt;= UCHAR_MAX);</a>
<a name="ln1722">  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char_u)c;</a>
<a name="ln1723">  if (!curbuf_splice_pending) {</a>
<a name="ln1724">    extmark_splice_cols(curbuf, (int)lp.lnum-1, lp.col, 1, 1, kExtmarkUndo);</a>
<a name="ln1725">  }</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">// Replace the character under the cursor with &quot;c&quot;.</a>
<a name="ln1729">// This takes care of multi-byte characters.</a>
<a name="ln1730">static void replace_character(int c)</a>
<a name="ln1731">{</a>
<a name="ln1732">  const int n = State;</a>
<a name="ln1733"> </a>
<a name="ln1734">  State = REPLACE;</a>
<a name="ln1735">  ins_char(c);</a>
<a name="ln1736">  State = n;</a>
<a name="ln1737">  // Backup to the replaced character.</a>
<a name="ln1738">  dec_cursor();</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">/*</a>
<a name="ln1742"> * Replace a whole area with one character.</a>
<a name="ln1743"> */</a>
<a name="ln1744">int op_replace(oparg_T *oap, int c)</a>
<a name="ln1745">{</a>
<a name="ln1746">  int n, numc;</a>
<a name="ln1747">  int num_chars;</a>
<a name="ln1748">  char_u              *newp, *oldp;</a>
<a name="ln1749">  colnr_T oldlen;</a>
<a name="ln1750">  struct block_def bd;</a>
<a name="ln1751">  char_u              *after_p = NULL;</a>
<a name="ln1752">  int had_ctrl_v_cr = false;</a>
<a name="ln1753"> </a>
<a name="ln1754">  if ((curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY ) || oap-&gt;empty)</a>
<a name="ln1755">    return OK;              /* nothing to do */</a>
<a name="ln1756"> </a>
<a name="ln1757">  if (c == REPLACE_CR_NCHAR) {</a>
<a name="ln1758">    had_ctrl_v_cr = true;</a>
<a name="ln1759">    c = CAR;</a>
<a name="ln1760">  } else if (c == REPLACE_NL_NCHAR) {</a>
<a name="ln1761">    had_ctrl_v_cr = true;</a>
<a name="ln1762">    c = NL;</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  mb_adjust_opend(oap);</a>
<a name="ln1766"> </a>
<a name="ln1767">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1768">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1769">    return FAIL;</a>
<a name="ln1770"> </a>
<a name="ln1771">  /*</a>
<a name="ln1772">   * block mode replace</a>
<a name="ln1773">   */</a>
<a name="ln1774">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1775">    bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln1776">    for (; curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln1777">      curwin-&gt;w_cursor.col = 0;       // make sure cursor position is valid</a>
<a name="ln1778">      block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln1779">      if (bd.textlen == 0 &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1780">        continue;                     // nothing to replace</a>
<a name="ln1781">      }</a>
<a name="ln1782"> </a>
<a name="ln1783">      /* n == number of extra chars required</a>
<a name="ln1784">       * If we split a TAB, it may be replaced by several characters.</a>
<a name="ln1785">       * Thus the number of characters may increase!</a>
<a name="ln1786">       */</a>
<a name="ln1787">      /* If the range starts in virtual space, count the initial</a>
<a name="ln1788">       * coladd offset as part of &quot;startspaces&quot; */</a>
<a name="ln1789">      if (virtual_op &amp;&amp; bd.is_short &amp;&amp; *bd.textstart == NUL) {</a>
<a name="ln1790">        pos_T vpos;</a>
<a name="ln1791"> </a>
<a name="ln1792">        vpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1793">        getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln1794">        bd.startspaces += vpos.coladd;</a>
<a name="ln1795">        n = bd.startspaces;</a>
<a name="ln1796">      } else</a>
<a name="ln1797">        /* allow for pre spaces */</a>
<a name="ln1798">        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);</a>
<a name="ln1799"> </a>
<a name="ln1800">      /* allow for post spp */</a>
<a name="ln1801">      n += (bd.endspaces</a>
<a name="ln1802">            &amp;&amp; !bd.is_oneChar</a>
<a name="ln1803">            &amp;&amp; bd.end_char_vcols &gt; 0) ? bd.end_char_vcols - 1 : 0;</a>
<a name="ln1804">      /* Figure out how many characters to replace. */</a>
<a name="ln1805">      numc = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln1806">      if (bd.is_short &amp;&amp; (!virtual_op || bd.is_MAX))</a>
<a name="ln1807">        numc -= (oap-&gt;end_vcol - bd.end_vcol) + 1;</a>
<a name="ln1808"> </a>
<a name="ln1809">      /* A double-wide character can be replaced only up to half the</a>
<a name="ln1810">       * times. */</a>
<a name="ln1811">      if ((*mb_char2cells)(c) &gt; 1) {</a>
<a name="ln1812">        if ((numc &amp; 1) &amp;&amp; !bd.is_short) {</a>
<a name="ln1813">          ++bd.endspaces;</a>
<a name="ln1814">          ++n;</a>
<a name="ln1815">        }</a>
<a name="ln1816">        numc = numc / 2;</a>
<a name="ln1817">      }</a>
<a name="ln1818"> </a>
<a name="ln1819">      /* Compute bytes needed, move character count to num_chars. */</a>
<a name="ln1820">      num_chars = numc;</a>
<a name="ln1821">      numc *= (*mb_char2len)(c);</a>
<a name="ln1822"> </a>
<a name="ln1823">      oldp = get_cursor_line_ptr();</a>
<a name="ln1824">      oldlen = (int)STRLEN(oldp);</a>
<a name="ln1825"> </a>
<a name="ln1826">      size_t newp_size = (size_t)bd.textcol + (size_t)bd.startspaces;</a>
<a name="ln1827">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1828">        newp_size += (size_t)numc;</a>
<a name="ln1829">        if (!bd.is_short) {</a>
<a name="ln1830">          newp_size += (size_t)(bd.endspaces + oldlen</a>
<a name="ln1831">                                - bd.textcol - bd.textlen);</a>
<a name="ln1832">        }</a>
<a name="ln1833">      }</a>
<a name="ln1834">      newp = xmallocz(newp_size);</a>
<a name="ln1835">      // copy up to deleted part</a>
<a name="ln1836">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1837">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1838">      // insert pre-spaces</a>
<a name="ln1839">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);</a>
<a name="ln1840">      // insert replacement chars CHECK FOR ALLOCATED SPACE</a>
<a name="ln1841">      // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR literally.</a>
<a name="ln1842">      size_t after_p_len = 0;</a>
<a name="ln1843">      int col = oldlen - bd.textcol - bd.textlen + 1;</a>
<a name="ln1844">      assert(col &gt;= 0);</a>
<a name="ln1845">      int newrows = 0, newcols = 0;</a>
<a name="ln1846">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1847">          // strlen(newp) at this point</a>
<a name="ln1848">          int newp_len = bd.textcol + bd.startspaces;</a>
<a name="ln1849">          while (--num_chars &gt;= 0) {</a>
<a name="ln1850">            newp_len += utf_char2bytes(c, newp + newp_len);</a>
<a name="ln1851">          }</a>
<a name="ln1852">          if (!bd.is_short) {</a>
<a name="ln1853">            // insert post-spaces</a>
<a name="ln1854">            memset(newp + newp_len, ' ', (size_t)bd.endspaces);</a>
<a name="ln1855">            newp_len += bd.endspaces;</a>
<a name="ln1856">            // copy the part after the changed part</a>
<a name="ln1857">            memmove(newp + newp_len, oldp, (size_t)col);</a>
<a name="ln1858">          }</a>
<a name="ln1859">          newcols = newp_len - bd.textcol;</a>
<a name="ln1860">      } else {</a>
<a name="ln1861">        // Replacing with \r or \n means splitting the line.</a>
<a name="ln1862">        after_p_len = (size_t)col;</a>
<a name="ln1863">        after_p = (char_u *)xmalloc(after_p_len);</a>
<a name="ln1864">        memmove(after_p, oldp, after_p_len);</a>
<a name="ln1865">        newrows = 1;</a>
<a name="ln1866">      }</a>
<a name="ln1867">      // replace the line</a>
<a name="ln1868">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln1869">      curbuf_splice_pending++;</a>
<a name="ln1870">      linenr_T baselnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1871">      if (after_p != NULL) {</a>
<a name="ln1872">        ml_append(curwin-&gt;w_cursor.lnum++, after_p, (int)after_p_len, false);</a>
<a name="ln1873">        appended_lines_mark(curwin-&gt;w_cursor.lnum, 1L);</a>
<a name="ln1874">        oap-&gt;end.lnum++;</a>
<a name="ln1875">        xfree(after_p);</a>
<a name="ln1876">      }</a>
<a name="ln1877">      curbuf_splice_pending--;</a>
<a name="ln1878">      extmark_splice(curbuf, (int)baselnum-1, bd.textcol,</a>
<a name="ln1879">                     0, bd.textlen, bd.textlen,</a>
<a name="ln1880">                     newrows, newcols, newrows+newcols, kExtmarkUndo);</a>
<a name="ln1881">    }</a>
<a name="ln1882">  } else {</a>
<a name="ln1883">    // Characterwise or linewise motion replace.</a>
<a name="ln1884">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1885">      oap-&gt;start.col = 0;</a>
<a name="ln1886">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1887">      oap-&gt;end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1888">      if (oap-&gt;end.col)</a>
<a name="ln1889">        --oap-&gt;end.col;</a>
<a name="ln1890">    } else if (!oap-&gt;inclusive)</a>
<a name="ln1891">      dec(&amp;(oap-&gt;end));</a>
<a name="ln1892"> </a>
<a name="ln1893">    // TODO(bfredl): we could batch all the splicing</a>
<a name="ln1894">    // done on the same line, at least</a>
<a name="ln1895">    while (ltoreq(curwin-&gt;w_cursor, oap-&gt;end)) {</a>
<a name="ln1896">      n = gchar_cursor();</a>
<a name="ln1897">      if (n != NUL) {</a>
<a name="ln1898">        if ((*mb_char2len)(c) &gt; 1 || (*mb_char2len)(n) &gt; 1) {</a>
<a name="ln1899">          /* This is slow, but it handles replacing a single-byte</a>
<a name="ln1900">           * with a multi-byte and the other way around. */</a>
<a name="ln1901">          if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum)</a>
<a name="ln1902">            oap-&gt;end.col += (*mb_char2len)(c) - (*mb_char2len)(n);</a>
<a name="ln1903">          replace_character(c);</a>
<a name="ln1904">        } else {</a>
<a name="ln1905">          if (n == TAB) {</a>
<a name="ln1906">            int end_vcol = 0;</a>
<a name="ln1907"> </a>
<a name="ln1908">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1909">              /* oap-&gt;end has to be recalculated when</a>
<a name="ln1910">               * the tab breaks */</a>
<a name="ln1911">              end_vcol = getviscol2(oap-&gt;end.col,</a>
<a name="ln1912">                  oap-&gt;end.coladd);</a>
<a name="ln1913">            }</a>
<a name="ln1914">            coladvance_force(getviscol());</a>
<a name="ln1915">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum)</a>
<a name="ln1916">              getvpos(&amp;oap-&gt;end, end_vcol);</a>
<a name="ln1917">          }</a>
<a name="ln1918">          pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1919">        }</a>
<a name="ln1920">      } else if (virtual_op &amp;&amp; curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1921">        int virtcols = oap-&gt;end.coladd;</a>
<a name="ln1922"> </a>
<a name="ln1923">        if (curwin-&gt;w_cursor.lnum == oap-&gt;start.lnum</a>
<a name="ln1924">            &amp;&amp; oap-&gt;start.col == oap-&gt;end.col &amp;&amp; oap-&gt;start.coladd)</a>
<a name="ln1925">          virtcols -= oap-&gt;start.coladd;</a>
<a name="ln1926"> </a>
<a name="ln1927">        /* oap-&gt;end has been trimmed so it's effectively inclusive;</a>
<a name="ln1928">         * as a result an extra +1 must be counted so we don't</a>
<a name="ln1929">         * trample the NUL byte. */</a>
<a name="ln1930">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd) + 1);</a>
<a name="ln1931">        curwin-&gt;w_cursor.col -= (virtcols + 1);</a>
<a name="ln1932">        for (; virtcols &gt;= 0; virtcols--) {</a>
<a name="ln1933">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln1934">            replace_character(c);</a>
<a name="ln1935">          } else {</a>
<a name="ln1936">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1937">          }</a>
<a name="ln1938">          if (inc(&amp;curwin-&gt;w_cursor) == -1) {</a>
<a name="ln1939">            break;</a>
<a name="ln1940">          }</a>
<a name="ln1941">        }</a>
<a name="ln1942">      }</a>
<a name="ln1943"> </a>
<a name="ln1944">      /* Advance to next character, stop at the end of the file. */</a>
<a name="ln1945">      if (inc_cursor() == -1)</a>
<a name="ln1946">        break;</a>
<a name="ln1947">    }</a>
<a name="ln1948">  }</a>
<a name="ln1949"> </a>
<a name="ln1950">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1951">  check_cursor();</a>
<a name="ln1952">  changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1953"> </a>
<a name="ln1954">  /* Set &quot;'[&quot; and &quot;']&quot; marks. */</a>
<a name="ln1955">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1956">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln1957"> </a>
<a name="ln1958">  return OK;</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961"> </a>
<a name="ln1962">/*</a>
<a name="ln1963"> * Handle the (non-standard vi) tilde operator.  Also for &quot;gu&quot;, &quot;gU&quot; and &quot;g?&quot;.</a>
<a name="ln1964"> */</a>
<a name="ln1965">void op_tilde(oparg_T *oap)</a>
<a name="ln1966">{</a>
<a name="ln1967">  pos_T pos;</a>
<a name="ln1968">  struct block_def bd;</a>
<a name="ln1969">  int did_change = FALSE;</a>
<a name="ln1970"> </a>
<a name="ln1971">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1972">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln1973">    return;</a>
<a name="ln1974"> </a>
<a name="ln1975">  pos = oap-&gt;start;</a>
<a name="ln1976">  if (oap-&gt;motion_type == kMTBlockWise) {  // Visual block mode</a>
<a name="ln1977">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln1978">      int one_change;</a>
<a name="ln1979"> </a>
<a name="ln1980">      block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln1981">      pos.col = bd.textcol;</a>
<a name="ln1982">      one_change = swapchars(oap-&gt;op_type, &amp;pos, bd.textlen);</a>
<a name="ln1983">      did_change |= one_change;</a>
<a name="ln1984"> </a>
<a name="ln1985">    }</a>
<a name="ln1986">    if (did_change) {</a>
<a name="ln1987">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1988">    }</a>
<a name="ln1989">  } else {  // not block mode</a>
<a name="ln1990">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1991">      oap-&gt;start.col = 0;</a>
<a name="ln1992">      pos.col = 0;</a>
<a name="ln1993">      oap-&gt;end.col = (colnr_T)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1994">      if (oap-&gt;end.col)</a>
<a name="ln1995">        --oap-&gt;end.col;</a>
<a name="ln1996">    } else if (!oap-&gt;inclusive)</a>
<a name="ln1997">      dec(&amp;(oap-&gt;end));</a>
<a name="ln1998"> </a>
<a name="ln1999">    if (pos.lnum == oap-&gt;end.lnum)</a>
<a name="ln2000">      did_change = swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2001">          oap-&gt;end.col - pos.col + 1);</a>
<a name="ln2002">    else</a>
<a name="ln2003">      for (;; ) {</a>
<a name="ln2004">        did_change |= swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2005">            pos.lnum == oap-&gt;end.lnum ? oap-&gt;end.col + 1 :</a>
<a name="ln2006">            (int)STRLEN(ml_get_pos(&amp;pos)));</a>
<a name="ln2007">        if (ltoreq(oap-&gt;end, pos) || inc(&amp;pos) == -1)</a>
<a name="ln2008">          break;</a>
<a name="ln2009">      }</a>
<a name="ln2010">    if (did_change) {</a>
<a name="ln2011">      changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1,</a>
<a name="ln2012">                    0L, true);</a>
<a name="ln2013">    }</a>
<a name="ln2014">  }</a>
<a name="ln2015"> </a>
<a name="ln2016">  if (!did_change &amp;&amp; oap-&gt;is_VIsual)</a>
<a name="ln2017">    /* No change: need to remove the Visual selection */</a>
<a name="ln2018">    redraw_curbuf_later(INVERTED);</a>
<a name="ln2019"> </a>
<a name="ln2020">  /*</a>
<a name="ln2021">   * Set '[ and '] marks.</a>
<a name="ln2022">   */</a>
<a name="ln2023">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2024">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2025"> </a>
<a name="ln2026">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln2027">    if (oap-&gt;line_count == 1)</a>
<a name="ln2028">      MSG(_(&quot;1 line changed&quot;));</a>
<a name="ln2029">    else</a>
<a name="ln2030">      smsg(_(&quot;%&quot; PRId64 &quot; lines changed&quot;), (int64_t)oap-&gt;line_count);</a>
<a name="ln2031">  }</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">/*</a>
<a name="ln2035"> * Invoke swapchar() on &quot;length&quot; bytes at position &quot;pos&quot;.</a>
<a name="ln2036"> * &quot;pos&quot; is advanced to just after the changed characters.</a>
<a name="ln2037"> * &quot;length&quot; is rounded up to include the whole last multi-byte character.</a>
<a name="ln2038"> * Also works correctly when the number of bytes changes.</a>
<a name="ln2039"> * Returns TRUE if some character was changed.</a>
<a name="ln2040"> */</a>
<a name="ln2041">static int swapchars(int op_type, pos_T *pos, int length)</a>
<a name="ln2042">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2043">{</a>
<a name="ln2044">  int did_change = 0;</a>
<a name="ln2045"> </a>
<a name="ln2046">  for (int todo = length; todo &gt; 0; todo--) {</a>
<a name="ln2047">    const int len = utfc_ptr2len(ml_get_pos(pos));</a>
<a name="ln2048"> </a>
<a name="ln2049">    // we're counting bytes, not characters</a>
<a name="ln2050">    if (len &gt; 0) {</a>
<a name="ln2051">      todo -= len - 1;</a>
<a name="ln2052">    }</a>
<a name="ln2053">    did_change |= swapchar(op_type, pos);</a>
<a name="ln2054">    if (inc(pos) == -1)        /* at end of file */</a>
<a name="ln2055">      break;</a>
<a name="ln2056">  }</a>
<a name="ln2057">  return did_change;</a>
<a name="ln2058">}</a>
<a name="ln2059"> </a>
<a name="ln2060">// If op_type == OP_UPPER: make uppercase,</a>
<a name="ln2061">// if op_type == OP_LOWER: make lowercase,</a>
<a name="ln2062">// if op_type == OP_ROT13: do rot13 encoding,</a>
<a name="ln2063">// else swap case of character at 'pos'</a>
<a name="ln2064">// returns true when something actually changed.</a>
<a name="ln2065">bool swapchar(int op_type, pos_T *pos)</a>
<a name="ln2066">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2067">{</a>
<a name="ln2068">  const int c = gchar_pos(pos);</a>
<a name="ln2069"> </a>
<a name="ln2070">  // Only do rot13 encoding for ASCII characters.</a>
<a name="ln2071">  if (c &gt;= 0x80 &amp;&amp; op_type == OP_ROT13) {</a>
<a name="ln2072">    return false;</a>
<a name="ln2073">  }</a>
<a name="ln2074"> </a>
<a name="ln2075">  if (op_type == OP_UPPER &amp;&amp; c == 0xdf) {</a>
<a name="ln2076">    pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2077"> </a>
<a name="ln2078">    /* Special handling of German sharp s: change to &quot;SS&quot;. */</a>
<a name="ln2079">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln2080">    del_char(false);</a>
<a name="ln2081">    ins_char('S');</a>
<a name="ln2082">    ins_char('S');</a>
<a name="ln2083">    curwin-&gt;w_cursor = sp;</a>
<a name="ln2084">    inc(pos);</a>
<a name="ln2085">  }</a>
<a name="ln2086"> </a>
<a name="ln2087">  int nc = c;</a>
<a name="ln2088">  if (mb_islower(c)) {</a>
<a name="ln2089">    if (op_type == OP_ROT13) {</a>
<a name="ln2090">      nc = ROT13(c, 'a');</a>
<a name="ln2091">    } else if (op_type != OP_LOWER) {</a>
<a name="ln2092">      nc = mb_toupper(c);</a>
<a name="ln2093">    }</a>
<a name="ln2094">  } else if (mb_isupper(c)) {</a>
<a name="ln2095">    if (op_type == OP_ROT13) {</a>
<a name="ln2096">      nc = ROT13(c, 'A');</a>
<a name="ln2097">    } else if (op_type != OP_UPPER) {</a>
<a name="ln2098">      nc = mb_tolower(c);</a>
<a name="ln2099">    }</a>
<a name="ln2100">  }</a>
<a name="ln2101">  if (nc != c) {</a>
<a name="ln2102">    if (c &gt;= 0x80 || nc &gt;= 0x80) {</a>
<a name="ln2103">      pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2104"> </a>
<a name="ln2105">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln2106">      // don't use del_char(), it also removes composing chars</a>
<a name="ln2107">      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), false, false);</a>
<a name="ln2108">      ins_char(nc);</a>
<a name="ln2109">      curwin-&gt;w_cursor = sp;</a>
<a name="ln2110">    } else {</a>
<a name="ln2111">      pbyte(*pos, nc);</a>
<a name="ln2112">    }</a>
<a name="ln2113">    return true;</a>
<a name="ln2114">  }</a>
<a name="ln2115">  return false;</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">/*</a>
<a name="ln2119"> * op_insert - Insert and append operators for Visual mode.</a>
<a name="ln2120"> */</a>
<a name="ln2121">void op_insert(oparg_T *oap, long count1)</a>
<a name="ln2122">{</a>
<a name="ln2123">  long ins_len, pre_textlen = 0;</a>
<a name="ln2124">  char_u              *firstline, *ins_text;</a>
<a name="ln2125">  colnr_T ind_pre = 0;</a>
<a name="ln2126">  struct block_def bd;</a>
<a name="ln2127">  int i;</a>
<a name="ln2128">  pos_T t1;</a>
<a name="ln2129"> </a>
<a name="ln2130">  /* edit() changes this - record it for OP_APPEND */</a>
<a name="ln2131">  bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln2132"> </a>
<a name="ln2133">  /* vis block is still marked. Get rid of it now. */</a>
<a name="ln2134">  curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln2135">  update_screen(INVERTED);</a>
<a name="ln2136"> </a>
<a name="ln2137">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2138">    // When 'virtualedit' is used, need to insert the extra spaces before</a>
<a name="ln2139">    // doing block_prep().  When only &quot;block&quot; is used, virtual edit is</a>
<a name="ln2140">    // already disabled, but still need it when calling</a>
<a name="ln2141">    // coladvance_force().</a>
<a name="ln2142">    if (curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln2143">      unsigned old_ve_flags = ve_flags;</a>
<a name="ln2144"> </a>
<a name="ln2145">      ve_flags = VE_ALL;</a>
<a name="ln2146">      if (u_save_cursor() == FAIL)</a>
<a name="ln2147">        return;</a>
<a name="ln2148">      coladvance_force(oap-&gt;op_type == OP_APPEND</a>
<a name="ln2149">          ? oap-&gt;end_vcol + 1 : getviscol());</a>
<a name="ln2150">      if (oap-&gt;op_type == OP_APPEND)</a>
<a name="ln2151">        --curwin-&gt;w_cursor.col;</a>
<a name="ln2152">      ve_flags = old_ve_flags;</a>
<a name="ln2153">    }</a>
<a name="ln2154">    // Get the info about the block before entering the text</a>
<a name="ln2155">    block_prep(oap, &amp;bd, oap-&gt;start.lnum, true);</a>
<a name="ln2156">    // Get indent information</a>
<a name="ln2157">    ind_pre = (colnr_T)getwhitecols_curline();</a>
<a name="ln2158">    firstline = ml_get(oap-&gt;start.lnum) + bd.textcol;</a>
<a name="ln2159"> </a>
<a name="ln2160">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2161">      firstline += bd.textlen;</a>
<a name="ln2162">    }</a>
<a name="ln2163">    pre_textlen = (long)STRLEN(firstline);</a>
<a name="ln2164">  }</a>
<a name="ln2165"> </a>
<a name="ln2166">  if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2167">    if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2168">        &amp;&amp; curwin-&gt;w_cursor.coladd == 0</a>
<a name="ln2169">        ) {</a>
<a name="ln2170">      /* Move the cursor to the character right of the block. */</a>
<a name="ln2171">      curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln2172">      while (*get_cursor_pos_ptr() != NUL</a>
<a name="ln2173">             &amp;&amp; (curwin-&gt;w_cursor.col &lt; bd.textcol + bd.textlen))</a>
<a name="ln2174">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln2175">      if (bd.is_short &amp;&amp; !bd.is_MAX) {</a>
<a name="ln2176">        /* First line was too short, make it longer and adjust the</a>
<a name="ln2177">         * values in &quot;bd&quot;. */</a>
<a name="ln2178">        if (u_save_cursor() == FAIL)</a>
<a name="ln2179">          return;</a>
<a name="ln2180">        for (i = 0; i &lt; bd.endspaces; i++) {</a>
<a name="ln2181">          ins_char(' ');</a>
<a name="ln2182">        }</a>
<a name="ln2183">        bd.textlen += bd.endspaces;</a>
<a name="ln2184">      }</a>
<a name="ln2185">    } else {</a>
<a name="ln2186">      curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln2187">      check_cursor_col();</a>
<a name="ln2188"> </a>
<a name="ln2189">      // Works just like an 'i'nsert on the next character.</a>
<a name="ln2190">      if (!LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2191">          &amp;&amp; oap-&gt;start_vcol != oap-&gt;end_vcol) {</a>
<a name="ln2192">        inc_cursor();</a>
<a name="ln2193">      }</a>
<a name="ln2194">    }</a>
<a name="ln2195">  }</a>
<a name="ln2196"> </a>
<a name="ln2197">  t1 = oap-&gt;start;</a>
<a name="ln2198">  (void)edit(NUL, false, (linenr_T)count1);</a>
<a name="ln2199"> </a>
<a name="ln2200">  // When a tab was inserted, and the characters in front of the tab</a>
<a name="ln2201">  // have been converted to a tab as well, the column of the cursor</a>
<a name="ln2202">  // might have actually been reduced, so need to adjust here. */</a>
<a name="ln2203">  if (t1.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2204">      &amp;&amp; lt(curbuf-&gt;b_op_start_orig, t1)) {</a>
<a name="ln2205">    oap-&gt;start = curbuf-&gt;b_op_start_orig;</a>
<a name="ln2206">  }</a>
<a name="ln2207"> </a>
<a name="ln2208">  /* If user has moved off this line, we don't know what to do, so do</a>
<a name="ln2209">   * nothing.</a>
<a name="ln2210">   * Also don't repeat the insert when Insert mode ended with CTRL-C. */</a>
<a name="ln2211">  if (curwin-&gt;w_cursor.lnum != oap-&gt;start.lnum || got_int)</a>
<a name="ln2212">    return;</a>
<a name="ln2213"> </a>
<a name="ln2214">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2215">    struct block_def bd2;</a>
<a name="ln2216">    bool did_indent = false;</a>
<a name="ln2217"> </a>
<a name="ln2218">    // if indent kicked in, the firstline might have changed</a>
<a name="ln2219">    // but only do that, if the indent actually increased</a>
<a name="ln2220">    const colnr_T ind_post = (colnr_T)getwhitecols_curline();</a>
<a name="ln2221">    if (curbuf-&gt;b_op_start.col &gt; ind_pre &amp;&amp; ind_post &gt; ind_pre) {</a>
<a name="ln2222">      bd.textcol += ind_post - ind_pre;</a>
<a name="ln2223">      bd.start_vcol += ind_post - ind_pre;</a>
<a name="ln2224">      did_indent = true;</a>
<a name="ln2225">    }</a>
<a name="ln2226"> </a>
<a name="ln2227">    // The user may have moved the cursor before inserting something, try</a>
<a name="ln2228">    // to adjust the block for that.  But only do it, if the difference</a>
<a name="ln2229">    // does not come from indent kicking in.</a>
<a name="ln2230">    if (oap-&gt;start.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2231">        &amp;&amp; !bd.is_MAX</a>
<a name="ln2232">        &amp;&amp; !did_indent) {</a>
<a name="ln2233">      if (oap-&gt;op_type == OP_INSERT</a>
<a name="ln2234">          &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2235">          != curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2236">        int t = getviscol2(curbuf-&gt;b_op_start_orig.col,</a>
<a name="ln2237">                           curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2238">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2239">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2240">        oap-&gt;start_vcol = t;</a>
<a name="ln2241">      } else if (oap-&gt;op_type == OP_APPEND</a>
<a name="ln2242">                 &amp;&amp; oap-&gt;end.col + oap-&gt;end.coladd</a>
<a name="ln2243">                 &gt;= curbuf-&gt;b_op_start_orig.col</a>
<a name="ln2244">                 + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2245">        int t = getviscol2(curbuf-&gt;b_op_start_orig.col,</a>
<a name="ln2246">                           curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2247">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2248">        /* reset pre_textlen to the value of OP_INSERT */</a>
<a name="ln2249">        pre_textlen += bd.textlen;</a>
<a name="ln2250">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2251">        oap-&gt;start_vcol = t;</a>
<a name="ln2252">        oap-&gt;op_type = OP_INSERT;</a>
<a name="ln2253">      }</a>
<a name="ln2254">    }</a>
<a name="ln2255"> </a>
<a name="ln2256">    /*</a>
<a name="ln2257">     * Spaces and tabs in the indent may have changed to other spaces and</a>
<a name="ln2258">     * tabs.  Get the starting column again and correct the length.</a>
<a name="ln2259">     * Don't do this when &quot;$&quot; used, end-of-line will have changed.</a>
<a name="ln2260">     */</a>
<a name="ln2261">    block_prep(oap, &amp;bd2, oap-&gt;start.lnum, true);</a>
<a name="ln2262">    if (!bd.is_MAX || bd2.textlen &lt; bd.textlen) {</a>
<a name="ln2263">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2264">        pre_textlen += bd2.textlen - bd.textlen;</a>
<a name="ln2265">        if (bd2.endspaces)</a>
<a name="ln2266">          --bd2.textlen;</a>
<a name="ln2267">      }</a>
<a name="ln2268">      bd.textcol = bd2.textcol;</a>
<a name="ln2269">      bd.textlen = bd2.textlen;</a>
<a name="ln2270">    }</a>
<a name="ln2271"> </a>
<a name="ln2272">    /*</a>
<a name="ln2273">     * Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2274">     * copy of the required string.</a>
<a name="ln2275">     */</a>
<a name="ln2276">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2277">    const size_t len = STRLEN(firstline);</a>
<a name="ln2278">    colnr_T add = bd.textcol;</a>
<a name="ln2279">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2280">      add += bd.textlen;</a>
<a name="ln2281">    }</a>
<a name="ln2282">    if ((size_t)add &gt; len) {</a>
<a name="ln2283">      firstline += len;  // short line, point to the NUL</a>
<a name="ln2284">    } else {</a>
<a name="ln2285">      firstline += add;</a>
<a name="ln2286">    }</a>
<a name="ln2287">    ins_len = (long)STRLEN(firstline) - pre_textlen;</a>
<a name="ln2288">    if (pre_textlen &gt;= 0 &amp;&amp; ins_len &gt; 0) {</a>
<a name="ln2289">      ins_text = vim_strnsave(firstline, (size_t)ins_len);</a>
<a name="ln2290">      // block handled here</a>
<a name="ln2291">      if (u_save(oap-&gt;start.lnum, (linenr_T)(oap-&gt;end.lnum + 1)) == OK) {</a>
<a name="ln2292">        block_insert(oap, ins_text, (oap-&gt;op_type == OP_INSERT), &amp;bd);</a>
<a name="ln2293">      }</a>
<a name="ln2294"> </a>
<a name="ln2295">      curwin-&gt;w_cursor.col = oap-&gt;start.col;</a>
<a name="ln2296">      check_cursor();</a>
<a name="ln2297">      xfree(ins_text);</a>
<a name="ln2298">    }</a>
<a name="ln2299">  }</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">/*</a>
<a name="ln2303"> * op_change - handle a change operation</a>
<a name="ln2304"> *</a>
<a name="ln2305"> * return TRUE if edit() returns because of a CTRL-O command</a>
<a name="ln2306"> */</a>
<a name="ln2307">int op_change(oparg_T *oap)</a>
<a name="ln2308">{</a>
<a name="ln2309">  colnr_T l;</a>
<a name="ln2310">  int retval;</a>
<a name="ln2311">  long offset;</a>
<a name="ln2312">  linenr_T linenr;</a>
<a name="ln2313">  long ins_len;</a>
<a name="ln2314">  long pre_textlen = 0;</a>
<a name="ln2315">  long pre_indent = 0;</a>
<a name="ln2316">  char_u *newp;</a>
<a name="ln2317">  char_u *firstline;</a>
<a name="ln2318">  char_u *ins_text;</a>
<a name="ln2319">  char_u *oldp;</a>
<a name="ln2320">  struct block_def bd;</a>
<a name="ln2321"> </a>
<a name="ln2322">  l = oap-&gt;start.col;</a>
<a name="ln2323">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2324">    l = 0;</a>
<a name="ln2325">    if (!p_paste &amp;&amp; curbuf-&gt;b_p_si</a>
<a name="ln2326">        &amp;&amp; !curbuf-&gt;b_p_cin</a>
<a name="ln2327">        )</a>
<a name="ln2328">      can_si = true;            // It's like opening a new line, do si</a>
<a name="ln2329">  }</a>
<a name="ln2330"> </a>
<a name="ln2331">  /* First delete the text in the region.  In an empty buffer only need to</a>
<a name="ln2332">   * save for undo */</a>
<a name="ln2333">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2334">    if (u_save_cursor() == FAIL)</a>
<a name="ln2335">      return FALSE;</a>
<a name="ln2336">  } else if (op_delete(oap) == FAIL)</a>
<a name="ln2337">    return FALSE;</a>
<a name="ln2338"> </a>
<a name="ln2339">  if ((l &gt; curwin-&gt;w_cursor.col) &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2340">      &amp;&amp; !virtual_op) {</a>
<a name="ln2341">    inc_cursor();</a>
<a name="ln2342">  }</a>
<a name="ln2343"> </a>
<a name="ln2344">  // check for still on same line (&lt;CR&gt; in inserted text meaningless)</a>
<a name="ln2345">  // skip blank lines too</a>
<a name="ln2346">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2347">    // Add spaces before getting the current line length.</a>
<a name="ln2348">    if (virtual_op &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln2349">                       || gchar_cursor() == NUL)) {</a>
<a name="ln2350">      coladvance_force(getviscol());</a>
<a name="ln2351">    }</a>
<a name="ln2352">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2353">    pre_textlen = (long)STRLEN(firstline);</a>
<a name="ln2354">    pre_indent = (long)getwhitecols(firstline);</a>
<a name="ln2355">    bd.textcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2356">  }</a>
<a name="ln2357"> </a>
<a name="ln2358">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2359">    fix_indent();</a>
<a name="ln2360">  }</a>
<a name="ln2361"> </a>
<a name="ln2362">  retval = edit(NUL, FALSE, (linenr_T)1);</a>
<a name="ln2363"> </a>
<a name="ln2364">  /*</a>
<a name="ln2365">   * In Visual block mode, handle copying the new text to all lines of the</a>
<a name="ln2366">   * block.</a>
<a name="ln2367">   * Don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2368">   */</a>
<a name="ln2369">  if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2370">      &amp;&amp; oap-&gt;start.lnum != oap-&gt;end.lnum &amp;&amp; !got_int) {</a>
<a name="ln2371">    // Auto-indenting may have changed the indent.  If the cursor was past</a>
<a name="ln2372">    // the indent, exclude that indent change from the inserted text.</a>
<a name="ln2373">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2374">    if (bd.textcol &gt; (colnr_T)pre_indent) {</a>
<a name="ln2375">      long new_indent = (long)getwhitecols(firstline);</a>
<a name="ln2376"> </a>
<a name="ln2377">      pre_textlen += new_indent - pre_indent;</a>
<a name="ln2378">      bd.textcol += (colnr_T)(new_indent - pre_indent);</a>
<a name="ln2379">    }</a>
<a name="ln2380"> </a>
<a name="ln2381">    ins_len = (long)STRLEN(firstline) - pre_textlen;</a>
<a name="ln2382">    if (ins_len &gt; 0) {</a>
<a name="ln2383">      /* Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2384">       * copy of the inserted text.  */</a>
<a name="ln2385">      ins_text = (char_u *)xmalloc((size_t)(ins_len + 1));</a>
<a name="ln2386">      STRLCPY(ins_text, firstline + bd.textcol, ins_len + 1);</a>
<a name="ln2387">      for (linenr = oap-&gt;start.lnum + 1; linenr &lt;= oap-&gt;end.lnum;</a>
<a name="ln2388">           linenr++) {</a>
<a name="ln2389">        block_prep(oap, &amp;bd, linenr, true);</a>
<a name="ln2390">        if (!bd.is_short || virtual_op) {</a>
<a name="ln2391">          pos_T vpos;</a>
<a name="ln2392"> </a>
<a name="ln2393">          /* If the block starts in virtual space, count the</a>
<a name="ln2394">           * initial coladd offset as part of &quot;startspaces&quot; */</a>
<a name="ln2395">          if (bd.is_short) {</a>
<a name="ln2396">            vpos.lnum = linenr;</a>
<a name="ln2397">            (void)getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln2398">          } else {</a>
<a name="ln2399">            vpos.coladd = 0;</a>
<a name="ln2400">          }</a>
<a name="ln2401">          oldp = ml_get(linenr);</a>
<a name="ln2402">          newp = xmalloc(STRLEN(oldp) + (size_t)vpos.coladd</a>
<a name="ln2403">                         + (size_t)ins_len + 1);</a>
<a name="ln2404">          // copy up to block start</a>
<a name="ln2405">          memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln2406">          offset = bd.textcol;</a>
<a name="ln2407">          memset(newp + offset, ' ', (size_t)vpos.coladd);</a>
<a name="ln2408">          offset += vpos.coladd;</a>
<a name="ln2409">          memmove(newp + offset, ins_text, (size_t)ins_len);</a>
<a name="ln2410">          offset += ins_len;</a>
<a name="ln2411">          oldp += bd.textcol;</a>
<a name="ln2412">          STRMOVE(newp + offset, oldp);</a>
<a name="ln2413">          ml_replace(linenr, newp, false);</a>
<a name="ln2414">          extmark_splice_cols(curbuf, (int)linenr-1, bd.textcol,</a>
<a name="ln2415">                              0, vpos.coladd+(int)ins_len, kExtmarkUndo);</a>
<a name="ln2416">        }</a>
<a name="ln2417">      }</a>
<a name="ln2418">      check_cursor();</a>
<a name="ln2419">      changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2420">      xfree(ins_text);</a>
<a name="ln2421">    }</a>
<a name="ln2422">  }</a>
<a name="ln2423"> </a>
<a name="ln2424">  return retval;</a>
<a name="ln2425">}</a>
<a name="ln2426"> </a>
<a name="ln2427">/*</a>
<a name="ln2428"> * set all the yank registers to empty (called from main())</a>
<a name="ln2429"> */</a>
<a name="ln2430">void init_yank(void)</a>
<a name="ln2431">{</a>
<a name="ln2432">  memset(&amp;(y_regs[0]), 0, sizeof(y_regs));</a>
<a name="ln2433">}</a>
<a name="ln2434"> </a>
<a name="ln2435">#if defined(EXITFREE)</a>
<a name="ln2436">void clear_registers(void)</a>
<a name="ln2437">{</a>
<a name="ln2438">  int i;</a>
<a name="ln2439"> </a>
<a name="ln2440">  for (i = 0; i &lt; NUM_REGISTERS; i++) {</a>
<a name="ln2441">    free_register(&amp;y_regs[i]);</a>
<a name="ln2442">  }</a>
<a name="ln2443">}</a>
<a name="ln2444"> </a>
<a name="ln2445">#endif</a>
<a name="ln2446"> </a>
<a name="ln2447"> </a>
<a name="ln2448"> /// Free contents of yankreg `reg`.</a>
<a name="ln2449"> /// Called for normal freeing and in case of error.</a>
<a name="ln2450"> /// `reg` must not be NULL (but `reg-&gt;y_array` might be)</a>
<a name="ln2451">void free_register(yankreg_T *reg)</a>
<a name="ln2452">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2453">{</a>
<a name="ln2454">  set_yreg_additional_data(reg, NULL);</a>
<a name="ln2455">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln2456">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln2457">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln2458">    }</a>
<a name="ln2459">    XFREE_CLEAR(reg-&gt;y_array);</a>
<a name="ln2460">  }</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">/// Yanks the text between &quot;oap-&gt;start&quot; and &quot;oap-&gt;end&quot; into a yank register.</a>
<a name="ln2464">/// If we are to append (uppercase register), we first yank into a new yank</a>
<a name="ln2465">/// register and then concatenate the old and the new one.</a>
<a name="ln2466">///</a>
<a name="ln2467">/// @param oap operator arguments</a>
<a name="ln2468">/// @param message show message when more than `&amp;report` lines are yanked.</a>
<a name="ln2469">/// @param deleting whether the function was called from a delete operation.</a>
<a name="ln2470">/// @returns whether the operation register was writable.</a>
<a name="ln2471">bool op_yank(oparg_T *oap, bool message, int deleting)</a>
<a name="ln2472">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2473">{</a>
<a name="ln2474">  // check for read-only register</a>
<a name="ln2475">  if (oap-&gt;regname != 0 &amp;&amp; !valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln2476">    beep_flush();</a>
<a name="ln2477">    return false;</a>
<a name="ln2478">  }</a>
<a name="ln2479">  if (oap-&gt;regname == '_') {</a>
<a name="ln2480">    return true; // black hole: nothing to do</a>
<a name="ln2481">  }</a>
<a name="ln2482"> </a>
<a name="ln2483">  yankreg_T *reg = get_yank_register(oap-&gt;regname, YREG_YANK);</a>
<a name="ln2484">  op_yank_reg(oap, message, reg, is_append_register(oap-&gt;regname));</a>
<a name="ln2485">  // op_delete will set_clipboard and do_autocmd</a>
<a name="ln2486">  if (!deleting) {</a>
<a name="ln2487">    set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln2488">    do_autocmd_textyankpost(oap, reg);</a>
<a name="ln2489">  }</a>
<a name="ln2490"> </a>
<a name="ln2491">  return true;</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494">static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)</a>
<a name="ln2495">{</a>
<a name="ln2496">  yankreg_T newreg;  // new yank register when appending</a>
<a name="ln2497">  char_u **new_ptr;</a>
<a name="ln2498">  linenr_T lnum;     // current line number</a>
<a name="ln2499">  size_t j;</a>
<a name="ln2500">  MotionType yank_type = oap-&gt;motion_type;</a>
<a name="ln2501">  size_t yanklines = (size_t)oap-&gt;line_count;</a>
<a name="ln2502">  linenr_T yankendlnum = oap-&gt;end.lnum;</a>
<a name="ln2503">  char_u *p;</a>
<a name="ln2504">  char_u *pnew;</a>
<a name="ln2505">  struct block_def bd;</a>
<a name="ln2506"> </a>
<a name="ln2507">  yankreg_T *curr = reg;  // copy of current register</a>
<a name="ln2508">  // append to existing contents</a>
<a name="ln2509">  if (append &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln2510">    reg = &amp;newreg;</a>
<a name="ln2511">  } else {</a>
<a name="ln2512">    free_register(reg);  // free previously yanked lines</a>
<a name="ln2513">  }</a>
<a name="ln2514"> </a>
<a name="ln2515">  // If the cursor was in column 1 before and after the movement, and the</a>
<a name="ln2516">  // operator is not inclusive, the yank is always linewise.</a>
<a name="ln2517">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln2518">      &amp;&amp; oap-&gt;start.col == 0</a>
<a name="ln2519">      &amp;&amp; !oap-&gt;inclusive</a>
<a name="ln2520">      &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln2521">      &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln2522">      &amp;&amp; yanklines &gt; 1) {</a>
<a name="ln2523">    yank_type = kMTLineWise;</a>
<a name="ln2524">    yankendlnum--;</a>
<a name="ln2525">    yanklines--;</a>
<a name="ln2526">  }</a>
<a name="ln2527"> </a>
<a name="ln2528">  reg-&gt;y_size = yanklines;</a>
<a name="ln2529">  reg-&gt;y_type = yank_type;  // set the yank register type</a>
<a name="ln2530">  reg-&gt;y_width = 0;</a>
<a name="ln2531">  reg-&gt;y_array = xcalloc(yanklines, sizeof(char_u *));</a>
<a name="ln2532">  reg-&gt;additional_data = NULL;</a>
<a name="ln2533">  reg-&gt;timestamp = os_time();</a>
<a name="ln2534"> </a>
<a name="ln2535">  size_t y_idx = 0;  // index in y_array[]</a>
<a name="ln2536">  lnum = oap-&gt;start.lnum;</a>
<a name="ln2537"> </a>
<a name="ln2538">  if (yank_type == kMTBlockWise) {</a>
<a name="ln2539">    // Visual block mode</a>
<a name="ln2540">    reg-&gt;y_width = oap-&gt;end_vcol - oap-&gt;start_vcol;</a>
<a name="ln2541"> </a>
<a name="ln2542">    if (curwin-&gt;w_curswant == MAXCOL &amp;&amp; reg-&gt;y_width &gt; 0)</a>
<a name="ln2543">      reg-&gt;y_width--;</a>
<a name="ln2544">  }</a>
<a name="ln2545"> </a>
<a name="ln2546">  for (; lnum &lt;= yankendlnum; lnum++, y_idx++) {</a>
<a name="ln2547">    switch (reg-&gt;y_type) {</a>
<a name="ln2548">    case kMTBlockWise:</a>
<a name="ln2549">      block_prep(oap, &amp;bd, lnum, false);</a>
<a name="ln2550">      yank_copy_line(reg, &amp;bd, y_idx);</a>
<a name="ln2551">      break;</a>
<a name="ln2552"> </a>
<a name="ln2553">    case kMTLineWise:</a>
<a name="ln2554">      reg-&gt;y_array[y_idx] = vim_strsave(ml_get(lnum));</a>
<a name="ln2555">      break;</a>
<a name="ln2556"> </a>
<a name="ln2557">    case kMTCharWise:</a>
<a name="ln2558">    {</a>
<a name="ln2559">      colnr_T startcol = 0, endcol = MAXCOL;</a>
<a name="ln2560">      int is_oneChar = false;</a>
<a name="ln2561">      colnr_T cs, ce;</a>
<a name="ln2562">      p = ml_get(lnum);</a>
<a name="ln2563">      bd.startspaces = 0;</a>
<a name="ln2564">      bd.endspaces = 0;</a>
<a name="ln2565"> </a>
<a name="ln2566">      if (lnum == oap-&gt;start.lnum) {</a>
<a name="ln2567">        startcol = oap-&gt;start.col;</a>
<a name="ln2568">        if (virtual_op) {</a>
<a name="ln2569">          getvcol(curwin, &amp;oap-&gt;start, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2570">          if (ce != cs &amp;&amp; oap-&gt;start.coladd &gt; 0) {</a>
<a name="ln2571">            /* Part of a tab selected -- but don't</a>
<a name="ln2572">             * double-count it. */</a>
<a name="ln2573">            bd.startspaces = (ce - cs + 1)</a>
<a name="ln2574">                             - oap-&gt;start.coladd;</a>
<a name="ln2575">            startcol++;</a>
<a name="ln2576">          }</a>
<a name="ln2577">        }</a>
<a name="ln2578">      }</a>
<a name="ln2579"> </a>
<a name="ln2580">      if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln2581">        endcol = oap-&gt;end.col;</a>
<a name="ln2582">        if (virtual_op) {</a>
<a name="ln2583">          getvcol(curwin, &amp;oap-&gt;end, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2584">          if (p[endcol] == NUL || (cs + oap-&gt;end.coladd &lt; ce</a>
<a name="ln2585">                                   // Don't add space for double-wide</a>
<a name="ln2586">                                   // char; endcol will be on last byte</a>
<a name="ln2587">                                   // of multi-byte char.</a>
<a name="ln2588">                                   &amp;&amp; utf_head_off(p, p + endcol) == 0)) {</a>
<a name="ln2589">            if (oap-&gt;start.lnum == oap-&gt;end.lnum</a>
<a name="ln2590">                &amp;&amp; oap-&gt;start.col == oap-&gt;end.col) {</a>
<a name="ln2591">              // Special case: inside a single char</a>
<a name="ln2592">              is_oneChar = true;</a>
<a name="ln2593">              bd.startspaces = oap-&gt;end.coladd</a>
<a name="ln2594">                               - oap-&gt;start.coladd + oap-&gt;inclusive;</a>
<a name="ln2595">              endcol = startcol;</a>
<a name="ln2596">            } else {</a>
<a name="ln2597">              bd.endspaces = oap-&gt;end.coladd</a>
<a name="ln2598">                             + oap-&gt;inclusive;</a>
<a name="ln2599">              endcol -= oap-&gt;inclusive;</a>
<a name="ln2600">            }</a>
<a name="ln2601">          }</a>
<a name="ln2602">        }</a>
<a name="ln2603">      }</a>
<a name="ln2604">      if (endcol == MAXCOL)</a>
<a name="ln2605">        endcol = (colnr_T)STRLEN(p);</a>
<a name="ln2606">      if (startcol &gt; endcol</a>
<a name="ln2607">          || is_oneChar</a>
<a name="ln2608">          ) {</a>
<a name="ln2609">        bd.textlen = 0;</a>
<a name="ln2610">      } else {</a>
<a name="ln2611">        bd.textlen = endcol - startcol + oap-&gt;inclusive;</a>
<a name="ln2612">      }</a>
<a name="ln2613">      bd.textstart = p + startcol;</a>
<a name="ln2614">      yank_copy_line(reg, &amp;bd, y_idx);</a>
<a name="ln2615">      break;</a>
<a name="ln2616">    }</a>
<a name="ln2617">    // NOTREACHED</a>
<a name="ln2618">    case kMTUnknown:</a>
<a name="ln2619">        assert(false);</a>
<a name="ln2620">    }</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  if (curr != reg) {      /* append the new block to the old block */</a>
<a name="ln2624">    new_ptr = xmalloc(sizeof(char_u *) * (curr-&gt;y_size + reg-&gt;y_size));</a>
<a name="ln2625">    for (j = 0; j &lt; curr-&gt;y_size; ++j)</a>
<a name="ln2626">      new_ptr[j] = curr-&gt;y_array[j];</a>
<a name="ln2627">    xfree(curr-&gt;y_array);</a>
<a name="ln2628">    curr-&gt;y_array = new_ptr;</a>
<a name="ln2629"> </a>
<a name="ln2630">    if (yank_type == kMTLineWise) {</a>
<a name="ln2631">      // kMTLineWise overrides kMTCharWise and kMTBlockWise</a>
<a name="ln2632">      curr-&gt;y_type = kMTLineWise;</a>
<a name="ln2633">    }</a>
<a name="ln2634"> </a>
<a name="ln2635">    // Concatenate the last line of the old block with the first line of</a>
<a name="ln2636">    // the new block, unless being Vi compatible.</a>
<a name="ln2637">    if (curr-&gt;y_type == kMTCharWise</a>
<a name="ln2638">        &amp;&amp; vim_strchr(p_cpo, CPO_REGAPPEND) == NULL) {</a>
<a name="ln2639">      pnew = xmalloc(STRLEN(curr-&gt;y_array[curr-&gt;y_size - 1])</a>
<a name="ln2640">                     + STRLEN(reg-&gt;y_array[0]) + 1);</a>
<a name="ln2641">      STRCPY(pnew, curr-&gt;y_array[--j]);</a>
<a name="ln2642">      STRCAT(pnew, reg-&gt;y_array[0]);</a>
<a name="ln2643">      xfree(curr-&gt;y_array[j]);</a>
<a name="ln2644">      xfree(reg-&gt;y_array[0]);</a>
<a name="ln2645">      curr-&gt;y_array[j++] = pnew;</a>
<a name="ln2646">      y_idx = 1;</a>
<a name="ln2647">    } else</a>
<a name="ln2648">      y_idx = 0;</a>
<a name="ln2649">    while (y_idx &lt; reg-&gt;y_size)</a>
<a name="ln2650">      curr-&gt;y_array[j++] = reg-&gt;y_array[y_idx++];</a>
<a name="ln2651">    curr-&gt;y_size = j;</a>
<a name="ln2652">    xfree(reg-&gt;y_array);</a>
<a name="ln2653">  }</a>
<a name="ln2654">  if (curwin-&gt;w_p_rnu) {</a>
<a name="ln2655">    redraw_later(curwin, SOME_VALID);  // cursor moved to start</a>
<a name="ln2656">  }</a>
<a name="ln2657">  if (message) {  // Display message about yank?</a>
<a name="ln2658">    if (yank_type == kMTCharWise &amp;&amp; yanklines == 1) {</a>
<a name="ln2659">      yanklines = 0;</a>
<a name="ln2660">    }</a>
<a name="ln2661">    // Some versions of Vi use &quot;&gt;=&quot; here, some don't...</a>
<a name="ln2662">    if (yanklines &gt; (size_t)p_report) {</a>
<a name="ln2663">      char namebuf[100];</a>
<a name="ln2664"> </a>
<a name="ln2665">      if (oap-&gt;regname == NUL) {</a>
<a name="ln2666">        *namebuf = NUL;</a>
<a name="ln2667">      } else {</a>
<a name="ln2668">        vim_snprintf(namebuf, sizeof(namebuf), _(&quot; into \&quot;%c&quot;), oap-&gt;regname);</a>
<a name="ln2669">      }</a>
<a name="ln2670"> </a>
<a name="ln2671">      // redisplay now, so message is not deleted</a>
<a name="ln2672">      update_topline_redraw();</a>
<a name="ln2673">      if (yanklines == 1) {</a>
<a name="ln2674">        if (yank_type == kMTBlockWise) {</a>
<a name="ln2675">          smsg(_(&quot;block of 1 line yanked%s&quot;), namebuf);</a>
<a name="ln2676">        } else {</a>
<a name="ln2677">          smsg(_(&quot;1 line yanked%s&quot;), namebuf);</a>
<a name="ln2678">        }</a>
<a name="ln2679">      } else if (yank_type == kMTBlockWise) {</a>
<a name="ln2680">        smsg(_(&quot;block of %&quot; PRId64 &quot; lines yanked%s&quot;),</a>
<a name="ln2681">             (int64_t)yanklines, namebuf);</a>
<a name="ln2682">      } else {</a>
<a name="ln2683">        smsg(_(&quot;%&quot; PRId64 &quot; lines yanked%s&quot;), (int64_t)yanklines, namebuf);</a>
<a name="ln2684">      }</a>
<a name="ln2685">    }</a>
<a name="ln2686">  }</a>
<a name="ln2687"> </a>
<a name="ln2688">  /*</a>
<a name="ln2689">   * Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2690">   */</a>
<a name="ln2691">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2692">  curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2693">  if (yank_type == kMTLineWise) {</a>
<a name="ln2694">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln2695">    curbuf-&gt;b_op_end.col = MAXCOL;</a>
<a name="ln2696">  }</a>
<a name="ln2697"> </a>
<a name="ln2698">  return;</a>
<a name="ln2699">}</a>
<a name="ln2700"> </a>
<a name="ln2701">static void yank_copy_line(yankreg_T *reg, struct block_def *bd, size_t y_idx)</a>
<a name="ln2702">{</a>
<a name="ln2703">  int size = bd-&gt;startspaces + bd-&gt;endspaces + bd-&gt;textlen;</a>
<a name="ln2704">  assert(size &gt;= 0);</a>
<a name="ln2705">  char_u *pnew = xmallocz((size_t)size);</a>
<a name="ln2706">  reg-&gt;y_array[y_idx] = pnew;</a>
<a name="ln2707">  memset(pnew, ' ', (size_t)bd-&gt;startspaces);</a>
<a name="ln2708">  pnew += bd-&gt;startspaces;</a>
<a name="ln2709">  memmove(pnew, bd-&gt;textstart, (size_t)bd-&gt;textlen);</a>
<a name="ln2710">  pnew += bd-&gt;textlen;</a>
<a name="ln2711">  memset(pnew, ' ', (size_t)bd-&gt;endspaces);</a>
<a name="ln2712">  pnew += bd-&gt;endspaces;</a>
<a name="ln2713">  *pnew = NUL;</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">/// Execute autocommands for TextYankPost.</a>
<a name="ln2717">///</a>
<a name="ln2718">/// @param oap Operator arguments.</a>
<a name="ln2719">/// @param reg The yank register used.</a>
<a name="ln2720">static void do_autocmd_textyankpost(oparg_T *oap, yankreg_T *reg)</a>
<a name="ln2721">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2722">{</a>
<a name="ln2723">  static bool recursive = false;</a>
<a name="ln2724"> </a>
<a name="ln2725">  if (recursive || !has_event(EVENT_TEXTYANKPOST)) {</a>
<a name="ln2726">    // No autocommand was defined, or we yanked from this autocommand.</a>
<a name="ln2727">    return;</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  recursive = true;</a>
<a name="ln2731"> </a>
<a name="ln2732">  // Set the v:event dictionary with information about the yank.</a>
<a name="ln2733">  dict_T *dict = get_vim_var_dict(VV_EVENT);</a>
<a name="ln2734"> </a>
<a name="ln2735">  // The yanked text contents.</a>
<a name="ln2736">  list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln2737">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln2738">    tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln2739">  }</a>
<a name="ln2740">  tv_list_set_lock(list, VAR_FIXED);</a>
<a name="ln2741">  tv_dict_add_list(dict, S_LEN(&quot;regcontents&quot;), list);</a>
<a name="ln2742"> </a>
<a name="ln2743">  // Register type.</a>
<a name="ln2744">  char buf[NUMBUFLEN+2];</a>
<a name="ln2745">  format_reg_type(reg-&gt;y_type, reg-&gt;y_width, buf, ARRAY_SIZE(buf));</a>
<a name="ln2746">  tv_dict_add_str(dict, S_LEN(&quot;regtype&quot;), buf);</a>
<a name="ln2747"> </a>
<a name="ln2748">  // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln2749">  buf[0] = (char)oap-&gt;regname;</a>
<a name="ln2750">  buf[1] = NUL;</a>
<a name="ln2751">  tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln2752"> </a>
<a name="ln2753">  // Motion type: inclusive or exclusive.</a>
<a name="ln2754">  tv_dict_add_bool(dict, S_LEN(&quot;inclusive&quot;),</a>
<a name="ln2755">                   oap-&gt;inclusive ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2756"> </a>
<a name="ln2757">  // Kind of operation: yank, delete, change).</a>
<a name="ln2758">  buf[0] = (char)get_op_char(oap-&gt;op_type);</a>
<a name="ln2759">  buf[1] = NUL;</a>
<a name="ln2760">  tv_dict_add_str(dict, S_LEN(&quot;operator&quot;), buf);</a>
<a name="ln2761"> </a>
<a name="ln2762">  // Selection type: visual or not.</a>
<a name="ln2763">  tv_dict_add_bool(dict, S_LEN(&quot;visual&quot;),</a>
<a name="ln2764">                   oap-&gt;is_VIsual ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2765"> </a>
<a name="ln2766">  tv_dict_set_keys_readonly(dict);</a>
<a name="ln2767">  textlock++;</a>
<a name="ln2768">  apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, false, curbuf);</a>
<a name="ln2769">  textlock--;</a>
<a name="ln2770">  tv_dict_clear(dict);</a>
<a name="ln2771"> </a>
<a name="ln2772">  recursive = false;</a>
<a name="ln2773">}</a>
<a name="ln2774"> </a>
<a name="ln2775">/*</a>
<a name="ln2776"> * Put contents of register &quot;regname&quot; into the text.</a>
<a name="ln2777"> * Caller must check &quot;regname&quot; to be valid!</a>
<a name="ln2778"> * &quot;flags&quot;: PUT_FIXINDENT     make indent look nice</a>
<a name="ln2779"> *          PUT_CURSEND       leave cursor after end of new text</a>
<a name="ln2780"> *          PUT_LINE          force linewise put (&quot;:put&quot;)</a>
<a name="ln2781">    dir: BACKWARD for 'P', FORWARD for 'p' */</a>
<a name="ln2782">void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)</a>
<a name="ln2783">{</a>
<a name="ln2784">  char_u *ptr;</a>
<a name="ln2785">  char_u *newp;</a>
<a name="ln2786">  char_u *oldp;</a>
<a name="ln2787">  int yanklen;</a>
<a name="ln2788">  size_t totlen = 0;  // init for gcc</a>
<a name="ln2789">  linenr_T lnum = 0;</a>
<a name="ln2790">  colnr_T col = 0;</a>
<a name="ln2791">  size_t i;  // index in y_array[]</a>
<a name="ln2792">  MotionType y_type;</a>
<a name="ln2793">  size_t y_size;</a>
<a name="ln2794">  size_t oldlen;</a>
<a name="ln2795">  int y_width = 0;</a>
<a name="ln2796">  colnr_T vcol;</a>
<a name="ln2797">  int delcount;</a>
<a name="ln2798">  int incr = 0;</a>
<a name="ln2799">  struct block_def bd;</a>
<a name="ln2800">  char_u      **y_array = NULL;</a>
<a name="ln2801">  long nr_lines = 0;</a>
<a name="ln2802">  pos_T new_cursor;</a>
<a name="ln2803">  int indent;</a>
<a name="ln2804">  int orig_indent = 0;                  /* init for gcc */</a>
<a name="ln2805">  int indent_diff = 0;                  /* init for gcc */</a>
<a name="ln2806">  int first_indent = TRUE;</a>
<a name="ln2807">  int lendiff = 0;</a>
<a name="ln2808">  pos_T old_pos;</a>
<a name="ln2809">  char_u      *insert_string = NULL;</a>
<a name="ln2810">  bool allocated = false;</a>
<a name="ln2811">  long cnt;</a>
<a name="ln2812"> </a>
<a name="ln2813">  if (flags &amp; PUT_FIXINDENT)</a>
<a name="ln2814">    orig_indent = get_indent();</a>
<a name="ln2815"> </a>
<a name="ln2816">  curbuf-&gt;b_op_start = curwin-&gt;w_cursor;        /* default for '[ mark */</a>
<a name="ln2817">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;          /* default for '] mark */</a>
<a name="ln2818"> </a>
<a name="ln2819">  /*</a>
<a name="ln2820">   * Using inserted text works differently, because the register includes</a>
<a name="ln2821">   * special characters (newlines, etc.).</a>
<a name="ln2822">   */</a>
<a name="ln2823">  if (regname == '.' &amp;&amp; !reg) {</a>
<a name="ln2824">    bool non_linewise_vis = (VIsual_active &amp;&amp; VIsual_mode != 'V');</a>
<a name="ln2825"> </a>
<a name="ln2826">    // PUT_LINE has special handling below which means we use 'i' to start.</a>
<a name="ln2827">    char command_start_char = non_linewise_vis ? 'c' :</a>
<a name="ln2828">      (flags &amp; PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));</a>
<a name="ln2829"> </a>
<a name="ln2830">    // To avoid 'autoindent' on linewise puts, create a new line with `:put _`.</a>
<a name="ln2831">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2832">      do_put('_', NULL, dir, 1, PUT_LINE);</a>
<a name="ln2833">    }</a>
<a name="ln2834"> </a>
<a name="ln2835">    // If given a count when putting linewise, we stuff the readbuf with the</a>
<a name="ln2836">    // dot register 'count' times split by newlines.</a>
<a name="ln2837">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2838">      stuffcharReadbuff(command_start_char);</a>
<a name="ln2839">      for (; count &gt; 0; count--) {</a>
<a name="ln2840">        (void)stuff_inserted(NUL, 1, count != 1);</a>
<a name="ln2841">        if (count != 1) {</a>
<a name="ln2842">          // To avoid 'autoindent' affecting the text, use Ctrl_U to remove any</a>
<a name="ln2843">          // whitespace. Can't just insert Ctrl_U into readbuf1, this would go</a>
<a name="ln2844">          // back to the previous line in the case of 'noautoindent' and</a>
<a name="ln2845">          // 'backspace' includes &quot;eol&quot;. So we insert a dummy space for Ctrl_U</a>
<a name="ln2846">          // to consume.</a>
<a name="ln2847">          stuffReadbuff(&quot;\n &quot;);</a>
<a name="ln2848">          stuffcharReadbuff(Ctrl_U);</a>
<a name="ln2849">        }</a>
<a name="ln2850">      }</a>
<a name="ln2851">    } else {</a>
<a name="ln2852">      (void)stuff_inserted(command_start_char, count, false);</a>
<a name="ln2853">    }</a>
<a name="ln2854"> </a>
<a name="ln2855">    // Putting the text is done later, so can't move the cursor to the next</a>
<a name="ln2856">    // character.  Simulate it with motion commands after the insert.</a>
<a name="ln2857">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln2858">      if (flags &amp; PUT_LINE) {</a>
<a name="ln2859">        stuffReadbuff(&quot;j0&quot;);</a>
<a name="ln2860">      } else {</a>
<a name="ln2861">        // Avoid ringing the bell from attempting to move into the space after</a>
<a name="ln2862">        // the current line. We can stuff the readbuffer with &quot;l&quot; if:</a>
<a name="ln2863">        // 1) 'virtualedit' is &quot;all&quot; or &quot;onemore&quot;</a>
<a name="ln2864">        // 2) We are not at the end of the line</a>
<a name="ln2865">        // 3) We are not  (one past the end of the line &amp;&amp; on the last line)</a>
<a name="ln2866">        //    This allows a visual put over a selection one past the end of the</a>
<a name="ln2867">        //    line joining the current line with the one below.</a>
<a name="ln2868"> </a>
<a name="ln2869">        // curwin-&gt;w_cursor.col marks the byte position of the cursor in the</a>
<a name="ln2870">        // currunt line. It increases up to a max of</a>
<a name="ln2871">        // STRLEN(ml_get(curwin-&gt;w_cursor.lnum)). With 'virtualedit' and the</a>
<a name="ln2872">        // cursor past the end of the line, curwin-&gt;w_cursor.coladd is</a>
<a name="ln2873">        // incremented instead of curwin-&gt;w_cursor.col.</a>
<a name="ln2874">        char_u *cursor_pos = get_cursor_pos_ptr();</a>
<a name="ln2875">        bool one_past_line = (*cursor_pos == NUL);</a>
<a name="ln2876">        bool eol = false;</a>
<a name="ln2877">        if (!one_past_line) {</a>
<a name="ln2878">          eol = (*(cursor_pos + mb_ptr2len(cursor_pos)) == NUL);</a>
<a name="ln2879">        }</a>
<a name="ln2880"> </a>
<a name="ln2881">        bool ve_allows = (ve_flags == VE_ALL || ve_flags == VE_ONEMORE);</a>
<a name="ln2882">        bool eof = curbuf-&gt;b_ml.ml_line_count == curwin-&gt;w_cursor.lnum</a>
<a name="ln2883">                   &amp;&amp; one_past_line;</a>
<a name="ln2884">        if (ve_allows || !(eol || eof)) {</a>
<a name="ln2885">          stuffcharReadbuff('l');</a>
<a name="ln2886">        }</a>
<a name="ln2887">      }</a>
<a name="ln2888">    } else if (flags &amp; PUT_LINE) {</a>
<a name="ln2889">      stuffReadbuff(&quot;g'[&quot;);</a>
<a name="ln2890">    }</a>
<a name="ln2891"> </a>
<a name="ln2892">    // So the 'u' command restores cursor position after &quot;.p, save the cursor</a>
<a name="ln2893">    // position now (though not saving any text).</a>
<a name="ln2894">    if (command_start_char == 'a') {</a>
<a name="ln2895">      if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln2896">        return;</a>
<a name="ln2897">      }</a>
<a name="ln2898">    }</a>
<a name="ln2899">    return;</a>
<a name="ln2900">  }</a>
<a name="ln2901"> </a>
<a name="ln2902">  /*</a>
<a name="ln2903">   * For special registers '%' (file name), '#' (alternate file name) and</a>
<a name="ln2904">   * ':' (last command line), etc. we have to create a fake yank register.</a>
<a name="ln2905">   */</a>
<a name="ln2906">  if (!reg &amp;&amp; get_spec_reg(regname, &amp;insert_string, &amp;allocated, true)) {</a>
<a name="ln2907">    if (insert_string == NULL) {</a>
<a name="ln2908">      return;</a>
<a name="ln2909">    }</a>
<a name="ln2910">  }</a>
<a name="ln2911"> </a>
<a name="ln2912">  if (!curbuf-&gt;terminal) {</a>
<a name="ln2913">    // Autocommands may be executed when saving lines for undo.  This might</a>
<a name="ln2914">    // make y_array invalid, so we start undo now to avoid that.</a>
<a name="ln2915">    if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln2916">      return;</a>
<a name="ln2917">    }</a>
<a name="ln2918">  }</a>
<a name="ln2919"> </a>
<a name="ln2920">  if (insert_string != NULL) {</a>
<a name="ln2921">    y_type = kMTCharWise;</a>
<a name="ln2922">    if (regname == '=') {</a>
<a name="ln2923">      /* For the = register we need to split the string at NL</a>
<a name="ln2924">       * characters.</a>
<a name="ln2925">       * Loop twice: count the number of lines and save them. */</a>
<a name="ln2926">      for (;; ) {</a>
<a name="ln2927">        y_size = 0;</a>
<a name="ln2928">        ptr = insert_string;</a>
<a name="ln2929">        while (ptr != NULL) {</a>
<a name="ln2930">          if (y_array != NULL)</a>
<a name="ln2931">            y_array[y_size] = ptr;</a>
<a name="ln2932">          ++y_size;</a>
<a name="ln2933">          ptr = vim_strchr(ptr, '\n');</a>
<a name="ln2934">          if (ptr != NULL) {</a>
<a name="ln2935">            if (y_array != NULL)</a>
<a name="ln2936">              *ptr = NUL;</a>
<a name="ln2937">            ++ptr;</a>
<a name="ln2938">            /* A trailing '\n' makes the register linewise. */</a>
<a name="ln2939">            if (*ptr == NUL) {</a>
<a name="ln2940">              y_type = kMTLineWise;</a>
<a name="ln2941">              break;</a>
<a name="ln2942">            }</a>
<a name="ln2943">          }</a>
<a name="ln2944">        }</a>
<a name="ln2945">        if (y_array != NULL)</a>
<a name="ln2946">          break;</a>
<a name="ln2947">        y_array = (char_u **)xmalloc(y_size * sizeof(char_u *));</a>
<a name="ln2948">      }</a>
<a name="ln2949">    } else {</a>
<a name="ln2950">      y_size = 1;               /* use fake one-line yank register */</a>
<a name="ln2951">      y_array = &amp;insert_string;</a>
<a name="ln2952">    }</a>
<a name="ln2953">  } else {</a>
<a name="ln2954">    // in case of replacing visually selected text</a>
<a name="ln2955">    // the yankreg might already have been saved to avoid</a>
<a name="ln2956">    // just restoring the deleted text.</a>
<a name="ln2957">    if (reg == NULL) {</a>
<a name="ln2958">      reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln2959">    }</a>
<a name="ln2960"> </a>
<a name="ln2961">    y_type = reg-&gt;y_type;</a>
<a name="ln2962">    y_width = reg-&gt;y_width;</a>
<a name="ln2963">    y_size = reg-&gt;y_size;</a>
<a name="ln2964">    y_array = reg-&gt;y_array;</a>
<a name="ln2965">  }</a>
<a name="ln2966"> </a>
<a name="ln2967">  if (curbuf-&gt;terminal) {</a>
<a name="ln2968">    terminal_paste(count, y_array, y_size);</a>
<a name="ln2969">    return;</a>
<a name="ln2970">  }</a>
<a name="ln2971"> </a>
<a name="ln2972">  if (y_type == kMTLineWise) {</a>
<a name="ln2973">    if (flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln2974">      // &quot;p&quot; or &quot;P&quot; in Visual mode: split the lines to put the text in</a>
<a name="ln2975">      // between.</a>
<a name="ln2976">      if (u_save_cursor() == FAIL) {</a>
<a name="ln2977">        goto end;</a>
<a name="ln2978">      }</a>
<a name="ln2979">      char_u *p = get_cursor_pos_ptr();</a>
<a name="ln2980">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln2981">        MB_PTR_ADV(p);</a>
<a name="ln2982">      }</a>
<a name="ln2983">      ptr = vim_strsave(p);</a>
<a name="ln2984">      ml_append(curwin-&gt;w_cursor.lnum, ptr, (colnr_T)0, false);</a>
<a name="ln2985">      xfree(ptr);</a>
<a name="ln2986"> </a>
<a name="ln2987">      oldp = get_cursor_line_ptr();</a>
<a name="ln2988">      p = oldp + curwin-&gt;w_cursor.col;</a>
<a name="ln2989">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln2990">        MB_PTR_ADV(p);</a>
<a name="ln2991">      }</a>
<a name="ln2992">      ptr = vim_strnsave(oldp, (size_t)(p - oldp));</a>
<a name="ln2993">      ml_replace(curwin-&gt;w_cursor.lnum, ptr, false);</a>
<a name="ln2994">      nr_lines++;</a>
<a name="ln2995">      dir = FORWARD;</a>
<a name="ln2996">    }</a>
<a name="ln2997">    if (flags &amp; PUT_LINE_FORWARD) {</a>
<a name="ln2998">      /* Must be &quot;p&quot; for a Visual block, put lines below the block. */</a>
<a name="ln2999">      curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln3000">      dir = FORWARD;</a>
<a name="ln3001">    }</a>
<a name="ln3002">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      /* default for '[ mark */</a>
<a name="ln3003">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;        /* default for '] mark */</a>
<a name="ln3004">  }</a>
<a name="ln3005"> </a>
<a name="ln3006">  if (flags &amp; PUT_LINE) {  // :put command or &quot;p&quot; in Visual line mode.</a>
<a name="ln3007">    y_type = kMTLineWise;</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010">  if (y_size == 0 || y_array == NULL) {</a>
<a name="ln3011">    EMSG2(_(&quot;E353: Nothing in register %s&quot;),</a>
<a name="ln3012">        regname == 0 ? (char_u *)&quot;\&quot;&quot; : transchar(regname));</a>
<a name="ln3013">    goto end;</a>
<a name="ln3014">  }</a>
<a name="ln3015"> </a>
<a name="ln3016">  if (y_type == kMTBlockWise) {</a>
<a name="ln3017">    lnum = curwin-&gt;w_cursor.lnum + (linenr_T)y_size + 1;</a>
<a name="ln3018">    if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3019">      lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln3020">    }</a>
<a name="ln3021">    if (u_save(curwin-&gt;w_cursor.lnum - 1, lnum) == FAIL) {</a>
<a name="ln3022">      goto end;</a>
<a name="ln3023">    }</a>
<a name="ln3024">  } else if (y_type == kMTLineWise) {</a>
<a name="ln3025">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3026">    // Correct line number for closed fold.  Don't move the cursor yet,</a>
<a name="ln3027">    // u_save() uses it.</a>
<a name="ln3028">    if (dir == BACKWARD) {</a>
<a name="ln3029">      (void)hasFolding(lnum, &amp;lnum, NULL);</a>
<a name="ln3030">    } else {</a>
<a name="ln3031">      (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3032">    }</a>
<a name="ln3033">    if (dir == FORWARD) {</a>
<a name="ln3034">      lnum++;</a>
<a name="ln3035">    }</a>
<a name="ln3036">    // In an empty buffer the empty line is going to be replaced, include</a>
<a name="ln3037">    // it in the saved lines.</a>
<a name="ln3038">    if ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) {</a>
<a name="ln3039">      goto end;</a>
<a name="ln3040">    }</a>
<a name="ln3041">    if (dir == FORWARD) {</a>
<a name="ln3042">      curwin-&gt;w_cursor.lnum = lnum - 1;</a>
<a name="ln3043">    } else {</a>
<a name="ln3044">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3045">    }</a>
<a name="ln3046">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // for mark_adjust()</a>
<a name="ln3047">  } else if (u_save_cursor() == FAIL) {</a>
<a name="ln3048">    goto end;</a>
<a name="ln3049">  }</a>
<a name="ln3050"> </a>
<a name="ln3051">  yanklen = (int)STRLEN(y_array[0]);</a>
<a name="ln3052"> </a>
<a name="ln3053">  if (ve_flags == VE_ALL &amp;&amp; y_type == kMTCharWise) {</a>
<a name="ln3054">    if (gchar_cursor() == TAB) {</a>
<a name="ln3055">      /* Don't need to insert spaces when &quot;p&quot; on the last position of a</a>
<a name="ln3056">       * tab or &quot;P&quot; on the first position. */</a>
<a name="ln3057">      if (dir == FORWARD</a>
<a name="ln3058">          ? (int)curwin-&gt;w_cursor.coladd &lt; curbuf-&gt;b_p_ts - 1</a>
<a name="ln3059">          : curwin-&gt;w_cursor.coladd &gt; 0)</a>
<a name="ln3060">        coladvance_force(getviscol());</a>
<a name="ln3061">      else</a>
<a name="ln3062">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3063">    } else if (curwin-&gt;w_cursor.coladd &gt; 0 || gchar_cursor() == NUL)</a>
<a name="ln3064">      coladvance_force(getviscol() + (dir == FORWARD));</a>
<a name="ln3065">  }</a>
<a name="ln3066"> </a>
<a name="ln3067">  lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3068">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln3069"> </a>
<a name="ln3070">  /*</a>
<a name="ln3071">   * Block mode</a>
<a name="ln3072">   */</a>
<a name="ln3073">  if (y_type == kMTBlockWise) {</a>
<a name="ln3074">    int c = gchar_cursor();</a>
<a name="ln3075">    colnr_T endcol2 = 0;</a>
<a name="ln3076"> </a>
<a name="ln3077">    if (dir == FORWARD &amp;&amp; c != NUL) {</a>
<a name="ln3078">      if (ve_flags == VE_ALL)</a>
<a name="ln3079">        getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3080">      else</a>
<a name="ln3081">        getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;col);</a>
<a name="ln3082"> </a>
<a name="ln3083">      // move to start of next multi-byte character</a>
<a name="ln3084">      curwin-&gt;w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3085">      col++;</a>
<a name="ln3086">    } else {</a>
<a name="ln3087">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3088">    }</a>
<a name="ln3089"> </a>
<a name="ln3090">    col += curwin-&gt;w_cursor.coladd;</a>
<a name="ln3091">    if (ve_flags == VE_ALL</a>
<a name="ln3092">        &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln3093">            || endcol2 == curwin-&gt;w_cursor.col)) {</a>
<a name="ln3094">      if (dir == FORWARD &amp;&amp; c == NUL) {</a>
<a name="ln3095">        col++;</a>
<a name="ln3096">      }</a>
<a name="ln3097">      if (dir != FORWARD &amp;&amp; c != NUL &amp;&amp; curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3098">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3099">      }</a>
<a name="ln3100">      if (c == TAB) {</a>
<a name="ln3101">        if (dir == BACKWARD &amp;&amp; curwin-&gt;w_cursor.col)</a>
<a name="ln3102">          curwin-&gt;w_cursor.col--;</a>
<a name="ln3103">        if (dir == FORWARD &amp;&amp; col - 1 == endcol2)</a>
<a name="ln3104">          curwin-&gt;w_cursor.col++;</a>
<a name="ln3105">      }</a>
<a name="ln3106">    }</a>
<a name="ln3107">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3108">    bd.textcol = 0;</a>
<a name="ln3109">    for (i = 0; i &lt; y_size; i++) {</a>
<a name="ln3110">      int spaces;</a>
<a name="ln3111">      char shortline;</a>
<a name="ln3112">      // can just be 0 or 1, needed for blockwise paste beyond the current</a>
<a name="ln3113">      // buffer end</a>
<a name="ln3114">      int lines_appended = 0;</a>
<a name="ln3115"> </a>
<a name="ln3116">      bd.startspaces = 0;</a>
<a name="ln3117">      bd.endspaces = 0;</a>
<a name="ln3118">      vcol = 0;</a>
<a name="ln3119">      delcount = 0;</a>
<a name="ln3120"> </a>
<a name="ln3121">      /* add a new line */</a>
<a name="ln3122">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3123">        if (ml_append(curbuf-&gt;b_ml.ml_line_count, (char_u *)&quot;&quot;,</a>
<a name="ln3124">                      (colnr_T)1, false) == FAIL) {</a>
<a name="ln3125">          break;</a>
<a name="ln3126">        }</a>
<a name="ln3127">        nr_lines++;</a>
<a name="ln3128">        lines_appended = 1;</a>
<a name="ln3129">      }</a>
<a name="ln3130">      /* get the old line and advance to the position to insert at */</a>
<a name="ln3131">      oldp = get_cursor_line_ptr();</a>
<a name="ln3132">      oldlen = STRLEN(oldp);</a>
<a name="ln3133">      for (ptr = oldp; vcol &lt; col &amp;&amp; *ptr; ) {</a>
<a name="ln3134">        /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln3135">        incr = lbr_chartabsize_adv(oldp, &amp;ptr, (colnr_T)vcol);</a>
<a name="ln3136">        vcol += incr;</a>
<a name="ln3137">      }</a>
<a name="ln3138">      bd.textcol = (colnr_T)(ptr - oldp);</a>
<a name="ln3139"> </a>
<a name="ln3140">      shortline = (vcol &lt; col) || (vcol == col &amp;&amp; !*ptr);</a>
<a name="ln3141"> </a>
<a name="ln3142">      if (vcol &lt; col)       /* line too short, padd with spaces */</a>
<a name="ln3143">        bd.startspaces = col - vcol;</a>
<a name="ln3144">      else if (vcol &gt; col) {</a>
<a name="ln3145">        bd.endspaces = vcol - col;</a>
<a name="ln3146">        bd.startspaces = incr - bd.endspaces;</a>
<a name="ln3147">        --bd.textcol;</a>
<a name="ln3148">        delcount = 1;</a>
<a name="ln3149">        bd.textcol -= utf_head_off(oldp, oldp + bd.textcol);</a>
<a name="ln3150">        if (oldp[bd.textcol] != TAB) {</a>
<a name="ln3151">          /* Only a Tab can be split into spaces.  Other</a>
<a name="ln3152">           * characters will have to be moved to after the</a>
<a name="ln3153">           * block, causing misalignment. */</a>
<a name="ln3154">          delcount = 0;</a>
<a name="ln3155">          bd.endspaces = 0;</a>
<a name="ln3156">        }</a>
<a name="ln3157">      }</a>
<a name="ln3158"> </a>
<a name="ln3159">      yanklen = (int)STRLEN(y_array[i]);</a>
<a name="ln3160"> </a>
<a name="ln3161">      // calculate number of spaces required to fill right side of block</a>
<a name="ln3162">      spaces = y_width + 1;</a>
<a name="ln3163">      for (long j = 0; j &lt; yanklen; j++) {</a>
<a name="ln3164">        spaces -= lbr_chartabsize(NULL, &amp;y_array[i][j], 0);</a>
<a name="ln3165">      }</a>
<a name="ln3166">      if (spaces &lt; 0) {</a>
<a name="ln3167">        spaces = 0;</a>
<a name="ln3168">      }</a>
<a name="ln3169"> </a>
<a name="ln3170">      // insert the new text</a>
<a name="ln3171">      totlen = (size_t)(count * (yanklen + spaces)</a>
<a name="ln3172">                        + bd.startspaces + bd.endspaces);</a>
<a name="ln3173">      newp = (char_u *) xmalloc(totlen + oldlen + 1);</a>
<a name="ln3174">      // copy part up to cursor to new line</a>
<a name="ln3175">      ptr = newp;</a>
<a name="ln3176">      memmove(ptr, oldp, (size_t)bd.textcol);</a>
<a name="ln3177">      ptr += bd.textcol;</a>
<a name="ln3178">      // may insert some spaces before the new text</a>
<a name="ln3179">      memset(ptr, ' ', (size_t)bd.startspaces);</a>
<a name="ln3180">      ptr += bd.startspaces;</a>
<a name="ln3181">      // insert the new text</a>
<a name="ln3182">      for (long j = 0; j &lt; count; j++) {</a>
<a name="ln3183">        memmove(ptr, y_array[i], (size_t)yanklen);</a>
<a name="ln3184">        ptr += yanklen;</a>
<a name="ln3185"> </a>
<a name="ln3186">        // insert block's trailing spaces only if there's text behind</a>
<a name="ln3187">        if ((j &lt; count - 1 || !shortline) &amp;&amp; spaces) {</a>
<a name="ln3188">          memset(ptr, ' ', (size_t)spaces);</a>
<a name="ln3189">          ptr += spaces;</a>
<a name="ln3190">        }</a>
<a name="ln3191">      }</a>
<a name="ln3192">      // may insert some spaces after the new text</a>
<a name="ln3193">      memset(ptr, ' ', (size_t)bd.endspaces);</a>
<a name="ln3194">      ptr += bd.endspaces;</a>
<a name="ln3195">      // move the text after the cursor to the end of the line.</a>
<a name="ln3196">      int columns = (int)oldlen - bd.textcol - delcount + 1;</a>
<a name="ln3197">      assert(columns &gt;= 0);</a>
<a name="ln3198">      memmove(ptr, oldp + bd.textcol + delcount, (size_t)columns);</a>
<a name="ln3199">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3200">      extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum-1, bd.textcol,</a>
<a name="ln3201">                          delcount, (int)totlen + lines_appended, kExtmarkUndo);</a>
<a name="ln3202"> </a>
<a name="ln3203">      ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln3204">      if (i == 0)</a>
<a name="ln3205">        curwin-&gt;w_cursor.col += bd.startspaces;</a>
<a name="ln3206">    }</a>
<a name="ln3207"> </a>
<a name="ln3208">    changed_lines(lnum, 0, curbuf-&gt;b_op_start.lnum + (linenr_T)y_size</a>
<a name="ln3209">                  - (linenr_T)nr_lines , nr_lines, true);</a>
<a name="ln3210"> </a>
<a name="ln3211">    /* Set '[ mark. */</a>
<a name="ln3212">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3213">    curbuf-&gt;b_op_start.lnum = lnum;</a>
<a name="ln3214"> </a>
<a name="ln3215">    /* adjust '] mark */</a>
<a name="ln3216">    curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum - 1;</a>
<a name="ln3217">    curbuf-&gt;b_op_end.col = bd.textcol + (colnr_T)totlen - 1;</a>
<a name="ln3218">    curbuf-&gt;b_op_end.coladd = 0;</a>
<a name="ln3219">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3220">      colnr_T len;</a>
<a name="ln3221"> </a>
<a name="ln3222">      curwin-&gt;w_cursor = curbuf-&gt;b_op_end;</a>
<a name="ln3223">      curwin-&gt;w_cursor.col++;</a>
<a name="ln3224"> </a>
<a name="ln3225">      /* in Insert mode we might be after the NUL, correct for that */</a>
<a name="ln3226">      len = (colnr_T)STRLEN(get_cursor_line_ptr());</a>
<a name="ln3227">      if (curwin-&gt;w_cursor.col &gt; len)</a>
<a name="ln3228">        curwin-&gt;w_cursor.col = len;</a>
<a name="ln3229">    } else</a>
<a name="ln3230">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3231">  } else {</a>
<a name="ln3232">    // Character or Line mode</a>
<a name="ln3233">    if (y_type == kMTCharWise) {</a>
<a name="ln3234">      // if type is kMTCharWise, FORWARD is the same as BACKWARD on the next</a>
<a name="ln3235">      // char</a>
<a name="ln3236">      if (dir == FORWARD &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3237">        int bytelen = (*mb_ptr2len)(get_cursor_pos_ptr());</a>
<a name="ln3238"> </a>
<a name="ln3239">        // put it on the next of the multi-byte character.</a>
<a name="ln3240">        col += bytelen;</a>
<a name="ln3241">        if (yanklen) {</a>
<a name="ln3242">          curwin-&gt;w_cursor.col += bytelen;</a>
<a name="ln3243">          curbuf-&gt;b_op_end.col += bytelen;</a>
<a name="ln3244">        }</a>
<a name="ln3245">      }</a>
<a name="ln3246">      curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3247">    }</a>
<a name="ln3248">    /*</a>
<a name="ln3249">     * Line mode: BACKWARD is the same as FORWARD on the previous line</a>
<a name="ln3250">     */</a>
<a name="ln3251">    else if (dir == BACKWARD)</a>
<a name="ln3252">      --lnum;</a>
<a name="ln3253">    new_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3254"> </a>
<a name="ln3255">    // simple case: insert into one line at a time</a>
<a name="ln3256">    if (y_type == kMTCharWise &amp;&amp; y_size == 1) {</a>
<a name="ln3257">      linenr_T end_lnum = 0;  // init for gcc</a>
<a name="ln3258">      linenr_T start_lnum = lnum;</a>
<a name="ln3259"> </a>
<a name="ln3260">      if (VIsual_active) {</a>
<a name="ln3261">        end_lnum = curbuf-&gt;b_visual.vi_end.lnum;</a>
<a name="ln3262">        if (end_lnum &lt; curbuf-&gt;b_visual.vi_start.lnum) {</a>
<a name="ln3263">            end_lnum = curbuf-&gt;b_visual.vi_start.lnum;</a>
<a name="ln3264">        }</a>
<a name="ln3265">        if (end_lnum &gt; start_lnum) {</a>
<a name="ln3266">          // &quot;col&quot; is valid for the first line, in following lines</a>
<a name="ln3267">          // the virtual column needs to be used.  Matters for</a>
<a name="ln3268">          // multi-byte characters.</a>
<a name="ln3269">          pos_T pos = {</a>
<a name="ln3270">            .lnum = lnum,</a>
<a name="ln3271">            .col = col,</a>
<a name="ln3272">            .coladd = 0,</a>
<a name="ln3273">          };</a>
<a name="ln3274">          getvcol(curwin, &amp;pos, NULL, &amp;vcol, NULL);</a>
<a name="ln3275">        }</a>
<a name="ln3276">      }</a>
<a name="ln3277"> </a>
<a name="ln3278">      do {</a>
<a name="ln3279">        totlen = (size_t)(count * yanklen);</a>
<a name="ln3280">        if (totlen &gt; 0) {</a>
<a name="ln3281">          oldp = ml_get(lnum);</a>
<a name="ln3282">          if (lnum &gt; start_lnum) {</a>
<a name="ln3283">            pos_T pos = {</a>
<a name="ln3284">              .lnum = lnum,</a>
<a name="ln3285">            };</a>
<a name="ln3286">            if (getvpos(&amp;pos, vcol) == OK) {</a>
<a name="ln3287">              col = pos.col;</a>
<a name="ln3288">            } else {</a>
<a name="ln3289">              col = MAXCOL;</a>
<a name="ln3290">            }</a>
<a name="ln3291">          }</a>
<a name="ln3292">          if (VIsual_active &amp;&amp; col &gt; (int)STRLEN(oldp)) {</a>
<a name="ln3293">            lnum++;</a>
<a name="ln3294">            continue;</a>
<a name="ln3295">          }</a>
<a name="ln3296">          newp = (char_u *)xmalloc((size_t)(STRLEN(oldp) + totlen + 1));</a>
<a name="ln3297">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3298">          ptr = newp + col;</a>
<a name="ln3299">          for (i = 0; i &lt; (size_t)count; i++) {</a>
<a name="ln3300">            memmove(ptr, y_array[0], (size_t)yanklen);</a>
<a name="ln3301">            ptr += yanklen;</a>
<a name="ln3302">          }</a>
<a name="ln3303">          STRMOVE(ptr, oldp + col);</a>
<a name="ln3304">          ml_replace(lnum, newp, false);</a>
<a name="ln3305">          // Place cursor on last putted char.</a>
<a name="ln3306">          if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3307">            // make sure curwin-&gt;w_virtcol is updated</a>
<a name="ln3308">            changed_cline_bef_curs();</a>
<a name="ln3309">            curwin-&gt;w_cursor.col += (colnr_T)(totlen - 1);</a>
<a name="ln3310">          }</a>
<a name="ln3311">        }</a>
<a name="ln3312">        if (VIsual_active) {</a>
<a name="ln3313">          lnum++;</a>
<a name="ln3314">        }</a>
<a name="ln3315">      } while (VIsual_active &amp;&amp; lnum &lt;= end_lnum);</a>
<a name="ln3316"> </a>
<a name="ln3317">      if (VIsual_active) {  /* reset lnum to the last visual line */</a>
<a name="ln3318">        lnum--;</a>
<a name="ln3319">      }</a>
<a name="ln3320"> </a>
<a name="ln3321">      curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3322">      /* For &quot;CTRL-O p&quot; in Insert mode, put cursor after last char */</a>
<a name="ln3323">      if (totlen &amp;&amp; (restart_edit != 0 || (flags &amp; PUT_CURSEND)))</a>
<a name="ln3324">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln3325">      changed_bytes(lnum, col);</a>
<a name="ln3326">      extmark_splice_cols(curbuf, (int)lnum-1, col,</a>
<a name="ln3327">                          0, (int)totlen, kExtmarkUndo);</a>
<a name="ln3328">    } else {</a>
<a name="ln3329">      // Insert at least one line.  When y_type is kMTCharWise, break the first</a>
<a name="ln3330">      // line in two.</a>
<a name="ln3331">      for (cnt = 1; cnt &lt;= count; cnt++) {</a>
<a name="ln3332">        i = 0;</a>
<a name="ln3333">        if (y_type == kMTCharWise) {</a>
<a name="ln3334">          // Split the current line in two at the insert position.</a>
<a name="ln3335">          // First insert y_array[size - 1] in front of second line.</a>
<a name="ln3336">          // Then append y_array[0] to first line.</a>
<a name="ln3337">          lnum = new_cursor.lnum;</a>
<a name="ln3338">          ptr = ml_get(lnum) + col;</a>
<a name="ln3339">          totlen = STRLEN(y_array[y_size - 1]);</a>
<a name="ln3340">          newp = (char_u *) xmalloc((size_t)(STRLEN(ptr) + totlen + 1));</a>
<a name="ln3341">          STRCPY(newp, y_array[y_size - 1]);</a>
<a name="ln3342">          STRCAT(newp, ptr);</a>
<a name="ln3343">          // insert second line</a>
<a name="ln3344">          ml_append(lnum, newp, (colnr_T)0, false);</a>
<a name="ln3345">          xfree(newp);</a>
<a name="ln3346"> </a>
<a name="ln3347">          oldp = ml_get(lnum);</a>
<a name="ln3348">          newp = (char_u *)xmalloc((size_t)col + (size_t)yanklen + 1);</a>
<a name="ln3349">          // copy first part of line</a>
<a name="ln3350">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3351">          // append to first line</a>
<a name="ln3352">          memmove(newp + col, y_array[0], (size_t)yanklen + 1);</a>
<a name="ln3353">          ml_replace(lnum, newp, false);</a>
<a name="ln3354"> </a>
<a name="ln3355">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3356">          i = 1;</a>
<a name="ln3357">        }</a>
<a name="ln3358"> </a>
<a name="ln3359">        for (; i &lt; y_size; i++) {</a>
<a name="ln3360">          if ((y_type != kMTCharWise || i &lt; y_size - 1)</a>
<a name="ln3361">              &amp;&amp; ml_append(lnum, y_array[i], (colnr_T)0, false)</a>
<a name="ln3362">              == FAIL) {</a>
<a name="ln3363">            goto error;</a>
<a name="ln3364">          }</a>
<a name="ln3365">          lnum++;</a>
<a name="ln3366">          ++nr_lines;</a>
<a name="ln3367">          if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln3368">            old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3369">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3370">            ptr = ml_get(lnum);</a>
<a name="ln3371">            if (cnt == count &amp;&amp; i == y_size - 1)</a>
<a name="ln3372">              lendiff = (int)STRLEN(ptr);</a>
<a name="ln3373">            if (*ptr == '#' &amp;&amp; preprocs_left())</a>
<a name="ln3374">              indent = 0;                   /* Leave # lines at start */</a>
<a name="ln3375">            else if (*ptr == NUL)</a>
<a name="ln3376">              indent = 0;                   /* Ignore empty lines */</a>
<a name="ln3377">            else if (first_indent) {</a>
<a name="ln3378">              indent_diff = orig_indent - get_indent();</a>
<a name="ln3379">              indent = orig_indent;</a>
<a name="ln3380">              first_indent = FALSE;</a>
<a name="ln3381">            } else if ((indent = get_indent() + indent_diff) &lt; 0)</a>
<a name="ln3382">              indent = 0;</a>
<a name="ln3383">            (void)set_indent(indent, SIN_NOMARK);</a>
<a name="ln3384">            curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3385">            /* remember how many chars were removed */</a>
<a name="ln3386">            if (cnt == count &amp;&amp; i == y_size - 1)</a>
<a name="ln3387">              lendiff -= (int)STRLEN(ml_get(lnum));</a>
<a name="ln3388">          }</a>
<a name="ln3389">        }</a>
<a name="ln3390"> </a>
<a name="ln3391">        bcount_t totsize = 0;</a>
<a name="ln3392">        int lastsize = 0;</a>
<a name="ln3393">        if (y_type == kMTCharWise</a>
<a name="ln3394">            || (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT)) {</a>
<a name="ln3395">          for (i = 0; i &lt; y_size-1; i++) {</a>
<a name="ln3396">            totsize += (bcount_t)STRLEN(y_array[i]) + 1;</a>
<a name="ln3397">          }</a>
<a name="ln3398">          lastsize = (int)STRLEN(y_array[y_size-1]);</a>
<a name="ln3399">          totsize += lastsize;</a>
<a name="ln3400">        }</a>
<a name="ln3401">        if (y_type == kMTCharWise) {</a>
<a name="ln3402">          extmark_splice(curbuf, (int)new_cursor.lnum-1, col, 0, 0, 0,</a>
<a name="ln3403">                         (int)y_size-1, lastsize, totsize,</a>
<a name="ln3404">                         kExtmarkUndo);</a>
<a name="ln3405">        } else if (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3406">          extmark_splice(curbuf, (int)new_cursor.lnum-1, col, 0, 0, 0,</a>
<a name="ln3407">                         (int)y_size+1, 0, totsize+1, kExtmarkUndo);</a>
<a name="ln3408">        }</a>
<a name="ln3409">      }</a>
<a name="ln3410"> </a>
<a name="ln3411">error:</a>
<a name="ln3412">      // Adjust marks.</a>
<a name="ln3413">      if (y_type == kMTLineWise) {</a>
<a name="ln3414">        curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln3415">        if (dir == FORWARD)</a>
<a name="ln3416">          curbuf-&gt;b_op_start.lnum++;</a>
<a name="ln3417">      }</a>
<a name="ln3418">      // Skip mark_adjust when adding lines after the last one, there</a>
<a name="ln3419">      // can't be marks there.</a>
<a name="ln3420">      if (curbuf-&gt;b_op_start.lnum + (y_type == kMTCharWise) - 1 + nr_lines</a>
<a name="ln3421">          &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3422">        ExtmarkOp kind = (y_type == kMTLineWise &amp;&amp; !(flags &amp; PUT_LINE_SPLIT))</a>
<a name="ln3423">                         ? kExtmarkUndo : kExtmarkNOOP;</a>
<a name="ln3424">        mark_adjust(curbuf-&gt;b_op_start.lnum + (y_type == kMTCharWise),</a>
<a name="ln3425">                    (linenr_T)MAXLNUM, nr_lines, 0L, kind);</a>
<a name="ln3426">      }</a>
<a name="ln3427"> </a>
<a name="ln3428">      // note changed text for displaying and folding</a>
<a name="ln3429">      if (y_type == kMTCharWise) {</a>
<a name="ln3430">        changed_lines(curwin-&gt;w_cursor.lnum, col,</a>
<a name="ln3431">                      curwin-&gt;w_cursor.lnum + 1, nr_lines, true);</a>
<a name="ln3432">      } else {</a>
<a name="ln3433">        changed_lines(curbuf-&gt;b_op_start.lnum, 0,</a>
<a name="ln3434">                      curbuf-&gt;b_op_start.lnum, nr_lines, true);</a>
<a name="ln3435">      }</a>
<a name="ln3436"> </a>
<a name="ln3437">      /* put '] mark at last inserted character */</a>
<a name="ln3438">      curbuf-&gt;b_op_end.lnum = lnum;</a>
<a name="ln3439">      /* correct length for change in indent */</a>
<a name="ln3440">      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;</a>
<a name="ln3441">      if (col &gt; 1)</a>
<a name="ln3442">        curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3443">      else</a>
<a name="ln3444">        curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln3445"> </a>
<a name="ln3446">      if (flags &amp; PUT_CURSLINE) {</a>
<a name="ln3447">        /* &quot;:put&quot;: put cursor on last inserted line */</a>
<a name="ln3448">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3449">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3450">      } else if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3451">        // put cursor after inserted text</a>
<a name="ln3452">        if (y_type == kMTLineWise) {</a>
<a name="ln3453">          if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3454">            curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3455">          } else {</a>
<a name="ln3456">            curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln3457">          }</a>
<a name="ln3458">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3459">        } else {</a>
<a name="ln3460">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3461">          curwin-&gt;w_cursor.col = col;</a>
<a name="ln3462">        }</a>
<a name="ln3463">      } else if (y_type == kMTLineWise) {</a>
<a name="ln3464">        // put cursor on first non-blank in first inserted line</a>
<a name="ln3465">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3466">        if (dir == FORWARD)</a>
<a name="ln3467">          ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln3468">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3469">      } else            /* put cursor on first inserted character */</a>
<a name="ln3470">        curwin-&gt;w_cursor = new_cursor;</a>
<a name="ln3471">    }</a>
<a name="ln3472">  }</a>
<a name="ln3473"> </a>
<a name="ln3474">  msgmore(nr_lines);</a>
<a name="ln3475">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln3476"> </a>
<a name="ln3477">end:</a>
<a name="ln3478">  if (allocated)</a>
<a name="ln3479">    xfree(insert_string);</a>
<a name="ln3480">  if (regname == '=')</a>
<a name="ln3481">    xfree(y_array);</a>
<a name="ln3482"> </a>
<a name="ln3483">  VIsual_active = FALSE;</a>
<a name="ln3484"> </a>
<a name="ln3485">  /* If the cursor is past the end of the line put it at the end. */</a>
<a name="ln3486">  adjust_cursor_eol();</a>
<a name="ln3487">}  // NOLINT(readability/fn_size)</a>
<a name="ln3488"> </a>
<a name="ln3489">/*</a>
<a name="ln3490"> * When the cursor is on the NUL past the end of the line and it should not be</a>
<a name="ln3491"> * there move it left.</a>
<a name="ln3492"> */</a>
<a name="ln3493">void adjust_cursor_eol(void)</a>
<a name="ln3494">{</a>
<a name="ln3495">  if (curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3496">      &amp;&amp; gchar_cursor() == NUL</a>
<a name="ln3497">      &amp;&amp; (ve_flags &amp; VE_ONEMORE) == 0</a>
<a name="ln3498">      &amp;&amp; !(restart_edit || (State &amp; INSERT))) {</a>
<a name="ln3499">    /* Put the cursor on the last character in the line. */</a>
<a name="ln3500">    dec_cursor();</a>
<a name="ln3501"> </a>
<a name="ln3502">    if (ve_flags == VE_ALL) {</a>
<a name="ln3503">      colnr_T scol, ecol;</a>
<a name="ln3504"> </a>
<a name="ln3505">      /* Coladd is set to the width of the last character. */</a>
<a name="ln3506">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;scol, NULL, &amp;ecol);</a>
<a name="ln3507">      curwin-&gt;w_cursor.coladd = ecol - scol + 1;</a>
<a name="ln3508">    }</a>
<a name="ln3509">  }</a>
<a name="ln3510">}</a>
<a name="ln3511"> </a>
<a name="ln3512">/*</a>
<a name="ln3513"> * Return TRUE if lines starting with '#' should be left aligned.</a>
<a name="ln3514"> */</a>
<a name="ln3515">int preprocs_left(void)</a>
<a name="ln3516">{</a>
<a name="ln3517">  return ((curbuf-&gt;b_p_si &amp;&amp; !curbuf-&gt;b_p_cin)</a>
<a name="ln3518">          || (curbuf-&gt;b_p_cin &amp;&amp; in_cinkeys('#', ' ', true)</a>
<a name="ln3519">              &amp;&amp; curbuf-&gt;b_ind_hash_comment == 0));</a>
<a name="ln3520">}</a>
<a name="ln3521"> </a>
<a name="ln3522">/* Return the character name of the register with the given number */</a>
<a name="ln3523">int get_register_name(int num)</a>
<a name="ln3524">{</a>
<a name="ln3525">  if (num == -1)</a>
<a name="ln3526">    return '&quot;';</a>
<a name="ln3527">  else if (num &lt; 10)</a>
<a name="ln3528">    return num + '0';</a>
<a name="ln3529">  else if (num == DELETION_REGISTER)</a>
<a name="ln3530">    return '-';</a>
<a name="ln3531">  else if (num == STAR_REGISTER)</a>
<a name="ln3532">    return '*';</a>
<a name="ln3533">  else if (num == PLUS_REGISTER)</a>
<a name="ln3534">    return '+';</a>
<a name="ln3535">  else {</a>
<a name="ln3536">    return num + 'a' - 10;</a>
<a name="ln3537">  }</a>
<a name="ln3538">}</a>
<a name="ln3539"> </a>
<a name="ln3540">/*</a>
<a name="ln3541"> * &quot;:dis&quot; and &quot;:registers&quot;: Display the contents of the yank registers.</a>
<a name="ln3542"> */</a>
<a name="ln3543">void ex_display(exarg_T *eap)</a>
<a name="ln3544">{</a>
<a name="ln3545">  char_u *p;</a>
<a name="ln3546">  yankreg_T *yb;</a>
<a name="ln3547">  int name;</a>
<a name="ln3548">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3549">  int clen;</a>
<a name="ln3550"> </a>
<a name="ln3551">  if (arg != NULL &amp;&amp; *arg == NUL)</a>
<a name="ln3552">    arg = NULL;</a>
<a name="ln3553">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln3554"> </a>
<a name="ln3555">  /* Highlight title */</a>
<a name="ln3556">  MSG_PUTS_TITLE(_(&quot;\n--- Registers ---&quot;));</a>
<a name="ln3557">  for (int i = -1; i &lt; NUM_REGISTERS &amp;&amp; !got_int; i++) {</a>
<a name="ln3558">    name = get_register_name(i);</a>
<a name="ln3559"> </a>
<a name="ln3560">    if (arg != NULL &amp;&amp; vim_strchr(arg, name) == NULL) {</a>
<a name="ln3561">      continue;             /* did not ask for this register */</a>
<a name="ln3562">    }</a>
<a name="ln3563"> </a>
<a name="ln3564"> </a>
<a name="ln3565">    if (i == -1) {</a>
<a name="ln3566">      if (y_previous != NULL)</a>
<a name="ln3567">        yb = y_previous;</a>
<a name="ln3568">      else</a>
<a name="ln3569">        yb = &amp;(y_regs[0]);</a>
<a name="ln3570">    } else</a>
<a name="ln3571">      yb = &amp;(y_regs[i]);</a>
<a name="ln3572"> </a>
<a name="ln3573">    get_clipboard(name, &amp;yb, true);</a>
<a name="ln3574"> </a>
<a name="ln3575">    if (name == mb_tolower(redir_reg)</a>
<a name="ln3576">        || (redir_reg == '&quot;' &amp;&amp; yb == y_previous)) {</a>
<a name="ln3577">      continue;  // do not list register being written to, the</a>
<a name="ln3578">                 // pointer can be freed</a>
<a name="ln3579">    }</a>
<a name="ln3580"> </a>
<a name="ln3581">    if (yb-&gt;y_array != NULL) {</a>
<a name="ln3582">      msg_putchar('\n');</a>
<a name="ln3583">      msg_putchar('&quot;');</a>
<a name="ln3584">      msg_putchar(name);</a>
<a name="ln3585">      MSG_PUTS(&quot;   &quot;);</a>
<a name="ln3586"> </a>
<a name="ln3587">      int n = Columns - 6;</a>
<a name="ln3588">      for (size_t j = 0; j &lt; yb-&gt;y_size &amp;&amp; n &gt; 1; j++) {</a>
<a name="ln3589">        if (j) {</a>
<a name="ln3590">          MSG_PUTS_ATTR(&quot;^J&quot;, attr);</a>
<a name="ln3591">          n -= 2;</a>
<a name="ln3592">        }</a>
<a name="ln3593">        for (p = yb-&gt;y_array[j]; *p &amp;&amp; (n -= ptr2cells(p)) &gt;= 0; p++) {  // -V1019 NOLINT(whitespace/line_length)</a>
<a name="ln3594">          clen = (*mb_ptr2len)(p);</a>
<a name="ln3595">          msg_outtrans_len(p, clen);</a>
<a name="ln3596">          p += clen - 1;</a>
<a name="ln3597">        }</a>
<a name="ln3598">      }</a>
<a name="ln3599">      if (n &gt; 1 &amp;&amp; yb-&gt;y_type == kMTLineWise) {</a>
<a name="ln3600">        MSG_PUTS_ATTR(&quot;^J&quot;, attr);</a>
<a name="ln3601">      }</a>
<a name="ln3602">      ui_flush();  // show one line at a time</a>
<a name="ln3603">    }</a>
<a name="ln3604">    os_breakcheck();</a>
<a name="ln3605">  }</a>
<a name="ln3606"> </a>
<a name="ln3607">  /*</a>
<a name="ln3608">   * display last inserted text</a>
<a name="ln3609">   */</a>
<a name="ln3610">  if ((p = get_last_insert()) != NULL</a>
<a name="ln3611">      &amp;&amp; (arg == NULL || vim_strchr(arg, '.') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3612">    MSG_PUTS(&quot;\n\&quot;.   &quot;);</a>
<a name="ln3613">    dis_msg(p, TRUE);</a>
<a name="ln3614">  }</a>
<a name="ln3615"> </a>
<a name="ln3616">  /*</a>
<a name="ln3617">   * display last command line</a>
<a name="ln3618">   */</a>
<a name="ln3619">  if (last_cmdline != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, ':') != NULL)</a>
<a name="ln3620">      &amp;&amp; !got_int) {</a>
<a name="ln3621">    MSG_PUTS(&quot;\n\&quot;:   &quot;);</a>
<a name="ln3622">    dis_msg(last_cmdline, FALSE);</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  /*</a>
<a name="ln3626">   * display current file name</a>
<a name="ln3627">   */</a>
<a name="ln3628">  if (curbuf-&gt;b_fname != NULL</a>
<a name="ln3629">      &amp;&amp; (arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3630">    MSG_PUTS(&quot;\n\&quot;%   &quot;);</a>
<a name="ln3631">    dis_msg(curbuf-&gt;b_fname, FALSE);</a>
<a name="ln3632">  }</a>
<a name="ln3633"> </a>
<a name="ln3634">  /*</a>
<a name="ln3635">   * display alternate file name</a>
<a name="ln3636">   */</a>
<a name="ln3637">  if ((arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3638">    char_u      *fname;</a>
<a name="ln3639">    linenr_T dummy;</a>
<a name="ln3640"> </a>
<a name="ln3641">    if (buflist_name_nr(0, &amp;fname, &amp;dummy) != FAIL) {</a>
<a name="ln3642">      MSG_PUTS(&quot;\n\&quot;#   &quot;);</a>
<a name="ln3643">      dis_msg(fname, FALSE);</a>
<a name="ln3644">    }</a>
<a name="ln3645">  }</a>
<a name="ln3646"> </a>
<a name="ln3647">  /*</a>
<a name="ln3648">   * display last search pattern</a>
<a name="ln3649">   */</a>
<a name="ln3650">  if (last_search_pat() != NULL</a>
<a name="ln3651">      &amp;&amp; (arg == NULL || vim_strchr(arg, '/') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3652">    MSG_PUTS(&quot;\n\&quot;/   &quot;);</a>
<a name="ln3653">    dis_msg(last_search_pat(), FALSE);</a>
<a name="ln3654">  }</a>
<a name="ln3655"> </a>
<a name="ln3656">  /*</a>
<a name="ln3657">   * display last used expression</a>
<a name="ln3658">   */</a>
<a name="ln3659">  if (expr_line != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, '=') != NULL)</a>
<a name="ln3660">      &amp;&amp; !got_int) {</a>
<a name="ln3661">    MSG_PUTS(&quot;\n\&quot;=   &quot;);</a>
<a name="ln3662">    dis_msg(expr_line, FALSE);</a>
<a name="ln3663">  }</a>
<a name="ln3664">}</a>
<a name="ln3665"> </a>
<a name="ln3666">/*</a>
<a name="ln3667"> * display a string for do_dis()</a>
<a name="ln3668"> * truncate at end of screen line</a>
<a name="ln3669"> */</a>
<a name="ln3670">static void</a>
<a name="ln3671">dis_msg(</a>
<a name="ln3672">    char_u *p,</a>
<a name="ln3673">    int skip_esc                       /* if TRUE, ignore trailing ESC */</a>
<a name="ln3674">)</a>
<a name="ln3675">{</a>
<a name="ln3676">  int n;</a>
<a name="ln3677">  int l;</a>
<a name="ln3678"> </a>
<a name="ln3679">  n = Columns - 6;</a>
<a name="ln3680">  while (*p != NUL</a>
<a name="ln3681">         &amp;&amp; !(*p == ESC &amp;&amp; skip_esc &amp;&amp; *(p + 1) == NUL)</a>
<a name="ln3682">         &amp;&amp; (n -= ptr2cells(p)) &gt;= 0) {</a>
<a name="ln3683">    if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln3684">      msg_outtrans_len(p, l);</a>
<a name="ln3685">      p += l;</a>
<a name="ln3686">    } else</a>
<a name="ln3687">      msg_outtrans_len(p++, 1);</a>
<a name="ln3688">  }</a>
<a name="ln3689">  os_breakcheck();</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692">/// If \p &quot;process&quot; is true and the line begins with a comment leader (possibly</a>
<a name="ln3693">/// after some white space), return a pointer to the text after it.</a>
<a name="ln3694">/// Put a boolean value indicating whether the line ends with an unclosed</a>
<a name="ln3695">/// comment in &quot;is_comment&quot;.</a>
<a name="ln3696">///</a>
<a name="ln3697">/// @param line - line to be processed</a>
<a name="ln3698">/// @param process - if false, will only check whether the line ends</a>
<a name="ln3699">///         with an unclosed comment,</a>
<a name="ln3700">/// @param include_space - whether to skip space following the comment leader</a>
<a name="ln3701">/// @param[out] is_comment - whether the current line ends with an unclosed</a>
<a name="ln3702">///  comment.</a>
<a name="ln3703">char_u *skip_comment(</a>
<a name="ln3704">    char_u *line, bool process, bool include_space, bool *is_comment</a>
<a name="ln3705">)</a>
<a name="ln3706">{</a>
<a name="ln3707">  char_u *comment_flags = NULL;</a>
<a name="ln3708">  int lead_len;</a>
<a name="ln3709">  int leader_offset = get_last_leader_offset(line, &amp;comment_flags);</a>
<a name="ln3710"> </a>
<a name="ln3711">  *is_comment = false;</a>
<a name="ln3712">  if (leader_offset != -1) {</a>
<a name="ln3713">    /* Let's check whether the line ends with an unclosed comment.</a>
<a name="ln3714">     * If the last comment leader has COM_END in flags, there's no comment.</a>
<a name="ln3715">     */</a>
<a name="ln3716">    while (*comment_flags) {</a>
<a name="ln3717">      if (*comment_flags == COM_END</a>
<a name="ln3718">          || *comment_flags == ':') {</a>
<a name="ln3719">        break;</a>
<a name="ln3720">      }</a>
<a name="ln3721">      comment_flags++;</a>
<a name="ln3722">    }</a>
<a name="ln3723">    if (*comment_flags != COM_END) {</a>
<a name="ln3724">      *is_comment = true;</a>
<a name="ln3725">    }</a>
<a name="ln3726">  }</a>
<a name="ln3727"> </a>
<a name="ln3728">  if (process == false) {</a>
<a name="ln3729">    return line;</a>
<a name="ln3730">  }</a>
<a name="ln3731"> </a>
<a name="ln3732">  lead_len = get_leader_len(line, &amp;comment_flags, false, include_space);</a>
<a name="ln3733"> </a>
<a name="ln3734">  if (lead_len == 0)</a>
<a name="ln3735">    return line;</a>
<a name="ln3736"> </a>
<a name="ln3737">  /* Find:</a>
<a name="ln3738">   * - COM_END,</a>
<a name="ln3739">   * - colon,</a>
<a name="ln3740">   * whichever comes first.</a>
<a name="ln3741">   */</a>
<a name="ln3742">  while (*comment_flags) {</a>
<a name="ln3743">    if (*comment_flags == COM_END</a>
<a name="ln3744">        || *comment_flags == ':') {</a>
<a name="ln3745">      break;</a>
<a name="ln3746">    }</a>
<a name="ln3747">    ++comment_flags;</a>
<a name="ln3748">  }</a>
<a name="ln3749"> </a>
<a name="ln3750">  /* If we found a colon, it means that we are not processing a line</a>
<a name="ln3751">   * starting with a closing part of a three-part comment. That's good,</a>
<a name="ln3752">   * because we don't want to remove those as this would be annoying.</a>
<a name="ln3753">   */</a>
<a name="ln3754">  if (*comment_flags == ':' || *comment_flags == NUL) {</a>
<a name="ln3755">    line += lead_len;</a>
<a name="ln3756">  }</a>
<a name="ln3757"> </a>
<a name="ln3758">  return line;</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">// Join 'count' lines (minimal 2) at cursor position.</a>
<a name="ln3762">// When &quot;save_undo&quot; is TRUE save lines for undo first.</a>
<a name="ln3763">// Set &quot;use_formatoptions&quot; to FALSE when e.g. processing backspace and comment</a>
<a name="ln3764">// leaders should not be removed.</a>
<a name="ln3765">// When setmark is true, sets the '[ and '] mark, else, the caller is expected</a>
<a name="ln3766">// to set those marks.</a>
<a name="ln3767">//</a>
<a name="ln3768">// return FAIL for failure, OK otherwise</a>
<a name="ln3769">int do_join(size_t count,</a>
<a name="ln3770">            int insert_space,</a>
<a name="ln3771">            int save_undo,</a>
<a name="ln3772">            int use_formatoptions,</a>
<a name="ln3773">            bool setmark)</a>
<a name="ln3774">{</a>
<a name="ln3775">  char_u      *curr = NULL;</a>
<a name="ln3776">  char_u      *curr_start = NULL;</a>
<a name="ln3777">  char_u      *cend;</a>
<a name="ln3778">  char_u      *newp;</a>
<a name="ln3779">  char_u      *spaces;          /* number of spaces inserted before a line */</a>
<a name="ln3780">  int endcurr1 = NUL;</a>
<a name="ln3781">  int endcurr2 = NUL;</a>
<a name="ln3782">  int currsize = 0;             /* size of the current line */</a>
<a name="ln3783">  int sumsize = 0;              /* size of the long new line */</a>
<a name="ln3784">  linenr_T t;</a>
<a name="ln3785">  colnr_T col = 0;</a>
<a name="ln3786">  int ret = OK;</a>
<a name="ln3787">  int         *comments = NULL;</a>
<a name="ln3788">  int remove_comments = (use_formatoptions == TRUE)</a>
<a name="ln3789">                        &amp;&amp; has_format_option(FO_REMOVE_COMS);</a>
<a name="ln3790">  bool prev_was_comment = false;</a>
<a name="ln3791">  assert(count &gt;= 1);</a>
<a name="ln3792"> </a>
<a name="ln3793">  if (save_undo &amp;&amp; u_save(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln3794">                          curwin-&gt;w_cursor.lnum + (linenr_T)count) == FAIL) {</a>
<a name="ln3795">    return FAIL;</a>
<a name="ln3796">  }</a>
<a name="ln3797">  // Allocate an array to store the number of spaces inserted before each</a>
<a name="ln3798">  // line.  We will use it to pre-compute the length of the new line and the</a>
<a name="ln3799">  // proper placement of each original line in the new one.</a>
<a name="ln3800">  spaces = xcalloc(count, 1);</a>
<a name="ln3801">  if (remove_comments) {</a>
<a name="ln3802">    comments = xcalloc(count, sizeof(*comments));</a>
<a name="ln3803">  }</a>
<a name="ln3804"> </a>
<a name="ln3805">  // Don't move anything, just compute the final line length</a>
<a name="ln3806">  // and setup the array of space strings lengths</a>
<a name="ln3807">  for (t = 0; t &lt; (linenr_T)count; t++) {</a>
<a name="ln3808">    curr = curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t));</a>
<a name="ln3809">    if (t == 0 &amp;&amp; setmark) {</a>
<a name="ln3810">      // Set the '[ mark.</a>
<a name="ln3811">      curwin-&gt;w_buffer-&gt;b_op_start.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3812">      curwin-&gt;w_buffer-&gt;b_op_start.col = (colnr_T)STRLEN(curr);</a>
<a name="ln3813">    }</a>
<a name="ln3814">    if (remove_comments) {</a>
<a name="ln3815">      // We don't want to remove the comment leader if the</a>
<a name="ln3816">      // previous line is not a comment.</a>
<a name="ln3817">      if (t &gt; 0 &amp;&amp; prev_was_comment) {</a>
<a name="ln3818">        char_u *new_curr = skip_comment(curr, true, insert_space,</a>
<a name="ln3819">                                        &amp;prev_was_comment);</a>
<a name="ln3820">        comments[t] = (int)(new_curr - curr);</a>
<a name="ln3821">        curr = new_curr;</a>
<a name="ln3822">      } else {</a>
<a name="ln3823">        curr = skip_comment(curr, false, insert_space, &amp;prev_was_comment);</a>
<a name="ln3824">      }</a>
<a name="ln3825">    }</a>
<a name="ln3826"> </a>
<a name="ln3827">    if (insert_space &amp;&amp; t &gt; 0) {</a>
<a name="ln3828">      curr = skipwhite(curr);</a>
<a name="ln3829">      if (*curr != NUL</a>
<a name="ln3830">          &amp;&amp; *curr != ')'</a>
<a name="ln3831">          &amp;&amp; sumsize != 0</a>
<a name="ln3832">          &amp;&amp; endcurr1 != TAB</a>
<a name="ln3833">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN)</a>
<a name="ln3834">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; endcurr1 &lt; 0x100))</a>
<a name="ln3835">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN2)</a>
<a name="ln3836">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; !utf_eat_space(endcurr1))</a>
<a name="ln3837">              || (endcurr1 &lt; 0x100 &amp;&amp; !utf_eat_space(utf_ptr2char(curr))))</a>
<a name="ln3838">          ) {</a>
<a name="ln3839">        /* don't add a space if the line is ending in a space */</a>
<a name="ln3840">        if (endcurr1 == ' ')</a>
<a name="ln3841">          endcurr1 = endcurr2;</a>
<a name="ln3842">        else</a>
<a name="ln3843">          ++spaces[t];</a>
<a name="ln3844">        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.</a>
<a name="ln3845">        if (p_js &amp;&amp; (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {</a>
<a name="ln3846">          ++spaces[t];</a>
<a name="ln3847">        }</a>
<a name="ln3848">      }</a>
<a name="ln3849">    }</a>
<a name="ln3850"> </a>
<a name="ln3851">    if (t &gt; 0 &amp;&amp; curbuf_splice_pending == 0) {</a>
<a name="ln3852">      colnr_T removed = (int)(curr- curr_start);</a>
<a name="ln3853">      extmark_splice(curbuf, (int)curwin-&gt;w_cursor.lnum-1, sumsize,</a>
<a name="ln3854">                     1, removed, removed + 1,</a>
<a name="ln3855">                     0, spaces[t], spaces[t],</a>
<a name="ln3856">                     kExtmarkUndo);</a>
<a name="ln3857">    }</a>
<a name="ln3858">    currsize = (int)STRLEN(curr);</a>
<a name="ln3859">    sumsize += currsize + spaces[t];</a>
<a name="ln3860">    endcurr1 = endcurr2 = NUL;</a>
<a name="ln3861">    if (insert_space &amp;&amp; currsize &gt; 0) {</a>
<a name="ln3862">      cend = curr + currsize;</a>
<a name="ln3863">      MB_PTR_BACK(curr, cend);</a>
<a name="ln3864">      endcurr1 = utf_ptr2char(cend);</a>
<a name="ln3865">      if (cend &gt; curr) {</a>
<a name="ln3866">        MB_PTR_BACK(curr, cend);</a>
<a name="ln3867">        endcurr2 = utf_ptr2char(cend);</a>
<a name="ln3868">      }</a>
<a name="ln3869">    }</a>
<a name="ln3870">    line_breakcheck();</a>
<a name="ln3871">    if (got_int) {</a>
<a name="ln3872">      ret = FAIL;</a>
<a name="ln3873">      goto theend;</a>
<a name="ln3874">    }</a>
<a name="ln3875">  }</a>
<a name="ln3876"> </a>
<a name="ln3877">  // store the column position before last line</a>
<a name="ln3878">  col = sumsize - currsize - spaces[count - 1];</a>
<a name="ln3879"> </a>
<a name="ln3880">  // allocate the space for the new line</a>
<a name="ln3881">  newp = (char_u *)xmalloc((size_t)sumsize + 1);</a>
<a name="ln3882">  cend = newp + sumsize;</a>
<a name="ln3883">  *cend = 0;</a>
<a name="ln3884"> </a>
<a name="ln3885">  /*</a>
<a name="ln3886">   * Move affected lines to the new long one.</a>
<a name="ln3887">   *</a>
<a name="ln3888">   * Move marks from each deleted line to the joined line, adjusting the</a>
<a name="ln3889">   * column.  This is not Vi compatible, but Vi deletes the marks, thus that</a>
<a name="ln3890">   * should not really be a problem.</a>
<a name="ln3891">   */</a>
<a name="ln3892"> </a>
<a name="ln3893">  curbuf_splice_pending++;</a>
<a name="ln3894"> </a>
<a name="ln3895">  for (t = (linenr_T)count - 1;; t--) {</a>
<a name="ln3896">    cend -= currsize;</a>
<a name="ln3897">    memmove(cend, curr, (size_t)currsize);</a>
<a name="ln3898">    if (spaces[t] &gt; 0) {</a>
<a name="ln3899">      cend -= spaces[t];</a>
<a name="ln3900">      memset(cend, ' ', (size_t)(spaces[t]));</a>
<a name="ln3901">    }</a>
<a name="ln3902"> </a>
<a name="ln3903">    // If deleting more spaces than adding, the cursor moves no more than</a>
<a name="ln3904">    // what is added if it is inside these spaces.</a>
<a name="ln3905">    const int spaces_removed = (int)((curr - curr_start) - spaces[t]);</a>
<a name="ln3906">    linenr_T lnum = curwin-&gt;w_cursor.lnum + t;</a>
<a name="ln3907">    colnr_T mincol = (colnr_T)0;</a>
<a name="ln3908">    long lnum_amount = (linenr_T)-t;</a>
<a name="ln3909">    long col_amount = (long)(cend - newp - spaces_removed);</a>
<a name="ln3910"> </a>
<a name="ln3911">    mark_col_adjust(lnum, mincol, lnum_amount, col_amount, spaces_removed);</a>
<a name="ln3912"> </a>
<a name="ln3913">    if (t == 0) {</a>
<a name="ln3914">      break;</a>
<a name="ln3915">    }</a>
<a name="ln3916"> </a>
<a name="ln3917">    curr = curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t - 1));</a>
<a name="ln3918">    if (remove_comments)</a>
<a name="ln3919">      curr += comments[t - 1];</a>
<a name="ln3920">    if (insert_space &amp;&amp; t &gt; 1)</a>
<a name="ln3921">      curr = skipwhite(curr);</a>
<a name="ln3922">    currsize = (int)STRLEN(curr);</a>
<a name="ln3923">  }</a>
<a name="ln3924"> </a>
<a name="ln3925">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3926"> </a>
<a name="ln3927">  if (setmark) {</a>
<a name="ln3928">    // Set the '] mark.</a>
<a name="ln3929">    curwin-&gt;w_buffer-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3930">    curwin-&gt;w_buffer-&gt;b_op_end.col = sumsize;</a>
<a name="ln3931">  }</a>
<a name="ln3932"> </a>
<a name="ln3933">  /* Only report the change in the first line here, del_lines() will report</a>
<a name="ln3934">   * the deleted line. */</a>
<a name="ln3935">  changed_lines(curwin-&gt;w_cursor.lnum, currsize,</a>
<a name="ln3936">                curwin-&gt;w_cursor.lnum + 1, 0L, true);</a>
<a name="ln3937"> </a>
<a name="ln3938">  /*</a>
<a name="ln3939">   * Delete following lines. To do this we move the cursor there</a>
<a name="ln3940">   * briefly, and then move it back. After del_lines() the cursor may</a>
<a name="ln3941">   * have moved up (last line deleted), so the current lnum is kept in t.</a>
<a name="ln3942">   */</a>
<a name="ln3943">  t = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3944">  curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3945">  del_lines((long)count - 1, false);</a>
<a name="ln3946">  curwin-&gt;w_cursor.lnum = t;</a>
<a name="ln3947">  curbuf_splice_pending--;</a>
<a name="ln3948"> </a>
<a name="ln3949">  /*</a>
<a name="ln3950">   * Set the cursor column:</a>
<a name="ln3951">   * Vi compatible: use the column of the first join</a>
<a name="ln3952">   * vim:	      use the column of the last join</a>
<a name="ln3953">   */</a>
<a name="ln3954">  curwin-&gt;w_cursor.col =</a>
<a name="ln3955">    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);</a>
<a name="ln3956">  check_cursor_col();</a>
<a name="ln3957"> </a>
<a name="ln3958">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3959">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln3960"> </a>
<a name="ln3961">theend:</a>
<a name="ln3962">  xfree(spaces);</a>
<a name="ln3963">  if (remove_comments)</a>
<a name="ln3964">    xfree(comments);</a>
<a name="ln3965">  return ret;</a>
<a name="ln3966">}</a>
<a name="ln3967"> </a>
<a name="ln3968">/*</a>
<a name="ln3969"> * Return TRUE if the two comment leaders given are the same.  &quot;lnum&quot; is</a>
<a name="ln3970"> * the first line.  White-space is ignored.  Note that the whole of</a>
<a name="ln3971"> * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb</a>
<a name="ln3972"> */</a>
<a name="ln3973">static int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)</a>
<a name="ln3974">{</a>
<a name="ln3975">  int idx1 = 0, idx2 = 0;</a>
<a name="ln3976">  char_u  *p;</a>
<a name="ln3977">  char_u  *line1;</a>
<a name="ln3978">  char_u  *line2;</a>
<a name="ln3979"> </a>
<a name="ln3980">  if (leader1_len == 0)</a>
<a name="ln3981">    return leader2_len == 0;</a>
<a name="ln3982"> </a>
<a name="ln3983">  /*</a>
<a name="ln3984">   * If first leader has 'f' flag, the lines can be joined only if the</a>
<a name="ln3985">   * second line does not have a leader.</a>
<a name="ln3986">   * If first leader has 'e' flag, the lines can never be joined.</a>
<a name="ln3987">   * If fist leader has 's' flag, the lines can only be joined if there is</a>
<a name="ln3988">   * some text after it and the second line has the 'm' flag.</a>
<a name="ln3989">   */</a>
<a name="ln3990">  if (leader1_flags != NULL) {</a>
<a name="ln3991">    for (p = leader1_flags; *p &amp;&amp; *p != ':'; ++p) {</a>
<a name="ln3992">      if (*p == COM_FIRST)</a>
<a name="ln3993">        return leader2_len == 0;</a>
<a name="ln3994">      if (*p == COM_END)</a>
<a name="ln3995">        return FALSE;</a>
<a name="ln3996">      if (*p == COM_START) {</a>
<a name="ln3997">        if (*(ml_get(lnum) + leader1_len) == NUL)</a>
<a name="ln3998">          return FALSE;</a>
<a name="ln3999">        if (leader2_flags == NULL || leader2_len == 0)</a>
<a name="ln4000">          return FALSE;</a>
<a name="ln4001">        for (p = leader2_flags; *p &amp;&amp; *p != ':'; ++p)</a>
<a name="ln4002">          if (*p == COM_MIDDLE)</a>
<a name="ln4003">            return TRUE;</a>
<a name="ln4004">        return FALSE;</a>
<a name="ln4005">      }</a>
<a name="ln4006">    }</a>
<a name="ln4007">  }</a>
<a name="ln4008"> </a>
<a name="ln4009">  /*</a>
<a name="ln4010">   * Get current line and next line, compare the leaders.</a>
<a name="ln4011">   * The first line has to be saved, only one line can be locked at a time.</a>
<a name="ln4012">   */</a>
<a name="ln4013">  line1 = vim_strsave(ml_get(lnum));</a>
<a name="ln4014">  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)</a>
<a name="ln4015">    ;</a>
<a name="ln4016">  line2 = ml_get(lnum + 1);</a>
<a name="ln4017">  for (idx2 = 0; idx2 &lt; leader2_len; ++idx2) {</a>
<a name="ln4018">    if (!ascii_iswhite(line2[idx2])) {</a>
<a name="ln4019">      if (line1[idx1++] != line2[idx2])</a>
<a name="ln4020">        break;</a>
<a name="ln4021">    } else</a>
<a name="ln4022">      while (ascii_iswhite(line1[idx1]))</a>
<a name="ln4023">        ++idx1;</a>
<a name="ln4024">  }</a>
<a name="ln4025">  xfree(line1);</a>
<a name="ln4026"> </a>
<a name="ln4027">  return idx2 == leader2_len &amp;&amp; idx1 == leader1_len;</a>
<a name="ln4028">}</a>
<a name="ln4029"> </a>
<a name="ln4030">/*</a>
<a name="ln4031"> * Implementation of the format operator 'gq'.</a>
<a name="ln4032"> */</a>
<a name="ln4033">void</a>
<a name="ln4034">op_format(</a>
<a name="ln4035">    oparg_T *oap,</a>
<a name="ln4036">    int keep_cursor                        /* keep cursor on same text char */</a>
<a name="ln4037">)</a>
<a name="ln4038">{</a>
<a name="ln4039">  long old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4040"> </a>
<a name="ln4041">  /* Place the cursor where the &quot;gq&quot; or &quot;gw&quot; command was given, so that &quot;u&quot;</a>
<a name="ln4042">   * can put it back there. */</a>
<a name="ln4043">  curwin-&gt;w_cursor = oap-&gt;cursor_start;</a>
<a name="ln4044"> </a>
<a name="ln4045">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4046">          (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL)</a>
<a name="ln4047">    return;</a>
<a name="ln4048">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln4049"> </a>
<a name="ln4050">  if (oap-&gt;is_VIsual)</a>
<a name="ln4051">    /* When there is no change: need to remove the Visual selection */</a>
<a name="ln4052">    redraw_curbuf_later(INVERTED);</a>
<a name="ln4053"> </a>
<a name="ln4054">  /* Set '[ mark at the start of the formatted area */</a>
<a name="ln4055">  curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln4056"> </a>
<a name="ln4057">  /* For &quot;gw&quot; remember the cursor position and put it back below (adjusted</a>
<a name="ln4058">   * for joined and split lines). */</a>
<a name="ln4059">  if (keep_cursor)</a>
<a name="ln4060">    saved_cursor = oap-&gt;cursor_start;</a>
<a name="ln4061"> </a>
<a name="ln4062">  format_lines(oap-&gt;line_count, keep_cursor);</a>
<a name="ln4063"> </a>
<a name="ln4064">  /*</a>
<a name="ln4065">   * Leave the cursor at the first non-blank of the last formatted line.</a>
<a name="ln4066">   * If the cursor was moved one line back (e.g. with &quot;Q}&quot;) go to the next</a>
<a name="ln4067">   * line, so &quot;.&quot; will do the next lines.</a>
<a name="ln4068">   */</a>
<a name="ln4069">  if (oap-&gt;end_adjusted &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4070">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln4071">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4072">  old_line_count = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4073">  msgmore(old_line_count);</a>
<a name="ln4074"> </a>
<a name="ln4075">  /* put '] mark on the end of the formatted area */</a>
<a name="ln4076">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln4077"> </a>
<a name="ln4078">  if (keep_cursor) {</a>
<a name="ln4079">    curwin-&gt;w_cursor = saved_cursor;</a>
<a name="ln4080">    saved_cursor.lnum = 0;</a>
<a name="ln4081">  }</a>
<a name="ln4082"> </a>
<a name="ln4083">  if (oap-&gt;is_VIsual) {</a>
<a name="ln4084">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4085">      if (wp-&gt;w_old_cursor_lnum != 0) {</a>
<a name="ln4086">        /* When lines have been inserted or deleted, adjust the end of</a>
<a name="ln4087">         * the Visual area to be redrawn. */</a>
<a name="ln4088">        if (wp-&gt;w_old_cursor_lnum &gt; wp-&gt;w_old_visual_lnum) {</a>
<a name="ln4089">          wp-&gt;w_old_cursor_lnum += old_line_count;</a>
<a name="ln4090">        } else {</a>
<a name="ln4091">          wp-&gt;w_old_visual_lnum += old_line_count;</a>
<a name="ln4092">        }</a>
<a name="ln4093">      }</a>
<a name="ln4094">    }</a>
<a name="ln4095">  }</a>
<a name="ln4096">}</a>
<a name="ln4097"> </a>
<a name="ln4098">/*</a>
<a name="ln4099"> * Implementation of the format operator 'gq' for when using 'formatexpr'.</a>
<a name="ln4100"> */</a>
<a name="ln4101">void op_formatexpr(oparg_T *oap)</a>
<a name="ln4102">{</a>
<a name="ln4103">  if (oap-&gt;is_VIsual)</a>
<a name="ln4104">    /* When there is no change: need to remove the Visual selection */</a>
<a name="ln4105">    redraw_curbuf_later(INVERTED);</a>
<a name="ln4106"> </a>
<a name="ln4107">  if (fex_format(oap-&gt;start.lnum, oap-&gt;line_count, NUL) != 0)</a>
<a name="ln4108">    /* As documented: when 'formatexpr' returns non-zero fall back to</a>
<a name="ln4109">     * internal formatting. */</a>
<a name="ln4110">    op_format(oap, FALSE);</a>
<a name="ln4111">}</a>
<a name="ln4112"> </a>
<a name="ln4113">int</a>
<a name="ln4114">fex_format(</a>
<a name="ln4115">    linenr_T lnum,</a>
<a name="ln4116">    long count,</a>
<a name="ln4117">    int c                  /* character to be inserted */</a>
<a name="ln4118">)</a>
<a name="ln4119">{</a>
<a name="ln4120">  int use_sandbox = was_set_insecurely((char_u *)&quot;formatexpr&quot;,</a>
<a name="ln4121">      OPT_LOCAL);</a>
<a name="ln4122">  int r;</a>
<a name="ln4123">  char_u *fex;</a>
<a name="ln4124"> </a>
<a name="ln4125">  /*</a>
<a name="ln4126">   * Set v:lnum to the first line number and v:count to the number of lines.</a>
<a name="ln4127">   * Set v:char to the character to be inserted (can be NUL).</a>
<a name="ln4128">   */</a>
<a name="ln4129">  set_vim_var_nr(VV_LNUM, (varnumber_T)lnum);</a>
<a name="ln4130">  set_vim_var_nr(VV_COUNT, (varnumber_T)count);</a>
<a name="ln4131">  set_vim_var_char(c);</a>
<a name="ln4132"> </a>
<a name="ln4133">  // Make a copy, the option could be changed while calling it.</a>
<a name="ln4134">  fex = vim_strsave(curbuf-&gt;b_p_fex);</a>
<a name="ln4135">  // Evaluate the function.</a>
<a name="ln4136">  if (use_sandbox) {</a>
<a name="ln4137">    sandbox++;</a>
<a name="ln4138">  }</a>
<a name="ln4139">  r = (int)eval_to_number(fex);</a>
<a name="ln4140">  if (use_sandbox) {</a>
<a name="ln4141">    sandbox--;</a>
<a name="ln4142">  }</a>
<a name="ln4143"> </a>
<a name="ln4144">  set_vim_var_string(VV_CHAR, NULL, -1);</a>
<a name="ln4145">  xfree(fex);</a>
<a name="ln4146"> </a>
<a name="ln4147">  return r;</a>
<a name="ln4148">}</a>
<a name="ln4149"> </a>
<a name="ln4150">/*</a>
<a name="ln4151"> * Format &quot;line_count&quot; lines, starting at the cursor position.</a>
<a name="ln4152"> * When &quot;line_count&quot; is negative, format until the end of the paragraph.</a>
<a name="ln4153"> * Lines after the cursor line are saved for undo, caller must have saved the</a>
<a name="ln4154"> * first line.</a>
<a name="ln4155"> */</a>
<a name="ln4156">void</a>
<a name="ln4157">format_lines(</a>
<a name="ln4158">    linenr_T line_count,</a>
<a name="ln4159">    int avoid_fex                          /* don't use 'formatexpr' */</a>
<a name="ln4160">)</a>
<a name="ln4161">{</a>
<a name="ln4162">  bool is_not_par;                  // current line not part of parag.</a>
<a name="ln4163">  bool next_is_not_par;             // next line not part of paragraph</a>
<a name="ln4164">  bool is_end_par;                  // at end of paragraph</a>
<a name="ln4165">  bool prev_is_end_par = false;     // prev. line not part of parag.</a>
<a name="ln4166">  bool next_is_start_par = false;</a>
<a name="ln4167">  int leader_len = 0;               // leader len of current line</a>
<a name="ln4168">  int next_leader_len;              // leader len of next line</a>
<a name="ln4169">  char_u *leader_flags = NULL;      // flags for leader of current line</a>
<a name="ln4170">  char_u *next_leader_flags;        // flags for leader of next line</a>
<a name="ln4171">  bool advance = true;</a>
<a name="ln4172">  int second_indent = -1;           // indent for second line (comment aware)</a>
<a name="ln4173">  bool first_par_line = true;</a>
<a name="ln4174">  int smd_save;</a>
<a name="ln4175">  long count;</a>
<a name="ln4176">  bool need_set_indent = true;      // set indent of next paragraph</a>
<a name="ln4177">  bool force_format = false;</a>
<a name="ln4178">  const int old_State = State;</a>
<a name="ln4179"> </a>
<a name="ln4180">  // length of a line to force formatting: 3 * 'tw'</a>
<a name="ln4181">  const int max_len = comp_textwidth(true) * 3;</a>
<a name="ln4182"> </a>
<a name="ln4183">  // check for 'q', '2' and '1' in 'formatoptions'</a>
<a name="ln4184">  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments</a>
<a name="ln4185">  int do_comments_list = 0;  // format comments with 'n' or '2'</a>
<a name="ln4186">  const bool do_second_indent = has_format_option(FO_Q_SECOND);</a>
<a name="ln4187">  const bool do_number_indent = has_format_option(FO_Q_NUMBER);</a>
<a name="ln4188">  const bool do_trail_white = has_format_option(FO_WHITE_PAR);</a>
<a name="ln4189"> </a>
<a name="ln4190">  // Get info about the previous and current line.</a>
<a name="ln4191">  if (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln4192">    is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln4193">                               &amp;leader_len, &amp;leader_flags, do_comments);</a>
<a name="ln4194">  } else {</a>
<a name="ln4195">    is_not_par = true;</a>
<a name="ln4196">  }</a>
<a name="ln4197">  next_is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum</a>
<a name="ln4198">      , &amp;next_leader_len, &amp;next_leader_flags, do_comments</a>
<a name="ln4199">      );</a>
<a name="ln4200">  is_end_par = (is_not_par || next_is_not_par);</a>
<a name="ln4201">  if (!is_end_par &amp;&amp; do_trail_white)</a>
<a name="ln4202">    is_end_par = !ends_in_white(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln4203"> </a>
<a name="ln4204">  curwin-&gt;w_cursor.lnum--;</a>
<a name="ln4205">  for (count = line_count; count != 0 &amp;&amp; !got_int; --count) {</a>
<a name="ln4206">    /*</a>
<a name="ln4207">     * Advance to next paragraph.</a>
<a name="ln4208">     */</a>
<a name="ln4209">    if (advance) {</a>
<a name="ln4210">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4211">      prev_is_end_par = is_end_par;</a>
<a name="ln4212">      is_not_par = next_is_not_par;</a>
<a name="ln4213">      leader_len = next_leader_len;</a>
<a name="ln4214">      leader_flags = next_leader_flags;</a>
<a name="ln4215">    }</a>
<a name="ln4216"> </a>
<a name="ln4217">    /*</a>
<a name="ln4218">     * The last line to be formatted.</a>
<a name="ln4219">     */</a>
<a name="ln4220">    if (count == 1 || curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4221">      next_is_not_par = true;</a>
<a name="ln4222">      next_leader_len = 0;</a>
<a name="ln4223">      next_leader_flags = NULL;</a>
<a name="ln4224">    } else {</a>
<a name="ln4225">      next_is_not_par = fmt_check_par(curwin-&gt;w_cursor.lnum + 1</a>
<a name="ln4226">          , &amp;next_leader_len, &amp;next_leader_flags, do_comments</a>
<a name="ln4227">          );</a>
<a name="ln4228">      if (do_number_indent)</a>
<a name="ln4229">        next_is_start_par =</a>
<a name="ln4230">          (get_number_indent(curwin-&gt;w_cursor.lnum + 1) &gt; 0);</a>
<a name="ln4231">    }</a>
<a name="ln4232">    advance = true;</a>
<a name="ln4233">    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);</a>
<a name="ln4234">    if (!is_end_par &amp;&amp; do_trail_white)</a>
<a name="ln4235">      is_end_par = !ends_in_white(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4236"> </a>
<a name="ln4237">    /*</a>
<a name="ln4238">     * Skip lines that are not in a paragraph.</a>
<a name="ln4239">     */</a>
<a name="ln4240">    if (is_not_par) {</a>
<a name="ln4241">      if (line_count &lt; 0)</a>
<a name="ln4242">        break;</a>
<a name="ln4243">    } else {</a>
<a name="ln4244">      /*</a>
<a name="ln4245">       * For the first line of a paragraph, check indent of second line.</a>
<a name="ln4246">       * Don't do this for comments and empty lines.</a>
<a name="ln4247">       */</a>
<a name="ln4248">      if (first_par_line</a>
<a name="ln4249">          &amp;&amp; (do_second_indent || do_number_indent)</a>
<a name="ln4250">          &amp;&amp; prev_is_end_par</a>
<a name="ln4251">          &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4252">        if (do_second_indent &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum + 1)) {</a>
<a name="ln4253">          if (leader_len == 0 &amp;&amp; next_leader_len == 0) {</a>
<a name="ln4254">            /* no comment found */</a>
<a name="ln4255">            second_indent =</a>
<a name="ln4256">              get_indent_lnum(curwin-&gt;w_cursor.lnum + 1);</a>
<a name="ln4257">          } else {</a>
<a name="ln4258">            second_indent = next_leader_len;</a>
<a name="ln4259">            do_comments_list = 1;</a>
<a name="ln4260">          }</a>
<a name="ln4261">        } else if (do_number_indent) {</a>
<a name="ln4262">          if (leader_len == 0 &amp;&amp; next_leader_len == 0) {</a>
<a name="ln4263">            /* no comment found */</a>
<a name="ln4264">            second_indent =</a>
<a name="ln4265">              get_number_indent(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4266">          } else {</a>
<a name="ln4267">            /* get_number_indent() is now &quot;comment aware&quot;... */</a>
<a name="ln4268">            second_indent =</a>
<a name="ln4269">              get_number_indent(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4270">            do_comments_list = 1;</a>
<a name="ln4271">          }</a>
<a name="ln4272">        }</a>
<a name="ln4273">      }</a>
<a name="ln4274"> </a>
<a name="ln4275">      /*</a>
<a name="ln4276">       * When the comment leader changes, it's the end of the paragraph.</a>
<a name="ln4277">       */</a>
<a name="ln4278">      if (curwin-&gt;w_cursor.lnum &gt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln4279">          || !same_leader(curwin-&gt;w_cursor.lnum,</a>
<a name="ln4280">              leader_len, leader_flags,</a>
<a name="ln4281">              next_leader_len, next_leader_flags)</a>
<a name="ln4282">          )</a>
<a name="ln4283">        is_end_par = true;</a>
<a name="ln4284"> </a>
<a name="ln4285">      /*</a>
<a name="ln4286">       * If we have got to the end of a paragraph, or the line is</a>
<a name="ln4287">       * getting long, format it.</a>
<a name="ln4288">       */</a>
<a name="ln4289">      if (is_end_par || force_format) {</a>
<a name="ln4290">        if (need_set_indent)</a>
<a name="ln4291">          /* replace indent in first line with minimal number of</a>
<a name="ln4292">           * tabs and spaces, according to current options */</a>
<a name="ln4293">          (void)set_indent(get_indent(), SIN_CHANGED);</a>
<a name="ln4294"> </a>
<a name="ln4295">        /* put cursor on last non-space */</a>
<a name="ln4296">        State = NORMAL;         /* don't go past end-of-line */</a>
<a name="ln4297">        coladvance((colnr_T)MAXCOL);</a>
<a name="ln4298">        while (curwin-&gt;w_cursor.col &amp;&amp; ascii_isspace(gchar_cursor()))</a>
<a name="ln4299">          dec_cursor();</a>
<a name="ln4300"> </a>
<a name="ln4301">        /* do the formatting, without 'showmode' */</a>
<a name="ln4302">        State = INSERT;         /* for open_line() */</a>
<a name="ln4303">        smd_save = p_smd;</a>
<a name="ln4304">        p_smd = FALSE;</a>
<a name="ln4305">        insertchar(NUL, INSCHAR_FORMAT</a>
<a name="ln4306">            + (do_comments ? INSCHAR_DO_COM : 0)</a>
<a name="ln4307">            + (do_comments &amp;&amp; do_comments_list</a>
<a name="ln4308">               ? INSCHAR_COM_LIST : 0)</a>
<a name="ln4309">            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);</a>
<a name="ln4310">        State = old_State;</a>
<a name="ln4311">        p_smd = smd_save;</a>
<a name="ln4312">        second_indent = -1;</a>
<a name="ln4313">        /* at end of par.: need to set indent of next par. */</a>
<a name="ln4314">        need_set_indent = is_end_par;</a>
<a name="ln4315">        if (is_end_par) {</a>
<a name="ln4316">          /* When called with a negative line count, break at the</a>
<a name="ln4317">           * end of the paragraph. */</a>
<a name="ln4318">          if (line_count &lt; 0)</a>
<a name="ln4319">            break;</a>
<a name="ln4320">          first_par_line = true;</a>
<a name="ln4321">        }</a>
<a name="ln4322">        force_format = false;</a>
<a name="ln4323">      }</a>
<a name="ln4324"> </a>
<a name="ln4325">      /*</a>
<a name="ln4326">       * When still in same paragraph, join the lines together.  But</a>
<a name="ln4327">       * first delete the leader from the second line.</a>
<a name="ln4328">       */</a>
<a name="ln4329">      if (!is_end_par) {</a>
<a name="ln4330">        advance = false;</a>
<a name="ln4331">        curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4332">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4333">        if (line_count &lt; 0 &amp;&amp; u_save_cursor() == FAIL)</a>
<a name="ln4334">          break;</a>
<a name="ln4335">        if (next_leader_len &gt; 0) {</a>
<a name="ln4336">          (void)del_bytes(next_leader_len, false, false);</a>
<a name="ln4337">          mark_col_adjust(curwin-&gt;w_cursor.lnum, (colnr_T)0, 0L,</a>
<a name="ln4338">                          (long)-next_leader_len, 0);</a>
<a name="ln4339">        } else if (second_indent &gt; 0) {   // the &quot;leader&quot; for FO_Q_SECOND</a>
<a name="ln4340">          int indent = (int)getwhitecols_curline();</a>
<a name="ln4341"> </a>
<a name="ln4342">          if (indent &gt; 0) {</a>
<a name="ln4343">            (void)del_bytes(indent, false, false);</a>
<a name="ln4344">            mark_col_adjust(curwin-&gt;w_cursor.lnum,</a>
<a name="ln4345">                            (colnr_T)0, 0L, (long)-indent, 0);</a>
<a name="ln4346">          }</a>
<a name="ln4347">        }</a>
<a name="ln4348">        curwin-&gt;w_cursor.lnum--;</a>
<a name="ln4349">        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {</a>
<a name="ln4350">          beep_flush();</a>
<a name="ln4351">          break;</a>
<a name="ln4352">        }</a>
<a name="ln4353">        first_par_line = false;</a>
<a name="ln4354">        // If the line is getting long, format it next time</a>
<a name="ln4355">        if (STRLEN(get_cursor_line_ptr()) &gt; (size_t)max_len) {</a>
<a name="ln4356">          force_format = true;</a>
<a name="ln4357">        } else {</a>
<a name="ln4358">          force_format = false;</a>
<a name="ln4359">        }</a>
<a name="ln4360">      }</a>
<a name="ln4361">    }</a>
<a name="ln4362">    line_breakcheck();</a>
<a name="ln4363">  }</a>
<a name="ln4364">}</a>
<a name="ln4365"> </a>
<a name="ln4366">/*</a>
<a name="ln4367"> * Return TRUE if line &quot;lnum&quot; ends in a white character.</a>
<a name="ln4368"> */</a>
<a name="ln4369">static int ends_in_white(linenr_T lnum)</a>
<a name="ln4370">{</a>
<a name="ln4371">  char_u      *s = ml_get(lnum);</a>
<a name="ln4372">  size_t l;</a>
<a name="ln4373"> </a>
<a name="ln4374">  if (*s == NUL)</a>
<a name="ln4375">    return FALSE;</a>
<a name="ln4376">  l = STRLEN(s) - 1;</a>
<a name="ln4377">  return ascii_iswhite(s[l]);</a>
<a name="ln4378">}</a>
<a name="ln4379"> </a>
<a name="ln4380">/*</a>
<a name="ln4381"> * Blank lines, and lines containing only the comment leader, are left</a>
<a name="ln4382"> * untouched by the formatting.  The function returns TRUE in this</a>
<a name="ln4383"> * case.  It also returns TRUE when a line starts with the end of a comment</a>
<a name="ln4384"> * ('e' in comment flags), so that this line is skipped, and not joined to the</a>
<a name="ln4385"> * previous line.  A new paragraph starts after a blank line, or when the</a>
<a name="ln4386"> * comment leader changes -- webb.</a>
<a name="ln4387"> */</a>
<a name="ln4388">static int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)</a>
<a name="ln4389">{</a>
<a name="ln4390">  char_u      *flags = NULL;        /* init for GCC */</a>
<a name="ln4391">  char_u      *ptr;</a>
<a name="ln4392"> </a>
<a name="ln4393">  ptr = ml_get(lnum);</a>
<a name="ln4394">  if (do_comments)</a>
<a name="ln4395">    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);</a>
<a name="ln4396">  else</a>
<a name="ln4397">    *leader_len = 0;</a>
<a name="ln4398"> </a>
<a name="ln4399">  if (*leader_len &gt; 0) {</a>
<a name="ln4400">    /*</a>
<a name="ln4401">     * Search for 'e' flag in comment leader flags.</a>
<a name="ln4402">     */</a>
<a name="ln4403">    flags = *leader_flags;</a>
<a name="ln4404">    while (*flags &amp;&amp; *flags != ':' &amp;&amp; *flags != COM_END)</a>
<a name="ln4405">      ++flags;</a>
<a name="ln4406">  }</a>
<a name="ln4407"> </a>
<a name="ln4408">  return *skipwhite(ptr + *leader_len) == NUL</a>
<a name="ln4409">         || (*leader_len &gt; 0 &amp;&amp; *flags == COM_END)</a>
<a name="ln4410">         || startPS(lnum, NUL, FALSE);</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">/*</a>
<a name="ln4414"> * Return TRUE when a paragraph starts in line &quot;lnum&quot;.  Return FALSE when the</a>
<a name="ln4415"> * previous line is in the same paragraph.  Used for auto-formatting.</a>
<a name="ln4416"> */</a>
<a name="ln4417">int paragraph_start(linenr_T lnum)</a>
<a name="ln4418">{</a>
<a name="ln4419">  char_u *p;</a>
<a name="ln4420">  int leader_len = 0;                // leader len of current line</a>
<a name="ln4421">  char_u *leader_flags = NULL;       // flags for leader of current line</a>
<a name="ln4422">  int next_leader_len = 0;           // leader len of next line</a>
<a name="ln4423">  char_u *next_leader_flags = NULL;  // flags for leader of next line</a>
<a name="ln4424"> </a>
<a name="ln4425">  if (lnum &lt;= 1)</a>
<a name="ln4426">    return TRUE;                /* start of the file */</a>
<a name="ln4427"> </a>
<a name="ln4428">  p = ml_get(lnum - 1);</a>
<a name="ln4429">  if (*p == NUL)</a>
<a name="ln4430">    return TRUE;                /* after empty line */</a>
<a name="ln4431"> </a>
<a name="ln4432">  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments</a>
<a name="ln4433">  if (fmt_check_par(lnum - 1, &amp;leader_len, &amp;leader_flags, do_comments)) {</a>
<a name="ln4434">    return true;  // after non-paragraph line</a>
<a name="ln4435">  }</a>
<a name="ln4436"> </a>
<a name="ln4437">  if (fmt_check_par(lnum, &amp;next_leader_len, &amp;next_leader_flags, do_comments)) {</a>
<a name="ln4438">    return true;  // &quot;lnum&quot; is not a paragraph line</a>
<a name="ln4439">  }</a>
<a name="ln4440"> </a>
<a name="ln4441">  if (has_format_option(FO_WHITE_PAR) &amp;&amp; !ends_in_white(lnum - 1))</a>
<a name="ln4442">    return TRUE;                /* missing trailing space in previous line. */</a>
<a name="ln4443"> </a>
<a name="ln4444">  if (has_format_option(FO_Q_NUMBER) &amp;&amp; (get_number_indent(lnum) &gt; 0))</a>
<a name="ln4445">    return TRUE;                /* numbered item starts in &quot;lnum&quot;. */</a>
<a name="ln4446"> </a>
<a name="ln4447">  if (!same_leader(lnum - 1, leader_len, leader_flags,</a>
<a name="ln4448">          next_leader_len, next_leader_flags))</a>
<a name="ln4449">    return TRUE;                /* change of comment leader. */</a>
<a name="ln4450"> </a>
<a name="ln4451">  return FALSE;</a>
<a name="ln4452">}</a>
<a name="ln4453"> </a>
<a name="ln4454">/*</a>
<a name="ln4455"> * prepare a few things for block mode yank/delete/tilde</a>
<a name="ln4456"> *</a>
<a name="ln4457"> * for delete:</a>
<a name="ln4458"> * - textlen includes the first/last char to be (partly) deleted</a>
<a name="ln4459"> * - start/endspaces is the number of columns that are taken by the</a>
<a name="ln4460"> *   first/last deleted char minus the number of columns that have to be</a>
<a name="ln4461"> *   deleted.</a>
<a name="ln4462"> * for yank and tilde:</a>
<a name="ln4463"> * - textlen includes the first/last char to be wholly yanked</a>
<a name="ln4464"> * - start/endspaces is the number of columns of the first/last yanked char</a>
<a name="ln4465"> *   that are to be yanked.</a>
<a name="ln4466"> */</a>
<a name="ln4467">static void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum,</a>
<a name="ln4468">                       bool is_del)</a>
<a name="ln4469">{</a>
<a name="ln4470">  int incr = 0;</a>
<a name="ln4471">  char_u      *pend;</a>
<a name="ln4472">  char_u      *pstart;</a>
<a name="ln4473">  char_u      *line;</a>
<a name="ln4474">  char_u      *prev_pstart;</a>
<a name="ln4475">  char_u      *prev_pend;</a>
<a name="ln4476">  const int lbr_saved = curwin-&gt;w_p_lbr;</a>
<a name="ln4477"> </a>
<a name="ln4478">  // Avoid a problem with unwanted linebreaks in block mode.</a>
<a name="ln4479">  curwin-&gt;w_p_lbr = false;</a>
<a name="ln4480">  bdp-&gt;startspaces = 0;</a>
<a name="ln4481">  bdp-&gt;endspaces = 0;</a>
<a name="ln4482">  bdp-&gt;textlen = 0;</a>
<a name="ln4483">  bdp-&gt;start_vcol = 0;</a>
<a name="ln4484">  bdp-&gt;end_vcol = 0;</a>
<a name="ln4485">  bdp-&gt;is_short = false;</a>
<a name="ln4486">  bdp-&gt;is_oneChar = false;</a>
<a name="ln4487">  bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4488">  bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4489">  bdp-&gt;end_char_vcols = 0;</a>
<a name="ln4490">  bdp-&gt;start_char_vcols = 0;</a>
<a name="ln4491"> </a>
<a name="ln4492">  line = ml_get(lnum);</a>
<a name="ln4493">  pstart = line;</a>
<a name="ln4494">  prev_pstart = line;</a>
<a name="ln4495">  while (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol &amp;&amp; *pstart) {</a>
<a name="ln4496">    /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln4497">    incr = lbr_chartabsize(line, pstart, (colnr_T)bdp-&gt;start_vcol);</a>
<a name="ln4498">    bdp-&gt;start_vcol += incr;</a>
<a name="ln4499">    if (ascii_iswhite(*pstart)) {</a>
<a name="ln4500">      bdp-&gt;pre_whitesp += incr;</a>
<a name="ln4501">      bdp-&gt;pre_whitesp_c++;</a>
<a name="ln4502">    } else {</a>
<a name="ln4503">      bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4504">      bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4505">    }</a>
<a name="ln4506">    prev_pstart = pstart;</a>
<a name="ln4507">    MB_PTR_ADV(pstart);</a>
<a name="ln4508">  }</a>
<a name="ln4509">  bdp-&gt;start_char_vcols = incr;</a>
<a name="ln4510">  if (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol) {      /* line too short */</a>
<a name="ln4511">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4512">    bdp-&gt;is_short = true;</a>
<a name="ln4513">    if (!is_del || oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4514">      bdp-&gt;endspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4515">    }</a>
<a name="ln4516">  } else {</a>
<a name="ln4517">    /* notice: this converts partly selected Multibyte characters to</a>
<a name="ln4518">     * spaces, too. */</a>
<a name="ln4519">    bdp-&gt;startspaces = bdp-&gt;start_vcol - oap-&gt;start_vcol;</a>
<a name="ln4520">    if (is_del &amp;&amp; bdp-&gt;startspaces)</a>
<a name="ln4521">      bdp-&gt;startspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4522">    pend = pstart;</a>
<a name="ln4523">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4524">    if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {  // it's all in one character</a>
<a name="ln4525">      bdp-&gt;is_oneChar = true;</a>
<a name="ln4526">      if (oap-&gt;op_type == OP_INSERT) {</a>
<a name="ln4527">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4528">      } else if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4529">        bdp-&gt;startspaces += oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4530">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4531">      } else {</a>
<a name="ln4532">        bdp-&gt;startspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4533">        if (is_del &amp;&amp; oap-&gt;op_type != OP_LSHIFT) {</a>
<a name="ln4534">          /* just putting the sum of those two into</a>
<a name="ln4535">           * bdp-&gt;startspaces doesn't work for Visual replace,</a>
<a name="ln4536">           * so we have to split the tab in two */</a>
<a name="ln4537">          bdp-&gt;startspaces = bdp-&gt;start_char_vcols</a>
<a name="ln4538">                             - (bdp-&gt;start_vcol - oap-&gt;start_vcol);</a>
<a name="ln4539">          bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4540">        }</a>
<a name="ln4541">      }</a>
<a name="ln4542">    } else {</a>
<a name="ln4543">      prev_pend = pend;</a>
<a name="ln4544">      while (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol &amp;&amp; *pend != NUL) {</a>
<a name="ln4545">        /* Count a tab for what it's worth (if list mode not on) */</a>
<a name="ln4546">        prev_pend = pend;</a>
<a name="ln4547">        incr = lbr_chartabsize_adv(line, &amp;pend, (colnr_T)bdp-&gt;end_vcol);</a>
<a name="ln4548">        bdp-&gt;end_vcol += incr;</a>
<a name="ln4549">      }</a>
<a name="ln4550">      if (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol</a>
<a name="ln4551">          &amp;&amp; (!is_del</a>
<a name="ln4552">              || oap-&gt;op_type == OP_APPEND</a>
<a name="ln4553">              || oap-&gt;op_type == OP_REPLACE)) {  // line too short</a>
<a name="ln4554">        bdp-&gt;is_short = true;</a>
<a name="ln4555">        // Alternative: include spaces to fill up the block.</a>
<a name="ln4556">        // Disadvantage: can lead to trailing spaces when the line is</a>
<a name="ln4557">        // short where the text is put</a>
<a name="ln4558">        // if (!is_del || oap-&gt;op_type == OP_APPEND)</a>
<a name="ln4559">        if (oap-&gt;op_type == OP_APPEND || virtual_op) {</a>
<a name="ln4560">          bdp-&gt;endspaces = oap-&gt;end_vcol - bdp-&gt;end_vcol</a>
<a name="ln4561">                           + oap-&gt;inclusive;</a>
<a name="ln4562">        }</a>
<a name="ln4563">      } else if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {</a>
<a name="ln4564">        bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4565">        if (!is_del &amp;&amp; bdp-&gt;endspaces) {</a>
<a name="ln4566">          bdp-&gt;endspaces = incr - bdp-&gt;endspaces;</a>
<a name="ln4567">          if (pend != pstart)</a>
<a name="ln4568">            pend = prev_pend;</a>
<a name="ln4569">        }</a>
<a name="ln4570">      }</a>
<a name="ln4571">    }</a>
<a name="ln4572">    bdp-&gt;end_char_vcols = incr;</a>
<a name="ln4573">    if (is_del &amp;&amp; bdp-&gt;startspaces)</a>
<a name="ln4574">      pstart = prev_pstart;</a>
<a name="ln4575">    bdp-&gt;textlen = (int)(pend - pstart);</a>
<a name="ln4576">  }</a>
<a name="ln4577">  bdp-&gt;textcol = (colnr_T) (pstart - line);</a>
<a name="ln4578">  bdp-&gt;textstart = pstart;</a>
<a name="ln4579">  curwin-&gt;w_p_lbr = lbr_saved;</a>
<a name="ln4580">}</a>
<a name="ln4581"> </a>
<a name="ln4582">/// Handle the add/subtract operator.</a>
<a name="ln4583">///</a>
<a name="ln4584">/// @param[in]  oap      Arguments of operator.</a>
<a name="ln4585">/// @param[in]  Prenum1  Amount of addition or subtraction.</a>
<a name="ln4586">/// @param[in]  g_cmd    Prefixed with `g`.</a>
<a name="ln4587">void op_addsub(oparg_T *oap, linenr_T Prenum1, bool g_cmd)</a>
<a name="ln4588">{</a>
<a name="ln4589">  pos_T pos;</a>
<a name="ln4590">  struct block_def bd;</a>
<a name="ln4591">  ssize_t change_cnt = 0;</a>
<a name="ln4592">  linenr_T amount = Prenum1;</a>
<a name="ln4593"> </a>
<a name="ln4594">  if (!VIsual_active) {</a>
<a name="ln4595">    pos = curwin-&gt;w_cursor;</a>
<a name="ln4596">    if (u_save_cursor() == FAIL) {</a>
<a name="ln4597">      return;</a>
<a name="ln4598">    }</a>
<a name="ln4599">    change_cnt = do_addsub(oap-&gt;op_type, &amp;pos, 0, amount);</a>
<a name="ln4600">    if (change_cnt) {</a>
<a name="ln4601">      changed_lines(pos.lnum, 0, pos.lnum + 1, 0L, true);</a>
<a name="ln4602">    }</a>
<a name="ln4603">  } else {</a>
<a name="ln4604">    int one_change;</a>
<a name="ln4605">    int length;</a>
<a name="ln4606">    pos_T startpos;</a>
<a name="ln4607"> </a>
<a name="ln4608">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4609">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln4610">      return;</a>
<a name="ln4611">    }</a>
<a name="ln4612"> </a>
<a name="ln4613">    pos = oap-&gt;start;</a>
<a name="ln4614">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln4615">      if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln4616">        // Visual block mode</a>
<a name="ln4617">        block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln4618">        pos.col = bd.textcol;</a>
<a name="ln4619">        length = bd.textlen;</a>
<a name="ln4620">      } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln4621">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4622">        pos.col = 0;</a>
<a name="ln4623">        length = (colnr_T)STRLEN(ml_get(pos.lnum));</a>
<a name="ln4624">      } else {</a>
<a name="ln4625">        // oap-&gt;motion_type == kMTCharWise</a>
<a name="ln4626">        if (pos.lnum == oap-&gt;start.lnum &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln4627">          dec(&amp;(oap-&gt;end));</a>
<a name="ln4628">        }</a>
<a name="ln4629">        length = (colnr_T)STRLEN(ml_get(pos.lnum));</a>
<a name="ln4630">        pos.col = 0;</a>
<a name="ln4631">        if (pos.lnum == oap-&gt;start.lnum) {</a>
<a name="ln4632">          pos.col += oap-&gt;start.col;</a>
<a name="ln4633">          length -= oap-&gt;start.col;</a>
<a name="ln4634">        }</a>
<a name="ln4635">        if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln4636">          length = (int)STRLEN(ml_get(oap-&gt;end.lnum));</a>
<a name="ln4637">          if (oap-&gt;end.col &gt;= length) {</a>
<a name="ln4638">            oap-&gt;end.col = length - 1;</a>
<a name="ln4639">          }</a>
<a name="ln4640">          length = oap-&gt;end.col - pos.col + 1;</a>
<a name="ln4641">        }</a>
<a name="ln4642">      }</a>
<a name="ln4643">      one_change = do_addsub(oap-&gt;op_type, &amp;pos, length, amount);</a>
<a name="ln4644">      if (one_change) {</a>
<a name="ln4645">        // Remember the start position of the first change.</a>
<a name="ln4646">        if (change_cnt == 0) {</a>
<a name="ln4647">          startpos = curbuf-&gt;b_op_start;</a>
<a name="ln4648">        }</a>
<a name="ln4649">        change_cnt++;</a>
<a name="ln4650">      }</a>
<a name="ln4651"> </a>
<a name="ln4652">      if (g_cmd &amp;&amp; one_change) {</a>
<a name="ln4653">        amount += Prenum1;</a>
<a name="ln4654">      }</a>
<a name="ln4655">    }</a>
<a name="ln4656">    if (change_cnt) {</a>
<a name="ln4657">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln4658">    }</a>
<a name="ln4659"> </a>
<a name="ln4660">    if (!change_cnt &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln4661">      // No change: need to remove the Visual selection</a>
<a name="ln4662">      redraw_curbuf_later(INVERTED);</a>
<a name="ln4663">    }</a>
<a name="ln4664"> </a>
<a name="ln4665">    // Set '[ mark if something changed. Keep the last end</a>
<a name="ln4666">    // position from do_addsub().</a>
<a name="ln4667">    if (change_cnt &gt; 0) {</a>
<a name="ln4668">      curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4669">    }</a>
<a name="ln4670"> </a>
<a name="ln4671">    if (change_cnt &gt; p_report) {</a>
<a name="ln4672">      if (change_cnt == 1) {</a>
<a name="ln4673">        MSG(_(&quot;1 line changed&quot;));</a>
<a name="ln4674">      } else {</a>
<a name="ln4675">        smsg((char *)_(&quot;%&quot; PRId64 &quot; lines changed&quot;), (int64_t)change_cnt);</a>
<a name="ln4676">      }</a>
<a name="ln4677">    }</a>
<a name="ln4678">  }</a>
<a name="ln4679">}</a>
<a name="ln4680"> </a>
<a name="ln4681">/// Add or subtract from a number in a line.</a>
<a name="ln4682">///</a>
<a name="ln4683">/// @param op_type OP_NR_ADD or OP_NR_SUB.</a>
<a name="ln4684">/// @param pos     Cursor position.</a>
<a name="ln4685">/// @param length  Target number length.</a>
<a name="ln4686">/// @param Prenum1 Amount of addition or subtraction.</a>
<a name="ln4687">///</a>
<a name="ln4688">/// @return true if some character was changed.</a>
<a name="ln4689">int do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1)</a>
<a name="ln4690">{</a>
<a name="ln4691">  int col;</a>
<a name="ln4692">  char_u      *buf1 = NULL;</a>
<a name="ln4693">  char_u buf2[NUMBUFLEN];</a>
<a name="ln4694">  int pre;  // 'X' or 'x': hex; '0': octal; 'B' or 'b': bin</a>
<a name="ln4695">  static bool hexupper = false;  // 0xABC</a>
<a name="ln4696">  uvarnumber_T n;</a>
<a name="ln4697">  uvarnumber_T oldn;</a>
<a name="ln4698">  char_u      *ptr;</a>
<a name="ln4699">  int c;</a>
<a name="ln4700">  int todel;</a>
<a name="ln4701">  bool dohex;</a>
<a name="ln4702">  bool dooct;</a>
<a name="ln4703">  bool dobin;</a>
<a name="ln4704">  bool doalp;</a>
<a name="ln4705">  int firstdigit;</a>
<a name="ln4706">  bool subtract;</a>
<a name="ln4707">  bool negative = false;</a>
<a name="ln4708">  bool was_positive = true;</a>
<a name="ln4709">  bool visual = VIsual_active;</a>
<a name="ln4710">  bool did_change = false;</a>
<a name="ln4711">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4712">  int maxlen = 0;</a>
<a name="ln4713">  pos_T startpos;</a>
<a name="ln4714">  pos_T endpos;</a>
<a name="ln4715">  colnr_T save_coladd = 0;</a>
<a name="ln4716"> </a>
<a name="ln4717">  dohex = (vim_strchr(curbuf-&gt;b_p_nf, 'x') != NULL);    // &quot;heX&quot;</a>
<a name="ln4718">  dooct = (vim_strchr(curbuf-&gt;b_p_nf, 'o') != NULL);    // &quot;Octal&quot;</a>
<a name="ln4719">  dobin = (vim_strchr(curbuf-&gt;b_p_nf, 'b') != NULL);    // &quot;Bin&quot;</a>
<a name="ln4720">  doalp = (vim_strchr(curbuf-&gt;b_p_nf, 'p') != NULL);    // &quot;alPha&quot;</a>
<a name="ln4721"> </a>
<a name="ln4722">  if (virtual_active()) {</a>
<a name="ln4723">    save_coladd = pos-&gt;coladd;</a>
<a name="ln4724">    pos-&gt;coladd = 0;</a>
<a name="ln4725">  }</a>
<a name="ln4726"> </a>
<a name="ln4727">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln4728">  ptr = ml_get(pos-&gt;lnum);</a>
<a name="ln4729">  col = pos-&gt;col;</a>
<a name="ln4730"> </a>
<a name="ln4731">  if (*ptr == NUL || col + !!save_coladd &gt;= (int)STRLEN(ptr)) {</a>
<a name="ln4732">    goto theend;</a>
<a name="ln4733">  }</a>
<a name="ln4734"> </a>
<a name="ln4735">  // First check if we are on a hexadecimal number, after the &quot;0x&quot;.</a>
<a name="ln4736">  if (!VIsual_active) {</a>
<a name="ln4737">    if (dobin) {</a>
<a name="ln4738">      while (col &gt; 0 &amp;&amp; ascii_isbdigit(ptr[col])) {</a>
<a name="ln4739">        col--;</a>
<a name="ln4740">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4741">      }</a>
<a name="ln4742">    }</a>
<a name="ln4743"> </a>
<a name="ln4744">    if (dohex) {</a>
<a name="ln4745">      while (col &gt; 0 &amp;&amp; ascii_isxdigit(ptr[col])) {</a>
<a name="ln4746">        col--;</a>
<a name="ln4747">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4748">      }</a>
<a name="ln4749">    }</a>
<a name="ln4750">    if (dobin</a>
<a name="ln4751">        &amp;&amp; dohex</a>
<a name="ln4752">        &amp;&amp; !((col &gt; 0</a>
<a name="ln4753">              &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4754">              &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4755">              &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4756">              &amp;&amp; ascii_isxdigit(ptr[col + 1])))) {</a>
<a name="ln4757">        // In case of binary/hexadecimal pattern overlap match, rescan</a>
<a name="ln4758"> </a>
<a name="ln4759">        col = curwin-&gt;w_cursor.col;</a>
<a name="ln4760"> </a>
<a name="ln4761">        while (col &gt; 0 &amp;&amp; ascii_isdigit(ptr[col])) {</a>
<a name="ln4762">          col--;</a>
<a name="ln4763">          col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4764">        }</a>
<a name="ln4765">    }</a>
<a name="ln4766"> </a>
<a name="ln4767">    if ((dohex</a>
<a name="ln4768">         &amp;&amp; col &gt; 0</a>
<a name="ln4769">         &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4770">         &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4771">         &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4772">         &amp;&amp; ascii_isxdigit(ptr[col + 1]))</a>
<a name="ln4773">        || (dobin</a>
<a name="ln4774">            &amp;&amp; col &gt; 0</a>
<a name="ln4775">            &amp;&amp; (ptr[col] == 'B' || ptr[col] == 'b')</a>
<a name="ln4776">            &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4777">            &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4778">            &amp;&amp; ascii_isbdigit(ptr[col + 1]))) {</a>
<a name="ln4779">      // Found hexadecimal or binary number, move to its start.</a>
<a name="ln4780">        col--;</a>
<a name="ln4781">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4782">    } else {</a>
<a name="ln4783">      // Search forward and then backward to find the start of number.</a>
<a name="ln4784">      col = pos-&gt;col;</a>
<a name="ln4785"> </a>
<a name="ln4786">      while (ptr[col] != NUL</a>
<a name="ln4787">             &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4788">             &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4789">        col++;</a>
<a name="ln4790">      }</a>
<a name="ln4791"> </a>
<a name="ln4792">      while (col &gt; 0</a>
<a name="ln4793">             &amp;&amp; ascii_isdigit(ptr[col - 1])</a>
<a name="ln4794">             &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4795">        col--;</a>
<a name="ln4796">      }</a>
<a name="ln4797">    }</a>
<a name="ln4798">  }</a>
<a name="ln4799"> </a>
<a name="ln4800">  if (visual) {</a>
<a name="ln4801">    while (ptr[col] != NUL &amp;&amp; length &gt; 0 &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4802">           &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4803">      int mb_len = utfc_ptr2len(ptr + col);</a>
<a name="ln4804"> </a>
<a name="ln4805">      col += mb_len;</a>
<a name="ln4806">      length -= mb_len;</a>
<a name="ln4807">    }</a>
<a name="ln4808"> </a>
<a name="ln4809">    if (length == 0) {</a>
<a name="ln4810">      goto theend;</a>
<a name="ln4811">    }</a>
<a name="ln4812"> </a>
<a name="ln4813">    if (col &gt; pos-&gt;col &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4814">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1)) {</a>
<a name="ln4815">      negative = true;</a>
<a name="ln4816">      was_positive = false;</a>
<a name="ln4817">    }</a>
<a name="ln4818">  }</a>
<a name="ln4819"> </a>
<a name="ln4820">  // If a number was found, and saving for undo works, replace the number.</a>
<a name="ln4821">  firstdigit = ptr[col];</a>
<a name="ln4822">  if (!ascii_isdigit(firstdigit) &amp;&amp; !(doalp &amp;&amp; ASCII_ISALPHA(firstdigit))) {</a>
<a name="ln4823">    beep_flush();</a>
<a name="ln4824">    goto theend;</a>
<a name="ln4825">  }</a>
<a name="ln4826"> </a>
<a name="ln4827">  if (doalp &amp;&amp; ASCII_ISALPHA(firstdigit)) {</a>
<a name="ln4828">    // decrement or increment alphabetic character</a>
<a name="ln4829">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4830">      if (CharOrd(firstdigit) &lt; Prenum1) {</a>
<a name="ln4831">        if (isupper(firstdigit)) {</a>
<a name="ln4832">          firstdigit = 'A';</a>
<a name="ln4833">        } else {</a>
<a name="ln4834">          firstdigit = 'a';</a>
<a name="ln4835">        }</a>
<a name="ln4836">      } else {</a>
<a name="ln4837">        firstdigit -= (int)Prenum1;</a>
<a name="ln4838">      }</a>
<a name="ln4839">    } else {</a>
<a name="ln4840">      if (26 - CharOrd(firstdigit) - 1 &lt; Prenum1) {</a>
<a name="ln4841">        if (isupper(firstdigit)) {</a>
<a name="ln4842">          firstdigit = 'Z';</a>
<a name="ln4843">        } else {</a>
<a name="ln4844">          firstdigit = 'z';</a>
<a name="ln4845">        }</a>
<a name="ln4846">      } else {</a>
<a name="ln4847">        firstdigit += (int)Prenum1;</a>
<a name="ln4848">      }</a>
<a name="ln4849">    }</a>
<a name="ln4850">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4851">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4852">    did_change = true;</a>
<a name="ln4853">    (void)del_char(false);</a>
<a name="ln4854">    ins_char(firstdigit);</a>
<a name="ln4855">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4856">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4857">  } else {</a>
<a name="ln4858">    if (col &gt; 0 &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4859">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1) &amp;&amp; !visual) {</a>
<a name="ln4860">      // negative number</a>
<a name="ln4861">      col--;</a>
<a name="ln4862">      negative = true;</a>
<a name="ln4863">    }</a>
<a name="ln4864"> </a>
<a name="ln4865">    // get the number value (unsigned)</a>
<a name="ln4866">    if (visual &amp;&amp; VIsual_mode != 'V') {</a>
<a name="ln4867">      maxlen = (curbuf-&gt;b_visual.vi_curswant == MAXCOL</a>
<a name="ln4868">                ? (int)STRLEN(ptr) - col</a>
<a name="ln4869">                : length);</a>
<a name="ln4870">    }</a>
<a name="ln4871"> </a>
<a name="ln4872">    vim_str2nr(ptr + col, &amp;pre, &amp;length,</a>
<a name="ln4873">               0 + (dobin ? STR2NR_BIN : 0)</a>
<a name="ln4874">               + (dooct ? STR2NR_OCT : 0)</a>
<a name="ln4875">               + (dohex ? STR2NR_HEX : 0),</a>
<a name="ln4876">               NULL, &amp;n, maxlen);</a>
<a name="ln4877"> </a>
<a name="ln4878">    // ignore leading '-' for hex, octal and bin numbers</a>
<a name="ln4879">    if (pre &amp;&amp; negative) {</a>
<a name="ln4880">      col++;</a>
<a name="ln4881">      length--;</a>
<a name="ln4882">      negative = false;</a>
<a name="ln4883">    }</a>
<a name="ln4884"> </a>
<a name="ln4885">    // add or subtract</a>
<a name="ln4886">    subtract = false;</a>
<a name="ln4887">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4888">      subtract ^= true;</a>
<a name="ln4889">    }</a>
<a name="ln4890">    if (negative) {</a>
<a name="ln4891">      subtract ^= true;</a>
<a name="ln4892">    }</a>
<a name="ln4893"> </a>
<a name="ln4894">    oldn = n;</a>
<a name="ln4895"> </a>
<a name="ln4896">    n = subtract ? n - (uvarnumber_T)Prenum1</a>
<a name="ln4897">                 : n + (uvarnumber_T)Prenum1;</a>
<a name="ln4898"> </a>
<a name="ln4899">    // handle wraparound for decimal numbers</a>
<a name="ln4900">    if (!pre) {</a>
<a name="ln4901">      if (subtract) {</a>
<a name="ln4902">        if (n &gt; oldn) {</a>
<a name="ln4903">          n = 1 + (n ^ (uvarnumber_T)-1);</a>
<a name="ln4904">          negative ^= true;</a>
<a name="ln4905">        }</a>
<a name="ln4906">      } else {</a>
<a name="ln4907">        // add</a>
<a name="ln4908">        if (n &lt; oldn) {</a>
<a name="ln4909">          n = (n ^ (uvarnumber_T)-1);</a>
<a name="ln4910">          negative ^= true;</a>
<a name="ln4911">        }</a>
<a name="ln4912">      }</a>
<a name="ln4913">      if (n == 0) {</a>
<a name="ln4914">        negative = false;</a>
<a name="ln4915">      }</a>
<a name="ln4916">    }</a>
<a name="ln4917"> </a>
<a name="ln4918">    if (visual &amp;&amp; !was_positive &amp;&amp; !negative &amp;&amp; col &gt; 0) {</a>
<a name="ln4919">      // need to remove the '-'</a>
<a name="ln4920">      col--;</a>
<a name="ln4921">      length++;</a>
<a name="ln4922">    }</a>
<a name="ln4923"> </a>
<a name="ln4924">    // Delete the old number.</a>
<a name="ln4925">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4926">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4927">    did_change = true;</a>
<a name="ln4928">    todel = length;</a>
<a name="ln4929">    c = gchar_cursor();</a>
<a name="ln4930"> </a>
<a name="ln4931">    // Don't include the '-' in the length, only the length of the part</a>
<a name="ln4932">    // after it is kept the same.</a>
<a name="ln4933">    if (c == '-') {</a>
<a name="ln4934">      length--;</a>
<a name="ln4935">    }</a>
<a name="ln4936">    while (todel-- &gt; 0) {</a>
<a name="ln4937">      if (c &lt; 0x100 &amp;&amp; isalpha(c)) {</a>
<a name="ln4938">        if (isupper(c)) {</a>
<a name="ln4939">          hexupper = true;</a>
<a name="ln4940">        } else {</a>
<a name="ln4941">          hexupper = false;</a>
<a name="ln4942">        }</a>
<a name="ln4943">      }</a>
<a name="ln4944">      // del_char() will mark line needing displaying</a>
<a name="ln4945">      (void)del_char(false);</a>
<a name="ln4946">      c = gchar_cursor();</a>
<a name="ln4947">    }</a>
<a name="ln4948"> </a>
<a name="ln4949">    // Prepare the leading characters in buf1[].</a>
<a name="ln4950">    // When there are many leading zeros it could be very long.</a>
<a name="ln4951">    // Allocate a bit too much.</a>
<a name="ln4952">    buf1 = xmalloc((size_t)length + NUMBUFLEN);</a>
<a name="ln4953">    ptr = buf1;</a>
<a name="ln4954">    if (negative &amp;&amp; (!visual || was_positive)) {</a>
<a name="ln4955">      *ptr++ = '-';</a>
<a name="ln4956">    }</a>
<a name="ln4957">    if (pre) {</a>
<a name="ln4958">      *ptr++ = '0';</a>
<a name="ln4959">      length--;</a>
<a name="ln4960">    }</a>
<a name="ln4961">    if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') {</a>
<a name="ln4962">      *ptr++ = (char_u)pre;</a>
<a name="ln4963">      length--;</a>
<a name="ln4964">    }</a>
<a name="ln4965"> </a>
<a name="ln4966">    // Put the number characters in buf2[].</a>
<a name="ln4967">    if (pre == 'b' || pre == 'B') {</a>
<a name="ln4968">      size_t bits = 0;</a>
<a name="ln4969">      size_t i = 0;</a>
<a name="ln4970"> </a>
<a name="ln4971">      // leading zeros</a>
<a name="ln4972">      for (bits = 8 * sizeof(n); bits &gt; 0; bits--) {</a>
<a name="ln4973">          if ((n &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln4974">            break;</a>
<a name="ln4975">          }</a>
<a name="ln4976">      }</a>
<a name="ln4977"> </a>
<a name="ln4978">      while (bits &gt; 0) {</a>
<a name="ln4979">          buf2[i++] = ((n &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln4980">      }</a>
<a name="ln4981"> </a>
<a name="ln4982">      buf2[i] = '\0';</a>
<a name="ln4983"> </a>
<a name="ln4984">    } else if (pre == 0) {</a>
<a name="ln4985">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIu64, (uint64_t)n);</a>
<a name="ln4986">    } else if (pre == '0') {</a>
<a name="ln4987">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIo64, (uint64_t)n);</a>
<a name="ln4988">    } else if (hexupper) {</a>
<a name="ln4989">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIX64, (uint64_t)n);</a>
<a name="ln4990">    } else {</a>
<a name="ln4991">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIx64, (uint64_t)n);</a>
<a name="ln4992">    }</a>
<a name="ln4993">    length -= (int)STRLEN(buf2);</a>
<a name="ln4994"> </a>
<a name="ln4995">    // Adjust number of zeros to the new number of digits, so the</a>
<a name="ln4996">    // total length of the number remains the same.</a>
<a name="ln4997">    // Don't do this when</a>
<a name="ln4998">    // the result may look like an octal number.</a>
<a name="ln4999">    if (firstdigit == '0' &amp;&amp; !(dooct &amp;&amp; pre == 0)) {</a>
<a name="ln5000">      while (length-- &gt; 0) {</a>
<a name="ln5001">        *ptr++ = '0';</a>
<a name="ln5002">      }</a>
<a name="ln5003">    }</a>
<a name="ln5004">    *ptr = NUL;</a>
<a name="ln5005">    STRCAT(buf1, buf2);</a>
<a name="ln5006">    ins_str(buf1);              // insert the new number</a>
<a name="ln5007">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln5008">    if (curwin-&gt;w_cursor.col) {</a>
<a name="ln5009">      curwin-&gt;w_cursor.col--;</a>
<a name="ln5010">    }</a>
<a name="ln5011">  }</a>
<a name="ln5012"> </a>
<a name="ln5013">  // set the '[ and '] marks</a>
<a name="ln5014">  curbuf-&gt;b_op_start = startpos;</a>
<a name="ln5015">  curbuf-&gt;b_op_end = endpos;</a>
<a name="ln5016">  if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln5017">    curbuf-&gt;b_op_end.col--;</a>
<a name="ln5018">  }</a>
<a name="ln5019"> </a>
<a name="ln5020">theend:</a>
<a name="ln5021">  xfree(buf1);</a>
<a name="ln5022">  if (visual) {</a>
<a name="ln5023">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln5024">  } else if (did_change) {</a>
<a name="ln5025">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln5026">  } else if (virtual_active()) {</a>
<a name="ln5027">    curwin-&gt;w_cursor.coladd = save_coladd;</a>
<a name="ln5028">  }</a>
<a name="ln5029"> </a>
<a name="ln5030">  return did_change;</a>
<a name="ln5031">}</a>
<a name="ln5032"> </a>
<a name="ln5033">/*</a>
<a name="ln5034"> * Return the type of a register.</a>
<a name="ln5035"> * Used for getregtype()</a>
<a name="ln5036"> * Returns kMTUnknown for error.</a>
<a name="ln5037"> */</a>
<a name="ln5038">MotionType get_reg_type(int regname, colnr_T *reg_width)</a>
<a name="ln5039">{</a>
<a name="ln5040">  switch (regname) {</a>
<a name="ln5041">    case '%':     // file name</a>
<a name="ln5042">    case '#':     // alternate file name</a>
<a name="ln5043">    case '=':     // expression</a>
<a name="ln5044">    case ':':     // last command line</a>
<a name="ln5045">    case '/':     // last search-pattern</a>
<a name="ln5046">    case '.':     // last inserted text</a>
<a name="ln5047">    case Ctrl_F:  // Filename under cursor</a>
<a name="ln5048">    case Ctrl_P:  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln5049">    case Ctrl_W:  // word under cursor</a>
<a name="ln5050">    case Ctrl_A:  // WORD (mnemonic All) under cursor</a>
<a name="ln5051">    case '_':     // black hole: always empty</a>
<a name="ln5052">      return kMTCharWise;</a>
<a name="ln5053">  }</a>
<a name="ln5054"> </a>
<a name="ln5055">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln5056">    return kMTUnknown;</a>
<a name="ln5057">  }</a>
<a name="ln5058"> </a>
<a name="ln5059">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln5060"> </a>
<a name="ln5061">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln5062">    if (reg_width != NULL &amp;&amp; reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln5063">      *reg_width = reg-&gt;y_width;</a>
<a name="ln5064">    }</a>
<a name="ln5065">    return reg-&gt;y_type;</a>
<a name="ln5066">  }</a>
<a name="ln5067">  return kMTUnknown;</a>
<a name="ln5068">}</a>
<a name="ln5069"> </a>
<a name="ln5070">/// Format the register type as a string.</a>
<a name="ln5071">///</a>
<a name="ln5072">/// @param reg_type The register type.</a>
<a name="ln5073">/// @param reg_width The width, only used if &quot;reg_type&quot; is kMTBlockWise.</a>
<a name="ln5074">/// @param[out] buf Buffer to store formatted string. The allocated size should</a>
<a name="ln5075">///                 be at least NUMBUFLEN+2 to always fit the value.</a>
<a name="ln5076">/// @param buf_len The allocated size of the buffer.</a>
<a name="ln5077">void format_reg_type(MotionType reg_type, colnr_T reg_width,</a>
<a name="ln5078">                     char *buf, size_t buf_len)</a>
<a name="ln5079">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5080">{</a>
<a name="ln5081">  assert(buf_len &gt; 1);</a>
<a name="ln5082">  switch (reg_type) {</a>
<a name="ln5083">    case kMTLineWise:</a>
<a name="ln5084">      buf[0] = 'V';</a>
<a name="ln5085">      buf[1] = NUL;</a>
<a name="ln5086">      break;</a>
<a name="ln5087">    case kMTCharWise:</a>
<a name="ln5088">      buf[0] = 'v';</a>
<a name="ln5089">      buf[1] = NUL;</a>
<a name="ln5090">      break;</a>
<a name="ln5091">    case kMTBlockWise:</a>
<a name="ln5092">      snprintf(buf, buf_len, CTRL_V_STR &quot;%&quot; PRIdCOLNR, reg_width + 1);</a>
<a name="ln5093">      break;</a>
<a name="ln5094">    case kMTUnknown:</a>
<a name="ln5095">      buf[0] = NUL;</a>
<a name="ln5096">      break;</a>
<a name="ln5097">  }</a>
<a name="ln5098">}</a>
<a name="ln5099"> </a>
<a name="ln5100"> </a>
<a name="ln5101">/// When `flags` has `kGRegList` return a list with text `s`.</a>
<a name="ln5102">/// Otherwise just return `s`.</a>
<a name="ln5103">///</a>
<a name="ln5104">/// Returns a void * for use in get_reg_contents().</a>
<a name="ln5105">static void *get_reg_wrap_one_line(char_u *s, int flags)</a>
<a name="ln5106">{</a>
<a name="ln5107">  if (!(flags &amp; kGRegList)) {</a>
<a name="ln5108">    return s;</a>
<a name="ln5109">  }</a>
<a name="ln5110">  list_T *const list = tv_list_alloc(1);</a>
<a name="ln5111">  tv_list_append_allocated_string(list, (char *)s);</a>
<a name="ln5112">  return list;</a>
<a name="ln5113">}</a>
<a name="ln5114"> </a>
<a name="ln5115">/// Gets the contents of a register.</a>
<a name="ln5116">/// @remark Used for `@r` in expressions and for `getreg()`.</a>
<a name="ln5117">///</a>
<a name="ln5118">/// @param regname  The register.</a>
<a name="ln5119">/// @param flags    see @ref GRegFlags</a>
<a name="ln5120">///</a>
<a name="ln5121">/// @returns The contents of the register as an allocated string.</a>
<a name="ln5122">/// @returns A linked list when `flags` contains @ref kGRegList.</a>
<a name="ln5123">/// @returns NULL for error.</a>
<a name="ln5124">void *get_reg_contents(int regname, int flags)</a>
<a name="ln5125">{</a>
<a name="ln5126">  // Don't allow using an expression register inside an expression.</a>
<a name="ln5127">  if (regname == '=') {</a>
<a name="ln5128">    if (flags &amp; kGRegNoExpr) {</a>
<a name="ln5129">      return NULL;</a>
<a name="ln5130">    }</a>
<a name="ln5131">    if (flags &amp; kGRegExprSrc) {</a>
<a name="ln5132">      return get_reg_wrap_one_line(get_expr_line_src(), flags);</a>
<a name="ln5133">    }</a>
<a name="ln5134">    return get_reg_wrap_one_line(get_expr_line(), flags);</a>
<a name="ln5135">  }</a>
<a name="ln5136"> </a>
<a name="ln5137">  if (regname == '@')       /* &quot;@@&quot; is used for unnamed register */</a>
<a name="ln5138">    regname = '&quot;';</a>
<a name="ln5139"> </a>
<a name="ln5140">  /* check for valid regname */</a>
<a name="ln5141">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false))</a>
<a name="ln5142">    return NULL;</a>
<a name="ln5143"> </a>
<a name="ln5144">  char_u *retval;</a>
<a name="ln5145">  bool allocated;</a>
<a name="ln5146">  if (get_spec_reg(regname, &amp;retval, &amp;allocated, false)) {</a>
<a name="ln5147">    if (retval == NULL) {</a>
<a name="ln5148">      return NULL;</a>
<a name="ln5149">    }</a>
<a name="ln5150">    if (allocated) {</a>
<a name="ln5151">      return get_reg_wrap_one_line(retval, flags);</a>
<a name="ln5152">    }</a>
<a name="ln5153">    return get_reg_wrap_one_line(vim_strsave(retval), flags);</a>
<a name="ln5154">  }</a>
<a name="ln5155"> </a>
<a name="ln5156">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln5157">  if (reg-&gt;y_array == NULL)</a>
<a name="ln5158">    return NULL;</a>
<a name="ln5159"> </a>
<a name="ln5160">  if (flags &amp; kGRegList) {</a>
<a name="ln5161">    list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln5162">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5163">      tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln5164">    }</a>
<a name="ln5165"> </a>
<a name="ln5166">    return list;</a>
<a name="ln5167">  }</a>
<a name="ln5168"> </a>
<a name="ln5169">  /*</a>
<a name="ln5170">   * Compute length of resulting string.</a>
<a name="ln5171">   */</a>
<a name="ln5172">  size_t len = 0;</a>
<a name="ln5173">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5174">    len += STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln5175">    /*</a>
<a name="ln5176">     * Insert a newline between lines and after last line if</a>
<a name="ln5177">     * y_type is kMTLineWise.</a>
<a name="ln5178">     */</a>
<a name="ln5179">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln5180">      len++;</a>
<a name="ln5181">    }</a>
<a name="ln5182">  }</a>
<a name="ln5183"> </a>
<a name="ln5184">  retval = xmalloc(len + 1);</a>
<a name="ln5185"> </a>
<a name="ln5186">  /*</a>
<a name="ln5187">   * Copy the lines of the yank register into the string.</a>
<a name="ln5188">   */</a>
<a name="ln5189">  len = 0;</a>
<a name="ln5190">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5191">    STRCPY(retval + len, reg-&gt;y_array[i]);</a>
<a name="ln5192">    len += STRLEN(retval + len);</a>
<a name="ln5193"> </a>
<a name="ln5194">    /*</a>
<a name="ln5195">     * Insert a NL between lines and after the last line if y_type is</a>
<a name="ln5196">     * kMTLineWise.</a>
<a name="ln5197">     */</a>
<a name="ln5198">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln5199">      retval[len++] = '\n';</a>
<a name="ln5200">    }</a>
<a name="ln5201">  }</a>
<a name="ln5202">  retval[len] = NUL;</a>
<a name="ln5203"> </a>
<a name="ln5204">  return retval;</a>
<a name="ln5205">}</a>
<a name="ln5206"> </a>
<a name="ln5207">static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)</a>
<a name="ln5208">{</a>
<a name="ln5209">  if (!valid_yank_reg(name, true)) {  // check for valid reg name</a>
<a name="ln5210">    emsg_invreg(name);</a>
<a name="ln5211">    return NULL;</a>
<a name="ln5212">  }</a>
<a name="ln5213"> </a>
<a name="ln5214">  // Don't want to change the current (unnamed) register.</a>
<a name="ln5215">  *old_y_previous = y_previous;</a>
<a name="ln5216"> </a>
<a name="ln5217">  yankreg_T *reg = get_yank_register(name, YREG_YANK);</a>
<a name="ln5218">  if (!is_append_register(name) &amp;&amp; !must_append) {</a>
<a name="ln5219">      free_register(reg);</a>
<a name="ln5220">  }</a>
<a name="ln5221">  return reg;</a>
<a name="ln5222">}</a>
<a name="ln5223"> </a>
<a name="ln5224">static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)</a>
<a name="ln5225">{</a>
<a name="ln5226">  // Send text of clipboard register to the clipboard.</a>
<a name="ln5227">  set_clipboard(name, reg);</a>
<a name="ln5228"> </a>
<a name="ln5229">  // ':let @&quot; = &quot;val&quot;' should change the meaning of the &quot;&quot; register</a>
<a name="ln5230">  if (name != '&quot;') {</a>
<a name="ln5231">    y_previous = old_y_previous;</a>
<a name="ln5232">  }</a>
<a name="ln5233">}</a>
<a name="ln5234"> </a>
<a name="ln5235">/// write_reg_contents - store `str` in register `name`</a>
<a name="ln5236">///</a>
<a name="ln5237">/// @see write_reg_contents_ex</a>
<a name="ln5238">void write_reg_contents(int name, const char_u *str, ssize_t len,</a>
<a name="ln5239">                        int must_append)</a>
<a name="ln5240">{</a>
<a name="ln5241">  write_reg_contents_ex(name, str, len, must_append, kMTUnknown, 0L);</a>
<a name="ln5242">}</a>
<a name="ln5243"> </a>
<a name="ln5244">void write_reg_contents_lst(int name, char_u **strings,</a>
<a name="ln5245">                            bool must_append, MotionType yank_type,</a>
<a name="ln5246">                            colnr_T block_len)</a>
<a name="ln5247">{</a>
<a name="ln5248">  if (name == '/' || name == '=') {</a>
<a name="ln5249">    char_u  *s = strings[0];</a>
<a name="ln5250">    if (strings[0] == NULL) {</a>
<a name="ln5251">      s = (char_u *)&quot;&quot;;</a>
<a name="ln5252">    } else if (strings[1] != NULL) {</a>
<a name="ln5253">      EMSG(_(&quot;E883: search pattern and expression register may not &quot;</a>
<a name="ln5254">             &quot;contain two or more lines&quot;));</a>
<a name="ln5255">      return;</a>
<a name="ln5256">    }</a>
<a name="ln5257">    write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);</a>
<a name="ln5258">    return;</a>
<a name="ln5259">  }</a>
<a name="ln5260"> </a>
<a name="ln5261">  // black hole: nothing to do</a>
<a name="ln5262">  if (name == '_') {</a>
<a name="ln5263">    return;</a>
<a name="ln5264">  }</a>
<a name="ln5265"> </a>
<a name="ln5266">  yankreg_T  *old_y_previous, *reg;</a>
<a name="ln5267">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5268">    return;</a>
<a name="ln5269">  }</a>
<a name="ln5270"> </a>
<a name="ln5271">  str_to_reg(reg, yank_type, (char_u *)strings, STRLEN((char_u *)strings),</a>
<a name="ln5272">             block_len, true);</a>
<a name="ln5273">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5274">}</a>
<a name="ln5275"> </a>
<a name="ln5276">/// write_reg_contents_ex - store `str` in register `name`</a>
<a name="ln5277">///</a>
<a name="ln5278">/// If `str` ends in '\n' or '\r', use linewise, otherwise use charwise.</a>
<a name="ln5279">///</a>
<a name="ln5280">/// @warning when `name` is '/', `len` and `must_append` are ignored. This</a>
<a name="ln5281">///          means that `str` MUST be NUL-terminated.</a>
<a name="ln5282">///</a>
<a name="ln5283">/// @param name The name of the register</a>
<a name="ln5284">/// @param str The contents to write</a>
<a name="ln5285">/// @param len If &gt;= 0, write `len` bytes of `str`. Otherwise, write</a>
<a name="ln5286">///               `strlen(str)` bytes. If `len` is larger than the</a>
<a name="ln5287">///               allocated size of `src`, the behaviour is undefined.</a>
<a name="ln5288">/// @param must_append If true, append the contents of `str` to the current</a>
<a name="ln5289">///                    contents of the register. Note that regardless of</a>
<a name="ln5290">///                    `must_append`, this function will append when `name`</a>
<a name="ln5291">///                    is an uppercase letter.</a>
<a name="ln5292">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5293">/// @param block_len width of visual block</a>
<a name="ln5294">void write_reg_contents_ex(int name,</a>
<a name="ln5295">                           const char_u *str,</a>
<a name="ln5296">                           ssize_t len,</a>
<a name="ln5297">                           bool must_append,</a>
<a name="ln5298">                           MotionType yank_type,</a>
<a name="ln5299">                           colnr_T block_len)</a>
<a name="ln5300">{</a>
<a name="ln5301">  if (len &lt; 0) {</a>
<a name="ln5302">    len = (ssize_t) STRLEN(str);</a>
<a name="ln5303">  }</a>
<a name="ln5304"> </a>
<a name="ln5305">  /* Special case: '/' search pattern */</a>
<a name="ln5306">  if (name == '/') {</a>
<a name="ln5307">    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);</a>
<a name="ln5308">    return;</a>
<a name="ln5309">  }</a>
<a name="ln5310"> </a>
<a name="ln5311">  if (name == '#') {</a>
<a name="ln5312">    buf_T *buf;</a>
<a name="ln5313"> </a>
<a name="ln5314">    if (ascii_isdigit(*str)) {</a>
<a name="ln5315">      int num = atoi((char *)str);</a>
<a name="ln5316"> </a>
<a name="ln5317">      buf = buflist_findnr(num);</a>
<a name="ln5318">      if (buf == NULL) {</a>
<a name="ln5319">        EMSGN(_(e_nobufnr), (long)num);</a>
<a name="ln5320">      }</a>
<a name="ln5321">    } else {</a>
<a name="ln5322">      buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),</a>
<a name="ln5323">                                           true, false, false));</a>
<a name="ln5324">    }</a>
<a name="ln5325">    if (buf == NULL) {</a>
<a name="ln5326">      return;</a>
<a name="ln5327">    }</a>
<a name="ln5328">    curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln5329">    return;</a>
<a name="ln5330">  }</a>
<a name="ln5331"> </a>
<a name="ln5332">  if (name == '=') {</a>
<a name="ln5333">    size_t offset = 0;</a>
<a name="ln5334">    size_t totlen = (size_t) len;</a>
<a name="ln5335"> </a>
<a name="ln5336">    if (must_append &amp;&amp; expr_line) {</a>
<a name="ln5337">      // append has been specified and expr_line already exists, so we'll</a>
<a name="ln5338">      // append the new string to expr_line.</a>
<a name="ln5339">      size_t exprlen = STRLEN(expr_line);</a>
<a name="ln5340"> </a>
<a name="ln5341">      totlen += exprlen;</a>
<a name="ln5342">      offset = exprlen;</a>
<a name="ln5343">    }</a>
<a name="ln5344"> </a>
<a name="ln5345">    // modify the global expr_line, extend/shrink it if necessary (realloc).</a>
<a name="ln5346">    // Copy the input string into the adjusted memory at the specified</a>
<a name="ln5347">    // offset.</a>
<a name="ln5348">    expr_line = xrealloc(expr_line, totlen + 1);</a>
<a name="ln5349">    memcpy(expr_line + offset, str, (size_t)len);</a>
<a name="ln5350">    expr_line[totlen] = NUL;</a>
<a name="ln5351"> </a>
<a name="ln5352">    return;</a>
<a name="ln5353">  }</a>
<a name="ln5354"> </a>
<a name="ln5355">  if (name == '_') {        // black hole: nothing to do</a>
<a name="ln5356">    return;</a>
<a name="ln5357">  }</a>
<a name="ln5358"> </a>
<a name="ln5359">  yankreg_T  *old_y_previous, *reg;</a>
<a name="ln5360">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5361">    return;</a>
<a name="ln5362">  }</a>
<a name="ln5363">  str_to_reg(reg, yank_type, str, (size_t)len, block_len, false);</a>
<a name="ln5364">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5365">}</a>
<a name="ln5366"> </a>
<a name="ln5367">/// str_to_reg - Put a string into a register.</a>
<a name="ln5368">///</a>
<a name="ln5369">/// When the register is not empty, the string is appended.</a>
<a name="ln5370">///</a>
<a name="ln5371">/// @param y_ptr pointer to yank register</a>
<a name="ln5372">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5373">/// @param str string or list of strings to put in register</a>
<a name="ln5374">/// @param len length of the string (Ignored when str_list=true.)</a>
<a name="ln5375">/// @param blocklen width of visual block, or -1 for &quot;I don't know.&quot;</a>
<a name="ln5376">/// @param str_list True if str is `char_u **`.</a>
<a name="ln5377">static void str_to_reg(yankreg_T *y_ptr, MotionType yank_type,</a>
<a name="ln5378">                       const char_u *str, size_t len, colnr_T blocklen,</a>
<a name="ln5379">                       bool str_list)</a>
<a name="ln5380">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5381">{</a>
<a name="ln5382">  if (y_ptr-&gt;y_array == NULL) {  // NULL means empty register</a>
<a name="ln5383">    y_ptr-&gt;y_size = 0;</a>
<a name="ln5384">  }</a>
<a name="ln5385"> </a>
<a name="ln5386">  if (yank_type == kMTUnknown) {</a>
<a name="ln5387">    yank_type = ((str_list</a>
<a name="ln5388">                  || (len &gt; 0 &amp;&amp; (str[len - 1] == NL || str[len - 1] == CAR)))</a>
<a name="ln5389">                 ? kMTLineWise : kMTCharWise);</a>
<a name="ln5390">  }</a>
<a name="ln5391"> </a>
<a name="ln5392">  size_t newlines = 0;</a>
<a name="ln5393">  bool extraline = false;  // extra line at the end</a>
<a name="ln5394">  bool append = false;     // append to last line in register</a>
<a name="ln5395"> </a>
<a name="ln5396">  // Count the number of lines within the string</a>
<a name="ln5397">  if (str_list) {</a>
<a name="ln5398">    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {</a>
<a name="ln5399">      newlines++;</a>
<a name="ln5400">    }</a>
<a name="ln5401">  } else {</a>
<a name="ln5402">    newlines = memcnt(str, '\n', len);</a>
<a name="ln5403">    if (yank_type == kMTCharWise || len == 0 || str[len - 1] != '\n') {</a>
<a name="ln5404">      extraline = 1;</a>
<a name="ln5405">      ++newlines;         // count extra newline at the end</a>
<a name="ln5406">    }</a>
<a name="ln5407">    if (y_ptr-&gt;y_size &gt; 0 &amp;&amp; y_ptr-&gt;y_type == kMTCharWise) {</a>
<a name="ln5408">      append = true;</a>
<a name="ln5409">      --newlines;         // uncount newline when appending first line</a>
<a name="ln5410">    }</a>
<a name="ln5411">  }</a>
<a name="ln5412"> </a>
<a name="ln5413"> </a>
<a name="ln5414">  // Grow the register array to hold the pointers to the new lines.</a>
<a name="ln5415">  char_u **pp = xrealloc(y_ptr-&gt;y_array,</a>
<a name="ln5416">                         (y_ptr-&gt;y_size + newlines) * sizeof(char_u *));</a>
<a name="ln5417">  y_ptr-&gt;y_array = pp;</a>
<a name="ln5418"> </a>
<a name="ln5419">  size_t lnum = y_ptr-&gt;y_size;  // The current line number.</a>
<a name="ln5420"> </a>
<a name="ln5421">  // If called with `blocklen &lt; 0`, we have to update the yank reg's width.</a>
<a name="ln5422">  size_t maxlen = 0;</a>
<a name="ln5423"> </a>
<a name="ln5424">  // Find the end of each line and save it into the array.</a>
<a name="ln5425">  if (str_list) {</a>
<a name="ln5426">    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {</a>
<a name="ln5427">      size_t ss_len = STRLEN(*ss);</a>
<a name="ln5428">      pp[lnum] = xmemdupz(*ss, ss_len);</a>
<a name="ln5429">      if (ss_len &gt; maxlen) {</a>
<a name="ln5430">        maxlen = ss_len;</a>
<a name="ln5431">      }</a>
<a name="ln5432">    }</a>
<a name="ln5433">  } else {</a>
<a name="ln5434">    size_t line_len;</a>
<a name="ln5435">    for (const char_u *start = str, *end = str + len;</a>
<a name="ln5436">         start &lt; end + extraline;</a>
<a name="ln5437">         start += line_len + 1, lnum++) {</a>
<a name="ln5438">      assert(end - start &gt;= 0);</a>
<a name="ln5439">      line_len = (size_t)((char_u *)xmemscan(start, '\n',</a>
<a name="ln5440">                                             (size_t)(end - start)) - start);</a>
<a name="ln5441">      if (line_len &gt; maxlen) {</a>
<a name="ln5442">        maxlen = line_len;</a>
<a name="ln5443">      }</a>
<a name="ln5444"> </a>
<a name="ln5445">      // When appending, copy the previous line and free it after.</a>
<a name="ln5446">      size_t extra = append ? STRLEN(pp[--lnum]) : 0;</a>
<a name="ln5447">      char_u *s = xmallocz(line_len + extra);</a>
<a name="ln5448">      memcpy(s, pp[lnum], extra);</a>
<a name="ln5449">      memcpy(s + extra, start, line_len);</a>
<a name="ln5450">      size_t s_len = extra + line_len;</a>
<a name="ln5451"> </a>
<a name="ln5452">      if (append) {</a>
<a name="ln5453">        xfree(pp[lnum]);</a>
<a name="ln5454">        append = false;  // only first line is appended</a>
<a name="ln5455">      }</a>
<a name="ln5456">      pp[lnum] = s;</a>
<a name="ln5457"> </a>
<a name="ln5458">      // Convert NULs to '\n' to prevent truncation.</a>
<a name="ln5459">      memchrsub(pp[lnum], NUL, '\n', s_len);</a>
<a name="ln5460">    }</a>
<a name="ln5461">  }</a>
<a name="ln5462">  y_ptr-&gt;y_type = yank_type;</a>
<a name="ln5463">  y_ptr-&gt;y_size = lnum;</a>
<a name="ln5464">  set_yreg_additional_data(y_ptr, NULL);</a>
<a name="ln5465">  y_ptr-&gt;timestamp = os_time();</a>
<a name="ln5466">  if (yank_type == kMTBlockWise) {</a>
<a name="ln5467">    y_ptr-&gt;y_width = (blocklen == -1 ? (colnr_T) maxlen - 1 : blocklen);</a>
<a name="ln5468">  } else {</a>
<a name="ln5469">    y_ptr-&gt;y_width = 0;</a>
<a name="ln5470">  }</a>
<a name="ln5471">}</a>
<a name="ln5472"> </a>
<a name="ln5473">void clear_oparg(oparg_T *oap)</a>
<a name="ln5474">{</a>
<a name="ln5475">  memset(oap, 0, sizeof(oparg_T));</a>
<a name="ln5476">}</a>
<a name="ln5477"> </a>
<a name="ln5478"> </a>
<a name="ln5479">/*</a>
<a name="ln5480"> *  Count the number of bytes, characters and &quot;words&quot; in a line.</a>
<a name="ln5481"> *</a>
<a name="ln5482"> *  &quot;Words&quot; are counted by looking for boundaries between non-space and</a>
<a name="ln5483"> *  space characters.  (it seems to produce results that match 'wc'.)</a>
<a name="ln5484"> *</a>
<a name="ln5485"> *  Return value is byte count; word count for the line is added to &quot;*wc&quot;.</a>
<a name="ln5486"> *  Char count is added to &quot;*cc&quot;.</a>
<a name="ln5487"> *</a>
<a name="ln5488"> *  The function will only examine the first &quot;limit&quot; characters in the</a>
<a name="ln5489"> *  line, stopping if it encounters an end-of-line (NUL byte).  In that</a>
<a name="ln5490"> *  case, eol_size will be added to the character count to account for</a>
<a name="ln5491"> *  the size of the EOL character.</a>
<a name="ln5492"> */</a>
<a name="ln5493">static varnumber_T line_count_info(char_u *line, varnumber_T *wc,</a>
<a name="ln5494">                                   varnumber_T *cc, varnumber_T limit,</a>
<a name="ln5495">                                   int eol_size)</a>
<a name="ln5496">{</a>
<a name="ln5497">  varnumber_T i;</a>
<a name="ln5498">  varnumber_T words = 0;</a>
<a name="ln5499">  varnumber_T chars = 0;</a>
<a name="ln5500">  int is_word = 0;</a>
<a name="ln5501"> </a>
<a name="ln5502">  for (i = 0; i &lt; limit &amp;&amp; line[i] != NUL; ) {</a>
<a name="ln5503">    if (is_word) {</a>
<a name="ln5504">      if (ascii_isspace(line[i])) {</a>
<a name="ln5505">        words++;</a>
<a name="ln5506">        is_word = 0;</a>
<a name="ln5507">      }</a>
<a name="ln5508">    } else if (!ascii_isspace(line[i]))</a>
<a name="ln5509">      is_word = 1;</a>
<a name="ln5510">    ++chars;</a>
<a name="ln5511">    i += (*mb_ptr2len)(line + i);</a>
<a name="ln5512">  }</a>
<a name="ln5513"> </a>
<a name="ln5514">  if (is_word)</a>
<a name="ln5515">    words++;</a>
<a name="ln5516">  *wc += words;</a>
<a name="ln5517"> </a>
<a name="ln5518">  /* Add eol_size if the end of line was reached before hitting limit. */</a>
<a name="ln5519">  if (i &lt; limit &amp;&amp; line[i] == NUL) {</a>
<a name="ln5520">    i += eol_size;</a>
<a name="ln5521">    chars += eol_size;</a>
<a name="ln5522">  }</a>
<a name="ln5523">  *cc += chars;</a>
<a name="ln5524">  return i;</a>
<a name="ln5525">}</a>
<a name="ln5526"> </a>
<a name="ln5527">/// Give some info about the position of the cursor (for &quot;g CTRL-G&quot;).</a>
<a name="ln5528">/// In Visual mode, give some info about the selected region.  (In this case,</a>
<a name="ln5529">/// the *_count_cursor variables store running totals for the selection.)</a>
<a name="ln5530">/// When &quot;dict&quot; is not NULL store the info there instead of showing it.</a>
<a name="ln5531">void cursor_pos_info(dict_T *dict)</a>
<a name="ln5532">{</a>
<a name="ln5533">  char_u      *p;</a>
<a name="ln5534">  char_u buf1[50];</a>
<a name="ln5535">  char_u buf2[40];</a>
<a name="ln5536">  linenr_T lnum;</a>
<a name="ln5537">  varnumber_T byte_count = 0;</a>
<a name="ln5538">  varnumber_T bom_count = 0;</a>
<a name="ln5539">  varnumber_T byte_count_cursor = 0;</a>
<a name="ln5540">  varnumber_T char_count = 0;</a>
<a name="ln5541">  varnumber_T char_count_cursor = 0;</a>
<a name="ln5542">  varnumber_T word_count = 0;</a>
<a name="ln5543">  varnumber_T word_count_cursor = 0;</a>
<a name="ln5544">  int eol_size;</a>
<a name="ln5545">  varnumber_T last_check = 100000L;</a>
<a name="ln5546">  long line_count_selected = 0;</a>
<a name="ln5547">  pos_T min_pos, max_pos;</a>
<a name="ln5548">  oparg_T oparg;</a>
<a name="ln5549">  struct block_def bd;</a>
<a name="ln5550">  const int l_VIsual_active = VIsual_active;</a>
<a name="ln5551">  const int l_VIsual_mode = VIsual_mode;</a>
<a name="ln5552"> </a>
<a name="ln5553">  // Compute the length of the file in characters.</a>
<a name="ln5554">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln5555">    if (dict == NULL) {</a>
<a name="ln5556">      MSG(_(no_lines_msg));</a>
<a name="ln5557">      return;</a>
<a name="ln5558">    }</a>
<a name="ln5559">  } else {</a>
<a name="ln5560">    if (get_fileformat(curbuf) == EOL_DOS)</a>
<a name="ln5561">      eol_size = 2;</a>
<a name="ln5562">    else</a>
<a name="ln5563">      eol_size = 1;</a>
<a name="ln5564"> </a>
<a name="ln5565">    if (l_VIsual_active) {</a>
<a name="ln5566">      if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5567">        min_pos = VIsual;</a>
<a name="ln5568">        max_pos = curwin-&gt;w_cursor;</a>
<a name="ln5569">      } else {</a>
<a name="ln5570">        min_pos = curwin-&gt;w_cursor;</a>
<a name="ln5571">        max_pos = VIsual;</a>
<a name="ln5572">      }</a>
<a name="ln5573">      if (*p_sel == 'e' &amp;&amp; max_pos.col &gt; 0)</a>
<a name="ln5574">        --max_pos.col;</a>
<a name="ln5575"> </a>
<a name="ln5576">      if (l_VIsual_mode == Ctrl_V) {</a>
<a name="ln5577">        char_u * saved_sbr = p_sbr;</a>
<a name="ln5578"> </a>
<a name="ln5579">        /* Make 'sbr' empty for a moment to get the correct size. */</a>
<a name="ln5580">        p_sbr = empty_option;</a>
<a name="ln5581">        oparg.is_VIsual = true;</a>
<a name="ln5582">        oparg.motion_type = kMTBlockWise;</a>
<a name="ln5583">        oparg.op_type = OP_NOP;</a>
<a name="ln5584">        getvcols(curwin, &amp;min_pos, &amp;max_pos,</a>
<a name="ln5585">            &amp;oparg.start_vcol, &amp;oparg.end_vcol);</a>
<a name="ln5586">        p_sbr = saved_sbr;</a>
<a name="ln5587">        if (curwin-&gt;w_curswant == MAXCOL)</a>
<a name="ln5588">          oparg.end_vcol = MAXCOL;</a>
<a name="ln5589">        /* Swap the start, end vcol if needed */</a>
<a name="ln5590">        if (oparg.end_vcol &lt; oparg.start_vcol) {</a>
<a name="ln5591">          oparg.end_vcol += oparg.start_vcol;</a>
<a name="ln5592">          oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;</a>
<a name="ln5593">          oparg.end_vcol -= oparg.start_vcol;</a>
<a name="ln5594">        }</a>
<a name="ln5595">      }</a>
<a name="ln5596">      line_count_selected = max_pos.lnum - min_pos.lnum + 1;</a>
<a name="ln5597">    }</a>
<a name="ln5598"> </a>
<a name="ln5599">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; ++lnum) {</a>
<a name="ln5600">      /* Check for a CTRL-C every 100000 characters. */</a>
<a name="ln5601">      if (byte_count &gt; last_check) {</a>
<a name="ln5602">        os_breakcheck();</a>
<a name="ln5603">        if (got_int)</a>
<a name="ln5604">          return;</a>
<a name="ln5605">        last_check = byte_count + 100000L;</a>
<a name="ln5606">      }</a>
<a name="ln5607"> </a>
<a name="ln5608">      /* Do extra processing for VIsual mode. */</a>
<a name="ln5609">      if (l_VIsual_active</a>
<a name="ln5610">          &amp;&amp; lnum &gt;= min_pos.lnum &amp;&amp; lnum &lt;= max_pos.lnum) {</a>
<a name="ln5611">        char_u      *s = NULL;</a>
<a name="ln5612">        long len = 0L;</a>
<a name="ln5613"> </a>
<a name="ln5614">        switch (l_VIsual_mode) {</a>
<a name="ln5615">        case Ctrl_V:</a>
<a name="ln5616">          virtual_op = virtual_active();</a>
<a name="ln5617">          block_prep(&amp;oparg, &amp;bd, lnum, false);</a>
<a name="ln5618">          virtual_op = kNone;</a>
<a name="ln5619">          s = bd.textstart;</a>
<a name="ln5620">          len = (long)bd.textlen;</a>
<a name="ln5621">          break;</a>
<a name="ln5622">        case 'V':</a>
<a name="ln5623">          s = ml_get(lnum);</a>
<a name="ln5624">          len = MAXCOL;</a>
<a name="ln5625">          break;</a>
<a name="ln5626">        case 'v':</a>
<a name="ln5627">        {</a>
<a name="ln5628">          colnr_T start_col = (lnum == min_pos.lnum)</a>
<a name="ln5629">                              ? min_pos.col : 0;</a>
<a name="ln5630">          colnr_T end_col = (lnum == max_pos.lnum)</a>
<a name="ln5631">                            ? max_pos.col - start_col + 1 : MAXCOL;</a>
<a name="ln5632"> </a>
<a name="ln5633">          s = ml_get(lnum) + start_col;</a>
<a name="ln5634">          len = end_col;</a>
<a name="ln5635">        }</a>
<a name="ln5636">        break;</a>
<a name="ln5637">        }</a>
<a name="ln5638">        if (s != NULL) {</a>
<a name="ln5639">          byte_count_cursor += line_count_info(s, &amp;word_count_cursor,</a>
<a name="ln5640">              &amp;char_count_cursor, len, eol_size);</a>
<a name="ln5641">          if (lnum == curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln5642">              &amp;&amp; !curbuf-&gt;b_p_eol</a>
<a name="ln5643">              &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)</a>
<a name="ln5644">              &amp;&amp; (long)STRLEN(s) &lt; len)</a>
<a name="ln5645">            byte_count_cursor -= eol_size;</a>
<a name="ln5646">        }</a>
<a name="ln5647">      } else {</a>
<a name="ln5648">        /* In non-visual mode, check for the line the cursor is on */</a>
<a name="ln5649">        if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5650">          word_count_cursor += word_count;</a>
<a name="ln5651">          char_count_cursor += char_count;</a>
<a name="ln5652">          byte_count_cursor = byte_count</a>
<a name="ln5653">            + line_count_info(ml_get(lnum), &amp;word_count_cursor,</a>
<a name="ln5654">                              &amp;char_count_cursor,</a>
<a name="ln5655">                              (varnumber_T)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5656">                              eol_size);</a>
<a name="ln5657">        }</a>
<a name="ln5658">      }</a>
<a name="ln5659">      // Add to the running totals</a>
<a name="ln5660">      byte_count += line_count_info(ml_get(lnum), &amp;word_count, &amp;char_count,</a>
<a name="ln5661">                                    (varnumber_T)MAXCOL, eol_size);</a>
<a name="ln5662">    }</a>
<a name="ln5663"> </a>
<a name="ln5664">    // Correction for when last line doesn't have an EOL.</a>
<a name="ln5665">    if (!curbuf-&gt;b_p_eol &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)) {</a>
<a name="ln5666">      byte_count -= eol_size;</a>
<a name="ln5667">    }</a>
<a name="ln5668"> </a>
<a name="ln5669">    if (dict == NULL) {</a>
<a name="ln5670">      if (l_VIsual_active) {</a>
<a name="ln5671">        if (l_VIsual_mode == Ctrl_V &amp;&amp; curwin-&gt;w_curswant &lt; MAXCOL) {</a>
<a name="ln5672">          getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;min_pos.col, &amp;max_pos.col);</a>
<a name="ln5673">          int64_t cols;</a>
<a name="ln5674">          STRICT_SUB(oparg.end_vcol + 1, oparg.start_vcol, &amp;cols, int64_t);</a>
<a name="ln5675">          vim_snprintf((char *)buf1, sizeof(buf1), _(&quot;%&quot; PRId64 &quot; Cols; &quot;),</a>
<a name="ln5676">                       cols);</a>
<a name="ln5677">        } else {</a>
<a name="ln5678">          buf1[0] = NUL;</a>
<a name="ln5679">        }</a>
<a name="ln5680"> </a>
<a name="ln5681">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5682">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5683">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5684">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5685">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5686">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5687">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5688">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5689">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5690">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5691">        } else {</a>
<a name="ln5692">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5693">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5694">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5695">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Chars;&quot;</a>
<a name="ln5696">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5697">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5698">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5699">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5700">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5701">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5702">        }</a>
<a name="ln5703">      } else {</a>
<a name="ln5704">        p = get_cursor_line_ptr();</a>
<a name="ln5705">        validate_virtcol();</a>
<a name="ln5706">        col_print(buf1, sizeof(buf1), (int)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5707">                  (int)curwin-&gt;w_virtcol + 1);</a>
<a name="ln5708">        col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));</a>
<a name="ln5709"> </a>
<a name="ln5710">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5711">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5712">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5713">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5714">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5715">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5716">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5717">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5718">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5719">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5720">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5721">        } else {</a>
<a name="ln5722">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5723">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5724">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5725">                         &quot; Char %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5726">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5727">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5728">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5729">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5730">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5731">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5732">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5733">        }</a>
<a name="ln5734">      }</a>
<a name="ln5735">    }</a>
<a name="ln5736"> </a>
<a name="ln5737">    bom_count = bomb_size();</a>
<a name="ln5738">    if (dict == NULL &amp;&amp; bom_count &gt; 0) {</a>
<a name="ln5739">      const size_t len = STRLEN(IObuff);</a>
<a name="ln5740">      vim_snprintf((char *)IObuff + len, IOSIZE - len,</a>
<a name="ln5741">                   _(&quot;(+%&quot; PRId64 &quot; for BOM)&quot;), (int64_t)bom_count);</a>
<a name="ln5742">    }</a>
<a name="ln5743">    if (dict == NULL) {</a>
<a name="ln5744">      // Don't shorten this message, the user asked for it.</a>
<a name="ln5745">      p = p_shm;</a>
<a name="ln5746">      p_shm = (char_u *)&quot;&quot;;</a>
<a name="ln5747">      msg(IObuff);</a>
<a name="ln5748">      p_shm = p;</a>
<a name="ln5749">    }</a>
<a name="ln5750">  }</a>
<a name="ln5751"> </a>
<a name="ln5752">  if (dict != NULL) {</a>
<a name="ln5753">    // Don't shorten this message, the user asked for it.</a>
<a name="ln5754">    tv_dict_add_nr(dict, S_LEN(&quot;words&quot;), (varnumber_T)word_count);</a>
<a name="ln5755">    tv_dict_add_nr(dict, S_LEN(&quot;chars&quot;), (varnumber_T)char_count);</a>
<a name="ln5756">    tv_dict_add_nr(dict, S_LEN(&quot;bytes&quot;), (varnumber_T)(byte_count + bom_count));</a>
<a name="ln5757"> </a>
<a name="ln5758">    STATIC_ASSERT(sizeof(&quot;visual&quot;) == sizeof(&quot;cursor&quot;),</a>
<a name="ln5759">                  &quot;key_len argument in tv_dict_add_nr is wrong&quot;);</a>
<a name="ln5760">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_bytes&quot; : &quot;cursor_bytes&quot;,</a>
<a name="ln5761">                   sizeof(&quot;visual_bytes&quot;) - 1, (varnumber_T)byte_count_cursor);</a>
<a name="ln5762">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_chars&quot; : &quot;cursor_chars&quot;,</a>
<a name="ln5763">                   sizeof(&quot;visual_chars&quot;) - 1, (varnumber_T)char_count_cursor);</a>
<a name="ln5764">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_words&quot; : &quot;cursor_words&quot;,</a>
<a name="ln5765">                   sizeof(&quot;visual_words&quot;) - 1, (varnumber_T)word_count_cursor);</a>
<a name="ln5766">  }</a>
<a name="ln5767">}</a>
<a name="ln5768"> </a>
<a name="ln5769">/// Check if the default register (used in an unnamed paste) should be a</a>
<a name="ln5770">/// clipboard register. This happens when `clipboard=unnamed[plus]` is set</a>
<a name="ln5771">/// and a provider is available.</a>
<a name="ln5772">///</a>
<a name="ln5773">/// @returns the name of of a clipboard register that should be used, or `NUL` if none.</a>
<a name="ln5774">int get_default_register_name(void)</a>
<a name="ln5775">{</a>
<a name="ln5776">  int name = NUL;</a>
<a name="ln5777">  adjust_clipboard_name(&amp;name, true, false);</a>
<a name="ln5778">  return name;</a>
<a name="ln5779">}</a>
<a name="ln5780"> </a>
<a name="ln5781">/// Determine if register `*name` should be used as a clipboard.</a>
<a name="ln5782">/// In an unnamed operation, `*name` is `NUL` and will be adjusted to */+ if</a>
<a name="ln5783">/// `clipboard=unnamed[plus]` is set.</a>
<a name="ln5784">///</a>
<a name="ln5785">/// @param name The name of register, or `NUL` if unnamed.</a>
<a name="ln5786">/// @param quiet Suppress error messages</a>
<a name="ln5787">/// @param writing if we're setting the contents of the clipboard</a>
<a name="ln5788">///</a>
<a name="ln5789">/// @returns the yankreg that should be written into, or `NULL`</a>
<a name="ln5790">/// if the register isn't a clipboard or provider isn't available.</a>
<a name="ln5791">static yankreg_T *adjust_clipboard_name(int *name, bool quiet, bool writing)</a>
<a name="ln5792">{</a>
<a name="ln5793">#define MSG_NO_CLIP &quot;clipboard: No provider. &quot; \</a>
<a name="ln5794">  &quot;Try \&quot;:checkhealth\&quot; or \&quot;:h clipboard\&quot;.&quot;</a>
<a name="ln5795"> </a>
<a name="ln5796">  yankreg_T *target = NULL;</a>
<a name="ln5797">  bool explicit_cb_reg = (*name == '*' || *name == '+');</a>
<a name="ln5798">  bool implicit_cb_reg = (*name == NUL) &amp;&amp; (cb_flags &amp; CB_UNNAMEDMASK);</a>
<a name="ln5799">  if (!explicit_cb_reg &amp;&amp; !implicit_cb_reg) {</a>
<a name="ln5800">    goto end;</a>
<a name="ln5801">  }</a>
<a name="ln5802"> </a>
<a name="ln5803">  if (!eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln5804">    if (batch_change_count == 1 &amp;&amp; !quiet</a>
<a name="ln5805">        &amp;&amp; (!clipboard_didwarn || (explicit_cb_reg &amp;&amp; !redirecting()))) {</a>
<a name="ln5806">      clipboard_didwarn = true;</a>
<a name="ln5807">      // Do NOT error (emsg()) here--if it interrupts :redir we get into</a>
<a name="ln5808">      // a weird state, stuck in &quot;redirect mode&quot;.</a>
<a name="ln5809">      msg((char_u *)MSG_NO_CLIP);</a>
<a name="ln5810">    }</a>
<a name="ln5811">    // ... else, be silent (don't flood during :while, :redir, etc.).</a>
<a name="ln5812">    goto end;</a>
<a name="ln5813">  }</a>
<a name="ln5814"> </a>
<a name="ln5815">  if (explicit_cb_reg) {</a>
<a name="ln5816">    target = &amp;y_regs[*name == '*' ? STAR_REGISTER : PLUS_REGISTER];</a>
<a name="ln5817">    if (writing &amp;&amp; (cb_flags &amp; (*name == '*' ? CB_UNNAMED : CB_UNNAMEDPLUS))) {</a>
<a name="ln5818">      clipboard_needs_update = false;</a>
<a name="ln5819">    }</a>
<a name="ln5820">    goto end;</a>
<a name="ln5821">  } else {  // unnamed register: &quot;implicit&quot; clipboard</a>
<a name="ln5822">    if (writing &amp;&amp; clipboard_delay_update) {</a>
<a name="ln5823">      // For &quot;set&quot; (copy), defer the clipboard call.</a>
<a name="ln5824">      clipboard_needs_update = true;</a>
<a name="ln5825">      goto end;</a>
<a name="ln5826">    } else if (!writing &amp;&amp; clipboard_needs_update) {</a>
<a name="ln5827">      // For &quot;get&quot; (paste), use the internal value.</a>
<a name="ln5828">      goto end;</a>
<a name="ln5829">    }</a>
<a name="ln5830"> </a>
<a name="ln5831">    if (cb_flags &amp; CB_UNNAMEDPLUS) {</a>
<a name="ln5832">      *name = (cb_flags &amp; CB_UNNAMED &amp;&amp; writing) ? '&quot;': '+';</a>
<a name="ln5833">      target = &amp;y_regs[PLUS_REGISTER];</a>
<a name="ln5834">    } else {</a>
<a name="ln5835">      *name = '*';</a>
<a name="ln5836">      target = &amp;y_regs[STAR_REGISTER];</a>
<a name="ln5837">    }</a>
<a name="ln5838">    goto end;</a>
<a name="ln5839">  }</a>
<a name="ln5840"> </a>
<a name="ln5841">end:</a>
<a name="ln5842">  return target;</a>
<a name="ln5843">}</a>
<a name="ln5844"> </a>
<a name="ln5845">/// @param[out] reg Expected to be empty</a>
<a name="ln5846">bool prepare_yankreg_from_object(yankreg_T *reg, String regtype, size_t lines)</a>
<a name="ln5847">{</a>
<a name="ln5848">  char type = regtype.data ? regtype.data[0] : NUL;</a>
<a name="ln5849"> </a>
<a name="ln5850">  switch (type) {</a>
<a name="ln5851">  case 0:</a>
<a name="ln5852">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln5853">    break;</a>
<a name="ln5854">  case 'v': case 'c':</a>
<a name="ln5855">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln5856">    break;</a>
<a name="ln5857">  case 'V': case 'l':</a>
<a name="ln5858">    reg-&gt;y_type = kMTLineWise;</a>
<a name="ln5859">    break;</a>
<a name="ln5860">  case 'b': case Ctrl_V:</a>
<a name="ln5861">    reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln5862">    break;</a>
<a name="ln5863">  default:</a>
<a name="ln5864">    return false;</a>
<a name="ln5865">  }</a>
<a name="ln5866"> </a>
<a name="ln5867">  reg-&gt;y_width = 0;</a>
<a name="ln5868">  if (regtype.size &gt; 1) {</a>
<a name="ln5869">    if (reg-&gt;y_type != kMTBlockWise) {</a>
<a name="ln5870">      return false;</a>
<a name="ln5871">    }</a>
<a name="ln5872"> </a>
<a name="ln5873">    // allow &quot;b7&quot; for a block at least 7 spaces wide</a>
<a name="ln5874">    if (!ascii_isdigit(regtype.data[1])) {</a>
<a name="ln5875">      return false;</a>
<a name="ln5876">    }</a>
<a name="ln5877">    const char *p = regtype.data+1;</a>
<a name="ln5878">    reg-&gt;y_width = getdigits_int((char_u **)&amp;p, false, 1) - 1;</a>
<a name="ln5879">    if (regtype.size &gt; (size_t)(p-regtype.data)) {</a>
<a name="ln5880">      return false;</a>
<a name="ln5881">    }</a>
<a name="ln5882">  }</a>
<a name="ln5883"> </a>
<a name="ln5884">  reg-&gt;y_array = xcalloc(lines, sizeof(uint8_t *));</a>
<a name="ln5885">  reg-&gt;y_size = lines;</a>
<a name="ln5886">  reg-&gt;additional_data = NULL;</a>
<a name="ln5887">  reg-&gt;timestamp = 0;</a>
<a name="ln5888">  return true;</a>
<a name="ln5889">}</a>
<a name="ln5890"> </a>
<a name="ln5891">void finish_yankreg_from_object(yankreg_T *reg, bool clipboard_adjust)</a>
<a name="ln5892">{</a>
<a name="ln5893">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen((char *)reg-&gt;y_array[reg-&gt;y_size-1]) == 0) {</a>
<a name="ln5894">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln5895">    // but otherwise there is no line after the final newline</a>
<a name="ln5896">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln5897">      if (reg-&gt;y_type == kMTUnknown || clipboard_adjust) {</a>
<a name="ln5898">        xfree(reg-&gt;y_array[reg-&gt;y_size-1]);</a>
<a name="ln5899">        reg-&gt;y_size--;</a>
<a name="ln5900">      }</a>
<a name="ln5901">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln5902">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln5903">      }</a>
<a name="ln5904">    }</a>
<a name="ln5905">  } else {</a>
<a name="ln5906">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln5907">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln5908">    }</a>
<a name="ln5909">  }</a>
<a name="ln5910"> </a>
<a name="ln5911">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln5912">    size_t maxlen = 0;</a>
<a name="ln5913">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln5914">      size_t rowlen = STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln5915">      if (rowlen &gt; maxlen) {</a>
<a name="ln5916">        maxlen = rowlen;</a>
<a name="ln5917">      }</a>
<a name="ln5918">    }</a>
<a name="ln5919">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln5920">    reg-&gt;y_width = MAX(reg-&gt;y_width, (int)maxlen - 1);</a>
<a name="ln5921">  }</a>
<a name="ln5922">}</a>
<a name="ln5923"> </a>
<a name="ln5924">static bool get_clipboard(int name, yankreg_T **target, bool quiet)</a>
<a name="ln5925">{</a>
<a name="ln5926">  // show message on error</a>
<a name="ln5927">  bool errmsg = true;</a>
<a name="ln5928"> </a>
<a name="ln5929">  yankreg_T *reg = adjust_clipboard_name(&amp;name, quiet, false);</a>
<a name="ln5930">  if (reg == NULL) {</a>
<a name="ln5931">    return false;</a>
<a name="ln5932">  }</a>
<a name="ln5933">  free_register(reg);</a>
<a name="ln5934"> </a>
<a name="ln5935">  list_T *const args = tv_list_alloc(1);</a>
<a name="ln5936">  const char regname = (char)name;</a>
<a name="ln5937">  tv_list_append_string(args, &amp;regname, 1);</a>
<a name="ln5938"> </a>
<a name="ln5939">  typval_T result = eval_call_provider(&quot;clipboard&quot;, &quot;get&quot;, args, false);</a>
<a name="ln5940"> </a>
<a name="ln5941">  if (result.v_type != VAR_LIST) {</a>
<a name="ln5942">    if (result.v_type == VAR_NUMBER &amp;&amp; result.vval.v_number == 0) {</a>
<a name="ln5943">      // failure has already been indicated by provider</a>
<a name="ln5944">      errmsg = false;</a>
<a name="ln5945">    }</a>
<a name="ln5946">    goto err;</a>
<a name="ln5947">  }</a>
<a name="ln5948"> </a>
<a name="ln5949">  list_T *res = result.vval.v_list;</a>
<a name="ln5950">  list_T *lines = NULL;</a>
<a name="ln5951">  if (tv_list_len(res) == 2</a>
<a name="ln5952">      &amp;&amp; TV_LIST_ITEM_TV(tv_list_first(res))-&gt;v_type == VAR_LIST) {</a>
<a name="ln5953">    lines = TV_LIST_ITEM_TV(tv_list_first(res))-&gt;vval.v_list;</a>
<a name="ln5954">    if (TV_LIST_ITEM_TV(tv_list_last(res))-&gt;v_type != VAR_STRING) {</a>
<a name="ln5955">      goto err;</a>
<a name="ln5956">    }</a>
<a name="ln5957">    char_u *regtype = TV_LIST_ITEM_TV(tv_list_last(res))-&gt;vval.v_string;</a>
<a name="ln5958">    if (regtype == NULL || strlen((char *)regtype) &gt; 1) {</a>
<a name="ln5959">      goto err;</a>
<a name="ln5960">    }</a>
<a name="ln5961">    switch (regtype[0]) {</a>
<a name="ln5962">    case 0:</a>
<a name="ln5963">      reg-&gt;y_type = kMTUnknown;</a>
<a name="ln5964">      break;</a>
<a name="ln5965">    case 'v': case 'c':</a>
<a name="ln5966">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln5967">      break;</a>
<a name="ln5968">    case 'V': case 'l':</a>
<a name="ln5969">      reg-&gt;y_type = kMTLineWise;</a>
<a name="ln5970">      break;</a>
<a name="ln5971">    case 'b': case Ctrl_V:</a>
<a name="ln5972">      reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln5973">      break;</a>
<a name="ln5974">    default:</a>
<a name="ln5975">      goto err;</a>
<a name="ln5976">    }</a>
<a name="ln5977">  } else {</a>
<a name="ln5978">    lines = res;</a>
<a name="ln5979">    // provider did not specify regtype, calculate it below</a>
<a name="ln5980">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln5981">  }</a>
<a name="ln5982"> </a>
<a name="ln5983">  reg-&gt;y_array = xcalloc((size_t)tv_list_len(lines), sizeof(char_u *));</a>
<a name="ln5984">  reg-&gt;y_size = (size_t)tv_list_len(lines);</a>
<a name="ln5985">  reg-&gt;additional_data = NULL;</a>
<a name="ln5986">  reg-&gt;timestamp = 0;</a>
<a name="ln5987">  // Timestamp is not saved for clipboard registers because clipboard registers</a>
<a name="ln5988">  // are not saved in the ShaDa file.</a>
<a name="ln5989"> </a>
<a name="ln5990">  size_t tv_idx = 0;</a>
<a name="ln5991">  TV_LIST_ITER_CONST(lines, li, {</a>
<a name="ln5992">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {</a>
<a name="ln5993">      goto err;</a>
<a name="ln5994">    }</a>
<a name="ln5995">    reg-&gt;y_array[tv_idx++] = (char_u *)xstrdupnul(</a>
<a name="ln5996">        (const char *)TV_LIST_ITEM_TV(li)-&gt;vval.v_string);</a>
<a name="ln5997">  });</a>
<a name="ln5998"> </a>
<a name="ln5999">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen((char*)reg-&gt;y_array[reg-&gt;y_size-1]) == 0) {</a>
<a name="ln6000">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6001">    // but otherwise there is no line after the final newline</a>
<a name="ln6002">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6003">      xfree(reg-&gt;y_array[reg-&gt;y_size-1]);</a>
<a name="ln6004">      reg-&gt;y_size--;</a>
<a name="ln6005">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6006">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6007">      }</a>
<a name="ln6008">    }</a>
<a name="ln6009">  } else {</a>
<a name="ln6010">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6011">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6012">    }</a>
<a name="ln6013">  }</a>
<a name="ln6014"> </a>
<a name="ln6015">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6016">    size_t maxlen = 0;</a>
<a name="ln6017">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6018">      size_t rowlen = STRLEN(reg-&gt;y_array[i]);</a>
<a name="ln6019">      if (rowlen &gt; maxlen) {</a>
<a name="ln6020">        maxlen = rowlen;</a>
<a name="ln6021">      }</a>
<a name="ln6022">    }</a>
<a name="ln6023">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6024">    reg-&gt;y_width = (int)maxlen - 1;</a>
<a name="ln6025">  }</a>
<a name="ln6026"> </a>
<a name="ln6027">  *target = reg;</a>
<a name="ln6028">  return true;</a>
<a name="ln6029"> </a>
<a name="ln6030">err:</a>
<a name="ln6031">  if (reg-&gt;y_array) {</a>
<a name="ln6032">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6033">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln6034">    }</a>
<a name="ln6035">    xfree(reg-&gt;y_array);</a>
<a name="ln6036">  }</a>
<a name="ln6037">  reg-&gt;y_array = NULL;</a>
<a name="ln6038">  reg-&gt;y_size = 0;</a>
<a name="ln6039">  reg-&gt;additional_data = NULL;</a>
<a name="ln6040">  reg-&gt;timestamp = 0;</a>
<a name="ln6041">  if (errmsg) {</a>
<a name="ln6042">    EMSG(&quot;clipboard: provider returned invalid data&quot;);</a>
<a name="ln6043">  }</a>
<a name="ln6044">  *target = reg;</a>
<a name="ln6045">  return false;</a>
<a name="ln6046">}</a>
<a name="ln6047"> </a>
<a name="ln6048">static void set_clipboard(int name, yankreg_T *reg)</a>
<a name="ln6049">{</a>
<a name="ln6050">  if (!adjust_clipboard_name(&amp;name, false, true)) {</a>
<a name="ln6051">    return;</a>
<a name="ln6052">  }</a>
<a name="ln6053"> </a>
<a name="ln6054">  list_T *const lines = tv_list_alloc(</a>
<a name="ln6055">      (ptrdiff_t)reg-&gt;y_size + (reg-&gt;y_type != kMTCharWise));</a>
<a name="ln6056"> </a>
<a name="ln6057">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6058">    tv_list_append_string(lines, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln6059">  }</a>
<a name="ln6060"> </a>
<a name="ln6061">  char regtype;</a>
<a name="ln6062">  switch (reg-&gt;y_type) {</a>
<a name="ln6063">    case kMTLineWise: {</a>
<a name="ln6064">      regtype = 'V';</a>
<a name="ln6065">      tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6066">      break;</a>
<a name="ln6067">    }</a>
<a name="ln6068">    case kMTCharWise: {</a>
<a name="ln6069">      regtype = 'v';</a>
<a name="ln6070">      break;</a>
<a name="ln6071">    }</a>
<a name="ln6072">    case kMTBlockWise: {</a>
<a name="ln6073">      regtype = 'b';</a>
<a name="ln6074">      tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6075">      break;</a>
<a name="ln6076">    }</a>
<a name="ln6077">    case kMTUnknown: {</a>
<a name="ln6078">      assert(false);</a>
<a name="ln6079">    }</a>
<a name="ln6080">  }</a>
<a name="ln6081"> </a>
<a name="ln6082">  list_T *args = tv_list_alloc(3);</a>
<a name="ln6083">  tv_list_append_list(args, lines);</a>
<a name="ln6084">  tv_list_append_string(args, &amp;regtype, 1);  // -V614</a>
<a name="ln6085">  tv_list_append_string(args, ((char[]) { (char)name }), 1);</a>
<a name="ln6086"> </a>
<a name="ln6087">  (void)eval_call_provider(&quot;clipboard&quot;, &quot;set&quot;, args, true);</a>
<a name="ln6088">}</a>
<a name="ln6089"> </a>
<a name="ln6090">/// Avoid slow things (clipboard) during batch operations (while/for-loops).</a>
<a name="ln6091">void start_batch_changes(void)</a>
<a name="ln6092">{</a>
<a name="ln6093">  if (++batch_change_count &gt; 1) {</a>
<a name="ln6094">    return;</a>
<a name="ln6095">  }</a>
<a name="ln6096">  clipboard_delay_update = true;</a>
<a name="ln6097">}</a>
<a name="ln6098"> </a>
<a name="ln6099">/// Counterpart to start_batch_changes().</a>
<a name="ln6100">void end_batch_changes(void)</a>
<a name="ln6101">{</a>
<a name="ln6102">  if (--batch_change_count &gt; 0) {</a>
<a name="ln6103">    // recursive</a>
<a name="ln6104">    return;</a>
<a name="ln6105">  }</a>
<a name="ln6106">  clipboard_delay_update = false;</a>
<a name="ln6107">  if (clipboard_needs_update) {</a>
<a name="ln6108">    // must be before, as set_clipboard will invoke</a>
<a name="ln6109">    // start/end_batch_changes recursively</a>
<a name="ln6110">    clipboard_needs_update = false;</a>
<a name="ln6111">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6112">    set_clipboard(NUL, y_previous);</a>
<a name="ln6113">  }</a>
<a name="ln6114">}</a>
<a name="ln6115"> </a>
<a name="ln6116">int save_batch_count(void)</a>
<a name="ln6117">{</a>
<a name="ln6118">  int save_count = batch_change_count;</a>
<a name="ln6119">  batch_change_count = 0;</a>
<a name="ln6120">  clipboard_delay_update = false;</a>
<a name="ln6121">  if (clipboard_needs_update) {</a>
<a name="ln6122">    clipboard_needs_update = false;</a>
<a name="ln6123">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6124">    set_clipboard(NUL, y_previous);</a>
<a name="ln6125">  }</a>
<a name="ln6126">  return save_count;</a>
<a name="ln6127">}</a>
<a name="ln6128"> </a>
<a name="ln6129">void restore_batch_count(int save_count)</a>
<a name="ln6130">{</a>
<a name="ln6131">  assert(batch_change_count == 0);</a>
<a name="ln6132">  batch_change_count = save_count;</a>
<a name="ln6133">  if (batch_change_count &gt; 0) {</a>
<a name="ln6134">    clipboard_delay_update = true;</a>
<a name="ln6135">  }</a>
<a name="ln6136">}</a>
<a name="ln6137"> </a>
<a name="ln6138"> </a>
<a name="ln6139">/// Check whether register is empty</a>
<a name="ln6140">static inline bool reg_empty(const yankreg_T *const reg)</a>
<a name="ln6141">  FUNC_ATTR_PURE</a>
<a name="ln6142">{</a>
<a name="ln6143">  return (reg-&gt;y_array == NULL</a>
<a name="ln6144">          || reg-&gt;y_size == 0</a>
<a name="ln6145">          || (reg-&gt;y_size == 1</a>
<a name="ln6146">              &amp;&amp; reg-&gt;y_type == kMTCharWise</a>
<a name="ln6147">              &amp;&amp; *(reg-&gt;y_array[0]) == NUL));</a>
<a name="ln6148">}</a>
<a name="ln6149"> </a>
<a name="ln6150">/// Iterate over global registers.</a>
<a name="ln6151">///</a>
<a name="ln6152">/// @see op_register_iter</a>
<a name="ln6153">const void *op_global_reg_iter(const void *const iter, char *const name,</a>
<a name="ln6154">                               yankreg_T *const reg, bool *is_unnamed)</a>
<a name="ln6155">  FUNC_ATTR_NONNULL_ARG(2, 3, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6156">{</a>
<a name="ln6157">  return op_reg_iter(iter, y_regs, name, reg, is_unnamed);</a>
<a name="ln6158">}</a>
<a name="ln6159"> </a>
<a name="ln6160">/// Iterate over registers `regs`.</a>
<a name="ln6161">///</a>
<a name="ln6162">/// @param[in]   iter      Iterator. Pass NULL to start iteration.</a>
<a name="ln6163">/// @param[in]   regs      Registers list to be iterated.</a>
<a name="ln6164">/// @param[out]  name      Register name.</a>
<a name="ln6165">/// @param[out]  reg       Register contents.</a>
<a name="ln6166">///</a>
<a name="ln6167">/// @return Pointer that must be passed to next `op_register_iter` call or</a>
<a name="ln6168">///         NULL if iteration is over.</a>
<a name="ln6169">const void *op_reg_iter(const void *const iter, const yankreg_T *const regs,</a>
<a name="ln6170">                        char *const name, yankreg_T *const reg,</a>
<a name="ln6171">                        bool *is_unnamed)</a>
<a name="ln6172">  FUNC_ATTR_NONNULL_ARG(3, 4, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6173">{</a>
<a name="ln6174">  *name = NUL;</a>
<a name="ln6175">  const yankreg_T *iter_reg = (iter == NULL</a>
<a name="ln6176">                               ? &amp;(regs[0])</a>
<a name="ln6177">                               : (const yankreg_T *const)iter);</a>
<a name="ln6178">  while (iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS &amp;&amp; reg_empty(iter_reg)) {</a>
<a name="ln6179">    iter_reg++;</a>
<a name="ln6180">  }</a>
<a name="ln6181">  if (iter_reg - &amp;(regs[0]) == NUM_SAVED_REGISTERS || reg_empty(iter_reg)) {</a>
<a name="ln6182">    return NULL;</a>
<a name="ln6183">  }</a>
<a name="ln6184">  int iter_off = (int)(iter_reg - &amp;(regs[0]));</a>
<a name="ln6185">  *name = (char)get_register_name(iter_off);</a>
<a name="ln6186">  *reg = *iter_reg;</a>
<a name="ln6187">  *is_unnamed = (iter_reg == y_previous);</a>
<a name="ln6188">  while (++iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS) {</a>
<a name="ln6189">    if (!reg_empty(iter_reg)) {</a>
<a name="ln6190">      return (void *) iter_reg;</a>
<a name="ln6191">    }</a>
<a name="ln6192">  }</a>
<a name="ln6193">  return NULL;</a>
<a name="ln6194">}</a>
<a name="ln6195"> </a>
<a name="ln6196">/// Get a number of non-empty registers</a>
<a name="ln6197">size_t op_reg_amount(void)</a>
<a name="ln6198">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6199">{</a>
<a name="ln6200">  size_t ret = 0;</a>
<a name="ln6201">  for (size_t i = 0; i &lt; NUM_SAVED_REGISTERS; i++) {</a>
<a name="ln6202">    if (!reg_empty(y_regs + i)) {</a>
<a name="ln6203">      ret++;</a>
<a name="ln6204">    }</a>
<a name="ln6205">  }</a>
<a name="ln6206">  return ret;</a>
<a name="ln6207">}</a>
<a name="ln6208"> </a>
<a name="ln6209">/// Set register to a given value</a>
<a name="ln6210">///</a>
<a name="ln6211">/// @param[in]  name  Register name.</a>
<a name="ln6212">/// @param[in]  reg  Register value.</a>
<a name="ln6213">/// @param[in]  is_unnamed  Whether to set the unnamed regiseter to reg</a>
<a name="ln6214">///</a>
<a name="ln6215">/// @return true on success, false on failure.</a>
<a name="ln6216">bool op_reg_set(const char name, const yankreg_T reg, bool is_unnamed)</a>
<a name="ln6217">{</a>
<a name="ln6218">  int i = op_reg_index(name);</a>
<a name="ln6219">  if (i == -1) {</a>
<a name="ln6220">    return false;</a>
<a name="ln6221">  }</a>
<a name="ln6222">  free_register(&amp;y_regs[i]);</a>
<a name="ln6223">  y_regs[i] = reg;</a>
<a name="ln6224"> </a>
<a name="ln6225">  if (is_unnamed) {</a>
<a name="ln6226">    y_previous = &amp;y_regs[i];</a>
<a name="ln6227">  }</a>
<a name="ln6228">  return true;</a>
<a name="ln6229">}</a>
<a name="ln6230"> </a>
<a name="ln6231">/// Get register with the given name</a>
<a name="ln6232">///</a>
<a name="ln6233">/// @param[in]  name  Register name.</a>
<a name="ln6234">///</a>
<a name="ln6235">/// @return Pointer to the register contents or NULL.</a>
<a name="ln6236">const yankreg_T *op_reg_get(const char name)</a>
<a name="ln6237">{</a>
<a name="ln6238">  int i = op_reg_index(name);</a>
<a name="ln6239">  if (i == -1) {</a>
<a name="ln6240">    return NULL;</a>
<a name="ln6241">  }</a>
<a name="ln6242">  return &amp;y_regs[i];</a>
<a name="ln6243">}</a>
<a name="ln6244"> </a>
<a name="ln6245">/// Set the previous yank register</a>
<a name="ln6246">///</a>
<a name="ln6247">/// @param[in]  name  Register name.</a>
<a name="ln6248">///</a>
<a name="ln6249">/// @return true on success, false on failure.</a>
<a name="ln6250">bool op_reg_set_previous(const char name)</a>
<a name="ln6251">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6252">{</a>
<a name="ln6253">  int i = op_reg_index(name);</a>
<a name="ln6254">  if (i == -1) {</a>
<a name="ln6255">    return false;</a>
<a name="ln6256">  }</a>
<a name="ln6257"> </a>
<a name="ln6258">  y_previous = &amp;y_regs[i];</a>
<a name="ln6259">  return true;</a>
<a name="ln6260">}</a>

</code></pre>
<div class="balloon" rel="2745"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4985"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4987"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4989"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4991"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

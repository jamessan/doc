
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>option.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User-settable options. Checklist for adding a new option:</a>
<a name="ln5">// - Put it in options.lua</a>
<a name="ln6">// - For a global option: Add a variable for it in option_defs.h.</a>
<a name="ln7">// - For a buffer or window local option:</a>
<a name="ln8">//   - Add a BV_XX or WV_XX entry to option_defs.h</a>
<a name="ln9">//   - Add a variable to the window or buffer struct in buffer_defs.h.</a>
<a name="ln10">//   - For a window option, add some code to copy_winopt().</a>
<a name="ln11">//   - For a window string option, add code to check_winopt()</a>
<a name="ln12">//     and clear_winopt(). If setting the option needs parsing,</a>
<a name="ln13">//     add some code to didset_window_options().</a>
<a name="ln14">//   - For a buffer option, add some code to buf_copy_options().</a>
<a name="ln15">//   - For a buffer string option, add code to check_buf_options().</a>
<a name="ln16">// - If it's a numeric option, add any necessary bounds checks to</a>
<a name="ln17">//   set_num_option().</a>
<a name="ln18">// - If it's a list of flags, add some code in do_set(), search for WW_ALL.</a>
<a name="ln19">// - When adding an option with expansion (P_EXPAND), but with a different</a>
<a name="ln20">//   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.</a>
<a name="ln21">// - Add documentation! doc/options.txt, and any other related places.</a>
<a name="ln22">// - Add an entry in runtime/optwin.vim.</a>
<a name="ln23"> </a>
<a name="ln24">#define IN_OPTION_C</a>
<a name="ln25">#include &lt;assert.h&gt;</a>
<a name="ln26">#include &lt;inttypes.h&gt;</a>
<a name="ln27">#include &lt;stdbool.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#include &lt;limits.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;nvim/vim.h&quot;</a>
<a name="ln33">#include &quot;nvim/macros.h&quot;</a>
<a name="ln34">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln35">#include &quot;nvim/edit.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln38">#include &quot;nvim/charset.h&quot;</a>
<a name="ln39">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln40">#include &quot;nvim/diff.h&quot;</a>
<a name="ln41">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln42">#include &quot;nvim/eval.h&quot;</a>
<a name="ln43">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln45">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln46">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln47">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln48">#include &quot;nvim/fold.h&quot;</a>
<a name="ln49">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln50">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln51">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln52">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln53">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln54">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln55">#include &quot;nvim/memline.h&quot;</a>
<a name="ln56">#include &quot;nvim/memory.h&quot;</a>
<a name="ln57">#include &quot;nvim/message.h&quot;</a>
<a name="ln58">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln59">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln60">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln61">#include &quot;nvim/garray.h&quot;</a>
<a name="ln62">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln63">#include &quot;nvim/move.h&quot;</a>
<a name="ln64">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln65">#include &quot;nvim/normal.h&quot;</a>
<a name="ln66">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln67">#include &quot;nvim/path.h&quot;</a>
<a name="ln68">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln69">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln70">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln71">#include &quot;nvim/screen.h&quot;</a>
<a name="ln72">#include &quot;nvim/spell.h&quot;</a>
<a name="ln73">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln74">#include &quot;nvim/strings.h&quot;</a>
<a name="ln75">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln76">#include &quot;nvim/ui.h&quot;</a>
<a name="ln77">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln78">#include &quot;nvim/undo.h&quot;</a>
<a name="ln79">#include &quot;nvim/window.h&quot;</a>
<a name="ln80">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln81">#ifdef WIN32</a>
<a name="ln82"># include &quot;nvim/os/pty_conpty_win.h&quot;</a>
<a name="ln83">#endif</a>
<a name="ln84">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln85">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln86">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln87">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89">/*</a>
<a name="ln90"> * The options that are local to a window or buffer have &quot;indir&quot; set to one of</a>
<a name="ln91"> * these values.  Special values:</a>
<a name="ln92"> * PV_NONE: global option.</a>
<a name="ln93"> * PV_WIN is added: window-local option</a>
<a name="ln94"> * PV_BUF is added: buffer-local option</a>
<a name="ln95"> * PV_BOTH is added: global option which also has a local value.</a>
<a name="ln96"> */</a>
<a name="ln97">#define PV_BOTH 0x1000</a>
<a name="ln98">#define PV_WIN  0x2000</a>
<a name="ln99">#define PV_BUF  0x4000</a>
<a name="ln100">#define PV_MASK 0x0fff</a>
<a name="ln101">#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))</a>
<a name="ln102">#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))</a>
<a name="ln103">#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">// WV_ and BV_ values get typecasted to this for the &quot;indir&quot; field</a>
<a name="ln107">typedef enum {</a>
<a name="ln108">  PV_NONE = 0,</a>
<a name="ln109">  PV_MAXVAL = 0xffff      // to avoid warnings for value out of range</a>
<a name="ln110">} idopt_T;</a>
<a name="ln111"> </a>
<a name="ln112">/*</a>
<a name="ln113"> * Options local to a window have a value local to a buffer and global to all</a>
<a name="ln114"> * buffers.  Indicate this by setting &quot;var&quot; to VAR_WIN.</a>
<a name="ln115"> */</a>
<a name="ln116">#define VAR_WIN ((char_u *)-1)</a>
<a name="ln117"> </a>
<a name="ln118">static char *p_term = NULL;</a>
<a name="ln119">static char *p_ttytype = NULL;</a>
<a name="ln120"> </a>
<a name="ln121">/*</a>
<a name="ln122"> * These are the global values for options which are also local to a buffer.</a>
<a name="ln123"> * Only to be used in option.c!</a>
<a name="ln124"> */</a>
<a name="ln125">static int p_ai;</a>
<a name="ln126">static int p_bin;</a>
<a name="ln127">static int p_bomb;</a>
<a name="ln128">static char_u   *p_bh;</a>
<a name="ln129">static char_u   *p_bt;</a>
<a name="ln130">static int p_bl;</a>
<a name="ln131">static long p_channel;</a>
<a name="ln132">static int p_ci;</a>
<a name="ln133">static int p_cin;</a>
<a name="ln134">static char_u   *p_cink;</a>
<a name="ln135">static char_u   *p_cino;</a>
<a name="ln136">static char_u   *p_cinw;</a>
<a name="ln137">static char_u   *p_com;</a>
<a name="ln138">static char_u   *p_cms;</a>
<a name="ln139">static char_u   *p_cpt;</a>
<a name="ln140">static char_u   *p_cfu;</a>
<a name="ln141">static char_u   *p_ofu;</a>
<a name="ln142">static char_u   *p_tfu;</a>
<a name="ln143">static int p_eol;</a>
<a name="ln144">static int p_fixeol;</a>
<a name="ln145">static int p_et;</a>
<a name="ln146">static char_u   *p_fenc;</a>
<a name="ln147">static char_u   *p_ff;</a>
<a name="ln148">static char_u   *p_fo;</a>
<a name="ln149">static char_u   *p_flp;</a>
<a name="ln150">static char_u   *p_ft;</a>
<a name="ln151">static long p_iminsert;</a>
<a name="ln152">static long p_imsearch;</a>
<a name="ln153">static char_u   *p_inex;</a>
<a name="ln154">static char_u   *p_inde;</a>
<a name="ln155">static char_u   *p_indk;</a>
<a name="ln156">static char_u   *p_fex;</a>
<a name="ln157">static int p_inf;</a>
<a name="ln158">static char_u   *p_isk;</a>
<a name="ln159">static int p_lisp;</a>
<a name="ln160">static int p_ml;</a>
<a name="ln161">static int p_ma;</a>
<a name="ln162">static int p_mod;</a>
<a name="ln163">static char_u   *p_mps;</a>
<a name="ln164">static char_u   *p_nf;</a>
<a name="ln165">static int p_pi;</a>
<a name="ln166">static char_u   *p_qe;</a>
<a name="ln167">static int p_ro;</a>
<a name="ln168">static int p_si;</a>
<a name="ln169">static long p_sts;</a>
<a name="ln170">static char_u   *p_sua;</a>
<a name="ln171">static long p_sw;</a>
<a name="ln172">static int p_swf;</a>
<a name="ln173">static long p_smc;</a>
<a name="ln174">static char_u   *p_syn;</a>
<a name="ln175">static char_u   *p_spc;</a>
<a name="ln176">static char_u   *p_spf;</a>
<a name="ln177">static char_u   *p_spl;</a>
<a name="ln178">static char_u   *p_spo;</a>
<a name="ln179">static long p_ts;</a>
<a name="ln180">static long p_tw;</a>
<a name="ln181">static int p_udf;</a>
<a name="ln182">static long p_wm;</a>
<a name="ln183">static char_u   *p_keymap;</a>
<a name="ln184"> </a>
<a name="ln185">// Saved values for when 'bin' is set.</a>
<a name="ln186">static int p_et_nobin;</a>
<a name="ln187">static int p_ml_nobin;</a>
<a name="ln188">static long p_tw_nobin;</a>
<a name="ln189">static long p_wm_nobin;</a>
<a name="ln190"> </a>
<a name="ln191">// Saved values for when 'paste' is set.</a>
<a name="ln192">static int p_ai_nopaste;</a>
<a name="ln193">static int p_et_nopaste;</a>
<a name="ln194">static long p_sts_nopaste;</a>
<a name="ln195">static long p_tw_nopaste;</a>
<a name="ln196">static long p_wm_nopaste;</a>
<a name="ln197"> </a>
<a name="ln198">typedef struct vimoption {</a>
<a name="ln199">  char        *fullname;        // full option name</a>
<a name="ln200">  char        *shortname;       // permissible abbreviation</a>
<a name="ln201">  uint32_t flags;               // see below</a>
<a name="ln202">  char_u      *var;             // global option: pointer to variable;</a>
<a name="ln203">                                // window-local option: VAR_WIN;</a>
<a name="ln204">                                // buffer-local option: global value</a>
<a name="ln205">  idopt_T indir;                // global option: PV_NONE;</a>
<a name="ln206">                                // local option: indirect option index</a>
<a name="ln207">  char_u      *def_val[2];      // default values for variable (vi and vim)</a>
<a name="ln208">  LastSet last_set;             // script in which the option was last set</a>
<a name="ln209">} vimoption_T;</a>
<a name="ln210"> </a>
<a name="ln211">#define VI_DEFAULT  0       // def_val[VI_DEFAULT] is Vi default value</a>
<a name="ln212">#define VIM_DEFAULT 1       // def_val[VIM_DEFAULT] is Vim default value</a>
<a name="ln213"> </a>
<a name="ln214">/*</a>
<a name="ln215"> * Flags</a>
<a name="ln216"> */</a>
<a name="ln217">#define P_BOOL          0x01U    // the option is boolean</a>
<a name="ln218">#define P_NUM           0x02U    // the option is numeric</a>
<a name="ln219">#define P_STRING        0x04U    // the option is a string</a>
<a name="ln220">#define P_ALLOCED       0x08U    // the string option is in allocated memory,</a>
<a name="ln221">                                 // must use free_string_option() when</a>
<a name="ln222">                                 // assigning new value. Not set if default is</a>
<a name="ln223">                                 // the same.</a>
<a name="ln224">#define P_EXPAND        0x10U    // environment expansion.  NOTE: P_EXPAND can</a>
<a name="ln225">                                 // never be used for local or hidden options</a>
<a name="ln226">#define P_NODEFAULT     0x40U    // don't set to default value</a>
<a name="ln227">#define P_DEF_ALLOCED   0x80U    // default value is in allocated memory, must</a>
<a name="ln228">                                 // use free() when assigning new value</a>
<a name="ln229">#define P_WAS_SET       0x100U   // option has been set/reset</a>
<a name="ln230">#define P_NO_MKRC       0x200U   // don't include in :mkvimrc output</a>
<a name="ln231">#define P_VI_DEF        0x400U   // Use Vi default for Vim</a>
<a name="ln232">#define P_VIM           0x800U   // Vim option</a>
<a name="ln233"> </a>
<a name="ln234">// when option changed, what to display:</a>
<a name="ln235">#define P_RSTAT         0x1000U  ///&lt; redraw status lines</a>
<a name="ln236">#define P_RWIN          0x2000U  ///&lt; redraw current window and recompute text</a>
<a name="ln237">#define P_RBUF          0x4000U  ///&lt; redraw current buffer and recompute text</a>
<a name="ln238">#define P_RALL          0x6000U  ///&lt; redraw all windows</a>
<a name="ln239">#define P_RCLR          0x7000U  ///&lt; clear and redraw all</a>
<a name="ln240"> </a>
<a name="ln241">#define P_COMMA         0x8000U    ///&lt; comma separated list</a>
<a name="ln242">#define P_ONECOMMA      0x18000U   ///&lt; P_COMMA and cannot have two consecutive</a>
<a name="ln243">                                   ///&lt; commas</a>
<a name="ln244">#define P_NODUP         0x20000U   ///&lt; don't allow duplicate strings</a>
<a name="ln245">#define P_FLAGLIST      0x40000U   ///&lt; list of single-char flags</a>
<a name="ln246"> </a>
<a name="ln247">#define P_SECURE        0x80000U   ///&lt; cannot change in modeline or secure mode</a>
<a name="ln248">#define P_GETTEXT       0x100000U  ///&lt; expand default value with _()</a>
<a name="ln249">#define P_NOGLOB        0x200000U  ///&lt; do not use local value for global vimrc</a>
<a name="ln250">#define P_NFNAME        0x400000U  ///&lt; only normal file name chars allowed</a>
<a name="ln251">#define P_INSECURE      0x800000U  ///&lt; option was set from a modeline</a>
<a name="ln252">#define P_PRI_MKRC     0x1000000U  ///&lt; priority for :mkvimrc (setting option</a>
<a name="ln253">                                   ///&lt; has side effects)</a>
<a name="ln254">#define P_NO_ML        0x2000000U  ///&lt; not allowed in modeline</a>
<a name="ln255">#define P_CURSWANT     0x4000000U  ///&lt; update curswant required; not needed</a>
<a name="ln256">                                   ///&lt; when there is a redraw flag</a>
<a name="ln257">#define P_NO_DEF_EXP   0x8000000U  ///&lt; Do not expand default value.</a>
<a name="ln258"> </a>
<a name="ln259">#define P_RWINONLY     0x10000000U  ///&lt; only redraw current window</a>
<a name="ln260">#define P_NDNAME       0x20000000U  ///&lt; only normal dir name chars allowed</a>
<a name="ln261">#define P_UI_OPTION    0x40000000U  ///&lt; send option to remote ui</a>
<a name="ln262">#define P_MLE          0x80000000U  ///&lt; under control of 'modelineexpr'</a>
<a name="ln263"> </a>
<a name="ln264">#define HIGHLIGHT_INIT \</a>
<a name="ln265">  &quot;8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,&quot; \</a>
<a name="ln266">  &quot;d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,&quot; \</a>
<a name="ln267">  &quot;N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,&quot; \</a>
<a name="ln268">  &quot;v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,&quot; \</a>
<a name="ln269">  &quot;A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,&gt;:SignColumn,-:Conceal,&quot; \</a>
<a name="ln270">  &quot;B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,&quot; \</a>
<a name="ln271">  &quot;x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,&quot; \</a>
<a name="ln272">  &quot;!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine,&quot; \</a>
<a name="ln273">  &quot;0:Whitespace,I:NormalNC&quot;</a>
<a name="ln274"> </a>
<a name="ln275">/*</a>
<a name="ln276"> * options[] is initialized here.</a>
<a name="ln277"> * The order of the options MUST be alphabetic for &quot;:set all&quot; and findoption().</a>
<a name="ln278"> * All option names MUST start with a lowercase letter (for findoption()).</a>
<a name="ln279"> * Exception: &quot;t_&quot; options are at the end.</a>
<a name="ln280"> * The options with a NULL variable are 'hidden': a set command for them is</a>
<a name="ln281"> * ignored and they are not printed.</a>
<a name="ln282"> */</a>
<a name="ln283"> </a>
<a name="ln284">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln285"># include &quot;options.generated.h&quot;</a>
<a name="ln286">#endif</a>
<a name="ln287"> </a>
<a name="ln288">#define PARAM_COUNT ARRAY_SIZE(options)</a>
<a name="ln289"> </a>
<a name="ln290">static char *(p_ambw_values[]) =      { &quot;single&quot;, &quot;double&quot;, NULL };</a>
<a name="ln291">static char *(p_bg_values[]) =        { &quot;light&quot;, &quot;dark&quot;, NULL };</a>
<a name="ln292">static char *(p_nf_values[]) =        { &quot;bin&quot;, &quot;octal&quot;, &quot;hex&quot;, &quot;alpha&quot;, NULL };</a>
<a name="ln293">static char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };</a>
<a name="ln294">static char *(p_wak_values[]) =       { &quot;yes&quot;, &quot;menu&quot;, &quot;no&quot;, NULL };</a>
<a name="ln295">static char *(p_mousem_values[]) =    { &quot;extend&quot;, &quot;popup&quot;, &quot;popup_setpos&quot;,</a>
<a name="ln296">                                        &quot;mac&quot;, NULL };</a>
<a name="ln297">static char *(p_sel_values[]) =       { &quot;inclusive&quot;, &quot;exclusive&quot;, &quot;old&quot;, NULL };</a>
<a name="ln298">static char *(p_slm_values[]) =       { &quot;mouse&quot;, &quot;key&quot;, &quot;cmd&quot;, NULL };</a>
<a name="ln299">static char *(p_km_values[]) =        { &quot;startsel&quot;, &quot;stopsel&quot;, NULL };</a>
<a name="ln300">static char *(p_scbopt_values[]) =    { &quot;ver&quot;, &quot;hor&quot;, &quot;jump&quot;, NULL };</a>
<a name="ln301">static char *(p_debug_values[]) =     { &quot;msg&quot;, &quot;throw&quot;, &quot;beep&quot;, NULL };</a>
<a name="ln302">static char *(p_ead_values[]) =       { &quot;both&quot;, &quot;ver&quot;, &quot;hor&quot;, NULL };</a>
<a name="ln303">static char *(p_buftype_values[]) =   { &quot;nofile&quot;, &quot;nowrite&quot;, &quot;quickfix&quot;,</a>
<a name="ln304">                                        &quot;help&quot;, &quot;acwrite&quot;, &quot;terminal&quot;,</a>
<a name="ln305">                                        &quot;prompt&quot;, NULL };</a>
<a name="ln306"> </a>
<a name="ln307">static char *(p_bufhidden_values[]) = { &quot;hide&quot;, &quot;unload&quot;, &quot;delete&quot;,</a>
<a name="ln308">                                        &quot;wipe&quot;, NULL };</a>
<a name="ln309">static char *(p_bs_values[]) = { &quot;indent&quot;, &quot;eol&quot;, &quot;start&quot;, &quot;nostop&quot;, NULL };</a>
<a name="ln310">static char *(p_fdm_values[]) =       { &quot;manual&quot;, &quot;expr&quot;, &quot;marker&quot;, &quot;indent&quot;,</a>
<a name="ln311">                                        &quot;syntax&quot;,  &quot;diff&quot;, NULL };</a>
<a name="ln312">static char *(p_fcl_values[]) =       { &quot;all&quot;, NULL };</a>
<a name="ln313">static char *(p_cot_values[]) =       { &quot;menu&quot;, &quot;menuone&quot;, &quot;longest&quot;, &quot;preview&quot;,</a>
<a name="ln314">                                        &quot;noinsert&quot;, &quot;noselect&quot;, NULL };</a>
<a name="ln315">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln316">static char *(p_csl_values[]) =       { &quot;slash&quot;, &quot;backslash&quot;, NULL };</a>
<a name="ln317">#endif</a>
<a name="ln318">static char *(p_icm_values[]) =       { &quot;nosplit&quot;, &quot;split&quot;, NULL };</a>
<a name="ln319">static char *(p_scl_values[]) =       { &quot;yes&quot;, &quot;no&quot;, &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln320">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln321">  &quot;yes:1&quot;, &quot;yes:2&quot;, &quot;yes:3&quot;, &quot;yes:4&quot;, &quot;yes:5&quot;, &quot;yes:6&quot;, &quot;yes:7&quot;, &quot;yes:8&quot;,</a>
<a name="ln322">  &quot;yes:9&quot;, &quot;number&quot;, NULL };</a>
<a name="ln323">static char *(p_fdc_values[]) =       { &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln324">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln325">  &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, NULL };</a>
<a name="ln326"> </a>
<a name="ln327">/// All possible flags for 'shm'.</a>
<a name="ln328">static char_u SHM_ALL[] = {</a>
<a name="ln329">  SHM_RO, SHM_MOD, SHM_FILE, SHM_LAST, SHM_TEXT, SHM_LINES, SHM_NEW, SHM_WRI,</a>
<a name="ln330">  SHM_ABBREVIATIONS, SHM_WRITE, SHM_TRUNC, SHM_TRUNCALL, SHM_OVER,</a>
<a name="ln331">  SHM_OVERALL, SHM_SEARCH, SHM_ATTENTION, SHM_INTRO, SHM_COMPLETIONMENU,</a>
<a name="ln332">  SHM_RECORDING, SHM_FILEINFO, SHM_SEARCHCOUNT,</a>
<a name="ln333">  0,</a>
<a name="ln334">};</a>
<a name="ln335"> </a>
<a name="ln336">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln337"># include &quot;option.c.generated.h&quot;</a>
<a name="ln338">#endif</a>
<a name="ln339"> </a>
<a name="ln340">/// Initialize the options, first part.</a>
<a name="ln341">///</a>
<a name="ln342">/// Called only once from main(), just after creating the first buffer.</a>
<a name="ln343">/// If &quot;clean_arg&quot; is true, Nvim was started with --clean.</a>
<a name="ln344">///</a>
<a name="ln345">/// NOTE: ELOG() etc calls are not allowed here, as log location depends on</a>
<a name="ln346">/// env var expansion which depends on expression evaluation and other</a>
<a name="ln347">/// editor state initialized here. Do logging in set_init_2 or later.</a>
<a name="ln348">void set_init_1(bool clean_arg)</a>
<a name="ln349">{</a>
<a name="ln350">  int opt_idx;</a>
<a name="ln351"> </a>
<a name="ln352">  langmap_init();</a>
<a name="ln353"> </a>
<a name="ln354">  /*</a>
<a name="ln355">   * Find default value for 'shell' option.</a>
<a name="ln356">   * Don't use it if it is empty.</a>
<a name="ln357">   */</a>
<a name="ln358">  {</a>
<a name="ln359">    const char *shell = os_getenv(&quot;SHELL&quot;);</a>
<a name="ln360">    if (shell != NULL) {</a>
<a name="ln361">      if (vim_strchr((const char_u *)shell, ' ') != NULL) {</a>
<a name="ln362">        const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL</a>
<a name="ln363">        char *const cmd = xmalloc(len);</a>
<a name="ln364">        snprintf(cmd, len, &quot;\&quot;%s\&quot;&quot;, shell);</a>
<a name="ln365">        set_string_default(&quot;sh&quot;, cmd, true);</a>
<a name="ln366">      } else {</a>
<a name="ln367">        set_string_default(&quot;sh&quot;, (char *)shell, false);</a>
<a name="ln368">      }</a>
<a name="ln369">    }</a>
<a name="ln370">  }</a>
<a name="ln371"> </a>
<a name="ln372">  /*</a>
<a name="ln373">   * Set the default for 'backupskip' to include environment variables for</a>
<a name="ln374">   * temp files.</a>
<a name="ln375">   */</a>
<a name="ln376">  {</a>
<a name="ln377"># ifdef UNIX</a>
<a name="ln378">    static char     *(names[4]) = {&quot;&quot;, &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln379"># else</a>
<a name="ln380">    static char     *(names[3]) = {&quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln381"># endif</a>
<a name="ln382">    int len;</a>
<a name="ln383">    garray_T ga;</a>
<a name="ln384"> </a>
<a name="ln385">    ga_init(&amp;ga, 1, 100);</a>
<a name="ln386">    for (size_t n = 0; n &lt; ARRAY_SIZE(names); n++) {</a>
<a name="ln387">      bool mustfree = true;</a>
<a name="ln388">      char *p;</a>
<a name="ln389"># ifdef UNIX</a>
<a name="ln390">      if (*names[n] == NUL) {</a>
<a name="ln391">#  ifdef __APPLE__</a>
<a name="ln392">        p = &quot;/private/tmp&quot;;</a>
<a name="ln393">#  else</a>
<a name="ln394">        p = &quot;/tmp&quot;;</a>
<a name="ln395">#  endif</a>
<a name="ln396">        mustfree = false;</a>
<a name="ln397">      } else</a>
<a name="ln398"># endif</a>
<a name="ln399">      {</a>
<a name="ln400">        p = vim_getenv(names[n]);</a>
<a name="ln401">      }</a>
<a name="ln402">      if (p != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln403">        // First time count the NUL, otherwise count the ','.</a>
<a name="ln404">        len = (int)strlen(p) + 3;</a>
<a name="ln405">        ga_grow(&amp;ga, len);</a>
<a name="ln406">        if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln407">          STRCAT(ga.ga_data, &quot;,&quot;);</a>
<a name="ln408">        }</a>
<a name="ln409">        STRCAT(ga.ga_data, p);</a>
<a name="ln410">        add_pathsep(ga.ga_data);</a>
<a name="ln411">        STRCAT(ga.ga_data, &quot;*&quot;);</a>
<a name="ln412">        ga.ga_len += len;</a>
<a name="ln413">      }</a>
<a name="ln414">      if(mustfree) {</a>
<a name="ln415">        xfree(p);</a>
<a name="ln416">      }</a>
<a name="ln417">    }</a>
<a name="ln418">    if (ga.ga_data != NULL) {</a>
<a name="ln419">      set_string_default(&quot;bsk&quot;, ga.ga_data, true);</a>
<a name="ln420">    }</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  {</a>
<a name="ln424">    char_u  *cdpath;</a>
<a name="ln425">    char_u  *buf;</a>
<a name="ln426">    int i;</a>
<a name="ln427">    int j;</a>
<a name="ln428"> </a>
<a name="ln429">    // Initialize the 'cdpath' option's default value.</a>
<a name="ln430">    cdpath = (char_u *)vim_getenv(&quot;CDPATH&quot;);</a>
<a name="ln431">    if (cdpath != NULL) {</a>
<a name="ln432">      buf = xmalloc(2 * STRLEN(cdpath) + 2);</a>
<a name="ln433">      {</a>
<a name="ln434">        buf[0] = ',';               // start with &quot;,&quot;, current dir first</a>
<a name="ln435">        j = 1;</a>
<a name="ln436">        for (i = 0; cdpath[i] != NUL; i++) {</a>
<a name="ln437">          if (vim_ispathlistsep(cdpath[i])) {</a>
<a name="ln438">            buf[j++] = ',';</a>
<a name="ln439">          } else {</a>
<a name="ln440">            if (cdpath[i] == ' ' || cdpath[i] == ',') {</a>
<a name="ln441">              buf[j++] = '\\';</a>
<a name="ln442">            }</a>
<a name="ln443">            buf[j++] = cdpath[i];</a>
<a name="ln444">          }</a>
<a name="ln445">        }</a>
<a name="ln446">        buf[j] = NUL;</a>
<a name="ln447">        opt_idx = findoption(&quot;cdpath&quot;);</a>
<a name="ln448">        if (opt_idx &gt;= 0) {</a>
<a name="ln449">          options[opt_idx].def_val[VI_DEFAULT] = buf;</a>
<a name="ln450">          options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln451">        } else {</a>
<a name="ln452">          xfree(buf);           // cannot happen</a>
<a name="ln453">        }</a>
<a name="ln454">      }</a>
<a name="ln455">      xfree(cdpath);</a>
<a name="ln456">    }</a>
<a name="ln457">  }</a>
<a name="ln458"> </a>
<a name="ln459">#if defined(MSWIN) || defined(MAC)</a>
<a name="ln460">  // Set print encoding on platforms that don't default to latin1</a>
<a name="ln461">  set_string_default(&quot;printencoding&quot;, &quot;hp-roman8&quot;, false);</a>
<a name="ln462">#endif</a>
<a name="ln463"> </a>
<a name="ln464">  // 'printexpr' must be allocated to be able to evaluate it.</a>
<a name="ln465">  set_string_default(&quot;printexpr&quot;,</a>
<a name="ln466">#ifdef UNIX</a>
<a name="ln467">                     &quot;system(['lpr'] &quot;</a>
<a name="ln468">                            &quot;+ (empty(&amp;printdevice)?[]:['-P', &amp;printdevice]) &quot;</a>
<a name="ln469">                            &quot;+ [v:fname_in])&quot;</a>
<a name="ln470">                     &quot;. delete(v:fname_in)&quot;</a>
<a name="ln471">                     &quot;+ v:shell_error&quot;,</a>
<a name="ln472">#elif defined(MSWIN)</a>
<a name="ln473">                     &quot;system(['copy', v:fname_in, &quot;</a>
<a name="ln474">                             &quot;empty(&amp;printdevice)?'LPT1':&amp;printdevice])&quot;</a>
<a name="ln475">                     &quot;. delete(v:fname_in)&quot;,</a>
<a name="ln476">#else</a>
<a name="ln477">                     &quot;&quot;,</a>
<a name="ln478">#endif</a>
<a name="ln479">                     false);</a>
<a name="ln480"> </a>
<a name="ln481">  char *backupdir = stdpaths_user_data_subpath(&quot;backup&quot;, 0, true);</a>
<a name="ln482">  const size_t backupdir_len = strlen(backupdir);</a>
<a name="ln483">  backupdir = xrealloc(backupdir, backupdir_len + 3);</a>
<a name="ln484">  memmove(backupdir + 2, backupdir, backupdir_len + 1);</a>
<a name="ln485">  memmove(backupdir, &quot;.,&quot;, 2);</a>
<a name="ln486">  set_string_default(&quot;viewdir&quot;, stdpaths_user_data_subpath(&quot;view&quot;, 0, true),</a>
<a name="ln487">                     true);</a>
<a name="ln488">  set_string_default(&quot;backupdir&quot;, backupdir, true);</a>
<a name="ln489">  set_string_default(&quot;directory&quot;, stdpaths_user_data_subpath(&quot;swap&quot;, 2, true),</a>
<a name="ln490">                     true);</a>
<a name="ln491">  set_string_default(&quot;undodir&quot;, stdpaths_user_data_subpath(&quot;undo&quot;, 0, true),</a>
<a name="ln492">                     true);</a>
<a name="ln493">  // Set default for &amp;runtimepath. All necessary expansions are performed in</a>
<a name="ln494">  // this function.</a>
<a name="ln495">  char *rtp = runtimepath_default(clean_arg);</a>
<a name="ln496">  if (rtp) {</a>
<a name="ln497">    set_string_default(&quot;runtimepath&quot;, rtp, true);</a>
<a name="ln498">    // Make a copy of 'rtp' for 'packpath'</a>
<a name="ln499">    set_string_default(&quot;packpath&quot;, rtp, false);</a>
<a name="ln500">    rtp = NULL;  // ownership taken</a>
<a name="ln501">  }</a>
<a name="ln502"> </a>
<a name="ln503">  /*</a>
<a name="ln504">   * Set all the options (except the terminal options) to their default</a>
<a name="ln505">   * value.  Also set the global value for local options.</a>
<a name="ln506">   */</a>
<a name="ln507">  set_options_default(0);</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">  curbuf-&gt;b_p_initialized = true;</a>
<a name="ln511">  curbuf-&gt;b_p_ar = -1;          // no local 'autoread' value</a>
<a name="ln512">  curbuf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln513">  check_buf_options(curbuf);</a>
<a name="ln514">  check_win_options(curwin);</a>
<a name="ln515">  check_options();</a>
<a name="ln516"> </a>
<a name="ln517">  // Set all options to their Vim default</a>
<a name="ln518">  set_options_default(OPT_FREE);</a>
<a name="ln519"> </a>
<a name="ln520">  // set 'laststatus'</a>
<a name="ln521">  last_status(false);</a>
<a name="ln522"> </a>
<a name="ln523">  // Must be before option_expand(), because that one needs vim_isIDc()</a>
<a name="ln524">  didset_options();</a>
<a name="ln525"> </a>
<a name="ln526">  // Use the current chartab for the generic chartab. This is not in</a>
<a name="ln527">  // didset_options() because it only depends on 'encoding'.</a>
<a name="ln528">  init_spell_chartab();</a>
<a name="ln529"> </a>
<a name="ln530">  /*</a>
<a name="ln531">   * Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln532">   * If option_expand() returns non-NULL the variable is expanded.  This can</a>
<a name="ln533">   * only happen for non-indirect options.</a>
<a name="ln534">   * Also set the default to the expanded value, so &quot;:set&quot; does not list</a>
<a name="ln535">   * them.</a>
<a name="ln536">   * Don't set the P_ALLOCED flag, because we don't want to free the</a>
<a name="ln537">   * default.</a>
<a name="ln538">   */</a>
<a name="ln539">  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln540">    if (options[opt_idx].flags &amp; P_NO_DEF_EXP) {</a>
<a name="ln541">      continue;</a>
<a name="ln542">    }</a>
<a name="ln543">    char *p;</a>
<a name="ln544">    if ((options[opt_idx].flags &amp; P_GETTEXT)</a>
<a name="ln545">        &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln546">      p = _(*(char **)options[opt_idx].var);</a>
<a name="ln547">    } else {</a>
<a name="ln548">      p = (char *) option_expand(opt_idx, NULL);</a>
<a name="ln549">    }</a>
<a name="ln550">    if (p != NULL) {</a>
<a name="ln551">      p = xstrdup(p);</a>
<a name="ln552">      *(char **)options[opt_idx].var = p;</a>
<a name="ln553">      /* VIMEXP</a>
<a name="ln554">       * Defaults for all expanded options are currently the same for Vi</a>
<a name="ln555">       * and Vim.  When this changes, add some code here!  Also need to</a>
<a name="ln556">       * split P_DEF_ALLOCED in two.</a>
<a name="ln557">       */</a>
<a name="ln558">      if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln559">        xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln560">      }</a>
<a name="ln561">      options[opt_idx].def_val[VI_DEFAULT] = (char_u *)p;</a>
<a name="ln562">      options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln563">    }</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  save_file_ff(curbuf);         // Buffer is unchanged</a>
<a name="ln567"> </a>
<a name="ln568">  /* Detect use of mlterm.</a>
<a name="ln569">   * Mlterm is a terminal emulator akin to xterm that has some special</a>
<a name="ln570">   * abilities (bidi namely).</a>
<a name="ln571">   * NOTE: mlterm's author is being asked to 'set' a variable</a>
<a name="ln572">   *       instead of an environment variable due to inheritance.</a>
<a name="ln573">   */</a>
<a name="ln574">  if (os_env_exists(&quot;MLTERM&quot;)) {</a>
<a name="ln575">    set_option_value(&quot;tbidi&quot;, 1L, NULL, 0);</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  didset_options2();</a>
<a name="ln579"> </a>
<a name="ln580">  lang_init();</a>
<a name="ln581"> </a>
<a name="ln582">  // enc_locale() will try to find the encoding of the current locale.</a>
<a name="ln583">  // This will be used when 'default' is used as encoding specifier</a>
<a name="ln584">  // in 'fileencodings'</a>
<a name="ln585">  char_u *p = enc_locale();</a>
<a name="ln586">  if (p == NULL) {</a>
<a name="ln587">      // use utf-8 as 'default' if locale encoding can't be detected.</a>
<a name="ln588">      p = (char_u *)xmemdupz(S_LEN(&quot;utf-8&quot;));</a>
<a name="ln589">  }</a>
<a name="ln590">  fenc_default = p;</a>
<a name="ln591"> </a>
<a name="ln592">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln593">  // GNU gettext 0.10.37 supports this feature: set the codeset used for</a>
<a name="ln594">  // translated messages independently from the current locale.</a>
<a name="ln595">  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);</a>
<a name="ln596">#endif</a>
<a name="ln597"> </a>
<a name="ln598">  // Set the default for 'helplang'.</a>
<a name="ln599">  set_helplang_default(get_mess_lang());</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">/// Set an option to its default value.</a>
<a name="ln603">/// This does not take care of side effects!</a>
<a name="ln604">static void</a>
<a name="ln605">set_option_default(</a>
<a name="ln606">    int opt_idx,</a>
<a name="ln607">    int opt_flags,              // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln608">    int compatible              // use Vi default value</a>
<a name="ln609">)</a>
<a name="ln610">{</a>
<a name="ln611">  char_u      *varp;            // pointer to variable for current option</a>
<a name="ln612">  int dvi;                      // index in def_val[]</a>
<a name="ln613">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln614"> </a>
<a name="ln615">  varp = get_varp_scope(&amp;(options[opt_idx]), both ? OPT_LOCAL : opt_flags);</a>
<a name="ln616">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln617">  if (varp != NULL) {       // skip hidden option, nothing to do for it</a>
<a name="ln618">    dvi = ((flags &amp; P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln619">    if (flags &amp; P_STRING) {</a>
<a name="ln620">      /* Use set_string_option_direct() for local options to handle</a>
<a name="ln621">       * freeing and allocating the value. */</a>
<a name="ln622">      if (options[opt_idx].indir != PV_NONE) {</a>
<a name="ln623">        set_string_option_direct(NULL, opt_idx,</a>
<a name="ln624">                                 options[opt_idx].def_val[dvi], opt_flags, 0);</a>
<a name="ln625">      } else {</a>
<a name="ln626">        if ((opt_flags &amp; OPT_FREE) &amp;&amp; (flags &amp; P_ALLOCED)) {</a>
<a name="ln627">          free_string_option(*(char_u **)(varp));</a>
<a name="ln628">        }</a>
<a name="ln629">        *(char_u **)varp = options[opt_idx].def_val[dvi];</a>
<a name="ln630">        options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln631">      }</a>
<a name="ln632">    } else if (flags &amp; P_NUM)   {</a>
<a name="ln633">      if (options[opt_idx].indir == PV_SCROLL) {</a>
<a name="ln634">        win_comp_scroll(curwin);</a>
<a name="ln635">      } else {</a>
<a name="ln636">        long def_val = (long)options[opt_idx].def_val[dvi];</a>
<a name="ln637">        if ((long *)varp == &amp;curwin-&gt;w_p_so</a>
<a name="ln638">            || (long *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln639">          // 'scrolloff' and 'sidescrolloff' local values have a</a>
<a name="ln640">          // different default value than the global default.</a>
<a name="ln641">          *(long *)varp = -1;</a>
<a name="ln642">        } else {</a>
<a name="ln643">          *(long *)varp = def_val;</a>
<a name="ln644">        }</a>
<a name="ln645">        // May also set global value for local option.</a>
<a name="ln646">        if (both) {</a>
<a name="ln647">          *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln648">            def_val;</a>
<a name="ln649">        }</a>
<a name="ln650">      }</a>
<a name="ln651">    } else {  // P_BOOL</a>
<a name="ln652">      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val[dvi];</a>
<a name="ln653">#ifdef UNIX</a>
<a name="ln654">      // 'modeline' defaults to off for root</a>
<a name="ln655">      if (options[opt_idx].indir == PV_ML &amp;&amp; getuid() == ROOT_UID) {</a>
<a name="ln656">        *(int *)varp = false;</a>
<a name="ln657">      }</a>
<a name="ln658">#endif</a>
<a name="ln659">      // May also set global value for local option.</a>
<a name="ln660">      if (both) {</a>
<a name="ln661">        *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln662">          *(int *)varp;</a>
<a name="ln663">      }</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    // The default value is not insecure.</a>
<a name="ln667">    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln668">    *flagsp = *flagsp &amp; ~P_INSECURE;</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/// Set all options (except terminal options) to their default value.</a>
<a name="ln675">static void</a>
<a name="ln676">set_options_default(</a>
<a name="ln677">    int opt_flags               // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln678">)</a>
<a name="ln679">{</a>
<a name="ln680">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln681">    if (!(options[i].flags &amp; P_NODEFAULT)) {</a>
<a name="ln682">      set_option_default(i, opt_flags, false);</a>
<a name="ln683">    }</a>
<a name="ln684">  }</a>
<a name="ln685"> </a>
<a name="ln686">  // The 'scroll' option must be computed for all windows.</a>
<a name="ln687">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln688">    win_comp_scroll(wp);</a>
<a name="ln689">  }</a>
<a name="ln690"> </a>
<a name="ln691">  parse_cino(curbuf);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">/// Set the Vi-default value of a string option.</a>
<a name="ln695">/// Used for 'sh', 'backupskip' and 'term'.</a>
<a name="ln696">///</a>
<a name="ln697">/// @param name The name of the option</a>
<a name="ln698">/// @param val The value of the option</a>
<a name="ln699">/// @param allocated If true, do not copy default as it was already allocated.</a>
<a name="ln700">static void set_string_default(const char *name, char *val, bool allocated)</a>
<a name="ln701">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln702">{</a>
<a name="ln703">  int opt_idx = findoption(name);</a>
<a name="ln704">  if (opt_idx &gt;= 0) {</a>
<a name="ln705">    if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln706">      xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln707">    }</a>
<a name="ln708"> </a>
<a name="ln709">    options[opt_idx].def_val[VI_DEFAULT] = allocated</a>
<a name="ln710">        ? (char_u *)val</a>
<a name="ln711">        : (char_u *)xstrdup(val);</a>
<a name="ln712">    options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln713">  }</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">/// Set the Vi-default value of a number option.</a>
<a name="ln717">/// Used for 'lines' and 'columns'.</a>
<a name="ln718">void set_number_default(char *name, long val)</a>
<a name="ln719">{</a>
<a name="ln720">  int opt_idx;</a>
<a name="ln721"> </a>
<a name="ln722">  opt_idx = findoption(name);</a>
<a name="ln723">  if (opt_idx &gt;= 0) {</a>
<a name="ln724">    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)(intptr_t)val;</a>
<a name="ln725">  }</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">#if defined(EXITFREE)</a>
<a name="ln729">/// Free all options.</a>
<a name="ln730">void free_all_options(void)</a>
<a name="ln731">{</a>
<a name="ln732">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln733">    if (options[i].indir == PV_NONE) {</a>
<a name="ln734">      // global option: free value and default value.</a>
<a name="ln735">      if ((options[i].flags &amp; P_ALLOCED) &amp;&amp; options[i].var != NULL) {</a>
<a name="ln736">        free_string_option(*(char_u **)options[i].var);</a>
<a name="ln737">      }</a>
<a name="ln738">      if (options[i].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln739">        free_string_option(options[i].def_val[VI_DEFAULT]);</a>
<a name="ln740">      }</a>
<a name="ln741">    } else if (options[i].var != VAR_WIN &amp;&amp; (options[i].flags &amp; P_STRING)) {</a>
<a name="ln742">      // buffer-local option: free global value</a>
<a name="ln743">      free_string_option(*(char_u **)options[i].var);</a>
<a name="ln744">    }</a>
<a name="ln745">  }</a>
<a name="ln746">}</a>
<a name="ln747">#endif</a>
<a name="ln748"> </a>
<a name="ln749"> </a>
<a name="ln750">/// Initialize the options, part two: After getting Rows and Columns.</a>
<a name="ln751">void set_init_2(bool headless)</a>
<a name="ln752">{</a>
<a name="ln753">  // set in set_init_1 but logging is not allowed there</a>
<a name="ln754">  ILOG(&quot;startup runtimepath/packpath value: %s&quot;, p_rtp);</a>
<a name="ln755"> </a>
<a name="ln756">  int idx;</a>
<a name="ln757"> </a>
<a name="ln758">  // 'scroll' defaults to half the window height. The stored default is zero,</a>
<a name="ln759">  // which results in the actual value computed from the window height.</a>
<a name="ln760">  idx = findoption(&quot;scroll&quot;);</a>
<a name="ln761">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln762">    set_option_default(idx, OPT_LOCAL, false);</a>
<a name="ln763">  }</a>
<a name="ln764">  comp_col();</a>
<a name="ln765"> </a>
<a name="ln766">  /*</a>
<a name="ln767">   * 'window' is only for backwards compatibility with Vi.</a>
<a name="ln768">   * Default is Rows - 1.</a>
<a name="ln769">   */</a>
<a name="ln770">  if (!option_was_set(&quot;window&quot;)) {</a>
<a name="ln771">    p_window = Rows - 1;</a>
<a name="ln772">  }</a>
<a name="ln773">  set_number_default(&quot;window&quot;, Rows - 1);</a>
<a name="ln774">  (void)parse_printoptions();      // parse 'printoptions' default value</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/// Initialize the options, part three: After reading the .vimrc</a>
<a name="ln778">void set_init_3(void)</a>
<a name="ln779">{</a>
<a name="ln780">  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'</a>
<a name="ln781"> </a>
<a name="ln782">  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.</a>
<a name="ln783">  // This is done after other initializations, where 'shell' might have been</a>
<a name="ln784">  // set, but only if they have not been set before.</a>
<a name="ln785">  int idx_srr = findoption(&quot;srr&quot;);</a>
<a name="ln786">  int do_srr = (idx_srr &lt; 0)</a>
<a name="ln787">    ? false</a>
<a name="ln788">    : !(options[idx_srr].flags &amp; P_WAS_SET);</a>
<a name="ln789">  int idx_sp = findoption(&quot;sp&quot;);</a>
<a name="ln790">  int do_sp = (idx_sp &lt; 0)</a>
<a name="ln791">    ? false</a>
<a name="ln792">    : !(options[idx_sp].flags &amp; P_WAS_SET);</a>
<a name="ln793"> </a>
<a name="ln794">  size_t len = 0;</a>
<a name="ln795">  char_u *p = (char_u *)invocation_path_tail(p_sh, &amp;len);</a>
<a name="ln796">  p = vim_strnsave(p, len);</a>
<a name="ln797"> </a>
<a name="ln798">  {</a>
<a name="ln799">    //</a>
<a name="ln800">    // Default for p_sp is &quot;| tee&quot;, for p_srr is &quot;&gt;&quot;.</a>
<a name="ln801">    // For known shells it is changed here to include stderr.</a>
<a name="ln802">    //</a>
<a name="ln803">    if (       fnamecmp(p, &quot;csh&quot;) == 0</a>
<a name="ln804">               || fnamecmp(p, &quot;tcsh&quot;) == 0</a>
<a name="ln805">               ) {</a>
<a name="ln806">      if (do_sp) {</a>
<a name="ln807">        p_sp = (char_u *)&quot;|&amp; tee&quot;;</a>
<a name="ln808">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln809">      }</a>
<a name="ln810">      if (do_srr) {</a>
<a name="ln811">        p_srr = (char_u *)&quot;&gt;&amp;&quot;;</a>
<a name="ln812">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln813">      }</a>
<a name="ln814">    } else if (       fnamecmp(p, &quot;sh&quot;) == 0</a>
<a name="ln815">                      || fnamecmp(p, &quot;ksh&quot;) == 0</a>
<a name="ln816">                      || fnamecmp(p, &quot;mksh&quot;) == 0</a>
<a name="ln817">                      || fnamecmp(p, &quot;pdksh&quot;) == 0</a>
<a name="ln818">                      || fnamecmp(p, &quot;zsh&quot;) == 0</a>
<a name="ln819">                      || fnamecmp(p, &quot;zsh-beta&quot;) == 0</a>
<a name="ln820">                      || fnamecmp(p, &quot;bash&quot;) == 0</a>
<a name="ln821">                      || fnamecmp(p, &quot;fish&quot;) == 0</a>
<a name="ln822">                      ) {</a>
<a name="ln823">      if (do_sp) {</a>
<a name="ln824">        p_sp = (char_u *)&quot;2&gt;&amp;1| tee&quot;;</a>
<a name="ln825">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln826">      }</a>
<a name="ln827">      if (do_srr) {</a>
<a name="ln828">        p_srr = (char_u *)&quot;&gt;%s 2&gt;&amp;1&quot;;</a>
<a name="ln829">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln830">      }</a>
<a name="ln831">    }</a>
<a name="ln832">    xfree(p);</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  if (BUFEMPTY()) {</a>
<a name="ln836">    int idx_ffs = findoption_len(S_LEN(&quot;ffs&quot;));</a>
<a name="ln837"> </a>
<a name="ln838">    // Apply the first entry of 'fileformats' to the initial buffer.</a>
<a name="ln839">    if (idx_ffs &gt;= 0 &amp;&amp; (options[idx_ffs].flags &amp; P_WAS_SET)) {</a>
<a name="ln840">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln841">    }</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  set_title_defaults();  // 'title', 'icon'</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">/// When 'helplang' is still at its default value, set it to &quot;lang&quot;.</a>
<a name="ln848">/// Only the first two characters of &quot;lang&quot; are used.</a>
<a name="ln849">void set_helplang_default(const char *lang)</a>
<a name="ln850">{</a>
<a name="ln851">  if (lang == NULL) {</a>
<a name="ln852">    return;</a>
<a name="ln853">  }</a>
<a name="ln854"> </a>
<a name="ln855">  const size_t lang_len = strlen(lang);</a>
<a name="ln856">  if (lang_len &lt; 2) {  // safety check</a>
<a name="ln857">    return;</a>
<a name="ln858">  }</a>
<a name="ln859">  int idx = findoption(&quot;hlg&quot;);</a>
<a name="ln860">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln861">    if (options[idx].flags &amp; P_ALLOCED) {</a>
<a name="ln862">      free_string_option(p_hlg);</a>
<a name="ln863">    }</a>
<a name="ln864">    p_hlg = (char_u *)xmemdupz(lang, lang_len);</a>
<a name="ln865">    // zh_CN becomes &quot;cn&quot;, zh_TW becomes &quot;tw&quot;.</a>
<a name="ln866">    if (STRNICMP(p_hlg, &quot;zh_&quot;, 3) == 0 &amp;&amp; STRLEN(p_hlg) &gt;= 5) {</a>
<a name="ln867">      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);</a>
<a name="ln868">      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);</a>
<a name="ln869">    } else if (STRLEN(p_hlg) &gt;= 1 &amp;&amp; *p_hlg == 'C') {</a>
<a name="ln870">      // any C like setting, such as C.UTF-8, becomes &quot;en&quot;</a>
<a name="ln871">      p_hlg[0] = 'e';</a>
<a name="ln872">      p_hlg[1] = 'n';</a>
<a name="ln873">    }</a>
<a name="ln874">    p_hlg[2] = NUL;</a>
<a name="ln875">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln876">  }</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879"> </a>
<a name="ln880">/// 'title' and 'icon' only default to true if they have not been set or reset</a>
<a name="ln881">/// in .vimrc and we can read the old value.</a>
<a name="ln882">/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if</a>
<a name="ln883">/// they can be reset.  This reduces startup time when using X on a remote</a>
<a name="ln884">/// machine.</a>
<a name="ln885">void set_title_defaults(void)</a>
<a name="ln886">{</a>
<a name="ln887">  int idx1;</a>
<a name="ln888"> </a>
<a name="ln889">  /*</a>
<a name="ln890">   * If GUI is (going to be) used, we can always set the window title and</a>
<a name="ln891">   * icon name.  Saves a bit of time, because the X11 display server does</a>
<a name="ln892">   * not need to be contacted.</a>
<a name="ln893">   */</a>
<a name="ln894">  idx1 = findoption(&quot;title&quot;);</a>
<a name="ln895">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln896">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln897">    p_title = 0;</a>
<a name="ln898">  }</a>
<a name="ln899">  idx1 = findoption(&quot;icon&quot;);</a>
<a name="ln900">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln901">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln902">    p_icon = 0;</a>
<a name="ln903">  }</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">// Parse 'arg' for option settings.</a>
<a name="ln907">//</a>
<a name="ln908">// 'arg' may be IObuff, but only when no errors can be present and option</a>
<a name="ln909">// does not need to be expanded with option_expand().</a>
<a name="ln910">// &quot;opt_flags&quot;:</a>
<a name="ln911">// 0 for &quot;:set&quot;</a>
<a name="ln912">// OPT_GLOBAL   for &quot;:setglobal&quot;</a>
<a name="ln913">// OPT_LOCAL    for &quot;:setlocal&quot; and a modeline</a>
<a name="ln914">// OPT_MODELINE for a modeline</a>
<a name="ln915">// OPT_WINONLY  to only set window-local options</a>
<a name="ln916">// OPT_NOWIN    to skip setting window-local options</a>
<a name="ln917">//</a>
<a name="ln918">// returns FAIL if an error is detected, OK otherwise</a>
<a name="ln919">int do_set(</a>
<a name="ln920">    char_u *arg,               // option string (may be written to!)</a>
<a name="ln921">    int opt_flags</a>
<a name="ln922">)</a>
<a name="ln923">{</a>
<a name="ln924">  int opt_idx;</a>
<a name="ln925">  char_u      *errmsg;</a>
<a name="ln926">  char_u errbuf[80];</a>
<a name="ln927">  char_u      *startarg;</a>
<a name="ln928">  int prefix;           // 1: nothing, 0: &quot;no&quot;, 2: &quot;inv&quot; in front of name</a>
<a name="ln929">  char_u nextchar;                  // next non-white char after option name</a>
<a name="ln930">  int afterchar;                    // character just after option name</a>
<a name="ln931">  int len;</a>
<a name="ln932">  int i;</a>
<a name="ln933">  varnumber_T value;</a>
<a name="ln934">  int key;</a>
<a name="ln935">  uint32_t flags;                   // flags for current option</a>
<a name="ln936">  char_u      *varp = NULL;         // pointer to variable for current option</a>
<a name="ln937">  int did_show = false;             // already showed one value</a>
<a name="ln938">  int adding;                       // &quot;opt+=arg&quot;</a>
<a name="ln939">  int prepending;                   // &quot;opt^=arg&quot;</a>
<a name="ln940">  int removing;                     // &quot;opt-=arg&quot;</a>
<a name="ln941">  int cp_val = 0;</a>
<a name="ln942"> </a>
<a name="ln943">  if (*arg == NUL) {</a>
<a name="ln944">    showoptions(0, opt_flags);</a>
<a name="ln945">    did_show = true;</a>
<a name="ln946">    goto theend;</a>
<a name="ln947">  }</a>
<a name="ln948"> </a>
<a name="ln949">  while (*arg != NUL) {         // loop to process all options</a>
<a name="ln950">    errmsg = NULL;</a>
<a name="ln951">    startarg = arg;             // remember for error message</a>
<a name="ln952"> </a>
<a name="ln953">    if (STRNCMP(arg, &quot;all&quot;, 3) == 0 &amp;&amp; !isalpha(arg[3])</a>
<a name="ln954">        &amp;&amp; !(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln955">      /*</a>
<a name="ln956">       * &quot;:set all&quot;  show all options.</a>
<a name="ln957">       * &quot;:set all&amp;&quot; set all options to their default value.</a>
<a name="ln958">       */</a>
<a name="ln959">      arg += 3;</a>
<a name="ln960">      if (*arg == '&amp;') {</a>
<a name="ln961">        arg++;</a>
<a name="ln962">        // Only for :set command set global value of local options.</a>
<a name="ln963">        set_options_default(OPT_FREE | opt_flags);</a>
<a name="ln964">        didset_options();</a>
<a name="ln965">        didset_options2();</a>
<a name="ln966">        ui_refresh_options();</a>
<a name="ln967">        redraw_all_later(CLEAR);</a>
<a name="ln968">      } else {</a>
<a name="ln969">        showoptions(1, opt_flags);</a>
<a name="ln970">        did_show = true;</a>
<a name="ln971">      }</a>
<a name="ln972">    } else {</a>
<a name="ln973">      prefix = 1;</a>
<a name="ln974">      if (STRNCMP(arg, &quot;no&quot;, 2) == 0) {</a>
<a name="ln975">        prefix = 0;</a>
<a name="ln976">        arg += 2;</a>
<a name="ln977">      } else if (STRNCMP(arg, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln978">        prefix = 2;</a>
<a name="ln979">        arg += 3;</a>
<a name="ln980">      }</a>
<a name="ln981"> </a>
<a name="ln982">      // find end of name</a>
<a name="ln983">      key = 0;</a>
<a name="ln984">      if (*arg == '&lt;') {</a>
<a name="ln985">        opt_idx = -1;</a>
<a name="ln986">        // look out for &lt;t_&gt;;&gt;</a>
<a name="ln987">        if (arg[1] == 't' &amp;&amp; arg[2] == '_' &amp;&amp; arg[3] &amp;&amp; arg[4]) {</a>
<a name="ln988">          len = 5;</a>
<a name="ln989">        } else {</a>
<a name="ln990">          len = 1;</a>
<a name="ln991">          while (arg[len] != NUL &amp;&amp; arg[len] != '&gt;') {</a>
<a name="ln992">            len++;</a>
<a name="ln993">          }</a>
<a name="ln994">        }</a>
<a name="ln995">        if (arg[len] != '&gt;') {</a>
<a name="ln996">          errmsg = e_invarg;</a>
<a name="ln997">          goto skip;</a>
<a name="ln998">        }</a>
<a name="ln999">        if (arg[1] == 't' &amp;&amp; arg[2] == '_') {  // could be term code</a>
<a name="ln1000">          opt_idx = findoption_len((const char *)arg + 1, (size_t)(len - 1));</a>
<a name="ln1001">        }</a>
<a name="ln1002">        len++;</a>
<a name="ln1003">        if (opt_idx == -1) {</a>
<a name="ln1004">          key = find_key_option(arg + 1, true);</a>
<a name="ln1005">        }</a>
<a name="ln1006">      } else {</a>
<a name="ln1007">        len = 0;</a>
<a name="ln1008">        // The two characters after &quot;t_&quot; may not be alphanumeric.</a>
<a name="ln1009">        if (arg[0] == 't' &amp;&amp; arg[1] == '_' &amp;&amp; arg[2] &amp;&amp; arg[3]) {</a>
<a name="ln1010">          len = 4;</a>
<a name="ln1011">        } else {</a>
<a name="ln1012">          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {</a>
<a name="ln1013">            len++;</a>
<a name="ln1014">          }</a>
<a name="ln1015">        }</a>
<a name="ln1016">        opt_idx = findoption_len((const char *)arg, (size_t)len);</a>
<a name="ln1017">        if (opt_idx == -1) {</a>
<a name="ln1018">          key = find_key_option(arg, false);</a>
<a name="ln1019">        }</a>
<a name="ln1020">      }</a>
<a name="ln1021"> </a>
<a name="ln1022">      // remember character after option name</a>
<a name="ln1023">      afterchar = arg[len];</a>
<a name="ln1024"> </a>
<a name="ln1025">      // skip white space, allow &quot;:set ai  ?&quot;</a>
<a name="ln1026">      while (ascii_iswhite(arg[len])) {</a>
<a name="ln1027">        len++;</a>
<a name="ln1028">      }</a>
<a name="ln1029"> </a>
<a name="ln1030">      adding = false;</a>
<a name="ln1031">      prepending = false;</a>
<a name="ln1032">      removing = false;</a>
<a name="ln1033">      if (arg[len] != NUL &amp;&amp; arg[len + 1] == '=') {</a>
<a name="ln1034">        if (arg[len] == '+') {</a>
<a name="ln1035">          adding = true;                        // &quot;+=&quot;</a>
<a name="ln1036">          len++;</a>
<a name="ln1037">        } else if (arg[len] == '^') {</a>
<a name="ln1038">          prepending = true;                    // &quot;^=&quot;</a>
<a name="ln1039">          len++;</a>
<a name="ln1040">        } else if (arg[len] == '-') {</a>
<a name="ln1041">          removing = true;                      // &quot;-=&quot;</a>
<a name="ln1042">          len++;</a>
<a name="ln1043">        }</a>
<a name="ln1044">      }</a>
<a name="ln1045">      nextchar = arg[len];</a>
<a name="ln1046"> </a>
<a name="ln1047">      if (opt_idx == -1 &amp;&amp; key == 0) {          // found a mismatch: skip</a>
<a name="ln1048">        errmsg = (char_u *)N_(&quot;E518: Unknown option&quot;);</a>
<a name="ln1049">        goto skip;</a>
<a name="ln1050">      }</a>
<a name="ln1051"> </a>
<a name="ln1052">      if (opt_idx &gt;= 0) {</a>
<a name="ln1053">        if (options[opt_idx].var == NULL) {         // hidden option: skip</a>
<a name="ln1054">          // Only give an error message when requesting the value of</a>
<a name="ln1055">          // a hidden option, ignore setting it.</a>
<a name="ln1056">          if (vim_strchr((char_u *)&quot;=:!&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1057">              &amp;&amp; (!(options[opt_idx].flags &amp; P_BOOL)</a>
<a name="ln1058">                  || nextchar == '?')) {</a>
<a name="ln1059">            errmsg = (char_u *)_(e_unsupportedoption);</a>
<a name="ln1060">          }</a>
<a name="ln1061">          goto skip;</a>
<a name="ln1062">        }</a>
<a name="ln1063"> </a>
<a name="ln1064">        flags = options[opt_idx].flags;</a>
<a name="ln1065">        varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln1066">      } else {</a>
<a name="ln1067">        flags = P_STRING;</a>
<a name="ln1068">      }</a>
<a name="ln1069"> </a>
<a name="ln1070">      /* Skip all options that are not window-local (used when showing</a>
<a name="ln1071">       * an already loaded buffer in a window). */</a>
<a name="ln1072">      if ((opt_flags &amp; OPT_WINONLY)</a>
<a name="ln1073">          &amp;&amp; (opt_idx &lt; 0 || options[opt_idx].var != VAR_WIN))</a>
<a name="ln1074">        goto skip;</a>
<a name="ln1075"> </a>
<a name="ln1076">      // Skip all options that are window-local (used for :vimgrep).</a>
<a name="ln1077">      if ((opt_flags &amp; OPT_NOWIN) &amp;&amp; opt_idx &gt;= 0</a>
<a name="ln1078">          &amp;&amp; options[opt_idx].var == VAR_WIN) {</a>
<a name="ln1079">        goto skip;</a>
<a name="ln1080">      }</a>
<a name="ln1081"> </a>
<a name="ln1082">      // Disallow changing some options from modelines.</a>
<a name="ln1083">      if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln1084">        if (flags &amp; (P_SECURE | P_NO_ML)) {</a>
<a name="ln1085">          errmsg = (char_u *)N_(&quot;E520: Not allowed in a modeline&quot;);</a>
<a name="ln1086">          goto skip;</a>
<a name="ln1087">        }</a>
<a name="ln1088">        if ((flags &amp; P_MLE) &amp;&amp; !p_mle) {</a>
<a name="ln1089">          errmsg = (char_u *)N_(</a>
<a name="ln1090">              &quot;E992: Not allowed in a modeline when 'modelineexpr' is off&quot;);</a>
<a name="ln1091">          goto skip;</a>
<a name="ln1092">        }</a>
<a name="ln1093">        // In diff mode some options are overruled.  This avoids that</a>
<a name="ln1094">        // 'foldmethod' becomes &quot;marker&quot; instead of &quot;diff&quot; and that</a>
<a name="ln1095">        // &quot;wrap&quot; gets set.</a>
<a name="ln1096">        if (curwin-&gt;w_p_diff</a>
<a name="ln1097">            &amp;&amp; opt_idx &gt;= 0              // shut up coverity warning</a>
<a name="ln1098">            &amp;&amp; (options[opt_idx].indir == PV_FDM</a>
<a name="ln1099">                || options[opt_idx].indir == PV_WRAP)) {</a>
<a name="ln1100">          goto skip;</a>
<a name="ln1101">        }</a>
<a name="ln1102">      }</a>
<a name="ln1103"> </a>
<a name="ln1104">      // Disallow changing some options in the sandbox</a>
<a name="ln1105">      if (sandbox != 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln1106">        errmsg = e_sandbox;</a>
<a name="ln1107">        goto skip;</a>
<a name="ln1108">      }</a>
<a name="ln1109"> </a>
<a name="ln1110">      if (vim_strchr((char_u *)&quot;?=:!&amp;&lt;&quot;, nextchar) != NULL) {</a>
<a name="ln1111">        arg += len;</a>
<a name="ln1112">        cp_val = false;</a>
<a name="ln1113">        if (nextchar == '&amp;' &amp;&amp; arg[1] == 'v' &amp;&amp; arg[2] == 'i') {</a>
<a name="ln1114">          if (arg[3] == 'm') {          // &quot;opt&amp;vim&quot;: set to Vim default</a>
<a name="ln1115">            cp_val = false;</a>
<a name="ln1116">            arg += 3;</a>
<a name="ln1117">          } else {                    // &quot;opt&amp;vi&quot;: set to Vi default</a>
<a name="ln1118">            cp_val = true;</a>
<a name="ln1119">            arg += 2;</a>
<a name="ln1120">          }</a>
<a name="ln1121">        }</a>
<a name="ln1122">        if (vim_strchr((char_u *)&quot;?!&amp;&lt;&quot;, nextchar) != NULL</a>
<a name="ln1123">            &amp;&amp; arg[1] != NUL &amp;&amp; !ascii_iswhite(arg[1])) {</a>
<a name="ln1124">          errmsg = e_trailing;</a>
<a name="ln1125">          goto skip;</a>
<a name="ln1126">        }</a>
<a name="ln1127">      }</a>
<a name="ln1128"> </a>
<a name="ln1129">      /*</a>
<a name="ln1130">       * allow '=' and ':' as MSDOS command.com allows only one</a>
<a name="ln1131">       * '=' character per &quot;set&quot; command line. grrr. (jw)</a>
<a name="ln1132">       */</a>
<a name="ln1133">      if (nextchar == '?'</a>
<a name="ln1134">          || (prefix == 1</a>
<a name="ln1135">              &amp;&amp; vim_strchr((char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1136">              &amp;&amp; !(flags &amp; P_BOOL))) {</a>
<a name="ln1137">        /*</a>
<a name="ln1138">         * print value</a>
<a name="ln1139">         */</a>
<a name="ln1140">        if (did_show) {</a>
<a name="ln1141">          msg_putchar('\n');                // cursor below last one</a>
<a name="ln1142">        } else {</a>
<a name="ln1143">          gotocmdline(true);                // cursor at status line</a>
<a name="ln1144">          did_show = true;                  // remember that we did a line</a>
<a name="ln1145">        }</a>
<a name="ln1146">        if (opt_idx &gt;= 0) {</a>
<a name="ln1147">          showoneopt(&amp;options[opt_idx], opt_flags);</a>
<a name="ln1148">          if (p_verbose &gt; 0) {</a>
<a name="ln1149">            // Mention where the option was last set.</a>
<a name="ln1150">            if (varp == options[opt_idx].var) {</a>
<a name="ln1151">              option_last_set_msg(options[opt_idx].last_set);</a>
<a name="ln1152">            } else if ((int)options[opt_idx].indir &amp; PV_WIN) {</a>
<a name="ln1153">              option_last_set_msg(curwin-&gt;w_p_script_ctx[</a>
<a name="ln1154">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1155">            } else if ((int)options[opt_idx].indir &amp; PV_BUF) {</a>
<a name="ln1156">              option_last_set_msg(curbuf-&gt;b_p_script_ctx[</a>
<a name="ln1157">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1158">            }</a>
<a name="ln1159">          }</a>
<a name="ln1160">        } else {</a>
<a name="ln1161">          errmsg = (char_u *)N_(&quot;E846: Key code not set&quot;);</a>
<a name="ln1162">          goto skip;</a>
<a name="ln1163">        }</a>
<a name="ln1164">        if (nextchar != '?'</a>
<a name="ln1165">            &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar))</a>
<a name="ln1166">          errmsg = e_trailing;</a>
<a name="ln1167">      } else {</a>
<a name="ln1168">        int value_is_replaced = !prepending &amp;&amp; !adding &amp;&amp; !removing;</a>
<a name="ln1169">        int value_checked = false;</a>
<a name="ln1170"> </a>
<a name="ln1171">        if (flags &amp; P_BOOL) {                       // boolean</a>
<a name="ln1172">          if (nextchar == '=' || nextchar == ':') {</a>
<a name="ln1173">            errmsg = e_invarg;</a>
<a name="ln1174">            goto skip;</a>
<a name="ln1175">          }</a>
<a name="ln1176"> </a>
<a name="ln1177">          /*</a>
<a name="ln1178">           * &quot;:set opt!&quot;: invert</a>
<a name="ln1179">           * &quot;:set opt&amp;&quot;: reset to default value</a>
<a name="ln1180">           * &quot;:set opt&lt;&quot;: reset to global value</a>
<a name="ln1181">           */</a>
<a name="ln1182">          if (nextchar == '!') {</a>
<a name="ln1183">            value = *(int *)(varp) ^ 1;</a>
<a name="ln1184">          } else if (nextchar == '&amp;') {</a>
<a name="ln1185">            value = (int)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1186">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1187">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1188">          } else if (nextchar == '&lt;') {</a>
<a name="ln1189">            // For 'autoread' -1 means to use global value.</a>
<a name="ln1190">            if ((int *)varp == &amp;curbuf-&gt;b_p_ar</a>
<a name="ln1191">                &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1192">              value = -1;</a>
<a name="ln1193">            } else {</a>
<a name="ln1194">              value = *(int *)get_varp_scope(&amp;(options[opt_idx]),</a>
<a name="ln1195">                                             OPT_GLOBAL);</a>
<a name="ln1196">            }</a>
<a name="ln1197">          } else {</a>
<a name="ln1198">            /*</a>
<a name="ln1199">             * &quot;:set invopt&quot;: invert</a>
<a name="ln1200">             * &quot;:set opt&quot; or &quot;:set noopt&quot;: set or reset</a>
<a name="ln1201">             */</a>
<a name="ln1202">            if (nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1203">              errmsg = e_trailing;</a>
<a name="ln1204">              goto skip;</a>
<a name="ln1205">            }</a>
<a name="ln1206">            if (prefix == 2) {                  // inv</a>
<a name="ln1207">              value = *(int *)(varp) ^ 1;</a>
<a name="ln1208">            } else {</a>
<a name="ln1209">              value = prefix;</a>
<a name="ln1210">            }</a>
<a name="ln1211">          }</a>
<a name="ln1212"> </a>
<a name="ln1213">          errmsg = (char_u *)set_bool_option(opt_idx, varp, (int)value,</a>
<a name="ln1214">                                             opt_flags);</a>
<a name="ln1215">        } else {  // Numeric or string.</a>
<a name="ln1216">          if (vim_strchr((const char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1217">              || prefix != 1) {</a>
<a name="ln1218">            errmsg = e_invarg;</a>
<a name="ln1219">            goto skip;</a>
<a name="ln1220">          }</a>
<a name="ln1221"> </a>
<a name="ln1222">          if (flags &amp; P_NUM) {                      // numeric</a>
<a name="ln1223">            // Different ways to set a number option:</a>
<a name="ln1224">            // &amp;            set to default value</a>
<a name="ln1225">            // &lt;            set to global value</a>
<a name="ln1226">            // &lt;xx&gt;         accept special key codes for 'wildchar'</a>
<a name="ln1227">            // c            accept any non-digit for 'wildchar'</a>
<a name="ln1228">            // [-]0-9       set number</a>
<a name="ln1229">            // other        error</a>
<a name="ln1230">            arg++;</a>
<a name="ln1231">            if (nextchar == '&amp;') {</a>
<a name="ln1232">              value = (long)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1233">                  ((flags &amp; P_VI_DEF) || cp_val) ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1234">            } else if (nextchar == '&lt;') {</a>
<a name="ln1235">              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to</a>
<a name="ln1236">              // use the global value.</a>
<a name="ln1237">              if ((long *)varp == &amp;curbuf-&gt;b_p_ul &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1238">                value = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln1239">              } else {</a>
<a name="ln1240">                value = *(long *)get_varp_scope(</a>
<a name="ln1241">                    &amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln1242">              }</a>
<a name="ln1243">            } else if (((long *)varp == &amp;p_wc</a>
<a name="ln1244">                        || (long *)varp == &amp;p_wcm)</a>
<a name="ln1245">                       &amp;&amp; (*arg == '&lt;'</a>
<a name="ln1246">                           || *arg == '^'</a>
<a name="ln1247">                           || (*arg != NUL &amp;&amp; (!arg[1] || ascii_iswhite(arg[1]))</a>
<a name="ln1248">                               &amp;&amp; !ascii_isdigit(*arg)))) {</a>
<a name="ln1249">              value = string_to_key(arg);</a>
<a name="ln1250">              if (value == 0 &amp;&amp; (long *)varp != &amp;p_wcm) {</a>
<a name="ln1251">                errmsg = e_invarg;</a>
<a name="ln1252">                goto skip;</a>
<a name="ln1253">              }</a>
<a name="ln1254">            } else if (*arg == '-' || ascii_isdigit(*arg)) {</a>
<a name="ln1255">              // Allow negative, octal and hex numbers.</a>
<a name="ln1256">              vim_str2nr(arg, NULL, &amp;i, STR2NR_ALL, &amp;value, NULL, 0);</a>
<a name="ln1257">              if (arg[i] != NUL &amp;&amp; !ascii_iswhite(arg[i])) {</a>
<a name="ln1258">                errmsg = e_invarg;</a>
<a name="ln1259">                goto skip;</a>
<a name="ln1260">              }</a>
<a name="ln1261">            } else {</a>
<a name="ln1262">              errmsg = (char_u *)N_(&quot;E521: Number required after =&quot;);</a>
<a name="ln1263">              goto skip;</a>
<a name="ln1264">            }</a>
<a name="ln1265"> </a>
<a name="ln1266">            if (adding) {</a>
<a name="ln1267">              value = *(long *)varp + value;</a>
<a name="ln1268">            }</a>
<a name="ln1269">            if (prepending) {</a>
<a name="ln1270">              value = *(long *)varp * value;</a>
<a name="ln1271">            }</a>
<a name="ln1272">            if (removing) {</a>
<a name="ln1273">              value = *(long *)varp - value;</a>
<a name="ln1274">            }</a>
<a name="ln1275">            errmsg = (char_u *)set_num_option(opt_idx, varp, (long)value,</a>
<a name="ln1276">                                              errbuf, sizeof(errbuf),</a>
<a name="ln1277">                                              opt_flags);</a>
<a name="ln1278">          } else if (opt_idx &gt;= 0) {  // String.</a>
<a name="ln1279">            char_u      *save_arg = NULL;</a>
<a name="ln1280">            char_u      *s = NULL;</a>
<a name="ln1281">            char_u      *oldval = NULL;         // previous value if *varp</a>
<a name="ln1282">            char_u      *newval;</a>
<a name="ln1283">            char_u      *origval = NULL;</a>
<a name="ln1284">            char *saved_origval = NULL;</a>
<a name="ln1285">            char *saved_newval = NULL;</a>
<a name="ln1286">            unsigned newlen;</a>
<a name="ln1287">            int comma;</a>
<a name="ln1288">            int bs;</a>
<a name="ln1289">            int new_value_alloced;                      /* new string option</a>
<a name="ln1290">                                                           was allocated */</a>
<a name="ln1291"> </a>
<a name="ln1292">            /* When using &quot;:set opt=val&quot; for a global option</a>
<a name="ln1293">             * with a local value the local value will be</a>
<a name="ln1294">             * reset, use the global value here. */</a>
<a name="ln1295">            if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln1296">                &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH))</a>
<a name="ln1297">              varp = options[opt_idx].var;</a>
<a name="ln1298"> </a>
<a name="ln1299">            /* The old value is kept until we are sure that the</a>
<a name="ln1300">             * new value is valid. */</a>
<a name="ln1301">            oldval = *(char_u **)varp;</a>
<a name="ln1302"> </a>
<a name="ln1303">            // When setting the local value of a global</a>
<a name="ln1304">            // option, the old value may be the global value.</a>
<a name="ln1305">            if (((int)options[opt_idx].indir &amp; PV_BOTH) &amp;&amp; (opt_flags</a>
<a name="ln1306">                                                            &amp; OPT_LOCAL)) {</a>
<a name="ln1307">              origval = *(char_u **)get_varp(&amp;options[opt_idx]);</a>
<a name="ln1308">            } else {</a>
<a name="ln1309">              origval = oldval;</a>
<a name="ln1310">            }</a>
<a name="ln1311"> </a>
<a name="ln1312">            if (nextchar == '&amp;') {              // set to default val</a>
<a name="ln1313">              newval = options[opt_idx].def_val[</a>
<a name="ln1314">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1315">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1316">              /* expand environment variables and ~ (since the</a>
<a name="ln1317">               * default value was already expanded, only</a>
<a name="ln1318">               * required when an environment variable was set</a>
<a name="ln1319">               * later */</a>
<a name="ln1320">              new_value_alloced = true;</a>
<a name="ln1321">              if (newval == NULL) {</a>
<a name="ln1322">                newval = empty_option;</a>
<a name="ln1323">              } else if (!(options[opt_idx].flags &amp; P_NO_DEF_EXP)) {</a>
<a name="ln1324">                s = option_expand(opt_idx, newval);</a>
<a name="ln1325">                if (s == NULL) {</a>
<a name="ln1326">                  s = newval;</a>
<a name="ln1327">                }</a>
<a name="ln1328">                newval = vim_strsave(s);</a>
<a name="ln1329">              } else {</a>
<a name="ln1330">                newval = (char_u *)xstrdup((char *)newval);</a>
<a name="ln1331">              }</a>
<a name="ln1332">            } else if (nextchar == '&lt;') {  // set to global val</a>
<a name="ln1333">              newval = vim_strsave(*(char_u **)get_varp_scope(</a>
<a name="ln1334">                  &amp;(options[opt_idx]), OPT_GLOBAL));</a>
<a name="ln1335">              new_value_alloced = true;</a>
<a name="ln1336">            } else {</a>
<a name="ln1337">              arg++;                    // jump to after the '=' or ':'</a>
<a name="ln1338"> </a>
<a name="ln1339">              /*</a>
<a name="ln1340">               * Set 'keywordprg' to &quot;:help&quot; if an empty</a>
<a name="ln1341">               * value was passed to :set by the user.</a>
<a name="ln1342">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1343">               */</a>
<a name="ln1344">              if (varp == (char_u *)&amp;p_kp</a>
<a name="ln1345">                  &amp;&amp; (*arg == NUL || *arg == ' ')) {</a>
<a name="ln1346">                STRCPY(errbuf, &quot;:help&quot;);</a>
<a name="ln1347">                save_arg = arg;</a>
<a name="ln1348">                arg = errbuf;</a>
<a name="ln1349">              }</a>
<a name="ln1350">              /*</a>
<a name="ln1351">               * Convert 'backspace' number to string, for</a>
<a name="ln1352">               * adding, prepending and removing string.</a>
<a name="ln1353">               */</a>
<a name="ln1354">              else if (varp == (char_u *)&amp;p_bs</a>
<a name="ln1355">                       &amp;&amp; ascii_isdigit(**(char_u **)varp)) {</a>
<a name="ln1356">                i = getdigits_int((char_u **)varp, true, 0);</a>
<a name="ln1357">                switch (i) {</a>
<a name="ln1358">                case 0:</a>
<a name="ln1359">                  *(char_u **)varp = empty_option;</a>
<a name="ln1360">                  break;</a>
<a name="ln1361">                case 1:</a>
<a name="ln1362">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1363">                      (char_u *)&quot;indent,eol&quot;);</a>
<a name="ln1364">                  break;</a>
<a name="ln1365">                case 2:</a>
<a name="ln1366">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1367">                      (char_u *)&quot;indent,eol,start&quot;);</a>
<a name="ln1368">                  break;</a>
<a name="ln1369">                case 3:</a>
<a name="ln1370">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1371">                      (char_u *)&quot;indent,eol,nostop&quot;);</a>
<a name="ln1372">                  break;</a>
<a name="ln1373">                }</a>
<a name="ln1374">                xfree(oldval);</a>
<a name="ln1375">                if (origval == oldval) {</a>
<a name="ln1376">                  origval = *(char_u **)varp;</a>
<a name="ln1377">                }</a>
<a name="ln1378">                oldval = *(char_u **)varp;</a>
<a name="ln1379">              }</a>
<a name="ln1380">              /*</a>
<a name="ln1381">               * Convert 'whichwrap' number to string, for</a>
<a name="ln1382">               * backwards compatibility with Vim 3.0.</a>
<a name="ln1383">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1384">               */</a>
<a name="ln1385">              else if (varp == (char_u *)&amp;p_ww</a>
<a name="ln1386">                       &amp;&amp; ascii_isdigit(*arg)) {</a>
<a name="ln1387">                *errbuf = NUL;</a>
<a name="ln1388">                i = getdigits_int(&amp;arg, true, 0);</a>
<a name="ln1389">                if (i &amp; 1) {</a>
<a name="ln1390">                  STRCAT(errbuf, &quot;b,&quot;);</a>
<a name="ln1391">                }</a>
<a name="ln1392">                if (i &amp; 2) {</a>
<a name="ln1393">                  STRCAT(errbuf, &quot;s,&quot;);</a>
<a name="ln1394">                }</a>
<a name="ln1395">                if (i &amp; 4) {</a>
<a name="ln1396">                  STRCAT(errbuf, &quot;h,l,&quot;);</a>
<a name="ln1397">                }</a>
<a name="ln1398">                if (i &amp; 8) {</a>
<a name="ln1399">                  STRCAT(errbuf, &quot;&lt;,&gt;,&quot;);</a>
<a name="ln1400">                }</a>
<a name="ln1401">                if (i &amp; 16) {</a>
<a name="ln1402">                  STRCAT(errbuf, &quot;[,],&quot;);</a>
<a name="ln1403">                }</a>
<a name="ln1404">                if (*errbuf != NUL) {                   // remove trailing ,</a>
<a name="ln1405">                  errbuf[STRLEN(errbuf) - 1] = NUL;</a>
<a name="ln1406">                }</a>
<a name="ln1407">                save_arg = arg;</a>
<a name="ln1408">                arg = errbuf;</a>
<a name="ln1409">              }</a>
<a name="ln1410">              /*</a>
<a name="ln1411">               * Remove '&gt;' before 'dir' and 'bdir', for</a>
<a name="ln1412">               * backwards compatibility with version 3.0</a>
<a name="ln1413">               */</a>
<a name="ln1414">              else if (  *arg == '&gt;'</a>
<a name="ln1415">                         &amp;&amp; (varp == (char_u *)&amp;p_dir</a>
<a name="ln1416">                             || varp == (char_u *)&amp;p_bdir)) {</a>
<a name="ln1417">                arg++;</a>
<a name="ln1418">              }</a>
<a name="ln1419"> </a>
<a name="ln1420">              /*</a>
<a name="ln1421">               * Copy the new string into allocated memory.</a>
<a name="ln1422">               * Can't use set_string_option_direct(), because</a>
<a name="ln1423">               * we need to remove the backslashes.</a>
<a name="ln1424">               */</a>
<a name="ln1425">              // get a bit too much</a>
<a name="ln1426">              newlen = (unsigned)STRLEN(arg) + 1;</a>
<a name="ln1427">              if (adding || prepending || removing) {</a>
<a name="ln1428">                newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1429">              }</a>
<a name="ln1430">              newval = xmalloc(newlen);</a>
<a name="ln1431">              s = newval;</a>
<a name="ln1432"> </a>
<a name="ln1433">              /*</a>
<a name="ln1434">               * Copy the string, skip over escaped chars.</a>
<a name="ln1435">               * For WIN32 backslashes before normal</a>
<a name="ln1436">               * file name characters are not removed, and keep</a>
<a name="ln1437">               * backslash at start, for &quot;\\machine\path&quot;, but</a>
<a name="ln1438">               * do remove it for &quot;\\\\machine\\path&quot;.</a>
<a name="ln1439">               * The reverse is found in ExpandOldSetting().</a>
<a name="ln1440">               */</a>
<a name="ln1441">              while (*arg &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1442">                if (*arg == '\\' &amp;&amp; arg[1] != NUL</a>
<a name="ln1443">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln1444">                    &amp;&amp; !((flags &amp; P_EXPAND)</a>
<a name="ln1445">                         &amp;&amp; vim_isfilec(arg[1])</a>
<a name="ln1446">                         &amp;&amp; !ascii_iswhite(arg[1])</a>
<a name="ln1447">                         &amp;&amp; (arg[1] != '\\'</a>
<a name="ln1448">                             || (s == newval</a>
<a name="ln1449">                                 &amp;&amp; arg[2] != '\\')))</a>
<a name="ln1450">#endif</a>
<a name="ln1451">                    )</a>
<a name="ln1452">                  arg++;                        // remove backslash</a>
<a name="ln1453">                i = utfc_ptr2len(arg);</a>
<a name="ln1454">                if (i &gt; 1) {</a>
<a name="ln1455">                  // copy multibyte char</a>
<a name="ln1456">                  memmove(s, arg, (size_t)i);</a>
<a name="ln1457">                  arg += i;</a>
<a name="ln1458">                  s += i;</a>
<a name="ln1459">                } else {</a>
<a name="ln1460">                  *s++ = *arg++;</a>
<a name="ln1461">                }</a>
<a name="ln1462">              }</a>
<a name="ln1463">              *s = NUL;</a>
<a name="ln1464"> </a>
<a name="ln1465">              /*</a>
<a name="ln1466">               * Expand environment variables and ~.</a>
<a name="ln1467">               * Don't do it when adding without inserting a</a>
<a name="ln1468">               * comma.</a>
<a name="ln1469">               */</a>
<a name="ln1470">              if (!(adding || prepending || removing)</a>
<a name="ln1471">                  || (flags &amp; P_COMMA)) {</a>
<a name="ln1472">                s = option_expand(opt_idx, newval);</a>
<a name="ln1473">                if (s != NULL) {</a>
<a name="ln1474">                  xfree(newval);</a>
<a name="ln1475">                  newlen = (unsigned)STRLEN(s) + 1;</a>
<a name="ln1476">                  if (adding || prepending || removing) {</a>
<a name="ln1477">                    newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1478">                  }</a>
<a name="ln1479">                  newval = xmalloc(newlen);</a>
<a name="ln1480">                  STRCPY(newval, s);</a>
<a name="ln1481">                }</a>
<a name="ln1482">              }</a>
<a name="ln1483"> </a>
<a name="ln1484">              /* locate newval[] in origval[] when removing it</a>
<a name="ln1485">               * and when adding to avoid duplicates */</a>
<a name="ln1486">              i = 0;                    // init for GCC</a>
<a name="ln1487">              if (removing || (flags &amp; P_NODUP)) {</a>
<a name="ln1488">                i = (int)STRLEN(newval);</a>
<a name="ln1489">                bs = 0;</a>
<a name="ln1490">                for (s = origval; *s; s++) {</a>
<a name="ln1491">                  if ((!(flags &amp; P_COMMA)</a>
<a name="ln1492">                       || s == origval</a>
<a name="ln1493">                       || (s[-1] == ',' &amp;&amp; !(bs &amp; 1)))</a>
<a name="ln1494">                      &amp;&amp; STRNCMP(s, newval, i) == 0</a>
<a name="ln1495">                      &amp;&amp; (!(flags &amp; P_COMMA)</a>
<a name="ln1496">                          || s[i] == ','</a>
<a name="ln1497">                          || s[i] == NUL)) {</a>
<a name="ln1498">                    break;</a>
<a name="ln1499">                  }</a>
<a name="ln1500">                  // Count backslashes.  Only a comma with an even number of</a>
<a name="ln1501">                  // backslashes or a single backslash preceded by a comma</a>
<a name="ln1502">                  // before it is recognized as a separator</a>
<a name="ln1503">                  if ((s &gt; origval + 1 &amp;&amp; s[-1] == '\\' &amp;&amp; s[-2] != ',')</a>
<a name="ln1504">                      || (s == origval + 1 &amp;&amp; s[-1] == '\\')) {</a>
<a name="ln1505">                    bs++;</a>
<a name="ln1506">                  } else {</a>
<a name="ln1507">                    bs = 0;</a>
<a name="ln1508">                  }</a>
<a name="ln1509">                }</a>
<a name="ln1510"> </a>
<a name="ln1511">                // do not add if already there</a>
<a name="ln1512">                if ((adding || prepending) &amp;&amp; *s) {</a>
<a name="ln1513">                  prepending = false;</a>
<a name="ln1514">                  adding = false;</a>
<a name="ln1515">                  STRCPY(newval, origval);</a>
<a name="ln1516">                }</a>
<a name="ln1517">              }</a>
<a name="ln1518"> </a>
<a name="ln1519">              /* concatenate the two strings; add a ',' if</a>
<a name="ln1520">               * needed */</a>
<a name="ln1521">              if (adding || prepending) {</a>
<a name="ln1522">                comma = ((flags &amp; P_COMMA) &amp;&amp; *origval != NUL</a>
<a name="ln1523">                         &amp;&amp; *newval != NUL);</a>
<a name="ln1524">                if (adding) {</a>
<a name="ln1525">                  i = (int)STRLEN(origval);</a>
<a name="ln1526">                  // Strip a trailing comma, would get 2.</a>
<a name="ln1527">                  if (comma &amp;&amp; i &gt; 1</a>
<a name="ln1528">                      &amp;&amp; (flags &amp; P_ONECOMMA) == P_ONECOMMA</a>
<a name="ln1529">                      &amp;&amp; origval[i - 1] == ','</a>
<a name="ln1530">                      &amp;&amp; origval[i - 2] != '\\') {</a>
<a name="ln1531">                    i--;</a>
<a name="ln1532">                  }</a>
<a name="ln1533">                  memmove(newval + i + comma, newval,</a>
<a name="ln1534">                      STRLEN(newval) + 1);</a>
<a name="ln1535">                  memmove(newval, origval, (size_t)i);</a>
<a name="ln1536">                } else {</a>
<a name="ln1537">                  i = (int)STRLEN(newval);</a>
<a name="ln1538">                  STRMOVE(newval + i + comma, origval);</a>
<a name="ln1539">                }</a>
<a name="ln1540">                if (comma) {</a>
<a name="ln1541">                  newval[i] = ',';</a>
<a name="ln1542">                }</a>
<a name="ln1543">              }</a>
<a name="ln1544"> </a>
<a name="ln1545">              /* Remove newval[] from origval[]. (Note: &quot;i&quot; has</a>
<a name="ln1546">               * been set above and is used here). */</a>
<a name="ln1547">              if (removing) {</a>
<a name="ln1548">                STRCPY(newval, origval);</a>
<a name="ln1549">                if (*s) {</a>
<a name="ln1550">                  // may need to remove a comma</a>
<a name="ln1551">                  if (flags &amp; P_COMMA) {</a>
<a name="ln1552">                    if (s == origval) {</a>
<a name="ln1553">                      // include comma after string</a>
<a name="ln1554">                      if (s[i] == ',') {</a>
<a name="ln1555">                        i++;</a>
<a name="ln1556">                      }</a>
<a name="ln1557">                    } else {</a>
<a name="ln1558">                      // include comma before string</a>
<a name="ln1559">                      s--;</a>
<a name="ln1560">                      i++;</a>
<a name="ln1561">                    }</a>
<a name="ln1562">                  }</a>
<a name="ln1563">                  STRMOVE(newval + (s - origval), s + i);</a>
<a name="ln1564">                }</a>
<a name="ln1565">              }</a>
<a name="ln1566"> </a>
<a name="ln1567">              if (flags &amp; P_FLAGLIST) {</a>
<a name="ln1568">                // Remove flags that appear twice.</a>
<a name="ln1569">                for (s = newval; *s;) {</a>
<a name="ln1570">                  // if options have P_FLAGLIST and P_ONECOMMA such as</a>
<a name="ln1571">                  // 'whichwrap'</a>
<a name="ln1572">                  if (flags &amp; P_ONECOMMA) {</a>
<a name="ln1573">                    if (*s != ',' &amp;&amp; *(s + 1) == ','</a>
<a name="ln1574">                        &amp;&amp; vim_strchr(s + 2, *s) != NULL) {</a>
<a name="ln1575">                      // Remove the duplicated value and the next comma.</a>
<a name="ln1576">                      STRMOVE(s, s + 2);</a>
<a name="ln1577">                      continue;</a>
<a name="ln1578">                    }</a>
<a name="ln1579">                  } else {</a>
<a name="ln1580">                    if ((!(flags &amp; P_COMMA) || *s != ',')</a>
<a name="ln1581">                        &amp;&amp; vim_strchr(s + 1, *s) != NULL) {</a>
<a name="ln1582">                      STRMOVE(s, s + 1);</a>
<a name="ln1583">                      continue;</a>
<a name="ln1584">                    }</a>
<a name="ln1585">                  }</a>
<a name="ln1586">                  s++;</a>
<a name="ln1587">                }</a>
<a name="ln1588">              }</a>
<a name="ln1589"> </a>
<a name="ln1590">              if (save_arg != NULL) {               // number for 'whichwrap'</a>
<a name="ln1591">                arg = save_arg;</a>
<a name="ln1592">              }</a>
<a name="ln1593">              new_value_alloced = true;</a>
<a name="ln1594">            }</a>
<a name="ln1595"> </a>
<a name="ln1596">            // Set the new value.</a>
<a name="ln1597">            *(char_u **)(varp) = newval;</a>
<a name="ln1598"> </a>
<a name="ln1599">            // origval may be freed by</a>
<a name="ln1600">            // did_set_string_option(), make a copy.</a>
<a name="ln1601">            saved_origval = (origval != NULL) ? xstrdup((char *)origval) : 0;</a>
<a name="ln1602"> </a>
<a name="ln1603">            // newval (and varp) may become invalid if the</a>
<a name="ln1604">            // buffer is closed by autocommands.</a>
<a name="ln1605">            saved_newval = (newval != NULL) ? xstrdup((char *)newval) : 0;</a>
<a name="ln1606"> </a>
<a name="ln1607">            {</a>
<a name="ln1608">              uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1609">              const int secure_saved = secure;</a>
<a name="ln1610"> </a>
<a name="ln1611">              // When an option is set in the sandbox, from a</a>
<a name="ln1612">              // modeline or in secure mode, then deal with side</a>
<a name="ln1613">              // effects in secure mode.  Also when the value was</a>
<a name="ln1614">              // set with the P_INSECURE flag and is not</a>
<a name="ln1615">              // completely replaced.</a>
<a name="ln1616">              if ((opt_flags &amp; OPT_MODELINE)</a>
<a name="ln1617">                  || sandbox != 0</a>
<a name="ln1618">                  || (!value_is_replaced &amp;&amp; (*p &amp; P_INSECURE))) {</a>
<a name="ln1619">                secure = 1;</a>
<a name="ln1620">              }</a>
<a name="ln1621"> </a>
<a name="ln1622">              // Handle side effects, and set the global value</a>
<a name="ln1623">              // for &quot;:set&quot; on local options. Note: when setting</a>
<a name="ln1624">              // 'syntax' or 'filetype' autocommands may be</a>
<a name="ln1625">              // triggered that can cause havoc.</a>
<a name="ln1626">              errmsg = did_set_string_option(opt_idx, (char_u **)varp,</a>
<a name="ln1627">                                             new_value_alloced, oldval,</a>
<a name="ln1628">                                             errbuf, sizeof(errbuf),</a>
<a name="ln1629">                                             opt_flags, &amp;value_checked);</a>
<a name="ln1630"> </a>
<a name="ln1631">              secure = secure_saved;</a>
<a name="ln1632">            }</a>
<a name="ln1633"> </a>
<a name="ln1634">            if (errmsg == NULL) {</a>
<a name="ln1635">              if (!starting) {</a>
<a name="ln1636">                trigger_optionsset_string(opt_idx, opt_flags, saved_origval,</a>
<a name="ln1637">                                          saved_newval);</a>
<a name="ln1638">              }</a>
<a name="ln1639">              if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln1640">                ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln1641">                                   STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln1642">              }</a>
<a name="ln1643">            }</a>
<a name="ln1644">            xfree(saved_origval);</a>
<a name="ln1645">            xfree(saved_newval);</a>
<a name="ln1646"> </a>
<a name="ln1647">            // If error detected, print the error message.</a>
<a name="ln1648">            if (errmsg != NULL) {</a>
<a name="ln1649">              goto skip;</a>
<a name="ln1650">            }</a>
<a name="ln1651"> </a>
<a name="ln1652">          } else {</a>
<a name="ln1653">            // key code option(FIXME(tarruda): Show a warning or something</a>
<a name="ln1654">            // similar)</a>
<a name="ln1655">          }</a>
<a name="ln1656">        }</a>
<a name="ln1657"> </a>
<a name="ln1658">        if (opt_idx &gt;= 0) {</a>
<a name="ln1659">          did_set_option(opt_idx, opt_flags, value_is_replaced, value_checked);</a>
<a name="ln1660">        }</a>
<a name="ln1661">      }</a>
<a name="ln1662"> </a>
<a name="ln1663">skip:</a>
<a name="ln1664">      /*</a>
<a name="ln1665">       * Advance to next argument.</a>
<a name="ln1666">       * - skip until a blank found, taking care of backslashes</a>
<a name="ln1667">       * - skip blanks</a>
<a name="ln1668">       * - skip one &quot;=val&quot; argument (for hidden options &quot;:set gfn =xx&quot;)</a>
<a name="ln1669">       */</a>
<a name="ln1670">      for (i = 0; i &lt; 2; i++) {</a>
<a name="ln1671">        while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1672">          if (*arg++ == '\\' &amp;&amp; *arg != NUL) {</a>
<a name="ln1673">            arg++;</a>
<a name="ln1674">          }</a>
<a name="ln1675">        }</a>
<a name="ln1676">        arg = skipwhite(arg);</a>
<a name="ln1677">        if (*arg != '=') {</a>
<a name="ln1678">          break;</a>
<a name="ln1679">        }</a>
<a name="ln1680">      }</a>
<a name="ln1681">    }</a>
<a name="ln1682"> </a>
<a name="ln1683">    if (errmsg != NULL) {</a>
<a name="ln1684">      STRLCPY(IObuff, _(errmsg), IOSIZE);</a>
<a name="ln1685">      i = (int)STRLEN(IObuff) + 2;</a>
<a name="ln1686">      if (i + (arg - startarg) &lt; IOSIZE) {</a>
<a name="ln1687">        // append the argument with the error</a>
<a name="ln1688">        STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln1689">        assert(arg &gt;= startarg);</a>
<a name="ln1690">        memmove(IObuff + i, startarg, (size_t)(arg - startarg));</a>
<a name="ln1691">        IObuff[i + (arg - startarg)] = NUL;</a>
<a name="ln1692">      }</a>
<a name="ln1693">      // make sure all characters are printable</a>
<a name="ln1694">      trans_characters(IObuff, IOSIZE);</a>
<a name="ln1695"> </a>
<a name="ln1696">      no_wait_return++;         // wait_return done later</a>
<a name="ln1697">      emsg(IObuff);             // show error highlighted</a>
<a name="ln1698">      no_wait_return--;</a>
<a name="ln1699"> </a>
<a name="ln1700">      return FAIL;</a>
<a name="ln1701">    }</a>
<a name="ln1702"> </a>
<a name="ln1703">    arg = skipwhite(arg);</a>
<a name="ln1704">  }</a>
<a name="ln1705"> </a>
<a name="ln1706">theend:</a>
<a name="ln1707">  if (silent_mode &amp;&amp; did_show) {</a>
<a name="ln1708">    // After displaying option values in silent mode.</a>
<a name="ln1709">    silent_mode = false;</a>
<a name="ln1710">    info_message = true;        // use mch_msg(), not mch_errmsg()</a>
<a name="ln1711">    msg_putchar('\n');</a>
<a name="ln1712">    ui_flush();</a>
<a name="ln1713">    silent_mode = true;</a>
<a name="ln1714">    info_message = false;       // use mch_msg(), not mch_errmsg()</a>
<a name="ln1715">  }</a>
<a name="ln1716"> </a>
<a name="ln1717">  return OK;</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720">// Call this when an option has been given a new value through a user command.</a>
<a name="ln1721">// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.</a>
<a name="ln1722">static void did_set_option(</a>
<a name="ln1723">    int opt_idx,</a>
<a name="ln1724">    int opt_flags,              // possibly with OPT_MODELINE</a>
<a name="ln1725">    int new_value,              // value was replaced completely</a>
<a name="ln1726">    int value_checked           // value was checked to be safe, no need to</a>
<a name="ln1727">                                // set P_INSECURE</a>
<a name="ln1728">)</a>
<a name="ln1729">{</a>
<a name="ln1730">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln1731"> </a>
<a name="ln1732">  /* When an option is set in the sandbox, from a modeline or in secure mode</a>
<a name="ln1733">   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the</a>
<a name="ln1734">   * flag. */</a>
<a name="ln1735">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1736">  if (!value_checked &amp;&amp; (secure</a>
<a name="ln1737">                         || sandbox != 0</a>
<a name="ln1738">                         || (opt_flags &amp; OPT_MODELINE))) {</a>
<a name="ln1739">    *p = *p | P_INSECURE;</a>
<a name="ln1740">  } else if (new_value) {</a>
<a name="ln1741">    *p = *p &amp; ~P_INSECURE;</a>
<a name="ln1742">  }</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">static char_u *illegal_char(char_u *errbuf, size_t errbuflen, int c)</a>
<a name="ln1746">{</a>
<a name="ln1747">  if (errbuf == NULL) {</a>
<a name="ln1748">    return (char_u *)&quot;&quot;;</a>
<a name="ln1749">  }</a>
<a name="ln1750">  vim_snprintf((char *)errbuf, errbuflen, _(&quot;E539: Illegal character &lt;%s&gt;&quot;),</a>
<a name="ln1751">               (char *)transchar(c));</a>
<a name="ln1752">  return errbuf;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755">/// Convert a key name or string into a key value.</a>
<a name="ln1756">/// Used for 'wildchar' and 'cedit' options.</a>
<a name="ln1757">static int string_to_key(char_u *arg)</a>
<a name="ln1758">{</a>
<a name="ln1759">  if (*arg == '&lt;') {</a>
<a name="ln1760">    return find_key_option(arg + 1, true);</a>
<a name="ln1761">  }</a>
<a name="ln1762">  if (*arg == '^') {</a>
<a name="ln1763">    return Ctrl_chr(arg[1]);</a>
<a name="ln1764">  }</a>
<a name="ln1765">  return *arg;</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">/// Check value of 'cedit' and set cedit_key.</a>
<a name="ln1769">/// Returns NULL if value is OK, error message otherwise.</a>
<a name="ln1770">static char_u *check_cedit(void)</a>
<a name="ln1771">{</a>
<a name="ln1772">  int n;</a>
<a name="ln1773"> </a>
<a name="ln1774">  if (*p_cedit == NUL) {</a>
<a name="ln1775">    cedit_key = -1;</a>
<a name="ln1776">  } else {</a>
<a name="ln1777">    n = string_to_key(p_cedit);</a>
<a name="ln1778">    if (vim_isprintc(n)) {</a>
<a name="ln1779">      return e_invarg;</a>
<a name="ln1780">    }</a>
<a name="ln1781">    cedit_key = n;</a>
<a name="ln1782">  }</a>
<a name="ln1783">  return NULL;</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">// When changing 'title', 'titlestring', 'icon' or 'iconstring', call</a>
<a name="ln1787">// maketitle() to create and display it.</a>
<a name="ln1788">// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get</a>
<a name="ln1789">// the old value back.</a>
<a name="ln1790">static void did_set_title(void)</a>
<a name="ln1791">{</a>
<a name="ln1792">  if (starting != NO_SCREEN) {</a>
<a name="ln1793">    maketitle();</a>
<a name="ln1794">  }</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">// set_options_bin -  called when 'bin' changes value.</a>
<a name="ln1798">void set_options_bin(</a>
<a name="ln1799">    int oldval,</a>
<a name="ln1800">    int newval,</a>
<a name="ln1801">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln1802">)</a>
<a name="ln1803">{</a>
<a name="ln1804">  /*</a>
<a name="ln1805">   * The option values that are changed when 'bin' changes are</a>
<a name="ln1806">   * copied when 'bin is set and restored when 'bin' is reset.</a>
<a name="ln1807">   */</a>
<a name="ln1808">  if (newval) {</a>
<a name="ln1809">    if (!oldval) {              // switched on</a>
<a name="ln1810">      if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1811">        curbuf-&gt;b_p_tw_nobin = curbuf-&gt;b_p_tw;</a>
<a name="ln1812">        curbuf-&gt;b_p_wm_nobin = curbuf-&gt;b_p_wm;</a>
<a name="ln1813">        curbuf-&gt;b_p_ml_nobin = curbuf-&gt;b_p_ml;</a>
<a name="ln1814">        curbuf-&gt;b_p_et_nobin = curbuf-&gt;b_p_et;</a>
<a name="ln1815">      }</a>
<a name="ln1816">      if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1817">        p_tw_nobin = p_tw;</a>
<a name="ln1818">        p_wm_nobin = p_wm;</a>
<a name="ln1819">        p_ml_nobin = p_ml;</a>
<a name="ln1820">        p_et_nobin = p_et;</a>
<a name="ln1821">      }</a>
<a name="ln1822">    }</a>
<a name="ln1823"> </a>
<a name="ln1824">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1825">      curbuf-&gt;b_p_tw = 0;       // no automatic line wrap</a>
<a name="ln1826">      curbuf-&gt;b_p_wm = 0;       // no automatic line wrap</a>
<a name="ln1827">      curbuf-&gt;b_p_ml = 0;       // no modelines</a>
<a name="ln1828">      curbuf-&gt;b_p_et = 0;       // no expandtab</a>
<a name="ln1829">    }</a>
<a name="ln1830">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1831">      p_tw = 0;</a>
<a name="ln1832">      p_wm = 0;</a>
<a name="ln1833">      p_ml = false;</a>
<a name="ln1834">      p_et = false;</a>
<a name="ln1835">      p_bin = true;             // needed when called for the &quot;-b&quot; argument</a>
<a name="ln1836">    }</a>
<a name="ln1837">  } else if (oldval) {        // switched off</a>
<a name="ln1838">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1839">      curbuf-&gt;b_p_tw = curbuf-&gt;b_p_tw_nobin;</a>
<a name="ln1840">      curbuf-&gt;b_p_wm = curbuf-&gt;b_p_wm_nobin;</a>
<a name="ln1841">      curbuf-&gt;b_p_ml = curbuf-&gt;b_p_ml_nobin;</a>
<a name="ln1842">      curbuf-&gt;b_p_et = curbuf-&gt;b_p_et_nobin;</a>
<a name="ln1843">    }</a>
<a name="ln1844">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1845">      p_tw = p_tw_nobin;</a>
<a name="ln1846">      p_wm = p_wm_nobin;</a>
<a name="ln1847">      p_ml = p_ml_nobin;</a>
<a name="ln1848">      p_et = p_et_nobin;</a>
<a name="ln1849">    }</a>
<a name="ln1850">  }</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853">/// Find the parameter represented by the given character (eg ', :, &quot;, or /),</a>
<a name="ln1854">/// and return its associated value in the 'shada' string.</a>
<a name="ln1855">/// Only works for number parameters, not for 'r' or 'n'.</a>
<a name="ln1856">/// If the parameter is not specified in the string or there is no following</a>
<a name="ln1857">/// number, return -1.</a>
<a name="ln1858">int get_shada_parameter(int type)</a>
<a name="ln1859">{</a>
<a name="ln1860">  char_u  *p;</a>
<a name="ln1861"> </a>
<a name="ln1862">  p = find_shada_parameter(type);</a>
<a name="ln1863">  if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln1864">    return atoi((char *)p);</a>
<a name="ln1865">  }</a>
<a name="ln1866">  return -1;</a>
<a name="ln1867">}</a>
<a name="ln1868"> </a>
<a name="ln1869">/// Find the parameter represented by the given character (eg ''', ':', '&quot;', or</a>
<a name="ln1870">/// '/') in the 'shada' option and return a pointer to the string after it.</a>
<a name="ln1871">/// Return NULL if the parameter is not specified in the string.</a>
<a name="ln1872">char_u *find_shada_parameter(int type)</a>
<a name="ln1873">{</a>
<a name="ln1874">  char_u  *p;</a>
<a name="ln1875"> </a>
<a name="ln1876">  for (p = p_shada; *p; p++) {</a>
<a name="ln1877">    if (*p == type) {</a>
<a name="ln1878">      return p + 1;</a>
<a name="ln1879">    }</a>
<a name="ln1880">    if (*p == 'n') {                // 'n' is always the last one</a>
<a name="ln1881">      break;</a>
<a name="ln1882">    }</a>
<a name="ln1883">    p = vim_strchr(p, ',');         // skip until next ','</a>
<a name="ln1884">    if (p == NULL) {                // hit the end without finding parameter</a>
<a name="ln1885">      break;</a>
<a name="ln1886">    }</a>
<a name="ln1887">  }</a>
<a name="ln1888">  return NULL;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">/// Expand environment variables for some string options.</a>
<a name="ln1892">/// These string options cannot be indirect!</a>
<a name="ln1893">/// If &quot;val&quot; is NULL expand the current value of the option.</a>
<a name="ln1894">/// Return pointer to NameBuff, or NULL when not expanded.</a>
<a name="ln1895">static char_u *option_expand(int opt_idx, char_u *val)</a>
<a name="ln1896">{</a>
<a name="ln1897">  // if option doesn't need expansion nothing to do</a>
<a name="ln1898">  if (!(options[opt_idx].flags &amp; P_EXPAND) || options[opt_idx].var == NULL) {</a>
<a name="ln1899">    return NULL;</a>
<a name="ln1900">  }</a>
<a name="ln1901"> </a>
<a name="ln1902">  if (val == NULL) {</a>
<a name="ln1903">    val = *(char_u **)options[opt_idx].var;</a>
<a name="ln1904">  }</a>
<a name="ln1905"> </a>
<a name="ln1906">  // If val is longer than MAXPATHL no meaningful expansion can be done,</a>
<a name="ln1907">  // expand_env() would truncate the string.</a>
<a name="ln1908">  if (val == NULL || STRLEN(val) &gt; MAXPATHL) {</a>
<a name="ln1909">    return NULL;</a>
<a name="ln1910">  }</a>
<a name="ln1911"> </a>
<a name="ln1912">  /*</a>
<a name="ln1913">   * Expanding this with NameBuff, expand_env() must not be passed IObuff.</a>
<a name="ln1914">   * Escape spaces when expanding 'tags', they are used to separate file</a>
<a name="ln1915">   * names.</a>
<a name="ln1916">   * For 'spellsuggest' expand after &quot;file:&quot;.</a>
<a name="ln1917">   */</a>
<a name="ln1918">  expand_env_esc(val, NameBuff, MAXPATHL,</a>
<a name="ln1919">                 (char_u **)options[opt_idx].var == &amp;p_tags, false,</a>
<a name="ln1920">                 (char_u **)options[opt_idx].var == &amp;p_sps ? (char_u *)&quot;file:&quot; :</a>
<a name="ln1921">                 NULL);</a>
<a name="ln1922">  if (STRCMP(NameBuff, val) == 0) {   // they are the same</a>
<a name="ln1923">    return NULL;</a>
<a name="ln1924">  }</a>
<a name="ln1925"> </a>
<a name="ln1926">  return NameBuff;</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">// After setting various option values: recompute variables that depend on</a>
<a name="ln1930">// option values.</a>
<a name="ln1931">static void didset_options(void)</a>
<a name="ln1932">{</a>
<a name="ln1933">  // initialize the table for 'iskeyword' et.al.</a>
<a name="ln1934">  (void)init_chartab();</a>
<a name="ln1935"> </a>
<a name="ln1936">  (void)opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true);</a>
<a name="ln1937">  (void)opt_strings_flags(p_bkc, p_bkc_values, &amp;bkc_flags, true);</a>
<a name="ln1938">  (void)opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true);</a>
<a name="ln1939">  (void)opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln1940">  (void)opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true);</a>
<a name="ln1941">  (void)opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true);</a>
<a name="ln1942">  (void)opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true);</a>
<a name="ln1943">  (void)opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true);</a>
<a name="ln1944">  (void)opt_strings_flags(p_tc, p_tc_values, &amp;tc_flags, false);</a>
<a name="ln1945">  (void)opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true);</a>
<a name="ln1946">  (void)opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true);</a>
<a name="ln1947">  (void)opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true);</a>
<a name="ln1948">  (void)spell_check_msm();</a>
<a name="ln1949">  (void)spell_check_sps();</a>
<a name="ln1950">  (void)compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln1951">  (void)did_set_spell_option(true);</a>
<a name="ln1952">  // set cedit_key</a>
<a name="ln1953">  (void)check_cedit();</a>
<a name="ln1954">  briopt_check(curwin);</a>
<a name="ln1955">  // initialize the table for 'breakat'.</a>
<a name="ln1956">  fill_breakat_flags();</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959">// More side effects of setting options.</a>
<a name="ln1960">static void didset_options2(void)</a>
<a name="ln1961">{</a>
<a name="ln1962">  // Initialize the highlight_attr[] table.</a>
<a name="ln1963">  highlight_changed();</a>
<a name="ln1964"> </a>
<a name="ln1965">  // Parse default for 'clipboard'.</a>
<a name="ln1966">  (void)opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true);</a>
<a name="ln1967"> </a>
<a name="ln1968">  // Parse default for 'fillchars'.</a>
<a name="ln1969">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_fcs, true);</a>
<a name="ln1970"> </a>
<a name="ln1971">  // Parse default for 'listchars'.</a>
<a name="ln1972">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_lcs, true);</a>
<a name="ln1973"> </a>
<a name="ln1974">  // Parse default for 'wildmode'.</a>
<a name="ln1975">  check_opt_wim();</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978">/// Check for string options that are NULL (normally only termcap options).</a>
<a name="ln1979">void check_options(void)</a>
<a name="ln1980">{</a>
<a name="ln1981">  int opt_idx;</a>
<a name="ln1982"> </a>
<a name="ln1983">  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln1984">    if ((options[opt_idx].flags &amp; P_STRING) &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln1985">      check_string_option((char_u **)get_varp(&amp;(options[opt_idx])));</a>
<a name="ln1986">    }</a>
<a name="ln1987">  }</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">/// Check string options in a buffer for NULL value.</a>
<a name="ln1991">void check_buf_options(buf_T *buf)</a>
<a name="ln1992">{</a>
<a name="ln1993">  check_string_option(&amp;buf-&gt;b_p_bh);</a>
<a name="ln1994">  check_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln1995">  check_string_option(&amp;buf-&gt;b_p_fenc);</a>
<a name="ln1996">  check_string_option(&amp;buf-&gt;b_p_ff);</a>
<a name="ln1997">  check_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln1998">  check_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln1999">  check_string_option(&amp;buf-&gt;b_p_inex);</a>
<a name="ln2000">  check_string_option(&amp;buf-&gt;b_p_inde);</a>
<a name="ln2001">  check_string_option(&amp;buf-&gt;b_p_indk);</a>
<a name="ln2002">  check_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln2003">  check_string_option(&amp;buf-&gt;b_p_fex);</a>
<a name="ln2004">  check_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln2005">  check_string_option(&amp;buf-&gt;b_p_mps);</a>
<a name="ln2006">  check_string_option(&amp;buf-&gt;b_p_fo);</a>
<a name="ln2007">  check_string_option(&amp;buf-&gt;b_p_flp);</a>
<a name="ln2008">  check_string_option(&amp;buf-&gt;b_p_isk);</a>
<a name="ln2009">  check_string_option(&amp;buf-&gt;b_p_com);</a>
<a name="ln2010">  check_string_option(&amp;buf-&gt;b_p_cms);</a>
<a name="ln2011">  check_string_option(&amp;buf-&gt;b_p_nf);</a>
<a name="ln2012">  check_string_option(&amp;buf-&gt;b_p_qe);</a>
<a name="ln2013">  check_string_option(&amp;buf-&gt;b_p_syn);</a>
<a name="ln2014">  check_string_option(&amp;buf-&gt;b_s.b_syn_isk);</a>
<a name="ln2015">  check_string_option(&amp;buf-&gt;b_s.b_p_spc);</a>
<a name="ln2016">  check_string_option(&amp;buf-&gt;b_s.b_p_spf);</a>
<a name="ln2017">  check_string_option(&amp;buf-&gt;b_s.b_p_spl);</a>
<a name="ln2018">  check_string_option(&amp;buf-&gt;b_s.b_p_spo);</a>
<a name="ln2019">  check_string_option(&amp;buf-&gt;b_p_sua);</a>
<a name="ln2020">  check_string_option(&amp;buf-&gt;b_p_cink);</a>
<a name="ln2021">  check_string_option(&amp;buf-&gt;b_p_cino);</a>
<a name="ln2022">  parse_cino(buf);</a>
<a name="ln2023">  check_string_option(&amp;buf-&gt;b_p_ft);</a>
<a name="ln2024">  check_string_option(&amp;buf-&gt;b_p_cinw);</a>
<a name="ln2025">  check_string_option(&amp;buf-&gt;b_p_cpt);</a>
<a name="ln2026">  check_string_option(&amp;buf-&gt;b_p_cfu);</a>
<a name="ln2027">  check_string_option(&amp;buf-&gt;b_p_ofu);</a>
<a name="ln2028">  check_string_option(&amp;buf-&gt;b_p_keymap);</a>
<a name="ln2029">  check_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln2030">  check_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln2031">  check_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln2032">  check_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln2033">  check_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln2034">  check_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln2035">  check_string_option(&amp;buf-&gt;b_p_tfu);</a>
<a name="ln2036">  check_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln2037">  check_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln2038">  check_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln2039">  check_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln2040">  check_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln2041">  check_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">/// Free the string allocated for an option.</a>
<a name="ln2045">/// Checks for the string being empty_option. This may happen if we're out of</a>
<a name="ln2046">/// memory, vim_strsave() returned NULL, which was replaced by empty_option by</a>
<a name="ln2047">/// check_options().</a>
<a name="ln2048">/// Does NOT check for P_ALLOCED flag!</a>
<a name="ln2049">void free_string_option(char_u *p)</a>
<a name="ln2050">{</a>
<a name="ln2051">  if (p != empty_option) {</a>
<a name="ln2052">    xfree(p);</a>
<a name="ln2053">  }</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">void clear_string_option(char_u **pp)</a>
<a name="ln2057">{</a>
<a name="ln2058">  if (*pp != empty_option) {</a>
<a name="ln2059">    xfree(*pp);</a>
<a name="ln2060">  }</a>
<a name="ln2061">  *pp = empty_option;</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">static void check_string_option(char_u **pp)</a>
<a name="ln2065">{</a>
<a name="ln2066">  if (*pp == NULL) {</a>
<a name="ln2067">    *pp = empty_option;</a>
<a name="ln2068">  }</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071">/// Return true when option &quot;opt&quot; was set from a modeline or in secure mode.</a>
<a name="ln2072">/// Return false when it wasn't.</a>
<a name="ln2073">/// Return -1 for an unknown option.</a>
<a name="ln2074">int was_set_insecurely(win_T *const wp, char_u *opt, int opt_flags)</a>
<a name="ln2075">{</a>
<a name="ln2076">  int idx = findoption((const char *)opt);</a>
<a name="ln2077"> </a>
<a name="ln2078">  if (idx &gt;= 0) {</a>
<a name="ln2079">    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);</a>
<a name="ln2080">    return (*flagp &amp; P_INSECURE) != 0;</a>
<a name="ln2081">  }</a>
<a name="ln2082">  internal_error(&quot;was_set_insecurely()&quot;);</a>
<a name="ln2083">  return -1;</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">/// Get a pointer to the flags used for the P_INSECURE flag of option</a>
<a name="ln2087">/// &quot;opt_idx&quot;.  For some local options a local flags field is used.</a>
<a name="ln2088">static uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)</a>
<a name="ln2089">{</a>
<a name="ln2090">  if (opt_flags &amp; OPT_LOCAL)</a>
<a name="ln2091">    switch ((int)options[opt_idx].indir) {</a>
<a name="ln2092">    case PV_STL:        return &amp;wp-&gt;w_p_stl_flags;</a>
<a name="ln2093">    case PV_FDE:        return &amp;wp-&gt;w_p_fde_flags;</a>
<a name="ln2094">    case PV_FDT:        return &amp;wp-&gt;w_p_fdt_flags;</a>
<a name="ln2095">    case PV_INDE:       return &amp;wp-&gt;w_buffer-&gt;b_p_inde_flags;</a>
<a name="ln2096">    case PV_FEX:        return &amp;wp-&gt;w_buffer-&gt;b_p_fex_flags;</a>
<a name="ln2097">    case PV_INEX:       return &amp;wp-&gt;w_buffer-&gt;b_p_inex_flags;</a>
<a name="ln2098">    }</a>
<a name="ln2099"> </a>
<a name="ln2100">  // Nothing special, return global flags field.</a>
<a name="ln2101">  return &amp;options[opt_idx].flags;</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104"> </a>
<a name="ln2105">/// Redraw the window title and/or tab page text later.</a>
<a name="ln2106">static void redraw_titles(void)</a>
<a name="ln2107">{</a>
<a name="ln2108">  need_maketitle = true;</a>
<a name="ln2109">  redraw_tabline = true;</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">static int shada_idx = -1;</a>
<a name="ln2113"> </a>
<a name="ln2114">// Set a string option to a new value (without checking the effect).</a>
<a name="ln2115">// The string is copied into allocated memory.</a>
<a name="ln2116">// if (&quot;opt_idx&quot; == -1) &quot;name&quot; is used, otherwise &quot;opt_idx&quot; is used.</a>
<a name="ln2117">// When &quot;set_sid&quot; is zero set the scriptID to current_sctx.sc_sid.  When</a>
<a name="ln2118">// &quot;set_sid&quot; is SID_NONE don't set the scriptID.  Otherwise set the scriptID to</a>
<a name="ln2119">// &quot;set_sid&quot;.</a>
<a name="ln2120">void</a>
<a name="ln2121">set_string_option_direct(</a>
<a name="ln2122">    char_u *name,</a>
<a name="ln2123">    int opt_idx,</a>
<a name="ln2124">    char_u *val,</a>
<a name="ln2125">    int opt_flags,                  // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2126">    int set_sid</a>
<a name="ln2127">)</a>
<a name="ln2128">{</a>
<a name="ln2129">  char_u      *s;</a>
<a name="ln2130">  char_u      **varp;</a>
<a name="ln2131">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln2132">  int idx = opt_idx;</a>
<a name="ln2133"> </a>
<a name="ln2134">  if (idx == -1) {  // Use name.</a>
<a name="ln2135">    idx = findoption((const char *)name);</a>
<a name="ln2136">    if (idx &lt; 0) {  // Not found (should not happen).</a>
<a name="ln2137">      internal_error(&quot;set_string_option_direct()&quot;);</a>
<a name="ln2138">      IEMSG2(_(&quot;For option %s&quot;), name);</a>
<a name="ln2139">      return;</a>
<a name="ln2140">    }</a>
<a name="ln2141">  }</a>
<a name="ln2142"> </a>
<a name="ln2143">  if (options[idx].var == NULL) {       // can't set hidden option</a>
<a name="ln2144">    return;</a>
<a name="ln2145">  }</a>
<a name="ln2146"> </a>
<a name="ln2147">  assert((void *) options[idx].var != (void *) &amp;p_shada);</a>
<a name="ln2148"> </a>
<a name="ln2149">  s = vim_strsave(val);</a>
<a name="ln2150">  {</a>
<a name="ln2151">    varp = (char_u **)get_varp_scope(&amp;(options[idx]),</a>
<a name="ln2152">                                     both ? OPT_LOCAL : opt_flags);</a>
<a name="ln2153">    if ((opt_flags &amp; OPT_FREE) &amp;&amp; (options[idx].flags &amp; P_ALLOCED)) {</a>
<a name="ln2154">      free_string_option(*varp);</a>
<a name="ln2155">    }</a>
<a name="ln2156">    *varp = s;</a>
<a name="ln2157"> </a>
<a name="ln2158">    // For buffer/window local option may also set the global value.</a>
<a name="ln2159">    if (both) {</a>
<a name="ln2160">      set_string_option_global(idx, varp);</a>
<a name="ln2161">    }</a>
<a name="ln2162"> </a>
<a name="ln2163">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln2164"> </a>
<a name="ln2165">    /* When setting both values of a global option with a local value,</a>
<a name="ln2166">    * make the local value empty, so that the global value is used. */</a>
<a name="ln2167">    if (((int)options[idx].indir &amp; PV_BOTH) &amp;&amp; both) {</a>
<a name="ln2168">      free_string_option(*varp);</a>
<a name="ln2169">      *varp = empty_option;</a>
<a name="ln2170">    }</a>
<a name="ln2171">    if (set_sid != SID_NONE) {</a>
<a name="ln2172">      sctx_T script_ctx;</a>
<a name="ln2173"> </a>
<a name="ln2174">      if (set_sid == 0) {</a>
<a name="ln2175">        script_ctx = current_sctx;</a>
<a name="ln2176">      } else {</a>
<a name="ln2177">        script_ctx.sc_sid = set_sid;</a>
<a name="ln2178">        script_ctx.sc_seq = 0;</a>
<a name="ln2179">        script_ctx.sc_lnum = 0;</a>
<a name="ln2180">      }</a>
<a name="ln2181">      set_option_sctx_idx(idx, opt_flags, script_ctx);</a>
<a name="ln2182">    }</a>
<a name="ln2183">  }</a>
<a name="ln2184">}</a>
<a name="ln2185"> </a>
<a name="ln2186">/// Set global value for string option when it's a local option.</a>
<a name="ln2187">static void</a>
<a name="ln2188">set_string_option_global(</a>
<a name="ln2189">    int opt_idx,                    // option index</a>
<a name="ln2190">    char_u **varp             // pointer to option variable</a>
<a name="ln2191">)</a>
<a name="ln2192">{</a>
<a name="ln2193">  char_u      **p, *s;</a>
<a name="ln2194"> </a>
<a name="ln2195">  // the global value is always allocated</a>
<a name="ln2196">  if (options[opt_idx].var == VAR_WIN) {</a>
<a name="ln2197">    p = (char_u **)GLOBAL_WO(varp);</a>
<a name="ln2198">  } else {</a>
<a name="ln2199">    p = (char_u **)options[opt_idx].var;</a>
<a name="ln2200">  }</a>
<a name="ln2201">  if (options[opt_idx].indir != PV_NONE &amp;&amp; p != varp) {</a>
<a name="ln2202">    s = vim_strsave(*varp);</a>
<a name="ln2203">    free_string_option(*p);</a>
<a name="ln2204">    *p = s;</a>
<a name="ln2205">  }</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">/// Set a string option to a new value, handling the effects</a>
<a name="ln2209">///</a>
<a name="ln2210">/// @param[in]  opt_idx  Option to set.</a>
<a name="ln2211">/// @param[in]  value  New value.</a>
<a name="ln2212">/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or</a>
<a name="ln2213">///                        #OPT_GLOBAL.</a>
<a name="ln2214">///</a>
<a name="ln2215">/// @return NULL on success, error message on error.</a>
<a name="ln2216">static char *set_string_option(const int opt_idx, const char *const value,</a>
<a name="ln2217">                               const int opt_flags)</a>
<a name="ln2218">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2219">{</a>
<a name="ln2220">  if (options[opt_idx].var == NULL) {  // don't set hidden option</a>
<a name="ln2221">    return NULL;</a>
<a name="ln2222">  }</a>
<a name="ln2223"> </a>
<a name="ln2224">  char *const s = xstrdup(value);</a>
<a name="ln2225">  char **const varp = (char **)get_varp_scope(</a>
<a name="ln2226">      &amp;(options[opt_idx]),</a>
<a name="ln2227">      ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln2228">       ? (((int)options[opt_idx].indir &amp; PV_BOTH)</a>
<a name="ln2229">          ? OPT_GLOBAL : OPT_LOCAL)</a>
<a name="ln2230">       : opt_flags));</a>
<a name="ln2231">  char *const oldval = *varp;</a>
<a name="ln2232">  *varp = s;</a>
<a name="ln2233"> </a>
<a name="ln2234">  char *const saved_oldval = xstrdup(oldval);</a>
<a name="ln2235">  char *const saved_newval = xstrdup(s);</a>
<a name="ln2236"> </a>
<a name="ln2237">  int value_checked = false;</a>
<a name="ln2238">  char *const r = (char *)did_set_string_option(</a>
<a name="ln2239">      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval,</a>
<a name="ln2240">      NULL, 0, opt_flags, &amp;value_checked);</a>
<a name="ln2241">  if (r == NULL) {</a>
<a name="ln2242">    did_set_option(opt_idx, opt_flags, true, value_checked);</a>
<a name="ln2243">  }</a>
<a name="ln2244"> </a>
<a name="ln2245">  // call autocommand after handling side effects</a>
<a name="ln2246">  if (r == NULL) {</a>
<a name="ln2247">    if (!starting) {</a>
<a name="ln2248">      trigger_optionsset_string(opt_idx, opt_flags, saved_oldval, saved_newval);</a>
<a name="ln2249">    }</a>
<a name="ln2250">    if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2251">      ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2252">                         STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln2253">    }</a>
<a name="ln2254">  }</a>
<a name="ln2255">  xfree(saved_oldval);</a>
<a name="ln2256">  xfree(saved_newval);</a>
<a name="ln2257"> </a>
<a name="ln2258">  return r;</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">/// Return true if &quot;val&quot; is a valid name: only consists of alphanumeric ASCII</a>
<a name="ln2262">/// characters or characters in &quot;allowed&quot;.</a>
<a name="ln2263">static bool valid_name(const char_u *val, const char *allowed)</a>
<a name="ln2264">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2265">{</a>
<a name="ln2266">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2267">    if (!ASCII_ISALNUM(*s)</a>
<a name="ln2268">        &amp;&amp; vim_strchr((const char_u *)allowed, *s) == NULL) {</a>
<a name="ln2269">      return false;</a>
<a name="ln2270">    }</a>
<a name="ln2271">  }</a>
<a name="ln2272">  return true;</a>
<a name="ln2273">}</a>
<a name="ln2274"> </a>
<a name="ln2275">/// Return true if &quot;val&quot; is a valid 'filetype' name.</a>
<a name="ln2276">/// Also used for 'syntax' and 'keymap'.</a>
<a name="ln2277">static bool valid_filetype(const char_u *val)</a>
<a name="ln2278">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2279">{</a>
<a name="ln2280">  return valid_name(val, &quot;.-_&quot;);</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283">/// Return true if &quot;val&quot; is a valid 'spelllang' value.</a>
<a name="ln2284">bool valid_spelllang(const char_u *val)</a>
<a name="ln2285">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2286">{</a>
<a name="ln2287">  return valid_name(val, &quot;.-_,@&quot;);</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/// Return true if &quot;val&quot; is a valid 'spellfile' value.</a>
<a name="ln2291">static bool valid_spellfile(const char_u *val)</a>
<a name="ln2292">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2293">{</a>
<a name="ln2294">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2295">    if (!vim_isfilec(*s) &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2296">      return false;</a>
<a name="ln2297">    }</a>
<a name="ln2298">  }</a>
<a name="ln2299">  return true;</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">/// Handle string options that need some action to perform when changed.</a>
<a name="ln2303">/// Returns NULL for success, or an error message for an error.</a>
<a name="ln2304">static char_u *</a>
<a name="ln2305">did_set_string_option(</a>
<a name="ln2306">    int opt_idx,                       // index in options[] table</a>
<a name="ln2307">    char_u **varp,                     // pointer to the option variable</a>
<a name="ln2308">    int new_value_alloced,             // new value was allocated</a>
<a name="ln2309">    char_u *oldval,                    // previous value of the option</a>
<a name="ln2310">    char_u *errbuf,                    // buffer for errors, or NULL</a>
<a name="ln2311">    size_t errbuflen,                  // length of errors buffer</a>
<a name="ln2312">    int opt_flags,                     // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2313">    int *value_checked                 // value was checked to be safe, no</a>
<a name="ln2314">                                       // need to set P_INSECURE</a>
<a name="ln2315">)</a>
<a name="ln2316">{</a>
<a name="ln2317">  char_u      *errmsg = NULL;</a>
<a name="ln2318">  char_u      *s, *p;</a>
<a name="ln2319">  int did_chartab = false;</a>
<a name="ln2320">  char_u      **gvarp;</a>
<a name="ln2321">  bool free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2322">  bool value_changed = false;</a>
<a name="ln2323"> </a>
<a name="ln2324">  /* Get the global option to compare with, otherwise we would have to check</a>
<a name="ln2325">   * two values for all local options. */</a>
<a name="ln2326">  gvarp = (char_u **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln2327"> </a>
<a name="ln2328">  // Disallow changing some options from secure mode</a>
<a name="ln2329">  if ((secure || sandbox != 0)</a>
<a name="ln2330">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln2331">    errmsg = e_secure;</a>
<a name="ln2332">  } else if (((options[opt_idx].flags &amp; P_NFNAME)</a>
<a name="ln2333">              &amp;&amp; vim_strpbrk(*varp, (char_u *)(secure ? &quot;/\\*?[|;&amp;&lt;&gt;\r\n&quot;</a>
<a name="ln2334">                                               : &quot;/\\*?[&lt;&gt;\r\n&quot;)) != NULL)</a>
<a name="ln2335">             || ((options[opt_idx].flags &amp; P_NDNAME)</a>
<a name="ln2336">                 &amp;&amp; vim_strpbrk(*varp, (char_u *)&quot;*?[|;&amp;&lt;&gt;\r\n&quot;) != NULL)) {</a>
<a name="ln2337">    // Check for a &quot;normal&quot; directory or file name in some options.  Disallow a</a>
<a name="ln2338">    // path separator (slash and/or backslash), wildcards and characters that</a>
<a name="ln2339">    // are often illegal in a file name. Be more permissive if &quot;secure&quot; is off.</a>
<a name="ln2340">    errmsg = e_invarg;</a>
<a name="ln2341">  } else if (gvarp == &amp;p_bkc) {  // 'backupcopy'</a>
<a name="ln2342">    char_u       *bkc   = p_bkc;</a>
<a name="ln2343">    unsigned int *flags = &amp;bkc_flags;</a>
<a name="ln2344"> </a>
<a name="ln2345">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2346">      bkc   = curbuf-&gt;b_p_bkc;</a>
<a name="ln2347">      flags = &amp;curbuf-&gt;b_bkc_flags;</a>
<a name="ln2348">    }</a>
<a name="ln2349"> </a>
<a name="ln2350">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *bkc == NUL) {</a>
<a name="ln2351">      // make the local value empty: use the global value</a>
<a name="ln2352">      *flags = 0;</a>
<a name="ln2353">    } else {</a>
<a name="ln2354">      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {</a>
<a name="ln2355">        errmsg = e_invarg;</a>
<a name="ln2356">      }</a>
<a name="ln2357"> </a>
<a name="ln2358">      if (((*flags &amp; BKC_AUTO) != 0)</a>
<a name="ln2359">          + ((*flags &amp; BKC_YES) != 0)</a>
<a name="ln2360">          + ((*flags &amp; BKC_NO) != 0) != 1) {</a>
<a name="ln2361">        // Must have exactly one of &quot;auto&quot;, &quot;yes&quot;  and &quot;no&quot;.</a>
<a name="ln2362">        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);</a>
<a name="ln2363">        errmsg = e_invarg;</a>
<a name="ln2364">      }</a>
<a name="ln2365">    }</a>
<a name="ln2366">  } else if (varp == &amp;p_bex || varp == &amp;p_pm) {  // 'backupext' and 'patchmode'</a>
<a name="ln2367">    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,</a>
<a name="ln2368">               *p_pm == '.' ? p_pm + 1 : p_pm) == 0) {</a>
<a name="ln2369">      errmsg = (char_u *)N_(&quot;E589: 'backupext' and 'patchmode' are equal&quot;);</a>
<a name="ln2370">    }</a>
<a name="ln2371">  } else if (varp == &amp;curwin-&gt;w_p_briopt) {  // 'breakindentopt'</a>
<a name="ln2372">    if (briopt_check(curwin) == FAIL) {</a>
<a name="ln2373">      errmsg = e_invarg;</a>
<a name="ln2374">    }</a>
<a name="ln2375">  } else if (varp == &amp;p_isi</a>
<a name="ln2376">             || varp == &amp;(curbuf-&gt;b_p_isk)</a>
<a name="ln2377">             || varp == &amp;p_isp</a>
<a name="ln2378">             || varp == &amp;p_isf) {</a>
<a name="ln2379">    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]</a>
<a name="ln2380">    // If the new option is invalid, use old value.  'lisp' option: refill</a>
<a name="ln2381">    // g_chartab[] for '-' char</a>
<a name="ln2382">    if (init_chartab() == FAIL) {</a>
<a name="ln2383">      did_chartab = true;           // need to restore it below</a>
<a name="ln2384">      errmsg = e_invarg;            // error in value</a>
<a name="ln2385">    }</a>
<a name="ln2386">  } else if (varp == &amp;p_hf) {  // 'helpfile'</a>
<a name="ln2387">    // May compute new values for $VIM and $VIMRUNTIME</a>
<a name="ln2388">    if (didset_vim) {</a>
<a name="ln2389">      os_setenv(&quot;VIM&quot;, &quot;&quot;, 1);</a>
<a name="ln2390">      didset_vim = false;</a>
<a name="ln2391">    }</a>
<a name="ln2392">    if (didset_vimruntime) {</a>
<a name="ln2393">      os_setenv(&quot;VIMRUNTIME&quot;, &quot;&quot;, 1);</a>
<a name="ln2394">      didset_vimruntime = false;</a>
<a name="ln2395">    }</a>
<a name="ln2396">  } else if (varp == &amp;curwin-&gt;w_p_cc) {  // 'colorcolumn'</a>
<a name="ln2397">    errmsg = check_colorcolumn(curwin);</a>
<a name="ln2398">  } else if (varp == &amp;p_hlg) {  // 'helplang'</a>
<a name="ln2399">    // Check for &quot;&quot;, &quot;ab&quot;, &quot;ab,cd&quot;, etc.</a>
<a name="ln2400">    for (s = p_hlg; *s != NUL; s += 3) {</a>
<a name="ln2401">      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) &amp;&amp; s[2] != NUL)) {</a>
<a name="ln2402">        errmsg = e_invarg;</a>
<a name="ln2403">        break;</a>
<a name="ln2404">      }</a>
<a name="ln2405">      if (s[2] == NUL) {</a>
<a name="ln2406">        break;</a>
<a name="ln2407">      }</a>
<a name="ln2408">    }</a>
<a name="ln2409">  } else if (varp == &amp;p_hl) {</a>
<a name="ln2410">    // 'highlight'</a>
<a name="ln2411">    if (strcmp((char *)(*varp), HIGHLIGHT_INIT) != 0) {</a>
<a name="ln2412">      errmsg = e_unsupportedoption;</a>
<a name="ln2413">    }</a>
<a name="ln2414">  } else if (varp == &amp;p_jop) {  // 'jumpoptions'</a>
<a name="ln2415">    if (opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true) != OK) {</a>
<a name="ln2416">      errmsg = e_invarg;</a>
<a name="ln2417">    }</a>
<a name="ln2418">  } else if (gvarp == &amp;p_nf) {  // 'nrformats'</a>
<a name="ln2419">    if (check_opt_strings(*varp, p_nf_values, true) != OK) {</a>
<a name="ln2420">      errmsg = e_invarg;</a>
<a name="ln2421">    }</a>
<a name="ln2422">  } else if (varp == &amp;p_ssop) {  // 'sessionoptions'</a>
<a name="ln2423">    if (opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true) != OK) {</a>
<a name="ln2424">      errmsg = e_invarg;</a>
<a name="ln2425">    }</a>
<a name="ln2426">    if ((ssop_flags &amp; SSOP_CURDIR) &amp;&amp; (ssop_flags &amp; SSOP_SESDIR)) {</a>
<a name="ln2427">      // Don't allow both &quot;sesdir&quot; and &quot;curdir&quot;.</a>
<a name="ln2428">      (void)opt_strings_flags(oldval, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln2429">      errmsg = e_invarg;</a>
<a name="ln2430">    }</a>
<a name="ln2431">  } else if (varp == &amp;p_vop) {  // 'viewoptions'</a>
<a name="ln2432">    if (opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true) != OK) {</a>
<a name="ln2433">      errmsg = e_invarg;</a>
<a name="ln2434">    }</a>
<a name="ln2435">  } else if (varp == &amp;p_rdb) {  // 'redrawdebug'</a>
<a name="ln2436">    if (opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true) != OK) {</a>
<a name="ln2437">      errmsg = e_invarg;</a>
<a name="ln2438">    }</a>
<a name="ln2439">  } else if (varp == &amp;p_sbo) {  // 'scrollopt'</a>
<a name="ln2440">    if (check_opt_strings(p_sbo, p_scbopt_values, true) != OK) {</a>
<a name="ln2441">      errmsg = e_invarg;</a>
<a name="ln2442">    }</a>
<a name="ln2443">  } else if (varp == &amp;p_ambw || (int *)varp == &amp;p_emoji) {</a>
<a name="ln2444">    // 'ambiwidth'</a>
<a name="ln2445">    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {</a>
<a name="ln2446">      errmsg = e_invarg;</a>
<a name="ln2447">    } else {</a>
<a name="ln2448">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2449">        if (set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true) != NULL) {</a>
<a name="ln2450">          errmsg = (char_u *)_(&quot;E834: Conflicts with value of 'listchars'&quot;);</a>
<a name="ln2451">          goto ambw_end;</a>
<a name="ln2452">        }</a>
<a name="ln2453">        if (set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true) != NULL) {</a>
<a name="ln2454">          errmsg = (char_u *)_(&quot;E835: Conflicts with value of 'fillchars'&quot;);</a>
<a name="ln2455">          goto ambw_end;</a>
<a name="ln2456">        }</a>
<a name="ln2457">      }</a>
<a name="ln2458">ambw_end:</a>
<a name="ln2459">      {}  // clint prefers {} over ; as an empty statement</a>
<a name="ln2460">    }</a>
<a name="ln2461">  } else if (varp == &amp;p_bg) {  // 'background'</a>
<a name="ln2462">    if (check_opt_strings(p_bg, p_bg_values, false) == OK) {</a>
<a name="ln2463">      int dark = (*p_bg == 'd');</a>
<a name="ln2464"> </a>
<a name="ln2465">      init_highlight(false, false);</a>
<a name="ln2466"> </a>
<a name="ln2467">      if (dark != (*p_bg == 'd') &amp;&amp; get_var_value(&quot;g:colors_name&quot;) != NULL) {</a>
<a name="ln2468">        // The color scheme must have set 'background' back to another</a>
<a name="ln2469">        // value, that's not what we want here.  Disable the color</a>
<a name="ln2470">        // scheme and set the colors again.</a>
<a name="ln2471">        do_unlet(S_LEN(&quot;g:colors_name&quot;), true);</a>
<a name="ln2472">        free_string_option(p_bg);</a>
<a name="ln2473">        p_bg = vim_strsave((char_u *)(dark ? &quot;dark&quot; : &quot;light&quot;));</a>
<a name="ln2474">        check_string_option(&amp;p_bg);</a>
<a name="ln2475">        init_highlight(false, false);</a>
<a name="ln2476">      }</a>
<a name="ln2477">    } else</a>
<a name="ln2478">      errmsg = e_invarg;</a>
<a name="ln2479">  } else if (varp == &amp;p_wim) {  // 'wildmode'</a>
<a name="ln2480">    if (check_opt_wim() == FAIL) {</a>
<a name="ln2481">      errmsg = e_invarg;</a>
<a name="ln2482">    }</a>
<a name="ln2483">  // 'wildoptions'</a>
<a name="ln2484">  } else if (varp == &amp;p_wop) {</a>
<a name="ln2485">    if (opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true) != OK) {</a>
<a name="ln2486">      errmsg = e_invarg;</a>
<a name="ln2487">    }</a>
<a name="ln2488">  } else if (varp == &amp;p_wak) {  // 'winaltkeys'</a>
<a name="ln2489">    if (*p_wak == NUL</a>
<a name="ln2490">        || check_opt_strings(p_wak, p_wak_values, false) != OK) {</a>
<a name="ln2491">      errmsg = e_invarg;</a>
<a name="ln2492">    }</a>
<a name="ln2493">  } else if (varp == &amp;p_ei) {  // 'eventignore'</a>
<a name="ln2494">    if (check_ei() == FAIL) {</a>
<a name="ln2495">      errmsg = e_invarg;</a>
<a name="ln2496">    }</a>
<a name="ln2497">  // 'encoding', 'fileencoding' and 'makeencoding'</a>
<a name="ln2498">  } else if (varp == &amp;p_enc || gvarp == &amp;p_fenc || gvarp == &amp;p_menc) {</a>
<a name="ln2499">    if (gvarp == &amp;p_fenc) {</a>
<a name="ln2500">      if (!MODIFIABLE(curbuf) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln2501">        errmsg = e_modifiable;</a>
<a name="ln2502">      } else if (vim_strchr(*varp, ',') != NULL) {</a>
<a name="ln2503">        // No comma allowed in 'fileencoding'; catches confusing it</a>
<a name="ln2504">        // with 'fileencodings'.</a>
<a name="ln2505">        errmsg = e_invarg;</a>
<a name="ln2506">      } else {</a>
<a name="ln2507">        // May show a &quot;+&quot; in the title now.</a>
<a name="ln2508">        redraw_titles();</a>
<a name="ln2509">        // Add 'fileencoding' to the swap file.</a>
<a name="ln2510">        ml_setflags(curbuf);</a>
<a name="ln2511">      }</a>
<a name="ln2512">    }</a>
<a name="ln2513"> </a>
<a name="ln2514">    if (errmsg == NULL) {</a>
<a name="ln2515">      // canonize the value, so that STRCMP() can be used on it</a>
<a name="ln2516">      p = enc_canonize(*varp);</a>
<a name="ln2517">      xfree(*varp);</a>
<a name="ln2518">      *varp = p;</a>
<a name="ln2519">      if (varp == &amp;p_enc) {</a>
<a name="ln2520">        // only encoding=utf-8 allowed</a>
<a name="ln2521">        if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln2522">          errmsg = e_unsupportedoption;</a>
<a name="ln2523">        }</a>
<a name="ln2524">      }</a>
<a name="ln2525">    }</a>
<a name="ln2526">  } else if (varp == &amp;p_penc) {</a>
<a name="ln2527">    // Canonize printencoding if VIM standard one</a>
<a name="ln2528">    p = enc_canonize(p_penc);</a>
<a name="ln2529">    xfree(p_penc);</a>
<a name="ln2530">    p_penc = p;</a>
<a name="ln2531">  } else if (varp == &amp;curbuf-&gt;b_p_keymap) {</a>
<a name="ln2532">    if (!valid_filetype(*varp)) {</a>
<a name="ln2533">      errmsg = e_invarg;</a>
<a name="ln2534">    } else {</a>
<a name="ln2535">      int secure_save = secure;</a>
<a name="ln2536"> </a>
<a name="ln2537">      // Reset the secure flag, since the value of 'keymap' has</a>
<a name="ln2538">      // been checked to be safe.</a>
<a name="ln2539">      secure = 0;</a>
<a name="ln2540"> </a>
<a name="ln2541">      // load or unload key mapping tables</a>
<a name="ln2542">      errmsg = keymap_init();</a>
<a name="ln2543"> </a>
<a name="ln2544">      secure = secure_save;</a>
<a name="ln2545"> </a>
<a name="ln2546">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln2547">      // even when the value comes from a modeline.</a>
<a name="ln2548">      *value_checked = true;</a>
<a name="ln2549">    }</a>
<a name="ln2550"> </a>
<a name="ln2551">    if (errmsg == NULL) {</a>
<a name="ln2552">      if (*curbuf-&gt;b_p_keymap != NUL) {</a>
<a name="ln2553">        // Installed a new keymap, switch on using it.</a>
<a name="ln2554">        curbuf-&gt;b_p_iminsert = B_IMODE_LMAP;</a>
<a name="ln2555">        if (curbuf-&gt;b_p_imsearch != B_IMODE_USE_INSERT) {</a>
<a name="ln2556">          curbuf-&gt;b_p_imsearch = B_IMODE_LMAP;</a>
<a name="ln2557">        }</a>
<a name="ln2558">      } else {</a>
<a name="ln2559">        // Cleared the keymap, may reset 'iminsert' and 'imsearch'.</a>
<a name="ln2560">        if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln2561">          curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln2562">        }</a>
<a name="ln2563">        if (curbuf-&gt;b_p_imsearch == B_IMODE_LMAP) {</a>
<a name="ln2564">          curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln2565">        }</a>
<a name="ln2566">      }</a>
<a name="ln2567">      if ((opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln2568">        set_iminsert_global();</a>
<a name="ln2569">        set_imsearch_global();</a>
<a name="ln2570">      }</a>
<a name="ln2571">      status_redraw_curbuf();</a>
<a name="ln2572">    }</a>
<a name="ln2573">  } else if (gvarp == &amp;p_ff) {  // 'fileformat'</a>
<a name="ln2574">    if (!MODIFIABLE(curbuf) &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln2575">      errmsg = e_modifiable;</a>
<a name="ln2576">    } else if (check_opt_strings(*varp, p_ff_values, false) != OK) {</a>
<a name="ln2577">      errmsg = e_invarg;</a>
<a name="ln2578">    } else {</a>
<a name="ln2579">      redraw_titles();</a>
<a name="ln2580">      // update flag in swap file</a>
<a name="ln2581">      ml_setflags(curbuf);</a>
<a name="ln2582">      /* Redraw needed when switching to/from &quot;mac&quot;: a CR in the text</a>
<a name="ln2583">       * will be displayed differently. */</a>
<a name="ln2584">      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm') {</a>
<a name="ln2585">        redraw_curbuf_later(NOT_VALID);</a>
<a name="ln2586">      }</a>
<a name="ln2587">    }</a>
<a name="ln2588">  } else if (varp == &amp;p_ffs) {  // 'fileformats'</a>
<a name="ln2589">    if (check_opt_strings(p_ffs, p_ff_values, true) != OK) {</a>
<a name="ln2590">      errmsg = e_invarg;</a>
<a name="ln2591">    }</a>
<a name="ln2592">  } else if (gvarp == &amp;p_mps) {  // 'matchpairs'</a>
<a name="ln2593">    for (p = *varp; *p != NUL; p++) {</a>
<a name="ln2594">      int x2 = -1;</a>
<a name="ln2595">      int x3 = -1;</a>
<a name="ln2596"> </a>
<a name="ln2597">      if (*p != NUL) {</a>
<a name="ln2598">        p += utfc_ptr2len(p);</a>
<a name="ln2599">      }</a>
<a name="ln2600">      if (*p != NUL) {</a>
<a name="ln2601">        x2 = *p++;</a>
<a name="ln2602">      }</a>
<a name="ln2603">      if (*p != NUL) {</a>
<a name="ln2604">        x3 = utf_ptr2char(p);</a>
<a name="ln2605">        p += utfc_ptr2len(p);</a>
<a name="ln2606">      }</a>
<a name="ln2607">      if (x2 != ':' || x3 == -1 || (*p != NUL &amp;&amp; *p != ',')) {</a>
<a name="ln2608">        errmsg = e_invarg;</a>
<a name="ln2609">        break;</a>
<a name="ln2610">      }</a>
<a name="ln2611">      if (*p == NUL) {</a>
<a name="ln2612">        break;</a>
<a name="ln2613">      }</a>
<a name="ln2614">    }</a>
<a name="ln2615">  } else if (gvarp == &amp;p_com) {  // 'comments'</a>
<a name="ln2616">    for (s = *varp; *s; ) {</a>
<a name="ln2617">      while (*s &amp;&amp; *s != ':') {</a>
<a name="ln2618">        if (vim_strchr((char_u *)COM_ALL, *s) == NULL</a>
<a name="ln2619">            &amp;&amp; !ascii_isdigit(*s) &amp;&amp; *s != '-') {</a>
<a name="ln2620">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2621">          break;</a>
<a name="ln2622">        }</a>
<a name="ln2623">        s++;</a>
<a name="ln2624">      }</a>
<a name="ln2625">      if (*s++ == NUL) {</a>
<a name="ln2626">        errmsg = (char_u *)N_(&quot;E524: Missing colon&quot;);</a>
<a name="ln2627">      } else if (*s == ',' || *s == NUL) {</a>
<a name="ln2628">        errmsg = (char_u *)N_(&quot;E525: Zero length string&quot;);</a>
<a name="ln2629">      }</a>
<a name="ln2630">      if (errmsg != NULL) {</a>
<a name="ln2631">        break;</a>
<a name="ln2632">      }</a>
<a name="ln2633">      while (*s &amp;&amp; *s != ',') {</a>
<a name="ln2634">        if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2635">          s++;</a>
<a name="ln2636">        }</a>
<a name="ln2637">        s++;</a>
<a name="ln2638">      }</a>
<a name="ln2639">      s = skip_to_option_part(s);</a>
<a name="ln2640">    }</a>
<a name="ln2641">  } else if (varp == &amp;p_lcs) {  // 'listchars'</a>
<a name="ln2642">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2643">    if (!errmsg) {</a>
<a name="ln2644">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2645">        set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln2646">      }</a>
<a name="ln2647">    }</a>
<a name="ln2648">    redraw_all_later(NOT_VALID);</a>
<a name="ln2649">  } else if (varp == &amp;curwin-&gt;w_p_lcs) {  // local 'listchars'</a>
<a name="ln2650">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2651">  } else if (varp == &amp;p_fcs) {  // 'fillchars'</a>
<a name="ln2652">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2653">    if (!errmsg) {</a>
<a name="ln2654">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2655">        set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln2656">      }</a>
<a name="ln2657">    }</a>
<a name="ln2658">    redraw_all_later(NOT_VALID);</a>
<a name="ln2659">  } else if (varp == &amp;curwin-&gt;w_p_fcs) {  // local 'fillchars'</a>
<a name="ln2660">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2661">  } else if (varp == &amp;p_cedit) {  // 'cedit'</a>
<a name="ln2662">    errmsg = check_cedit();</a>
<a name="ln2663">  } else if (varp == &amp;p_vfile) {  // 'verbosefile'</a>
<a name="ln2664">    verbose_stop();</a>
<a name="ln2665">    if (*p_vfile != NUL &amp;&amp; verbose_open() == FAIL) {</a>
<a name="ln2666">      errmsg = e_invarg;</a>
<a name="ln2667">    }</a>
<a name="ln2668">  // 'shada'</a>
<a name="ln2669">  } else if (varp == &amp;p_shada) {</a>
<a name="ln2670">    // TODO(ZyX-I): Remove this code in the future, alongside with &amp;viminfo</a>
<a name="ln2671">    //              option.</a>
<a name="ln2672">    opt_idx = ((options[opt_idx].fullname[0] == 'v')</a>
<a name="ln2673">               ? (shada_idx == -1</a>
<a name="ln2674">                  ? ((shada_idx = findoption(&quot;shada&quot;)))</a>
<a name="ln2675">                  : shada_idx)</a>
<a name="ln2676">               : opt_idx);</a>
<a name="ln2677">    // Update free_oldval now that we have the opt_idx for 'shada', otherwise</a>
<a name="ln2678">    // there would be a disconnect between the check for P_ALLOCED at the start</a>
<a name="ln2679">    // of the function and the set of P_ALLOCED at the end of the fuction.</a>
<a name="ln2680">    free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2681">    for (s = p_shada; *s; ) {</a>
<a name="ln2682">      // Check it's a valid character</a>
<a name="ln2683">      if (vim_strchr((char_u *)&quot;!\&quot;%'/:&lt;@cfhnrs&quot;, *s) == NULL) {</a>
<a name="ln2684">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2685">        break;</a>
<a name="ln2686">      }</a>
<a name="ln2687">      if (*s == 'n') {          // name is always last one</a>
<a name="ln2688">        break;</a>
<a name="ln2689">      } else if (*s == 'r') {  // skip until next ','</a>
<a name="ln2690">        while (*++s &amp;&amp; *s != ',') {}</a>
<a name="ln2691">      } else if (*s == '%') {</a>
<a name="ln2692">        // optional number</a>
<a name="ln2693">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2694">      } else if (*s == '!' || *s == 'h' || *s == 'c') {</a>
<a name="ln2695">        s++;                    // no extra chars</a>
<a name="ln2696">      } else {                    // must have a number</a>
<a name="ln2697">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2698"> </a>
<a name="ln2699">        if (!ascii_isdigit(*(s - 1))) {</a>
<a name="ln2700">          if (errbuf != NULL) {</a>
<a name="ln2701">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2702">                         _(&quot;E526: Missing number after &lt;%s&gt;&quot;),</a>
<a name="ln2703">                         transchar_byte(*(s - 1)));</a>
<a name="ln2704">            errmsg = errbuf;</a>
<a name="ln2705">          } else</a>
<a name="ln2706">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2707">          break;</a>
<a name="ln2708">        }</a>
<a name="ln2709">      }</a>
<a name="ln2710">      if (*s == ',') {</a>
<a name="ln2711">        s++;</a>
<a name="ln2712">      } else if (*s) {</a>
<a name="ln2713">        if (errbuf != NULL) {</a>
<a name="ln2714">          errmsg = (char_u *)N_(&quot;E527: Missing comma&quot;);</a>
<a name="ln2715">        } else {</a>
<a name="ln2716">          errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2717">        }</a>
<a name="ln2718">        break;</a>
<a name="ln2719">      }</a>
<a name="ln2720">    }</a>
<a name="ln2721">    if (*p_shada &amp;&amp; errmsg == NULL &amp;&amp; get_shada_parameter('\'') &lt; 0) {</a>
<a name="ln2722">      errmsg = (char_u *)N_(&quot;E528: Must specify a ' value&quot;);</a>
<a name="ln2723">    }</a>
<a name="ln2724">  } else if (varp == &amp;p_sbr) {  // 'showbreak'</a>
<a name="ln2725">    for (s = p_sbr; *s; ) {</a>
<a name="ln2726">      if (ptr2cells(s) != 1) {</a>
<a name="ln2727">        errmsg = (char_u *)N_(&quot;E595: contains unprintable or wide character&quot;);</a>
<a name="ln2728">      }</a>
<a name="ln2729">      MB_PTR_ADV(s);</a>
<a name="ln2730">    }</a>
<a name="ln2731">  } else if (varp == &amp;p_guicursor) {  // 'guicursor'</a>
<a name="ln2732">    errmsg = parse_shape_opt(SHAPE_CURSOR);</a>
<a name="ln2733">  } else if (varp == &amp;p_popt) {</a>
<a name="ln2734">    errmsg = parse_printoptions();</a>
<a name="ln2735">  } else if (varp == &amp;p_pmfn) {</a>
<a name="ln2736">    errmsg = parse_printmbfont();</a>
<a name="ln2737">  } else if (varp == &amp;p_langmap) {  // 'langmap'</a>
<a name="ln2738">    langmap_set();</a>
<a name="ln2739">  } else if (varp == &amp;p_breakat) {  // 'breakat'</a>
<a name="ln2740">    fill_breakat_flags();</a>
<a name="ln2741">  } else if (varp == &amp;p_titlestring || varp == &amp;p_iconstring) {</a>
<a name="ln2742">    // 'titlestring' and 'iconstring'</a>
<a name="ln2743">    int flagval = (varp == &amp;p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;</a>
<a name="ln2744"> </a>
<a name="ln2745">    // NULL =&gt; statusline syntax</a>
<a name="ln2746">    if (vim_strchr(*varp, '%') &amp;&amp; check_stl_option(*varp) == NULL) {</a>
<a name="ln2747">      stl_syntax |= flagval;</a>
<a name="ln2748">    } else {</a>
<a name="ln2749">      stl_syntax &amp;= ~flagval;</a>
<a name="ln2750">    }</a>
<a name="ln2751">    did_set_title();</a>
<a name="ln2752"> </a>
<a name="ln2753">  } else if (varp == &amp;p_sel) {  // 'selection'</a>
<a name="ln2754">    if (*p_sel == NUL</a>
<a name="ln2755">        || check_opt_strings(p_sel, p_sel_values, false) != OK) {</a>
<a name="ln2756">      errmsg = e_invarg;</a>
<a name="ln2757">    }</a>
<a name="ln2758">  } else if (varp == &amp;p_slm) {  // 'selectmode'</a>
<a name="ln2759">    if (check_opt_strings(p_slm, p_slm_values, true) != OK) {</a>
<a name="ln2760">      errmsg = e_invarg;</a>
<a name="ln2761">    }</a>
<a name="ln2762">  } else if (varp == &amp;p_km) {  // 'keymodel'</a>
<a name="ln2763">    if (check_opt_strings(p_km, p_km_values, true) != OK) {</a>
<a name="ln2764">      errmsg = e_invarg;</a>
<a name="ln2765">    } else {</a>
<a name="ln2766">      km_stopsel = (vim_strchr(p_km, 'o') != NULL);</a>
<a name="ln2767">      km_startsel = (vim_strchr(p_km, 'a') != NULL);</a>
<a name="ln2768">    }</a>
<a name="ln2769">  } else if (varp == &amp;p_mousem) {  // 'mousemodel'</a>
<a name="ln2770">    if (check_opt_strings(p_mousem, p_mousem_values, false) != OK) {</a>
<a name="ln2771">      errmsg = e_invarg;</a>
<a name="ln2772">    }</a>
<a name="ln2773">  } else if (varp == &amp;p_swb) {  // 'switchbuf'</a>
<a name="ln2774">    if (opt_strings_flags(p_swb, p_swb_values, &amp;swb_flags, true) != OK) {</a>
<a name="ln2775">      errmsg = e_invarg;</a>
<a name="ln2776">    }</a>
<a name="ln2777">  } else if (varp == &amp;p_debug) {  // 'debug'</a>
<a name="ln2778">    if (check_opt_strings(p_debug, p_debug_values, true) != OK) {</a>
<a name="ln2779">      errmsg = e_invarg;</a>
<a name="ln2780">    }</a>
<a name="ln2781">  } else if (varp == &amp;p_dy) {  // 'display'</a>
<a name="ln2782">    if (opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true) != OK) {</a>
<a name="ln2783">      errmsg = e_invarg;</a>
<a name="ln2784">    } else {</a>
<a name="ln2785">      (void)init_chartab();</a>
<a name="ln2786">      msg_grid_validate();</a>
<a name="ln2787">    }</a>
<a name="ln2788">  } else if (varp == &amp;p_ead) {  // 'eadirection'</a>
<a name="ln2789">    if (check_opt_strings(p_ead, p_ead_values, false) != OK) {</a>
<a name="ln2790">      errmsg = e_invarg;</a>
<a name="ln2791">    }</a>
<a name="ln2792">  } else if (varp == &amp;p_cb) {  // 'clipboard'</a>
<a name="ln2793">    if (opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true) != OK) {</a>
<a name="ln2794">      errmsg = e_invarg;</a>
<a name="ln2795">    }</a>
<a name="ln2796">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)  // 'spell'</a>
<a name="ln2797">             || varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf)) {</a>
<a name="ln2798">    // When 'spelllang' or 'spellfile' is set and there is a window for this</a>
<a name="ln2799">    // buffer in which 'spell' is set load the wordlists.</a>
<a name="ln2800">    const bool is_spellfile = varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln2801"> </a>
<a name="ln2802">    if ((is_spellfile &amp;&amp; !valid_spellfile(*varp))</a>
<a name="ln2803">        || (!is_spellfile &amp;&amp; !valid_spelllang(*varp))) {</a>
<a name="ln2804">      errmsg = e_invarg;</a>
<a name="ln2805">    } else {</a>
<a name="ln2806">      errmsg = did_set_spell_option(is_spellfile);</a>
<a name="ln2807">    }</a>
<a name="ln2808">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spc)) {</a>
<a name="ln2809">    // When 'spellcapcheck' is set compile the regexp program.</a>
<a name="ln2810">    errmsg = compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln2811">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spo)) {  // 'spelloptions'</a>
<a name="ln2812">    if (**varp != NUL &amp;&amp; STRCMP(&quot;camel&quot;, *varp) != 0) {</a>
<a name="ln2813">      errmsg = e_invarg;</a>
<a name="ln2814">    }</a>
<a name="ln2815">  } else if (varp == &amp;p_sps) {  // 'spellsuggest'</a>
<a name="ln2816">    if (spell_check_sps() != OK) {</a>
<a name="ln2817">      errmsg = e_invarg;</a>
<a name="ln2818">    }</a>
<a name="ln2819">  } else if (varp == &amp;p_msm) {  // 'mkspellmem'</a>
<a name="ln2820">    if (spell_check_msm() != OK) {</a>
<a name="ln2821">      errmsg = e_invarg;</a>
<a name="ln2822">    }</a>
<a name="ln2823">  } else if (gvarp == &amp;p_bh) {</a>
<a name="ln2824">    // When 'bufhidden' is set, check for valid value.</a>
<a name="ln2825">    if (check_opt_strings(curbuf-&gt;b_p_bh, p_bufhidden_values, false) != OK) {</a>
<a name="ln2826">      errmsg = e_invarg;</a>
<a name="ln2827">    }</a>
<a name="ln2828">  } else if (gvarp == &amp;p_bt) {</a>
<a name="ln2829">    // When 'buftype' is set, check for valid value.</a>
<a name="ln2830">    if ((curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] != 't')</a>
<a name="ln2831">        || (!curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] == 't')</a>
<a name="ln2832">        || check_opt_strings(curbuf-&gt;b_p_bt, p_buftype_values, false) != OK) {</a>
<a name="ln2833">      errmsg = e_invarg;</a>
<a name="ln2834">    } else {</a>
<a name="ln2835">      if (curwin-&gt;w_status_height) {</a>
<a name="ln2836">        curwin-&gt;w_redr_status = true;</a>
<a name="ln2837">        redraw_later(curwin, VALID);</a>
<a name="ln2838">      }</a>
<a name="ln2839">      curbuf-&gt;b_help = (curbuf-&gt;b_p_bt[0] == 'h');</a>
<a name="ln2840">      redraw_titles();</a>
<a name="ln2841">    }</a>
<a name="ln2842">  } else if (gvarp == &amp;p_stl || varp == &amp;p_ruf) {</a>
<a name="ln2843">    // 'statusline' or 'rulerformat'</a>
<a name="ln2844">    int wid;</a>
<a name="ln2845"> </a>
<a name="ln2846">    if (varp == &amp;p_ruf) {       // reset ru_wid first</a>
<a name="ln2847">      ru_wid = 0;</a>
<a name="ln2848">    }</a>
<a name="ln2849">    s = *varp;</a>
<a name="ln2850">    if (varp == &amp;p_ruf &amp;&amp; *s == '%') {</a>
<a name="ln2851">      // set ru_wid if 'ruf' starts with &quot;%99(&quot;</a>
<a name="ln2852">      if (*++s == '-') {        // ignore a '-'</a>
<a name="ln2853">        s++;</a>
<a name="ln2854">      }</a>
<a name="ln2855">      wid = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2856">      if (wid &amp;&amp; *s == '(' &amp;&amp; (errmsg = check_stl_option(p_ruf)) == NULL) {</a>
<a name="ln2857">        ru_wid = wid;</a>
<a name="ln2858">      } else {</a>
<a name="ln2859">        errmsg = check_stl_option(p_ruf);</a>
<a name="ln2860">      }</a>
<a name="ln2861">    } else if (varp == &amp;p_ruf || s[0] != '%' || s[1] != '!') {</a>
<a name="ln2862">      // check 'statusline' only if it doesn't start with &quot;%!&quot;</a>
<a name="ln2863">      errmsg = check_stl_option(s);</a>
<a name="ln2864">    }</a>
<a name="ln2865">    if (varp == &amp;p_ruf &amp;&amp; errmsg == NULL) {</a>
<a name="ln2866">      comp_col();</a>
<a name="ln2867">    }</a>
<a name="ln2868">  } else if (gvarp == &amp;p_cpt) {</a>
<a name="ln2869">    // check if it is a valid value for 'complete' -- Acevedo</a>
<a name="ln2870">    for (s = *varp; *s; ) {</a>
<a name="ln2871">      while (*s == ',' || *s == ' ')</a>
<a name="ln2872">        s++;</a>
<a name="ln2873">      if (!*s) {</a>
<a name="ln2874">        break;</a>
<a name="ln2875">      }</a>
<a name="ln2876">      if (vim_strchr((char_u *)&quot;.wbuksid]tU&quot;, *s) == NULL) {</a>
<a name="ln2877">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2878">        break;</a>
<a name="ln2879">      }</a>
<a name="ln2880">      if (*++s != NUL &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2881">        if (s[-1] == 'k' || s[-1] == 's') {</a>
<a name="ln2882">          // skip optional filename after 'k' and 's'</a>
<a name="ln2883">          while (*s &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2884">            if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2885">              s++;</a>
<a name="ln2886">            }</a>
<a name="ln2887">            s++;</a>
<a name="ln2888">          }</a>
<a name="ln2889">        } else {</a>
<a name="ln2890">          if (errbuf != NULL) {</a>
<a name="ln2891">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2892">                         _(&quot;E535: Illegal character after &lt;%c&gt;&quot;),</a>
<a name="ln2893">                         *--s);</a>
<a name="ln2894">            errmsg = errbuf;</a>
<a name="ln2895">          } else</a>
<a name="ln2896">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2897">          break;</a>
<a name="ln2898">        }</a>
<a name="ln2899">      }</a>
<a name="ln2900">    }</a>
<a name="ln2901">  } else if (varp == &amp;p_cot) {  // 'completeopt'</a>
<a name="ln2902">    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {</a>
<a name="ln2903">      errmsg = e_invarg;</a>
<a name="ln2904">    } else {</a>
<a name="ln2905">      completeopt_was_set();</a>
<a name="ln2906">    }</a>
<a name="ln2907">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2908">  } else if (gvarp == &amp;p_csl) {  // 'completeslash'</a>
<a name="ln2909">    if (check_opt_strings(p_csl, p_csl_values, false) != OK</a>
<a name="ln2910">        || check_opt_strings(curbuf-&gt;b_p_csl, p_csl_values, false) != OK) {</a>
<a name="ln2911">      errmsg = e_invarg;</a>
<a name="ln2912">    }</a>
<a name="ln2913">#endif</a>
<a name="ln2914">  } else if (varp == &amp;curwin-&gt;w_p_scl) {</a>
<a name="ln2915">    // 'signcolumn'</a>
<a name="ln2916">    if (check_opt_strings(*varp, p_scl_values, false) != OK) {</a>
<a name="ln2917">      errmsg = e_invarg;</a>
<a name="ln2918">    }</a>
<a name="ln2919">    // When changing the 'signcolumn' to or from 'number', recompute the</a>
<a name="ln2920">    // width of the number column if 'number' or 'relativenumber' is set.</a>
<a name="ln2921">    if (((*oldval == 'n' &amp;&amp; *(oldval + 1) == 'u')</a>
<a name="ln2922">         || (*curwin-&gt;w_p_scl == 'n' &amp;&amp; *(curwin-&gt;w_p_scl + 1) =='u'))</a>
<a name="ln2923">        &amp;&amp; (curwin-&gt;w_p_nu || curwin-&gt;w_p_rnu)) {</a>
<a name="ln2924">      curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln2925">    }</a>
<a name="ln2926">  } else if (varp == &amp;curwin-&gt;w_p_fdc || varp == &amp;curwin-&gt;w_allbuf_opt.wo_fdc) {</a>
<a name="ln2927">    // 'foldcolumn'</a>
<a name="ln2928">    if (check_opt_strings(*varp, p_fdc_values, false) != OK) {</a>
<a name="ln2929">      errmsg = e_invarg;</a>
<a name="ln2930">    }</a>
<a name="ln2931">  } else if (varp == &amp;p_pt) {</a>
<a name="ln2932">    // 'pastetoggle': translate key codes like in a mapping</a>
<a name="ln2933">    if (*p_pt) {</a>
<a name="ln2934">      (void)replace_termcodes(p_pt, STRLEN(p_pt), &amp;p, true, true, true,</a>
<a name="ln2935">                              CPO_TO_CPO_FLAGS);</a>
<a name="ln2936">      if (p != NULL) {</a>
<a name="ln2937">        if (new_value_alloced) {</a>
<a name="ln2938">          free_string_option(p_pt);</a>
<a name="ln2939">        }</a>
<a name="ln2940">        p_pt = p;</a>
<a name="ln2941">        new_value_alloced = true;</a>
<a name="ln2942">      }</a>
<a name="ln2943">    }</a>
<a name="ln2944">  } else if (varp == &amp;p_bs) {  // 'backspace'</a>
<a name="ln2945">    if (ascii_isdigit(*p_bs)) {</a>
<a name="ln2946">      if (*p_bs &gt; '3' || p_bs[1] != NUL) {</a>
<a name="ln2947">        errmsg = e_invarg;</a>
<a name="ln2948">      }</a>
<a name="ln2949">    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {</a>
<a name="ln2950">      errmsg = e_invarg;</a>
<a name="ln2951">    }</a>
<a name="ln2952">  } else if (varp == &amp;p_bo) {</a>
<a name="ln2953">    if (opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true) != OK) {</a>
<a name="ln2954">      errmsg = e_invarg;</a>
<a name="ln2955">    }</a>
<a name="ln2956">  } else if (gvarp == &amp;p_tc) {  // 'tagcase'</a>
<a name="ln2957">    unsigned int *flags;</a>
<a name="ln2958"> </a>
<a name="ln2959">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2960">      p = curbuf-&gt;b_p_tc;</a>
<a name="ln2961">      flags = &amp;curbuf-&gt;b_tc_flags;</a>
<a name="ln2962">    } else {</a>
<a name="ln2963">      p = p_tc;</a>
<a name="ln2964">      flags = &amp;tc_flags;</a>
<a name="ln2965">    }</a>
<a name="ln2966"> </a>
<a name="ln2967">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *p == NUL) {</a>
<a name="ln2968">      // make the local value empty: use the global value</a>
<a name="ln2969">      *flags = 0;</a>
<a name="ln2970">    } else if (*p == NUL</a>
<a name="ln2971">               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {</a>
<a name="ln2972">      errmsg = e_invarg;</a>
<a name="ln2973">    }</a>
<a name="ln2974">  } else if (varp == &amp;p_cmp) {  // 'casemap'</a>
<a name="ln2975">    if (opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true) != OK) {</a>
<a name="ln2976">      errmsg = e_invarg;</a>
<a name="ln2977">    }</a>
<a name="ln2978">  } else if (varp == &amp;p_dip) {  // 'diffopt'</a>
<a name="ln2979">    if (diffopt_changed() == FAIL) {</a>
<a name="ln2980">      errmsg = e_invarg;</a>
<a name="ln2981">    }</a>
<a name="ln2982">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdm) {  // 'foldmethod'</a>
<a name="ln2983">    if (check_opt_strings(*varp, p_fdm_values, false) != OK</a>
<a name="ln2984">        || *curwin-&gt;w_p_fdm == NUL) {</a>
<a name="ln2985">      errmsg = e_invarg;</a>
<a name="ln2986">    } else {</a>
<a name="ln2987">      foldUpdateAll(curwin);</a>
<a name="ln2988">      if (foldmethodIsDiff(curwin)) {</a>
<a name="ln2989">        newFoldLevel();</a>
<a name="ln2990">      }</a>
<a name="ln2991">    }</a>
<a name="ln2992">  } else if (varp == &amp;curwin-&gt;w_p_fde) {  // 'foldexpr'</a>
<a name="ln2993">    if (foldmethodIsExpr(curwin)) {</a>
<a name="ln2994">      foldUpdateAll(curwin);</a>
<a name="ln2995">    }</a>
<a name="ln2996">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fmr) {  // 'foldmarker'</a>
<a name="ln2997">    p = vim_strchr(*varp, ',');</a>
<a name="ln2998">    if (p == NULL) {</a>
<a name="ln2999">      errmsg = (char_u *)N_(&quot;E536: comma required&quot;);</a>
<a name="ln3000">    } else if (p == *varp || p[1] == NUL) {</a>
<a name="ln3001">      errmsg = e_invarg;</a>
<a name="ln3002">    } else if (foldmethodIsMarker(curwin)) {</a>
<a name="ln3003">      foldUpdateAll(curwin);</a>
<a name="ln3004">    }</a>
<a name="ln3005">  } else if (gvarp == &amp;p_cms) {  // 'commentstring'</a>
<a name="ln3006">    if (**varp != NUL &amp;&amp; strstr((char *)(*varp), &quot;%s&quot;) == NULL) {</a>
<a name="ln3007">      errmsg = (char_u *)N_(</a>
<a name="ln3008">          &quot;E537: 'commentstring' must be empty or contain %s&quot;);</a>
<a name="ln3009">    }</a>
<a name="ln3010">  } else if (varp == &amp;p_fdo) {  // 'foldopen'</a>
<a name="ln3011">    if (opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true) != OK) {</a>
<a name="ln3012">      errmsg = e_invarg;</a>
<a name="ln3013">    }</a>
<a name="ln3014">  } else if (varp == &amp;p_fcl) {  // 'foldclose'</a>
<a name="ln3015">    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {</a>
<a name="ln3016">      errmsg = e_invarg;</a>
<a name="ln3017">    }</a>
<a name="ln3018">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdi) {  // 'foldignore'</a>
<a name="ln3019">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln3020">      foldUpdateAll(curwin);</a>
<a name="ln3021">    }</a>
<a name="ln3022">  } else if (varp == &amp;p_ve) {  // 'virtualedit'</a>
<a name="ln3023">    if (opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true) != OK) {</a>
<a name="ln3024">      errmsg = e_invarg;</a>
<a name="ln3025">    } else if (STRCMP(p_ve, oldval) != 0) {</a>
<a name="ln3026">      // Recompute cursor position in case the new 've' setting</a>
<a name="ln3027">      // changes something.</a>
<a name="ln3028">      validate_virtcol();</a>
<a name="ln3029">      coladvance(curwin-&gt;w_virtcol);</a>
<a name="ln3030">    }</a>
<a name="ln3031">  } else if (varp == &amp;p_csqf) {</a>
<a name="ln3032">    if (p_csqf != NULL) {</a>
<a name="ln3033">      p = p_csqf;</a>
<a name="ln3034">      while (*p != NUL) {</a>
<a name="ln3035">        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL</a>
<a name="ln3036">            || p[1] == NUL</a>
<a name="ln3037">            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL</a>
<a name="ln3038">            || (p[2] != NUL &amp;&amp; p[2] != ',')) {</a>
<a name="ln3039">          errmsg = e_invarg;</a>
<a name="ln3040">          break;</a>
<a name="ln3041">        } else if (p[2] == NUL) {</a>
<a name="ln3042">          break;</a>
<a name="ln3043">        } else {</a>
<a name="ln3044">          p += 3;</a>
<a name="ln3045">        }</a>
<a name="ln3046">      }</a>
<a name="ln3047">    }</a>
<a name="ln3048">  } else if (gvarp == &amp;p_cino) {  // 'cinoptions'</a>
<a name="ln3049">    // TODO(vim): recognize errors</a>
<a name="ln3050">    parse_cino(curbuf);</a>
<a name="ln3051">  // inccommand</a>
<a name="ln3052">  } else if (varp == &amp;p_icm) {</a>
<a name="ln3053">      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {</a>
<a name="ln3054">        errmsg = e_invarg;</a>
<a name="ln3055">      }</a>
<a name="ln3056">  } else if (gvarp == &amp;p_ft) {</a>
<a name="ln3057">    if (!valid_filetype(*varp)) {</a>
<a name="ln3058">      errmsg = e_invarg;</a>
<a name="ln3059">    } else {</a>
<a name="ln3060">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3061"> </a>
<a name="ln3062">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3063">      // even when the value comes from a modeline.</a>
<a name="ln3064">      *value_checked = true;</a>
<a name="ln3065">    }</a>
<a name="ln3066">  } else if (gvarp == &amp;p_syn) {</a>
<a name="ln3067">    if (!valid_filetype(*varp)) {</a>
<a name="ln3068">      errmsg = e_invarg;</a>
<a name="ln3069">    } else {</a>
<a name="ln3070">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3071"> </a>
<a name="ln3072">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3073">      // even when the value comes from a modeline.</a>
<a name="ln3074">      *value_checked = true;</a>
<a name="ln3075">    }</a>
<a name="ln3076">  } else if (varp == &amp;curwin-&gt;w_p_winhl) {</a>
<a name="ln3077">    if (!parse_winhl_opt(curwin)) {</a>
<a name="ln3078">      errmsg = e_invarg;</a>
<a name="ln3079">    }</a>
<a name="ln3080">  } else {</a>
<a name="ln3081">    // Options that are a list of flags.</a>
<a name="ln3082">    p = NULL;</a>
<a name="ln3083">    if (varp == &amp;p_ww) {  // 'whichwrap'</a>
<a name="ln3084">      p = (char_u *)WW_ALL;</a>
<a name="ln3085">    }</a>
<a name="ln3086">    if (varp == &amp;p_shm) {  // 'shortmess'</a>
<a name="ln3087">      p = (char_u *)SHM_ALL;</a>
<a name="ln3088">    } else if (varp == &amp;(p_cpo)) {  // 'cpoptions'</a>
<a name="ln3089">      p = (char_u *)CPO_VI;</a>
<a name="ln3090">    } else if (varp == &amp;(curbuf-&gt;b_p_fo)) {  // 'formatoptions'</a>
<a name="ln3091">      p = (char_u *)FO_ALL;</a>
<a name="ln3092">    } else if (varp == &amp;curwin-&gt;w_p_cocu) {  // 'concealcursor'</a>
<a name="ln3093">      p = (char_u *)COCU_ALL;</a>
<a name="ln3094">    } else if (varp == &amp;p_mouse) {  // 'mouse'</a>
<a name="ln3095">      p = (char_u *)MOUSE_ALL;</a>
<a name="ln3096">    }</a>
<a name="ln3097">    if (p != NULL) {</a>
<a name="ln3098">      for (s = *varp; *s; s++) {</a>
<a name="ln3099">        if (vim_strchr(p, *s) == NULL) {</a>
<a name="ln3100">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln3101">          break;</a>
<a name="ln3102">        }</a>
<a name="ln3103">      }</a>
<a name="ln3104">    }</a>
<a name="ln3105">  }</a>
<a name="ln3106"> </a>
<a name="ln3107">  /*</a>
<a name="ln3108">   * If error detected, restore the previous value.</a>
<a name="ln3109">   */</a>
<a name="ln3110">  if (errmsg != NULL) {</a>
<a name="ln3111">    if (new_value_alloced) {</a>
<a name="ln3112">      free_string_option(*varp);</a>
<a name="ln3113">    }</a>
<a name="ln3114">    *varp = oldval;</a>
<a name="ln3115">    /*</a>
<a name="ln3116">     * When resetting some values, need to act on it.</a>
<a name="ln3117">     */</a>
<a name="ln3118">    if (did_chartab) {</a>
<a name="ln3119">      (void)init_chartab();</a>
<a name="ln3120">    }</a>
<a name="ln3121">  } else {</a>
<a name="ln3122">    // Remember where the option was set.</a>
<a name="ln3123">    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3124">    // Free string options that are in allocated memory.</a>
<a name="ln3125">    // Use &quot;free_oldval&quot;, because recursiveness may change the flags under</a>
<a name="ln3126">    // our fingers (esp. init_highlight()).</a>
<a name="ln3127">    if (free_oldval) {</a>
<a name="ln3128">      free_string_option(oldval);</a>
<a name="ln3129">    }</a>
<a name="ln3130">    if (new_value_alloced) {</a>
<a name="ln3131">      options[opt_idx].flags |= P_ALLOCED;</a>
<a name="ln3132">    } else {</a>
<a name="ln3133">      options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln3134">    }</a>
<a name="ln3135"> </a>
<a name="ln3136">    if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln3137">        &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH)) {</a>
<a name="ln3138">      /* global option with local value set to use global value; free</a>
<a name="ln3139">       * the local value and make it empty */</a>
<a name="ln3140">      p = get_varp_scope(&amp;(options[opt_idx]), OPT_LOCAL);</a>
<a name="ln3141">      free_string_option(*(char_u **)p);</a>
<a name="ln3142">      *(char_u **)p = empty_option;</a>
<a name="ln3143">    } else if (!(opt_flags &amp; OPT_LOCAL) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln3144">      // May set global value for local option.</a>
<a name="ln3145">      set_string_option_global(opt_idx, varp);</a>
<a name="ln3146">    }</a>
<a name="ln3147"> </a>
<a name="ln3148">    /*</a>
<a name="ln3149">     * Trigger the autocommand only after setting the flags.</a>
<a name="ln3150">     */</a>
<a name="ln3151">    // When 'syntax' is set, load the syntax of that name</a>
<a name="ln3152">    if (varp == &amp;(curbuf-&gt;b_p_syn)) {</a>
<a name="ln3153">      static int syn_recursive = 0;</a>
<a name="ln3154"> </a>
<a name="ln3155">      syn_recursive++;</a>
<a name="ln3156">      // Only pass true for &quot;force&quot; when the value changed or not used</a>
<a name="ln3157">      // recursively, to avoid endless recurrence.</a>
<a name="ln3158">      apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn, curbuf-&gt;b_fname,</a>
<a name="ln3159">                     value_changed || syn_recursive == 1, curbuf);</a>
<a name="ln3160">      curbuf-&gt;b_flags |= BF_SYN_SET;</a>
<a name="ln3161">      syn_recursive--;</a>
<a name="ln3162">    } else if (varp == &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3163">      // 'filetype' is set, trigger the FileType autocommand</a>
<a name="ln3164">      // Skip this when called from a modeline and the filetype was</a>
<a name="ln3165">      // already set to this value.</a>
<a name="ln3166">      if (!(opt_flags &amp; OPT_MODELINE) || value_changed) {</a>
<a name="ln3167">        static int ft_recursive = 0;</a>
<a name="ln3168">        int secure_save = secure;</a>
<a name="ln3169"> </a>
<a name="ln3170">        // Reset the secure flag, since the value of 'filetype' has</a>
<a name="ln3171">        // been checked to be safe.</a>
<a name="ln3172">        secure = 0;</a>
<a name="ln3173"> </a>
<a name="ln3174">        ft_recursive++;</a>
<a name="ln3175">        did_filetype = true;</a>
<a name="ln3176">        // Only pass true for &quot;force&quot; when the value changed or not</a>
<a name="ln3177">        // used recursively, to avoid endless recurrence.</a>
<a name="ln3178">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname,</a>
<a name="ln3179">                       value_changed || ft_recursive == 1, curbuf);</a>
<a name="ln3180">        ft_recursive--;</a>
<a name="ln3181">        // Just in case the old &quot;curbuf&quot; is now invalid</a>
<a name="ln3182">        if (varp != &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3183">          varp = NULL;</a>
<a name="ln3184">        }</a>
<a name="ln3185">        secure = secure_save;</a>
<a name="ln3186">      }</a>
<a name="ln3187">    }</a>
<a name="ln3188">    if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)) {</a>
<a name="ln3189">      char_u fname[200];</a>
<a name="ln3190">      char_u      *q = curwin-&gt;w_s-&gt;b_p_spl;</a>
<a name="ln3191"> </a>
<a name="ln3192">      // Skip the first name if it is &quot;cjk&quot;.</a>
<a name="ln3193">      if (STRNCMP(q, &quot;cjk,&quot;, 4) == 0) {</a>
<a name="ln3194">        q += 4;</a>
<a name="ln3195">      }</a>
<a name="ln3196"> </a>
<a name="ln3197">      /*</a>
<a name="ln3198">       * Source the spell/LANG.vim in 'runtimepath'.</a>
<a name="ln3199">       * They could set 'spellcapcheck' depending on the language.</a>
<a name="ln3200">       * Use the first name in 'spelllang' up to '_region' or</a>
<a name="ln3201">       * '.encoding'.</a>
<a name="ln3202">       */</a>
<a name="ln3203">      for (p = q; *p != NUL; p++) {</a>
<a name="ln3204">        if (!ASCII_ISALNUM(*p) &amp;&amp; *p != '-') {</a>
<a name="ln3205">          break;</a>
<a name="ln3206">        }</a>
<a name="ln3207">      }</a>
<a name="ln3208">      if (p &gt; q) {</a>
<a name="ln3209">        vim_snprintf((char *)fname, sizeof(fname), &quot;spell/%.*s.vim&quot;,</a>
<a name="ln3210">                     (int)(p - q), q);</a>
<a name="ln3211">        source_runtime(fname, DIP_ALL);</a>
<a name="ln3212">      }</a>
<a name="ln3213">    }</a>
<a name="ln3214">  }</a>
<a name="ln3215"> </a>
<a name="ln3216">  if (varp == &amp;p_mouse) {</a>
<a name="ln3217">    setmouse();  // in case 'mouse' changed</a>
<a name="ln3218">  }</a>
<a name="ln3219"> </a>
<a name="ln3220">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln3221">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0)</a>
<a name="ln3222">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3223"> </a>
<a name="ln3224">  check_redraw(options[opt_idx].flags);</a>
<a name="ln3225"> </a>
<a name="ln3226">  return errmsg;</a>
<a name="ln3227">}  // NOLINT(readability/fn_size)</a>
<a name="ln3228"> </a>
<a name="ln3229">/// Simple int comparison function for use with qsort()</a>
<a name="ln3230">static int int_cmp(const void *a, const void *b)</a>
<a name="ln3231">{</a>
<a name="ln3232">  return *(const int *)a - *(const int *)b;</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">/// Handle setting 'colorcolumn' or 'textwidth' in window &quot;wp&quot;.</a>
<a name="ln3236">///</a>
<a name="ln3237">/// @return error message, NULL if it's OK.</a>
<a name="ln3238">char_u *check_colorcolumn(win_T *wp)</a>
<a name="ln3239">{</a>
<a name="ln3240">  char_u      *s;</a>
<a name="ln3241">  int col;</a>
<a name="ln3242">  unsigned int count = 0;</a>
<a name="ln3243">  int color_cols[256];</a>
<a name="ln3244">  int j = 0;</a>
<a name="ln3245"> </a>
<a name="ln3246">  if (wp-&gt;w_buffer == NULL) {</a>
<a name="ln3247">    return NULL;      // buffer was closed</a>
<a name="ln3248">  }</a>
<a name="ln3249"> </a>
<a name="ln3250">  for (s = wp-&gt;w_p_cc; *s != NUL &amp;&amp; count &lt; 255; ) {</a>
<a name="ln3251">    if (*s == '-' || *s == '+') {</a>
<a name="ln3252">      // -N and +N: add to 'textwidth'</a>
<a name="ln3253">      col = (*s == '-') ? -1 : 1;</a>
<a name="ln3254">      s++;</a>
<a name="ln3255">      if (!ascii_isdigit(*s)) {</a>
<a name="ln3256">        return e_invarg;</a>
<a name="ln3257">      }</a>
<a name="ln3258">      col = col * getdigits_int(&amp;s, true, 0);</a>
<a name="ln3259">      if (wp-&gt;w_buffer-&gt;b_p_tw == 0) {</a>
<a name="ln3260">        goto skip;          // 'textwidth' not set, skip this item</a>
<a name="ln3261">      }</a>
<a name="ln3262">      assert((col &gt;= 0</a>
<a name="ln3263">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &lt;= INT_MAX - col</a>
<a name="ln3264">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &gt;= INT_MIN)</a>
<a name="ln3265">             || (col &lt; 0</a>
<a name="ln3266">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &gt;= INT_MIN - col</a>
<a name="ln3267">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &lt;= INT_MAX));</a>
<a name="ln3268">      col += (int)wp-&gt;w_buffer-&gt;b_p_tw;</a>
<a name="ln3269">      if (col &lt; 0) {</a>
<a name="ln3270">        goto skip;</a>
<a name="ln3271">      }</a>
<a name="ln3272">    } else if (ascii_isdigit(*s)) {</a>
<a name="ln3273">      col = getdigits_int(&amp;s, true, 0);</a>
<a name="ln3274">    } else {</a>
<a name="ln3275">      return e_invarg;</a>
<a name="ln3276">    }</a>
<a name="ln3277">    color_cols[count++] = col - 1;      // 1-based to 0-based</a>
<a name="ln3278">skip:</a>
<a name="ln3279">    if (*s == NUL) {</a>
<a name="ln3280">      break;</a>
<a name="ln3281">    }</a>
<a name="ln3282">    if (*s != ',') {</a>
<a name="ln3283">      return e_invarg;</a>
<a name="ln3284">    }</a>
<a name="ln3285">    if (*++s == NUL) {</a>
<a name="ln3286">      return e_invarg;        // illegal trailing comma as in &quot;set cc=80,&quot;</a>
<a name="ln3287">    }</a>
<a name="ln3288">  }</a>
<a name="ln3289"> </a>
<a name="ln3290">  xfree(wp-&gt;w_p_cc_cols);</a>
<a name="ln3291">  if (count == 0) {</a>
<a name="ln3292">    wp-&gt;w_p_cc_cols = NULL;</a>
<a name="ln3293">  } else {</a>
<a name="ln3294">    wp-&gt;w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));</a>
<a name="ln3295">    /* sort the columns for faster usage on screen redraw inside</a>
<a name="ln3296">     * win_line() */</a>
<a name="ln3297">    qsort(color_cols, count, sizeof(int), int_cmp);</a>
<a name="ln3298"> </a>
<a name="ln3299">    for (unsigned int i = 0; i &lt; count; i++) {</a>
<a name="ln3300">      // skip duplicates</a>
<a name="ln3301">      if (j == 0 || wp-&gt;w_p_cc_cols[j - 1] != color_cols[i]) {</a>
<a name="ln3302">        wp-&gt;w_p_cc_cols[j++] = color_cols[i];</a>
<a name="ln3303">      }</a>
<a name="ln3304">    }</a>
<a name="ln3305">    wp-&gt;w_p_cc_cols[j] = -1;        // end marker</a>
<a name="ln3306">  }</a>
<a name="ln3307"> </a>
<a name="ln3308">  return NULL;    // no error</a>
<a name="ln3309">}</a>
<a name="ln3310"> </a>
<a name="ln3311"> </a>
<a name="ln3312">/// Handle setting 'listchars' or 'fillchars'.</a>
<a name="ln3313">/// Assume monocell characters</a>
<a name="ln3314">///</a>
<a name="ln3315">/// @param varp either &amp;curwin-&gt;w_p_lcs or &amp;curwin-&gt;w_p_fcs</a>
<a name="ln3316">/// @return error message, NULL if it's OK.</a>
<a name="ln3317">static char_u *set_chars_option(win_T *wp, char_u **varp, bool set)</a>
<a name="ln3318">{</a>
<a name="ln3319">  int round, i, len, entries;</a>
<a name="ln3320">  char_u *p, *s;</a>
<a name="ln3321">  int c1;</a>
<a name="ln3322">  int c2 = 0;</a>
<a name="ln3323">  int c3 = 0;</a>
<a name="ln3324"> </a>
<a name="ln3325">  struct chars_tab {</a>
<a name="ln3326">    int     *cp;    ///&lt; char value</a>
<a name="ln3327">    char    *name;  ///&lt; char id</a>
<a name="ln3328">    int     def;    ///&lt; default value</a>
<a name="ln3329">  };</a>
<a name="ln3330">  struct chars_tab *tab;</a>
<a name="ln3331"> </a>
<a name="ln3332">  struct chars_tab fcs_tab[] = {</a>
<a name="ln3333">    { &amp;wp-&gt;w_p_fcs_chars.stl,     &quot;stl&quot;,      ' '  },</a>
<a name="ln3334">    { &amp;wp-&gt;w_p_fcs_chars.stlnc,   &quot;stlnc&quot;,    ' '  },</a>
<a name="ln3335">    { &amp;wp-&gt;w_p_fcs_chars.vert,    &quot;vert&quot;,     9474 },  // │</a>
<a name="ln3336">    { &amp;wp-&gt;w_p_fcs_chars.fold,    &quot;fold&quot;,     183  },  // ·</a>
<a name="ln3337">    { &amp;wp-&gt;w_p_fcs_chars.foldopen,   &quot;foldopen&quot;,  '-'  },</a>
<a name="ln3338">    { &amp;wp-&gt;w_p_fcs_chars.foldclosed, &quot;foldclose&quot;, '+'  },</a>
<a name="ln3339">    { &amp;wp-&gt;w_p_fcs_chars.foldsep,    &quot;foldsep&quot;,   9474 },  // │</a>
<a name="ln3340">    { &amp;wp-&gt;w_p_fcs_chars.diff,    &quot;diff&quot;,     '-'  },</a>
<a name="ln3341">    { &amp;wp-&gt;w_p_fcs_chars.msgsep,  &quot;msgsep&quot;,   ' '  },</a>
<a name="ln3342">    { &amp;wp-&gt;w_p_fcs_chars.eob,     &quot;eob&quot;,      '~'  },</a>
<a name="ln3343">  };</a>
<a name="ln3344">  struct chars_tab lcs_tab[] = {</a>
<a name="ln3345">    { &amp;wp-&gt;w_p_lcs_chars.eol,     &quot;eol&quot;,      NUL  },</a>
<a name="ln3346">    { &amp;wp-&gt;w_p_lcs_chars.ext,     &quot;extends&quot;,  NUL  },</a>
<a name="ln3347">    { &amp;wp-&gt;w_p_lcs_chars.nbsp,    &quot;nbsp&quot;,     NUL  },</a>
<a name="ln3348">    { &amp;wp-&gt;w_p_lcs_chars.prec,    &quot;precedes&quot;, NUL  },</a>
<a name="ln3349">    { &amp;wp-&gt;w_p_lcs_chars.space,   &quot;space&quot;,    NUL  },</a>
<a name="ln3350">    { &amp;wp-&gt;w_p_lcs_chars.tab2,    &quot;tab&quot;,      NUL  },</a>
<a name="ln3351">    { &amp;wp-&gt;w_p_lcs_chars.trail,   &quot;trail&quot;,    NUL  },</a>
<a name="ln3352">    { &amp;wp-&gt;w_p_lcs_chars.conceal, &quot;conceal&quot;,  NUL  },</a>
<a name="ln3353">  };</a>
<a name="ln3354"> </a>
<a name="ln3355">  if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3356">    tab = lcs_tab;</a>
<a name="ln3357">    entries = ARRAY_SIZE(lcs_tab);</a>
<a name="ln3358">    if (varp == &amp;wp-&gt;w_p_lcs &amp;&amp; wp-&gt;w_p_lcs[0] == NUL) {</a>
<a name="ln3359">      varp = &amp;p_lcs;</a>
<a name="ln3360">    }</a>
<a name="ln3361">  } else {</a>
<a name="ln3362">    tab = fcs_tab;</a>
<a name="ln3363">    entries = ARRAY_SIZE(fcs_tab);</a>
<a name="ln3364">    if (varp == &amp;wp-&gt;w_p_fcs &amp;&amp; wp-&gt;w_p_fcs[0] == NUL) {</a>
<a name="ln3365">      varp = &amp;p_fcs;</a>
<a name="ln3366">    }</a>
<a name="ln3367">    if (*p_ambw == 'd') {</a>
<a name="ln3368">      // XXX: If ambiwidth=double then &quot;|&quot; and &quot;·&quot; take 2 columns, which is</a>
<a name="ln3369">      // forbidden (TUI limitation?). Set old defaults.</a>
<a name="ln3370">      fcs_tab[2].def = '|';</a>
<a name="ln3371">      fcs_tab[6].def = '|';</a>
<a name="ln3372">      fcs_tab[3].def = '-';</a>
<a name="ln3373">    } else {</a>
<a name="ln3374">      fcs_tab[2].def = 9474;  // │</a>
<a name="ln3375">      fcs_tab[6].def = 9474;  // │</a>
<a name="ln3376">      fcs_tab[3].def = 183;   // ·</a>
<a name="ln3377">    }</a>
<a name="ln3378">  }</a>
<a name="ln3379"> </a>
<a name="ln3380">  // first round: check for valid value, second round: assign values</a>
<a name="ln3381">  for (round = 0; round &lt;= (set ? 1 : 0); round++) {</a>
<a name="ln3382">    if (round &gt; 0) {</a>
<a name="ln3383">      // After checking that the value is valid: set defaults</a>
<a name="ln3384">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3385">        if (tab[i].cp != NULL) {</a>
<a name="ln3386">          *(tab[i].cp) = tab[i].def;</a>
<a name="ln3387">        }</a>
<a name="ln3388">      }</a>
<a name="ln3389">      if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3390">        wp-&gt;w_p_lcs_chars.tab1 = NUL;</a>
<a name="ln3391">        wp-&gt;w_p_lcs_chars.tab3 = NUL;</a>
<a name="ln3392">      }</a>
<a name="ln3393">    }</a>
<a name="ln3394">    p = *varp;</a>
<a name="ln3395">    while (*p) {</a>
<a name="ln3396">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3397">        len = (int)STRLEN(tab[i].name);</a>
<a name="ln3398">        if (STRNCMP(p, tab[i].name, len) == 0</a>
<a name="ln3399">            &amp;&amp; p[len] == ':'</a>
<a name="ln3400">            &amp;&amp; p[len + 1] != NUL) {</a>
<a name="ln3401">          c2 = c3 = 0;</a>
<a name="ln3402">          s = p + len + 1;</a>
<a name="ln3403"> </a>
<a name="ln3404">          // TODO(bfredl): use schar_T representation and utfc_ptr2len</a>
<a name="ln3405">          int c1len = utf_ptr2len(s);</a>
<a name="ln3406">          c1 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3407">          if (mb_char2cells(c1) &gt; 1 || (c1len == 1 &amp;&amp; c1 &gt; 127)) {</a>
<a name="ln3408">            continue;</a>
<a name="ln3409">          }</a>
<a name="ln3410">          if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3411">            if (*s == NUL) {</a>
<a name="ln3412">              continue;</a>
<a name="ln3413">            }</a>
<a name="ln3414">            int c2len = utf_ptr2len(s);</a>
<a name="ln3415">            c2 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3416">            if (mb_char2cells(c2) &gt; 1 || (c2len == 1 &amp;&amp; c2 &gt; 127)) {</a>
<a name="ln3417">              continue;</a>
<a name="ln3418">            }</a>
<a name="ln3419">            if (!(*s == ',' || *s == NUL)) {</a>
<a name="ln3420">              int c3len = utf_ptr2len(s);</a>
<a name="ln3421">              c3 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3422">              if (mb_char2cells(c3) &gt; 1 || (c3len == 1 &amp;&amp; c3 &gt; 127)) {</a>
<a name="ln3423">                continue;</a>
<a name="ln3424">              }</a>
<a name="ln3425">            }</a>
<a name="ln3426">          }</a>
<a name="ln3427">          if (*s == ',' || *s == NUL) {</a>
<a name="ln3428">            if (round) {</a>
<a name="ln3429">              if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3430">                wp-&gt;w_p_lcs_chars.tab1 = c1;</a>
<a name="ln3431">                wp-&gt;w_p_lcs_chars.tab2 = c2;</a>
<a name="ln3432">                wp-&gt;w_p_lcs_chars.tab3 = c3;</a>
<a name="ln3433">              } else if (tab[i].cp != NULL) {</a>
<a name="ln3434">                *(tab[i].cp) = c1;</a>
<a name="ln3435">              }</a>
<a name="ln3436">            }</a>
<a name="ln3437">            p = s;</a>
<a name="ln3438">            break;</a>
<a name="ln3439">          }</a>
<a name="ln3440">        }</a>
<a name="ln3441">      }</a>
<a name="ln3442"> </a>
<a name="ln3443">      if (i == entries) {</a>
<a name="ln3444">        return e_invarg;</a>
<a name="ln3445">      }</a>
<a name="ln3446">      if (*p == ',') {</a>
<a name="ln3447">        p++;</a>
<a name="ln3448">      }</a>
<a name="ln3449">    }</a>
<a name="ln3450">  }</a>
<a name="ln3451"> </a>
<a name="ln3452">  return NULL;          // no error</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455">/// Check validity of options with the 'statusline' format.</a>
<a name="ln3456">/// Return error message or NULL.</a>
<a name="ln3457">char_u *check_stl_option(char_u *s)</a>
<a name="ln3458">{</a>
<a name="ln3459">  int groupdepth = 0;</a>
<a name="ln3460">  static char_u errbuf[80];</a>
<a name="ln3461"> </a>
<a name="ln3462">  while (*s) {</a>
<a name="ln3463">    // Check for valid keys after % sequences</a>
<a name="ln3464">    while (*s &amp;&amp; *s != '%') {</a>
<a name="ln3465">      s++;</a>
<a name="ln3466">    }</a>
<a name="ln3467">    if (!*s) {</a>
<a name="ln3468">      break;</a>
<a name="ln3469">    }</a>
<a name="ln3470">    s++;</a>
<a name="ln3471">    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {</a>
<a name="ln3472">      s++;</a>
<a name="ln3473">      continue;</a>
<a name="ln3474">    }</a>
<a name="ln3475">    if (*s == ')') {</a>
<a name="ln3476">      s++;</a>
<a name="ln3477">      if (--groupdepth &lt; 0) {</a>
<a name="ln3478">        break;</a>
<a name="ln3479">      }</a>
<a name="ln3480">      continue;</a>
<a name="ln3481">    }</a>
<a name="ln3482">    if (*s == '-') {</a>
<a name="ln3483">      s++;</a>
<a name="ln3484">    }</a>
<a name="ln3485">    while (ascii_isdigit(*s)) {</a>
<a name="ln3486">      s++;</a>
<a name="ln3487">    }</a>
<a name="ln3488">    if (*s == STL_USER_HL) {</a>
<a name="ln3489">      continue;</a>
<a name="ln3490">    }</a>
<a name="ln3491">    if (*s == '.') {</a>
<a name="ln3492">      s++;</a>
<a name="ln3493">      while (*s &amp;&amp; ascii_isdigit(*s))</a>
<a name="ln3494">        s++;</a>
<a name="ln3495">    }</a>
<a name="ln3496">    if (*s == '(') {</a>
<a name="ln3497">      groupdepth++;</a>
<a name="ln3498">      continue;</a>
<a name="ln3499">    }</a>
<a name="ln3500">    if (vim_strchr(STL_ALL, *s) == NULL) {</a>
<a name="ln3501">      return illegal_char(errbuf, sizeof(errbuf), *s);</a>
<a name="ln3502">    }</a>
<a name="ln3503">    if (*s == '{') {</a>
<a name="ln3504">      s++;</a>
<a name="ln3505">      while (*s != '}' &amp;&amp; *s)</a>
<a name="ln3506">        s++;</a>
<a name="ln3507">      if (*s != '}') {</a>
<a name="ln3508">        return (char_u *)N_(&quot;E540: Unclosed expression sequence&quot;);</a>
<a name="ln3509">      }</a>
<a name="ln3510">    }</a>
<a name="ln3511">  }</a>
<a name="ln3512">  if (groupdepth != 0) {</a>
<a name="ln3513">    return (char_u *)N_(&quot;E542: unbalanced groups&quot;);</a>
<a name="ln3514">  }</a>
<a name="ln3515">  return NULL;</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518">static char_u *did_set_spell_option(bool is_spellfile)</a>
<a name="ln3519">{</a>
<a name="ln3520">  char_u  *errmsg = NULL;</a>
<a name="ln3521"> </a>
<a name="ln3522">  if (is_spellfile) {</a>
<a name="ln3523">    int l = (int)STRLEN(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln3524">    if (l &gt; 0</a>
<a name="ln3525">        &amp;&amp; (l &lt; 4 || STRCMP(curwin-&gt;w_s-&gt;b_p_spf + l - 4, &quot;.add&quot;) != 0)) {</a>
<a name="ln3526">      errmsg = e_invarg;</a>
<a name="ln3527">    }</a>
<a name="ln3528">  }</a>
<a name="ln3529"> </a>
<a name="ln3530">  if (errmsg == NULL) {</a>
<a name="ln3531">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3532">      if (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;w_p_spell) {</a>
<a name="ln3533">        errmsg = did_set_spelllang(wp);</a>
<a name="ln3534">        break;</a>
<a name="ln3535">      }</a>
<a name="ln3536">    }</a>
<a name="ln3537">  }</a>
<a name="ln3538"> </a>
<a name="ln3539">  return errmsg;</a>
<a name="ln3540">}</a>
<a name="ln3541"> </a>
<a name="ln3542">/// Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</a>
<a name="ln3543">/// Return error message when failed, NULL when OK.</a>
<a name="ln3544">static char_u *compile_cap_prog(synblock_T *synblock)</a>
<a name="ln3545">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3546">{</a>
<a name="ln3547">  regprog_T   *rp = synblock-&gt;b_cap_prog;</a>
<a name="ln3548">  char_u      *re;</a>
<a name="ln3549"> </a>
<a name="ln3550">  if (synblock-&gt;b_p_spc == NULL || *synblock-&gt;b_p_spc == NUL) {</a>
<a name="ln3551">    synblock-&gt;b_cap_prog = NULL;</a>
<a name="ln3552">  } else {</a>
<a name="ln3553">    // Prepend a ^ so that we only match at one column</a>
<a name="ln3554">    re = concat_str((char_u *)&quot;^&quot;, synblock-&gt;b_p_spc);</a>
<a name="ln3555">    synblock-&gt;b_cap_prog = vim_regcomp(re, RE_MAGIC);</a>
<a name="ln3556">    xfree(re);</a>
<a name="ln3557">    if (synblock-&gt;b_cap_prog == NULL) {</a>
<a name="ln3558">      synblock-&gt;b_cap_prog = rp;         // restore the previous program</a>
<a name="ln3559">      return e_invarg;</a>
<a name="ln3560">    }</a>
<a name="ln3561">  }</a>
<a name="ln3562"> </a>
<a name="ln3563">  vim_regfree(rp);</a>
<a name="ln3564">  return NULL;</a>
<a name="ln3565">}</a>
<a name="ln3566"> </a>
<a name="ln3567">/// Handle setting `winhighlight' in window &quot;wp&quot;</a>
<a name="ln3568">static bool parse_winhl_opt(win_T *wp)</a>
<a name="ln3569">{</a>
<a name="ln3570">  int w_hl_id_normal = 0;</a>
<a name="ln3571">  int w_hl_ids[HLF_COUNT] = { 0 };</a>
<a name="ln3572">  int hlf;</a>
<a name="ln3573"> </a>
<a name="ln3574">  const char *p = (const char *)wp-&gt;w_p_winhl;</a>
<a name="ln3575">  while (*p) {</a>
<a name="ln3576">    char *colon = strchr(p, ':');</a>
<a name="ln3577">    if (!colon) {</a>
<a name="ln3578">      return false;</a>
<a name="ln3579">    }</a>
<a name="ln3580">    size_t nlen = (size_t)(colon-p);</a>
<a name="ln3581">    char *hi = colon+1;</a>
<a name="ln3582">    char *commap = xstrchrnul(hi, ',');</a>
<a name="ln3583">    int len = (int)(commap-hi);</a>
<a name="ln3584">    int hl_id = len ? syn_check_group((char_u *)hi, len) : -1;</a>
<a name="ln3585"> </a>
<a name="ln3586">    if (strncmp(&quot;Normal&quot;, p, nlen) == 0) {</a>
<a name="ln3587">      w_hl_id_normal = hl_id;</a>
<a name="ln3588">    } else {</a>
<a name="ln3589">      for (hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln3590">        if (strlen(hlf_names[hlf]) == nlen</a>
<a name="ln3591">            &amp;&amp; strncmp(hlf_names[hlf], p, nlen) == 0) {</a>
<a name="ln3592">          w_hl_ids[hlf] = hl_id;</a>
<a name="ln3593">          break;</a>
<a name="ln3594">        }</a>
<a name="ln3595">      }</a>
<a name="ln3596">      if (hlf == HLF_COUNT) {</a>
<a name="ln3597">        return false;</a>
<a name="ln3598">      }</a>
<a name="ln3599">    }</a>
<a name="ln3600"> </a>
<a name="ln3601">    p = *commap ? commap+1 : &quot;&quot;;</a>
<a name="ln3602">  }</a>
<a name="ln3603"> </a>
<a name="ln3604">  wp-&gt;w_hl_id_normal = w_hl_id_normal;</a>
<a name="ln3605">  memcpy(wp-&gt;w_hl_ids, w_hl_ids, sizeof(w_hl_ids));</a>
<a name="ln3606">  wp-&gt;w_hl_needs_update = true;</a>
<a name="ln3607">  return true;</a>
<a name="ln3608">}</a>
<a name="ln3609"> </a>
<a name="ln3610">// Set the script_ctx for an option, taking care of setting the buffer- or</a>
<a name="ln3611">// window-local value.</a>
<a name="ln3612">static void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)</a>
<a name="ln3613">{</a>
<a name="ln3614">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln3615">  int indir = (int)options[opt_idx].indir;</a>
<a name="ln3616">  const LastSet last_set = {</a>
<a name="ln3617">    .script_ctx = {</a>
<a name="ln3618">      script_ctx.sc_sid,</a>
<a name="ln3619">      script_ctx.sc_seq,</a>
<a name="ln3620">      script_ctx.sc_lnum + sourcing_lnum</a>
<a name="ln3621">    },</a>
<a name="ln3622">    current_channel_id</a>
<a name="ln3623">  };</a>
<a name="ln3624"> </a>
<a name="ln3625">  // Remember where the option was set.  For local options need to do that</a>
<a name="ln3626">  // in the buffer or window structure.</a>
<a name="ln3627">  if (both || (opt_flags &amp; OPT_GLOBAL) || (indir &amp; (PV_BUF|PV_WIN)) == 0) {</a>
<a name="ln3628">    options[opt_idx].last_set = last_set;</a>
<a name="ln3629">  }</a>
<a name="ln3630">  if (both || (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln3631">    if (indir &amp; PV_BUF) {</a>
<a name="ln3632">      curbuf-&gt;b_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3633">    } else if (indir &amp; PV_WIN) {</a>
<a name="ln3634">      curwin-&gt;w_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3635">    }</a>
<a name="ln3636">  }</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639">/// Set the value of a boolean option, taking care of side effects</a>
<a name="ln3640">///</a>
<a name="ln3641">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln3642">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln3643">/// @param[in]  value  New value.</a>
<a name="ln3644">/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.</a>
<a name="ln3645">///</a>
<a name="ln3646">/// @return NULL on success, error message on error.</a>
<a name="ln3647">static char *set_bool_option(const int opt_idx, char_u *const varp,</a>
<a name="ln3648">                             const int value,</a>
<a name="ln3649">                             const int opt_flags)</a>
<a name="ln3650">{</a>
<a name="ln3651">  int old_value = *(int *)varp;</a>
<a name="ln3652"> </a>
<a name="ln3653">  // Disallow changing some options from secure mode</a>
<a name="ln3654">  if ((secure || sandbox != 0)</a>
<a name="ln3655">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln3656">    return (char *)e_secure;</a>
<a name="ln3657">  }</a>
<a name="ln3658"> </a>
<a name="ln3659">  *(int *)varp = value;             // set the new value</a>
<a name="ln3660">  // Remember where the option was set.</a>
<a name="ln3661">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3662"> </a>
<a name="ln3663"> </a>
<a name="ln3664">  // May set global value for local option.</a>
<a name="ln3665">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln3666">    *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = value;</a>
<a name="ln3667">  }</a>
<a name="ln3668"> </a>
<a name="ln3669">  // Ensure that options set to p_force_on cannot be disabled.</a>
<a name="ln3670">  if ((int *)varp == &amp;p_force_on &amp;&amp; p_force_on == false) {</a>
<a name="ln3671">    p_force_on = true;</a>
<a name="ln3672">    return (char *)e_unsupportedoption;</a>
<a name="ln3673">  // Ensure that options set to p_force_off cannot be enabled.</a>
<a name="ln3674">  } else if ((int *)varp == &amp;p_force_off &amp;&amp; p_force_off == true) {</a>
<a name="ln3675">    p_force_off = false;</a>
<a name="ln3676">    return (char *)e_unsupportedoption;</a>
<a name="ln3677">  } else if ((int *)varp == &amp;p_lrm) {</a>
<a name="ln3678">    // 'langremap' -&gt; !'langnoremap'</a>
<a name="ln3679">    p_lnr = !p_lrm;</a>
<a name="ln3680">  } else if ((int *)varp == &amp;p_lnr) {</a>
<a name="ln3681">    // 'langnoremap' -&gt; !'langremap'</a>
<a name="ln3682">    p_lrm = !p_lnr;</a>
<a name="ln3683">  } else if ((int *)varp == &amp;curwin-&gt;w_p_cul &amp;&amp; !value &amp;&amp; old_value) {</a>
<a name="ln3684">    // 'cursorline'</a>
<a name="ln3685">    reset_cursorline();</a>
<a name="ln3686">  // 'undofile'</a>
<a name="ln3687">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_udf || (int *)varp == &amp;p_udf) {</a>
<a name="ln3688">    // Only take action when the option was set. When reset we do not</a>
<a name="ln3689">    // delete the undo file, the option may be set again without making</a>
<a name="ln3690">    // any changes in between.</a>
<a name="ln3691">    if (curbuf-&gt;b_p_udf || p_udf) {</a>
<a name="ln3692">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln3693">      buf_T       *save_curbuf = curbuf;</a>
<a name="ln3694"> </a>
<a name="ln3695">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln3696">        curbuf = bp;</a>
<a name="ln3697">        // When 'undofile' is set globally: for every buffer, otherwise</a>
<a name="ln3698">        // only for the current buffer: Try to read in the undofile,</a>
<a name="ln3699">        // if one exists, the buffer wasn't changed and the buffer was</a>
<a name="ln3700">        // loaded</a>
<a name="ln3701">        if ((curbuf == save_curbuf</a>
<a name="ln3702">             || (opt_flags &amp; OPT_GLOBAL) || opt_flags == 0)</a>
<a name="ln3703">            &amp;&amp; !curbufIsChanged() &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln3704">          u_compute_hash(hash);</a>
<a name="ln3705">          u_read_undo(NULL, hash, curbuf-&gt;b_fname);</a>
<a name="ln3706">        }</a>
<a name="ln3707">      }</a>
<a name="ln3708">      curbuf = save_curbuf;</a>
<a name="ln3709">    }</a>
<a name="ln3710">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ro) {</a>
<a name="ln3711">    // when 'readonly' is reset globally, also reset readonlymode</a>
<a name="ln3712">    if (!curbuf-&gt;b_p_ro &amp;&amp; (opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln3713">      readonlymode = false;</a>
<a name="ln3714">    }</a>
<a name="ln3715"> </a>
<a name="ln3716">    // when 'readonly' is set may give W10 again</a>
<a name="ln3717">    if (curbuf-&gt;b_p_ro) {</a>
<a name="ln3718">      curbuf-&gt;b_did_warn = false;</a>
<a name="ln3719">    }</a>
<a name="ln3720"> </a>
<a name="ln3721">    redraw_titles();</a>
<a name="ln3722">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ma) {</a>
<a name="ln3723">    // when 'modifiable' is changed, redraw the window title</a>
<a name="ln3724">    redraw_titles();</a>
<a name="ln3725">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_eol) {</a>
<a name="ln3726">    // when 'endofline' is changed, redraw the window title</a>
<a name="ln3727">    redraw_titles();</a>
<a name="ln3728">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_fixeol) {</a>
<a name="ln3729">    // when 'fixeol' is changed, redraw the window title</a>
<a name="ln3730">    redraw_titles();</a>
<a name="ln3731">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bomb) {</a>
<a name="ln3732">    // when 'bomb' is changed, redraw the window title and tab page text</a>
<a name="ln3733">    redraw_titles();</a>
<a name="ln3734">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bin) {</a>
<a name="ln3735">    // when 'bin' is set also set some other options</a>
<a name="ln3736">    set_options_bin(old_value, curbuf-&gt;b_p_bin, opt_flags);</a>
<a name="ln3737">    redraw_titles();</a>
<a name="ln3738">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bl &amp;&amp; old_value != curbuf-&gt;b_p_bl) {</a>
<a name="ln3739">    // when 'buflisted' changes, trigger autocommands</a>
<a name="ln3740">    apply_autocmds(curbuf-&gt;b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,</a>
<a name="ln3741">                   NULL, NULL, true, curbuf);</a>
<a name="ln3742">  } else if ((int *)varp == (int *)&amp;curbuf-&gt;b_p_swf) {</a>
<a name="ln3743">    // when 'swf' is set, create swapfile, when reset remove swapfile</a>
<a name="ln3744">    if (curbuf-&gt;b_p_swf &amp;&amp; p_uc) {</a>
<a name="ln3745">      ml_open_file(curbuf);                     // create the swap file</a>
<a name="ln3746">    } else {</a>
<a name="ln3747">      // no need to reset curbuf-&gt;b_may_swap, ml_open_file() will check</a>
<a name="ln3748">      // buf-&gt;b_p_swf</a>
<a name="ln3749">      mf_close_file(curbuf, true);              // remove the swap file</a>
<a name="ln3750">    }</a>
<a name="ln3751">  } else if ((int *)varp == &amp;p_terse) {</a>
<a name="ln3752">    // when 'terse' is set change 'shortmess'</a>
<a name="ln3753">    char_u  *p;</a>
<a name="ln3754"> </a>
<a name="ln3755">    p = vim_strchr(p_shm, SHM_SEARCH);</a>
<a name="ln3756"> </a>
<a name="ln3757">    // insert 's' in p_shm</a>
<a name="ln3758">    if (p_terse &amp;&amp; p == NULL) {</a>
<a name="ln3759">      STRCPY(IObuff, p_shm);</a>
<a name="ln3760">      STRCAT(IObuff, &quot;s&quot;);</a>
<a name="ln3761">      set_string_option_direct((char_u *)&quot;shm&quot;, -1, IObuff, OPT_FREE, 0);</a>
<a name="ln3762">    } else if (!p_terse &amp;&amp; p != NULL) {  // remove 's' from p_shm</a>
<a name="ln3763">      STRMOVE(p, p + 1);</a>
<a name="ln3764">    }</a>
<a name="ln3765">  } else if ((int *)varp == &amp;p_paste) {</a>
<a name="ln3766">    // when 'paste' is set or reset also change other options</a>
<a name="ln3767">    paste_option_changed();</a>
<a name="ln3768">  } else if ((int *)varp == &amp;p_im) {</a>
<a name="ln3769">    // when 'insertmode' is set from an autocommand need to do work here</a>
<a name="ln3770">    if (p_im) {</a>
<a name="ln3771">      if ((State &amp; INSERT) == 0) {</a>
<a name="ln3772">        need_start_insertmode = true;</a>
<a name="ln3773">      }</a>
<a name="ln3774">      stop_insert_mode = false;</a>
<a name="ln3775">    } else if (old_value) {  // only reset if it was set previously</a>
<a name="ln3776">      need_start_insertmode = false;</a>
<a name="ln3777">      stop_insert_mode = true;</a>
<a name="ln3778">      if (restart_edit != 0 &amp;&amp; mode_displayed) {</a>
<a name="ln3779">        clear_cmdline = true;  // remove &quot;(insert)&quot;</a>
<a name="ln3780">      }</a>
<a name="ln3781">      restart_edit = 0;</a>
<a name="ln3782">    }</a>
<a name="ln3783">  } else if ((int *)varp == &amp;p_ic &amp;&amp; p_hls) {</a>
<a name="ln3784">    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw</a>
<a name="ln3785">    redraw_all_later(SOME_VALID);</a>
<a name="ln3786">  } else if ((int *)varp == &amp;p_hls) {</a>
<a name="ln3787">    // when 'hlsearch' is set or reset: reset no_hlsearch</a>
<a name="ln3788">    set_no_hlsearch(false);</a>
<a name="ln3789">  } else if ((int *)varp == &amp;curwin-&gt;w_p_scb) {</a>
<a name="ln3790">  // when 'scrollbind' is set: snapshot the current position to avoid a jump</a>
<a name="ln3791">  // at the end of normal_cmd()</a>
<a name="ln3792">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln3793">      do_check_scrollbind(false);</a>
<a name="ln3794">      curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln3795">    }</a>
<a name="ln3796">  } else if ((int *)varp == &amp;curwin-&gt;w_p_pvw) {</a>
<a name="ln3797">    // There can be only one window with 'previewwindow' set.</a>
<a name="ln3798">    if (curwin-&gt;w_p_pvw) {</a>
<a name="ln3799">      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln3800">        if (win-&gt;w_p_pvw &amp;&amp; win != curwin) {</a>
<a name="ln3801">          curwin-&gt;w_p_pvw = false;</a>
<a name="ln3802">          return N_(&quot;E590: A preview window already exists&quot;);</a>
<a name="ln3803">        }</a>
<a name="ln3804">      }</a>
<a name="ln3805">    }</a>
<a name="ln3806">  } else if (varp == (char_u *)&amp;(curbuf-&gt;b_p_lisp)) {</a>
<a name="ln3807">    // When 'lisp' option changes include/exclude '-' in</a>
<a name="ln3808">    // keyword characters.</a>
<a name="ln3809">    (void)buf_init_chartab(curbuf, false);          // ignore errors</a>
<a name="ln3810">  } else if ((int *)varp == &amp;p_title) {</a>
<a name="ln3811">    // when 'title' changed, may need to change the title; same for 'icon'</a>
<a name="ln3812">    did_set_title();</a>
<a name="ln3813">  } else if ((int *)varp == &amp;p_icon) {</a>
<a name="ln3814">    did_set_title();</a>
<a name="ln3815">  } else if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln3816">    if (!value) {</a>
<a name="ln3817">      save_file_ff(curbuf);             // Buffer is unchanged</a>
<a name="ln3818">    }</a>
<a name="ln3819">    redraw_titles();</a>
<a name="ln3820">    modified_was_set = value;</a>
<a name="ln3821">  }</a>
<a name="ln3822"> </a>
<a name="ln3823">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3824">  else if ((int *)varp == &amp;p_ssl) {</a>
<a name="ln3825">    if (p_ssl) {</a>
<a name="ln3826">      psepc = '/';</a>
<a name="ln3827">      psepcN = '\\';</a>
<a name="ln3828">      pseps[0] = '/';</a>
<a name="ln3829">    } else {</a>
<a name="ln3830">      psepc = '\\';</a>
<a name="ln3831">      psepcN = '/';</a>
<a name="ln3832">      pseps[0] = '\\';</a>
<a name="ln3833">    }</a>
<a name="ln3834"> </a>
<a name="ln3835">    // need to adjust the file name arguments and buffer names.</a>
<a name="ln3836">    buflist_slash_adjust();</a>
<a name="ln3837">    alist_slash_adjust();</a>
<a name="ln3838">    scriptnames_slash_adjust();</a>
<a name="ln3839">  }</a>
<a name="ln3840">#endif</a>
<a name="ln3841">  else if ((int *)varp == &amp;curwin-&gt;w_p_wrap) {</a>
<a name="ln3842">    // If 'wrap' is set, set w_leftcol to zero.</a>
<a name="ln3843">    if (curwin-&gt;w_p_wrap) {</a>
<a name="ln3844">      curwin-&gt;w_leftcol = 0;</a>
<a name="ln3845">    }</a>
<a name="ln3846">  } else if ((int *)varp == &amp;p_ea) {</a>
<a name="ln3847">    if (p_ea &amp;&amp; !old_value) {</a>
<a name="ln3848">      win_equal(curwin, false, 0);</a>
<a name="ln3849">    }</a>
<a name="ln3850">  } else if ((int *)varp == &amp;p_acd) {</a>
<a name="ln3851">    // Change directories when the 'acd' option is set now.</a>
<a name="ln3852">    do_autochdir();</a>
<a name="ln3853">  } else if ((int *)varp == &amp;curwin-&gt;w_p_diff) {  // 'diff'</a>
<a name="ln3854">    // May add or remove the buffer from the list of diff buffers.</a>
<a name="ln3855">    diff_buf_adjust(curwin);</a>
<a name="ln3856">    if (foldmethodIsDiff(curwin)) {</a>
<a name="ln3857">      foldUpdateAll(curwin);</a>
<a name="ln3858">    }</a>
<a name="ln3859">  } else if ((int *)varp == &amp;curwin-&gt;w_p_spell) {  // 'spell'</a>
<a name="ln3860">    if (curwin-&gt;w_p_spell) {</a>
<a name="ln3861">      char_u      *errmsg = did_set_spelllang(curwin);</a>
<a name="ln3862">      if (errmsg != NULL) {</a>
<a name="ln3863">        EMSG(_(errmsg));</a>
<a name="ln3864">      }</a>
<a name="ln3865">    }</a>
<a name="ln3866">  }</a>
<a name="ln3867"> </a>
<a name="ln3868">  if ((int *)varp == &amp;curwin-&gt;w_p_arab) {</a>
<a name="ln3869">    if (curwin-&gt;w_p_arab) {</a>
<a name="ln3870">      /*</a>
<a name="ln3871">       * 'arabic' is set, handle various sub-settings.</a>
<a name="ln3872">       */</a>
<a name="ln3873">      if (!p_tbidi) {</a>
<a name="ln3874">        // set rightleft mode</a>
<a name="ln3875">        if (!curwin-&gt;w_p_rl) {</a>
<a name="ln3876">          curwin-&gt;w_p_rl = true;</a>
<a name="ln3877">          changed_window_setting();</a>
<a name="ln3878">        }</a>
<a name="ln3879"> </a>
<a name="ln3880">        // Enable Arabic shaping (major part of what Arabic requires)</a>
<a name="ln3881">        if (!p_arshape) {</a>
<a name="ln3882">          p_arshape = true;</a>
<a name="ln3883">          redraw_all_later(NOT_VALID);</a>
<a name="ln3884">        }</a>
<a name="ln3885">      }</a>
<a name="ln3886"> </a>
<a name="ln3887">      /* Arabic requires a utf-8 encoding, inform the user if its not</a>
<a name="ln3888">       * set. */</a>
<a name="ln3889">      if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln3890">        static char *w_arabic = N_(</a>
<a name="ln3891">            &quot;W17: Arabic requires UTF-8, do ':set encoding=utf-8'&quot;);</a>
<a name="ln3892"> </a>
<a name="ln3893">        msg_source(HL_ATTR(HLF_W));</a>
<a name="ln3894">        msg_attr(_(w_arabic), HL_ATTR(HLF_W));</a>
<a name="ln3895">        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);</a>
<a name="ln3896">      }</a>
<a name="ln3897"> </a>
<a name="ln3898">      // set 'delcombine'</a>
<a name="ln3899">      p_deco = true;</a>
<a name="ln3900"> </a>
<a name="ln3901">      // Force-set the necessary keymap for arabic.</a>
<a name="ln3902">      set_option_value(&quot;keymap&quot;, 0L, &quot;arabic&quot;, OPT_LOCAL);</a>
<a name="ln3903">    } else {</a>
<a name="ln3904">      /*</a>
<a name="ln3905">       * 'arabic' is reset, handle various sub-settings.</a>
<a name="ln3906">       */</a>
<a name="ln3907">      if (!p_tbidi) {</a>
<a name="ln3908">        // reset rightleft mode</a>
<a name="ln3909">        if (curwin-&gt;w_p_rl) {</a>
<a name="ln3910">          curwin-&gt;w_p_rl = false;</a>
<a name="ln3911">          changed_window_setting();</a>
<a name="ln3912">        }</a>
<a name="ln3913"> </a>
<a name="ln3914">        /* 'arabicshape' isn't reset, it is a global option and</a>
<a name="ln3915">         * another window may still need it &quot;on&quot;. */</a>
<a name="ln3916">      }</a>
<a name="ln3917"> </a>
<a name="ln3918">      /* 'delcombine' isn't reset, it is a global option and another</a>
<a name="ln3919">       * window may still want it &quot;on&quot;. */</a>
<a name="ln3920"> </a>
<a name="ln3921">      // Revert to the default keymap</a>
<a name="ln3922">      curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln3923">      curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln3924">    }</a>
<a name="ln3925">  }</a>
<a name="ln3926"> </a>
<a name="ln3927"> </a>
<a name="ln3928">  /*</a>
<a name="ln3929">   * End of handling side effects for bool options.</a>
<a name="ln3930">   */</a>
<a name="ln3931"> </a>
<a name="ln3932">  // after handling side effects, call autocommand</a>
<a name="ln3933"> </a>
<a name="ln3934">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln3935"> </a>
<a name="ln3936">  // Don't do this while starting up or recursively.</a>
<a name="ln3937">  if (!starting &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln3938">    char buf_old[2];</a>
<a name="ln3939">    char buf_new[2];</a>
<a name="ln3940">    char buf_type[7];</a>
<a name="ln3941">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%d&quot;,</a>
<a name="ln3942">                 old_value ? true: false);</a>
<a name="ln3943">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%d&quot;,</a>
<a name="ln3944">                 value ? true: false);</a>
<a name="ln3945">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln3946">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln3947">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln3948">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln3949">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln3950">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln3951">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln3952">                   NULL, false, NULL);</a>
<a name="ln3953">    reset_v_option_vars();</a>
<a name="ln3954">  }</a>
<a name="ln3955"> </a>
<a name="ln3956">  if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln3957">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln3958">                       BOOLEAN_OBJ(value));</a>
<a name="ln3959">  }</a>
<a name="ln3960"> </a>
<a name="ln3961">  comp_col();                       // in case 'ruler' or 'showcmd' changed</a>
<a name="ln3962">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln3963">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln3964">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3965">  }</a>
<a name="ln3966">  check_redraw(options[opt_idx].flags);</a>
<a name="ln3967"> </a>
<a name="ln3968">  return NULL;</a>
<a name="ln3969">}</a>
<a name="ln3970"> </a>
<a name="ln3971">/// Set the value of a number option, taking care of side effects</a>
<a name="ln3972">///</a>
<a name="ln3973">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln3974">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln3975">/// @param[in]  value  New value.</a>
<a name="ln3976">/// @param  errbuf  Buffer for error messages.</a>
<a name="ln3977">/// @param[in]  errbuflen  Length of `errbuf`.</a>
<a name="ln3978">/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.</a>
<a name="ln3979">///</a>
<a name="ln3980">/// @return NULL on success, error message on error.</a>
<a name="ln3981">static char *set_num_option(int opt_idx, char_u *varp, long value,</a>
<a name="ln3982">                            char_u *errbuf, size_t errbuflen, int opt_flags)</a>
<a name="ln3983">{</a>
<a name="ln3984">  char_u      *errmsg = NULL;</a>
<a name="ln3985">  long old_value = *(long *)varp;</a>
<a name="ln3986">  long old_Rows = Rows;                 // remember old Rows</a>
<a name="ln3987">  long        *pp = (long *)varp;</a>
<a name="ln3988"> </a>
<a name="ln3989">  // Disallow changing some options from secure mode.</a>
<a name="ln3990">  if ((secure || sandbox != 0)</a>
<a name="ln3991">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln3992">    return (char *)e_secure;</a>
<a name="ln3993">  }</a>
<a name="ln3994"> </a>
<a name="ln3995">  // Many number options assume their value is in the signed int range.</a>
<a name="ln3996">  if (value &lt; INT_MIN || value &gt; INT_MAX) {</a>
<a name="ln3997">      return (char *)e_invarg;</a>
<a name="ln3998">  }</a>
<a name="ln3999"> </a>
<a name="ln4000">  // Options that need some validation.</a>
<a name="ln4001">  if (pp == &amp;p_wh) {</a>
<a name="ln4002">    if (value &lt; 1) {</a>
<a name="ln4003">      errmsg = e_positive;</a>
<a name="ln4004">    } else if (p_wmh &gt; value) {</a>
<a name="ln4005">      errmsg = e_winheight;</a>
<a name="ln4006">    }</a>
<a name="ln4007">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4008">    if (value &lt; 0) {</a>
<a name="ln4009">      errmsg = e_positive;</a>
<a name="ln4010">    }</a>
<a name="ln4011">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4012">    if (value &lt; 0) {</a>
<a name="ln4013">      errmsg = e_positive;</a>
<a name="ln4014">    } else if (value &gt; p_wh) {</a>
<a name="ln4015">      errmsg = e_winheight;</a>
<a name="ln4016">    }</a>
<a name="ln4017">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4018">    if (value &lt; 1) {</a>
<a name="ln4019">      errmsg = e_positive;</a>
<a name="ln4020">    } else if (p_wmw &gt; value) {</a>
<a name="ln4021">      errmsg = e_winwidth;</a>
<a name="ln4022">    }</a>
<a name="ln4023">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4024">    if (value &lt; 0) {</a>
<a name="ln4025">      errmsg = e_positive;</a>
<a name="ln4026">    } else if (value &gt; p_wiw) {</a>
<a name="ln4027">      errmsg = e_winwidth;</a>
<a name="ln4028">    }</a>
<a name="ln4029">  } else if (pp == &amp;p_mco) {</a>
<a name="ln4030">    value = MAX_MCO;</a>
<a name="ln4031">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4032">    if (value &lt; 0) {</a>
<a name="ln4033">      errmsg = e_positive;</a>
<a name="ln4034">    }</a>
<a name="ln4035">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4036">    if (value &lt; 0) {</a>
<a name="ln4037">      errmsg = e_positive;</a>
<a name="ln4038">    }</a>
<a name="ln4039">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4040">    int minval = ui_has(kUIMessages) ? 0 : 1;</a>
<a name="ln4041">    if (value &lt; minval) {</a>
<a name="ln4042">      errmsg = e_positive;</a>
<a name="ln4043">    }</a>
<a name="ln4044">  } else if (pp == &amp;p_tm) {</a>
<a name="ln4045">    if (value &lt; 0) {</a>
<a name="ln4046">      errmsg = e_positive;</a>
<a name="ln4047">    }</a>
<a name="ln4048">  } else if (pp == &amp;p_hi) {</a>
<a name="ln4049">    if (value &lt; 0) {</a>
<a name="ln4050">      errmsg = e_positive;</a>
<a name="ln4051">    } else if (value &gt; 10000) {</a>
<a name="ln4052">      errmsg = e_invarg;</a>
<a name="ln4053">    }</a>
<a name="ln4054">  } else if (pp == &amp;p_re) {</a>
<a name="ln4055">    if (value &lt; 0 || value &gt; 2) {</a>
<a name="ln4056">      errmsg = e_invarg;</a>
<a name="ln4057">    }</a>
<a name="ln4058">  } else if (pp == &amp;p_report) {</a>
<a name="ln4059">    if (value &lt; 0) {</a>
<a name="ln4060">      errmsg = e_positive;</a>
<a name="ln4061">    }</a>
<a name="ln4062">  } else if (pp == &amp;p_so) {</a>
<a name="ln4063">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4064">      errmsg = e_positive;</a>
<a name="ln4065">    }</a>
<a name="ln4066">  } else if (pp == &amp;p_siso) {</a>
<a name="ln4067">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4068">      errmsg = e_positive;</a>
<a name="ln4069">    }</a>
<a name="ln4070">  } else if (pp == &amp;p_cwh) {</a>
<a name="ln4071">    if (value &lt; 1) {</a>
<a name="ln4072">      errmsg = e_positive;</a>
<a name="ln4073">    }</a>
<a name="ln4074">  } else if (pp == &amp;p_ut) {</a>
<a name="ln4075">    if (value &lt; 0) {</a>
<a name="ln4076">      errmsg = e_positive;</a>
<a name="ln4077">    }</a>
<a name="ln4078">  } else if (pp == &amp;p_ss) {</a>
<a name="ln4079">    if (value &lt; 0) {</a>
<a name="ln4080">      errmsg = e_positive;</a>
<a name="ln4081">    }</a>
<a name="ln4082">  } else if (pp == &amp;curwin-&gt;w_p_fdl || pp == &amp;curwin-&gt;w_allbuf_opt.wo_fdl) {</a>
<a name="ln4083">    if (value &lt; 0) {</a>
<a name="ln4084">      errmsg = e_positive;</a>
<a name="ln4085">    }</a>
<a name="ln4086">  } else if (pp == &amp;curwin-&gt;w_p_cole || pp == &amp;curwin-&gt;w_allbuf_opt.wo_cole) {</a>
<a name="ln4087">    if (value &lt; 0) {</a>
<a name="ln4088">      errmsg = e_positive;</a>
<a name="ln4089">    } else if (value &gt; 3) {</a>
<a name="ln4090">      errmsg = e_invarg;</a>
<a name="ln4091">    }</a>
<a name="ln4092">  } else if (pp == &amp;curwin-&gt;w_p_nuw || pp == &amp;curwin-&gt;w_allbuf_opt.wo_nuw) {</a>
<a name="ln4093">    if (value &lt; 1) {</a>
<a name="ln4094">      errmsg = e_positive;</a>
<a name="ln4095">    } else if (value &gt; 20) {</a>
<a name="ln4096">      errmsg = e_invarg;</a>
<a name="ln4097">    }</a>
<a name="ln4098">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert || pp == &amp;p_iminsert) {</a>
<a name="ln4099">    if (value &lt; 0 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4100">      errmsg = e_invarg;</a>
<a name="ln4101">    }</a>
<a name="ln4102">  } else if (pp == &amp;curbuf-&gt;b_p_imsearch || pp == &amp;p_imsearch) {</a>
<a name="ln4103">    if (value &lt; -1 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4104">      errmsg = e_invarg;</a>
<a name="ln4105">    }</a>
<a name="ln4106">  } else if (pp == &amp;curbuf-&gt;b_p_channel || pp == &amp;p_channel) {</a>
<a name="ln4107">    errmsg = e_invarg;</a>
<a name="ln4108">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4109">    if (value &lt; -1 || value &gt; SB_MAX) {</a>
<a name="ln4110">      errmsg = e_invarg;</a>
<a name="ln4111">    }</a>
<a name="ln4112">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;p_sw) {</a>
<a name="ln4113">    if (value &lt; 0) {</a>
<a name="ln4114">      errmsg = e_positive;</a>
<a name="ln4115">    }</a>
<a name="ln4116">  } else if (pp == &amp;curbuf-&gt;b_p_ts || pp == &amp;p_ts) {</a>
<a name="ln4117">    if (value &lt; 1) {</a>
<a name="ln4118">      errmsg = e_positive;</a>
<a name="ln4119">    }</a>
<a name="ln4120">  } else if (pp == &amp;curbuf-&gt;b_p_tw || pp == &amp;p_tw) {</a>
<a name="ln4121">    if (value &lt; 0) {</a>
<a name="ln4122">      errmsg = e_positive;</a>
<a name="ln4123">    }</a>
<a name="ln4124">  } else if (pp == &amp;p_wd) {</a>
<a name="ln4125">    if (value &lt; 0) {</a>
<a name="ln4126">      errmsg = e_positive;</a>
<a name="ln4127">    }</a>
<a name="ln4128">  }</a>
<a name="ln4129"> </a>
<a name="ln4130">  // Don't change the value and return early if validation failed.</a>
<a name="ln4131">  if (errmsg != NULL) {</a>
<a name="ln4132">    return (char *)errmsg;</a>
<a name="ln4133">  }</a>
<a name="ln4134"> </a>
<a name="ln4135">  *pp = value;</a>
<a name="ln4136">  // Remember where the option was set.</a>
<a name="ln4137">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln4138"> </a>
<a name="ln4139">  // For these options we want to fix some invalid values.</a>
<a name="ln4140">  if (pp == &amp;p_window) {</a>
<a name="ln4141">    if (p_window &lt; 1) {</a>
<a name="ln4142">      p_window = Rows - 1;</a>
<a name="ln4143">    } else if (p_window &gt;= Rows) {</a>
<a name="ln4144">      p_window = Rows - 1;</a>
<a name="ln4145">    }</a>
<a name="ln4146">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4147">    if (ui_has(kUIMessages)) {</a>
<a name="ln4148">      p_ch = 0;</a>
<a name="ln4149">    }</a>
<a name="ln4150">    if (p_ch &gt; Rows - min_rows() + 1) {</a>
<a name="ln4151">      p_ch = Rows - min_rows() + 1;</a>
<a name="ln4152">    }</a>
<a name="ln4153">  }</a>
<a name="ln4154"> </a>
<a name="ln4155">  // Number options that need some action when changed</a>
<a name="ln4156">  if (pp == &amp;p_wh) {</a>
<a name="ln4157">    // 'winheight'</a>
<a name="ln4158">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_height &lt; p_wh) {</a>
<a name="ln4159">      win_setheight((int)p_wh);</a>
<a name="ln4160">    }</a>
<a name="ln4161">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4162">    // 'helpheight'</a>
<a name="ln4163">    if (!ONE_WINDOW &amp;&amp; curbuf-&gt;b_help &amp;&amp; curwin-&gt;w_height &lt; p_hh) {</a>
<a name="ln4164">      win_setheight((int)p_hh);</a>
<a name="ln4165">    }</a>
<a name="ln4166">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4167">    // 'winminheight'</a>
<a name="ln4168">    win_setminheight();</a>
<a name="ln4169">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4170">    // 'winwidth'</a>
<a name="ln4171">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_width &lt; p_wiw) {</a>
<a name="ln4172">      win_setwidth((int)p_wiw);</a>
<a name="ln4173">    }</a>
<a name="ln4174">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4175">    // 'winminwidth'</a>
<a name="ln4176">    win_setminwidth();</a>
<a name="ln4177">  } else if (pp == &amp;p_ls) {</a>
<a name="ln4178">    last_status(false);  // (re)set last window status line.</a>
<a name="ln4179">  } else if (pp == &amp;p_stal) {</a>
<a name="ln4180">    // (re)set tab page line</a>
<a name="ln4181">    shell_new_rows();   // recompute window positions and heights</a>
<a name="ln4182">  } else if (pp == &amp;curwin-&gt;w_p_fdl) {</a>
<a name="ln4183">    newFoldLevel();</a>
<a name="ln4184">  } else if (pp == &amp;curwin-&gt;w_p_fml) {</a>
<a name="ln4185">    foldUpdateAll(curwin);</a>
<a name="ln4186">  } else if (pp == &amp;curwin-&gt;w_p_fdn) {</a>
<a name="ln4187">    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin)) {</a>
<a name="ln4188">      foldUpdateAll(curwin);</a>
<a name="ln4189">    }</a>
<a name="ln4190">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;curbuf-&gt;b_p_ts) {</a>
<a name="ln4191">    // 'shiftwidth' or 'tabstop'</a>
<a name="ln4192">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln4193">      foldUpdateAll(curwin);</a>
<a name="ln4194">    }</a>
<a name="ln4195">    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:</a>
<a name="ln4196">    // parse 'cinoptions'.</a>
<a name="ln4197">    if (pp == &amp;curbuf-&gt;b_p_sw || curbuf-&gt;b_p_sw == 0) {</a>
<a name="ln4198">      parse_cino(curbuf);</a>
<a name="ln4199">    }</a>
<a name="ln4200">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert) {</a>
<a name="ln4201">    showmode();</a>
<a name="ln4202">    // Show/unshow value of 'keymap' in status lines.</a>
<a name="ln4203">    status_redraw_curbuf();</a>
<a name="ln4204">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4205">    // if 'titlelen' has changed, redraw the title</a>
<a name="ln4206">    if (starting != NO_SCREEN &amp;&amp; old_value != p_titlelen) {</a>
<a name="ln4207">      need_maketitle = true;</a>
<a name="ln4208">    }</a>
<a name="ln4209">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4210">    // if p_ch changed value, change the command line height</a>
<a name="ln4211">    // Only compute the new window layout when startup has been</a>
<a name="ln4212">    // completed. Otherwise the frame sizes may be wrong.</a>
<a name="ln4213">    if (p_ch != old_value &amp;&amp; full_screen) {</a>
<a name="ln4214">      command_height();</a>
<a name="ln4215">    }</a>
<a name="ln4216">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4217">    // when 'updatecount' changes from zero to non-zero, open swap files</a>
<a name="ln4218">    if (p_uc &amp;&amp; !old_value) {</a>
<a name="ln4219">      ml_open_files();</a>
<a name="ln4220">    }</a>
<a name="ln4221">  } else if (pp == &amp;p_pb) {</a>
<a name="ln4222">    p_pb = MAX(MIN(p_pb, 100), 0);</a>
<a name="ln4223">    hl_invalidate_blends();</a>
<a name="ln4224">    pum_grid.blending = (p_pb &gt; 0);</a>
<a name="ln4225">    if (pum_drawn()) {</a>
<a name="ln4226">      pum_redraw();</a>
<a name="ln4227">    }</a>
<a name="ln4228">  } else if (pp == &amp;p_pyx) {</a>
<a name="ln4229">    if (p_pyx != 0 &amp;&amp; p_pyx != 2 &amp;&amp; p_pyx != 3) {</a>
<a name="ln4230">      errmsg = e_invarg;</a>
<a name="ln4231">    }</a>
<a name="ln4232">  } else if (pp == &amp;p_ul || pp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln4233">    // sync undo before 'undolevels' changes</a>
<a name="ln4234">    // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln4235">    *pp = old_value;</a>
<a name="ln4236">    u_sync(true);</a>
<a name="ln4237">    *pp = value;</a>
<a name="ln4238">  } else if (pp == &amp;curbuf-&gt;b_p_tw) {</a>
<a name="ln4239">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4240">      check_colorcolumn(wp);</a>
<a name="ln4241">    }</a>
<a name="ln4242">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4243">    if (curbuf-&gt;terminal) {</a>
<a name="ln4244">      // Force the scrollback to take effect.</a>
<a name="ln4245">      terminal_check_size(curbuf-&gt;terminal);</a>
<a name="ln4246">    }</a>
<a name="ln4247">  } else if (pp == &amp;curwin-&gt;w_p_nuw) {</a>
<a name="ln4248">    curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln4249">  } else if (pp == &amp;curwin-&gt;w_p_winbl &amp;&amp; value != old_value) {</a>
<a name="ln4250">    // 'floatblend'</a>
<a name="ln4251">    curwin-&gt;w_p_winbl = MAX(MIN(curwin-&gt;w_p_winbl, 100), 0);</a>
<a name="ln4252">    curwin-&gt;w_hl_needs_update = true;</a>
<a name="ln4253">    curwin-&gt;w_grid.blending = curwin-&gt;w_p_winbl &gt; 0;</a>
<a name="ln4254">  }</a>
<a name="ln4255"> </a>
<a name="ln4256"> </a>
<a name="ln4257">  // Check the (new) bounds for Rows and Columns here.</a>
<a name="ln4258">  if (p_lines &lt; min_rows() &amp;&amp; full_screen) {</a>
<a name="ln4259">    if (errbuf != NULL) {</a>
<a name="ln4260">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4261">          _(&quot;E593: Need at least %d lines&quot;), min_rows());</a>
<a name="ln4262">      errmsg = errbuf;</a>
<a name="ln4263">    }</a>
<a name="ln4264">    p_lines = min_rows();</a>
<a name="ln4265">  }</a>
<a name="ln4266">  if (p_columns &lt; MIN_COLUMNS &amp;&amp; full_screen) {</a>
<a name="ln4267">    if (errbuf != NULL) {</a>
<a name="ln4268">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4269">          _(&quot;E594: Need at least %d columns&quot;), MIN_COLUMNS);</a>
<a name="ln4270">      errmsg = errbuf;</a>
<a name="ln4271">    }</a>
<a name="ln4272">    p_columns = MIN_COLUMNS;</a>
<a name="ln4273">  }</a>
<a name="ln4274"> </a>
<a name="ln4275">  // True max size is defined by check_shellsize()</a>
<a name="ln4276">  p_lines = MIN(p_lines, INT_MAX);</a>
<a name="ln4277">  p_columns = MIN(p_columns, INT_MAX);</a>
<a name="ln4278"> </a>
<a name="ln4279">  // If the screen (shell) height has been changed, assume it is the</a>
<a name="ln4280">  // physical screenheight.</a>
<a name="ln4281">  if (p_lines != Rows || p_columns != Columns) {</a>
<a name="ln4282">    // Changing the screen size is not allowed while updating the screen.</a>
<a name="ln4283">    if (updating_screen) {</a>
<a name="ln4284">      *pp = old_value;</a>
<a name="ln4285">    } else if (full_screen) {</a>
<a name="ln4286">      screen_resize((int)p_columns, (int)p_lines);</a>
<a name="ln4287">    } else {</a>
<a name="ln4288">      // TODO(bfredl): is this branch ever needed?</a>
<a name="ln4289">      // Postpone the resizing; check the size and cmdline position for</a>
<a name="ln4290">      // messages.</a>
<a name="ln4291">      Rows = (int)p_lines;</a>
<a name="ln4292">      Columns = (int)p_columns;</a>
<a name="ln4293">      check_shellsize();</a>
<a name="ln4294">      if (cmdline_row &gt; Rows - p_ch &amp;&amp; Rows &gt; p_ch) {</a>
<a name="ln4295">        assert(p_ch &gt;= 0 &amp;&amp; Rows - p_ch &lt;= INT_MAX);</a>
<a name="ln4296">        cmdline_row = (int)(Rows - p_ch);</a>
<a name="ln4297">      }</a>
<a name="ln4298">    }</a>
<a name="ln4299">    if (p_window &gt;= Rows || !option_was_set(&quot;window&quot;)) {</a>
<a name="ln4300">      p_window = Rows - 1;</a>
<a name="ln4301">    }</a>
<a name="ln4302">  }</a>
<a name="ln4303"> </a>
<a name="ln4304">  if ((curwin-&gt;w_p_scr &lt;= 0</a>
<a name="ln4305">       || (curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4306">           &amp;&amp; curwin-&gt;w_height &gt; 0))</a>
<a name="ln4307">      &amp;&amp; full_screen) {</a>
<a name="ln4308">    if (pp == &amp;(curwin-&gt;w_p_scr)) {</a>
<a name="ln4309">      if (curwin-&gt;w_p_scr != 0) {</a>
<a name="ln4310">        errmsg = e_scroll;</a>
<a name="ln4311">      }</a>
<a name="ln4312">      win_comp_scroll(curwin);</a>
<a name="ln4313">    } else if (curwin-&gt;w_p_scr &lt;= 0) {</a>
<a name="ln4314">    // If 'scroll' became invalid because of a side effect silently adjust it.</a>
<a name="ln4315">      curwin-&gt;w_p_scr = 1;</a>
<a name="ln4316">    } else {  // curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4317">      curwin-&gt;w_p_scr = curwin-&gt;w_height;</a>
<a name="ln4318">    }</a>
<a name="ln4319">  }</a>
<a name="ln4320">  if ((p_sj &lt; -100 || p_sj &gt;= Rows) &amp;&amp; full_screen) {</a>
<a name="ln4321">    if (Rows != old_Rows) {     // Rows changed, just adjust p_sj</a>
<a name="ln4322">      p_sj = Rows / 2;</a>
<a name="ln4323">    } else {</a>
<a name="ln4324">      errmsg = e_scroll;</a>
<a name="ln4325">      p_sj = 1;</a>
<a name="ln4326">    }</a>
<a name="ln4327">  }</a>
<a name="ln4328"> </a>
<a name="ln4329">  // May set global value for local option.</a>
<a name="ln4330">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln4331">    *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = *pp;</a>
<a name="ln4332">  }</a>
<a name="ln4333"> </a>
<a name="ln4334">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln4335"> </a>
<a name="ln4336">  // Don't do this while starting up, failure or recursively.</a>
<a name="ln4337">  if (!starting &amp;&amp; errmsg == NULL &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4338">    char buf_old[NUMBUFLEN];</a>
<a name="ln4339">    char buf_new[NUMBUFLEN];</a>
<a name="ln4340">    char buf_type[7];</a>
<a name="ln4341"> </a>
<a name="ln4342">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%ld&quot;, old_value);</a>
<a name="ln4343">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%ld&quot;, value);</a>
<a name="ln4344">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4345">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4346">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln4347">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln4348">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4349">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4350">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln4351">                   NULL, false, NULL);</a>
<a name="ln4352">    reset_v_option_vars();</a>
<a name="ln4353">  }</a>
<a name="ln4354"> </a>
<a name="ln4355">  if (errmsg == NULL &amp;&amp; options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln4356">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln4357">                       INTEGER_OBJ(value));</a>
<a name="ln4358">  }</a>
<a name="ln4359"> </a>
<a name="ln4360">  comp_col();                       // in case 'columns' or 'ls' changed</a>
<a name="ln4361">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln4362">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln4363">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4364">  }</a>
<a name="ln4365">  check_redraw(options[opt_idx].flags);</a>
<a name="ln4366"> </a>
<a name="ln4367">  return (char *)errmsg;</a>
<a name="ln4368">}</a>
<a name="ln4369"> </a>
<a name="ln4370">static void trigger_optionsset_string(int opt_idx, int opt_flags,</a>
<a name="ln4371">                                      char *oldval, char *newval)</a>
<a name="ln4372">{</a>
<a name="ln4373">  // Don't do this recursively.</a>
<a name="ln4374">  if (oldval != NULL</a>
<a name="ln4375">      &amp;&amp; newval != NULL</a>
<a name="ln4376">      &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4377">    char buf_type[7];</a>
<a name="ln4378"> </a>
<a name="ln4379">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4380">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4381">    set_vim_var_string(VV_OPTION_OLD, oldval, -1);</a>
<a name="ln4382">    set_vim_var_string(VV_OPTION_NEW, newval, -1);</a>
<a name="ln4383">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4384">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4385">                   (char_u *)options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln4386">    reset_v_option_vars();</a>
<a name="ln4387">  }</a>
<a name="ln4388">}</a>
<a name="ln4389"> </a>
<a name="ln4390">/// Called after an option changed: check if something needs to be redrawn.</a>
<a name="ln4391">static void check_redraw(uint32_t flags)</a>
<a name="ln4392">{</a>
<a name="ln4393">  // Careful: P_RCLR and P_RALL are a combination of other P_ flags</a>
<a name="ln4394">  bool doclear = (flags &amp; P_RCLR) == P_RCLR;</a>
<a name="ln4395">  bool all = ((flags &amp; P_RALL) == P_RALL || doclear);</a>
<a name="ln4396"> </a>
<a name="ln4397">  if ((flags &amp; P_RSTAT) || all) {  // mark all status lines dirty</a>
<a name="ln4398">    status_redraw_all();</a>
<a name="ln4399">  }</a>
<a name="ln4400"> </a>
<a name="ln4401">  if ((flags &amp; P_RBUF) || (flags &amp; P_RWIN) || all) {</a>
<a name="ln4402">    changed_window_setting();</a>
<a name="ln4403">  }</a>
<a name="ln4404">  if (flags &amp; P_RBUF) {</a>
<a name="ln4405">    redraw_curbuf_later(NOT_VALID);</a>
<a name="ln4406">  }</a>
<a name="ln4407">  if (flags &amp; P_RWINONLY) {</a>
<a name="ln4408">    redraw_later(curwin, NOT_VALID);</a>
<a name="ln4409">  }</a>
<a name="ln4410">  if (doclear) {</a>
<a name="ln4411">    redraw_all_later(CLEAR);</a>
<a name="ln4412">  } else if (all) {</a>
<a name="ln4413">    redraw_all_later(NOT_VALID);</a>
<a name="ln4414">  }</a>
<a name="ln4415">}</a>
<a name="ln4416"> </a>
<a name="ln4417">/// Find index for named option</a>
<a name="ln4418">///</a>
<a name="ln4419">/// @param[in]  arg  Option to find index for.</a>
<a name="ln4420">/// @param[in]  len  Length of the option.</a>
<a name="ln4421">///</a>
<a name="ln4422">/// @return Index of the option or -1 if option was not found.</a>
<a name="ln4423">int findoption_len(const char *const arg, const size_t len)</a>
<a name="ln4424">{</a>
<a name="ln4425">  const char *s;</a>
<a name="ln4426">  const char *p;</a>
<a name="ln4427">  static int quick_tab[27] = { 0, 0 };  // quick access table</a>
<a name="ln4428"> </a>
<a name="ln4429">  // For first call: Initialize the quick-access table.</a>
<a name="ln4430">  // It contains the index for the first option that starts with a certain</a>
<a name="ln4431">  // letter.  There are 26 letters, plus the first &quot;t_&quot; option.</a>
<a name="ln4432">  if (quick_tab[1] == 0) {</a>
<a name="ln4433">    p = options[0].fullname;</a>
<a name="ln4434">    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {</a>
<a name="ln4435">      if (s[0] != p[0]) {</a>
<a name="ln4436">        if (s[0] == 't' &amp;&amp; s[1] == '_') {</a>
<a name="ln4437">          quick_tab[26] = i;</a>
<a name="ln4438">        } else {</a>
<a name="ln4439">          quick_tab[CharOrdLow(s[0])] = i;</a>
<a name="ln4440">        }</a>
<a name="ln4441">      }</a>
<a name="ln4442">      p = s;</a>
<a name="ln4443">    }</a>
<a name="ln4444">  }</a>
<a name="ln4445"> </a>
<a name="ln4446">  // Check for name starting with an illegal character.</a>
<a name="ln4447">  if (len == 0 || arg[0] &lt; 'a' || arg[0] &gt; 'z') {</a>
<a name="ln4448">    return -1;</a>
<a name="ln4449">  }</a>
<a name="ln4450"> </a>
<a name="ln4451">  int opt_idx;</a>
<a name="ln4452">  const bool is_term_opt = (len &gt; 2 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_');</a>
<a name="ln4453">  if (is_term_opt) {</a>
<a name="ln4454">    opt_idx = quick_tab[26];</a>
<a name="ln4455">  } else {</a>
<a name="ln4456">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4457">  }</a>
<a name="ln4458">  // Match full name</a>
<a name="ln4459">  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {</a>
<a name="ln4460">    if (strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4461">      break;</a>
<a name="ln4462">    }</a>
<a name="ln4463">  }</a>
<a name="ln4464">  if (s == NULL &amp;&amp; !is_term_opt) {</a>
<a name="ln4465">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4466">    // Match short name</a>
<a name="ln4467">    for (; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln4468">      s = options[opt_idx].shortname;</a>
<a name="ln4469">      if (s != NULL &amp;&amp; strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4470">        break;</a>
<a name="ln4471">      }</a>
<a name="ln4472">      s = NULL;</a>
<a name="ln4473">    }</a>
<a name="ln4474">  }</a>
<a name="ln4475">  if (s == NULL) {</a>
<a name="ln4476">    opt_idx = -1;</a>
<a name="ln4477">  } else {</a>
<a name="ln4478">    // Nvim: handle option aliases.</a>
<a name="ln4479">    if (STRNCMP(options[opt_idx].fullname, &quot;viminfo&quot;, 7) == 0) {</a>
<a name="ln4480">      if (STRLEN(options[opt_idx].fullname) == 7) {</a>
<a name="ln4481">        return findoption_len(&quot;shada&quot;, 5);</a>
<a name="ln4482">      }</a>
<a name="ln4483">      assert(STRCMP(options[opt_idx].fullname, &quot;viminfofile&quot;) == 0);</a>
<a name="ln4484">      return findoption_len(&quot;shadafile&quot;, 9);</a>
<a name="ln4485">    }</a>
<a name="ln4486">  }</a>
<a name="ln4487">  return opt_idx;</a>
<a name="ln4488">}</a>
<a name="ln4489"> </a>
<a name="ln4490">bool is_tty_option(const char *name)</a>
<a name="ln4491">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4492">{</a>
<a name="ln4493">  return (name[0] == 't' &amp;&amp; name[1] == '_')</a>
<a name="ln4494">    || strequal(name, &quot;term&quot;)</a>
<a name="ln4495">    || strequal(name, &quot;ttytype&quot;);</a>
<a name="ln4496">}</a>
<a name="ln4497"> </a>
<a name="ln4498">#define TCO_BUFFER_SIZE 8</a>
<a name="ln4499">/// @param name TUI-related option</a>
<a name="ln4500">/// @param[out,allocated] value option string value</a>
<a name="ln4501">bool get_tty_option(char *name, char **value)</a>
<a name="ln4502">{</a>
<a name="ln4503">  if (strequal(name, &quot;t_Co&quot;)) {</a>
<a name="ln4504">    if (value) {</a>
<a name="ln4505">      if (t_colors &lt;= 1) {</a>
<a name="ln4506">        *value = xstrdup(&quot;&quot;);</a>
<a name="ln4507">      } else {</a>
<a name="ln4508">        *value = xmalloc(TCO_BUFFER_SIZE);</a>
<a name="ln4509">        snprintf(*value, TCO_BUFFER_SIZE, &quot;%d&quot;, t_colors);</a>
<a name="ln4510">      }</a>
<a name="ln4511">    }</a>
<a name="ln4512">    return true;</a>
<a name="ln4513">  }</a>
<a name="ln4514"> </a>
<a name="ln4515">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4516">    if (value) {</a>
<a name="ln4517">      *value = p_term ? xstrdup(p_term) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4518">    }</a>
<a name="ln4519">    return true;</a>
<a name="ln4520">  }</a>
<a name="ln4521"> </a>
<a name="ln4522">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4523">    if (value) {</a>
<a name="ln4524">      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4525">    }</a>
<a name="ln4526">    return true;</a>
<a name="ln4527">  }</a>
<a name="ln4528"> </a>
<a name="ln4529">  if (is_tty_option(name)) {</a>
<a name="ln4530">    if (value) {</a>
<a name="ln4531">      // XXX: All other t_* options were removed in 3baba1e7.</a>
<a name="ln4532">      *value = xstrdup(&quot;&quot;);</a>
<a name="ln4533">    }</a>
<a name="ln4534">    return true;</a>
<a name="ln4535">  }</a>
<a name="ln4536"> </a>
<a name="ln4537">  return false;</a>
<a name="ln4538">}</a>
<a name="ln4539"> </a>
<a name="ln4540">bool set_tty_option(const char *name, char *value)</a>
<a name="ln4541">{</a>
<a name="ln4542">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4543">    if (p_term) {</a>
<a name="ln4544">      xfree(p_term);</a>
<a name="ln4545">    }</a>
<a name="ln4546">    p_term = value;</a>
<a name="ln4547">    return true;</a>
<a name="ln4548">  }</a>
<a name="ln4549"> </a>
<a name="ln4550">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4551">    if (p_ttytype) {</a>
<a name="ln4552">      xfree(p_ttytype);</a>
<a name="ln4553">    }</a>
<a name="ln4554">    p_ttytype = value;</a>
<a name="ln4555">    return true;</a>
<a name="ln4556">  }</a>
<a name="ln4557"> </a>
<a name="ln4558">  return false;</a>
<a name="ln4559">}</a>
<a name="ln4560"> </a>
<a name="ln4561">/// Find index for an option</a>
<a name="ln4562">///</a>
<a name="ln4563">/// @param[in]  arg  Option name.</a>
<a name="ln4564">///</a>
<a name="ln4565">/// @return Option index or -1 if option was not found.</a>
<a name="ln4566">static int findoption(const char *const arg)</a>
<a name="ln4567">{</a>
<a name="ln4568">  return findoption_len(arg, strlen(arg));</a>
<a name="ln4569">}</a>
<a name="ln4570"> </a>
<a name="ln4571">/// Gets the value for an option.</a>
<a name="ln4572">///</a>
<a name="ln4573">/// @returns:</a>
<a name="ln4574">/// Number or Toggle option: 1, *numval gets value.</a>
<a name="ln4575">///           String option: 0, *stringval gets allocated string.</a>
<a name="ln4576">/// Hidden Number or Toggle option: -1.</a>
<a name="ln4577">///           hidden String option: -2.</a>
<a name="ln4578">///                 unknown option: -3.</a>
<a name="ln4579">int get_option_value(</a>
<a name="ln4580">    char_u *name,</a>
<a name="ln4581">    long *numval,</a>
<a name="ln4582">    char_u **stringval,            ///&lt; NULL when only checking existence</a>
<a name="ln4583">    int opt_flags</a>
<a name="ln4584">)</a>
<a name="ln4585">{</a>
<a name="ln4586">  if (get_tty_option((char *)name, (char **)stringval)) {</a>
<a name="ln4587">    return 0;</a>
<a name="ln4588">  }</a>
<a name="ln4589"> </a>
<a name="ln4590">  int opt_idx = findoption((const char *)name);</a>
<a name="ln4591">  if (opt_idx &lt; 0) {  // Unknown option.</a>
<a name="ln4592">    return -3;</a>
<a name="ln4593">  }</a>
<a name="ln4594"> </a>
<a name="ln4595">  char_u *varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4596"> </a>
<a name="ln4597">  if (options[opt_idx].flags &amp; P_STRING) {</a>
<a name="ln4598">    if (varp == NULL) {  // hidden option</a>
<a name="ln4599">      return -2;</a>
<a name="ln4600">    }</a>
<a name="ln4601">    if (stringval != NULL) {</a>
<a name="ln4602">      *stringval = vim_strsave(*(char_u **)(varp));</a>
<a name="ln4603">    }</a>
<a name="ln4604">    return 0;</a>
<a name="ln4605">  }</a>
<a name="ln4606"> </a>
<a name="ln4607">  if (varp == NULL) {  // hidden option</a>
<a name="ln4608">    return -1;</a>
<a name="ln4609">  }</a>
<a name="ln4610">  if (options[opt_idx].flags &amp; P_NUM) {</a>
<a name="ln4611">    *numval = *(long *)varp;</a>
<a name="ln4612">  } else {</a>
<a name="ln4613">    // Special case: 'modified' is b_changed, but we also want to consider</a>
<a name="ln4614">    // it set when 'ff' or 'fenc' changed.</a>
<a name="ln4615">    if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln4616">      *numval = curbufIsChanged();</a>
<a name="ln4617">    } else {</a>
<a name="ln4618">      *numval = (long) *(int *)varp;  // NOLINT(whitespace/cast)</a>
<a name="ln4619">    }</a>
<a name="ln4620">  }</a>
<a name="ln4621">  return 1;</a>
<a name="ln4622">}</a>
<a name="ln4623"> </a>
<a name="ln4624">// Returns the option attributes and its value. Unlike the above function it</a>
<a name="ln4625">// will return either global value or local value of the option depending on</a>
<a name="ln4626">// what was requested, but it will never return global value if it was</a>
<a name="ln4627">// requested to return local one and vice versa. Neither it will return</a>
<a name="ln4628">// buffer-local value if it was requested to return window-local one.</a>
<a name="ln4629">//</a>
<a name="ln4630">// Pretends that option is absent if it is not present in the requested scope</a>
<a name="ln4631">// (i.e. has no global, window-local or buffer-local value depending on</a>
<a name="ln4632">// opt_type).</a>
<a name="ln4633">//</a>
<a name="ln4634">// Returned flags:</a>
<a name="ln4635">//       0 hidden or unknown option, also option that does not have requested</a>
<a name="ln4636">//         type (see SREQ_* in option_defs.h)</a>
<a name="ln4637">//  see SOPT_* in option_defs.h for other flags</a>
<a name="ln4638">//</a>
<a name="ln4639">// Possible opt_type values: see SREQ_* in option_defs.h</a>
<a name="ln4640">int get_option_value_strict(char *name,</a>
<a name="ln4641">                            int64_t *numval,</a>
<a name="ln4642">                            char **stringval,</a>
<a name="ln4643">                            int opt_type,</a>
<a name="ln4644">                            void *from)</a>
<a name="ln4645">{</a>
<a name="ln4646">  if (get_tty_option(name, stringval)) {</a>
<a name="ln4647">    return SOPT_STRING | SOPT_GLOBAL;</a>
<a name="ln4648">  }</a>
<a name="ln4649"> </a>
<a name="ln4650">  char_u *varp = NULL;</a>
<a name="ln4651">  int rv = 0;</a>
<a name="ln4652">  int opt_idx = findoption(name);</a>
<a name="ln4653">  if (opt_idx &lt; 0) {</a>
<a name="ln4654">    return 0;</a>
<a name="ln4655">  }</a>
<a name="ln4656"> </a>
<a name="ln4657">  vimoption_T *p = &amp;options[opt_idx];</a>
<a name="ln4658"> </a>
<a name="ln4659">  // Hidden option</a>
<a name="ln4660">  if (p-&gt;var == NULL) {</a>
<a name="ln4661">    return 0;</a>
<a name="ln4662">  }</a>
<a name="ln4663"> </a>
<a name="ln4664">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4665">    rv |= SOPT_BOOL;</a>
<a name="ln4666">  } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4667">    rv |= SOPT_NUM;</a>
<a name="ln4668">  } else if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4669">    rv |= SOPT_STRING;</a>
<a name="ln4670">  }</a>
<a name="ln4671"> </a>
<a name="ln4672">  if (p-&gt;indir == PV_NONE) {</a>
<a name="ln4673">    if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4674">      rv |= SOPT_GLOBAL;</a>
<a name="ln4675">    } else {</a>
<a name="ln4676">      return 0;  // Did not request global-only option</a>
<a name="ln4677">    }</a>
<a name="ln4678">  } else {</a>
<a name="ln4679">    if (p-&gt;indir &amp; PV_BOTH) {</a>
<a name="ln4680">      rv |= SOPT_GLOBAL;</a>
<a name="ln4681">    }</a>
<a name="ln4682"> </a>
<a name="ln4683">    if (p-&gt;indir &amp; PV_WIN) {</a>
<a name="ln4684">      if (opt_type == SREQ_BUF) {</a>
<a name="ln4685">        return 0;  // Requested buffer-local, not window-local option</a>
<a name="ln4686">      } else {</a>
<a name="ln4687">        rv |= SOPT_WIN;</a>
<a name="ln4688">      }</a>
<a name="ln4689">    } else if (p-&gt;indir &amp; PV_BUF) {</a>
<a name="ln4690">      if (opt_type == SREQ_WIN) {</a>
<a name="ln4691">        return 0;  // Requested window-local, not buffer-local option</a>
<a name="ln4692">      } else {</a>
<a name="ln4693">        rv |= SOPT_BUF;</a>
<a name="ln4694">      }</a>
<a name="ln4695">    }</a>
<a name="ln4696">  }</a>
<a name="ln4697"> </a>
<a name="ln4698">  if (stringval == NULL) {</a>
<a name="ln4699">    return rv;</a>
<a name="ln4700">  }</a>
<a name="ln4701"> </a>
<a name="ln4702">  if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4703">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln4704">      return 0;</a>
<a name="ln4705">    } else {</a>
<a name="ln4706">      varp = p-&gt;var;</a>
<a name="ln4707">    }</a>
<a name="ln4708">  } else {</a>
<a name="ln4709">    if (opt_type == SREQ_BUF) {</a>
<a name="ln4710">      // Special case: 'modified' is b_changed, but we also want to</a>
<a name="ln4711">      // consider it set when 'ff' or 'fenc' changed.</a>
<a name="ln4712">      if (p-&gt;indir == PV_MOD) {</a>
<a name="ln4713">        *numval = bufIsChanged((buf_T *)from);</a>
<a name="ln4714">        varp = NULL;</a>
<a name="ln4715">      } else {</a>
<a name="ln4716">        buf_T *save_curbuf = curbuf;</a>
<a name="ln4717"> </a>
<a name="ln4718">        // only getting a pointer, no need to use aucmd_prepbuf()</a>
<a name="ln4719">        curbuf = (buf_T *)from;</a>
<a name="ln4720">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4721">        varp = get_varp(p);</a>
<a name="ln4722">        curbuf = save_curbuf;</a>
<a name="ln4723">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4724">      }</a>
<a name="ln4725">    } else if (opt_type == SREQ_WIN) {</a>
<a name="ln4726">      win_T *save_curwin = curwin;</a>
<a name="ln4727">      curwin = (win_T *)from;</a>
<a name="ln4728">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4729">      varp = get_varp(p);</a>
<a name="ln4730">      curwin = save_curwin;</a>
<a name="ln4731">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4732">    }</a>
<a name="ln4733"> </a>
<a name="ln4734">    if (varp == p-&gt;var) {</a>
<a name="ln4735">      return (rv | SOPT_UNSET);</a>
<a name="ln4736">    }</a>
<a name="ln4737">  }</a>
<a name="ln4738"> </a>
<a name="ln4739">  if (varp != NULL) {</a>
<a name="ln4740">    if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4741">      *stringval = xstrdup(*(char **)(varp));</a>
<a name="ln4742">    } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4743">      *numval = *(long *) varp;</a>
<a name="ln4744">    } else {</a>
<a name="ln4745">      *numval = *(int *)varp;</a>
<a name="ln4746">    }</a>
<a name="ln4747">  }</a>
<a name="ln4748"> </a>
<a name="ln4749">  return rv;</a>
<a name="ln4750">}</a>
<a name="ln4751"> </a>
<a name="ln4752">/// Set the value of an option</a>
<a name="ln4753">///</a>
<a name="ln4754">/// @param[in]  name  Option name.</a>
<a name="ln4755">/// @param[in]  number  New value for the number or boolean option.</a>
<a name="ln4756">/// @param[in]  string  New value for string option.</a>
<a name="ln4757">/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).</a>
<a name="ln4758">///</a>
<a name="ln4759">/// @return NULL on success, error message on error.</a>
<a name="ln4760">char *set_option_value(const char *const name, const long number,</a>
<a name="ln4761">                       const char *const string, const int opt_flags)</a>
<a name="ln4762">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4763">{</a>
<a name="ln4764">  if (is_tty_option(name)) {</a>
<a name="ln4765">    return NULL;  // Fail silently; many old vimrcs set t_xx options.</a>
<a name="ln4766">  }</a>
<a name="ln4767"> </a>
<a name="ln4768">  int opt_idx;</a>
<a name="ln4769">  char_u      *varp;</a>
<a name="ln4770"> </a>
<a name="ln4771">  opt_idx = findoption(name);</a>
<a name="ln4772">  if (opt_idx &lt; 0) {</a>
<a name="ln4773">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln4774">  } else {</a>
<a name="ln4775">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln4776">    // Disallow changing some options in the sandbox</a>
<a name="ln4777">    if (sandbox &gt; 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln4778">      EMSG(_(e_sandbox));</a>
<a name="ln4779">      return NULL;</a>
<a name="ln4780">    }</a>
<a name="ln4781">    if (flags &amp; P_STRING) {</a>
<a name="ln4782">      const char *s = string;</a>
<a name="ln4783">      if (s == NULL) {</a>
<a name="ln4784">        s = &quot;&quot;;</a>
<a name="ln4785">      }</a>
<a name="ln4786">      return set_string_option(opt_idx, s, opt_flags);</a>
<a name="ln4787">    } else {</a>
<a name="ln4788">      varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4789">      if (varp != NULL) {       // hidden option is not changed</a>
<a name="ln4790">        if (number == 0 &amp;&amp; string != NULL) {</a>
<a name="ln4791">          int idx;</a>
<a name="ln4792"> </a>
<a name="ln4793">          // Either we are given a string or we are setting option</a>
<a name="ln4794">          // to zero.</a>
<a name="ln4795">          for (idx = 0; string[idx] == '0'; idx++) {}</a>
<a name="ln4796">          if (string[idx] != NUL || idx == 0) {</a>
<a name="ln4797">            // There's another character after zeros or the string</a>
<a name="ln4798">            // is empty.  In both cases, we are trying to set a</a>
<a name="ln4799">            // num option using a string.</a>
<a name="ln4800">            EMSG3(_(&quot;E521: Number required: &amp;%s = '%s'&quot;),</a>
<a name="ln4801">                  name, string);</a>
<a name="ln4802">            return NULL;  // do nothing as we hit an error</a>
<a name="ln4803">          }</a>
<a name="ln4804">        }</a>
<a name="ln4805">        if (flags &amp; P_NUM) {</a>
<a name="ln4806">          return set_num_option(opt_idx, varp, number, NULL, 0, opt_flags);</a>
<a name="ln4807">        } else {</a>
<a name="ln4808">          return set_bool_option(opt_idx, varp, (int)number, opt_flags);</a>
<a name="ln4809">        }</a>
<a name="ln4810">      }</a>
<a name="ln4811">    }</a>
<a name="ln4812">  }</a>
<a name="ln4813">  return NULL;</a>
<a name="ln4814">}</a>
<a name="ln4815"> </a>
<a name="ln4816">// Translate a string like &quot;t_xx&quot;, &quot;&lt;t_xx&gt;&quot; or &quot;&lt;S-Tab&gt;&quot; to a key number.</a>
<a name="ln4817">// When &quot;has_lt&quot; is true there is a '&lt;' before &quot;*arg_arg&quot;.</a>
<a name="ln4818">// Returns 0 when the key is not recognized.</a>
<a name="ln4819">int find_key_option_len(const char_u *arg_arg, size_t len, bool has_lt)</a>
<a name="ln4820">{</a>
<a name="ln4821">  int key = 0;</a>
<a name="ln4822">  int modifiers;</a>
<a name="ln4823">  const char_u *arg = arg_arg;</a>
<a name="ln4824"> </a>
<a name="ln4825">  // Don't use get_special_key_code() for t_xx, we don't want it to call</a>
<a name="ln4826">  // add_termcap_entry().</a>
<a name="ln4827">  if (len &gt;= 4 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_') {</a>
<a name="ln4828">    key = TERMCAP2KEY(arg[2], arg[3]);</a>
<a name="ln4829">  } else if (has_lt)  {</a>
<a name="ln4830">    arg--;  // put arg at the '&lt;'</a>
<a name="ln4831">    modifiers = 0;</a>
<a name="ln4832">    key = find_special_key(&amp;arg, len + 1, &amp;modifiers, true, true, false);</a>
<a name="ln4833">    if (modifiers) {  // can't handle modifiers here</a>
<a name="ln4834">      key = 0;</a>
<a name="ln4835">    }</a>
<a name="ln4836">  }</a>
<a name="ln4837">  return key;</a>
<a name="ln4838">}</a>
<a name="ln4839"> </a>
<a name="ln4840">static int find_key_option(const char_u *arg, bool has_lt)</a>
<a name="ln4841">{</a>
<a name="ln4842">  return find_key_option_len(arg, STRLEN(arg), has_lt);</a>
<a name="ln4843">}</a>
<a name="ln4844"> </a>
<a name="ln4845">/// if 'all' == 0: show changed options</a>
<a name="ln4846">/// if 'all' == 1: show all normal options</a>
<a name="ln4847">static void</a>
<a name="ln4848">showoptions(</a>
<a name="ln4849">    int all,</a>
<a name="ln4850">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln4851">)</a>
<a name="ln4852">{</a>
<a name="ln4853">  vimoption_T    *p;</a>
<a name="ln4854">  int col;</a>
<a name="ln4855">  char_u              *varp;</a>
<a name="ln4856">  int item_count;</a>
<a name="ln4857">  int run;</a>
<a name="ln4858">  int row, rows;</a>
<a name="ln4859">  int cols;</a>
<a name="ln4860">  int i;</a>
<a name="ln4861">  int len;</a>
<a name="ln4862"> </a>
<a name="ln4863">#define INC 20</a>
<a name="ln4864">#define GAP 3</a>
<a name="ln4865"> </a>
<a name="ln4866">  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);</a>
<a name="ln4867"> </a>
<a name="ln4868">  // Highlight title</a>
<a name="ln4869">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln4870">    MSG_PUTS_TITLE(_(&quot;\n--- Global option values ---&quot;));</a>
<a name="ln4871">  } else if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln4872">    MSG_PUTS_TITLE(_(&quot;\n--- Local option values ---&quot;));</a>
<a name="ln4873">  } else {</a>
<a name="ln4874">    MSG_PUTS_TITLE(_(&quot;\n--- Options ---&quot;));</a>
<a name="ln4875">  }</a>
<a name="ln4876"> </a>
<a name="ln4877">  // Do the loop two times:</a>
<a name="ln4878">  // 1. display the short items</a>
<a name="ln4879">  // 2. display the long items (only strings and numbers)</a>
<a name="ln4880">  for (run = 1; run &lt;= 2 &amp;&amp; !got_int; run++) {</a>
<a name="ln4881">    // collect the items in items[]</a>
<a name="ln4882">    item_count = 0;</a>
<a name="ln4883">    for (p = &amp;options[0]; p-&gt;fullname != NULL; p++) {</a>
<a name="ln4884">      // apply :filter /pat/</a>
<a name="ln4885">      if (message_filtered((char_u *)p-&gt;fullname)) {</a>
<a name="ln4886">        continue;</a>
<a name="ln4887">      }</a>
<a name="ln4888"> </a>
<a name="ln4889">      varp = NULL;</a>
<a name="ln4890">      if (opt_flags != 0) {</a>
<a name="ln4891">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln4892">          varp = get_varp_scope(p, opt_flags);</a>
<a name="ln4893">        }</a>
<a name="ln4894">      } else {</a>
<a name="ln4895">        varp = get_varp(p);</a>
<a name="ln4896">      }</a>
<a name="ln4897">      if (varp != NULL</a>
<a name="ln4898">          &amp;&amp; (all == 1 || (all == 0 &amp;&amp; !optval_default(p, varp)))) {</a>
<a name="ln4899">        if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4900">          len = 1;                      //  a toggle option fits always</a>
<a name="ln4901">        } else {</a>
<a name="ln4902">          option_value2string(p, opt_flags);</a>
<a name="ln4903">          len = (int)STRLEN(p-&gt;fullname) + vim_strsize(NameBuff) + 1;</a>
<a name="ln4904">        }</a>
<a name="ln4905">        if ((len &lt;= INC - GAP &amp;&amp; run == 1)</a>
<a name="ln4906">            || (len &gt; INC - GAP &amp;&amp; run == 2)) {</a>
<a name="ln4907">          items[item_count++] = p;</a>
<a name="ln4908">        }</a>
<a name="ln4909">      }</a>
<a name="ln4910">    }</a>
<a name="ln4911"> </a>
<a name="ln4912">    /*</a>
<a name="ln4913">     * display the items</a>
<a name="ln4914">     */</a>
<a name="ln4915">    if (run == 1) {</a>
<a name="ln4916">      assert(Columns &lt;= INT_MAX - GAP</a>
<a name="ln4917">             &amp;&amp; Columns + GAP &gt;= INT_MIN + 3</a>
<a name="ln4918">             &amp;&amp; (Columns + GAP - 3) / INC &gt;= INT_MIN</a>
<a name="ln4919">             &amp;&amp; (Columns + GAP - 3) / INC &lt;= INT_MAX);</a>
<a name="ln4920">      cols = (int)((Columns + GAP - 3) / INC);</a>
<a name="ln4921">      if (cols == 0) {</a>
<a name="ln4922">        cols = 1;</a>
<a name="ln4923">      }</a>
<a name="ln4924">      rows = (item_count + cols - 1) / cols;</a>
<a name="ln4925">    } else {    // run == 2</a>
<a name="ln4926">      rows = item_count;</a>
<a name="ln4927">    }</a>
<a name="ln4928">    for (row = 0; row &lt; rows &amp;&amp; !got_int; row++) {</a>
<a name="ln4929">      msg_putchar('\n');                        // go to next line</a>
<a name="ln4930">      if (got_int) {                            // 'q' typed in more</a>
<a name="ln4931">        break;</a>
<a name="ln4932">      }</a>
<a name="ln4933">      col = 0;</a>
<a name="ln4934">      for (i = row; i &lt; item_count; i += rows) {</a>
<a name="ln4935">        msg_col = col;                          // make columns</a>
<a name="ln4936">        showoneopt(items[i], opt_flags);</a>
<a name="ln4937">        col += INC;</a>
<a name="ln4938">      }</a>
<a name="ln4939">      ui_flush();</a>
<a name="ln4940">      os_breakcheck();</a>
<a name="ln4941">    }</a>
<a name="ln4942">  }</a>
<a name="ln4943">  xfree(items);</a>
<a name="ln4944">}</a>
<a name="ln4945"> </a>
<a name="ln4946">/// Return true if option &quot;p&quot; has its default value.</a>
<a name="ln4947">static int optval_default(vimoption_T *p, char_u *varp)</a>
<a name="ln4948">{</a>
<a name="ln4949">  int dvi;</a>
<a name="ln4950"> </a>
<a name="ln4951">  if (varp == NULL) {</a>
<a name="ln4952">    return true;            // hidden option is always at default</a>
<a name="ln4953">  }</a>
<a name="ln4954">  dvi = (p-&gt;flags &amp; P_VI_DEF) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln4955">  if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4956">    return *(long *)varp == (long)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln4957">  }</a>
<a name="ln4958">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4959">    return *(int *)varp == (int)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln4960">  }</a>
<a name="ln4961">  // P_STRING</a>
<a name="ln4962">  return STRCMP(*(char_u **)varp, p-&gt;def_val[dvi]) == 0;</a>
<a name="ln4963">}</a>
<a name="ln4964"> </a>
<a name="ln4965">/// Send update to UIs with values of UI relevant options</a>
<a name="ln4966">void ui_refresh_options(void)</a>
<a name="ln4967">{</a>
<a name="ln4968">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln4969">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln4970">    if (!(flags &amp; P_UI_OPTION)) {</a>
<a name="ln4971">      continue;</a>
<a name="ln4972">    }</a>
<a name="ln4973">    String name = cstr_as_string(options[opt_idx].fullname);</a>
<a name="ln4974">    void *varp = options[opt_idx].var;</a>
<a name="ln4975">    Object value = OBJECT_INIT;</a>
<a name="ln4976">    if (flags &amp; P_BOOL) {</a>
<a name="ln4977">      value = BOOLEAN_OBJ(*(int *)varp);</a>
<a name="ln4978">    } else if (flags &amp; P_NUM) {</a>
<a name="ln4979">      value = INTEGER_OBJ(*(long *)varp);</a>
<a name="ln4980">    } else if (flags &amp; P_STRING) {</a>
<a name="ln4981">      // cstr_as_string handles NULL string</a>
<a name="ln4982">      value = STRING_OBJ(cstr_as_string(*(char **)varp));</a>
<a name="ln4983">    }</a>
<a name="ln4984">    ui_call_option_set(name, value);</a>
<a name="ln4985">  }</a>
<a name="ln4986">  if (p_mouse != NULL) {</a>
<a name="ln4987">    setmouse();</a>
<a name="ln4988">  }</a>
<a name="ln4989">}</a>
<a name="ln4990"> </a>
<a name="ln4991">/// showoneopt: show the value of one option</a>
<a name="ln4992">/// must not be called with a hidden option!</a>
<a name="ln4993">static void</a>
<a name="ln4994">showoneopt(</a>
<a name="ln4995">    vimoption_T *p,</a>
<a name="ln4996">    int opt_flags                          // OPT_LOCAL or OPT_GLOBAL</a>
<a name="ln4997">)</a>
<a name="ln4998">{</a>
<a name="ln4999">  char_u      *varp;</a>
<a name="ln5000">  int save_silent = silent_mode;</a>
<a name="ln5001"> </a>
<a name="ln5002">  silent_mode = false;</a>
<a name="ln5003">  info_message = true;          // use mch_msg(), not mch_errmsg()</a>
<a name="ln5004"> </a>
<a name="ln5005">  varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5006"> </a>
<a name="ln5007">  // for 'modified' we also need to check if 'ff' or 'fenc' changed.</a>
<a name="ln5008">  if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; ((int *)varp == &amp;curbuf-&gt;b_changed</a>
<a name="ln5009">                              ? !curbufIsChanged() : !*(int *)varp)) {</a>
<a name="ln5010">    MSG_PUTS(&quot;no&quot;);</a>
<a name="ln5011">  } else if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; *(int *)varp &lt; 0) {</a>
<a name="ln5012">    MSG_PUTS(&quot;--&quot;);</a>
<a name="ln5013">  } else {</a>
<a name="ln5014">    MSG_PUTS(&quot;  &quot;);</a>
<a name="ln5015">  }</a>
<a name="ln5016">  MSG_PUTS(p-&gt;fullname);</a>
<a name="ln5017">  if (!(p-&gt;flags &amp; P_BOOL)) {</a>
<a name="ln5018">    msg_putchar('=');</a>
<a name="ln5019">    // put value string in NameBuff</a>
<a name="ln5020">    option_value2string(p, opt_flags);</a>
<a name="ln5021">    msg_outtrans(NameBuff);</a>
<a name="ln5022">  }</a>
<a name="ln5023"> </a>
<a name="ln5024">  silent_mode = save_silent;</a>
<a name="ln5025">  info_message = false;</a>
<a name="ln5026">}</a>
<a name="ln5027"> </a>
<a name="ln5028">/// Write modified options as &quot;:set&quot; commands to a file.</a>
<a name="ln5029">///</a>
<a name="ln5030">/// There are three values for &quot;opt_flags&quot;:</a>
<a name="ln5031">/// OPT_GLOBAL:         Write global option values and fresh values of</a>
<a name="ln5032">///             buffer-local options (used for start of a session</a>
<a name="ln5033">///             file).</a>
<a name="ln5034">/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for</a>
<a name="ln5035">///             curwin (used for a vimrc file).</a>
<a name="ln5036">/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh</a>
<a name="ln5037">///             and local values for window-local options of</a>
<a name="ln5038">///             curwin.  Local values are also written when at the</a>
<a name="ln5039">///             default value, because a modeline or autocommand</a>
<a name="ln5040">///             may have set them when doing &quot;:edit file&quot; and the</a>
<a name="ln5041">///             user has set them back at the default or fresh</a>
<a name="ln5042">///             value.</a>
<a name="ln5043">///             When &quot;local_only&quot; is true, don't write fresh</a>
<a name="ln5044">///             values, only local values (for &quot;:mkview&quot;).</a>
<a name="ln5045">/// (fresh value = value used for a new buffer or window for a local option).</a>
<a name="ln5046">///</a>
<a name="ln5047">/// Return FAIL on error, OK otherwise.</a>
<a name="ln5048">int makeset(FILE *fd, int opt_flags, int local_only)</a>
<a name="ln5049">{</a>
<a name="ln5050">  vimoption_T    *p;</a>
<a name="ln5051">  char_u              *varp;                    // currently used value</a>
<a name="ln5052">  char_u              *varp_fresh;              // local value</a>
<a name="ln5053">  char_u              *varp_local = NULL;       // fresh value</a>
<a name="ln5054">  char                *cmd;</a>
<a name="ln5055">  int round;</a>
<a name="ln5056">  int pri;</a>
<a name="ln5057"> </a>
<a name="ln5058">  /*</a>
<a name="ln5059">   * Some options are never written:</a>
<a name="ln5060">   * - Options that don't have a default (terminal name, columns, lines).</a>
<a name="ln5061">   * - Terminal options.</a>
<a name="ln5062">   * - Hidden options.</a>
<a name="ln5063">   *</a>
<a name="ln5064">   * Do the loop over &quot;options[]&quot; twice: once for options with the</a>
<a name="ln5065">   * P_PRI_MKRC flag and once without.</a>
<a name="ln5066">   */</a>
<a name="ln5067">  for (pri = 1; pri &gt;= 0; pri--) {</a>
<a name="ln5068">    for (p = &amp;options[0]; p-&gt;fullname; p++) {</a>
<a name="ln5069">      if (!(p-&gt;flags &amp; P_NO_MKRC)</a>
<a name="ln5070">          &amp;&amp; ((pri == 1) == ((p-&gt;flags &amp; P_PRI_MKRC) != 0))) {</a>
<a name="ln5071">        // skip global option when only doing locals</a>
<a name="ln5072">        if (p-&gt;indir == PV_NONE &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5073">          continue;</a>
<a name="ln5074">        }</a>
<a name="ln5075"> </a>
<a name="ln5076">        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc</a>
<a name="ln5077">         * file, they are always buffer-specific. */</a>
<a name="ln5078">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; (p-&gt;flags &amp; P_NOGLOB)) {</a>
<a name="ln5079">          continue;</a>
<a name="ln5080">        }</a>
<a name="ln5081"> </a>
<a name="ln5082">        varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5083">        // Hidden options are never written.</a>
<a name="ln5084">        if (!varp) {</a>
<a name="ln5085">          continue;</a>
<a name="ln5086">        }</a>
<a name="ln5087">        // Global values are only written when not at the default value.</a>
<a name="ln5088">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; optval_default(p, varp)) {</a>
<a name="ln5089">          continue;</a>
<a name="ln5090">        }</a>
<a name="ln5091"> </a>
<a name="ln5092">        round = 2;</a>
<a name="ln5093">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln5094">          if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5095">            // skip window-local option when only doing globals</a>
<a name="ln5096">            if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln5097">              continue;</a>
<a name="ln5098">            }</a>
<a name="ln5099">            // When fresh value of window-local option is not at the</a>
<a name="ln5100">            // default, need to write it too.</a>
<a name="ln5101">            if (!(opt_flags &amp; OPT_GLOBAL) &amp;&amp; !local_only) {</a>
<a name="ln5102">              varp_fresh = get_varp_scope(p, OPT_GLOBAL);</a>
<a name="ln5103">              if (!optval_default(p, varp_fresh)) {</a>
<a name="ln5104">                round = 1;</a>
<a name="ln5105">                varp_local = varp;</a>
<a name="ln5106">                varp = varp_fresh;</a>
<a name="ln5107">              }</a>
<a name="ln5108">            }</a>
<a name="ln5109">          }</a>
<a name="ln5110">        }</a>
<a name="ln5111"> </a>
<a name="ln5112">        /* Round 1: fresh value for window-local options.</a>
<a name="ln5113">         * Round 2: other values */</a>
<a name="ln5114">        for (; round &lt;= 2; varp = varp_local, round++) {</a>
<a name="ln5115">          if (round == 1 || (opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5116">            cmd = &quot;set&quot;;</a>
<a name="ln5117">          } else {</a>
<a name="ln5118">            cmd = &quot;setlocal&quot;;</a>
<a name="ln5119">          }</a>
<a name="ln5120"> </a>
<a name="ln5121">          if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5122">            if (put_setbool(fd, cmd, p-&gt;fullname, *(int *)varp) == FAIL) {</a>
<a name="ln5123">              return FAIL;</a>
<a name="ln5124">            }</a>
<a name="ln5125">          } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln5126">            if (put_setnum(fd, cmd, p-&gt;fullname, (long *)varp) == FAIL) {</a>
<a name="ln5127">              return FAIL;</a>
<a name="ln5128">            }</a>
<a name="ln5129">          } else {    // P_STRING</a>
<a name="ln5130">            int do_endif = false;</a>
<a name="ln5131"> </a>
<a name="ln5132">            // Don't set 'syntax' and 'filetype' again if the value is</a>
<a name="ln5133">            // already right, avoids reloading the syntax file.</a>
<a name="ln5134">            if (p-&gt;indir == PV_SYN || p-&gt;indir == PV_FT) {</a>
<a name="ln5135">              if (fprintf(fd, &quot;if &amp;%s != '%s'&quot;, p-&gt;fullname,</a>
<a name="ln5136">                          *(char_u **)(varp)) &lt; 0</a>
<a name="ln5137">                  || put_eol(fd) &lt; 0) {</a>
<a name="ln5138">                return FAIL;</a>
<a name="ln5139">              }</a>
<a name="ln5140">              do_endif = true;</a>
<a name="ln5141">            }</a>
<a name="ln5142">            if (put_setstring(fd, cmd, p-&gt;fullname, (char_u **)varp,</a>
<a name="ln5143">                              p-&gt;flags) == FAIL) {</a>
<a name="ln5144">              return FAIL;</a>
<a name="ln5145">            }</a>
<a name="ln5146">            if (do_endif) {</a>
<a name="ln5147">              if (put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln5148">                return FAIL;</a>
<a name="ln5149">              }</a>
<a name="ln5150">            }</a>
<a name="ln5151">          }</a>
<a name="ln5152">        }</a>
<a name="ln5153">      }</a>
<a name="ln5154">    }</a>
<a name="ln5155">  }</a>
<a name="ln5156">  return OK;</a>
<a name="ln5157">}</a>
<a name="ln5158"> </a>
<a name="ln5159">/// Generate set commands for the local fold options only.  Used when</a>
<a name="ln5160">/// 'sessionoptions' or 'viewoptions' contains &quot;folds&quot; but not &quot;options&quot;.</a>
<a name="ln5161">int makefoldset(FILE *fd)</a>
<a name="ln5162">{</a>
<a name="ln5163">  if (put_setstring(fd, &quot;setlocal&quot;, &quot;fdm&quot;, &amp;curwin-&gt;w_p_fdm, 0) == FAIL</a>
<a name="ln5164">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fde&quot;, &amp;curwin-&gt;w_p_fde, 0)</a>
<a name="ln5165">      == FAIL</a>
<a name="ln5166">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fmr&quot;, &amp;curwin-&gt;w_p_fmr, 0)</a>
<a name="ln5167">      == FAIL</a>
<a name="ln5168">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fdi&quot;, &amp;curwin-&gt;w_p_fdi, 0)</a>
<a name="ln5169">      == FAIL</a>
<a name="ln5170">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdl&quot;, &amp;curwin-&gt;w_p_fdl) == FAIL</a>
<a name="ln5171">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fml&quot;, &amp;curwin-&gt;w_p_fml) == FAIL</a>
<a name="ln5172">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdn&quot;, &amp;curwin-&gt;w_p_fdn) == FAIL</a>
<a name="ln5173">      || put_setbool(fd, &quot;setlocal&quot;, &quot;fen&quot;, curwin-&gt;w_p_fen) == FAIL</a>
<a name="ln5174">      ) {</a>
<a name="ln5175">    return FAIL;</a>
<a name="ln5176">  }</a>
<a name="ln5177"> </a>
<a name="ln5178">  return OK;</a>
<a name="ln5179">}</a>
<a name="ln5180"> </a>
<a name="ln5181">static int put_setstring(FILE *fd, char *cmd, char *name,</a>
<a name="ln5182">                         char_u **valuep, uint64_t flags)</a>
<a name="ln5183">{</a>
<a name="ln5184">  char_u      *s;</a>
<a name="ln5185">  char_u      *buf = NULL;</a>
<a name="ln5186">  char_u      *part = NULL;</a>
<a name="ln5187">  char_u      *p;</a>
<a name="ln5188"> </a>
<a name="ln5189">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5190">    return FAIL;</a>
<a name="ln5191">  }</a>
<a name="ln5192">  if (*valuep != NULL) {</a>
<a name="ln5193">    /* Output 'pastetoggle' as key names.  For other</a>
<a name="ln5194">     * options some characters have to be escaped with</a>
<a name="ln5195">     * CTRL-V or backslash */</a>
<a name="ln5196">    if (valuep == &amp;p_pt) {</a>
<a name="ln5197">      s = *valuep;</a>
<a name="ln5198">      while (*s != NUL) {</a>
<a name="ln5199">        if (put_escstr(fd, (char_u *)str2special((const char **)&amp;s, false,</a>
<a name="ln5200">                                                 false), 2)</a>
<a name="ln5201">            == FAIL) {</a>
<a name="ln5202">          return FAIL;</a>
<a name="ln5203">        }</a>
<a name="ln5204">      }</a>
<a name="ln5205">    } else if ((flags &amp; P_EXPAND) != 0) {</a>
<a name="ln5206">      size_t size = (size_t)STRLEN(*valuep) + 1;</a>
<a name="ln5207"> </a>
<a name="ln5208">      // replace home directory in the whole option value into &quot;buf&quot;</a>
<a name="ln5209">      buf = xmalloc(size);</a>
<a name="ln5210">      home_replace(NULL, *valuep, buf, size, false);</a>
<a name="ln5211"> </a>
<a name="ln5212">      // If the option value is longer than MAXPATHL, we need to append</a>
<a name="ln5213">      // earch comma separated part of the option sperately, so that it</a>
<a name="ln5214">      // can be expanded when read back.</a>
<a name="ln5215">      if (size &gt;= MAXPATHL &amp;&amp; (flags &amp; P_COMMA) != 0</a>
<a name="ln5216">          &amp;&amp; vim_strchr(*valuep, ',') != NULL) {</a>
<a name="ln5217">        part = xmalloc(size);</a>
<a name="ln5218"> </a>
<a name="ln5219">        // write line break to clear the option, e.g. ':set rtp='</a>
<a name="ln5220">        if (put_eol(fd) == FAIL) {</a>
<a name="ln5221">          goto fail;</a>
<a name="ln5222">        }</a>
<a name="ln5223">        p = buf;</a>
<a name="ln5224">        while (*p != NUL) {</a>
<a name="ln5225">            // for each comma seperated option part, append value to</a>
<a name="ln5226">            // the option, :set rtp+=value</a>
<a name="ln5227">            if (fprintf(fd, &quot;%s %s+=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5228">              goto fail;</a>
<a name="ln5229">            }</a>
<a name="ln5230">            (void)copy_option_part(&amp;p, part, size, &quot;,&quot;);</a>
<a name="ln5231">            if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {</a>
<a name="ln5232">              goto fail;</a>
<a name="ln5233">            }</a>
<a name="ln5234">        }</a>
<a name="ln5235">        xfree(buf);</a>
<a name="ln5236">        xfree(part);</a>
<a name="ln5237">        return OK;</a>
<a name="ln5238">      }</a>
<a name="ln5239">      if (put_escstr(fd, buf, 2) == FAIL) {</a>
<a name="ln5240">        xfree(buf);</a>
<a name="ln5241">        return FAIL;</a>
<a name="ln5242">      }</a>
<a name="ln5243">      xfree(buf);</a>
<a name="ln5244">    } else if (put_escstr(fd, *valuep, 2) == FAIL) {</a>
<a name="ln5245">      return FAIL;</a>
<a name="ln5246">    }</a>
<a name="ln5247">  }</a>
<a name="ln5248">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5249">    return FAIL;</a>
<a name="ln5250">  }</a>
<a name="ln5251">  return OK;</a>
<a name="ln5252">fail:</a>
<a name="ln5253">  xfree(buf);</a>
<a name="ln5254">  xfree(part);</a>
<a name="ln5255">  return FAIL;</a>
<a name="ln5256">}</a>
<a name="ln5257"> </a>
<a name="ln5258">static int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)</a>
<a name="ln5259">{</a>
<a name="ln5260">  long wc;</a>
<a name="ln5261"> </a>
<a name="ln5262">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5263">    return FAIL;</a>
<a name="ln5264">  }</a>
<a name="ln5265">  if (wc_use_keyname((char_u *)valuep, &amp;wc)) {</a>
<a name="ln5266">    // print 'wildchar' and 'wildcharm' as a key name</a>
<a name="ln5267">    if (fputs((char *)get_special_key_name((int)wc, 0), fd) &lt; 0) {</a>
<a name="ln5268">      return FAIL;</a>
<a name="ln5269">    }</a>
<a name="ln5270">  } else if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(*valuep)) &lt; 0) {</a>
<a name="ln5271">    return FAIL;</a>
<a name="ln5272">  }</a>
<a name="ln5273">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5274">    return FAIL;</a>
<a name="ln5275">  }</a>
<a name="ln5276">  return OK;</a>
<a name="ln5277">}</a>
<a name="ln5278"> </a>
<a name="ln5279">static int put_setbool(FILE *fd, char *cmd, char *name, int value)</a>
<a name="ln5280">{</a>
<a name="ln5281">  if (value &lt; 0) {      // global/local option using global value</a>
<a name="ln5282">    return OK;</a>
<a name="ln5283">  }</a>
<a name="ln5284">  if (fprintf(fd, &quot;%s %s%s&quot;, cmd, value ? &quot;&quot; : &quot;no&quot;, name) &lt; 0</a>
<a name="ln5285">      || put_eol(fd) &lt; 0) {</a>
<a name="ln5286">    return FAIL;</a>
<a name="ln5287">  }</a>
<a name="ln5288">  return OK;</a>
<a name="ln5289">}</a>
<a name="ln5290"> </a>
<a name="ln5291">/// Compute columns for ruler and shown command. 'sc_col' is also used to</a>
<a name="ln5292">/// decide what the maximum length of a message on the status line can be.</a>
<a name="ln5293">/// If there is a status line for the last window, 'sc_col' is independent</a>
<a name="ln5294">/// of 'ru_col'.</a>
<a name="ln5295"> </a>
<a name="ln5296">#define COL_RULER 17        // columns needed by standard ruler</a>
<a name="ln5297"> </a>
<a name="ln5298">void comp_col(void)</a>
<a name="ln5299">{</a>
<a name="ln5300">  int last_has_status = (p_ls == 2 || (p_ls == 1 &amp;&amp; !ONE_WINDOW));</a>
<a name="ln5301"> </a>
<a name="ln5302">  sc_col = 0;</a>
<a name="ln5303">  ru_col = 0;</a>
<a name="ln5304">  if (p_ru) {</a>
<a name="ln5305">    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;</a>
<a name="ln5306">    // no last status line, adjust sc_col</a>
<a name="ln5307">    if (!last_has_status) {</a>
<a name="ln5308">      sc_col = ru_col;</a>
<a name="ln5309">    }</a>
<a name="ln5310">  }</a>
<a name="ln5311">  if (p_sc) {</a>
<a name="ln5312">    sc_col += SHOWCMD_COLS;</a>
<a name="ln5313">    if (!p_ru || last_has_status) {         // no need for separating space</a>
<a name="ln5314">      sc_col++;</a>
<a name="ln5315">    }</a>
<a name="ln5316">  }</a>
<a name="ln5317">  assert(sc_col &gt;= 0</a>
<a name="ln5318">         &amp;&amp; INT_MIN + sc_col &lt;= Columns</a>
<a name="ln5319">         &amp;&amp; Columns - sc_col &lt;= INT_MAX);</a>
<a name="ln5320">  sc_col = (int)(Columns - sc_col);</a>
<a name="ln5321">  assert(ru_col &gt;= 0</a>
<a name="ln5322">         &amp;&amp; INT_MIN + ru_col &lt;= Columns</a>
<a name="ln5323">         &amp;&amp; Columns - ru_col &lt;= INT_MAX);</a>
<a name="ln5324">  ru_col = (int)(Columns - ru_col);</a>
<a name="ln5325">  if (sc_col &lt;= 0) {            // screen too narrow, will become a mess</a>
<a name="ln5326">    sc_col = 1;</a>
<a name="ln5327">  }</a>
<a name="ln5328">  if (ru_col &lt;= 0) {</a>
<a name="ln5329">    ru_col = 1;</a>
<a name="ln5330">  }</a>
<a name="ln5331">  set_vim_var_nr(VV_ECHOSPACE, sc_col - 1);</a>
<a name="ln5332">}</a>
<a name="ln5333"> </a>
<a name="ln5334">// Unset local option value, similar to &quot;:set opt&lt;&quot;.</a>
<a name="ln5335">void unset_global_local_option(char *name, void *from)</a>
<a name="ln5336">{</a>
<a name="ln5337">  vimoption_T *p;</a>
<a name="ln5338">  buf_T *buf = (buf_T *)from;</a>
<a name="ln5339"> </a>
<a name="ln5340">  int opt_idx = findoption(name);</a>
<a name="ln5341">  if (opt_idx &lt; 0) {</a>
<a name="ln5342">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln5343">    return;</a>
<a name="ln5344">  }</a>
<a name="ln5345">  p = &amp;(options[opt_idx]);</a>
<a name="ln5346"> </a>
<a name="ln5347">  switch ((int)p-&gt;indir)</a>
<a name="ln5348">  {</a>
<a name="ln5349">    // global option with local value: use local value if it's been set</a>
<a name="ln5350">    case PV_EP:</a>
<a name="ln5351">      clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln5352">      break;</a>
<a name="ln5353">    case PV_KP:</a>
<a name="ln5354">      clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln5355">      break;</a>
<a name="ln5356">    case PV_PATH:</a>
<a name="ln5357">      clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln5358">      break;</a>
<a name="ln5359">    case PV_AR:</a>
<a name="ln5360">      buf-&gt;b_p_ar = -1;</a>
<a name="ln5361">      break;</a>
<a name="ln5362">    case PV_BKC:</a>
<a name="ln5363">      clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln5364">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln5365">      break;</a>
<a name="ln5366">    case PV_TAGS:</a>
<a name="ln5367">      clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln5368">      break;</a>
<a name="ln5369">    case PV_TC:</a>
<a name="ln5370">      clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln5371">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln5372">      break;</a>
<a name="ln5373">    case PV_SISO:</a>
<a name="ln5374">      curwin-&gt;w_p_siso = -1;</a>
<a name="ln5375">      break;</a>
<a name="ln5376">    case PV_SO:</a>
<a name="ln5377">      curwin-&gt;w_p_so = -1;</a>
<a name="ln5378">      break;</a>
<a name="ln5379">    case PV_DEF:</a>
<a name="ln5380">      clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln5381">      break;</a>
<a name="ln5382">    case PV_INC:</a>
<a name="ln5383">      clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln5384">      break;</a>
<a name="ln5385">    case PV_DICT:</a>
<a name="ln5386">      clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln5387">      break;</a>
<a name="ln5388">    case PV_TSR:</a>
<a name="ln5389">      clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln5390">      break;</a>
<a name="ln5391">    case PV_FP:</a>
<a name="ln5392">      clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln5393">      break;</a>
<a name="ln5394">    case PV_EFM:</a>
<a name="ln5395">      clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln5396">      break;</a>
<a name="ln5397">    case PV_GP:</a>
<a name="ln5398">      clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln5399">      break;</a>
<a name="ln5400">    case PV_MP:</a>
<a name="ln5401">      clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln5402">      break;</a>
<a name="ln5403">    case PV_STL:</a>
<a name="ln5404">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_stl);</a>
<a name="ln5405">      break;</a>
<a name="ln5406">    case PV_UL:</a>
<a name="ln5407">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln5408">      break;</a>
<a name="ln5409">    case PV_LW:</a>
<a name="ln5410">      clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln5411">      break;</a>
<a name="ln5412">    case PV_MENC:</a>
<a name="ln5413">      clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln5414">      break;</a>
<a name="ln5415">    case PV_LCS:</a>
<a name="ln5416">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_lcs);</a>
<a name="ln5417">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_lcs, true);</a>
<a name="ln5418">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5419">      break;</a>
<a name="ln5420">    case PV_FCS:</a>
<a name="ln5421">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_fcs);</a>
<a name="ln5422">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_fcs, true);</a>
<a name="ln5423">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5424">      break;</a>
<a name="ln5425">  }</a>
<a name="ln5426">}</a>
<a name="ln5427"> </a>
<a name="ln5428">/// Get pointer to option variable, depending on local or global scope.</a>
<a name="ln5429">static char_u *get_varp_scope(vimoption_T *p, int opt_flags)</a>
<a name="ln5430">{</a>
<a name="ln5431">  if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; p-&gt;indir != PV_NONE) {</a>
<a name="ln5432">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5433">      return (char_u *)GLOBAL_WO(get_varp(p));</a>
<a name="ln5434">    }</a>
<a name="ln5435">    return p-&gt;var;</a>
<a name="ln5436">  }</a>
<a name="ln5437">  if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; ((int)p-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln5438">    switch ((int)p-&gt;indir) {</a>
<a name="ln5439">    case PV_FP:   return (char_u *)&amp;(curbuf-&gt;b_p_fp);</a>
<a name="ln5440">    case PV_EFM:  return (char_u *)&amp;(curbuf-&gt;b_p_efm);</a>
<a name="ln5441">    case PV_GP:   return (char_u *)&amp;(curbuf-&gt;b_p_gp);</a>
<a name="ln5442">    case PV_MP:   return (char_u *)&amp;(curbuf-&gt;b_p_mp);</a>
<a name="ln5443">    case PV_EP:   return (char_u *)&amp;(curbuf-&gt;b_p_ep);</a>
<a name="ln5444">    case PV_KP:   return (char_u *)&amp;(curbuf-&gt;b_p_kp);</a>
<a name="ln5445">    case PV_PATH: return (char_u *)&amp;(curbuf-&gt;b_p_path);</a>
<a name="ln5446">    case PV_AR:   return (char_u *)&amp;(curbuf-&gt;b_p_ar);</a>
<a name="ln5447">    case PV_TAGS: return (char_u *)&amp;(curbuf-&gt;b_p_tags);</a>
<a name="ln5448">    case PV_TC:   return (char_u *)&amp;(curbuf-&gt;b_p_tc);</a>
<a name="ln5449">    case PV_SISO: return (char_u *)&amp;(curwin-&gt;w_p_siso);</a>
<a name="ln5450">    case PV_SO:   return (char_u *)&amp;(curwin-&gt;w_p_so);</a>
<a name="ln5451">    case PV_DEF:  return (char_u *)&amp;(curbuf-&gt;b_p_def);</a>
<a name="ln5452">    case PV_INC:  return (char_u *)&amp;(curbuf-&gt;b_p_inc);</a>
<a name="ln5453">    case PV_DICT: return (char_u *)&amp;(curbuf-&gt;b_p_dict);</a>
<a name="ln5454">    case PV_TSR:  return (char_u *)&amp;(curbuf-&gt;b_p_tsr);</a>
<a name="ln5455">    case PV_TFU:  return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5456">    case PV_STL:  return (char_u *)&amp;(curwin-&gt;w_p_stl);</a>
<a name="ln5457">    case PV_UL:   return (char_u *)&amp;(curbuf-&gt;b_p_ul);</a>
<a name="ln5458">    case PV_LW:   return (char_u *)&amp;(curbuf-&gt;b_p_lw);</a>
<a name="ln5459">    case PV_BKC:  return (char_u *)&amp;(curbuf-&gt;b_p_bkc);</a>
<a name="ln5460">    case PV_MENC: return (char_u *)&amp;(curbuf-&gt;b_p_menc);</a>
<a name="ln5461">    case PV_FCS:  return (char_u *)&amp;(curwin-&gt;w_p_fcs);</a>
<a name="ln5462">    case PV_LCS:  return (char_u *)&amp;(curwin-&gt;w_p_lcs);</a>
<a name="ln5463">    }</a>
<a name="ln5464">    return NULL;     // &quot;cannot happen&quot;</a>
<a name="ln5465">  }</a>
<a name="ln5466">  return get_varp(p);</a>
<a name="ln5467">}</a>
<a name="ln5468"> </a>
<a name="ln5469">/// Get pointer to option variable.</a>
<a name="ln5470">static char_u *get_varp(vimoption_T *p)</a>
<a name="ln5471">{</a>
<a name="ln5472">  // hidden option, always return NULL</a>
<a name="ln5473">  if (p-&gt;var == NULL) {</a>
<a name="ln5474">    return NULL;</a>
<a name="ln5475">  }</a>
<a name="ln5476"> </a>
<a name="ln5477">  switch ((int)p-&gt;indir) {</a>
<a name="ln5478">  case PV_NONE:   return p-&gt;var;</a>
<a name="ln5479"> </a>
<a name="ln5480">  // global option with local value: use local value if it's been set</a>
<a name="ln5481">  case PV_EP:     return *curbuf-&gt;b_p_ep != NUL</a>
<a name="ln5482">           ? (char_u *)&amp;curbuf-&gt;b_p_ep : p-&gt;var;</a>
<a name="ln5483">  case PV_KP:     return *curbuf-&gt;b_p_kp != NUL</a>
<a name="ln5484">           ? (char_u *)&amp;curbuf-&gt;b_p_kp : p-&gt;var;</a>
<a name="ln5485">  case PV_PATH:   return *curbuf-&gt;b_p_path != NUL</a>
<a name="ln5486">           ? (char_u *)&amp;(curbuf-&gt;b_p_path) : p-&gt;var;</a>
<a name="ln5487">  case PV_AR:     return curbuf-&gt;b_p_ar &gt;= 0</a>
<a name="ln5488">           ? (char_u *)&amp;(curbuf-&gt;b_p_ar) : p-&gt;var;</a>
<a name="ln5489">  case PV_TAGS:   return *curbuf-&gt;b_p_tags != NUL</a>
<a name="ln5490">           ? (char_u *)&amp;(curbuf-&gt;b_p_tags) : p-&gt;var;</a>
<a name="ln5491">  case PV_TC:     return *curbuf-&gt;b_p_tc != NUL</a>
<a name="ln5492">           ? (char_u *)&amp;(curbuf-&gt;b_p_tc) : p-&gt;var;</a>
<a name="ln5493">  case PV_SISO:   return curwin-&gt;w_p_siso &gt;= 0</a>
<a name="ln5494">           ? (char_u *)&amp;(curwin-&gt;w_p_siso) : p-&gt;var;</a>
<a name="ln5495">  case PV_SO:     return curwin-&gt;w_p_so &gt;= 0</a>
<a name="ln5496">           ? (char_u *)&amp;(curwin-&gt;w_p_so) : p-&gt;var;</a>
<a name="ln5497">  case PV_BKC:    return *curbuf-&gt;b_p_bkc != NUL</a>
<a name="ln5498">           ? (char_u *)&amp;(curbuf-&gt;b_p_bkc) : p-&gt;var;</a>
<a name="ln5499">  case PV_DEF:    return *curbuf-&gt;b_p_def != NUL</a>
<a name="ln5500">           ? (char_u *)&amp;(curbuf-&gt;b_p_def) : p-&gt;var;</a>
<a name="ln5501">  case PV_INC:    return *curbuf-&gt;b_p_inc != NUL</a>
<a name="ln5502">           ? (char_u *)&amp;(curbuf-&gt;b_p_inc) : p-&gt;var;</a>
<a name="ln5503">  case PV_DICT:   return *curbuf-&gt;b_p_dict != NUL</a>
<a name="ln5504">           ? (char_u *)&amp;(curbuf-&gt;b_p_dict) : p-&gt;var;</a>
<a name="ln5505">  case PV_TSR:    return *curbuf-&gt;b_p_tsr != NUL</a>
<a name="ln5506">           ? (char_u *)&amp;(curbuf-&gt;b_p_tsr) : p-&gt;var;</a>
<a name="ln5507">  case PV_FP: return *curbuf-&gt;b_p_fp != NUL</a>
<a name="ln5508">           ? (char_u *)&amp;(curbuf-&gt;b_p_fp) : p-&gt;var;</a>
<a name="ln5509">  case PV_EFM:    return *curbuf-&gt;b_p_efm != NUL</a>
<a name="ln5510">           ? (char_u *)&amp;(curbuf-&gt;b_p_efm) : p-&gt;var;</a>
<a name="ln5511">  case PV_GP:     return *curbuf-&gt;b_p_gp != NUL</a>
<a name="ln5512">           ? (char_u *)&amp;(curbuf-&gt;b_p_gp) : p-&gt;var;</a>
<a name="ln5513">  case PV_MP:     return *curbuf-&gt;b_p_mp != NUL</a>
<a name="ln5514">           ? (char_u *)&amp;(curbuf-&gt;b_p_mp) : p-&gt;var;</a>
<a name="ln5515">  case PV_STL:    return *curwin-&gt;w_p_stl != NUL</a>
<a name="ln5516">           ? (char_u *)&amp;(curwin-&gt;w_p_stl) : p-&gt;var;</a>
<a name="ln5517">  case PV_UL:     return curbuf-&gt;b_p_ul != NO_LOCAL_UNDOLEVEL</a>
<a name="ln5518">           ? (char_u *)&amp;(curbuf-&gt;b_p_ul) : p-&gt;var;</a>
<a name="ln5519">  case PV_LW:   return *curbuf-&gt;b_p_lw != NUL</a>
<a name="ln5520">           ? (char_u *)&amp;(curbuf-&gt;b_p_lw) : p-&gt;var;</a>
<a name="ln5521">  case PV_MENC: return *curbuf-&gt;b_p_menc != NUL</a>
<a name="ln5522">           ? (char_u *)&amp;(curbuf-&gt;b_p_menc) : p-&gt;var;</a>
<a name="ln5523">  case PV_FCS:    return *curwin-&gt;w_p_fcs != NUL</a>
<a name="ln5524">           ? (char_u *)&amp;(curwin-&gt;w_p_fcs) : p-&gt;var;</a>
<a name="ln5525">  case PV_LCS:    return *curwin-&gt;w_p_lcs != NUL</a>
<a name="ln5526">           ? (char_u *)&amp;(curwin-&gt;w_p_lcs) : p-&gt;var;</a>
<a name="ln5527"> </a>
<a name="ln5528">  case PV_ARAB:   return (char_u *)&amp;(curwin-&gt;w_p_arab);</a>
<a name="ln5529">  case PV_LIST:   return (char_u *)&amp;(curwin-&gt;w_p_list);</a>
<a name="ln5530">  case PV_SPELL:  return (char_u *)&amp;(curwin-&gt;w_p_spell);</a>
<a name="ln5531">  case PV_CUC:    return (char_u *)&amp;(curwin-&gt;w_p_cuc);</a>
<a name="ln5532">  case PV_CUL:    return (char_u *)&amp;(curwin-&gt;w_p_cul);</a>
<a name="ln5533">  case PV_CC:     return (char_u *)&amp;(curwin-&gt;w_p_cc);</a>
<a name="ln5534">  case PV_DIFF:   return (char_u *)&amp;(curwin-&gt;w_p_diff);</a>
<a name="ln5535">  case PV_FDC:    return (char_u *)&amp;(curwin-&gt;w_p_fdc);</a>
<a name="ln5536">  case PV_FEN:    return (char_u *)&amp;(curwin-&gt;w_p_fen);</a>
<a name="ln5537">  case PV_FDI:    return (char_u *)&amp;(curwin-&gt;w_p_fdi);</a>
<a name="ln5538">  case PV_FDL:    return (char_u *)&amp;(curwin-&gt;w_p_fdl);</a>
<a name="ln5539">  case PV_FDM:    return (char_u *)&amp;(curwin-&gt;w_p_fdm);</a>
<a name="ln5540">  case PV_FML:    return (char_u *)&amp;(curwin-&gt;w_p_fml);</a>
<a name="ln5541">  case PV_FDN:    return (char_u *)&amp;(curwin-&gt;w_p_fdn);</a>
<a name="ln5542">  case PV_FDE:    return (char_u *)&amp;(curwin-&gt;w_p_fde);</a>
<a name="ln5543">  case PV_FDT:    return (char_u *)&amp;(curwin-&gt;w_p_fdt);</a>
<a name="ln5544">  case PV_FMR:    return (char_u *)&amp;(curwin-&gt;w_p_fmr);</a>
<a name="ln5545">  case PV_NU:     return (char_u *)&amp;(curwin-&gt;w_p_nu);</a>
<a name="ln5546">  case PV_RNU:    return (char_u *)&amp;(curwin-&gt;w_p_rnu);</a>
<a name="ln5547">  case PV_NUW:    return (char_u *)&amp;(curwin-&gt;w_p_nuw);</a>
<a name="ln5548">  case PV_WFH:    return (char_u *)&amp;(curwin-&gt;w_p_wfh);</a>
<a name="ln5549">  case PV_WFW:    return (char_u *)&amp;(curwin-&gt;w_p_wfw);</a>
<a name="ln5550">  case PV_PVW:    return (char_u *)&amp;(curwin-&gt;w_p_pvw);</a>
<a name="ln5551">  case PV_RL:     return (char_u *)&amp;(curwin-&gt;w_p_rl);</a>
<a name="ln5552">  case PV_RLC:    return (char_u *)&amp;(curwin-&gt;w_p_rlc);</a>
<a name="ln5553">  case PV_SCROLL: return (char_u *)&amp;(curwin-&gt;w_p_scr);</a>
<a name="ln5554">  case PV_WRAP:   return (char_u *)&amp;(curwin-&gt;w_p_wrap);</a>
<a name="ln5555">  case PV_LBR:    return (char_u *)&amp;(curwin-&gt;w_p_lbr);</a>
<a name="ln5556">  case PV_BRI:    return (char_u *)&amp;(curwin-&gt;w_p_bri);</a>
<a name="ln5557">  case PV_BRIOPT: return (char_u *)&amp;(curwin-&gt;w_p_briopt);</a>
<a name="ln5558">  case PV_SCBIND: return (char_u *)&amp;(curwin-&gt;w_p_scb);</a>
<a name="ln5559">  case PV_CRBIND: return (char_u *)&amp;(curwin-&gt;w_p_crb);</a>
<a name="ln5560">  case PV_COCU:    return (char_u *)&amp;(curwin-&gt;w_p_cocu);</a>
<a name="ln5561">  case PV_COLE:    return (char_u *)&amp;(curwin-&gt;w_p_cole);</a>
<a name="ln5562"> </a>
<a name="ln5563">  case PV_AI:     return (char_u *)&amp;(curbuf-&gt;b_p_ai);</a>
<a name="ln5564">  case PV_BIN:    return (char_u *)&amp;(curbuf-&gt;b_p_bin);</a>
<a name="ln5565">  case PV_BOMB:   return (char_u *)&amp;(curbuf-&gt;b_p_bomb);</a>
<a name="ln5566">  case PV_BH:     return (char_u *)&amp;(curbuf-&gt;b_p_bh);</a>
<a name="ln5567">  case PV_BT:     return (char_u *)&amp;(curbuf-&gt;b_p_bt);</a>
<a name="ln5568">  case PV_BL:     return (char_u *)&amp;(curbuf-&gt;b_p_bl);</a>
<a name="ln5569">  case PV_CHANNEL:return (char_u *)&amp;(curbuf-&gt;b_p_channel);</a>
<a name="ln5570">  case PV_CI:     return (char_u *)&amp;(curbuf-&gt;b_p_ci);</a>
<a name="ln5571">  case PV_CIN:    return (char_u *)&amp;(curbuf-&gt;b_p_cin);</a>
<a name="ln5572">  case PV_CINK:   return (char_u *)&amp;(curbuf-&gt;b_p_cink);</a>
<a name="ln5573">  case PV_CINO:   return (char_u *)&amp;(curbuf-&gt;b_p_cino);</a>
<a name="ln5574">  case PV_CINW:   return (char_u *)&amp;(curbuf-&gt;b_p_cinw);</a>
<a name="ln5575">  case PV_COM:    return (char_u *)&amp;(curbuf-&gt;b_p_com);</a>
<a name="ln5576">  case PV_CMS:    return (char_u *)&amp;(curbuf-&gt;b_p_cms);</a>
<a name="ln5577">  case PV_CPT:    return (char_u *)&amp;(curbuf-&gt;b_p_cpt);</a>
<a name="ln5578"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5579">  case PV_CSL:    return (char_u *)&amp;(curbuf-&gt;b_p_csl);</a>
<a name="ln5580"># endif</a>
<a name="ln5581">  case PV_CFU:    return (char_u *)&amp;(curbuf-&gt;b_p_cfu);</a>
<a name="ln5582">  case PV_OFU:    return (char_u *)&amp;(curbuf-&gt;b_p_ofu);</a>
<a name="ln5583">  case PV_EOL:    return (char_u *)&amp;(curbuf-&gt;b_p_eol);</a>
<a name="ln5584">  case PV_FIXEOL: return (char_u *)&amp;(curbuf-&gt;b_p_fixeol);</a>
<a name="ln5585">  case PV_ET:     return (char_u *)&amp;(curbuf-&gt;b_p_et);</a>
<a name="ln5586">  case PV_FENC:   return (char_u *)&amp;(curbuf-&gt;b_p_fenc);</a>
<a name="ln5587">  case PV_FF:     return (char_u *)&amp;(curbuf-&gt;b_p_ff);</a>
<a name="ln5588">  case PV_FT:     return (char_u *)&amp;(curbuf-&gt;b_p_ft);</a>
<a name="ln5589">  case PV_FO:     return (char_u *)&amp;(curbuf-&gt;b_p_fo);</a>
<a name="ln5590">  case PV_FLP:    return (char_u *)&amp;(curbuf-&gt;b_p_flp);</a>
<a name="ln5591">  case PV_IMI:    return (char_u *)&amp;(curbuf-&gt;b_p_iminsert);</a>
<a name="ln5592">  case PV_IMS:    return (char_u *)&amp;(curbuf-&gt;b_p_imsearch);</a>
<a name="ln5593">  case PV_INF:    return (char_u *)&amp;(curbuf-&gt;b_p_inf);</a>
<a name="ln5594">  case PV_ISK:    return (char_u *)&amp;(curbuf-&gt;b_p_isk);</a>
<a name="ln5595">  case PV_INEX:   return (char_u *)&amp;(curbuf-&gt;b_p_inex);</a>
<a name="ln5596">  case PV_INDE:   return (char_u *)&amp;(curbuf-&gt;b_p_inde);</a>
<a name="ln5597">  case PV_INDK:   return (char_u *)&amp;(curbuf-&gt;b_p_indk);</a>
<a name="ln5598">  case PV_FEX:    return (char_u *)&amp;(curbuf-&gt;b_p_fex);</a>
<a name="ln5599">  case PV_LISP:   return (char_u *)&amp;(curbuf-&gt;b_p_lisp);</a>
<a name="ln5600">  case PV_ML:     return (char_u *)&amp;(curbuf-&gt;b_p_ml);</a>
<a name="ln5601">  case PV_MPS:    return (char_u *)&amp;(curbuf-&gt;b_p_mps);</a>
<a name="ln5602">  case PV_MA:     return (char_u *)&amp;(curbuf-&gt;b_p_ma);</a>
<a name="ln5603">  case PV_MOD:    return (char_u *)&amp;(curbuf-&gt;b_changed);</a>
<a name="ln5604">  case PV_NF:     return (char_u *)&amp;(curbuf-&gt;b_p_nf);</a>
<a name="ln5605">  case PV_PI:     return (char_u *)&amp;(curbuf-&gt;b_p_pi);</a>
<a name="ln5606">  case PV_QE:     return (char_u *)&amp;(curbuf-&gt;b_p_qe);</a>
<a name="ln5607">  case PV_RO:     return (char_u *)&amp;(curbuf-&gt;b_p_ro);</a>
<a name="ln5608">  case PV_SCBK:   return (char_u *)&amp;(curbuf-&gt;b_p_scbk);</a>
<a name="ln5609">  case PV_SI:     return (char_u *)&amp;(curbuf-&gt;b_p_si);</a>
<a name="ln5610">  case PV_STS:    return (char_u *)&amp;(curbuf-&gt;b_p_sts);</a>
<a name="ln5611">  case PV_SUA:    return (char_u *)&amp;(curbuf-&gt;b_p_sua);</a>
<a name="ln5612">  case PV_SWF:    return (char_u *)&amp;(curbuf-&gt;b_p_swf);</a>
<a name="ln5613">  case PV_SMC:    return (char_u *)&amp;(curbuf-&gt;b_p_smc);</a>
<a name="ln5614">  case PV_SYN:    return (char_u *)&amp;(curbuf-&gt;b_p_syn);</a>
<a name="ln5615">  case PV_SPC:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln5616">  case PV_SPF:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln5617">  case PV_SPL:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln5618">  case PV_SPO:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln5619">  case PV_SW:     return (char_u *)&amp;(curbuf-&gt;b_p_sw);</a>
<a name="ln5620">  case PV_TFU:    return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5621">  case PV_TS:     return (char_u *)&amp;(curbuf-&gt;b_p_ts);</a>
<a name="ln5622">  case PV_TW:     return (char_u *)&amp;(curbuf-&gt;b_p_tw);</a>
<a name="ln5623">  case PV_UDF:    return (char_u *)&amp;(curbuf-&gt;b_p_udf);</a>
<a name="ln5624">  case PV_WM:     return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5625">  case PV_KMAP:   return (char_u *)&amp;(curbuf-&gt;b_p_keymap);</a>
<a name="ln5626">  case PV_SCL:    return (char_u *)&amp;(curwin-&gt;w_p_scl);</a>
<a name="ln5627">  case PV_WINHL:  return (char_u *)&amp;(curwin-&gt;w_p_winhl);</a>
<a name="ln5628">  case PV_WINBL:  return (char_u *)&amp;(curwin-&gt;w_p_winbl);</a>
<a name="ln5629">  default:        IEMSG(_(&quot;E356: get_varp ERROR&quot;));</a>
<a name="ln5630">  }</a>
<a name="ln5631">  // always return a valid pointer to avoid a crash!</a>
<a name="ln5632">  return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5633">}</a>
<a name="ln5634"> </a>
<a name="ln5635">/// Get the value of 'equalprg', either the buffer-local one or the global one.</a>
<a name="ln5636">char_u *get_equalprg(void)</a>
<a name="ln5637">{</a>
<a name="ln5638">  if (*curbuf-&gt;b_p_ep == NUL) {</a>
<a name="ln5639">    return p_ep;</a>
<a name="ln5640">  }</a>
<a name="ln5641">  return curbuf-&gt;b_p_ep;</a>
<a name="ln5642">}</a>
<a name="ln5643"> </a>
<a name="ln5644">/// Copy options from one window to another.</a>
<a name="ln5645">/// Used when splitting a window.</a>
<a name="ln5646">void win_copy_options(win_T *wp_from, win_T *wp_to)</a>
<a name="ln5647">{</a>
<a name="ln5648">  copy_winopt(&amp;wp_from-&gt;w_onebuf_opt, &amp;wp_to-&gt;w_onebuf_opt);</a>
<a name="ln5649">  copy_winopt(&amp;wp_from-&gt;w_allbuf_opt, &amp;wp_to-&gt;w_allbuf_opt);</a>
<a name="ln5650">}</a>
<a name="ln5651"> </a>
<a name="ln5652">/// Copy the options from one winopt_T to another.</a>
<a name="ln5653">/// Doesn't free the old option values in &quot;to&quot;, use clear_winopt() for that.</a>
<a name="ln5654">/// The 'scroll' option is not copied, because it depends on the window height.</a>
<a name="ln5655">/// The 'previewwindow' option is reset, there can be only one preview window.</a>
<a name="ln5656">void copy_winopt(winopt_T *from, winopt_T *to)</a>
<a name="ln5657">{</a>
<a name="ln5658">  to-&gt;wo_arab = from-&gt;wo_arab;</a>
<a name="ln5659">  to-&gt;wo_list = from-&gt;wo_list;</a>
<a name="ln5660">  to-&gt;wo_nu = from-&gt;wo_nu;</a>
<a name="ln5661">  to-&gt;wo_rnu = from-&gt;wo_rnu;</a>
<a name="ln5662">  to-&gt;wo_nuw = from-&gt;wo_nuw;</a>
<a name="ln5663">  to-&gt;wo_rl  = from-&gt;wo_rl;</a>
<a name="ln5664">  to-&gt;wo_rlc = vim_strsave(from-&gt;wo_rlc);</a>
<a name="ln5665">  to-&gt;wo_stl = vim_strsave(from-&gt;wo_stl);</a>
<a name="ln5666">  to-&gt;wo_wrap = from-&gt;wo_wrap;</a>
<a name="ln5667">  to-&gt;wo_wrap_save = from-&gt;wo_wrap_save;</a>
<a name="ln5668">  to-&gt;wo_lbr = from-&gt;wo_lbr;</a>
<a name="ln5669">  to-&gt;wo_bri = from-&gt;wo_bri;</a>
<a name="ln5670">  to-&gt;wo_briopt = vim_strsave(from-&gt;wo_briopt);</a>
<a name="ln5671">  to-&gt;wo_scb = from-&gt;wo_scb;</a>
<a name="ln5672">  to-&gt;wo_scb_save = from-&gt;wo_scb_save;</a>
<a name="ln5673">  to-&gt;wo_crb = from-&gt;wo_crb;</a>
<a name="ln5674">  to-&gt;wo_crb_save = from-&gt;wo_crb_save;</a>
<a name="ln5675">  to-&gt;wo_spell = from-&gt;wo_spell;</a>
<a name="ln5676">  to-&gt;wo_cuc = from-&gt;wo_cuc;</a>
<a name="ln5677">  to-&gt;wo_cul = from-&gt;wo_cul;</a>
<a name="ln5678">  to-&gt;wo_cc = vim_strsave(from-&gt;wo_cc);</a>
<a name="ln5679">  to-&gt;wo_diff = from-&gt;wo_diff;</a>
<a name="ln5680">  to-&gt;wo_diff_saved = from-&gt;wo_diff_saved;</a>
<a name="ln5681">  to-&gt;wo_cocu = vim_strsave(from-&gt;wo_cocu);</a>
<a name="ln5682">  to-&gt;wo_cole = from-&gt;wo_cole;</a>
<a name="ln5683">  to-&gt;wo_fdc = vim_strsave(from-&gt;wo_fdc);</a>
<a name="ln5684">  to-&gt;wo_fdc_save = from-&gt;wo_diff_saved</a>
<a name="ln5685">                    ? vim_strsave(from-&gt;wo_fdc_save) : empty_option;</a>
<a name="ln5686">  to-&gt;wo_fen = from-&gt;wo_fen;</a>
<a name="ln5687">  to-&gt;wo_fen_save = from-&gt;wo_fen_save;</a>
<a name="ln5688">  to-&gt;wo_fdi = vim_strsave(from-&gt;wo_fdi);</a>
<a name="ln5689">  to-&gt;wo_fml = from-&gt;wo_fml;</a>
<a name="ln5690">  to-&gt;wo_fdl = from-&gt;wo_fdl;</a>
<a name="ln5691">  to-&gt;wo_fdl_save = from-&gt;wo_fdl_save;</a>
<a name="ln5692">  to-&gt;wo_fdm = vim_strsave(from-&gt;wo_fdm);</a>
<a name="ln5693">  to-&gt;wo_fdm_save = from-&gt;wo_diff_saved</a>
<a name="ln5694">                    ? vim_strsave(from-&gt;wo_fdm_save) : empty_option;</a>
<a name="ln5695">  to-&gt;wo_fdn = from-&gt;wo_fdn;</a>
<a name="ln5696">  to-&gt;wo_fde = vim_strsave(from-&gt;wo_fde);</a>
<a name="ln5697">  to-&gt;wo_fdt = vim_strsave(from-&gt;wo_fdt);</a>
<a name="ln5698">  to-&gt;wo_fmr = vim_strsave(from-&gt;wo_fmr);</a>
<a name="ln5699">  to-&gt;wo_scl = vim_strsave(from-&gt;wo_scl);</a>
<a name="ln5700">  to-&gt;wo_winhl = vim_strsave(from-&gt;wo_winhl);</a>
<a name="ln5701">  to-&gt;wo_fcs = vim_strsave(from-&gt;wo_fcs);</a>
<a name="ln5702">  to-&gt;wo_lcs = vim_strsave(from-&gt;wo_lcs);</a>
<a name="ln5703">  to-&gt;wo_winbl = from-&gt;wo_winbl;</a>
<a name="ln5704">  check_winopt(to);             // don't want NULL pointers</a>
<a name="ln5705">}</a>
<a name="ln5706"> </a>
<a name="ln5707">/// Check string options in a window for a NULL value.</a>
<a name="ln5708">void check_win_options(win_T *win)</a>
<a name="ln5709">{</a>
<a name="ln5710">  check_winopt(&amp;win-&gt;w_onebuf_opt);</a>
<a name="ln5711">  check_winopt(&amp;win-&gt;w_allbuf_opt);</a>
<a name="ln5712">}</a>
<a name="ln5713"> </a>
<a name="ln5714">/// Check for NULL pointers in a winopt_T and replace them with empty_option.</a>
<a name="ln5715">static void check_winopt(winopt_T *wop)</a>
<a name="ln5716">{</a>
<a name="ln5717">  check_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5718">  check_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5719">  check_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5720">  check_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5721">  check_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5722">  check_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5723">  check_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5724">  check_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5725">  check_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5726">  check_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5727">  check_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5728">  check_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5729">  check_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5730">  check_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5731">  check_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5732">  check_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5733">  check_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5734">}</a>
<a name="ln5735"> </a>
<a name="ln5736">/// Free the allocated memory inside a winopt_T.</a>
<a name="ln5737">void clear_winopt(winopt_T *wop)</a>
<a name="ln5738">{</a>
<a name="ln5739">  clear_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5740">  clear_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5741">  clear_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5742">  clear_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5743">  clear_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5744">  clear_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5745">  clear_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5746">  clear_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5747">  clear_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5748">  clear_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5749">  clear_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5750">  clear_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5751">  clear_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5752">  clear_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5753">  clear_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5754">  clear_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5755">  clear_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5756">}</a>
<a name="ln5757"> </a>
<a name="ln5758">void didset_window_options(win_T *wp)</a>
<a name="ln5759">{</a>
<a name="ln5760">  check_colorcolumn(wp);</a>
<a name="ln5761">  briopt_check(wp);</a>
<a name="ln5762">  set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln5763">  set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln5764">  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl</a>
<a name="ln5765">  wp-&gt;w_grid.blending = wp-&gt;w_p_winbl &gt; 0;</a>
<a name="ln5766">}</a>
<a name="ln5767"> </a>
<a name="ln5768"> </a>
<a name="ln5769">/// Copy global option values to local options for one buffer.</a>
<a name="ln5770">/// Used when creating a new buffer and sometimes when entering a buffer.</a>
<a name="ln5771">/// flags:</a>
<a name="ln5772">/// BCO_ENTER    We will enter the buf buffer.</a>
<a name="ln5773">/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when</a>
<a name="ln5774">///      appropriate.</a>
<a name="ln5775">/// BCO_NOHELP   Don't copy the values to a help buffer.</a>
<a name="ln5776">void buf_copy_options(buf_T *buf, int flags)</a>
<a name="ln5777">{</a>
<a name="ln5778">  int should_copy = true;</a>
<a name="ln5779">  char_u      *save_p_isk = NULL;           // init for GCC</a>
<a name="ln5780">  int dont_do_help;</a>
<a name="ln5781">  int did_isk = false;</a>
<a name="ln5782"> </a>
<a name="ln5783">  /*</a>
<a name="ln5784">   * Skip this when the option defaults have not been set yet.  Happens when</a>
<a name="ln5785">   * main() allocates the first buffer.</a>
<a name="ln5786">   */</a>
<a name="ln5787">  if (p_cpo != NULL) {</a>
<a name="ln5788">    //</a>
<a name="ln5789">    // Always copy when entering and 'cpo' contains 'S'.</a>
<a name="ln5790">    // Don't copy when already initialized.</a>
<a name="ln5791">    // Don't copy when 'cpo' contains 's' and not entering.</a>
<a name="ln5792">    //    'S'      BCO_ENTER  initialized  's'  should_copy</a>
<a name="ln5793">    //    yes        yes          X         X      true</a>
<a name="ln5794">    //    yes        no          yes        X      false</a>
<a name="ln5795">    //    no          X          yes        X      false</a>
<a name="ln5796">    //     X         no          no        yes     false</a>
<a name="ln5797">    //     X         no          no        no      true</a>
<a name="ln5798">    //    no         yes         no         X      true</a>
<a name="ln5799">    ///</a>
<a name="ln5800">    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))</a>
<a name="ln5801">        &amp;&amp; (buf-&gt;b_p_initialized</a>
<a name="ln5802">            || (!(flags &amp; BCO_ENTER)</a>
<a name="ln5803">                &amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {</a>
<a name="ln5804">      should_copy = false;</a>
<a name="ln5805">    }</a>
<a name="ln5806"> </a>
<a name="ln5807">    if (should_copy || (flags &amp; BCO_ALWAYS)) {</a>
<a name="ln5808">      /* Don't copy the options specific to a help buffer when</a>
<a name="ln5809">      * BCO_NOHELP is given or the options were initialized already</a>
<a name="ln5810">      * (jumping back to a help file with CTRL-T or CTRL-O) */</a>
<a name="ln5811">      dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help)</a>
<a name="ln5812">                     || buf-&gt;b_p_initialized;</a>
<a name="ln5813">      if (dont_do_help) {               // don't free b_p_isk</a>
<a name="ln5814">        save_p_isk = buf-&gt;b_p_isk;</a>
<a name="ln5815">        buf-&gt;b_p_isk = NULL;</a>
<a name="ln5816">      }</a>
<a name="ln5817">      // Always free the allocated strings.  If not already initialized,</a>
<a name="ln5818">      // reset 'readonly' and copy 'fileformat'.</a>
<a name="ln5819">      if (!buf-&gt;b_p_initialized) {</a>
<a name="ln5820">        free_buf_options(buf, true);</a>
<a name="ln5821">        buf-&gt;b_p_ro = false;                    // don't copy readonly</a>
<a name="ln5822">        buf-&gt;b_p_fenc = vim_strsave(p_fenc);</a>
<a name="ln5823">        switch (*p_ffs) {</a>
<a name="ln5824">          case 'm': {</a>
<a name="ln5825">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_MAC);</a>
<a name="ln5826">            break;</a>
<a name="ln5827">          }</a>
<a name="ln5828">          case 'd': {</a>
<a name="ln5829">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_DOS);</a>
<a name="ln5830">            break;</a>
<a name="ln5831">          }</a>
<a name="ln5832">          case 'u': {</a>
<a name="ln5833">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_UNIX);</a>
<a name="ln5834">            break;</a>
<a name="ln5835">          }</a>
<a name="ln5836">          default: {</a>
<a name="ln5837">            buf-&gt;b_p_ff = vim_strsave(p_ff);</a>
<a name="ln5838">            break;</a>
<a name="ln5839">          }</a>
<a name="ln5840">        }</a>
<a name="ln5841">        buf-&gt;b_p_bh = empty_option;</a>
<a name="ln5842">        buf-&gt;b_p_bt = empty_option;</a>
<a name="ln5843">      } else {</a>
<a name="ln5844">        free_buf_options(buf, false);</a>
<a name="ln5845">      }</a>
<a name="ln5846"> </a>
<a name="ln5847">      buf-&gt;b_p_ai = p_ai;</a>
<a name="ln5848">      buf-&gt;b_p_ai_nopaste = p_ai_nopaste;</a>
<a name="ln5849">      buf-&gt;b_p_sw = p_sw;</a>
<a name="ln5850">      buf-&gt;b_p_scbk = p_scbk;</a>
<a name="ln5851">      buf-&gt;b_p_tw = p_tw;</a>
<a name="ln5852">      buf-&gt;b_p_tw_nopaste = p_tw_nopaste;</a>
<a name="ln5853">      buf-&gt;b_p_tw_nobin = p_tw_nobin;</a>
<a name="ln5854">      buf-&gt;b_p_wm = p_wm;</a>
<a name="ln5855">      buf-&gt;b_p_wm_nopaste = p_wm_nopaste;</a>
<a name="ln5856">      buf-&gt;b_p_wm_nobin = p_wm_nobin;</a>
<a name="ln5857">      buf-&gt;b_p_bin = p_bin;</a>
<a name="ln5858">      buf-&gt;b_p_bomb = p_bomb;</a>
<a name="ln5859">      buf-&gt;b_p_et = p_et;</a>
<a name="ln5860">      buf-&gt;b_p_fixeol = p_fixeol;</a>
<a name="ln5861">      buf-&gt;b_p_et_nobin = p_et_nobin;</a>
<a name="ln5862">      buf-&gt;b_p_et_nopaste = p_et_nopaste;</a>
<a name="ln5863">      buf-&gt;b_p_ml = p_ml;</a>
<a name="ln5864">      buf-&gt;b_p_ml_nobin = p_ml_nobin;</a>
<a name="ln5865">      buf-&gt;b_p_inf = p_inf;</a>
<a name="ln5866">      buf-&gt;b_p_swf = cmdmod.noswapfile ? false : p_swf;</a>
<a name="ln5867">      buf-&gt;b_p_cpt = vim_strsave(p_cpt);</a>
<a name="ln5868"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5869">      buf-&gt;b_p_csl = vim_strsave(p_csl);</a>
<a name="ln5870"># endif</a>
<a name="ln5871">      buf-&gt;b_p_cfu = vim_strsave(p_cfu);</a>
<a name="ln5872">      buf-&gt;b_p_ofu = vim_strsave(p_ofu);</a>
<a name="ln5873">      buf-&gt;b_p_tfu = vim_strsave(p_tfu);</a>
<a name="ln5874">      buf-&gt;b_p_sts = p_sts;</a>
<a name="ln5875">      buf-&gt;b_p_sts_nopaste = p_sts_nopaste;</a>
<a name="ln5876">      buf-&gt;b_p_com = vim_strsave(p_com);</a>
<a name="ln5877">      buf-&gt;b_p_cms = vim_strsave(p_cms);</a>
<a name="ln5878">      buf-&gt;b_p_fo = vim_strsave(p_fo);</a>
<a name="ln5879">      buf-&gt;b_p_flp = vim_strsave(p_flp);</a>
<a name="ln5880">      buf-&gt;b_p_nf = vim_strsave(p_nf);</a>
<a name="ln5881">      buf-&gt;b_p_mps = vim_strsave(p_mps);</a>
<a name="ln5882">      buf-&gt;b_p_si = p_si;</a>
<a name="ln5883">      buf-&gt;b_p_channel = 0;</a>
<a name="ln5884">      buf-&gt;b_p_ci = p_ci;</a>
<a name="ln5885">      buf-&gt;b_p_cin = p_cin;</a>
<a name="ln5886">      buf-&gt;b_p_cink = vim_strsave(p_cink);</a>
<a name="ln5887">      buf-&gt;b_p_cino = vim_strsave(p_cino);</a>
<a name="ln5888">      // Don't copy 'filetype', it must be detected</a>
<a name="ln5889">      buf-&gt;b_p_ft = empty_option;</a>
<a name="ln5890">      buf-&gt;b_p_pi = p_pi;</a>
<a name="ln5891">      buf-&gt;b_p_cinw = vim_strsave(p_cinw);</a>
<a name="ln5892">      buf-&gt;b_p_lisp = p_lisp;</a>
<a name="ln5893">      // Don't copy 'syntax', it must be set</a>
<a name="ln5894">      buf-&gt;b_p_syn = empty_option;</a>
<a name="ln5895">      buf-&gt;b_p_smc = p_smc;</a>
<a name="ln5896">      buf-&gt;b_s.b_syn_isk = empty_option;</a>
<a name="ln5897">      buf-&gt;b_s.b_p_spc = vim_strsave(p_spc);</a>
<a name="ln5898">      (void)compile_cap_prog(&amp;buf-&gt;b_s);</a>
<a name="ln5899">      buf-&gt;b_s.b_p_spf = vim_strsave(p_spf);</a>
<a name="ln5900">      buf-&gt;b_s.b_p_spl = vim_strsave(p_spl);</a>
<a name="ln5901">      buf-&gt;b_s.b_p_spo = vim_strsave(p_spo);</a>
<a name="ln5902">      buf-&gt;b_p_inde = vim_strsave(p_inde);</a>
<a name="ln5903">      buf-&gt;b_p_indk = vim_strsave(p_indk);</a>
<a name="ln5904">      buf-&gt;b_p_fp = empty_option;</a>
<a name="ln5905">      buf-&gt;b_p_fex = vim_strsave(p_fex);</a>
<a name="ln5906">      buf-&gt;b_p_sua = vim_strsave(p_sua);</a>
<a name="ln5907">      buf-&gt;b_p_keymap = vim_strsave(p_keymap);</a>
<a name="ln5908">      buf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln5909">      /* This isn't really an option, but copying the langmap and IME</a>
<a name="ln5910">      * state from the current buffer is better than resetting it. */</a>
<a name="ln5911">      buf-&gt;b_p_iminsert = p_iminsert;</a>
<a name="ln5912">      buf-&gt;b_p_imsearch = p_imsearch;</a>
<a name="ln5913"> </a>
<a name="ln5914">      /* options that are normally global but also have a local value</a>
<a name="ln5915">       * are not copied, start using the global value */</a>
<a name="ln5916">      buf-&gt;b_p_ar = -1;</a>
<a name="ln5917">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln5918">      buf-&gt;b_p_bkc = empty_option;</a>
<a name="ln5919">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln5920">      buf-&gt;b_p_gp = empty_option;</a>
<a name="ln5921">      buf-&gt;b_p_mp = empty_option;</a>
<a name="ln5922">      buf-&gt;b_p_efm = empty_option;</a>
<a name="ln5923">      buf-&gt;b_p_ep = empty_option;</a>
<a name="ln5924">      buf-&gt;b_p_kp = empty_option;</a>
<a name="ln5925">      buf-&gt;b_p_path = empty_option;</a>
<a name="ln5926">      buf-&gt;b_p_tags = empty_option;</a>
<a name="ln5927">      buf-&gt;b_p_tc = empty_option;</a>
<a name="ln5928">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln5929">      buf-&gt;b_p_def = empty_option;</a>
<a name="ln5930">      buf-&gt;b_p_inc = empty_option;</a>
<a name="ln5931">      buf-&gt;b_p_inex = vim_strsave(p_inex);</a>
<a name="ln5932">      buf-&gt;b_p_dict = empty_option;</a>
<a name="ln5933">      buf-&gt;b_p_tsr = empty_option;</a>
<a name="ln5934">      buf-&gt;b_p_qe = vim_strsave(p_qe);</a>
<a name="ln5935">      buf-&gt;b_p_udf = p_udf;</a>
<a name="ln5936">      buf-&gt;b_p_lw = empty_option;</a>
<a name="ln5937">      buf-&gt;b_p_menc = empty_option;</a>
<a name="ln5938"> </a>
<a name="ln5939">      /*</a>
<a name="ln5940">       * Don't copy the options set by ex_help(), use the saved values,</a>
<a name="ln5941">       * when going from a help buffer to a non-help buffer.</a>
<a name="ln5942">       * Don't touch these at all when BCO_NOHELP is used and going from</a>
<a name="ln5943">       * or to a help buffer.</a>
<a name="ln5944">       */</a>
<a name="ln5945">      if (dont_do_help) {</a>
<a name="ln5946">        buf-&gt;b_p_isk = save_p_isk;</a>
<a name="ln5947">      } else {</a>
<a name="ln5948">        buf-&gt;b_p_isk = vim_strsave(p_isk);</a>
<a name="ln5949">        did_isk = true;</a>
<a name="ln5950">        buf-&gt;b_p_ts = p_ts;</a>
<a name="ln5951">        buf-&gt;b_help = false;</a>
<a name="ln5952">        if (buf-&gt;b_p_bt[0] == 'h') {</a>
<a name="ln5953">          clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln5954">        }</a>
<a name="ln5955">        buf-&gt;b_p_ma = p_ma;</a>
<a name="ln5956">      }</a>
<a name="ln5957">    }</a>
<a name="ln5958"> </a>
<a name="ln5959">    /*</a>
<a name="ln5960">     * When the options should be copied (ignoring BCO_ALWAYS), set the</a>
<a name="ln5961">     * flag that indicates that the options have been initialized.</a>
<a name="ln5962">     */</a>
<a name="ln5963">    if (should_copy) {</a>
<a name="ln5964">      buf-&gt;b_p_initialized = true;</a>
<a name="ln5965">    }</a>
<a name="ln5966">  }</a>
<a name="ln5967"> </a>
<a name="ln5968">  check_buf_options(buf);           // make sure we don't have NULLs</a>
<a name="ln5969">  if (did_isk) {</a>
<a name="ln5970">    (void)buf_init_chartab(buf, false);</a>
<a name="ln5971">  }</a>
<a name="ln5972">}</a>
<a name="ln5973"> </a>
<a name="ln5974">/// Reset the 'modifiable' option and its default value.</a>
<a name="ln5975">void reset_modifiable(void)</a>
<a name="ln5976">{</a>
<a name="ln5977">  int opt_idx;</a>
<a name="ln5978"> </a>
<a name="ln5979">  curbuf-&gt;b_p_ma = false;</a>
<a name="ln5980">  p_ma = false;</a>
<a name="ln5981">  opt_idx = findoption(&quot;ma&quot;);</a>
<a name="ln5982">  if (opt_idx &gt;= 0) {</a>
<a name="ln5983">    options[opt_idx].def_val[VI_DEFAULT] = false;</a>
<a name="ln5984">  }</a>
<a name="ln5985">}</a>
<a name="ln5986"> </a>
<a name="ln5987">/// Set the global value for 'iminsert' to the local value.</a>
<a name="ln5988">void set_iminsert_global(void)</a>
<a name="ln5989">{</a>
<a name="ln5990">  p_iminsert = curbuf-&gt;b_p_iminsert;</a>
<a name="ln5991">}</a>
<a name="ln5992"> </a>
<a name="ln5993">/// Set the global value for 'imsearch' to the local value.</a>
<a name="ln5994">void set_imsearch_global(void)</a>
<a name="ln5995">{</a>
<a name="ln5996">  p_imsearch = curbuf-&gt;b_p_imsearch;</a>
<a name="ln5997">}</a>
<a name="ln5998"> </a>
<a name="ln5999">static int expand_option_idx = -1;</a>
<a name="ln6000">static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};</a>
<a name="ln6001">static int expand_option_flags = 0;</a>
<a name="ln6002"> </a>
<a name="ln6003">void</a>
<a name="ln6004">set_context_in_set_cmd(</a>
<a name="ln6005">    expand_T *xp,</a>
<a name="ln6006">    char_u *arg,</a>
<a name="ln6007">    int opt_flags                  // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6008">)</a>
<a name="ln6009">{</a>
<a name="ln6010">  char_u nextchar;</a>
<a name="ln6011">  uint32_t flags = 0;           // init for GCC</a>
<a name="ln6012">  int opt_idx = 0;              // init for GCC</a>
<a name="ln6013">  char_u      *p;</a>
<a name="ln6014">  char_u      *s;</a>
<a name="ln6015">  int is_term_option = false;</a>
<a name="ln6016">  int key;</a>
<a name="ln6017"> </a>
<a name="ln6018">  expand_option_flags = opt_flags;</a>
<a name="ln6019"> </a>
<a name="ln6020">  xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln6021">  if (*arg == NUL) {</a>
<a name="ln6022">    xp-&gt;xp_pattern = arg;</a>
<a name="ln6023">    return;</a>
<a name="ln6024">  }</a>
<a name="ln6025">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln6026">  if (*p == ' ' &amp;&amp; *(p - 1) != '\\') {</a>
<a name="ln6027">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6028">    return;</a>
<a name="ln6029">  }</a>
<a name="ln6030">  while (p &gt; arg) {</a>
<a name="ln6031">    s = p;</a>
<a name="ln6032">    // count number of backslashes before ' ' or ','</a>
<a name="ln6033">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6034">      while (s &gt; arg &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6035">        s--;</a>
<a name="ln6036">      }</a>
<a name="ln6037">    }</a>
<a name="ln6038">    // break at a space with an even number of backslashes</a>
<a name="ln6039">    if (*p == ' ' &amp;&amp; ((p - s) &amp; 1) == 0) {</a>
<a name="ln6040">      p++;</a>
<a name="ln6041">      break;</a>
<a name="ln6042">    }</a>
<a name="ln6043">    p--;</a>
<a name="ln6044">  }</a>
<a name="ln6045">  if (STRNCMP(p, &quot;no&quot;, 2) == 0) {</a>
<a name="ln6046">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6047">    p += 2;</a>
<a name="ln6048">  }</a>
<a name="ln6049">  if (STRNCMP(p, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln6050">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6051">    p += 3;</a>
<a name="ln6052">  }</a>
<a name="ln6053">  xp-&gt;xp_pattern = arg = p;</a>
<a name="ln6054">  if (*arg == '&lt;') {</a>
<a name="ln6055">    while (*p != '&gt;') {</a>
<a name="ln6056">      if (*p++ == NUL) {            // expand terminal option name</a>
<a name="ln6057">        return;</a>
<a name="ln6058">      }</a>
<a name="ln6059">    }</a>
<a name="ln6060">    key = get_special_key_code(arg + 1);</a>
<a name="ln6061">    if (key == 0) {                 // unknown name</a>
<a name="ln6062">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6063">      return;</a>
<a name="ln6064">    }</a>
<a name="ln6065">    nextchar = *++p;</a>
<a name="ln6066">    is_term_option = true;</a>
<a name="ln6067">    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);</a>
<a name="ln6068">    expand_option_name[3] = KEY2TERMCAP1(key);</a>
<a name="ln6069">  } else {</a>
<a name="ln6070">    if (p[0] == 't' &amp;&amp; p[1] == '_') {</a>
<a name="ln6071">      p += 2;</a>
<a name="ln6072">      if (*p != NUL) {</a>
<a name="ln6073">        p++;</a>
<a name="ln6074">      }</a>
<a name="ln6075">      if (*p == NUL) {</a>
<a name="ln6076">        return;                 // expand option name</a>
<a name="ln6077">      }</a>
<a name="ln6078">      nextchar = *++p;</a>
<a name="ln6079">      is_term_option = true;</a>
<a name="ln6080">      expand_option_name[2] = p[-2];</a>
<a name="ln6081">      expand_option_name[3] = p[-1];</a>
<a name="ln6082">    } else {</a>
<a name="ln6083">      // Allow * wildcard.</a>
<a name="ln6084">      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {</a>
<a name="ln6085">        p++;</a>
<a name="ln6086">      }</a>
<a name="ln6087">      if (*p == NUL) {</a>
<a name="ln6088">        return;</a>
<a name="ln6089">      }</a>
<a name="ln6090">      nextchar = *p;</a>
<a name="ln6091">      opt_idx = findoption_len((const char *)arg, (size_t)(p - arg));</a>
<a name="ln6092">      if (opt_idx == -1 || options[opt_idx].var == NULL) {</a>
<a name="ln6093">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6094">        return;</a>
<a name="ln6095">      }</a>
<a name="ln6096">      flags = options[opt_idx].flags;</a>
<a name="ln6097">      if (flags &amp; P_BOOL) {</a>
<a name="ln6098">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6099">        return;</a>
<a name="ln6100">      }</a>
<a name="ln6101">    }</a>
<a name="ln6102">  }</a>
<a name="ln6103">  // handle &quot;-=&quot; and &quot;+=&quot;</a>
<a name="ln6104">  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') &amp;&amp; p[1] == '=') {</a>
<a name="ln6105">    p++;</a>
<a name="ln6106">    nextchar = '=';</a>
<a name="ln6107">  }</a>
<a name="ln6108">  if ((nextchar != '=' &amp;&amp; nextchar != ':')</a>
<a name="ln6109">      || xp-&gt;xp_context == EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6110">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln6111">    return;</a>
<a name="ln6112">  }</a>
<a name="ln6113">  if (p[1] == NUL) {</a>
<a name="ln6114">    xp-&gt;xp_context = EXPAND_OLD_SETTING;</a>
<a name="ln6115">    if (is_term_option) {</a>
<a name="ln6116">      expand_option_idx = -1;</a>
<a name="ln6117">    } else {</a>
<a name="ln6118">      expand_option_idx = opt_idx;</a>
<a name="ln6119">    }</a>
<a name="ln6120">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6121">    return;</a>
<a name="ln6122">  }</a>
<a name="ln6123">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6124">  if (is_term_option || (flags &amp; P_NUM)) {</a>
<a name="ln6125">    return;</a>
<a name="ln6126">  }</a>
<a name="ln6127"> </a>
<a name="ln6128">  xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6129"> </a>
<a name="ln6130">  if (flags &amp; P_EXPAND) {</a>
<a name="ln6131">    p = options[opt_idx].var;</a>
<a name="ln6132">    if (p == (char_u *)&amp;p_bdir</a>
<a name="ln6133">        || p == (char_u *)&amp;p_dir</a>
<a name="ln6134">        || p == (char_u *)&amp;p_path</a>
<a name="ln6135">        || p == (char_u *)&amp;p_pp</a>
<a name="ln6136">        || p == (char_u *)&amp;p_rtp</a>
<a name="ln6137">        || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6138">        || p == (char_u *)&amp;p_vdir</a>
<a name="ln6139">        ) {</a>
<a name="ln6140">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln6141">      if (p == (char_u *)&amp;p_path</a>
<a name="ln6142">          || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6143">          )</a>
<a name="ln6144">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6145">      else</a>
<a name="ln6146">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6147">    } else {</a>
<a name="ln6148">      xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln6149">      // for 'tags' need three backslashes for a space</a>
<a name="ln6150">      if (p == (char_u *)&amp;p_tags) {</a>
<a name="ln6151">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6152">      } else {</a>
<a name="ln6153">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6154">      }</a>
<a name="ln6155">    }</a>
<a name="ln6156">  }</a>
<a name="ln6157"> </a>
<a name="ln6158">  /* For an option that is a list of file names, find the start of the</a>
<a name="ln6159">   * last file name. */</a>
<a name="ln6160">  for (p = arg + STRLEN(arg) - 1; p &gt; xp-&gt;xp_pattern; p--) {</a>
<a name="ln6161">    // count number of backslashes before ' ' or ','</a>
<a name="ln6162">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6163">      s = p;</a>
<a name="ln6164">      while (s &gt; xp-&gt;xp_pattern &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6165">        s--;</a>
<a name="ln6166">      }</a>
<a name="ln6167">      if ((*p == ' ' &amp;&amp; (xp-&gt;xp_backslash == XP_BS_THREE &amp;&amp; (p - s) &lt; 3))</a>
<a name="ln6168">          || (*p == ',' &amp;&amp; (flags &amp; P_COMMA) &amp;&amp; ((p - s) &amp; 1) == 0)) {</a>
<a name="ln6169">        xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6170">        break;</a>
<a name="ln6171">      }</a>
<a name="ln6172">    }</a>
<a name="ln6173"> </a>
<a name="ln6174">    // for 'spellsuggest' start at &quot;file:&quot;</a>
<a name="ln6175">    if (options[opt_idx].var == (char_u *)&amp;p_sps</a>
<a name="ln6176">        &amp;&amp; STRNCMP(p, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln6177">      xp-&gt;xp_pattern = p + 5;</a>
<a name="ln6178">      break;</a>
<a name="ln6179">    }</a>
<a name="ln6180">  }</a>
<a name="ln6181"> </a>
<a name="ln6182">  return;</a>
<a name="ln6183">}</a>
<a name="ln6184"> </a>
<a name="ln6185">int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)</a>
<a name="ln6186">{</a>
<a name="ln6187">  int num_normal = 0;  // Nr of matching non-term-code settings</a>
<a name="ln6188">  int match;</a>
<a name="ln6189">  int count = 0;</a>
<a name="ln6190">  char_u      *str;</a>
<a name="ln6191">  int loop;</a>
<a name="ln6192">  static char *(names[]) = { &quot;all&quot; };</a>
<a name="ln6193">  int ic = regmatch-&gt;rm_ic;  // remember the ignore-case flag</a>
<a name="ln6194"> </a>
<a name="ln6195">  /* do this loop twice:</a>
<a name="ln6196">   * loop == 0: count the number of matching options</a>
<a name="ln6197">   * loop == 1: copy the matching options into allocated memory</a>
<a name="ln6198">   */</a>
<a name="ln6199">  for (loop = 0; loop &lt;= 1; loop++) {</a>
<a name="ln6200">    regmatch-&gt;rm_ic = ic;</a>
<a name="ln6201">    if (xp-&gt;xp_context != EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6202">      for (match = 0; match &lt; (int)ARRAY_SIZE(names);</a>
<a name="ln6203">           match++) {</a>
<a name="ln6204">        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {</a>
<a name="ln6205">          if (loop == 0) {</a>
<a name="ln6206">            num_normal++;</a>
<a name="ln6207">          } else {</a>
<a name="ln6208">            (*file)[count++] = vim_strsave((char_u *)names[match]);</a>
<a name="ln6209">          }</a>
<a name="ln6210">        }</a>
<a name="ln6211">      }</a>
<a name="ln6212">    }</a>
<a name="ln6213">    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;</a>
<a name="ln6214">         opt_idx++) {</a>
<a name="ln6215">      if (options[opt_idx].var == NULL) {</a>
<a name="ln6216">        continue;</a>
<a name="ln6217">      }</a>
<a name="ln6218">      if (xp-&gt;xp_context == EXPAND_BOOL_SETTINGS</a>
<a name="ln6219">          &amp;&amp; !(options[opt_idx].flags &amp; P_BOOL)) {</a>
<a name="ln6220">        continue;</a>
<a name="ln6221">      }</a>
<a name="ln6222">      match = false;</a>
<a name="ln6223">      if (vim_regexec(regmatch, str, (colnr_T)0)</a>
<a name="ln6224">          || (options[opt_idx].shortname != NULL</a>
<a name="ln6225">              &amp;&amp; vim_regexec(regmatch,</a>
<a name="ln6226">                             (char_u *)options[opt_idx].shortname,</a>
<a name="ln6227">                             (colnr_T)0))) {</a>
<a name="ln6228">        match = true;</a>
<a name="ln6229">      }</a>
<a name="ln6230"> </a>
<a name="ln6231">      if (match) {</a>
<a name="ln6232">        if (loop == 0) {</a>
<a name="ln6233">          num_normal++;</a>
<a name="ln6234">        } else</a>
<a name="ln6235">          (*file)[count++] = vim_strsave(str);</a>
<a name="ln6236">      }</a>
<a name="ln6237">    }</a>
<a name="ln6238"> </a>
<a name="ln6239">    if (loop == 0) {</a>
<a name="ln6240">      if (num_normal &gt; 0) {</a>
<a name="ln6241">        *num_file = num_normal;</a>
<a name="ln6242">      } else {</a>
<a name="ln6243">        return OK;</a>
<a name="ln6244">      }</a>
<a name="ln6245">      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));</a>
<a name="ln6246">    }</a>
<a name="ln6247">  }</a>
<a name="ln6248">  return OK;</a>
<a name="ln6249">}</a>
<a name="ln6250"> </a>
<a name="ln6251">void ExpandOldSetting(int *num_file, char_u ***file)</a>
<a name="ln6252">{</a>
<a name="ln6253">  char_u *var = NULL;</a>
<a name="ln6254"> </a>
<a name="ln6255">  *num_file = 0;</a>
<a name="ln6256">  *file = (char_u **)xmalloc(sizeof(char_u *));</a>
<a name="ln6257"> </a>
<a name="ln6258">  /*</a>
<a name="ln6259">   * For a terminal key code expand_option_idx is &lt; 0.</a>
<a name="ln6260">   */</a>
<a name="ln6261">  if (expand_option_idx &lt; 0) {</a>
<a name="ln6262">    expand_option_idx = findoption((const char *)expand_option_name);</a>
<a name="ln6263">  }</a>
<a name="ln6264"> </a>
<a name="ln6265">  if (expand_option_idx &gt;= 0) {</a>
<a name="ln6266">    // Put string of option value in NameBuff.</a>
<a name="ln6267">    option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln6268">    var = NameBuff;</a>
<a name="ln6269">  } else {</a>
<a name="ln6270">    var = (char_u *)&quot;&quot;;</a>
<a name="ln6271">  }</a>
<a name="ln6272"> </a>
<a name="ln6273">  // A backslash is required before some characters.  This is the reverse of</a>
<a name="ln6274">  // what happens in do_set().</a>
<a name="ln6275">  char_u *buf = vim_strsave_escaped(var, escape_chars);</a>
<a name="ln6276"> </a>
<a name="ln6277">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6278">  /* For MS-Windows et al. we don't double backslashes at the start and</a>
<a name="ln6279">   * before a file name character. */</a>
<a name="ln6280">  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {</a>
<a name="ln6281">    if (var[0] == '\\' &amp;&amp; var[1] == '\\'</a>
<a name="ln6282">        &amp;&amp; expand_option_idx &gt;= 0</a>
<a name="ln6283">        &amp;&amp; (options[expand_option_idx].flags &amp; P_EXPAND)</a>
<a name="ln6284">        &amp;&amp; vim_isfilec(var[2])</a>
<a name="ln6285">        &amp;&amp; (var[2] != '\\' || (var == buf &amp;&amp; var[4] != '\\'))) {</a>
<a name="ln6286">      STRMOVE(var, var + 1);</a>
<a name="ln6287">    }</a>
<a name="ln6288">  }</a>
<a name="ln6289">#endif</a>
<a name="ln6290"> </a>
<a name="ln6291">  *file[0] = buf;</a>
<a name="ln6292">  *num_file = 1;</a>
<a name="ln6293">}</a>
<a name="ln6294"> </a>
<a name="ln6295">/// Get the value for the numeric or string option///opp in a nice format into</a>
<a name="ln6296">/// NameBuff[].  Must not be called with a hidden option!</a>
<a name="ln6297">static void</a>
<a name="ln6298">option_value2string(</a>
<a name="ln6299">    vimoption_T *opp,</a>
<a name="ln6300">    int opt_flags                          // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6301">)</a>
<a name="ln6302">{</a>
<a name="ln6303">  char_u      *varp;</a>
<a name="ln6304"> </a>
<a name="ln6305">  varp = get_varp_scope(opp, opt_flags);</a>
<a name="ln6306"> </a>
<a name="ln6307">  if (opp-&gt;flags &amp; P_NUM) {</a>
<a name="ln6308">    long wc = 0;</a>
<a name="ln6309"> </a>
<a name="ln6310">    if (wc_use_keyname(varp, &amp;wc)) {</a>
<a name="ln6311">      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));</a>
<a name="ln6312">    } else if (wc != 0) {</a>
<a name="ln6313">      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));</a>
<a name="ln6314">    } else {</a>
<a name="ln6315">      snprintf((char *)NameBuff,</a>
<a name="ln6316">               sizeof(NameBuff),</a>
<a name="ln6317">               &quot;%&quot; PRId64,</a>
<a name="ln6318">               (int64_t)*(long *)varp);</a>
<a name="ln6319">    }</a>
<a name="ln6320">  } else {  // P_STRING</a>
<a name="ln6321">    varp = *(char_u **)(varp);</a>
<a name="ln6322">    if (varp == NULL) {  // Just in case.</a>
<a name="ln6323">      NameBuff[0] = NUL;</a>
<a name="ln6324">    } else if (opp-&gt;flags &amp; P_EXPAND) {</a>
<a name="ln6325">      home_replace(NULL, varp, NameBuff, MAXPATHL, false);</a>
<a name="ln6326">    // Translate 'pastetoggle' into special key names.</a>
<a name="ln6327">    } else if ((char_u **)opp-&gt;var == &amp;p_pt) {</a>
<a name="ln6328">      str2specialbuf((const char *)p_pt, (char *)NameBuff, MAXPATHL);</a>
<a name="ln6329">    } else {</a>
<a name="ln6330">      STRLCPY(NameBuff, varp, MAXPATHL);</a>
<a name="ln6331">    }</a>
<a name="ln6332">  }</a>
<a name="ln6333">}</a>
<a name="ln6334"> </a>
<a name="ln6335">/// Return true if &quot;varp&quot; points to 'wildchar' or 'wildcharm' and it can be</a>
<a name="ln6336">/// printed as a keyname.</a>
<a name="ln6337">/// &quot;*wcp&quot; is set to the value of the option if it's 'wildchar' or 'wildcharm'.</a>
<a name="ln6338">static int wc_use_keyname(char_u *varp, long *wcp)</a>
<a name="ln6339">{</a>
<a name="ln6340">  if (((long *)varp == &amp;p_wc) || ((long *)varp == &amp;p_wcm)) {</a>
<a name="ln6341">    *wcp = *(long *)varp;</a>
<a name="ln6342">    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) &gt;= 0) {</a>
<a name="ln6343">      return true;</a>
<a name="ln6344">    }</a>
<a name="ln6345">  }</a>
<a name="ln6346">  return false;</a>
<a name="ln6347">}</a>
<a name="ln6348"> </a>
<a name="ln6349">/// Any character has an equivalent 'langmap' character.  This is used for</a>
<a name="ln6350">/// keyboards that have a special language mode that sends characters above</a>
<a name="ln6351">/// 128 (although other characters can be translated too).  The &quot;to&quot; field is a</a>
<a name="ln6352">/// Vim command character.  This avoids having to switch the keyboard back to</a>
<a name="ln6353">/// ASCII mode when leaving Insert mode.</a>
<a name="ln6354">///</a>
<a name="ln6355">/// langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim</a>
<a name="ln6356">/// commands.</a>
<a name="ln6357">/// langmap_mapga.ga_data is a sorted table of langmap_entry_T.</a>
<a name="ln6358">/// This does the same as langmap_mapchar[] for characters &gt;= 256.</a>
<a name="ln6359">///</a>
<a name="ln6360">/// With multi-byte support use growarray for 'langmap' chars &gt;= 256</a>
<a name="ln6361">typedef struct {</a>
<a name="ln6362">  int from;</a>
<a name="ln6363">  int to;</a>
<a name="ln6364">} langmap_entry_T;</a>
<a name="ln6365"> </a>
<a name="ln6366">static garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln6367"> </a>
<a name="ln6368">/// Search for an entry in &quot;langmap_mapga&quot; for &quot;from&quot;.  If found set the &quot;to&quot;</a>
<a name="ln6369">/// field.  If not found insert a new entry at the appropriate location.</a>
<a name="ln6370">static void langmap_set_entry(int from, int to)</a>
<a name="ln6371">{</a>
<a name="ln6372">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6373">  unsigned int a = 0;</a>
<a name="ln6374">  assert(langmap_mapga.ga_len &gt;= 0);</a>
<a name="ln6375">  unsigned int b = (unsigned int)langmap_mapga.ga_len;</a>
<a name="ln6376"> </a>
<a name="ln6377">  // Do a binary search for an existing entry.</a>
<a name="ln6378">  while (a != b) {</a>
<a name="ln6379">    unsigned int i = (a + b) / 2;</a>
<a name="ln6380">    int d = entries[i].from - from;</a>
<a name="ln6381"> </a>
<a name="ln6382">    if (d == 0) {</a>
<a name="ln6383">      entries[i].to = to;</a>
<a name="ln6384">      return;</a>
<a name="ln6385">    }</a>
<a name="ln6386">    if (d &lt; 0) {</a>
<a name="ln6387">      a = i + 1;</a>
<a name="ln6388">    } else {</a>
<a name="ln6389">      b = i;</a>
<a name="ln6390">    }</a>
<a name="ln6391">  }</a>
<a name="ln6392"> </a>
<a name="ln6393">  ga_grow(&amp;langmap_mapga, 1);</a>
<a name="ln6394"> </a>
<a name="ln6395">  // insert new entry at position &quot;a&quot;</a>
<a name="ln6396">  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;</a>
<a name="ln6397">  memmove(entries + 1, entries,</a>
<a name="ln6398">          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));</a>
<a name="ln6399">  langmap_mapga.ga_len++;</a>
<a name="ln6400">  entries[0].from = from;</a>
<a name="ln6401">  entries[0].to = to;</a>
<a name="ln6402">}</a>
<a name="ln6403"> </a>
<a name="ln6404">/// Apply 'langmap' to multi-byte character &quot;c&quot; and return the result.</a>
<a name="ln6405">int langmap_adjust_mb(int c)</a>
<a name="ln6406">{</a>
<a name="ln6407">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6408">  int a = 0;</a>
<a name="ln6409">  int b = langmap_mapga.ga_len;</a>
<a name="ln6410"> </a>
<a name="ln6411">  while (a != b) {</a>
<a name="ln6412">    int i = (a + b) / 2;</a>
<a name="ln6413">    int d = entries[i].from - c;</a>
<a name="ln6414"> </a>
<a name="ln6415">    if (d == 0) {</a>
<a name="ln6416">      return entries[i].to;        // found matching entry</a>
<a name="ln6417">    }</a>
<a name="ln6418">    if (d &lt; 0) {</a>
<a name="ln6419">      a = i + 1;</a>
<a name="ln6420">    } else {</a>
<a name="ln6421">      b = i;</a>
<a name="ln6422">    }</a>
<a name="ln6423">  }</a>
<a name="ln6424">  return c;    // no entry found, return &quot;c&quot; unmodified</a>
<a name="ln6425">}</a>
<a name="ln6426"> </a>
<a name="ln6427">static void langmap_init(void)</a>
<a name="ln6428">{</a>
<a name="ln6429">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln6430">    langmap_mapchar[i] = (char_u)i;      // we init with a one-to-one map</a>
<a name="ln6431">  }</a>
<a name="ln6432">  ga_init(&amp;langmap_mapga, sizeof(langmap_entry_T), 8);</a>
<a name="ln6433">}</a>
<a name="ln6434"> </a>
<a name="ln6435">/// Called when langmap option is set; the language map can be</a>
<a name="ln6436">/// changed at any time!</a>
<a name="ln6437">static void langmap_set(void)</a>
<a name="ln6438">{</a>
<a name="ln6439">  char_u  *p;</a>
<a name="ln6440">  char_u  *p2;</a>
<a name="ln6441">  int from, to;</a>
<a name="ln6442"> </a>
<a name="ln6443">  ga_clear(&amp;langmap_mapga);                 // clear the previous map first</a>
<a name="ln6444">  langmap_init();                           // back to one-to-one map</a>
<a name="ln6445"> </a>
<a name="ln6446">  for (p = p_langmap; p[0] != NUL; ) {</a>
<a name="ln6447">    for (p2 = p; p2[0] != NUL &amp;&amp; p2[0] != ',' &amp;&amp; p2[0] != ';';</a>
<a name="ln6448">         MB_PTR_ADV(p2)) {</a>
<a name="ln6449">      if (p2[0] == '\\' &amp;&amp; p2[1] != NUL) {</a>
<a name="ln6450">        p2++;</a>
<a name="ln6451">      }</a>
<a name="ln6452">    }</a>
<a name="ln6453">    if (p2[0] == ';') {</a>
<a name="ln6454">      p2++;                 // abcd;ABCD form, p2 points to A</a>
<a name="ln6455">    } else {</a>
<a name="ln6456">      p2 = NULL;            // aAbBcCdD form, p2 is NULL</a>
<a name="ln6457">    }</a>
<a name="ln6458">    while (p[0]) {</a>
<a name="ln6459">      if (p[0] == ',') {</a>
<a name="ln6460">        p++;</a>
<a name="ln6461">        break;</a>
<a name="ln6462">      }</a>
<a name="ln6463">      if (p[0] == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln6464">        p++;</a>
<a name="ln6465">      }</a>
<a name="ln6466">      from = utf_ptr2char(p);</a>
<a name="ln6467">      to = NUL;</a>
<a name="ln6468">      if (p2 == NULL) {</a>
<a name="ln6469">        MB_PTR_ADV(p);</a>
<a name="ln6470">        if (p[0] != ',') {</a>
<a name="ln6471">          if (p[0] == '\\') {</a>
<a name="ln6472">            p++;</a>
<a name="ln6473">          }</a>
<a name="ln6474">          to = utf_ptr2char(p);</a>
<a name="ln6475">        }</a>
<a name="ln6476">      } else {</a>
<a name="ln6477">        if (p2[0] != ',') {</a>
<a name="ln6478">          if (p2[0] == '\\') {</a>
<a name="ln6479">            p2++;</a>
<a name="ln6480">          }</a>
<a name="ln6481">          to = utf_ptr2char(p2);</a>
<a name="ln6482">        }</a>
<a name="ln6483">      }</a>
<a name="ln6484">      if (to == NUL) {</a>
<a name="ln6485">        EMSG2(_(&quot;E357: 'langmap': Matching character missing for %s&quot;),</a>
<a name="ln6486">            transchar(from));</a>
<a name="ln6487">        return;</a>
<a name="ln6488">      }</a>
<a name="ln6489"> </a>
<a name="ln6490">      if (from &gt;= 256) {</a>
<a name="ln6491">        langmap_set_entry(from, to);</a>
<a name="ln6492">      } else {</a>
<a name="ln6493">        assert(to &lt;= UCHAR_MAX);</a>
<a name="ln6494">        langmap_mapchar[from &amp; 255] = (char_u)to;</a>
<a name="ln6495">      }</a>
<a name="ln6496"> </a>
<a name="ln6497">      // Advance to next pair</a>
<a name="ln6498">      MB_PTR_ADV(p);</a>
<a name="ln6499">      if (p2 != NULL) {</a>
<a name="ln6500">        MB_PTR_ADV(p2);</a>
<a name="ln6501">        if (*p == ';') {</a>
<a name="ln6502">          p = p2;</a>
<a name="ln6503">          if (p[0] != NUL) {</a>
<a name="ln6504">            if (p[0] != ',') {</a>
<a name="ln6505">              EMSG2(_(</a>
<a name="ln6506">                      &quot;E358: 'langmap': Extra characters after semicolon: %s&quot;),</a>
<a name="ln6507">                  p);</a>
<a name="ln6508">              return;</a>
<a name="ln6509">            }</a>
<a name="ln6510">            p++;</a>
<a name="ln6511">          }</a>
<a name="ln6512">          break;</a>
<a name="ln6513">        }</a>
<a name="ln6514">      }</a>
<a name="ln6515">    }</a>
<a name="ln6516">  }</a>
<a name="ln6517">}</a>
<a name="ln6518"> </a>
<a name="ln6519">/// Return true if format option 'x' is in effect.</a>
<a name="ln6520">/// Take care of no formatting when 'paste' is set.</a>
<a name="ln6521">bool has_format_option(int x)</a>
<a name="ln6522">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6523">{</a>
<a name="ln6524">  if (p_paste) {</a>
<a name="ln6525">    return false;</a>
<a name="ln6526">  }</a>
<a name="ln6527">  return vim_strchr(curbuf-&gt;b_p_fo, x) != NULL;</a>
<a name="ln6528">}</a>
<a name="ln6529"> </a>
<a name="ln6530">/// @returns true if &quot;x&quot; is present in 'shortmess' option, or</a>
<a name="ln6531">/// 'shortmess' contains 'a' and &quot;x&quot; is present in SHM_ALL_ABBREVIATIONS.</a>
<a name="ln6532">bool shortmess(int x)</a>
<a name="ln6533">{</a>
<a name="ln6534">  return (p_shm != NULL</a>
<a name="ln6535">          &amp;&amp; (vim_strchr(p_shm, x) != NULL</a>
<a name="ln6536">              || (vim_strchr(p_shm, 'a') != NULL</a>
<a name="ln6537">                  &amp;&amp; vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));</a>
<a name="ln6538">}</a>
<a name="ln6539"> </a>
<a name="ln6540">/// paste_option_changed() - Called after p_paste was set or reset.</a>
<a name="ln6541">static void paste_option_changed(void)</a>
<a name="ln6542">{</a>
<a name="ln6543">  static int old_p_paste = false;</a>
<a name="ln6544">  static int save_sm = 0;</a>
<a name="ln6545">  static int save_sta = 0;</a>
<a name="ln6546">  static int save_ru = 0;</a>
<a name="ln6547">  static int save_ri = 0;</a>
<a name="ln6548">  static int save_hkmap = 0;</a>
<a name="ln6549"> </a>
<a name="ln6550">  if (p_paste) {</a>
<a name="ln6551">    /*</a>
<a name="ln6552">     * Paste switched from off to on.</a>
<a name="ln6553">     * Save the current values, so they can be restored later.</a>
<a name="ln6554">     */</a>
<a name="ln6555">    if (!old_p_paste) {</a>
<a name="ln6556">      // save options for each buffer</a>
<a name="ln6557">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6558">        buf-&gt;b_p_tw_nopaste = buf-&gt;b_p_tw;</a>
<a name="ln6559">        buf-&gt;b_p_wm_nopaste = buf-&gt;b_p_wm;</a>
<a name="ln6560">        buf-&gt;b_p_sts_nopaste = buf-&gt;b_p_sts;</a>
<a name="ln6561">        buf-&gt;b_p_ai_nopaste = buf-&gt;b_p_ai;</a>
<a name="ln6562">        buf-&gt;b_p_et_nopaste = buf-&gt;b_p_et;</a>
<a name="ln6563">      }</a>
<a name="ln6564"> </a>
<a name="ln6565">      // save global options</a>
<a name="ln6566">      save_sm = p_sm;</a>
<a name="ln6567">      save_sta = p_sta;</a>
<a name="ln6568">      save_ru = p_ru;</a>
<a name="ln6569">      save_ri = p_ri;</a>
<a name="ln6570">      save_hkmap = p_hkmap;</a>
<a name="ln6571">      // save global values for local buffer options</a>
<a name="ln6572">      p_ai_nopaste = p_ai;</a>
<a name="ln6573">      p_et_nopaste = p_et;</a>
<a name="ln6574">      p_sts_nopaste = p_sts;</a>
<a name="ln6575">      p_tw_nopaste = p_tw;</a>
<a name="ln6576">      p_wm_nopaste = p_wm;</a>
<a name="ln6577">    }</a>
<a name="ln6578"> </a>
<a name="ln6579">    // Always set the option values, also when 'paste' is set when it is</a>
<a name="ln6580">    // already on.</a>
<a name="ln6581">    // set options for each buffer</a>
<a name="ln6582">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6583">      buf-&gt;b_p_tw = 0;              // textwidth is 0</a>
<a name="ln6584">      buf-&gt;b_p_wm = 0;              // wrapmargin is 0</a>
<a name="ln6585">      buf-&gt;b_p_sts = 0;             // softtabstop is 0</a>
<a name="ln6586">      buf-&gt;b_p_ai = 0;              // no auto-indent</a>
<a name="ln6587">      buf-&gt;b_p_et = 0;              // no expandtab</a>
<a name="ln6588">    }</a>
<a name="ln6589"> </a>
<a name="ln6590">    // set global options</a>
<a name="ln6591">    p_sm = 0;                       // no showmatch</a>
<a name="ln6592">    p_sta = 0;                      // no smarttab</a>
<a name="ln6593">    if (p_ru) {</a>
<a name="ln6594">      status_redraw_all();          // redraw to remove the ruler</a>
<a name="ln6595">    }</a>
<a name="ln6596">    p_ru = 0;                       // no ruler</a>
<a name="ln6597">    p_ri = 0;                       // no reverse insert</a>
<a name="ln6598">    p_hkmap = 0;                    // no Hebrew keyboard</a>
<a name="ln6599">    // set global values for local buffer options</a>
<a name="ln6600">    p_tw = 0;</a>
<a name="ln6601">    p_wm = 0;</a>
<a name="ln6602">    p_sts = 0;</a>
<a name="ln6603">    p_ai = 0;</a>
<a name="ln6604">  } else if (old_p_paste) {</a>
<a name="ln6605">    // Paste switched from on to off: Restore saved values.</a>
<a name="ln6606"> </a>
<a name="ln6607">    // restore options for each buffer</a>
<a name="ln6608">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6609">      buf-&gt;b_p_tw = buf-&gt;b_p_tw_nopaste;</a>
<a name="ln6610">      buf-&gt;b_p_wm = buf-&gt;b_p_wm_nopaste;</a>
<a name="ln6611">      buf-&gt;b_p_sts = buf-&gt;b_p_sts_nopaste;</a>
<a name="ln6612">      buf-&gt;b_p_ai = buf-&gt;b_p_ai_nopaste;</a>
<a name="ln6613">      buf-&gt;b_p_et = buf-&gt;b_p_et_nopaste;</a>
<a name="ln6614">    }</a>
<a name="ln6615"> </a>
<a name="ln6616">    // restore global options</a>
<a name="ln6617">    p_sm = save_sm;</a>
<a name="ln6618">    p_sta = save_sta;</a>
<a name="ln6619">    if (p_ru != save_ru) {</a>
<a name="ln6620">      status_redraw_all();          // redraw to draw the ruler</a>
<a name="ln6621">    }</a>
<a name="ln6622">    p_ru = save_ru;</a>
<a name="ln6623">    p_ri = save_ri;</a>
<a name="ln6624">    p_hkmap = save_hkmap;</a>
<a name="ln6625">    // set global values for local buffer options</a>
<a name="ln6626">    p_ai = p_ai_nopaste;</a>
<a name="ln6627">    p_et = p_et_nopaste;</a>
<a name="ln6628">    p_sts = p_sts_nopaste;</a>
<a name="ln6629">    p_tw = p_tw_nopaste;</a>
<a name="ln6630">    p_wm = p_wm_nopaste;</a>
<a name="ln6631">  }</a>
<a name="ln6632"> </a>
<a name="ln6633">  old_p_paste = p_paste;</a>
<a name="ln6634">}</a>
<a name="ln6635"> </a>
<a name="ln6636">/// vimrc_found() - Called when a vimrc or &quot;VIMINIT&quot; has been found.</a>
<a name="ln6637">///</a>
<a name="ln6638">/// Set the values for options that didn't get set yet to the Vim defaults.</a>
<a name="ln6639">/// When &quot;fname&quot; is not NULL, use it to set $&quot;envname&quot; when it wasn't set yet.</a>
<a name="ln6640">void vimrc_found(char_u *fname, char_u *envname)</a>
<a name="ln6641">{</a>
<a name="ln6642">  if (fname != NULL &amp;&amp; envname != NULL) {</a>
<a name="ln6643">    char *p = vim_getenv((char *)envname);</a>
<a name="ln6644">    if (p == NULL) {</a>
<a name="ln6645">      // Set $MYVIMRC to the first vimrc file found.</a>
<a name="ln6646">      p = FullName_save((char *)fname, false);</a>
<a name="ln6647">      if (p != NULL) {</a>
<a name="ln6648">        os_setenv((char *)envname, p, 1);</a>
<a name="ln6649">        xfree(p);</a>
<a name="ln6650">      }</a>
<a name="ln6651">    } else {</a>
<a name="ln6652">      xfree(p);</a>
<a name="ln6653">    }</a>
<a name="ln6654">  }</a>
<a name="ln6655">}</a>
<a name="ln6656"> </a>
<a name="ln6657">/// Check whether global option has been set</a>
<a name="ln6658">///</a>
<a name="ln6659">/// @param[in]  name  Option name.</a>
<a name="ln6660">///</a>
<a name="ln6661">/// @return True if it was set.</a>
<a name="ln6662">bool option_was_set(const char *name)</a>
<a name="ln6663">{</a>
<a name="ln6664">  int idx;</a>
<a name="ln6665"> </a>
<a name="ln6666">  idx = findoption(name);</a>
<a name="ln6667">  if (idx &lt; 0) {  // Unknown option.</a>
<a name="ln6668">    return false;</a>
<a name="ln6669">  } else if (options[idx].flags &amp; P_WAS_SET) {</a>
<a name="ln6670">    return true;</a>
<a name="ln6671">  }</a>
<a name="ln6672">  return false;</a>
<a name="ln6673">}</a>
<a name="ln6674"> </a>
<a name="ln6675">/// Reset the flag indicating option &quot;name&quot; was set.</a>
<a name="ln6676">///</a>
<a name="ln6677">/// @param[in]  name  Option name.</a>
<a name="ln6678">void reset_option_was_set(const char *name)</a>
<a name="ln6679">{</a>
<a name="ln6680">  const int idx = findoption(name);</a>
<a name="ln6681"> </a>
<a name="ln6682">  if (idx &gt;= 0) {</a>
<a name="ln6683">    options[idx].flags &amp;= ~P_WAS_SET;</a>
<a name="ln6684">  }</a>
<a name="ln6685">}</a>
<a name="ln6686"> </a>
<a name="ln6687">/// fill_breakat_flags() -- called when 'breakat' changes value.</a>
<a name="ln6688">static void fill_breakat_flags(void)</a>
<a name="ln6689">{</a>
<a name="ln6690">  char_u      *p;</a>
<a name="ln6691">  int i;</a>
<a name="ln6692"> </a>
<a name="ln6693">  for (i = 0; i &lt; 256; i++) {</a>
<a name="ln6694">    breakat_flags[i] = false;</a>
<a name="ln6695">  }</a>
<a name="ln6696"> </a>
<a name="ln6697">  if (p_breakat != NULL) {</a>
<a name="ln6698">    for (p = p_breakat; *p; p++) {</a>
<a name="ln6699">      breakat_flags[*p] = true;</a>
<a name="ln6700">    }</a>
<a name="ln6701">  }</a>
<a name="ln6702">}</a>
<a name="ln6703"> </a>
<a name="ln6704">/// Check an option that can be a range of string values.</a>
<a name="ln6705">///</a>
<a name="ln6706">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6707">/// Empty is always OK.</a>
<a name="ln6708">static int check_opt_strings(</a>
<a name="ln6709">    char_u *val,</a>
<a name="ln6710">    char **values,</a>
<a name="ln6711">    int list                   // when true: accept a list of values</a>
<a name="ln6712">)</a>
<a name="ln6713">{</a>
<a name="ln6714">  return opt_strings_flags(val, values, NULL, list);</a>
<a name="ln6715">}</a>
<a name="ln6716"> </a>
<a name="ln6717">/// Handle an option that can be a range of string values.</a>
<a name="ln6718">/// Set a flag in &quot;*flagp&quot; for each string present.</a>
<a name="ln6719">///</a>
<a name="ln6720">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6721">/// Empty is always OK.</a>
<a name="ln6722">static int opt_strings_flags(</a>
<a name="ln6723">    char_u *val,             // new value</a>
<a name="ln6724">    char **values,           // array of valid string values</a>
<a name="ln6725">    unsigned *flagp,</a>
<a name="ln6726">    bool list                // when true: accept a list of values</a>
<a name="ln6727">)</a>
<a name="ln6728">{</a>
<a name="ln6729">  unsigned int new_flags = 0;</a>
<a name="ln6730"> </a>
<a name="ln6731">  while (*val) {</a>
<a name="ln6732">    for (unsigned int i = 0;; i++) {</a>
<a name="ln6733">      if (values[i] == NULL) {          // val not found in values[]</a>
<a name="ln6734">        return FAIL;</a>
<a name="ln6735">      }</a>
<a name="ln6736"> </a>
<a name="ln6737">      size_t len = STRLEN(values[i]);</a>
<a name="ln6738">      if (STRNCMP(values[i], val, len) == 0</a>
<a name="ln6739">          &amp;&amp; ((list &amp;&amp; val[len] == ',') || val[len] == NUL)) {</a>
<a name="ln6740">        val += len + (val[len] == ',');</a>
<a name="ln6741">        assert(i &lt; sizeof(1U) * 8);</a>
<a name="ln6742">        new_flags |= (1U &lt;&lt; i);</a>
<a name="ln6743">        break;                  // check next item in val list</a>
<a name="ln6744">      }</a>
<a name="ln6745">    }</a>
<a name="ln6746">  }</a>
<a name="ln6747">  if (flagp != NULL) {</a>
<a name="ln6748">    *flagp = new_flags;</a>
<a name="ln6749">  }</a>
<a name="ln6750"> </a>
<a name="ln6751">  return OK;</a>
<a name="ln6752">}</a>
<a name="ln6753"> </a>
<a name="ln6754">/// Read the 'wildmode' option, fill wim_flags[].</a>
<a name="ln6755">static int check_opt_wim(void)</a>
<a name="ln6756">{</a>
<a name="ln6757">  char_u new_wim_flags[4];</a>
<a name="ln6758">  char_u      *p;</a>
<a name="ln6759">  int i;</a>
<a name="ln6760">  int idx = 0;</a>
<a name="ln6761"> </a>
<a name="ln6762">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln6763">    new_wim_flags[i] = 0;</a>
<a name="ln6764">  }</a>
<a name="ln6765"> </a>
<a name="ln6766">  for (p = p_wim; *p; p++) {</a>
<a name="ln6767">    for (i = 0; ASCII_ISALPHA(p[i]); i++) {}</a>
<a name="ln6768">    if (p[i] != NUL &amp;&amp; p[i] != ',' &amp;&amp; p[i] != ':') {</a>
<a name="ln6769">      return FAIL;</a>
<a name="ln6770">    }</a>
<a name="ln6771">    if (i == 7 &amp;&amp; STRNCMP(p, &quot;longest&quot;, 7) == 0) {</a>
<a name="ln6772">      new_wim_flags[idx] |= WIM_LONGEST;</a>
<a name="ln6773">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;full&quot;, 4) == 0) {</a>
<a name="ln6774">      new_wim_flags[idx] |= WIM_FULL;</a>
<a name="ln6775">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;list&quot;, 4) == 0) {</a>
<a name="ln6776">      new_wim_flags[idx] |= WIM_LIST;</a>
<a name="ln6777">    } else if (i == 8 &amp;&amp; STRNCMP(p, &quot;lastused&quot;, 8) == 0) {</a>
<a name="ln6778">      new_wim_flags[idx] |= WIM_BUFLASTUSED;</a>
<a name="ln6779">    } else {</a>
<a name="ln6780">      return FAIL;</a>
<a name="ln6781">    }</a>
<a name="ln6782">    p += i;</a>
<a name="ln6783">    if (*p == NUL) {</a>
<a name="ln6784">      break;</a>
<a name="ln6785">    }</a>
<a name="ln6786">    if (*p == ',') {</a>
<a name="ln6787">      if (idx == 3) {</a>
<a name="ln6788">        return FAIL;</a>
<a name="ln6789">      }</a>
<a name="ln6790">      idx++;</a>
<a name="ln6791">    }</a>
<a name="ln6792">  }</a>
<a name="ln6793"> </a>
<a name="ln6794">  // fill remaining entries with last flag</a>
<a name="ln6795">  while (idx &lt; 3) {</a>
<a name="ln6796">    new_wim_flags[idx + 1] = new_wim_flags[idx];</a>
<a name="ln6797">    idx++;</a>
<a name="ln6798">  }</a>
<a name="ln6799"> </a>
<a name="ln6800">  // only when there are no errors, wim_flags[] is changed</a>
<a name="ln6801">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln6802">    wim_flags[i] = new_wim_flags[i];</a>
<a name="ln6803">  }</a>
<a name="ln6804">  return OK;</a>
<a name="ln6805">}</a>
<a name="ln6806"> </a>
<a name="ln6807">/// Check if backspacing over something is allowed.</a>
<a name="ln6808">/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP</a>
<a name="ln6809">bool can_bs(int what)</a>
<a name="ln6810">{</a>
<a name="ln6811">  if (what == BS_START &amp;&amp; bt_prompt(curbuf)) {</a>
<a name="ln6812">    return false;</a>
<a name="ln6813">  }</a>
<a name="ln6814">  switch (*p_bs) {</a>
<a name="ln6815">    case '3':       return true;</a>
<a name="ln6816">    case '2':       return what != BS_NOSTOP;</a>
<a name="ln6817">    case '1':       return what != BS_START;</a>
<a name="ln6818">    case '0':       return false;</a>
<a name="ln6819">  }</a>
<a name="ln6820">  return vim_strchr(p_bs, what) != NULL;</a>
<a name="ln6821">}</a>
<a name="ln6822"> </a>
<a name="ln6823">/// Save the current values of 'fileformat' and 'fileencoding', so that we know</a>
<a name="ln6824">/// the file must be considered changed when the value is different.</a>
<a name="ln6825">void save_file_ff(buf_T *buf)</a>
<a name="ln6826">{</a>
<a name="ln6827">  buf-&gt;b_start_ffc = *buf-&gt;b_p_ff;</a>
<a name="ln6828">  buf-&gt;b_start_eol = buf-&gt;b_p_eol;</a>
<a name="ln6829">  buf-&gt;b_start_bomb = buf-&gt;b_p_bomb;</a>
<a name="ln6830"> </a>
<a name="ln6831">  // Only use free/alloc when necessary, they take time.</a>
<a name="ln6832">  if (buf-&gt;b_start_fenc == NULL</a>
<a name="ln6833">      || STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0) {</a>
<a name="ln6834">    xfree(buf-&gt;b_start_fenc);</a>
<a name="ln6835">    buf-&gt;b_start_fenc = vim_strsave(buf-&gt;b_p_fenc);</a>
<a name="ln6836">  }</a>
<a name="ln6837">}</a>
<a name="ln6838"> </a>
<a name="ln6839">/// Return true if 'fileformat' and/or 'fileencoding' has a different value</a>
<a name="ln6840">/// from when editing started (save_file_ff() called).</a>
<a name="ln6841">/// Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was</a>
<a name="ln6842">/// changed and 'binary' is not set.</a>
<a name="ln6843">/// Also when 'endofline' was changed and 'fixeol' is not set.</a>
<a name="ln6844">/// When &quot;ignore_empty&quot; is true don't consider a new, empty buffer to be</a>
<a name="ln6845">/// changed.</a>
<a name="ln6846">bool file_ff_differs(buf_T *buf, bool ignore_empty)</a>
<a name="ln6847">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6848">{</a>
<a name="ln6849">  // In a buffer that was never loaded the options are not valid.</a>
<a name="ln6850">  if (buf-&gt;b_flags &amp; BF_NEVERLOADED) {</a>
<a name="ln6851">    return false;</a>
<a name="ln6852">  }</a>
<a name="ln6853">  if (ignore_empty</a>
<a name="ln6854">      &amp;&amp; (buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln6855">      &amp;&amp; buf-&gt;b_ml.ml_line_count == 1</a>
<a name="ln6856">      &amp;&amp; *ml_get_buf(buf, (linenr_T)1, false) == NUL) {</a>
<a name="ln6857">    return false;</a>
<a name="ln6858">  }</a>
<a name="ln6859">  if (buf-&gt;b_start_ffc != *buf-&gt;b_p_ff) {</a>
<a name="ln6860">    return true;</a>
<a name="ln6861">  }</a>
<a name="ln6862">  if ((buf-&gt;b_p_bin || !buf-&gt;b_p_fixeol) &amp;&amp; buf-&gt;b_start_eol != buf-&gt;b_p_eol) {</a>
<a name="ln6863">    return true;</a>
<a name="ln6864">  }</a>
<a name="ln6865">  if (!buf-&gt;b_p_bin &amp;&amp; buf-&gt;b_start_bomb != buf-&gt;b_p_bomb) {</a>
<a name="ln6866">    return true;</a>
<a name="ln6867">  }</a>
<a name="ln6868">  if (buf-&gt;b_start_fenc == NULL) {</a>
<a name="ln6869">    return *buf-&gt;b_p_fenc != NUL;</a>
<a name="ln6870">  }</a>
<a name="ln6871">  return STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0;</a>
<a name="ln6872">}</a>
<a name="ln6873"> </a>
<a name="ln6874">/// return OK if &quot;p&quot; is a valid fileformat name, FAIL otherwise.</a>
<a name="ln6875">int check_ff_value(char_u *p)</a>
<a name="ln6876">{</a>
<a name="ln6877">  return check_opt_strings(p, p_ff_values, false);</a>
<a name="ln6878">}</a>
<a name="ln6879"> </a>
<a name="ln6880">/// Return the effective shiftwidth value for current buffer, using the</a>
<a name="ln6881">/// 'tabstop' value when 'shiftwidth' is zero.</a>
<a name="ln6882">int get_sw_value(buf_T *buf)</a>
<a name="ln6883">{</a>
<a name="ln6884">  long result = buf-&gt;b_p_sw ? buf-&gt;b_p_sw : buf-&gt;b_p_ts;</a>
<a name="ln6885">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln6886">  return (int)result;</a>
<a name="ln6887">}</a>
<a name="ln6888"> </a>
<a name="ln6889">/// Return the effective softtabstop value for the current buffer,</a>
<a name="ln6890">/// using the effective shiftwidth  value when 'softtabstop' is negative.</a>
<a name="ln6891">int get_sts_value(void)</a>
<a name="ln6892">{</a>
<a name="ln6893">  long result = curbuf-&gt;b_p_sts &lt; 0 ? get_sw_value(curbuf) : curbuf-&gt;b_p_sts;</a>
<a name="ln6894">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln6895">  return (int)result;</a>
<a name="ln6896">}</a>
<a name="ln6897"> </a>
<a name="ln6898">/// This is called when 'breakindentopt' is changed and when a window is</a>
<a name="ln6899">/// initialized</a>
<a name="ln6900">static bool briopt_check(win_T *wp)</a>
<a name="ln6901">{</a>
<a name="ln6902">  int bri_shift = 0;</a>
<a name="ln6903">  int bri_min = 20;</a>
<a name="ln6904">  bool bri_sbr = false;</a>
<a name="ln6905"> </a>
<a name="ln6906">  char_u *p = wp-&gt;w_p_briopt;</a>
<a name="ln6907">  while (*p != NUL)</a>
<a name="ln6908">  {</a>
<a name="ln6909">    if (STRNCMP(p, &quot;shift:&quot;, 6) == 0</a>
<a name="ln6910">        &amp;&amp; ((p[6] == '-' &amp;&amp; ascii_isdigit(p[7])) || ascii_isdigit(p[6])))</a>
<a name="ln6911">    {</a>
<a name="ln6912">      p += 6;</a>
<a name="ln6913">      bri_shift = getdigits_int(&amp;p, true, 0);</a>
<a name="ln6914">    }</a>
<a name="ln6915">    else if (STRNCMP(p, &quot;min:&quot;, 4) == 0 &amp;&amp; ascii_isdigit(p[4]))</a>
<a name="ln6916">    {</a>
<a name="ln6917">      p += 4;</a>
<a name="ln6918">      bri_min = getdigits_int(&amp;p, true, 0);</a>
<a name="ln6919">    }</a>
<a name="ln6920">    else if (STRNCMP(p, &quot;sbr&quot;, 3) == 0)</a>
<a name="ln6921">    {</a>
<a name="ln6922">      p += 3;</a>
<a name="ln6923">      bri_sbr = true;</a>
<a name="ln6924">    }</a>
<a name="ln6925">    if (*p != ',' &amp;&amp; *p != NUL) {</a>
<a name="ln6926">      return false;</a>
<a name="ln6927">    }</a>
<a name="ln6928">    if (*p == ',') {</a>
<a name="ln6929">      p++;</a>
<a name="ln6930">    }</a>
<a name="ln6931">  }</a>
<a name="ln6932"> </a>
<a name="ln6933">  wp-&gt;w_briopt_shift = bri_shift;</a>
<a name="ln6934">  wp-&gt;w_briopt_min = bri_min;</a>
<a name="ln6935">  wp-&gt;w_briopt_sbr = bri_sbr;</a>
<a name="ln6936"> </a>
<a name="ln6937">  return true;</a>
<a name="ln6938">}</a>
<a name="ln6939"> </a>
<a name="ln6940">/// Get the local or global value of 'backupcopy'.</a>
<a name="ln6941">///</a>
<a name="ln6942">/// @param buf The buffer.</a>
<a name="ln6943">unsigned int get_bkc_value(buf_T *buf)</a>
<a name="ln6944">{</a>
<a name="ln6945">  return buf-&gt;b_bkc_flags ? buf-&gt;b_bkc_flags : bkc_flags;</a>
<a name="ln6946">}</a>
<a name="ln6947"> </a>
<a name="ln6948">/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.</a>
<a name="ln6949">int get_fileformat(const buf_T *buf)</a>
<a name="ln6950">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6951">{</a>
<a name="ln6952">  int c = *buf-&gt;b_p_ff;</a>
<a name="ln6953"> </a>
<a name="ln6954">  if (buf-&gt;b_p_bin || c == 'u') {</a>
<a name="ln6955">    return EOL_UNIX;</a>
<a name="ln6956">  }</a>
<a name="ln6957">  if (c == 'm') {</a>
<a name="ln6958">    return EOL_MAC;</a>
<a name="ln6959">  }</a>
<a name="ln6960">  return EOL_DOS;</a>
<a name="ln6961">}</a>
<a name="ln6962"> </a>
<a name="ln6963">/// Like get_fileformat(), but override 'fileformat' with &quot;p&quot; for &quot;++opt=val&quot;</a>
<a name="ln6964">/// argument.</a>
<a name="ln6965">///</a>
<a name="ln6966">/// @param eap  can be NULL!</a>
<a name="ln6967">int get_fileformat_force(const buf_T *buf, const exarg_T *eap)</a>
<a name="ln6968">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln6969">{</a>
<a name="ln6970">  int c;</a>
<a name="ln6971"> </a>
<a name="ln6972">  if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln6973">    c = eap-&gt;force_ff;</a>
<a name="ln6974">  } else {</a>
<a name="ln6975">    if ((eap != NULL &amp;&amp; eap-&gt;force_bin != 0)</a>
<a name="ln6976">        ? (eap-&gt;force_bin == FORCE_BIN) : buf-&gt;b_p_bin) {</a>
<a name="ln6977">      return EOL_UNIX;</a>
<a name="ln6978">    }</a>
<a name="ln6979">    c = *buf-&gt;b_p_ff;</a>
<a name="ln6980">  }</a>
<a name="ln6981">  if (c == 'u') {</a>
<a name="ln6982">    return EOL_UNIX;</a>
<a name="ln6983">  }</a>
<a name="ln6984">  if (c == 'm') {</a>
<a name="ln6985">    return EOL_MAC;</a>
<a name="ln6986">  }</a>
<a name="ln6987">  return EOL_DOS;</a>
<a name="ln6988">}</a>
<a name="ln6989"> </a>
<a name="ln6990">/// Return the default fileformat from 'fileformats'.</a>
<a name="ln6991">int default_fileformat(void)</a>
<a name="ln6992">{</a>
<a name="ln6993">  switch (*p_ffs) {</a>
<a name="ln6994">  case 'm':   return EOL_MAC;</a>
<a name="ln6995">  case 'd':   return EOL_DOS;</a>
<a name="ln6996">  }</a>
<a name="ln6997">  return EOL_UNIX;</a>
<a name="ln6998">}</a>
<a name="ln6999"> </a>
<a name="ln7000">/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.</a>
<a name="ln7001">///</a>
<a name="ln7002">/// Sets 'fileformat'.</a>
<a name="ln7003">///</a>
<a name="ln7004">/// @param eol_style End-of-line style.</a>
<a name="ln7005">/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln7006">void set_fileformat(int eol_style, int opt_flags)</a>
<a name="ln7007">{</a>
<a name="ln7008">  char *p = NULL;</a>
<a name="ln7009"> </a>
<a name="ln7010">  switch (eol_style) {</a>
<a name="ln7011">      case EOL_UNIX:</a>
<a name="ln7012">          p = FF_UNIX;</a>
<a name="ln7013">          break;</a>
<a name="ln7014">      case EOL_MAC:</a>
<a name="ln7015">          p = FF_MAC;</a>
<a name="ln7016">          break;</a>
<a name="ln7017">      case EOL_DOS:</a>
<a name="ln7018">          p = FF_DOS;</a>
<a name="ln7019">          break;</a>
<a name="ln7020">  }</a>
<a name="ln7021"> </a>
<a name="ln7022">  // p is NULL if &quot;eol_style&quot; is EOL_UNKNOWN.</a>
<a name="ln7023">  if (p != NULL) {</a>
<a name="ln7024">    set_string_option_direct((char_u *)&quot;ff&quot;,</a>
<a name="ln7025">                             -1,</a>
<a name="ln7026">                             (char_u *)p,</a>
<a name="ln7027">                             OPT_FREE | opt_flags,</a>
<a name="ln7028">                             0);</a>
<a name="ln7029">  }</a>
<a name="ln7030"> </a>
<a name="ln7031">  // This may cause the buffer to become (un)modified.</a>
<a name="ln7032">  check_status(curbuf);</a>
<a name="ln7033">  redraw_tabline = true;</a>
<a name="ln7034">  need_maketitle = true;  // Set window title later.</a>
<a name="ln7035">}</a>
<a name="ln7036"> </a>
<a name="ln7037">/// Skip to next part of an option argument: skip space and comma</a>
<a name="ln7038">char_u *skip_to_option_part(const char_u *p)</a>
<a name="ln7039">{</a>
<a name="ln7040">  if (*p == ',') {</a>
<a name="ln7041">    p++;</a>
<a name="ln7042">  }</a>
<a name="ln7043">  while (*p == ' ') {</a>
<a name="ln7044">    p++;</a>
<a name="ln7045">  }</a>
<a name="ln7046">  return (char_u *)p;</a>
<a name="ln7047">}</a>
<a name="ln7048"> </a>
<a name="ln7049">/// Isolate one part of a string option separated by `sep_chars`.</a>
<a name="ln7050">///</a>
<a name="ln7051">/// @param[in,out]  option    advanced to the next part</a>
<a name="ln7052">/// @param[in,out]  buf       copy of the isolated part</a>
<a name="ln7053">/// @param[in]      maxlen    length of `buf`</a>
<a name="ln7054">/// @param[in]      sep_chars chars that separate the option parts</a>
<a name="ln7055">///</a>
<a name="ln7056">/// @return length of `*option`</a>
<a name="ln7057">size_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,</a>
<a name="ln7058">                        char *sep_chars)</a>
<a name="ln7059">{</a>
<a name="ln7060">  size_t len = 0;</a>
<a name="ln7061">  char_u  *p = *option;</a>
<a name="ln7062"> </a>
<a name="ln7063">  // skip '.' at start of option part, for 'suffixes'</a>
<a name="ln7064">  if (*p == '.') {</a>
<a name="ln7065">    buf[len++] = *p++;</a>
<a name="ln7066">  }</a>
<a name="ln7067">  while (*p != NUL &amp;&amp; vim_strchr((char_u *)sep_chars, *p) == NULL) {</a>
<a name="ln7068">    // Skip backslash before a separator character and space.</a>
<a name="ln7069">    if (p[0] == '\\' &amp;&amp; vim_strchr((char_u *)sep_chars, p[1]) != NULL) {</a>
<a name="ln7070">      p++;</a>
<a name="ln7071">    }</a>
<a name="ln7072">    if (len &lt; maxlen - 1) {</a>
<a name="ln7073">      buf[len++] = *p;</a>
<a name="ln7074">    }</a>
<a name="ln7075">    p++;</a>
<a name="ln7076">  }</a>
<a name="ln7077">  buf[len] = NUL;</a>
<a name="ln7078"> </a>
<a name="ln7079">  if (*p != NUL &amp;&amp; *p != ',') {  // skip non-standard separator</a>
<a name="ln7080">    p++;</a>
<a name="ln7081">  }</a>
<a name="ln7082">  p = skip_to_option_part(p);    // p points to next file name</a>
<a name="ln7083"> </a>
<a name="ln7084">  *option = p;</a>
<a name="ln7085">  return len;</a>
<a name="ln7086">}</a>
<a name="ln7087"> </a>
<a name="ln7088">/// Return true when 'shell' has &quot;csh&quot; in the tail.</a>
<a name="ln7089">int csh_like_shell(void)</a>
<a name="ln7090">{</a>
<a name="ln7091">  return strstr((char *)path_tail(p_sh), &quot;csh&quot;) != NULL;</a>
<a name="ln7092">}</a>
<a name="ln7093"> </a>
<a name="ln7094">/// Return the number of requested sign columns, based on current</a>
<a name="ln7095">/// buffer signs and on user configuration.</a>
<a name="ln7096">int win_signcol_count(win_T *wp)</a>
<a name="ln7097">{</a>
<a name="ln7098">  int maximum = 1, needed_signcols;</a>
<a name="ln7099">  const char *scl = (const char *)wp-&gt;w_p_scl;</a>
<a name="ln7100"> </a>
<a name="ln7101">  // Note: It checks &quot;no&quot; or &quot;number&quot; in 'signcolumn' option</a>
<a name="ln7102">  if (*scl == 'n'</a>
<a name="ln7103">      &amp;&amp; (*(scl + 1) == 'o' || (*(scl + 1) == 'u'</a>
<a name="ln7104">                                &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu)))) {</a>
<a name="ln7105">    return 0;</a>
<a name="ln7106">  }</a>
<a name="ln7107">  needed_signcols = buf_signcols(wp-&gt;w_buffer);</a>
<a name="ln7108"> </a>
<a name="ln7109">  // yes or yes</a>
<a name="ln7110">  if (!strncmp(scl, &quot;yes:&quot;, 4)) {</a>
<a name="ln7111">    // Fixed amount of columns</a>
<a name="ln7112">    return scl[4] - '0';</a>
<a name="ln7113">  }</a>
<a name="ln7114">  if (*scl == 'y') {</a>
<a name="ln7115">    return 1;</a>
<a name="ln7116">  }</a>
<a name="ln7117"> </a>
<a name="ln7118">  // auto or auto:&lt;NUM&gt;</a>
<a name="ln7119">  if (!strncmp(scl, &quot;auto:&quot;, 5)) {</a>
<a name="ln7120">    // Variable depending on a configuration</a>
<a name="ln7121">    maximum = scl[5] - '0';</a>
<a name="ln7122">  }</a>
<a name="ln7123"> </a>
<a name="ln7124">  return MIN(maximum, needed_signcols);</a>
<a name="ln7125">}</a>
<a name="ln7126"> </a>
<a name="ln7127">/// Get window or buffer local options</a>
<a name="ln7128">dict_T *get_winbuf_options(const int bufopt)</a>
<a name="ln7129">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7130">{</a>
<a name="ln7131">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln7132"> </a>
<a name="ln7133">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln7134">    struct vimoption *opt = &amp;options[opt_idx];</a>
<a name="ln7135"> </a>
<a name="ln7136">    if ((bufopt &amp;&amp; (opt-&gt;indir &amp; PV_BUF))</a>
<a name="ln7137">        || (!bufopt &amp;&amp; (opt-&gt;indir &amp; PV_WIN))) {</a>
<a name="ln7138">      char_u *varp = get_varp(opt);</a>
<a name="ln7139"> </a>
<a name="ln7140">      if (varp != NULL) {</a>
<a name="ln7141">        if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7142">          tv_dict_add_str(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7143">                          *(const char **)varp);</a>
<a name="ln7144">        } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7145">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7146">                         *(long *)varp);</a>
<a name="ln7147">        } else {</a>
<a name="ln7148">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname), *(int *)varp);</a>
<a name="ln7149">        }</a>
<a name="ln7150">      }</a>
<a name="ln7151">    }</a>
<a name="ln7152">  }</a>
<a name="ln7153"> </a>
<a name="ln7154">  return d;</a>
<a name="ln7155">}</a>
<a name="ln7156"> </a>
<a name="ln7157">/// Return the effective 'scrolloff' value for the current window, using the</a>
<a name="ln7158">/// global value when appropriate.</a>
<a name="ln7159">long get_scrolloff_value(win_T *wp)</a>
<a name="ln7160">{</a>
<a name="ln7161">  // Disallow scrolloff in terminal-mode. #11915</a>
<a name="ln7162">  if (State &amp; TERM_FOCUS) {</a>
<a name="ln7163">    return 0;</a>
<a name="ln7164">  }</a>
<a name="ln7165">  return wp-&gt;w_p_so &lt; 0 ? p_so : wp-&gt;w_p_so;</a>
<a name="ln7166">}</a>
<a name="ln7167"> </a>
<a name="ln7168">/// Return the effective 'sidescrolloff' value for the current window, using the</a>
<a name="ln7169">/// global value when appropriate.</a>
<a name="ln7170">long get_sidescrolloff_value(win_T *wp)</a>
<a name="ln7171">{</a>
<a name="ln7172">  return wp-&gt;w_p_siso &lt; 0 ? p_siso : wp-&gt;w_p_siso;</a>
<a name="ln7173">}</a>
<a name="ln7174"> </a>
<a name="ln7175">Dictionary get_vimoption(String name, Error *err)</a>
<a name="ln7176">{</a>
<a name="ln7177">  int opt_idx = findoption_len((const char *)name.data, name.size);</a>
<a name="ln7178">  if (opt_idx &lt; 0) {</a>
<a name="ln7179">    api_set_error(err, kErrorTypeValidation, &quot;no such option: '%s'&quot;, name.data);</a>
<a name="ln7180">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln7181">  }</a>
<a name="ln7182">  return vimoption2dict(&amp;options[opt_idx]);</a>
<a name="ln7183">}</a>
<a name="ln7184"> </a>
<a name="ln7185">Dictionary get_all_vimoptions(void)</a>
<a name="ln7186">{</a>
<a name="ln7187">  Dictionary retval = ARRAY_DICT_INIT;</a>
<a name="ln7188">  for (size_t i = 0; i &lt; PARAM_COUNT; i++) {</a>
<a name="ln7189">    Dictionary opt_dict = vimoption2dict(&amp;options[i]);</a>
<a name="ln7190">    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));</a>
<a name="ln7191">  }</a>
<a name="ln7192">  return retval;</a>
<a name="ln7193">}</a>
<a name="ln7194"> </a>
<a name="ln7195">static Dictionary vimoption2dict(vimoption_T *opt)</a>
<a name="ln7196">{</a>
<a name="ln7197">    Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln7198"> </a>
<a name="ln7199">    PUT(dict, &quot;name&quot;, CSTR_TO_OBJ(opt-&gt;fullname));</a>
<a name="ln7200">    PUT(dict, &quot;shortname&quot;, CSTR_TO_OBJ(opt-&gt;shortname));</a>
<a name="ln7201"> </a>
<a name="ln7202">    const char *scope;</a>
<a name="ln7203">    if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln7204">      scope = &quot;buf&quot;;</a>
<a name="ln7205">    } else if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln7206">      scope = &quot;win&quot;;</a>
<a name="ln7207">    } else {</a>
<a name="ln7208">      scope = &quot;global&quot;;</a>
<a name="ln7209">    }</a>
<a name="ln7210"> </a>
<a name="ln7211">    PUT(dict, &quot;scope&quot;, CSTR_TO_OBJ(scope));</a>
<a name="ln7212"> </a>
<a name="ln7213">    // welcome to the jungle</a>
<a name="ln7214">    PUT(dict, &quot;global_local&quot;, BOOL(opt-&gt;indir &amp; PV_BOTH));</a>
<a name="ln7215">    PUT(dict, &quot;commalist&quot;, BOOL(opt-&gt;flags &amp; P_COMMA));</a>
<a name="ln7216">    PUT(dict, &quot;flaglist&quot;, BOOL(opt-&gt;flags &amp; P_FLAGLIST));</a>
<a name="ln7217"> </a>
<a name="ln7218">    PUT(dict, &quot;was_set&quot;, BOOL(opt-&gt;flags &amp; P_WAS_SET));</a>
<a name="ln7219"> </a>
<a name="ln7220">    PUT(dict, &quot;last_set_sid&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_sid));</a>
<a name="ln7221">    PUT(dict, &quot;last_set_linenr&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_lnum));</a>
<a name="ln7222">    PUT(dict, &quot;last_set_chan&quot;, INTEGER_OBJ((int64_t)opt-&gt;last_set.channel_id));</a>
<a name="ln7223"> </a>
<a name="ln7224">    const char *type;</a>
<a name="ln7225">    Object def;</a>
<a name="ln7226">    // TODO(bfredl): do you even nocp?</a>
<a name="ln7227">    char_u *def_val = opt-&gt;def_val[(opt-&gt;flags &amp; P_VI_DEF)</a>
<a name="ln7228">                                   ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln7229">    if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7230">      type = &quot;string&quot;;</a>
<a name="ln7231">      def = CSTR_TO_OBJ(def_val ? (char *)def_val : &quot;&quot;);</a>
<a name="ln7232">    } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7233">      type = &quot;number&quot;;</a>
<a name="ln7234">      def = INTEGER_OBJ((Integer)(intptr_t)def_val);</a>
<a name="ln7235">    } else if (opt-&gt;flags &amp; P_BOOL) {</a>
<a name="ln7236">      type = &quot;boolean&quot;;</a>
<a name="ln7237">      def = BOOL((intptr_t)def_val);</a>
<a name="ln7238">    } else {</a>
<a name="ln7239">      type = &quot;&quot;; def = NIL;</a>
<a name="ln7240">    }</a>
<a name="ln7241">    PUT(dict, &quot;type&quot;, CSTR_TO_OBJ(type));</a>
<a name="ln7242">    PUT(dict, &quot;default&quot;, def);</a>
<a name="ln7243"> </a>
<a name="ln7244">    return dict;</a>
<a name="ln7245">}</a>

</code></pre>
<div class="balloon" rel="3941"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="3943"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="3945"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4342"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4343"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4344"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="4379"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

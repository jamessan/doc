
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>regexp_nfa.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * NFA regular expression implementation.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is included in &quot;regexp.c&quot;.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;limits.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/garray.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">/*</a>
<a name="ln19"> * Logging of NFA engine.</a>
<a name="ln20"> *</a>
<a name="ln21"> * The NFA engine can write four log files:</a>
<a name="ln22"> * - Error log: Contains NFA engine's fatal errors.</a>
<a name="ln23"> * - Dump log: Contains compiled NFA state machine's information.</a>
<a name="ln24"> * - Run log: Contains information of matching procedure.</a>
<a name="ln25"> * - Debug log: Contains detailed information of matching procedure. Can be</a>
<a name="ln26"> *   disabled by undefining NFA_REGEXP_DEBUG_LOG.</a>
<a name="ln27"> * The first one can also be used without debug mode.</a>
<a name="ln28"> * The last three are enabled when compiled as debug mode and individually</a>
<a name="ln29"> * disabled by commenting them out.</a>
<a name="ln30"> * The log files can get quite big!</a>
<a name="ln31"> * Do disable all of this when compiling Vim for debugging, undefine REGEXP_DEBUG in</a>
<a name="ln32"> * regexp.c</a>
<a name="ln33"> */</a>
<a name="ln34">#ifdef REGEXP_DEBUG</a>
<a name="ln35"># define NFA_REGEXP_ERROR_LOG   &quot;nfa_regexp_error.log&quot;</a>
<a name="ln36"># define NFA_REGEXP_DUMP_LOG    &quot;nfa_regexp_dump.log&quot;</a>
<a name="ln37"># define NFA_REGEXP_RUN_LOG     &quot;nfa_regexp_run.log&quot;</a>
<a name="ln38"># define NFA_REGEXP_DEBUG_LOG   &quot;nfa_regexp_debug.log&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40"> </a>
<a name="ln41">/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */</a>
<a name="ln42">#define NFA_ADD_NL              31</a>
<a name="ln43"> </a>
<a name="ln44">enum {</a>
<a name="ln45">  NFA_SPLIT = -1024,</a>
<a name="ln46">  NFA_MATCH,</a>
<a name="ln47">  NFA_EMPTY,                        /* matches 0-length */</a>
<a name="ln48"> </a>
<a name="ln49">  NFA_START_COLL,                   /* [abc] start */</a>
<a name="ln50">  NFA_END_COLL,                     /* [abc] end */</a>
<a name="ln51">  NFA_START_NEG_COLL,               /* [^abc] start */</a>
<a name="ln52">  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */</a>
<a name="ln53">  NFA_RANGE,                        /* range of the two previous items</a>
<a name="ln54">                                     * (postfix only) */</a>
<a name="ln55">  NFA_RANGE_MIN,                    /* low end of a range  */</a>
<a name="ln56">  NFA_RANGE_MAX,                    /* high end of a range  */</a>
<a name="ln57"> </a>
<a name="ln58">  NFA_CONCAT,                       // concatenate two previous items (postfix</a>
<a name="ln59">                                    // only)</a>
<a name="ln60">  NFA_OR,                           // \| (postfix only)</a>
<a name="ln61">  NFA_STAR,                         // greedy * (postfix only)</a>
<a name="ln62">  NFA_STAR_NONGREEDY,               // non-greedy * (postfix only)</a>
<a name="ln63">  NFA_QUEST,                        // greedy \? (postfix only)</a>
<a name="ln64">  NFA_QUEST_NONGREEDY,              // non-greedy \? (postfix only)</a>
<a name="ln65"> </a>
<a name="ln66">  NFA_BOL,                          /* ^    Begin line */</a>
<a name="ln67">  NFA_EOL,                          /* $    End line */</a>
<a name="ln68">  NFA_BOW,                          /* \&lt;   Begin word */</a>
<a name="ln69">  NFA_EOW,                          /* \&gt;   End word */</a>
<a name="ln70">  NFA_BOF,                          /* \%^  Begin file */</a>
<a name="ln71">  NFA_EOF,                          /* \%$  End file */</a>
<a name="ln72">  NFA_NEWL,</a>
<a name="ln73">  NFA_ZSTART,                       /* Used for \zs */</a>
<a name="ln74">  NFA_ZEND,                         /* Used for \ze */</a>
<a name="ln75">  NFA_NOPEN,                        /* Start of subexpression marked with \%( */</a>
<a name="ln76">  NFA_NCLOSE,                       /* End of subexpr. marked with \%( ... \) */</a>
<a name="ln77">  NFA_START_INVISIBLE,</a>
<a name="ln78">  NFA_START_INVISIBLE_FIRST,</a>
<a name="ln79">  NFA_START_INVISIBLE_NEG,</a>
<a name="ln80">  NFA_START_INVISIBLE_NEG_FIRST,</a>
<a name="ln81">  NFA_START_INVISIBLE_BEFORE,</a>
<a name="ln82">  NFA_START_INVISIBLE_BEFORE_FIRST,</a>
<a name="ln83">  NFA_START_INVISIBLE_BEFORE_NEG,</a>
<a name="ln84">  NFA_START_INVISIBLE_BEFORE_NEG_FIRST,</a>
<a name="ln85">  NFA_START_PATTERN,</a>
<a name="ln86">  NFA_END_INVISIBLE,</a>
<a name="ln87">  NFA_END_INVISIBLE_NEG,</a>
<a name="ln88">  NFA_END_PATTERN,</a>
<a name="ln89">  NFA_COMPOSING,                    /* Next nodes in NFA are part of the</a>
<a name="ln90">                                       composing multibyte char */</a>
<a name="ln91">  NFA_END_COMPOSING,                /* End of a composing char in the NFA */</a>
<a name="ln92">  NFA_ANY_COMPOSING,                // \%C: Any composing characters.</a>
<a name="ln93">  NFA_OPT_CHARS,                    /* \%[abc] */</a>
<a name="ln94"> </a>
<a name="ln95">  /* The following are used only in the postfix form, not in the NFA */</a>
<a name="ln96">  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \@= */</a>
<a name="ln97">  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \@! */</a>
<a name="ln98">  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \@&lt;= */</a>
<a name="ln99">  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \@&lt;! */</a>
<a name="ln100">  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \@&gt; */</a>
<a name="ln101"> </a>
<a name="ln102">  NFA_BACKREF1,                     /* \1 */</a>
<a name="ln103">  NFA_BACKREF2,                     /* \2 */</a>
<a name="ln104">  NFA_BACKREF3,                     /* \3 */</a>
<a name="ln105">  NFA_BACKREF4,                     /* \4 */</a>
<a name="ln106">  NFA_BACKREF5,                     /* \5 */</a>
<a name="ln107">  NFA_BACKREF6,                     /* \6 */</a>
<a name="ln108">  NFA_BACKREF7,                     /* \7 */</a>
<a name="ln109">  NFA_BACKREF8,                     /* \8 */</a>
<a name="ln110">  NFA_BACKREF9,                     /* \9 */</a>
<a name="ln111">  NFA_ZREF1,                        /* \z1 */</a>
<a name="ln112">  NFA_ZREF2,                        /* \z2 */</a>
<a name="ln113">  NFA_ZREF3,                        /* \z3 */</a>
<a name="ln114">  NFA_ZREF4,                        /* \z4 */</a>
<a name="ln115">  NFA_ZREF5,                        /* \z5 */</a>
<a name="ln116">  NFA_ZREF6,                        /* \z6 */</a>
<a name="ln117">  NFA_ZREF7,                        /* \z7 */</a>
<a name="ln118">  NFA_ZREF8,                        /* \z8 */</a>
<a name="ln119">  NFA_ZREF9,                        /* \z9 */</a>
<a name="ln120">  NFA_SKIP,                         /* Skip characters */</a>
<a name="ln121"> </a>
<a name="ln122">  NFA_MOPEN,</a>
<a name="ln123">  NFA_MOPEN1,</a>
<a name="ln124">  NFA_MOPEN2,</a>
<a name="ln125">  NFA_MOPEN3,</a>
<a name="ln126">  NFA_MOPEN4,</a>
<a name="ln127">  NFA_MOPEN5,</a>
<a name="ln128">  NFA_MOPEN6,</a>
<a name="ln129">  NFA_MOPEN7,</a>
<a name="ln130">  NFA_MOPEN8,</a>
<a name="ln131">  NFA_MOPEN9,</a>
<a name="ln132"> </a>
<a name="ln133">  NFA_MCLOSE,</a>
<a name="ln134">  NFA_MCLOSE1,</a>
<a name="ln135">  NFA_MCLOSE2,</a>
<a name="ln136">  NFA_MCLOSE3,</a>
<a name="ln137">  NFA_MCLOSE4,</a>
<a name="ln138">  NFA_MCLOSE5,</a>
<a name="ln139">  NFA_MCLOSE6,</a>
<a name="ln140">  NFA_MCLOSE7,</a>
<a name="ln141">  NFA_MCLOSE8,</a>
<a name="ln142">  NFA_MCLOSE9,</a>
<a name="ln143"> </a>
<a name="ln144">  NFA_ZOPEN,</a>
<a name="ln145">  NFA_ZOPEN1,</a>
<a name="ln146">  NFA_ZOPEN2,</a>
<a name="ln147">  NFA_ZOPEN3,</a>
<a name="ln148">  NFA_ZOPEN4,</a>
<a name="ln149">  NFA_ZOPEN5,</a>
<a name="ln150">  NFA_ZOPEN6,</a>
<a name="ln151">  NFA_ZOPEN7,</a>
<a name="ln152">  NFA_ZOPEN8,</a>
<a name="ln153">  NFA_ZOPEN9,</a>
<a name="ln154"> </a>
<a name="ln155">  NFA_ZCLOSE,</a>
<a name="ln156">  NFA_ZCLOSE1,</a>
<a name="ln157">  NFA_ZCLOSE2,</a>
<a name="ln158">  NFA_ZCLOSE3,</a>
<a name="ln159">  NFA_ZCLOSE4,</a>
<a name="ln160">  NFA_ZCLOSE5,</a>
<a name="ln161">  NFA_ZCLOSE6,</a>
<a name="ln162">  NFA_ZCLOSE7,</a>
<a name="ln163">  NFA_ZCLOSE8,</a>
<a name="ln164">  NFA_ZCLOSE9,</a>
<a name="ln165"> </a>
<a name="ln166">  /* NFA_FIRST_NL */</a>
<a name="ln167">  NFA_ANY,              /*	Match any one character. */</a>
<a name="ln168">  NFA_IDENT,            /*	Match identifier char */</a>
<a name="ln169">  NFA_SIDENT,           /*	Match identifier char but no digit */</a>
<a name="ln170">  NFA_KWORD,            /*	Match keyword char */</a>
<a name="ln171">  NFA_SKWORD,           /*	Match word char but no digit */</a>
<a name="ln172">  NFA_FNAME,            /*	Match file name char */</a>
<a name="ln173">  NFA_SFNAME,           /*	Match file name char but no digit */</a>
<a name="ln174">  NFA_PRINT,            /*	Match printable char */</a>
<a name="ln175">  NFA_SPRINT,           /*	Match printable char but no digit */</a>
<a name="ln176">  NFA_WHITE,            /*	Match whitespace char */</a>
<a name="ln177">  NFA_NWHITE,           /*	Match non-whitespace char */</a>
<a name="ln178">  NFA_DIGIT,            /*	Match digit char */</a>
<a name="ln179">  NFA_NDIGIT,           /*	Match non-digit char */</a>
<a name="ln180">  NFA_HEX,              /*	Match hex char */</a>
<a name="ln181">  NFA_NHEX,             /*	Match non-hex char */</a>
<a name="ln182">  NFA_OCTAL,            /*	Match octal char */</a>
<a name="ln183">  NFA_NOCTAL,           /*	Match non-octal char */</a>
<a name="ln184">  NFA_WORD,             /*	Match word char */</a>
<a name="ln185">  NFA_NWORD,            /*	Match non-word char */</a>
<a name="ln186">  NFA_HEAD,             /*	Match head char */</a>
<a name="ln187">  NFA_NHEAD,            /*	Match non-head char */</a>
<a name="ln188">  NFA_ALPHA,            /*	Match alpha char */</a>
<a name="ln189">  NFA_NALPHA,           /*	Match non-alpha char */</a>
<a name="ln190">  NFA_LOWER,            /*	Match lowercase char */</a>
<a name="ln191">  NFA_NLOWER,           /*	Match non-lowercase char */</a>
<a name="ln192">  NFA_UPPER,            /*	Match uppercase char */</a>
<a name="ln193">  NFA_NUPPER,           /*	Match non-uppercase char */</a>
<a name="ln194">  NFA_LOWER_IC,         /*	Match [a-z] */</a>
<a name="ln195">  NFA_NLOWER_IC,        /*	Match [^a-z] */</a>
<a name="ln196">  NFA_UPPER_IC,         /*	Match [A-Z] */</a>
<a name="ln197">  NFA_NUPPER_IC,        /*	Match [^A-Z] */</a>
<a name="ln198"> </a>
<a name="ln199">  NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,</a>
<a name="ln200">  NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,</a>
<a name="ln201"> </a>
<a name="ln202">  NFA_CURSOR,           /*	Match cursor pos */</a>
<a name="ln203">  NFA_LNUM,             /*	Match line number */</a>
<a name="ln204">  NFA_LNUM_GT,          /*	Match &gt; line number */</a>
<a name="ln205">  NFA_LNUM_LT,          /*	Match &lt; line number */</a>
<a name="ln206">  NFA_COL,              /*	Match cursor column */</a>
<a name="ln207">  NFA_COL_GT,           /*	Match &gt; cursor column */</a>
<a name="ln208">  NFA_COL_LT,           /*	Match &lt; cursor column */</a>
<a name="ln209">  NFA_VCOL,             /*	Match cursor virtual column */</a>
<a name="ln210">  NFA_VCOL_GT,          /*	Match &gt; cursor virtual column */</a>
<a name="ln211">  NFA_VCOL_LT,          /*	Match &lt; cursor virtual column */</a>
<a name="ln212">  NFA_MARK,             /*	Match mark */</a>
<a name="ln213">  NFA_MARK_GT,          /*	Match &gt; mark */</a>
<a name="ln214">  NFA_MARK_LT,          /*	Match &lt; mark */</a>
<a name="ln215">  NFA_VISUAL,           /*	Match Visual area */</a>
<a name="ln216"> </a>
<a name="ln217">  /* Character classes [:alnum:] etc */</a>
<a name="ln218">  NFA_CLASS_ALNUM,</a>
<a name="ln219">  NFA_CLASS_ALPHA,</a>
<a name="ln220">  NFA_CLASS_BLANK,</a>
<a name="ln221">  NFA_CLASS_CNTRL,</a>
<a name="ln222">  NFA_CLASS_DIGIT,</a>
<a name="ln223">  NFA_CLASS_GRAPH,</a>
<a name="ln224">  NFA_CLASS_LOWER,</a>
<a name="ln225">  NFA_CLASS_PRINT,</a>
<a name="ln226">  NFA_CLASS_PUNCT,</a>
<a name="ln227">  NFA_CLASS_SPACE,</a>
<a name="ln228">  NFA_CLASS_UPPER,</a>
<a name="ln229">  NFA_CLASS_XDIGIT,</a>
<a name="ln230">  NFA_CLASS_TAB,</a>
<a name="ln231">  NFA_CLASS_RETURN,</a>
<a name="ln232">  NFA_CLASS_BACKSPACE,</a>
<a name="ln233">  NFA_CLASS_ESCAPE,</a>
<a name="ln234">  NFA_CLASS_IDENT,</a>
<a name="ln235">  NFA_CLASS_KEYWORD,</a>
<a name="ln236">  NFA_CLASS_FNAME,</a>
<a name="ln237">};</a>
<a name="ln238"> </a>
<a name="ln239">/* Keep in sync with classchars. */</a>
<a name="ln240">static int nfa_classcodes[] = {</a>
<a name="ln241">  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,</a>
<a name="ln242">  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,</a>
<a name="ln243">  NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,</a>
<a name="ln244">  NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,</a>
<a name="ln245">  NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,</a>
<a name="ln246">  NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,</a>
<a name="ln247">  NFA_UPPER, NFA_NUPPER</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">static char_u e_nul_found[] = N_(</a>
<a name="ln251">    &quot;E865: (NFA) Regexp end encountered prematurely&quot;);</a>
<a name="ln252">static char_u e_misplaced[] = N_(&quot;E866: (NFA regexp) Misplaced %c&quot;);</a>
<a name="ln253">static char_u e_ill_char_class[] = N_(</a>
<a name="ln254">    &quot;E877: (NFA regexp) Invalid character class: %&quot; PRId64);</a>
<a name="ln255">static char_u e_value_too_large[] = N_(&quot;E951: \\% value too large&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">/* Since the out pointers in the list are always</a>
<a name="ln258"> * uninitialized, we use the pointers themselves</a>
<a name="ln259"> * as storage for the Ptrlists. */</a>
<a name="ln260">typedef union Ptrlist Ptrlist;</a>
<a name="ln261">union Ptrlist {</a>
<a name="ln262">  Ptrlist     *next;</a>
<a name="ln263">  nfa_state_T *s;</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">struct Frag {</a>
<a name="ln267">  nfa_state_T *start;</a>
<a name="ln268">  Ptrlist     *out;</a>
<a name="ln269">};</a>
<a name="ln270">typedef struct Frag Frag_T;</a>
<a name="ln271"> </a>
<a name="ln272">typedef struct {</a>
<a name="ln273">  int in_use;       ///&lt; number of subexpr with useful info</a>
<a name="ln274"> </a>
<a name="ln275">  // When REG_MULTI is true list.multi is used, otherwise list.line.</a>
<a name="ln276">  union {</a>
<a name="ln277">    struct multipos {</a>
<a name="ln278">      linenr_T  start_lnum;</a>
<a name="ln279">      linenr_T  end_lnum;</a>
<a name="ln280">      colnr_T start_col;</a>
<a name="ln281">      colnr_T end_col;</a>
<a name="ln282">    } multi[NSUBEXP];</a>
<a name="ln283">    struct linepos {</a>
<a name="ln284">      char_u      *start;</a>
<a name="ln285">      char_u      *end;</a>
<a name="ln286">    } line[NSUBEXP];</a>
<a name="ln287">  } list;</a>
<a name="ln288">} regsub_T;</a>
<a name="ln289"> </a>
<a name="ln290">typedef struct {</a>
<a name="ln291">  regsub_T norm;      /* \( .. \) matches */</a>
<a name="ln292">  regsub_T synt;      /* \z( .. \) matches */</a>
<a name="ln293">} regsubs_T;</a>
<a name="ln294"> </a>
<a name="ln295">/* nfa_pim_T stores a Postponed Invisible Match. */</a>
<a name="ln296">typedef struct nfa_pim_S nfa_pim_T;</a>
<a name="ln297">struct nfa_pim_S {</a>
<a name="ln298">  int result;                   /* NFA_PIM_*, see below */</a>
<a name="ln299">  nfa_state_T *state;           /* the invisible match start state */</a>
<a name="ln300">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln301">  union {</a>
<a name="ln302">    lpos_T pos;</a>
<a name="ln303">    char_u  *ptr;</a>
<a name="ln304">  } end;                        /* where the match must end */</a>
<a name="ln305">};</a>
<a name="ln306"> </a>
<a name="ln307">/* nfa_thread_T contains execution information of a NFA state */</a>
<a name="ln308">typedef struct {</a>
<a name="ln309">  nfa_state_T *state;</a>
<a name="ln310">  int count;</a>
<a name="ln311">  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed</a>
<a name="ln312">                                 * invisible match */</a>
<a name="ln313">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln314">} nfa_thread_T;</a>
<a name="ln315"> </a>
<a name="ln316">// nfa_list_T contains the alternative NFA execution states.</a>
<a name="ln317">typedef struct {</a>
<a name="ln318">  nfa_thread_T    *t;           ///&lt; allocated array of states</a>
<a name="ln319">  int n;                        ///&lt; nr of states currently in &quot;t&quot;</a>
<a name="ln320">  int len;                      ///&lt; max nr of states in &quot;t&quot;</a>
<a name="ln321">  int id;                       ///&lt; ID of the list</a>
<a name="ln322">  int has_pim;                  ///&lt; true when any state has a PIM</a>
<a name="ln323">} nfa_list_T;</a>
<a name="ln324"> </a>
<a name="ln325">// Variables only used in nfa_regcomp() and descendants.</a>
<a name="ln326">static int nfa_re_flags;  ///&lt; re_flags passed to nfa_regcomp().</a>
<a name="ln327">static int *post_start;   ///&lt; holds the postfix form of r.e.</a>
<a name="ln328">static int *post_end;</a>
<a name="ln329">static int *post_ptr;</a>
<a name="ln330"> </a>
<a name="ln331">static int nstate;  ///&lt; Number of states in the NFA. Also used when executing.</a>
<a name="ln332">static int istate;  ///&lt; Index in the state vector, used in alloc_state()</a>
<a name="ln333"> </a>
<a name="ln334">/* If not NULL match must end at this position */</a>
<a name="ln335">static save_se_T *nfa_endp = NULL;</a>
<a name="ln336"> </a>
<a name="ln337">/* 0 for first call to nfa_regmatch(), 1 for recursive call. */</a>
<a name="ln338">static int nfa_ll_index = 0;</a>
<a name="ln339"> </a>
<a name="ln340">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln341"># include &quot;regexp_nfa.c.generated.h&quot;</a>
<a name="ln342">#endif</a>
<a name="ln343"> </a>
<a name="ln344">// Helper functions used when doing re2post() ... regatom() parsing</a>
<a name="ln345">#define EMIT(c) \</a>
<a name="ln346">    do { \</a>
<a name="ln347">      if (post_ptr &gt;= post_end) { \</a>
<a name="ln348">        realloc_post_list(); \</a>
<a name="ln349">      } \</a>
<a name="ln350">      *post_ptr++ = c; \</a>
<a name="ln351">    } while (0)</a>
<a name="ln352"> </a>
<a name="ln353">/*</a>
<a name="ln354"> * Initialize internal variables before NFA compilation.</a>
<a name="ln355"> */</a>
<a name="ln356">static void</a>
<a name="ln357">nfa_regcomp_start (</a>
<a name="ln358">    char_u *expr,</a>
<a name="ln359">    int re_flags                       /* see vim_regcomp() */</a>
<a name="ln360">)</a>
<a name="ln361">{</a>
<a name="ln362">  size_t postfix_size;</a>
<a name="ln363">  size_t nstate_max;</a>
<a name="ln364"> </a>
<a name="ln365">  nstate = 0;</a>
<a name="ln366">  istate = 0;</a>
<a name="ln367">  /* A reasonable estimation for maximum size */</a>
<a name="ln368">  nstate_max = (STRLEN(expr) + 1) * 25;</a>
<a name="ln369"> </a>
<a name="ln370">  /* Some items blow up in size, such as [A-z].  Add more space for that.</a>
<a name="ln371">   * When it is still not enough realloc_post_list() will be used. */</a>
<a name="ln372">  nstate_max += 1000;</a>
<a name="ln373"> </a>
<a name="ln374">  /* Size for postfix representation of expr. */</a>
<a name="ln375">  postfix_size = sizeof(int) * nstate_max;</a>
<a name="ln376"> </a>
<a name="ln377">  post_start = (int *)xmalloc(postfix_size);</a>
<a name="ln378">  post_ptr = post_start;</a>
<a name="ln379">  post_end = post_start + nstate_max;</a>
<a name="ln380">  rex.nfa_has_zend = false;</a>
<a name="ln381">  rex.nfa_has_backref = false;</a>
<a name="ln382"> </a>
<a name="ln383">  /* shared with BT engine */</a>
<a name="ln384">  regcomp_start(expr, re_flags);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/*</a>
<a name="ln388"> * Figure out if the NFA state list starts with an anchor, must match at start</a>
<a name="ln389"> * of the line.</a>
<a name="ln390"> */</a>
<a name="ln391">static int nfa_get_reganch(nfa_state_T *start, int depth)</a>
<a name="ln392">{</a>
<a name="ln393">  nfa_state_T *p = start;</a>
<a name="ln394"> </a>
<a name="ln395">  if (depth &gt; 4)</a>
<a name="ln396">    return 0;</a>
<a name="ln397"> </a>
<a name="ln398">  while (p != NULL) {</a>
<a name="ln399">    switch (p-&gt;c) {</a>
<a name="ln400">    case NFA_BOL:</a>
<a name="ln401">    case NFA_BOF:</a>
<a name="ln402">      return 1;           /* yes! */</a>
<a name="ln403"> </a>
<a name="ln404">    case NFA_ZSTART:</a>
<a name="ln405">    case NFA_ZEND:</a>
<a name="ln406">    case NFA_CURSOR:</a>
<a name="ln407">    case NFA_VISUAL:</a>
<a name="ln408"> </a>
<a name="ln409">    case NFA_MOPEN:</a>
<a name="ln410">    case NFA_MOPEN1:</a>
<a name="ln411">    case NFA_MOPEN2:</a>
<a name="ln412">    case NFA_MOPEN3:</a>
<a name="ln413">    case NFA_MOPEN4:</a>
<a name="ln414">    case NFA_MOPEN5:</a>
<a name="ln415">    case NFA_MOPEN6:</a>
<a name="ln416">    case NFA_MOPEN7:</a>
<a name="ln417">    case NFA_MOPEN8:</a>
<a name="ln418">    case NFA_MOPEN9:</a>
<a name="ln419">    case NFA_NOPEN:</a>
<a name="ln420">    case NFA_ZOPEN:</a>
<a name="ln421">    case NFA_ZOPEN1:</a>
<a name="ln422">    case NFA_ZOPEN2:</a>
<a name="ln423">    case NFA_ZOPEN3:</a>
<a name="ln424">    case NFA_ZOPEN4:</a>
<a name="ln425">    case NFA_ZOPEN5:</a>
<a name="ln426">    case NFA_ZOPEN6:</a>
<a name="ln427">    case NFA_ZOPEN7:</a>
<a name="ln428">    case NFA_ZOPEN8:</a>
<a name="ln429">    case NFA_ZOPEN9:</a>
<a name="ln430">      p = p-&gt;out;</a>
<a name="ln431">      break;</a>
<a name="ln432"> </a>
<a name="ln433">    case NFA_SPLIT:</a>
<a name="ln434">      return nfa_get_reganch(p-&gt;out, depth + 1)</a>
<a name="ln435">             &amp;&amp; nfa_get_reganch(p-&gt;out1, depth + 1);</a>
<a name="ln436"> </a>
<a name="ln437">    default:</a>
<a name="ln438">      return 0;           /* noooo */</a>
<a name="ln439">    }</a>
<a name="ln440">  }</a>
<a name="ln441">  return 0;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/*</a>
<a name="ln445"> * Figure out if the NFA state list starts with a character which must match</a>
<a name="ln446"> * at start of the match.</a>
<a name="ln447"> */</a>
<a name="ln448">static int nfa_get_regstart(nfa_state_T *start, int depth)</a>
<a name="ln449">{</a>
<a name="ln450">  nfa_state_T *p = start;</a>
<a name="ln451"> </a>
<a name="ln452">  if (depth &gt; 4)</a>
<a name="ln453">    return 0;</a>
<a name="ln454"> </a>
<a name="ln455">  while (p != NULL) {</a>
<a name="ln456">    switch (p-&gt;c) {</a>
<a name="ln457">    /* all kinds of zero-width matches */</a>
<a name="ln458">    case NFA_BOL:</a>
<a name="ln459">    case NFA_BOF:</a>
<a name="ln460">    case NFA_BOW:</a>
<a name="ln461">    case NFA_EOW:</a>
<a name="ln462">    case NFA_ZSTART:</a>
<a name="ln463">    case NFA_ZEND:</a>
<a name="ln464">    case NFA_CURSOR:</a>
<a name="ln465">    case NFA_VISUAL:</a>
<a name="ln466">    case NFA_LNUM:</a>
<a name="ln467">    case NFA_LNUM_GT:</a>
<a name="ln468">    case NFA_LNUM_LT:</a>
<a name="ln469">    case NFA_COL:</a>
<a name="ln470">    case NFA_COL_GT:</a>
<a name="ln471">    case NFA_COL_LT:</a>
<a name="ln472">    case NFA_VCOL:</a>
<a name="ln473">    case NFA_VCOL_GT:</a>
<a name="ln474">    case NFA_VCOL_LT:</a>
<a name="ln475">    case NFA_MARK:</a>
<a name="ln476">    case NFA_MARK_GT:</a>
<a name="ln477">    case NFA_MARK_LT:</a>
<a name="ln478"> </a>
<a name="ln479">    case NFA_MOPEN:</a>
<a name="ln480">    case NFA_MOPEN1:</a>
<a name="ln481">    case NFA_MOPEN2:</a>
<a name="ln482">    case NFA_MOPEN3:</a>
<a name="ln483">    case NFA_MOPEN4:</a>
<a name="ln484">    case NFA_MOPEN5:</a>
<a name="ln485">    case NFA_MOPEN6:</a>
<a name="ln486">    case NFA_MOPEN7:</a>
<a name="ln487">    case NFA_MOPEN8:</a>
<a name="ln488">    case NFA_MOPEN9:</a>
<a name="ln489">    case NFA_NOPEN:</a>
<a name="ln490">    case NFA_ZOPEN:</a>
<a name="ln491">    case NFA_ZOPEN1:</a>
<a name="ln492">    case NFA_ZOPEN2:</a>
<a name="ln493">    case NFA_ZOPEN3:</a>
<a name="ln494">    case NFA_ZOPEN4:</a>
<a name="ln495">    case NFA_ZOPEN5:</a>
<a name="ln496">    case NFA_ZOPEN6:</a>
<a name="ln497">    case NFA_ZOPEN7:</a>
<a name="ln498">    case NFA_ZOPEN8:</a>
<a name="ln499">    case NFA_ZOPEN9:</a>
<a name="ln500">      p = p-&gt;out;</a>
<a name="ln501">      break;</a>
<a name="ln502"> </a>
<a name="ln503">    case NFA_SPLIT:</a>
<a name="ln504">    {</a>
<a name="ln505">      int c1 = nfa_get_regstart(p-&gt;out, depth + 1);</a>
<a name="ln506">      int c2 = nfa_get_regstart(p-&gt;out1, depth + 1);</a>
<a name="ln507"> </a>
<a name="ln508">      if (c1 == c2)</a>
<a name="ln509">        return c1;             /* yes! */</a>
<a name="ln510">      return 0;</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    default:</a>
<a name="ln514">      if (p-&gt;c &gt; 0)</a>
<a name="ln515">        return p-&gt;c;             /* yes! */</a>
<a name="ln516">      return 0;</a>
<a name="ln517">    }</a>
<a name="ln518">  }</a>
<a name="ln519">  return 0;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">/*</a>
<a name="ln523"> * Figure out if the NFA state list contains just literal text and nothing</a>
<a name="ln524"> * else.  If so return a string in allocated memory with what must match after</a>
<a name="ln525"> * regstart.  Otherwise return NULL.</a>
<a name="ln526"> */</a>
<a name="ln527">static char_u *nfa_get_match_text(nfa_state_T *start)</a>
<a name="ln528">{</a>
<a name="ln529">  nfa_state_T *p = start;</a>
<a name="ln530">  int len = 0;</a>
<a name="ln531">  char_u      *ret;</a>
<a name="ln532">  char_u      *s;</a>
<a name="ln533"> </a>
<a name="ln534">  if (p-&gt;c != NFA_MOPEN)</a>
<a name="ln535">    return NULL;     /* just in case */</a>
<a name="ln536">  p = p-&gt;out;</a>
<a name="ln537">  while (p-&gt;c &gt; 0) {</a>
<a name="ln538">    len += MB_CHAR2LEN(p-&gt;c);</a>
<a name="ln539">    p = p-&gt;out;</a>
<a name="ln540">  }</a>
<a name="ln541">  if (p-&gt;c != NFA_MCLOSE || p-&gt;out-&gt;c != NFA_MATCH)</a>
<a name="ln542">    return NULL;</a>
<a name="ln543"> </a>
<a name="ln544">  ret = xmalloc(len);</a>
<a name="ln545">  p = start-&gt;out-&gt;out;     /* skip first char, it goes into regstart */</a>
<a name="ln546">  s = ret;</a>
<a name="ln547">  while (p-&gt;c &gt; 0) {</a>
<a name="ln548">    s += utf_char2bytes(p-&gt;c, s);</a>
<a name="ln549">    p = p-&gt;out;</a>
<a name="ln550">  }</a>
<a name="ln551">  *s = NUL;</a>
<a name="ln552"> </a>
<a name="ln553">  return ret;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/*</a>
<a name="ln557"> * Allocate more space for post_start.  Called when</a>
<a name="ln558"> * running above the estimated number of states.</a>
<a name="ln559"> */</a>
<a name="ln560">static void realloc_post_list(void)</a>
<a name="ln561">{</a>
<a name="ln562">  size_t new_max = (post_end - post_start) + 1000;</a>
<a name="ln563">  int *new_start = xrealloc(post_start, new_max * sizeof(int));</a>
<a name="ln564">  post_ptr = new_start + (post_ptr - post_start);</a>
<a name="ln565">  post_end = new_start + new_max;</a>
<a name="ln566">  post_start = new_start;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">/*</a>
<a name="ln570"> * Search between &quot;start&quot; and &quot;end&quot; and try to recognize a</a>
<a name="ln571"> * character class in expanded form. For example [0-9].</a>
<a name="ln572"> * On success, return the id the character class to be emitted.</a>
<a name="ln573"> * On failure, return 0 (=FAIL)</a>
<a name="ln574"> * Start points to the first char of the range, while end should point</a>
<a name="ln575"> * to the closing brace.</a>
<a name="ln576"> * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may</a>
<a name="ln577"> * need to be interpreted as [a-zA-Z].</a>
<a name="ln578"> */</a>
<a name="ln579">static int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)</a>
<a name="ln580">{</a>
<a name="ln581">#   define CLASS_not            0x80</a>
<a name="ln582">#   define CLASS_af             0x40</a>
<a name="ln583">#   define CLASS_AF             0x20</a>
<a name="ln584">#   define CLASS_az             0x10</a>
<a name="ln585">#   define CLASS_AZ             0x08</a>
<a name="ln586">#   define CLASS_o7             0x04</a>
<a name="ln587">#   define CLASS_o9             0x02</a>
<a name="ln588">#   define CLASS_underscore     0x01</a>
<a name="ln589"> </a>
<a name="ln590">  char_u      *p;</a>
<a name="ln591">  int config = 0;</a>
<a name="ln592"> </a>
<a name="ln593">  bool newl = extra_newl == true;</a>
<a name="ln594"> </a>
<a name="ln595">  if (*end != ']')</a>
<a name="ln596">    return FAIL;</a>
<a name="ln597">  p = start;</a>
<a name="ln598">  if (*p == '^') {</a>
<a name="ln599">    config |= CLASS_not;</a>
<a name="ln600">    p++;</a>
<a name="ln601">  }</a>
<a name="ln602"> </a>
<a name="ln603">  while (p &lt; end) {</a>
<a name="ln604">    if (p + 2 &lt; end &amp;&amp; *(p + 1) == '-') {</a>
<a name="ln605">      switch (*p) {</a>
<a name="ln606">      case '0':</a>
<a name="ln607">        if (*(p + 2) == '9') {</a>
<a name="ln608">          config |= CLASS_o9;</a>
<a name="ln609">          break;</a>
<a name="ln610">        } else if (*(p + 2) == '7') {</a>
<a name="ln611">          config |= CLASS_o7;</a>
<a name="ln612">          break;</a>
<a name="ln613">        }</a>
<a name="ln614">        return FAIL;</a>
<a name="ln615">      case 'a':</a>
<a name="ln616">        if (*(p + 2) == 'z') {</a>
<a name="ln617">          config |= CLASS_az;</a>
<a name="ln618">          break;</a>
<a name="ln619">        } else if (*(p + 2) == 'f') {</a>
<a name="ln620">          config |= CLASS_af;</a>
<a name="ln621">          break;</a>
<a name="ln622">        }</a>
<a name="ln623">        return FAIL;</a>
<a name="ln624">      case 'A':</a>
<a name="ln625">        if (*(p + 2) == 'Z') {</a>
<a name="ln626">          config |= CLASS_AZ;</a>
<a name="ln627">          break;</a>
<a name="ln628">        } else if (*(p + 2) == 'F') {</a>
<a name="ln629">          config |= CLASS_AF;</a>
<a name="ln630">          break;</a>
<a name="ln631">        }</a>
<a name="ln632">        return FAIL;</a>
<a name="ln633">      default:</a>
<a name="ln634">        return FAIL;</a>
<a name="ln635">      }</a>
<a name="ln636">      p += 3;</a>
<a name="ln637">    } else if (p + 1 &lt; end &amp;&amp; *p == '\\' &amp;&amp; *(p + 1) == 'n') {</a>
<a name="ln638">      newl = true;</a>
<a name="ln639">      p += 2;</a>
<a name="ln640">    } else if (*p == '_') {</a>
<a name="ln641">      config |= CLASS_underscore;</a>
<a name="ln642">      p++;</a>
<a name="ln643">    } else if (*p == '\n') {</a>
<a name="ln644">      newl = true;</a>
<a name="ln645">      p++;</a>
<a name="ln646">    } else</a>
<a name="ln647">      return FAIL;</a>
<a name="ln648">  }   /* while (p &lt; end) */</a>
<a name="ln649"> </a>
<a name="ln650">  if (p != end)</a>
<a name="ln651">    return FAIL;</a>
<a name="ln652"> </a>
<a name="ln653">  if (newl == true) {</a>
<a name="ln654">    extra_newl = NFA_ADD_NL;</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  switch (config) {</a>
<a name="ln658">  case CLASS_o9:</a>
<a name="ln659">    return extra_newl + NFA_DIGIT;</a>
<a name="ln660">  case CLASS_not |  CLASS_o9:</a>
<a name="ln661">    return extra_newl + NFA_NDIGIT;</a>
<a name="ln662">  case CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln663">    return extra_newl + NFA_HEX;</a>
<a name="ln664">  case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln665">    return extra_newl + NFA_NHEX;</a>
<a name="ln666">  case CLASS_o7:</a>
<a name="ln667">    return extra_newl + NFA_OCTAL;</a>
<a name="ln668">  case CLASS_not | CLASS_o7:</a>
<a name="ln669">    return extra_newl + NFA_NOCTAL;</a>
<a name="ln670">  case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln671">    return extra_newl + NFA_WORD;</a>
<a name="ln672">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln673">    return extra_newl + NFA_NWORD;</a>
<a name="ln674">  case CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln675">    return extra_newl + NFA_HEAD;</a>
<a name="ln676">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln677">    return extra_newl + NFA_NHEAD;</a>
<a name="ln678">  case CLASS_az | CLASS_AZ:</a>
<a name="ln679">    return extra_newl + NFA_ALPHA;</a>
<a name="ln680">  case CLASS_not | CLASS_az | CLASS_AZ:</a>
<a name="ln681">    return extra_newl + NFA_NALPHA;</a>
<a name="ln682">  case CLASS_az:</a>
<a name="ln683">    return extra_newl + NFA_LOWER_IC;</a>
<a name="ln684">  case CLASS_not | CLASS_az:</a>
<a name="ln685">    return extra_newl + NFA_NLOWER_IC;</a>
<a name="ln686">  case CLASS_AZ:</a>
<a name="ln687">    return extra_newl + NFA_UPPER_IC;</a>
<a name="ln688">  case CLASS_not | CLASS_AZ:</a>
<a name="ln689">    return extra_newl + NFA_NUPPER_IC;</a>
<a name="ln690">  }</a>
<a name="ln691">  return FAIL;</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">/*</a>
<a name="ln695"> * Produce the bytes for equivalence class &quot;c&quot;.</a>
<a name="ln696"> * Currently only handles latin1, latin9 and utf-8.</a>
<a name="ln697"> * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is</a>
<a name="ln698"> * equivalent to 'a OR b OR c'</a>
<a name="ln699"> *</a>
<a name="ln700"> * NOTE! When changing this function, also update reg_equi_class()</a>
<a name="ln701"> */</a>
<a name="ln702">static void nfa_emit_equi_class(int c)</a>
<a name="ln703">{</a>
<a name="ln704">#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln705">#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln706"> </a>
<a name="ln707">  {</a>
<a name="ln708">#define A_grave 0xc0</a>
<a name="ln709">#define A_acute 0xc1</a>
<a name="ln710">#define A_circumflex 0xc2</a>
<a name="ln711">#define A_virguilla 0xc3</a>
<a name="ln712">#define A_diaeresis 0xc4</a>
<a name="ln713">#define A_ring 0xc5</a>
<a name="ln714">#define C_cedilla 0xc7</a>
<a name="ln715">#define E_grave 0xc8</a>
<a name="ln716">#define E_acute 0xc9</a>
<a name="ln717">#define E_circumflex 0xca</a>
<a name="ln718">#define E_diaeresis 0xcb</a>
<a name="ln719">#define I_grave 0xcc</a>
<a name="ln720">#define I_acute 0xcd</a>
<a name="ln721">#define I_circumflex 0xce</a>
<a name="ln722">#define I_diaeresis 0xcf</a>
<a name="ln723">#define N_virguilla 0xd1</a>
<a name="ln724">#define O_grave 0xd2</a>
<a name="ln725">#define O_acute 0xd3</a>
<a name="ln726">#define O_circumflex 0xd4</a>
<a name="ln727">#define O_virguilla 0xd5</a>
<a name="ln728">#define O_diaeresis 0xd6</a>
<a name="ln729">#define O_slash 0xd8</a>
<a name="ln730">#define U_grave 0xd9</a>
<a name="ln731">#define U_acute 0xda</a>
<a name="ln732">#define U_circumflex 0xdb</a>
<a name="ln733">#define U_diaeresis 0xdc</a>
<a name="ln734">#define Y_acute 0xdd</a>
<a name="ln735">#define a_grave 0xe0</a>
<a name="ln736">#define a_acute 0xe1</a>
<a name="ln737">#define a_circumflex 0xe2</a>
<a name="ln738">#define a_virguilla 0xe3</a>
<a name="ln739">#define a_diaeresis 0xe4</a>
<a name="ln740">#define a_ring 0xe5</a>
<a name="ln741">#define c_cedilla 0xe7</a>
<a name="ln742">#define e_grave 0xe8</a>
<a name="ln743">#define e_acute 0xe9</a>
<a name="ln744">#define e_circumflex 0xea</a>
<a name="ln745">#define e_diaeresis 0xeb</a>
<a name="ln746">#define i_grave 0xec</a>
<a name="ln747">#define i_acute 0xed</a>
<a name="ln748">#define i_circumflex 0xee</a>
<a name="ln749">#define i_diaeresis 0xef</a>
<a name="ln750">#define n_virguilla 0xf1</a>
<a name="ln751">#define o_grave 0xf2</a>
<a name="ln752">#define o_acute 0xf3</a>
<a name="ln753">#define o_circumflex 0xf4</a>
<a name="ln754">#define o_virguilla 0xf5</a>
<a name="ln755">#define o_diaeresis 0xf6</a>
<a name="ln756">#define o_slash 0xf8</a>
<a name="ln757">#define u_grave 0xf9</a>
<a name="ln758">#define u_acute 0xfa</a>
<a name="ln759">#define u_circumflex 0xfb</a>
<a name="ln760">#define u_diaeresis 0xfc</a>
<a name="ln761">#define y_acute 0xfd</a>
<a name="ln762">#define y_diaeresis 0xff</a>
<a name="ln763">    switch (c) {</a>
<a name="ln764">    case 'A': case A_grave: case A_acute: case A_circumflex:</a>
<a name="ln765">              case A_virguilla: case A_diaeresis: case A_ring:</a>
<a name="ln766">              CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104)</a>
<a name="ln767">              CASEMBC(0x1cd) CASEMBC(0x1de) CASEMBC(0x1e0)</a>
<a name="ln768">              CASEMBC(0x1ea2)</a>
<a name="ln769">      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);</a>
<a name="ln770">      EMIT2(A_circumflex); EMIT2(A_virguilla);</a>
<a name="ln771">      EMIT2(A_diaeresis); EMIT2(A_ring);</a>
<a name="ln772">      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)</a>
<a name="ln773">      EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)</a>
<a name="ln774">      EMITMBC(0x1ea2)</a>
<a name="ln775">      return;</a>
<a name="ln776"> </a>
<a name="ln777">    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)</a>
<a name="ln778">      EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)</a>
<a name="ln779">      return;</a>
<a name="ln780"> </a>
<a name="ln781">    case 'C': case C_cedilla: CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a)</a>
<a name="ln782">              CASEMBC(0x10c)</a>
<a name="ln783">      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)</a>
<a name="ln784">      EMITMBC(0x10a) EMITMBC(0x10c)</a>
<a name="ln785">      return;</a>
<a name="ln786"> </a>
<a name="ln787">    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)</a>
<a name="ln788">              CASEMBC(0x1e0e) CASEMBC(0x1e10)</a>
<a name="ln789">      EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)</a>
<a name="ln790">      EMITMBC(0x1e0e) EMITMBC(0x1e10)</a>
<a name="ln791">      return;</a>
<a name="ln792"> </a>
<a name="ln793">    case 'E': case E_grave: case E_acute: case E_circumflex:</a>
<a name="ln794">              case E_diaeresis: CASEMBC(0x112) CASEMBC(0x114)</a>
<a name="ln795">              CASEMBC(0x116) CASEMBC(0x118) CASEMBC(0x11a)</a>
<a name="ln796">              CASEMBC(0x1eba) CASEMBC(0x1ebc)</a>
<a name="ln797">      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);</a>
<a name="ln798">      EMIT2(E_circumflex); EMIT2(E_diaeresis);</a>
<a name="ln799">      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)</a>
<a name="ln800">      EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)</a>
<a name="ln801">      EMITMBC(0x1ebc)</a>
<a name="ln802">      return;</a>
<a name="ln803"> </a>
<a name="ln804">    case 'F': CASEMBC(0x1e1e)</a>
<a name="ln805">      EMIT2('F'); EMITMBC(0x1e1e)</a>
<a name="ln806">      return;</a>
<a name="ln807"> </a>
<a name="ln808">    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)</a>
<a name="ln809">              CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6)</a>
<a name="ln810">              CASEMBC(0x1f4) CASEMBC(0x1e20)</a>
<a name="ln811">      EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)</a>
<a name="ln812">      EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)</a>
<a name="ln813">      EMITMBC(0x1f4) EMITMBC(0x1e20)</a>
<a name="ln814">      return;</a>
<a name="ln815"> </a>
<a name="ln816">    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)</a>
<a name="ln817">              CASEMBC(0x1e26) CASEMBC(0x1e28)</a>
<a name="ln818">      EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)</a>
<a name="ln819">      EMITMBC(0x1e26) EMITMBC(0x1e28)</a>
<a name="ln820">      return;</a>
<a name="ln821"> </a>
<a name="ln822">    case 'I': case I_grave: case I_acute: case I_circumflex:</a>
<a name="ln823">              case I_diaeresis: CASEMBC(0x128) CASEMBC(0x12a)</a>
<a name="ln824">              CASEMBC(0x12c) CASEMBC(0x12e) CASEMBC(0x130)</a>
<a name="ln825">              CASEMBC(0x1cf) CASEMBC(0x1ec8)</a>
<a name="ln826">      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);</a>
<a name="ln827">      EMIT2(I_circumflex); EMIT2(I_diaeresis);</a>
<a name="ln828">      EMITMBC(0x128) EMITMBC(0x12a)</a>
<a name="ln829">      EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)</a>
<a name="ln830">      EMITMBC(0x1cf) EMITMBC(0x1ec8)</a>
<a name="ln831">      return;</a>
<a name="ln832"> </a>
<a name="ln833">    case 'J': CASEMBC(0x134)</a>
<a name="ln834">      EMIT2('J'); EMITMBC(0x134)</a>
<a name="ln835">      return;</a>
<a name="ln836"> </a>
<a name="ln837">    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)</a>
<a name="ln838">              CASEMBC(0x1e34)</a>
<a name="ln839">      EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)</a>
<a name="ln840">      EMITMBC(0x1e34)</a>
<a name="ln841">      return;</a>
<a name="ln842"> </a>
<a name="ln843">    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)</a>
<a name="ln844">              CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)</a>
<a name="ln845">      EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)</a>
<a name="ln846">      EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)</a>
<a name="ln847">      return;</a>
<a name="ln848"> </a>
<a name="ln849">    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)</a>
<a name="ln850">      EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)</a>
<a name="ln851">      return;</a>
<a name="ln852"> </a>
<a name="ln853">    case 'N': case N_virguilla: CASEMBC(0x143) CASEMBC(0x145)</a>
<a name="ln854">              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)</a>
<a name="ln855">      EMIT2('N'); EMIT2(N_virguilla);</a>
<a name="ln856">      EMITMBC(0x143) EMITMBC(0x145)</a>
<a name="ln857">      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)</a>
<a name="ln858">      return;</a>
<a name="ln859"> </a>
<a name="ln860">    case 'O': case O_grave: case O_acute: case O_circumflex:</a>
<a name="ln861">              case O_virguilla: case O_diaeresis: case O_slash:</a>
<a name="ln862">              CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150)</a>
<a name="ln863">              CASEMBC(0x1a0) CASEMBC(0x1d1) CASEMBC(0x1ea)</a>
<a name="ln864">              CASEMBC(0x1ec) CASEMBC(0x1ece)</a>
<a name="ln865">      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);</a>
<a name="ln866">      EMIT2(O_circumflex); EMIT2(O_virguilla);</a>
<a name="ln867">      EMIT2(O_diaeresis); EMIT2(O_slash);</a>
<a name="ln868">      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)</a>
<a name="ln869">      EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)</a>
<a name="ln870">      EMITMBC(0x1ec) EMITMBC(0x1ece)</a>
<a name="ln871">      return;</a>
<a name="ln872"> </a>
<a name="ln873">    case 'P': case 0x1e54: case 0x1e56:</a>
<a name="ln874">      EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)</a>
<a name="ln875">      return;</a>
<a name="ln876"> </a>
<a name="ln877">    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)</a>
<a name="ln878">              CASEMBC(0x1e58) CASEMBC(0x1e5e)</a>
<a name="ln879">      EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)</a>
<a name="ln880">      EMITMBC(0x1e58) EMITMBC(0x1e5e)</a>
<a name="ln881">      return;</a>
<a name="ln882"> </a>
<a name="ln883">    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)</a>
<a name="ln884">              CASEMBC(0x160) CASEMBC(0x1e60)</a>
<a name="ln885">      EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)</a>
<a name="ln886">      EMITMBC(0x160) EMITMBC(0x1e60)</a>
<a name="ln887">      return;</a>
<a name="ln888"> </a>
<a name="ln889">    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)</a>
<a name="ln890">              CASEMBC(0x1e6a) CASEMBC(0x1e6e)</a>
<a name="ln891">      EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)</a>
<a name="ln892">      EMITMBC(0x1e6a) EMITMBC(0x1e6e)</a>
<a name="ln893">      return;</a>
<a name="ln894"> </a>
<a name="ln895">    case 'U': case U_grave: case U_acute: case U_diaeresis:</a>
<a name="ln896">              case U_circumflex: CASEMBC(0x168) CASEMBC(0x16a)</a>
<a name="ln897">              CASEMBC(0x16c) CASEMBC(0x16e) CASEMBC(0x170)</a>
<a name="ln898">              CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)</a>
<a name="ln899">              CASEMBC(0x1ee6)</a>
<a name="ln900">      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);</a>
<a name="ln901">      EMIT2(U_diaeresis); EMIT2(U_circumflex);</a>
<a name="ln902">      EMITMBC(0x168) EMITMBC(0x16a)</a>
<a name="ln903">      EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)</a>
<a name="ln904">      EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)</a>
<a name="ln905">      EMITMBC(0x1ee6)</a>
<a name="ln906">      return;</a>
<a name="ln907"> </a>
<a name="ln908">    case 'V': CASEMBC(0x1e7c)</a>
<a name="ln909">      EMIT2('V'); EMITMBC(0x1e7c)</a>
<a name="ln910">      return;</a>
<a name="ln911"> </a>
<a name="ln912">    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)</a>
<a name="ln913">              CASEMBC(0x1e84) CASEMBC(0x1e86)</a>
<a name="ln914">      EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)</a>
<a name="ln915">      EMITMBC(0x1e84) EMITMBC(0x1e86)</a>
<a name="ln916">      return;</a>
<a name="ln917"> </a>
<a name="ln918">    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)</a>
<a name="ln919">      EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)</a>
<a name="ln920">      return;</a>
<a name="ln921"> </a>
<a name="ln922">    case 'Y': case Y_acute: CASEMBC(0x176) CASEMBC(0x178)</a>
<a name="ln923">              CASEMBC(0x1e8e) CASEMBC(0x1ef2) CASEMBC(0x1ef6)</a>
<a name="ln924">              CASEMBC(0x1ef8)</a>
<a name="ln925">      EMIT2('Y'); EMIT2(Y_acute);</a>
<a name="ln926">      EMITMBC(0x176) EMITMBC(0x178)</a>
<a name="ln927">      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)</a>
<a name="ln928">      EMITMBC(0x1ef8)</a>
<a name="ln929">      return;</a>
<a name="ln930"> </a>
<a name="ln931">    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)</a>
<a name="ln932">              CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)</a>
<a name="ln933">      EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)</a>
<a name="ln934">      EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)</a>
<a name="ln935">      return;</a>
<a name="ln936"> </a>
<a name="ln937">    case 'a': case a_grave: case a_acute: case a_circumflex:</a>
<a name="ln938">              case a_virguilla: case a_diaeresis: case a_ring:</a>
<a name="ln939">              CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105)</a>
<a name="ln940">              CASEMBC(0x1ce) CASEMBC(0x1df) CASEMBC(0x1e1)</a>
<a name="ln941">              CASEMBC(0x1ea3)</a>
<a name="ln942">      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);</a>
<a name="ln943">      EMIT2(a_circumflex); EMIT2(a_virguilla);</a>
<a name="ln944">      EMIT2(a_diaeresis); EMIT2(a_ring);</a>
<a name="ln945">      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)</a>
<a name="ln946">      EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)</a>
<a name="ln947">      EMITMBC(0x1ea3)</a>
<a name="ln948">      return;</a>
<a name="ln949"> </a>
<a name="ln950">    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)</a>
<a name="ln951">      EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)</a>
<a name="ln952">      return;</a>
<a name="ln953"> </a>
<a name="ln954">    case 'c': case c_cedilla: CASEMBC(0x107) CASEMBC(0x109)</a>
<a name="ln955">              CASEMBC(0x10b) CASEMBC(0x10d)</a>
<a name="ln956">      EMIT2('c'); EMIT2(c_cedilla);</a>
<a name="ln957">      EMITMBC(0x107) EMITMBC(0x109)</a>
<a name="ln958">      EMITMBC(0x10b) EMITMBC(0x10d)</a>
<a name="ln959">      return;</a>
<a name="ln960"> </a>
<a name="ln961">    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)</a>
<a name="ln962">              CASEMBC(0x1e0f) CASEMBC(0x1e11)</a>
<a name="ln963">      EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)</a>
<a name="ln964">      EMITMBC(0x1e0f) EMITMBC(0x1e11)</a>
<a name="ln965">      return;</a>
<a name="ln966"> </a>
<a name="ln967">    case 'e': case e_grave: case e_acute: case e_circumflex:</a>
<a name="ln968">              case e_diaeresis: CASEMBC(0x113) CASEMBC(0x115)</a>
<a name="ln969">              CASEMBC(0x117) CASEMBC(0x119) CASEMBC(0x11b)</a>
<a name="ln970">              CASEMBC(0x1ebb) CASEMBC(0x1ebd)</a>
<a name="ln971">      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);</a>
<a name="ln972">      EMIT2(e_circumflex); EMIT2(e_diaeresis);</a>
<a name="ln973">      EMITMBC(0x113) EMITMBC(0x115)</a>
<a name="ln974">      EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)</a>
<a name="ln975">      EMITMBC(0x1ebb) EMITMBC(0x1ebd)</a>
<a name="ln976">      return;</a>
<a name="ln977"> </a>
<a name="ln978">    case 'f': CASEMBC(0x1e1f)</a>
<a name="ln979">      EMIT2('f'); EMITMBC(0x1e1f)</a>
<a name="ln980">      return;</a>
<a name="ln981"> </a>
<a name="ln982">    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)</a>
<a name="ln983">              CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7)</a>
<a name="ln984">              CASEMBC(0x1f5) CASEMBC(0x1e21)</a>
<a name="ln985">      EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)</a>
<a name="ln986">      EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)</a>
<a name="ln987">      EMITMBC(0x1f5) EMITMBC(0x1e21)</a>
<a name="ln988">      return;</a>
<a name="ln989"> </a>
<a name="ln990">    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)</a>
<a name="ln991">              CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)</a>
<a name="ln992">      EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)</a>
<a name="ln993">      EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)</a>
<a name="ln994">      return;</a>
<a name="ln995"> </a>
<a name="ln996">    case 'i': case i_grave: case i_acute: case i_circumflex:</a>
<a name="ln997">              case i_diaeresis: CASEMBC(0x129) CASEMBC(0x12b)</a>
<a name="ln998">              CASEMBC(0x12d) CASEMBC(0x12f) CASEMBC(0x1d0)</a>
<a name="ln999">              CASEMBC(0x1ec9)</a>
<a name="ln1000">      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);</a>
<a name="ln1001">      EMIT2(i_circumflex); EMIT2(i_diaeresis);</a>
<a name="ln1002">      EMITMBC(0x129) EMITMBC(0x12b)</a>
<a name="ln1003">      EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)</a>
<a name="ln1004">      EMITMBC(0x1ec9)</a>
<a name="ln1005">      return;</a>
<a name="ln1006"> </a>
<a name="ln1007">    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)</a>
<a name="ln1008">      EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)</a>
<a name="ln1009">      return;</a>
<a name="ln1010"> </a>
<a name="ln1011">    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)</a>
<a name="ln1012">              CASEMBC(0x1e35)</a>
<a name="ln1013">      EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)</a>
<a name="ln1014">      EMITMBC(0x1e35)</a>
<a name="ln1015">      return;</a>
<a name="ln1016"> </a>
<a name="ln1017">    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)</a>
<a name="ln1018">              CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)</a>
<a name="ln1019">      EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)</a>
<a name="ln1020">      EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)</a>
<a name="ln1021">      return;</a>
<a name="ln1022"> </a>
<a name="ln1023">    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)</a>
<a name="ln1024">      EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)</a>
<a name="ln1025">      return;</a>
<a name="ln1026"> </a>
<a name="ln1027">    case 'n': case n_virguilla: CASEMBC(0x144) CASEMBC(0x146)</a>
<a name="ln1028">              CASEMBC(0x148) CASEMBC(0x149) CASEMBC(0x1e45)</a>
<a name="ln1029">              CASEMBC(0x1e49)</a>
<a name="ln1030">      EMIT2('n'); EMIT2(n_virguilla);</a>
<a name="ln1031">      EMITMBC(0x144) EMITMBC(0x146)</a>
<a name="ln1032">      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)</a>
<a name="ln1033">      EMITMBC(0x1e49)</a>
<a name="ln1034">      return;</a>
<a name="ln1035"> </a>
<a name="ln1036">    case 'o': case o_grave: case o_acute: case o_circumflex:</a>
<a name="ln1037">              case o_virguilla: case o_diaeresis: case o_slash:</a>
<a name="ln1038">              CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151)</a>
<a name="ln1039">              CASEMBC(0x1a1) CASEMBC(0x1d2) CASEMBC(0x1eb)</a>
<a name="ln1040">              CASEMBC(0x1ed) CASEMBC(0x1ecf)</a>
<a name="ln1041">      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);</a>
<a name="ln1042">      EMIT2(o_circumflex); EMIT2(o_virguilla);</a>
<a name="ln1043">      EMIT2(o_diaeresis); EMIT2(o_slash);</a>
<a name="ln1044">      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)</a>
<a name="ln1045">      EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)</a>
<a name="ln1046">      EMITMBC(0x1ed) EMITMBC(0x1ecf)</a>
<a name="ln1047">      return;</a>
<a name="ln1048"> </a>
<a name="ln1049">    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)</a>
<a name="ln1050">      EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)</a>
<a name="ln1051">      return;</a>
<a name="ln1052"> </a>
<a name="ln1053">    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)</a>
<a name="ln1054">              CASEMBC(0x1e59) CASEMBC(0x1e5f)</a>
<a name="ln1055">      EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)</a>
<a name="ln1056">      EMITMBC(0x1e59) EMITMBC(0x1e5f)</a>
<a name="ln1057">      return;</a>
<a name="ln1058"> </a>
<a name="ln1059">    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)</a>
<a name="ln1060">              CASEMBC(0x161) CASEMBC(0x1e61)</a>
<a name="ln1061">      EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)</a>
<a name="ln1062">      EMITMBC(0x161) EMITMBC(0x1e61)</a>
<a name="ln1063">      return;</a>
<a name="ln1064"> </a>
<a name="ln1065">    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)</a>
<a name="ln1066">              CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)</a>
<a name="ln1067">      EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)</a>
<a name="ln1068">      EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)</a>
<a name="ln1069">      return;</a>
<a name="ln1070"> </a>
<a name="ln1071">    case 'u': case u_grave: case u_acute: case u_circumflex:</a>
<a name="ln1072">              case u_diaeresis: CASEMBC(0x169) CASEMBC(0x16b)</a>
<a name="ln1073">              CASEMBC(0x16d) CASEMBC(0x16f) CASEMBC(0x171)</a>
<a name="ln1074">              CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)</a>
<a name="ln1075">              CASEMBC(0x1ee7)</a>
<a name="ln1076">      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);</a>
<a name="ln1077">      EMIT2(u_circumflex); EMIT2(u_diaeresis);</a>
<a name="ln1078">      EMITMBC(0x169) EMITMBC(0x16b)</a>
<a name="ln1079">      EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)</a>
<a name="ln1080">      EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)</a>
<a name="ln1081">      EMITMBC(0x1ee7)</a>
<a name="ln1082">      return;</a>
<a name="ln1083"> </a>
<a name="ln1084">    case 'v': CASEMBC(0x1e7d)</a>
<a name="ln1085">      EMIT2('v'); EMITMBC(0x1e7d)</a>
<a name="ln1086">      return;</a>
<a name="ln1087"> </a>
<a name="ln1088">    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)</a>
<a name="ln1089">              CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)</a>
<a name="ln1090">      EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)</a>
<a name="ln1091">      EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)</a>
<a name="ln1092">      return;</a>
<a name="ln1093"> </a>
<a name="ln1094">    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)</a>
<a name="ln1095">      EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)</a>
<a name="ln1096">      return;</a>
<a name="ln1097"> </a>
<a name="ln1098">    case 'y': case y_acute: case y_diaeresis: CASEMBC(0x177)</a>
<a name="ln1099">              CASEMBC(0x1e8f) CASEMBC(0x1e99) CASEMBC(0x1ef3)</a>
<a name="ln1100">              CASEMBC(0x1ef7) CASEMBC(0x1ef9)</a>
<a name="ln1101">      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);</a>
<a name="ln1102">      EMITMBC(0x177)</a>
<a name="ln1103">      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)</a>
<a name="ln1104">      EMITMBC(0x1ef7) EMITMBC(0x1ef9)</a>
<a name="ln1105">      return;</a>
<a name="ln1106"> </a>
<a name="ln1107">    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)</a>
<a name="ln1108">              CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)</a>
<a name="ln1109">      EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)</a>
<a name="ln1110">      EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)</a>
<a name="ln1111">      return;</a>
<a name="ln1112"> </a>
<a name="ln1113">      /* default: character itself */</a>
<a name="ln1114">    }</a>
<a name="ln1115">  }</a>
<a name="ln1116"> </a>
<a name="ln1117">  EMIT2(c);</a>
<a name="ln1118">#undef EMIT2</a>
<a name="ln1119">#undef EMITMBC</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/*</a>
<a name="ln1123"> * Code to parse regular expression.</a>
<a name="ln1124"> *</a>
<a name="ln1125"> * We try to reuse parsing functions in regexp.c to</a>
<a name="ln1126"> * minimize surprise and keep the syntax consistent.</a>
<a name="ln1127"> */</a>
<a name="ln1128"> </a>
<a name="ln1129">/*</a>
<a name="ln1130"> * Parse the lowest level.</a>
<a name="ln1131"> *</a>
<a name="ln1132"> * An atom can be one of a long list of items.  Many atoms match one character</a>
<a name="ln1133"> * in the text.  It is often an ordinary character or a character class.</a>
<a name="ln1134"> * Braces can be used to make a pattern into an atom.  The &quot;\z(\)&quot; construct</a>
<a name="ln1135"> * is only for syntax highlighting.</a>
<a name="ln1136"> *</a>
<a name="ln1137"> * atom    ::=     ordinary-atom</a>
<a name="ln1138"> *     or  \( pattern \)</a>
<a name="ln1139"> *     or  \%( pattern \)</a>
<a name="ln1140"> *     or  \z( pattern \)</a>
<a name="ln1141"> */</a>
<a name="ln1142">static int nfa_regatom(void)</a>
<a name="ln1143">{</a>
<a name="ln1144">  int c;</a>
<a name="ln1145">  int charclass;</a>
<a name="ln1146">  int equiclass;</a>
<a name="ln1147">  int collclass;</a>
<a name="ln1148">  int got_coll_char;</a>
<a name="ln1149">  char_u      *p;</a>
<a name="ln1150">  char_u      *endp;</a>
<a name="ln1151">  char_u      *old_regparse = regparse;</a>
<a name="ln1152">  int extra = 0;</a>
<a name="ln1153">  int emit_range;</a>
<a name="ln1154">  int negated;</a>
<a name="ln1155">  int startc = -1;</a>
<a name="ln1156">  int endc = -1;</a>
<a name="ln1157">  int oldstartc = -1;</a>
<a name="ln1158">  int save_prev_at_start = prev_at_start;</a>
<a name="ln1159"> </a>
<a name="ln1160">  c = getchr();</a>
<a name="ln1161">  switch (c) {</a>
<a name="ln1162">  case NUL:</a>
<a name="ln1163">    EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1164"> </a>
<a name="ln1165">  case Magic('^'):</a>
<a name="ln1166">    EMIT(NFA_BOL);</a>
<a name="ln1167">    break;</a>
<a name="ln1168"> </a>
<a name="ln1169">  case Magic('$'):</a>
<a name="ln1170">    EMIT(NFA_EOL);</a>
<a name="ln1171">    had_eol = true;</a>
<a name="ln1172">    break;</a>
<a name="ln1173"> </a>
<a name="ln1174">  case Magic('&lt;'):</a>
<a name="ln1175">    EMIT(NFA_BOW);</a>
<a name="ln1176">    break;</a>
<a name="ln1177"> </a>
<a name="ln1178">  case Magic('&gt;'):</a>
<a name="ln1179">    EMIT(NFA_EOW);</a>
<a name="ln1180">    break;</a>
<a name="ln1181"> </a>
<a name="ln1182">  case Magic('_'):</a>
<a name="ln1183">    c = no_Magic(getchr());</a>
<a name="ln1184">    if (c == NUL)</a>
<a name="ln1185">      EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1186"> </a>
<a name="ln1187">    if (c == '^') {             /* &quot;\_^&quot; is start-of-line */</a>
<a name="ln1188">      EMIT(NFA_BOL);</a>
<a name="ln1189">      break;</a>
<a name="ln1190">    }</a>
<a name="ln1191">    if (c == '$') {             /* &quot;\_$&quot; is end-of-line */</a>
<a name="ln1192">      EMIT(NFA_EOL);</a>
<a name="ln1193">      had_eol = true;</a>
<a name="ln1194">      break;</a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197">    extra = NFA_ADD_NL;</a>
<a name="ln1198"> </a>
<a name="ln1199">    /* &quot;\_[&quot; is collection plus newline */</a>
<a name="ln1200">    if (c == '[')</a>
<a name="ln1201">      goto collection;</a>
<a name="ln1202"> </a>
<a name="ln1203">  // &quot;\_x&quot; is character class plus newline</a>
<a name="ln1204">  FALLTHROUGH;</a>
<a name="ln1205"> </a>
<a name="ln1206">  /*</a>
<a name="ln1207">   * Character classes.</a>
<a name="ln1208">   */</a>
<a name="ln1209">  case Magic('.'):</a>
<a name="ln1210">  case Magic('i'):</a>
<a name="ln1211">  case Magic('I'):</a>
<a name="ln1212">  case Magic('k'):</a>
<a name="ln1213">  case Magic('K'):</a>
<a name="ln1214">  case Magic('f'):</a>
<a name="ln1215">  case Magic('F'):</a>
<a name="ln1216">  case Magic('p'):</a>
<a name="ln1217">  case Magic('P'):</a>
<a name="ln1218">  case Magic('s'):</a>
<a name="ln1219">  case Magic('S'):</a>
<a name="ln1220">  case Magic('d'):</a>
<a name="ln1221">  case Magic('D'):</a>
<a name="ln1222">  case Magic('x'):</a>
<a name="ln1223">  case Magic('X'):</a>
<a name="ln1224">  case Magic('o'):</a>
<a name="ln1225">  case Magic('O'):</a>
<a name="ln1226">  case Magic('w'):</a>
<a name="ln1227">  case Magic('W'):</a>
<a name="ln1228">  case Magic('h'):</a>
<a name="ln1229">  case Magic('H'):</a>
<a name="ln1230">  case Magic('a'):</a>
<a name="ln1231">  case Magic('A'):</a>
<a name="ln1232">  case Magic('l'):</a>
<a name="ln1233">  case Magic('L'):</a>
<a name="ln1234">  case Magic('u'):</a>
<a name="ln1235">  case Magic('U'):</a>
<a name="ln1236">    p = vim_strchr(classchars, no_Magic(c));</a>
<a name="ln1237">    if (p == NULL) {</a>
<a name="ln1238">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1239">        EMSGN(_(e_ill_char_class), c);</a>
<a name="ln1240">        rc_did_emsg = true;</a>
<a name="ln1241">        return FAIL;</a>
<a name="ln1242">      }</a>
<a name="ln1243">      IEMSGN(&quot;INTERNAL: Unknown character class char: %&quot; PRId64, c);</a>
<a name="ln1244">      return FAIL;</a>
<a name="ln1245">    }</a>
<a name="ln1246">    // When '.' is followed by a composing char ignore the dot, so that</a>
<a name="ln1247">    // the composing char is matched here.</a>
<a name="ln1248">    if (c == Magic('.') &amp;&amp; utf_iscomposing(peekchr())) {</a>
<a name="ln1249">      old_regparse = regparse;</a>
<a name="ln1250">      c = getchr();</a>
<a name="ln1251">      goto nfa_do_multibyte;</a>
<a name="ln1252">    }</a>
<a name="ln1253">    EMIT(nfa_classcodes[p - classchars]);</a>
<a name="ln1254">    if (extra == NFA_ADD_NL) {</a>
<a name="ln1255">      EMIT(NFA_NEWL);</a>
<a name="ln1256">      EMIT(NFA_OR);</a>
<a name="ln1257">      regflags |= RF_HASNL;</a>
<a name="ln1258">    }</a>
<a name="ln1259">    break;</a>
<a name="ln1260"> </a>
<a name="ln1261">  case Magic('n'):</a>
<a name="ln1262">    if (reg_string) {</a>
<a name="ln1263">      // In a string &quot;\n&quot; matches a newline character.</a>
<a name="ln1264">      EMIT(NL);</a>
<a name="ln1265">    } else {</a>
<a name="ln1266">      // In buffer text &quot;\n&quot; matches the end of a line.</a>
<a name="ln1267">      EMIT(NFA_NEWL);</a>
<a name="ln1268">      regflags |= RF_HASNL;</a>
<a name="ln1269">    }</a>
<a name="ln1270">    break;</a>
<a name="ln1271"> </a>
<a name="ln1272">  case Magic('('):</a>
<a name="ln1273">    if (nfa_reg(REG_PAREN) == FAIL) {</a>
<a name="ln1274">      return FAIL;                  // cascaded error</a>
<a name="ln1275">    }</a>
<a name="ln1276">    break;</a>
<a name="ln1277"> </a>
<a name="ln1278">  case Magic('|'):</a>
<a name="ln1279">  case Magic('&amp;'):</a>
<a name="ln1280">  case Magic(')'):</a>
<a name="ln1281">    EMSGN(_(e_misplaced), no_Magic(c));  // -V1037</a>
<a name="ln1282">    return FAIL;</a>
<a name="ln1283"> </a>
<a name="ln1284">  case Magic('='):</a>
<a name="ln1285">  case Magic('?'):</a>
<a name="ln1286">  case Magic('+'):</a>
<a name="ln1287">  case Magic('@'):</a>
<a name="ln1288">  case Magic('*'):</a>
<a name="ln1289">  case Magic('{'):</a>
<a name="ln1290">    // these should follow an atom, not form an atom</a>
<a name="ln1291">    EMSGN(_(e_misplaced), no_Magic(c));</a>
<a name="ln1292">    return FAIL;</a>
<a name="ln1293"> </a>
<a name="ln1294">  case Magic('~'):</a>
<a name="ln1295">  {</a>
<a name="ln1296">    char_u      *lp;</a>
<a name="ln1297"> </a>
<a name="ln1298">    // Previous substitute pattern.</a>
<a name="ln1299">    // Generated as &quot;\%(pattern\)&quot;.</a>
<a name="ln1300">    if (reg_prev_sub == NULL) {</a>
<a name="ln1301">      EMSG(_(e_nopresub));</a>
<a name="ln1302">      return FAIL;</a>
<a name="ln1303">    }</a>
<a name="ln1304">    for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp)) {</a>
<a name="ln1305">      EMIT(PTR2CHAR(lp));</a>
<a name="ln1306">      if (lp != reg_prev_sub)</a>
<a name="ln1307">        EMIT(NFA_CONCAT);</a>
<a name="ln1308">    }</a>
<a name="ln1309">    EMIT(NFA_NOPEN);</a>
<a name="ln1310">    break;</a>
<a name="ln1311">  }</a>
<a name="ln1312"> </a>
<a name="ln1313">  case Magic('1'):</a>
<a name="ln1314">  case Magic('2'):</a>
<a name="ln1315">  case Magic('3'):</a>
<a name="ln1316">  case Magic('4'):</a>
<a name="ln1317">  case Magic('5'):</a>
<a name="ln1318">  case Magic('6'):</a>
<a name="ln1319">  case Magic('7'):</a>
<a name="ln1320">  case Magic('8'):</a>
<a name="ln1321">  case Magic('9'):</a>
<a name="ln1322">    {</a>
<a name="ln1323">      int refnum = no_Magic(c) - '1';</a>
<a name="ln1324"> </a>
<a name="ln1325">      if (!seen_endbrace(refnum + 1)) {</a>
<a name="ln1326">          return FAIL;</a>
<a name="ln1327">      }</a>
<a name="ln1328">      EMIT(NFA_BACKREF1 + refnum);</a>
<a name="ln1329">      rex.nfa_has_backref = true;</a>
<a name="ln1330">    }</a>
<a name="ln1331">    break;</a>
<a name="ln1332"> </a>
<a name="ln1333">  case Magic('z'):</a>
<a name="ln1334">    c = no_Magic(getchr());</a>
<a name="ln1335">    switch (c) {</a>
<a name="ln1336">    case 's':</a>
<a name="ln1337">      EMIT(NFA_ZSTART);</a>
<a name="ln1338">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1339">        return false;</a>
<a name="ln1340">      }</a>
<a name="ln1341">      break;</a>
<a name="ln1342">    case 'e':</a>
<a name="ln1343">      EMIT(NFA_ZEND);</a>
<a name="ln1344">      rex.nfa_has_zend = true;</a>
<a name="ln1345">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1346">        return false;</a>
<a name="ln1347">      }</a>
<a name="ln1348">      break;</a>
<a name="ln1349">    case '1':</a>
<a name="ln1350">    case '2':</a>
<a name="ln1351">    case '3':</a>
<a name="ln1352">    case '4':</a>
<a name="ln1353">    case '5':</a>
<a name="ln1354">    case '6':</a>
<a name="ln1355">    case '7':</a>
<a name="ln1356">    case '8':</a>
<a name="ln1357">    case '9':</a>
<a name="ln1358">      // \z1...\z9</a>
<a name="ln1359">      if ((reg_do_extmatch &amp; REX_USE) == 0) {</a>
<a name="ln1360">        EMSG_RET_FAIL(_(e_z1_not_allowed));</a>
<a name="ln1361">      }</a>
<a name="ln1362">      EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));</a>
<a name="ln1363">      // No need to set rex.nfa_has_backref, the sub-matches don't</a>
<a name="ln1364">      // change when \z1 .. \z9 matches or not.</a>
<a name="ln1365">      re_has_z = REX_USE;</a>
<a name="ln1366">      break;</a>
<a name="ln1367">    case '(':</a>
<a name="ln1368">      // \z(</a>
<a name="ln1369">      if (reg_do_extmatch != REX_SET) {</a>
<a name="ln1370">        EMSG_RET_FAIL(_(e_z_not_allowed));</a>
<a name="ln1371">      }</a>
<a name="ln1372">      if (nfa_reg(REG_ZPAREN) == FAIL) {</a>
<a name="ln1373">        return FAIL;                        // cascaded error</a>
<a name="ln1374">      }</a>
<a name="ln1375">      re_has_z = REX_SET;</a>
<a name="ln1376">      break;</a>
<a name="ln1377">    default:</a>
<a name="ln1378">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\z%c'&quot;),</a>
<a name="ln1379">            no_Magic(c));</a>
<a name="ln1380">      return FAIL;</a>
<a name="ln1381">    }</a>
<a name="ln1382">    break;</a>
<a name="ln1383"> </a>
<a name="ln1384">  case Magic('%'):</a>
<a name="ln1385">    c = no_Magic(getchr());</a>
<a name="ln1386">    switch (c) {</a>
<a name="ln1387">    /* () without a back reference */</a>
<a name="ln1388">    case '(':</a>
<a name="ln1389">      if (nfa_reg(REG_NPAREN) == FAIL)</a>
<a name="ln1390">        return FAIL;</a>
<a name="ln1391">      EMIT(NFA_NOPEN);</a>
<a name="ln1392">      break;</a>
<a name="ln1393"> </a>
<a name="ln1394">    case 'd':               /* %d123 decimal */</a>
<a name="ln1395">    case 'o':               /* %o123 octal */</a>
<a name="ln1396">    case 'x':               /* %xab hex 2 */</a>
<a name="ln1397">    case 'u':               /* %uabcd hex 4 */</a>
<a name="ln1398">    case 'U':               /* %U1234abcd hex 8 */</a>
<a name="ln1399">    {</a>
<a name="ln1400">      int64_t nr;</a>
<a name="ln1401"> </a>
<a name="ln1402">      switch (c) {</a>
<a name="ln1403">      case 'd': nr = getdecchrs(); break;</a>
<a name="ln1404">      case 'o': nr = getoctchrs(); break;</a>
<a name="ln1405">      case 'x': nr = gethexchrs(2); break;</a>
<a name="ln1406">      case 'u': nr = gethexchrs(4); break;</a>
<a name="ln1407">      case 'U': nr = gethexchrs(8); break;</a>
<a name="ln1408">      default:  nr = -1; break;</a>
<a name="ln1409">      }</a>
<a name="ln1410"> </a>
<a name="ln1411">      if (nr &lt; 0 || nr &gt; INT_MAX) {</a>
<a name="ln1412">        EMSG2_RET_FAIL(_(&quot;E678: Invalid character after %s%%[dxouU]&quot;),</a>
<a name="ln1413">                       reg_magic == MAGIC_ALL);</a>
<a name="ln1414">      }</a>
<a name="ln1415">      // A NUL is stored in the text as NL</a>
<a name="ln1416">      // TODO(vim): what if a composing character follows?</a>
<a name="ln1417">      EMIT(nr == 0 ? 0x0a : nr);</a>
<a name="ln1418">    }</a>
<a name="ln1419">    break;</a>
<a name="ln1420"> </a>
<a name="ln1421">    /* Catch \%^ and \%$ regardless of where they appear in the</a>
<a name="ln1422">     * pattern -- regardless of whether or not it makes sense. */</a>
<a name="ln1423">    case '^':</a>
<a name="ln1424">      EMIT(NFA_BOF);</a>
<a name="ln1425">      break;</a>
<a name="ln1426"> </a>
<a name="ln1427">    case '$':</a>
<a name="ln1428">      EMIT(NFA_EOF);</a>
<a name="ln1429">      break;</a>
<a name="ln1430"> </a>
<a name="ln1431">    case '#':</a>
<a name="ln1432">      EMIT(NFA_CURSOR);</a>
<a name="ln1433">      break;</a>
<a name="ln1434"> </a>
<a name="ln1435">    case 'V':</a>
<a name="ln1436">      EMIT(NFA_VISUAL);</a>
<a name="ln1437">      break;</a>
<a name="ln1438"> </a>
<a name="ln1439">    case 'C':</a>
<a name="ln1440">      EMIT(NFA_ANY_COMPOSING);</a>
<a name="ln1441">      break;</a>
<a name="ln1442"> </a>
<a name="ln1443">    case '[':</a>
<a name="ln1444">    {</a>
<a name="ln1445">      int n;</a>
<a name="ln1446"> </a>
<a name="ln1447">      /* \%[abc] */</a>
<a name="ln1448">      for (n = 0; (c = peekchr()) != ']'; ++n) {</a>
<a name="ln1449">        if (c == NUL)</a>
<a name="ln1450">          EMSG2_RET_FAIL(_(e_missing_sb),</a>
<a name="ln1451">              reg_magic == MAGIC_ALL);</a>
<a name="ln1452">        /* recursive call! */</a>
<a name="ln1453">        if (nfa_regatom() == FAIL)</a>
<a name="ln1454">          return FAIL;</a>
<a name="ln1455">      }</a>
<a name="ln1456">      getchr();                    /* get the ] */</a>
<a name="ln1457">      if (n == 0)</a>
<a name="ln1458">        EMSG2_RET_FAIL(_(e_empty_sb),</a>
<a name="ln1459">            reg_magic == MAGIC_ALL);</a>
<a name="ln1460">      EMIT(NFA_OPT_CHARS);</a>
<a name="ln1461">      EMIT(n);</a>
<a name="ln1462"> </a>
<a name="ln1463">      /* Emit as &quot;\%(\%[abc]\)&quot; to be able to handle</a>
<a name="ln1464">       * &quot;\%[abc]*&quot; which would cause the empty string to be</a>
<a name="ln1465">       * matched an unlimited number of times. NFA_NOPEN is</a>
<a name="ln1466">       * added only once at a position, while NFA_SPLIT is</a>
<a name="ln1467">       * added multiple times.  This is more efficient than</a>
<a name="ln1468">       * not allowing NFA_SPLIT multiple times, it is used</a>
<a name="ln1469">       * a lot. */</a>
<a name="ln1470">      EMIT(NFA_NOPEN);</a>
<a name="ln1471">      break;</a>
<a name="ln1472">    }</a>
<a name="ln1473"> </a>
<a name="ln1474">    default:</a>
<a name="ln1475">    {</a>
<a name="ln1476">      int64_t n = 0;</a>
<a name="ln1477">      const int cmp = c;</a>
<a name="ln1478"> </a>
<a name="ln1479">      if (c == '&lt;' || c == '&gt;')</a>
<a name="ln1480">        c = getchr();</a>
<a name="ln1481">      while (ascii_isdigit(c)) {</a>
<a name="ln1482">        if (n &gt; (INT32_MAX - (c - '0')) / 10) {</a>
<a name="ln1483">          // overflow.</a>
<a name="ln1484">          EMSG(_(e_value_too_large));</a>
<a name="ln1485">          return FAIL;</a>
<a name="ln1486">        }</a>
<a name="ln1487">        n = n * 10 + (c - '0');</a>
<a name="ln1488">        c = getchr();</a>
<a name="ln1489">      }</a>
<a name="ln1490">      if (c == 'l' || c == 'c' || c == 'v') {</a>
<a name="ln1491">        int32_t limit = INT32_MAX;</a>
<a name="ln1492"> </a>
<a name="ln1493">        if (c == 'l') {</a>
<a name="ln1494">          // \%{n}l  \%{n}&lt;l  \%{n}&gt;l</a>
<a name="ln1495">          EMIT(cmp == '&lt;' ? NFA_LNUM_LT :</a>
<a name="ln1496">               cmp == '&gt;' ? NFA_LNUM_GT : NFA_LNUM);</a>
<a name="ln1497">          if (save_prev_at_start) {</a>
<a name="ln1498">            at_start = true;</a>
<a name="ln1499">          }</a>
<a name="ln1500">        } else if (c == 'c') {</a>
<a name="ln1501">          // \%{n}c  \%{n}&lt;c  \%{n}&gt;c</a>
<a name="ln1502">          EMIT(cmp == '&lt;' ? NFA_COL_LT :</a>
<a name="ln1503">               cmp == '&gt;' ? NFA_COL_GT : NFA_COL);</a>
<a name="ln1504">        } else {</a>
<a name="ln1505">          // \%{n}v  \%{n}&lt;v  \%{n}&gt;v</a>
<a name="ln1506">          EMIT(cmp == '&lt;' ? NFA_VCOL_LT :</a>
<a name="ln1507">               cmp == '&gt;' ? NFA_VCOL_GT : NFA_VCOL);</a>
<a name="ln1508">          limit = INT32_MAX / MB_MAXBYTES;</a>
<a name="ln1509">        }</a>
<a name="ln1510">        if (n &gt;= limit) {</a>
<a name="ln1511">          EMSG(_(e_value_too_large));</a>
<a name="ln1512">          return FAIL;</a>
<a name="ln1513">        }</a>
<a name="ln1514">        EMIT((int)n);</a>
<a name="ln1515">        break;</a>
<a name="ln1516">      } else if (c == '\'' &amp;&amp; n == 0) {</a>
<a name="ln1517">        /* \%'m  \%&lt;'m  \%&gt;'m  */</a>
<a name="ln1518">        EMIT(cmp == '&lt;' ? NFA_MARK_LT :</a>
<a name="ln1519">            cmp == '&gt;' ? NFA_MARK_GT : NFA_MARK);</a>
<a name="ln1520">        EMIT(getchr());</a>
<a name="ln1521">        break;</a>
<a name="ln1522">      }</a>
<a name="ln1523">    }</a>
<a name="ln1524">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\%%%c'&quot;),</a>
<a name="ln1525">            no_Magic(c));</a>
<a name="ln1526">      return FAIL;</a>
<a name="ln1527">    }</a>
<a name="ln1528">    break;</a>
<a name="ln1529"> </a>
<a name="ln1530">  case Magic('['):</a>
<a name="ln1531">collection:</a>
<a name="ln1532">    /*</a>
<a name="ln1533">     * [abc]  uses NFA_START_COLL - NFA_END_COLL</a>
<a name="ln1534">     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL</a>
<a name="ln1535">     * Each character is produced as a regular state, using</a>
<a name="ln1536">     * NFA_CONCAT to bind them together.</a>
<a name="ln1537">     * Besides normal characters there can be:</a>
<a name="ln1538">     * - character classes  NFA_CLASS_*</a>
<a name="ln1539">     * - ranges, two characters followed by NFA_RANGE.</a>
<a name="ln1540">     */</a>
<a name="ln1541"> </a>
<a name="ln1542">    p = regparse;</a>
<a name="ln1543">    endp = skip_anyof(p);</a>
<a name="ln1544">    if (*endp == ']') {</a>
<a name="ln1545">      /*</a>
<a name="ln1546">       * Try to reverse engineer character classes. For example,</a>
<a name="ln1547">       * recognize that [0-9] stands for \d and [A-Za-z_] for \h,</a>
<a name="ln1548">       * and perform the necessary substitutions in the NFA.</a>
<a name="ln1549">       */</a>
<a name="ln1550">      int result = nfa_recognize_char_class(regparse, endp,</a>
<a name="ln1551">                                            extra == NFA_ADD_NL);</a>
<a name="ln1552">      if (result != FAIL) {</a>
<a name="ln1553">        if (result &gt;= NFA_FIRST_NL &amp;&amp; result &lt;= NFA_LAST_NL) {</a>
<a name="ln1554">          EMIT(result - NFA_ADD_NL);</a>
<a name="ln1555">          EMIT(NFA_NEWL);</a>
<a name="ln1556">          EMIT(NFA_OR);</a>
<a name="ln1557">        } else</a>
<a name="ln1558">          EMIT(result);</a>
<a name="ln1559">        regparse = endp;</a>
<a name="ln1560">        MB_PTR_ADV(regparse);</a>
<a name="ln1561">        return OK;</a>
<a name="ln1562">      }</a>
<a name="ln1563">      /*</a>
<a name="ln1564">       * Failed to recognize a character class. Use the simple</a>
<a name="ln1565">       * version that turns [abc] into 'a' OR 'b' OR 'c'</a>
<a name="ln1566">       */</a>
<a name="ln1567">      startc = endc = oldstartc = -1;</a>
<a name="ln1568">      negated = false;</a>
<a name="ln1569">      if (*regparse == '^') {                           // negated range</a>
<a name="ln1570">        negated = true;</a>
<a name="ln1571">        MB_PTR_ADV(regparse);</a>
<a name="ln1572">        EMIT(NFA_START_NEG_COLL);</a>
<a name="ln1573">      } else</a>
<a name="ln1574">        EMIT(NFA_START_COLL);</a>
<a name="ln1575">      if (*regparse == '-') {</a>
<a name="ln1576">        startc = '-';</a>
<a name="ln1577">        EMIT(startc);</a>
<a name="ln1578">        EMIT(NFA_CONCAT);</a>
<a name="ln1579">        MB_PTR_ADV(regparse);</a>
<a name="ln1580">      }</a>
<a name="ln1581">      // Emit the OR branches for each character in the []</a>
<a name="ln1582">      emit_range = false;</a>
<a name="ln1583">      while (regparse &lt; endp) {</a>
<a name="ln1584">        oldstartc = startc;</a>
<a name="ln1585">        startc = -1;</a>
<a name="ln1586">        got_coll_char = false;</a>
<a name="ln1587">        if (*regparse == '[') {</a>
<a name="ln1588">          /* Check for [: :], [= =], [. .] */</a>
<a name="ln1589">          equiclass = collclass = 0;</a>
<a name="ln1590">          charclass = get_char_class(&amp;regparse);</a>
<a name="ln1591">          if (charclass == CLASS_NONE) {</a>
<a name="ln1592">            equiclass = get_equi_class(&amp;regparse);</a>
<a name="ln1593">            if (equiclass == 0)</a>
<a name="ln1594">              collclass = get_coll_element(&amp;regparse);</a>
<a name="ln1595">          }</a>
<a name="ln1596"> </a>
<a name="ln1597">          /* Character class like [:alpha:]  */</a>
<a name="ln1598">          if (charclass != CLASS_NONE) {</a>
<a name="ln1599">            switch (charclass) {</a>
<a name="ln1600">            case CLASS_ALNUM:</a>
<a name="ln1601">              EMIT(NFA_CLASS_ALNUM);</a>
<a name="ln1602">              break;</a>
<a name="ln1603">            case CLASS_ALPHA:</a>
<a name="ln1604">              EMIT(NFA_CLASS_ALPHA);</a>
<a name="ln1605">              break;</a>
<a name="ln1606">            case CLASS_BLANK:</a>
<a name="ln1607">              EMIT(NFA_CLASS_BLANK);</a>
<a name="ln1608">              break;</a>
<a name="ln1609">            case CLASS_CNTRL:</a>
<a name="ln1610">              EMIT(NFA_CLASS_CNTRL);</a>
<a name="ln1611">              break;</a>
<a name="ln1612">            case CLASS_DIGIT:</a>
<a name="ln1613">              EMIT(NFA_CLASS_DIGIT);</a>
<a name="ln1614">              break;</a>
<a name="ln1615">            case CLASS_GRAPH:</a>
<a name="ln1616">              EMIT(NFA_CLASS_GRAPH);</a>
<a name="ln1617">              break;</a>
<a name="ln1618">            case CLASS_LOWER:</a>
<a name="ln1619">              EMIT(NFA_CLASS_LOWER);</a>
<a name="ln1620">              break;</a>
<a name="ln1621">            case CLASS_PRINT:</a>
<a name="ln1622">              EMIT(NFA_CLASS_PRINT);</a>
<a name="ln1623">              break;</a>
<a name="ln1624">            case CLASS_PUNCT:</a>
<a name="ln1625">              EMIT(NFA_CLASS_PUNCT);</a>
<a name="ln1626">              break;</a>
<a name="ln1627">            case CLASS_SPACE:</a>
<a name="ln1628">              EMIT(NFA_CLASS_SPACE);</a>
<a name="ln1629">              break;</a>
<a name="ln1630">            case CLASS_UPPER:</a>
<a name="ln1631">              EMIT(NFA_CLASS_UPPER);</a>
<a name="ln1632">              break;</a>
<a name="ln1633">            case CLASS_XDIGIT:</a>
<a name="ln1634">              EMIT(NFA_CLASS_XDIGIT);</a>
<a name="ln1635">              break;</a>
<a name="ln1636">            case CLASS_TAB:</a>
<a name="ln1637">              EMIT(NFA_CLASS_TAB);</a>
<a name="ln1638">              break;</a>
<a name="ln1639">            case CLASS_RETURN:</a>
<a name="ln1640">              EMIT(NFA_CLASS_RETURN);</a>
<a name="ln1641">              break;</a>
<a name="ln1642">            case CLASS_BACKSPACE:</a>
<a name="ln1643">              EMIT(NFA_CLASS_BACKSPACE);</a>
<a name="ln1644">              break;</a>
<a name="ln1645">            case CLASS_ESCAPE:</a>
<a name="ln1646">              EMIT(NFA_CLASS_ESCAPE);</a>
<a name="ln1647">              break;</a>
<a name="ln1648">            case CLASS_IDENT:</a>
<a name="ln1649">              EMIT(NFA_CLASS_IDENT);</a>
<a name="ln1650">              break;</a>
<a name="ln1651">            case CLASS_KEYWORD:</a>
<a name="ln1652">              EMIT(NFA_CLASS_KEYWORD);</a>
<a name="ln1653">              break;</a>
<a name="ln1654">            case CLASS_FNAME:</a>
<a name="ln1655">              EMIT(NFA_CLASS_FNAME);</a>
<a name="ln1656">              break;</a>
<a name="ln1657">            }</a>
<a name="ln1658">            EMIT(NFA_CONCAT);</a>
<a name="ln1659">            continue;</a>
<a name="ln1660">          }</a>
<a name="ln1661">          /* Try equivalence class [=a=] and the like */</a>
<a name="ln1662">          if (equiclass != 0) {</a>
<a name="ln1663">            nfa_emit_equi_class(equiclass);</a>
<a name="ln1664">            continue;</a>
<a name="ln1665">          }</a>
<a name="ln1666">          /* Try collating class like [. .]  */</a>
<a name="ln1667">          if (collclass != 0) {</a>
<a name="ln1668">            startc = collclass;                  /* allow [.a.]-x as a range */</a>
<a name="ln1669">            /* Will emit the proper atom at the end of the</a>
<a name="ln1670">             * while loop. */</a>
<a name="ln1671">          }</a>
<a name="ln1672">        }</a>
<a name="ln1673">        /* Try a range like 'a-x' or '\t-z'. Also allows '-' as a</a>
<a name="ln1674">         * start character. */</a>
<a name="ln1675">        if (*regparse == '-' &amp;&amp; oldstartc != -1) {</a>
<a name="ln1676">          emit_range = true;</a>
<a name="ln1677">          startc = oldstartc;</a>
<a name="ln1678">          MB_PTR_ADV(regparse);</a>
<a name="ln1679">          continue;                         // reading the end of the range</a>
<a name="ln1680">        }</a>
<a name="ln1681"> </a>
<a name="ln1682">        /* Now handle simple and escaped characters.</a>
<a name="ln1683">         * Only &quot;\]&quot;, &quot;\^&quot;, &quot;\]&quot; and &quot;\\&quot; are special in Vi.  Vim</a>
<a name="ln1684">         * accepts &quot;\t&quot;, &quot;\e&quot;, etc., but only when the 'l' flag in</a>
<a name="ln1685">         * 'cpoptions' is not included.</a>
<a name="ln1686">         */</a>
<a name="ln1687">        if (*regparse == '\\'</a>
<a name="ln1688">            &amp;&amp; regparse + 1 &lt;= endp</a>
<a name="ln1689">            &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL</a>
<a name="ln1690">                || (!reg_cpo_lit</a>
<a name="ln1691">                    &amp;&amp; vim_strchr(REGEXP_ABBR, regparse[1])</a>
<a name="ln1692">                    != NULL)</a>
<a name="ln1693">                )</a>
<a name="ln1694">            ) {</a>
<a name="ln1695">          MB_PTR_ADV(regparse);</a>
<a name="ln1696"> </a>
<a name="ln1697">          if (*regparse == 'n') {</a>
<a name="ln1698">            startc = (reg_string || emit_range || regparse[1] == '-')</a>
<a name="ln1699">              ? NL : NFA_NEWL;</a>
<a name="ln1700">          } else if  (*regparse == 'd'</a>
<a name="ln1701">                      || *regparse == 'o'</a>
<a name="ln1702">                      || *regparse == 'x'</a>
<a name="ln1703">                      || *regparse == 'u'</a>
<a name="ln1704">                      || *regparse == 'U'</a>
<a name="ln1705">                      ) {</a>
<a name="ln1706">            // TODO(RE): This needs more testing</a>
<a name="ln1707">            startc = coll_get_char();</a>
<a name="ln1708">            got_coll_char = true;</a>
<a name="ln1709">            MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1710">          } else {</a>
<a name="ln1711">            /* \r,\t,\e,\b */</a>
<a name="ln1712">            startc = backslash_trans(*regparse);</a>
<a name="ln1713">          }</a>
<a name="ln1714">        }</a>
<a name="ln1715"> </a>
<a name="ln1716">        /* Normal printable char */</a>
<a name="ln1717">        if (startc == -1)</a>
<a name="ln1718">          startc = PTR2CHAR(regparse);</a>
<a name="ln1719"> </a>
<a name="ln1720">        /* Previous char was '-', so this char is end of range. */</a>
<a name="ln1721">        if (emit_range) {</a>
<a name="ln1722">          endc = startc;</a>
<a name="ln1723">          startc = oldstartc;</a>
<a name="ln1724">          if (startc &gt; endc) {</a>
<a name="ln1725">            EMSG_RET_FAIL(_(e_reverse_range));</a>
<a name="ln1726">          }</a>
<a name="ln1727"> </a>
<a name="ln1728">          if (endc &gt; startc + 2) {</a>
<a name="ln1729">            /* Emit a range instead of the sequence of</a>
<a name="ln1730">             * individual characters. */</a>
<a name="ln1731">            if (startc == 0)</a>
<a name="ln1732">              /* \x00 is translated to \x0a, start at \x01. */</a>
<a name="ln1733">              EMIT(1);</a>
<a name="ln1734">            else</a>
<a name="ln1735">              --post_ptr;                   /* remove NFA_CONCAT */</a>
<a name="ln1736">            EMIT(endc);</a>
<a name="ln1737">            EMIT(NFA_RANGE);</a>
<a name="ln1738">            EMIT(NFA_CONCAT);</a>
<a name="ln1739">          } else if ((*mb_char2len)(startc) &gt; 1</a>
<a name="ln1740">                     || (*mb_char2len)(endc) &gt; 1) {</a>
<a name="ln1741">            // Emit the characters in the range.</a>
<a name="ln1742">            // &quot;startc&quot; was already emitted, so skip it.</a>
<a name="ln1743">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1744">              EMIT(c);</a>
<a name="ln1745">              EMIT(NFA_CONCAT);</a>
<a name="ln1746">            }</a>
<a name="ln1747">          } else {</a>
<a name="ln1748">            /* Emit the range. &quot;startc&quot; was already emitted, so</a>
<a name="ln1749">             * skip it. */</a>
<a name="ln1750">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1751">              EMIT(c);</a>
<a name="ln1752">              EMIT(NFA_CONCAT);</a>
<a name="ln1753">            }</a>
<a name="ln1754">          }</a>
<a name="ln1755">          emit_range = false;</a>
<a name="ln1756">          startc = -1;</a>
<a name="ln1757">        } else {</a>
<a name="ln1758">          /* This char (startc) is not part of a range. Just</a>
<a name="ln1759">           * emit it.</a>
<a name="ln1760">           * Normally, simply emit startc. But if we get char</a>
<a name="ln1761">           * code=0 from a collating char, then replace it with</a>
<a name="ln1762">           * 0x0a.</a>
<a name="ln1763">           * This is needed to completely mimic the behaviour of</a>
<a name="ln1764">           * the backtracking engine. */</a>
<a name="ln1765">          if (startc == NFA_NEWL) {</a>
<a name="ln1766">            /* Line break can't be matched as part of the</a>
<a name="ln1767">             * collection, add an OR below. But not for negated</a>
<a name="ln1768">             * range. */</a>
<a name="ln1769">            if (!negated)</a>
<a name="ln1770">              extra = NFA_ADD_NL;</a>
<a name="ln1771">          } else {</a>
<a name="ln1772">            if (got_coll_char == true &amp;&amp; startc == 0) {</a>
<a name="ln1773">              EMIT(0x0a);</a>
<a name="ln1774">            } else {</a>
<a name="ln1775">              EMIT(startc);</a>
<a name="ln1776">            }</a>
<a name="ln1777">            EMIT(NFA_CONCAT);</a>
<a name="ln1778">          }</a>
<a name="ln1779">        }</a>
<a name="ln1780"> </a>
<a name="ln1781">        MB_PTR_ADV(regparse);</a>
<a name="ln1782">      }           // while (p &lt; endp)</a>
<a name="ln1783"> </a>
<a name="ln1784">      MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1785">      if (*regparse == '-') {               // if last, '-' is just a char</a>
<a name="ln1786">        EMIT('-');</a>
<a name="ln1787">        EMIT(NFA_CONCAT);</a>
<a name="ln1788">      }</a>
<a name="ln1789"> </a>
<a name="ln1790">      /* skip the trailing ] */</a>
<a name="ln1791">      regparse = endp;</a>
<a name="ln1792">      MB_PTR_ADV(regparse);</a>
<a name="ln1793"> </a>
<a name="ln1794">      // Mark end of the collection.</a>
<a name="ln1795">      if (negated == true) {</a>
<a name="ln1796">        EMIT(NFA_END_NEG_COLL);</a>
<a name="ln1797">      } else {</a>
<a name="ln1798">        EMIT(NFA_END_COLL);</a>
<a name="ln1799">      }</a>
<a name="ln1800"> </a>
<a name="ln1801">      // \_[] also matches \n but it's not negated</a>
<a name="ln1802">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1803">        EMIT(reg_string ? NL : NFA_NEWL);</a>
<a name="ln1804">        EMIT(NFA_OR);</a>
<a name="ln1805">      }</a>
<a name="ln1806"> </a>
<a name="ln1807">      return OK;</a>
<a name="ln1808">    }         /* if exists closing ] */</a>
<a name="ln1809"> </a>
<a name="ln1810">    if (reg_strict)</a>
<a name="ln1811">      EMSG_RET_FAIL(_(e_missingbracket));</a>
<a name="ln1812">    FALLTHROUGH;</a>
<a name="ln1813"> </a>
<a name="ln1814">  default:</a>
<a name="ln1815">  {</a>
<a name="ln1816">    int plen;</a>
<a name="ln1817"> </a>
<a name="ln1818">nfa_do_multibyte:</a>
<a name="ln1819">    // plen is length of current char with composing chars</a>
<a name="ln1820">    if ((*mb_char2len)(c) != (plen = utfc_ptr2len(old_regparse))</a>
<a name="ln1821">        || utf_iscomposing(c)) {</a>
<a name="ln1822">      int i = 0;</a>
<a name="ln1823"> </a>
<a name="ln1824">      /* A base character plus composing characters, or just one</a>
<a name="ln1825">       * or more composing characters.</a>
<a name="ln1826">       * This requires creating a separate atom as if enclosing</a>
<a name="ln1827">       * the characters in (), where NFA_COMPOSING is the ( and</a>
<a name="ln1828">       * NFA_END_COMPOSING is the ). Note that right now we are</a>
<a name="ln1829">       * building the postfix form, not the NFA itself;</a>
<a name="ln1830">       * a composing char could be: a, b, c, NFA_COMPOSING</a>
<a name="ln1831">       * where 'b' and 'c' are chars with codes &gt; 256. */</a>
<a name="ln1832">      for (;; ) {</a>
<a name="ln1833">        EMIT(c);</a>
<a name="ln1834">        if (i &gt; 0)</a>
<a name="ln1835">          EMIT(NFA_CONCAT);</a>
<a name="ln1836">        if ((i += utf_char2len(c)) &gt;= plen)</a>
<a name="ln1837">          break;</a>
<a name="ln1838">        c = utf_ptr2char(old_regparse + i);</a>
<a name="ln1839">      }</a>
<a name="ln1840">      EMIT(NFA_COMPOSING);</a>
<a name="ln1841">      regparse = old_regparse + plen;</a>
<a name="ln1842">    } else {</a>
<a name="ln1843">      c = no_Magic(c);</a>
<a name="ln1844">      EMIT(c);</a>
<a name="ln1845">    }</a>
<a name="ln1846">    return OK;</a>
<a name="ln1847">  }</a>
<a name="ln1848">  }</a>
<a name="ln1849"> </a>
<a name="ln1850">  return OK;</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853">/*</a>
<a name="ln1854"> * Parse something followed by possible [*+=].</a>
<a name="ln1855"> *</a>
<a name="ln1856"> * A piece is an atom, possibly followed by a multi, an indication of how many</a>
<a name="ln1857"> * times the atom can be matched.  Example: &quot;a*&quot; matches any sequence of &quot;a&quot;</a>
<a name="ln1858"> * characters: &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, etc.</a>
<a name="ln1859"> *</a>
<a name="ln1860"> * piece   ::=	    atom</a>
<a name="ln1861"> *	or  atom  multi</a>
<a name="ln1862"> */</a>
<a name="ln1863">static int nfa_regpiece(void)</a>
<a name="ln1864">{</a>
<a name="ln1865">  int i;</a>
<a name="ln1866">  int op;</a>
<a name="ln1867">  int ret;</a>
<a name="ln1868">  long minval, maxval;</a>
<a name="ln1869">  bool greedy = true;  // Braces are prefixed with '-' ?</a>
<a name="ln1870">  parse_state_T old_state;</a>
<a name="ln1871">  parse_state_T new_state;</a>
<a name="ln1872">  int64_t c2;</a>
<a name="ln1873">  int old_post_pos;</a>
<a name="ln1874">  int my_post_start;</a>
<a name="ln1875">  int quest;</a>
<a name="ln1876"> </a>
<a name="ln1877">  /* Save the current parse state, so that we can use it if &lt;atom&gt;{m,n} is</a>
<a name="ln1878">   * next. */</a>
<a name="ln1879">  save_parse_state(&amp;old_state);</a>
<a name="ln1880"> </a>
<a name="ln1881">  /* store current pos in the postfix form, for \{m,n} involving 0s */</a>
<a name="ln1882">  my_post_start = (int)(post_ptr - post_start);</a>
<a name="ln1883"> </a>
<a name="ln1884">  ret = nfa_regatom();</a>
<a name="ln1885">  if (ret == FAIL)</a>
<a name="ln1886">    return FAIL;            /* cascaded error */</a>
<a name="ln1887"> </a>
<a name="ln1888">  op = peekchr();</a>
<a name="ln1889">  if (re_multi_type(op) == NOT_MULTI)</a>
<a name="ln1890">    return OK;</a>
<a name="ln1891"> </a>
<a name="ln1892">  skipchr();</a>
<a name="ln1893">  switch (op) {</a>
<a name="ln1894">  case Magic('*'):</a>
<a name="ln1895">    EMIT(NFA_STAR);</a>
<a name="ln1896">    break;</a>
<a name="ln1897"> </a>
<a name="ln1898">  case Magic('+'):</a>
<a name="ln1899">    /*</a>
<a name="ln1900">     * Trick: Normally, (a*)\+ would match the whole input &quot;aaa&quot;.  The</a>
<a name="ln1901">     * first and only submatch would be &quot;aaa&quot;. But the backtracking</a>
<a name="ln1902">     * engine interprets the plus as &quot;try matching one more time&quot;, and</a>
<a name="ln1903">     * a* matches a second time at the end of the input, the empty</a>
<a name="ln1904">     * string.</a>
<a name="ln1905">     * The submatch will be the empty string.</a>
<a name="ln1906">     *</a>
<a name="ln1907">     * In order to be consistent with the old engine, we replace</a>
<a name="ln1908">     * &lt;atom&gt;+ with &lt;atom&gt;&lt;atom&gt;*</a>
<a name="ln1909">     */</a>
<a name="ln1910">    restore_parse_state(&amp;old_state);</a>
<a name="ln1911">    curchr = -1;</a>
<a name="ln1912">    if (nfa_regatom() == FAIL)</a>
<a name="ln1913">      return FAIL;</a>
<a name="ln1914">    EMIT(NFA_STAR);</a>
<a name="ln1915">    EMIT(NFA_CONCAT);</a>
<a name="ln1916">    skipchr();                  /* skip the \+	*/</a>
<a name="ln1917">    break;</a>
<a name="ln1918"> </a>
<a name="ln1919">  case Magic('@'):</a>
<a name="ln1920">    c2 = getdecchrs();</a>
<a name="ln1921">    op = no_Magic(getchr());</a>
<a name="ln1922">    i = 0;</a>
<a name="ln1923">    switch(op) {</a>
<a name="ln1924">    case '=':</a>
<a name="ln1925">      /* \@= */</a>
<a name="ln1926">      i = NFA_PREV_ATOM_NO_WIDTH;</a>
<a name="ln1927">      break;</a>
<a name="ln1928">    case '!':</a>
<a name="ln1929">      /* \@! */</a>
<a name="ln1930">      i = NFA_PREV_ATOM_NO_WIDTH_NEG;</a>
<a name="ln1931">      break;</a>
<a name="ln1932">    case '&lt;':</a>
<a name="ln1933">      op = no_Magic(getchr());</a>
<a name="ln1934">      if (op == '=')</a>
<a name="ln1935">        /* \@&lt;= */</a>
<a name="ln1936">        i = NFA_PREV_ATOM_JUST_BEFORE;</a>
<a name="ln1937">      else if (op == '!')</a>
<a name="ln1938">        /* \@&lt;! */</a>
<a name="ln1939">        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;</a>
<a name="ln1940">      break;</a>
<a name="ln1941">    case '&gt;':</a>
<a name="ln1942">      /* \@&gt;  */</a>
<a name="ln1943">      i = NFA_PREV_ATOM_LIKE_PATTERN;</a>
<a name="ln1944">      break;</a>
<a name="ln1945">    }</a>
<a name="ln1946">    if (i == 0) {</a>
<a name="ln1947">      emsgf(_(&quot;E869: (NFA) Unknown operator '\\@%c'&quot;), op);</a>
<a name="ln1948">      return FAIL;</a>
<a name="ln1949">    }</a>
<a name="ln1950">    EMIT(i);</a>
<a name="ln1951">    if (i == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln1952">        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)</a>
<a name="ln1953">      EMIT(c2);</a>
<a name="ln1954">    break;</a>
<a name="ln1955"> </a>
<a name="ln1956">  case Magic('?'):</a>
<a name="ln1957">  case Magic('='):</a>
<a name="ln1958">    EMIT(NFA_QUEST);</a>
<a name="ln1959">    break;</a>
<a name="ln1960"> </a>
<a name="ln1961">  case Magic('{'):</a>
<a name="ln1962">    /* a{2,5} will expand to 'aaa?a?a?'</a>
<a name="ln1963">     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy</a>
<a name="ln1964">     * version of '?'</a>
<a name="ln1965">     * \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the</a>
<a name="ln1966">     * parenthesis have the same id</a>
<a name="ln1967">     */</a>
<a name="ln1968"> </a>
<a name="ln1969">    greedy = true;</a>
<a name="ln1970">    c2 = peekchr();</a>
<a name="ln1971">    if (c2 == '-' || c2 == Magic('-')) {</a>
<a name="ln1972">      skipchr();</a>
<a name="ln1973">      greedy = false;</a>
<a name="ln1974">    }</a>
<a name="ln1975">    if (!read_limits(&amp;minval, &amp;maxval))</a>
<a name="ln1976">      EMSG_RET_FAIL(_(&quot;E870: (NFA regexp) Error reading repetition limits&quot;));</a>
<a name="ln1977"> </a>
<a name="ln1978">    /*  &lt;atom&gt;{0,inf}, &lt;atom&gt;{0,} and &lt;atom&gt;{}  are equivalent to</a>
<a name="ln1979">     *  &lt;atom&gt;*  */</a>
<a name="ln1980">    if (minval == 0 &amp;&amp; maxval == MAX_LIMIT) {</a>
<a name="ln1981">      if (greedy)</a>
<a name="ln1982">        /* \{}, \{0,} */</a>
<a name="ln1983">        EMIT(NFA_STAR);</a>
<a name="ln1984">      else</a>
<a name="ln1985">        /* \{-}, \{-0,} */</a>
<a name="ln1986">        EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln1987">      break;</a>
<a name="ln1988">    }</a>
<a name="ln1989"> </a>
<a name="ln1990">    /* Special case: x{0} or x{-0} */</a>
<a name="ln1991">    if (maxval == 0) {</a>
<a name="ln1992">      /* Ignore result of previous call to nfa_regatom() */</a>
<a name="ln1993">      post_ptr = post_start + my_post_start;</a>
<a name="ln1994">      /* NFA_EMPTY is 0-length and works everywhere */</a>
<a name="ln1995">      EMIT(NFA_EMPTY);</a>
<a name="ln1996">      return OK;</a>
<a name="ln1997">    }</a>
<a name="ln1998"> </a>
<a name="ln1999">    // The engine is very inefficient (uses too many states) when the maximum</a>
<a name="ln2000">    // is much larger than the minimum and when the maximum is large. Bail out</a>
<a name="ln2001">    // if we can use the other engine.</a>
<a name="ln2002">    if ((nfa_re_flags &amp; RE_AUTO) &amp;&amp; (maxval &gt; 500 || maxval &gt; minval + 200)) {</a>
<a name="ln2003">      return FAIL;</a>
<a name="ln2004">    }</a>
<a name="ln2005"> </a>
<a name="ln2006">    /* Ignore previous call to nfa_regatom() */</a>
<a name="ln2007">    post_ptr = post_start + my_post_start;</a>
<a name="ln2008">    /* Save parse state after the repeated atom and the \{} */</a>
<a name="ln2009">    save_parse_state(&amp;new_state);</a>
<a name="ln2010"> </a>
<a name="ln2011">    quest = (greedy == true ? NFA_QUEST : NFA_QUEST_NONGREEDY);</a>
<a name="ln2012">    for (i = 0; i &lt; maxval; i++) {</a>
<a name="ln2013">      /* Goto beginning of the repeated atom */</a>
<a name="ln2014">      restore_parse_state(&amp;old_state);</a>
<a name="ln2015">      old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2016">      if (nfa_regatom() == FAIL)</a>
<a name="ln2017">        return FAIL;</a>
<a name="ln2018">      /* after &quot;minval&quot; times, atoms are optional */</a>
<a name="ln2019">      if (i + 1 &gt; minval) {</a>
<a name="ln2020">        if (maxval == MAX_LIMIT) {</a>
<a name="ln2021">          if (greedy)</a>
<a name="ln2022">            EMIT(NFA_STAR);</a>
<a name="ln2023">          else</a>
<a name="ln2024">            EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln2025">        } else</a>
<a name="ln2026">          EMIT(quest);</a>
<a name="ln2027">      }</a>
<a name="ln2028">      if (old_post_pos != my_post_start)</a>
<a name="ln2029">        EMIT(NFA_CONCAT);</a>
<a name="ln2030">      if (i + 1 &gt; minval &amp;&amp; maxval == MAX_LIMIT)</a>
<a name="ln2031">        break;</a>
<a name="ln2032">    }</a>
<a name="ln2033"> </a>
<a name="ln2034">    /* Go to just after the repeated atom and the \{} */</a>
<a name="ln2035">    restore_parse_state(&amp;new_state);</a>
<a name="ln2036">    curchr = -1;</a>
<a name="ln2037"> </a>
<a name="ln2038">    break;</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">  default:</a>
<a name="ln2042">    break;</a>
<a name="ln2043">  }     /* end switch */</a>
<a name="ln2044"> </a>
<a name="ln2045">  if (re_multi_type(peekchr()) != NOT_MULTI) {</a>
<a name="ln2046">    // Can't have a multi follow a multi.</a>
<a name="ln2047">    EMSG_RET_FAIL(_(&quot;E871: (NFA regexp) Can't have a multi follow a multi&quot;));</a>
<a name="ln2048">  }</a>
<a name="ln2049"> </a>
<a name="ln2050">  return OK;</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053">/*</a>
<a name="ln2054"> * Parse one or more pieces, concatenated.  It matches a match for the</a>
<a name="ln2055"> * first piece, followed by a match for the second piece, etc.  Example:</a>
<a name="ln2056"> * &quot;f[0-9]b&quot;, first matches &quot;f&quot;, then a digit and then &quot;b&quot;.</a>
<a name="ln2057"> *</a>
<a name="ln2058"> * concat  ::=	    piece</a>
<a name="ln2059"> *	or  piece piece</a>
<a name="ln2060"> *	or  piece piece piece</a>
<a name="ln2061"> *	etc.</a>
<a name="ln2062"> */</a>
<a name="ln2063">static int nfa_regconcat(void)</a>
<a name="ln2064">{</a>
<a name="ln2065">  bool cont = true;</a>
<a name="ln2066">  bool first = true;</a>
<a name="ln2067"> </a>
<a name="ln2068">  while (cont) {</a>
<a name="ln2069">    switch (peekchr()) {</a>
<a name="ln2070">    case NUL:</a>
<a name="ln2071">    case Magic('|'):</a>
<a name="ln2072">    case Magic('&amp;'):</a>
<a name="ln2073">    case Magic(')'):</a>
<a name="ln2074">      cont = false;</a>
<a name="ln2075">      break;</a>
<a name="ln2076"> </a>
<a name="ln2077">    case Magic('Z'):</a>
<a name="ln2078">      regflags |= RF_ICOMBINE;</a>
<a name="ln2079">      skipchr_keepstart();</a>
<a name="ln2080">      break;</a>
<a name="ln2081">    case Magic('c'):</a>
<a name="ln2082">      regflags |= RF_ICASE;</a>
<a name="ln2083">      skipchr_keepstart();</a>
<a name="ln2084">      break;</a>
<a name="ln2085">    case Magic('C'):</a>
<a name="ln2086">      regflags |= RF_NOICASE;</a>
<a name="ln2087">      skipchr_keepstart();</a>
<a name="ln2088">      break;</a>
<a name="ln2089">    case Magic('v'):</a>
<a name="ln2090">      reg_magic = MAGIC_ALL;</a>
<a name="ln2091">      skipchr_keepstart();</a>
<a name="ln2092">      curchr = -1;</a>
<a name="ln2093">      break;</a>
<a name="ln2094">    case Magic('m'):</a>
<a name="ln2095">      reg_magic = MAGIC_ON;</a>
<a name="ln2096">      skipchr_keepstart();</a>
<a name="ln2097">      curchr = -1;</a>
<a name="ln2098">      break;</a>
<a name="ln2099">    case Magic('M'):</a>
<a name="ln2100">      reg_magic = MAGIC_OFF;</a>
<a name="ln2101">      skipchr_keepstart();</a>
<a name="ln2102">      curchr = -1;</a>
<a name="ln2103">      break;</a>
<a name="ln2104">    case Magic('V'):</a>
<a name="ln2105">      reg_magic = MAGIC_NONE;</a>
<a name="ln2106">      skipchr_keepstart();</a>
<a name="ln2107">      curchr = -1;</a>
<a name="ln2108">      break;</a>
<a name="ln2109"> </a>
<a name="ln2110">    default:</a>
<a name="ln2111">      if (nfa_regpiece() == FAIL) {</a>
<a name="ln2112">        return FAIL;</a>
<a name="ln2113">      }</a>
<a name="ln2114">      if (first == false) {</a>
<a name="ln2115">        EMIT(NFA_CONCAT);</a>
<a name="ln2116">      } else {</a>
<a name="ln2117">        first = false;</a>
<a name="ln2118">      }</a>
<a name="ln2119">      break;</a>
<a name="ln2120">    }</a>
<a name="ln2121">  }</a>
<a name="ln2122"> </a>
<a name="ln2123">  return OK;</a>
<a name="ln2124">}</a>
<a name="ln2125"> </a>
<a name="ln2126">/*</a>
<a name="ln2127"> * Parse a branch, one or more concats, separated by &quot;\&amp;&quot;.  It matches the</a>
<a name="ln2128"> * last concat, but only if all the preceding concats also match at the same</a>
<a name="ln2129"> * position.  Examples:</a>
<a name="ln2130"> *      &quot;foobeep\&amp;...&quot; matches &quot;foo&quot; in &quot;foobeep&quot;.</a>
<a name="ln2131"> *      &quot;.*Peter\&amp;.*Bob&quot; matches in a line containing both &quot;Peter&quot; and &quot;Bob&quot;</a>
<a name="ln2132"> *</a>
<a name="ln2133"> * branch ::=	    concat</a>
<a name="ln2134"> *		or  concat \&amp; concat</a>
<a name="ln2135"> *		or  concat \&amp; concat \&amp; concat</a>
<a name="ln2136"> *		etc.</a>
<a name="ln2137"> */</a>
<a name="ln2138">static int nfa_regbranch(void)</a>
<a name="ln2139">{</a>
<a name="ln2140">  int old_post_pos;</a>
<a name="ln2141"> </a>
<a name="ln2142">  old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2143"> </a>
<a name="ln2144">  /* First branch, possibly the only one */</a>
<a name="ln2145">  if (nfa_regconcat() == FAIL)</a>
<a name="ln2146">    return FAIL;</a>
<a name="ln2147"> </a>
<a name="ln2148">  // Try next concats</a>
<a name="ln2149">  while (peekchr() == Magic('&amp;')) {</a>
<a name="ln2150">    skipchr();</a>
<a name="ln2151">    // if concat is empty do emit a node</a>
<a name="ln2152">    if (old_post_pos == (int)(post_ptr - post_start)) {</a>
<a name="ln2153">      EMIT(NFA_EMPTY);</a>
<a name="ln2154">    }</a>
<a name="ln2155">    EMIT(NFA_NOPEN);</a>
<a name="ln2156">    EMIT(NFA_PREV_ATOM_NO_WIDTH);</a>
<a name="ln2157">    old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2158">    if (nfa_regconcat() == FAIL)</a>
<a name="ln2159">      return FAIL;</a>
<a name="ln2160">    /* if concat is empty do emit a node */</a>
<a name="ln2161">    if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2162">      EMIT(NFA_EMPTY);</a>
<a name="ln2163">    EMIT(NFA_CONCAT);</a>
<a name="ln2164">  }</a>
<a name="ln2165"> </a>
<a name="ln2166">  /* if a branch is empty, emit one node for it */</a>
<a name="ln2167">  if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2168">    EMIT(NFA_EMPTY);</a>
<a name="ln2169"> </a>
<a name="ln2170">  return OK;</a>
<a name="ln2171">}</a>
<a name="ln2172"> </a>
<a name="ln2173">/*</a>
<a name="ln2174"> *  Parse a pattern, one or more branches, separated by &quot;\|&quot;.  It matches</a>
<a name="ln2175"> *  anything that matches one of the branches.  Example: &quot;foo\|beep&quot; matches</a>
<a name="ln2176"> *  &quot;foo&quot; and matches &quot;beep&quot;.  If more than one branch matches, the first one</a>
<a name="ln2177"> *  is used.</a>
<a name="ln2178"> *</a>
<a name="ln2179"> *  pattern ::=	    branch</a>
<a name="ln2180"> *	or  branch \| branch</a>
<a name="ln2181"> *	or  branch \| branch \| branch</a>
<a name="ln2182"> *	etc.</a>
<a name="ln2183"> */</a>
<a name="ln2184">static int </a>
<a name="ln2185">nfa_reg (</a>
<a name="ln2186">    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */</a>
<a name="ln2187">)</a>
<a name="ln2188">{</a>
<a name="ln2189">  int parno = 0;</a>
<a name="ln2190"> </a>
<a name="ln2191">  if (paren == REG_PAREN) {</a>
<a name="ln2192">    if (regnpar &gt;= NSUBEXP)     /* Too many `(' */</a>
<a name="ln2193">      EMSG_RET_FAIL(_(&quot;E872: (NFA regexp) Too many '('&quot;));</a>
<a name="ln2194">    parno = regnpar++;</a>
<a name="ln2195">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2196">    /* Make a ZOPEN node. */</a>
<a name="ln2197">    if (regnzpar &gt;= NSUBEXP)</a>
<a name="ln2198">      EMSG_RET_FAIL(_(&quot;E879: (NFA regexp) Too many \\z(&quot;));</a>
<a name="ln2199">    parno = regnzpar++;</a>
<a name="ln2200">  }</a>
<a name="ln2201"> </a>
<a name="ln2202">  if (nfa_regbranch() == FAIL)</a>
<a name="ln2203">    return FAIL;            /* cascaded error */</a>
<a name="ln2204"> </a>
<a name="ln2205">  while (peekchr() == Magic('|')) {</a>
<a name="ln2206">    skipchr();</a>
<a name="ln2207">    if (nfa_regbranch() == FAIL)</a>
<a name="ln2208">      return FAIL;          /* cascaded error */</a>
<a name="ln2209">    EMIT(NFA_OR);</a>
<a name="ln2210">  }</a>
<a name="ln2211"> </a>
<a name="ln2212">  /* Check for proper termination. */</a>
<a name="ln2213">  if (paren != REG_NOPAREN &amp;&amp; getchr() != Magic(')')) {</a>
<a name="ln2214">    if (paren == REG_NPAREN)</a>
<a name="ln2215">      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);</a>
<a name="ln2216">    else</a>
<a name="ln2217">      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);</a>
<a name="ln2218">  } else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL) {</a>
<a name="ln2219">    if (peekchr() == Magic(')'))</a>
<a name="ln2220">      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);</a>
<a name="ln2221">    else</a>
<a name="ln2222">      EMSG_RET_FAIL(_(&quot;E873: (NFA regexp) proper termination error&quot;));</a>
<a name="ln2223">  }</a>
<a name="ln2224">  // Here we set the flag allowing back references to this set of</a>
<a name="ln2225">  // parentheses.</a>
<a name="ln2226">  if (paren == REG_PAREN) {</a>
<a name="ln2227">    had_endbrace[parno] = true;  // have seen the close paren</a>
<a name="ln2228">    EMIT(NFA_MOPEN + parno);</a>
<a name="ln2229">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2230">    EMIT(NFA_ZOPEN + parno);</a>
<a name="ln2231">  }</a>
<a name="ln2232"> </a>
<a name="ln2233">  return OK;</a>
<a name="ln2234">}</a>
<a name="ln2235"> </a>
<a name="ln2236">#ifdef REGEXP_DEBUG</a>
<a name="ln2237">static char_u code[50];</a>
<a name="ln2238"> </a>
<a name="ln2239">static void nfa_set_code(int c)</a>
<a name="ln2240">{</a>
<a name="ln2241">  int addnl = false;</a>
<a name="ln2242"> </a>
<a name="ln2243">  if (c &gt;= NFA_FIRST_NL &amp;&amp; c &lt;= NFA_LAST_NL) {</a>
<a name="ln2244">    addnl = true;</a>
<a name="ln2245">    c -= NFA_ADD_NL;</a>
<a name="ln2246">  }</a>
<a name="ln2247"> </a>
<a name="ln2248">  STRCPY(code, &quot;&quot;);</a>
<a name="ln2249">  switch (c) {</a>
<a name="ln2250">  case NFA_MATCH:     STRCPY(code, &quot;NFA_MATCH &quot;); break;</a>
<a name="ln2251">  case NFA_SPLIT:     STRCPY(code, &quot;NFA_SPLIT &quot;); break;</a>
<a name="ln2252">  case NFA_CONCAT:    STRCPY(code, &quot;NFA_CONCAT &quot;); break;</a>
<a name="ln2253">  case NFA_NEWL:      STRCPY(code, &quot;NFA_NEWL &quot;); break;</a>
<a name="ln2254">  case NFA_ZSTART:    STRCPY(code, &quot;NFA_ZSTART&quot;); break;</a>
<a name="ln2255">  case NFA_ZEND:      STRCPY(code, &quot;NFA_ZEND&quot;); break;</a>
<a name="ln2256"> </a>
<a name="ln2257">  case NFA_BACKREF1:  STRCPY(code, &quot;NFA_BACKREF1&quot;); break;</a>
<a name="ln2258">  case NFA_BACKREF2:  STRCPY(code, &quot;NFA_BACKREF2&quot;); break;</a>
<a name="ln2259">  case NFA_BACKREF3:  STRCPY(code, &quot;NFA_BACKREF3&quot;); break;</a>
<a name="ln2260">  case NFA_BACKREF4:  STRCPY(code, &quot;NFA_BACKREF4&quot;); break;</a>
<a name="ln2261">  case NFA_BACKREF5:  STRCPY(code, &quot;NFA_BACKREF5&quot;); break;</a>
<a name="ln2262">  case NFA_BACKREF6:  STRCPY(code, &quot;NFA_BACKREF6&quot;); break;</a>
<a name="ln2263">  case NFA_BACKREF7:  STRCPY(code, &quot;NFA_BACKREF7&quot;); break;</a>
<a name="ln2264">  case NFA_BACKREF8:  STRCPY(code, &quot;NFA_BACKREF8&quot;); break;</a>
<a name="ln2265">  case NFA_BACKREF9:  STRCPY(code, &quot;NFA_BACKREF9&quot;); break;</a>
<a name="ln2266">  case NFA_ZREF1:     STRCPY(code, &quot;NFA_ZREF1&quot;); break;</a>
<a name="ln2267">  case NFA_ZREF2:     STRCPY(code, &quot;NFA_ZREF2&quot;); break;</a>
<a name="ln2268">  case NFA_ZREF3:     STRCPY(code, &quot;NFA_ZREF3&quot;); break;</a>
<a name="ln2269">  case NFA_ZREF4:     STRCPY(code, &quot;NFA_ZREF4&quot;); break;</a>
<a name="ln2270">  case NFA_ZREF5:     STRCPY(code, &quot;NFA_ZREF5&quot;); break;</a>
<a name="ln2271">  case NFA_ZREF6:     STRCPY(code, &quot;NFA_ZREF6&quot;); break;</a>
<a name="ln2272">  case NFA_ZREF7:     STRCPY(code, &quot;NFA_ZREF7&quot;); break;</a>
<a name="ln2273">  case NFA_ZREF8:     STRCPY(code, &quot;NFA_ZREF8&quot;); break;</a>
<a name="ln2274">  case NFA_ZREF9:     STRCPY(code, &quot;NFA_ZREF9&quot;); break;</a>
<a name="ln2275">  case NFA_SKIP:      STRCPY(code, &quot;NFA_SKIP&quot;); break;</a>
<a name="ln2276"> </a>
<a name="ln2277">  case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln2278">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH&quot;); break;</a>
<a name="ln2279">  case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln2280">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH_NEG&quot;); break;</a>
<a name="ln2281">  case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln2282">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE&quot;); break;</a>
<a name="ln2283">  case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln2284">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE_NEG&quot;); break;</a>
<a name="ln2285">  case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln2286">    STRCPY(code, &quot;NFA_PREV_ATOM_LIKE_PATTERN&quot;); break;</a>
<a name="ln2287"> </a>
<a name="ln2288">  case NFA_NOPEN:             STRCPY(code, &quot;NFA_NOPEN&quot;); break;</a>
<a name="ln2289">  case NFA_NCLOSE:            STRCPY(code, &quot;NFA_NCLOSE&quot;); break;</a>
<a name="ln2290">  case NFA_START_INVISIBLE:   STRCPY(code, &quot;NFA_START_INVISIBLE&quot;); break;</a>
<a name="ln2291">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln2292">    STRCPY(code, &quot;NFA_START_INVISIBLE_FIRST&quot;); break;</a>
<a name="ln2293">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2294">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2295">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln2296">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG_FIRST&quot;); break;</a>
<a name="ln2297">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2298">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE&quot;); break;</a>
<a name="ln2299">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln2300">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_FIRST&quot;); break;</a>
<a name="ln2301">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2302">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG&quot;); break;</a>
<a name="ln2303">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln2304">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG_FIRST&quot;); break;</a>
<a name="ln2305">  case NFA_START_PATTERN:   STRCPY(code, &quot;NFA_START_PATTERN&quot;); break;</a>
<a name="ln2306">  case NFA_END_INVISIBLE:     STRCPY(code, &quot;NFA_END_INVISIBLE&quot;); break;</a>
<a name="ln2307">  case NFA_END_INVISIBLE_NEG: STRCPY(code, &quot;NFA_END_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2308">  case NFA_END_PATTERN:       STRCPY(code, &quot;NFA_END_PATTERN&quot;); break;</a>
<a name="ln2309"> </a>
<a name="ln2310">  case NFA_COMPOSING:         STRCPY(code, &quot;NFA_COMPOSING&quot;); break;</a>
<a name="ln2311">  case NFA_END_COMPOSING:     STRCPY(code, &quot;NFA_END_COMPOSING&quot;); break;</a>
<a name="ln2312">  case NFA_OPT_CHARS:         STRCPY(code, &quot;NFA_OPT_CHARS&quot;); break;</a>
<a name="ln2313"> </a>
<a name="ln2314">  case NFA_MOPEN:</a>
<a name="ln2315">  case NFA_MOPEN1:</a>
<a name="ln2316">  case NFA_MOPEN2:</a>
<a name="ln2317">  case NFA_MOPEN3:</a>
<a name="ln2318">  case NFA_MOPEN4:</a>
<a name="ln2319">  case NFA_MOPEN5:</a>
<a name="ln2320">  case NFA_MOPEN6:</a>
<a name="ln2321">  case NFA_MOPEN7:</a>
<a name="ln2322">  case NFA_MOPEN8:</a>
<a name="ln2323">  case NFA_MOPEN9:</a>
<a name="ln2324">    STRCPY(code, &quot;NFA_MOPEN(x)&quot;);</a>
<a name="ln2325">    code[10] = c - NFA_MOPEN + '0';</a>
<a name="ln2326">    break;</a>
<a name="ln2327">  case NFA_MCLOSE:</a>
<a name="ln2328">  case NFA_MCLOSE1:</a>
<a name="ln2329">  case NFA_MCLOSE2:</a>
<a name="ln2330">  case NFA_MCLOSE3:</a>
<a name="ln2331">  case NFA_MCLOSE4:</a>
<a name="ln2332">  case NFA_MCLOSE5:</a>
<a name="ln2333">  case NFA_MCLOSE6:</a>
<a name="ln2334">  case NFA_MCLOSE7:</a>
<a name="ln2335">  case NFA_MCLOSE8:</a>
<a name="ln2336">  case NFA_MCLOSE9:</a>
<a name="ln2337">    STRCPY(code, &quot;NFA_MCLOSE(x)&quot;);</a>
<a name="ln2338">    code[11] = c - NFA_MCLOSE + '0';</a>
<a name="ln2339">    break;</a>
<a name="ln2340">  case NFA_ZOPEN:</a>
<a name="ln2341">  case NFA_ZOPEN1:</a>
<a name="ln2342">  case NFA_ZOPEN2:</a>
<a name="ln2343">  case NFA_ZOPEN3:</a>
<a name="ln2344">  case NFA_ZOPEN4:</a>
<a name="ln2345">  case NFA_ZOPEN5:</a>
<a name="ln2346">  case NFA_ZOPEN6:</a>
<a name="ln2347">  case NFA_ZOPEN7:</a>
<a name="ln2348">  case NFA_ZOPEN8:</a>
<a name="ln2349">  case NFA_ZOPEN9:</a>
<a name="ln2350">    STRCPY(code, &quot;NFA_ZOPEN(x)&quot;);</a>
<a name="ln2351">    code[10] = c - NFA_ZOPEN + '0';</a>
<a name="ln2352">    break;</a>
<a name="ln2353">  case NFA_ZCLOSE:</a>
<a name="ln2354">  case NFA_ZCLOSE1:</a>
<a name="ln2355">  case NFA_ZCLOSE2:</a>
<a name="ln2356">  case NFA_ZCLOSE3:</a>
<a name="ln2357">  case NFA_ZCLOSE4:</a>
<a name="ln2358">  case NFA_ZCLOSE5:</a>
<a name="ln2359">  case NFA_ZCLOSE6:</a>
<a name="ln2360">  case NFA_ZCLOSE7:</a>
<a name="ln2361">  case NFA_ZCLOSE8:</a>
<a name="ln2362">  case NFA_ZCLOSE9:</a>
<a name="ln2363">    STRCPY(code, &quot;NFA_ZCLOSE(x)&quot;);</a>
<a name="ln2364">    code[11] = c - NFA_ZCLOSE + '0';</a>
<a name="ln2365">    break;</a>
<a name="ln2366">  case NFA_EOL:           STRCPY(code, &quot;NFA_EOL &quot;); break;</a>
<a name="ln2367">  case NFA_BOL:           STRCPY(code, &quot;NFA_BOL &quot;); break;</a>
<a name="ln2368">  case NFA_EOW:           STRCPY(code, &quot;NFA_EOW &quot;); break;</a>
<a name="ln2369">  case NFA_BOW:           STRCPY(code, &quot;NFA_BOW &quot;); break;</a>
<a name="ln2370">  case NFA_EOF:           STRCPY(code, &quot;NFA_EOF &quot;); break;</a>
<a name="ln2371">  case NFA_BOF:           STRCPY(code, &quot;NFA_BOF &quot;); break;</a>
<a name="ln2372">  case NFA_LNUM:          STRCPY(code, &quot;NFA_LNUM &quot;); break;</a>
<a name="ln2373">  case NFA_LNUM_GT:       STRCPY(code, &quot;NFA_LNUM_GT &quot;); break;</a>
<a name="ln2374">  case NFA_LNUM_LT:       STRCPY(code, &quot;NFA_LNUM_LT &quot;); break;</a>
<a name="ln2375">  case NFA_COL:           STRCPY(code, &quot;NFA_COL &quot;); break;</a>
<a name="ln2376">  case NFA_COL_GT:        STRCPY(code, &quot;NFA_COL_GT &quot;); break;</a>
<a name="ln2377">  case NFA_COL_LT:        STRCPY(code, &quot;NFA_COL_LT &quot;); break;</a>
<a name="ln2378">  case NFA_VCOL:          STRCPY(code, &quot;NFA_VCOL &quot;); break;</a>
<a name="ln2379">  case NFA_VCOL_GT:       STRCPY(code, &quot;NFA_VCOL_GT &quot;); break;</a>
<a name="ln2380">  case NFA_VCOL_LT:       STRCPY(code, &quot;NFA_VCOL_LT &quot;); break;</a>
<a name="ln2381">  case NFA_MARK:          STRCPY(code, &quot;NFA_MARK &quot;); break;</a>
<a name="ln2382">  case NFA_MARK_GT:       STRCPY(code, &quot;NFA_MARK_GT &quot;); break;</a>
<a name="ln2383">  case NFA_MARK_LT:       STRCPY(code, &quot;NFA_MARK_LT &quot;); break;</a>
<a name="ln2384">  case NFA_CURSOR:        STRCPY(code, &quot;NFA_CURSOR &quot;); break;</a>
<a name="ln2385">  case NFA_VISUAL:        STRCPY(code, &quot;NFA_VISUAL &quot;); break;</a>
<a name="ln2386">  case NFA_ANY_COMPOSING: STRCPY(code, &quot;NFA_ANY_COMPOSING &quot;); break;</a>
<a name="ln2387"> </a>
<a name="ln2388">  case NFA_STAR:          STRCPY(code, &quot;NFA_STAR &quot;); break;</a>
<a name="ln2389">  case NFA_STAR_NONGREEDY: STRCPY(code, &quot;NFA_STAR_NONGREEDY &quot;); break;</a>
<a name="ln2390">  case NFA_QUEST:         STRCPY(code, &quot;NFA_QUEST&quot;); break;</a>
<a name="ln2391">  case NFA_QUEST_NONGREEDY: STRCPY(code, &quot;NFA_QUEST_NON_GREEDY&quot;); break;</a>
<a name="ln2392">  case NFA_EMPTY:         STRCPY(code, &quot;NFA_EMPTY&quot;); break;</a>
<a name="ln2393">  case NFA_OR:            STRCPY(code, &quot;NFA_OR&quot;); break;</a>
<a name="ln2394"> </a>
<a name="ln2395">  case NFA_START_COLL:    STRCPY(code, &quot;NFA_START_COLL&quot;); break;</a>
<a name="ln2396">  case NFA_END_COLL:      STRCPY(code, &quot;NFA_END_COLL&quot;); break;</a>
<a name="ln2397">  case NFA_START_NEG_COLL: STRCPY(code, &quot;NFA_START_NEG_COLL&quot;); break;</a>
<a name="ln2398">  case NFA_END_NEG_COLL:  STRCPY(code, &quot;NFA_END_NEG_COLL&quot;); break;</a>
<a name="ln2399">  case NFA_RANGE:         STRCPY(code, &quot;NFA_RANGE&quot;); break;</a>
<a name="ln2400">  case NFA_RANGE_MIN:     STRCPY(code, &quot;NFA_RANGE_MIN&quot;); break;</a>
<a name="ln2401">  case NFA_RANGE_MAX:     STRCPY(code, &quot;NFA_RANGE_MAX&quot;); break;</a>
<a name="ln2402"> </a>
<a name="ln2403">  case NFA_CLASS_ALNUM:   STRCPY(code, &quot;NFA_CLASS_ALNUM&quot;); break;</a>
<a name="ln2404">  case NFA_CLASS_ALPHA:   STRCPY(code, &quot;NFA_CLASS_ALPHA&quot;); break;</a>
<a name="ln2405">  case NFA_CLASS_BLANK:   STRCPY(code, &quot;NFA_CLASS_BLANK&quot;); break;</a>
<a name="ln2406">  case NFA_CLASS_CNTRL:   STRCPY(code, &quot;NFA_CLASS_CNTRL&quot;); break;</a>
<a name="ln2407">  case NFA_CLASS_DIGIT:   STRCPY(code, &quot;NFA_CLASS_DIGIT&quot;); break;</a>
<a name="ln2408">  case NFA_CLASS_GRAPH:   STRCPY(code, &quot;NFA_CLASS_GRAPH&quot;); break;</a>
<a name="ln2409">  case NFA_CLASS_LOWER:   STRCPY(code, &quot;NFA_CLASS_LOWER&quot;); break;</a>
<a name="ln2410">  case NFA_CLASS_PRINT:   STRCPY(code, &quot;NFA_CLASS_PRINT&quot;); break;</a>
<a name="ln2411">  case NFA_CLASS_PUNCT:   STRCPY(code, &quot;NFA_CLASS_PUNCT&quot;); break;</a>
<a name="ln2412">  case NFA_CLASS_SPACE:   STRCPY(code, &quot;NFA_CLASS_SPACE&quot;); break;</a>
<a name="ln2413">  case NFA_CLASS_UPPER:   STRCPY(code, &quot;NFA_CLASS_UPPER&quot;); break;</a>
<a name="ln2414">  case NFA_CLASS_XDIGIT:  STRCPY(code, &quot;NFA_CLASS_XDIGIT&quot;); break;</a>
<a name="ln2415">  case NFA_CLASS_TAB:     STRCPY(code, &quot;NFA_CLASS_TAB&quot;); break;</a>
<a name="ln2416">  case NFA_CLASS_RETURN:  STRCPY(code, &quot;NFA_CLASS_RETURN&quot;); break;</a>
<a name="ln2417">  case NFA_CLASS_BACKSPACE:   STRCPY(code, &quot;NFA_CLASS_BACKSPACE&quot;); break;</a>
<a name="ln2418">  case NFA_CLASS_ESCAPE:  STRCPY(code, &quot;NFA_CLASS_ESCAPE&quot;); break;</a>
<a name="ln2419">  case NFA_CLASS_IDENT:   STRCPY(code, &quot;NFA_CLASS_IDENT&quot;); break;</a>
<a name="ln2420">  case NFA_CLASS_KEYWORD: STRCPY(code, &quot;NFA_CLASS_KEYWORD&quot;); break;</a>
<a name="ln2421">  case NFA_CLASS_FNAME:   STRCPY(code, &quot;NFA_CLASS_FNAME&quot;); break;</a>
<a name="ln2422"> </a>
<a name="ln2423">  case NFA_ANY:   STRCPY(code, &quot;NFA_ANY&quot;); break;</a>
<a name="ln2424">  case NFA_IDENT: STRCPY(code, &quot;NFA_IDENT&quot;); break;</a>
<a name="ln2425">  case NFA_SIDENT: STRCPY(code, &quot;NFA_SIDENT&quot;); break;</a>
<a name="ln2426">  case NFA_KWORD: STRCPY(code, &quot;NFA_KWORD&quot;); break;</a>
<a name="ln2427">  case NFA_SKWORD: STRCPY(code, &quot;NFA_SKWORD&quot;); break;</a>
<a name="ln2428">  case NFA_FNAME: STRCPY(code, &quot;NFA_FNAME&quot;); break;</a>
<a name="ln2429">  case NFA_SFNAME: STRCPY(code, &quot;NFA_SFNAME&quot;); break;</a>
<a name="ln2430">  case NFA_PRINT: STRCPY(code, &quot;NFA_PRINT&quot;); break;</a>
<a name="ln2431">  case NFA_SPRINT: STRCPY(code, &quot;NFA_SPRINT&quot;); break;</a>
<a name="ln2432">  case NFA_WHITE: STRCPY(code, &quot;NFA_WHITE&quot;); break;</a>
<a name="ln2433">  case NFA_NWHITE: STRCPY(code, &quot;NFA_NWHITE&quot;); break;</a>
<a name="ln2434">  case NFA_DIGIT: STRCPY(code, &quot;NFA_DIGIT&quot;); break;</a>
<a name="ln2435">  case NFA_NDIGIT: STRCPY(code, &quot;NFA_NDIGIT&quot;); break;</a>
<a name="ln2436">  case NFA_HEX:   STRCPY(code, &quot;NFA_HEX&quot;); break;</a>
<a name="ln2437">  case NFA_NHEX:  STRCPY(code, &quot;NFA_NHEX&quot;); break;</a>
<a name="ln2438">  case NFA_OCTAL: STRCPY(code, &quot;NFA_OCTAL&quot;); break;</a>
<a name="ln2439">  case NFA_NOCTAL: STRCPY(code, &quot;NFA_NOCTAL&quot;); break;</a>
<a name="ln2440">  case NFA_WORD:  STRCPY(code, &quot;NFA_WORD&quot;); break;</a>
<a name="ln2441">  case NFA_NWORD: STRCPY(code, &quot;NFA_NWORD&quot;); break;</a>
<a name="ln2442">  case NFA_HEAD:  STRCPY(code, &quot;NFA_HEAD&quot;); break;</a>
<a name="ln2443">  case NFA_NHEAD: STRCPY(code, &quot;NFA_NHEAD&quot;); break;</a>
<a name="ln2444">  case NFA_ALPHA: STRCPY(code, &quot;NFA_ALPHA&quot;); break;</a>
<a name="ln2445">  case NFA_NALPHA: STRCPY(code, &quot;NFA_NALPHA&quot;); break;</a>
<a name="ln2446">  case NFA_LOWER: STRCPY(code, &quot;NFA_LOWER&quot;); break;</a>
<a name="ln2447">  case NFA_NLOWER: STRCPY(code, &quot;NFA_NLOWER&quot;); break;</a>
<a name="ln2448">  case NFA_UPPER: STRCPY(code, &quot;NFA_UPPER&quot;); break;</a>
<a name="ln2449">  case NFA_NUPPER: STRCPY(code, &quot;NFA_NUPPER&quot;); break;</a>
<a name="ln2450">  case NFA_LOWER_IC:  STRCPY(code, &quot;NFA_LOWER_IC&quot;); break;</a>
<a name="ln2451">  case NFA_NLOWER_IC: STRCPY(code, &quot;NFA_NLOWER_IC&quot;); break;</a>
<a name="ln2452">  case NFA_UPPER_IC:  STRCPY(code, &quot;NFA_UPPER_IC&quot;); break;</a>
<a name="ln2453">  case NFA_NUPPER_IC: STRCPY(code, &quot;NFA_NUPPER_IC&quot;); break;</a>
<a name="ln2454"> </a>
<a name="ln2455">  default:</a>
<a name="ln2456">    STRCPY(code, &quot;CHAR(x)&quot;);</a>
<a name="ln2457">    code[5] = c;</a>
<a name="ln2458">  }</a>
<a name="ln2459"> </a>
<a name="ln2460">  if (addnl == true) {</a>
<a name="ln2461">    STRCAT(code, &quot; + NEWLINE &quot;);</a>
<a name="ln2462">  }</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">static FILE *log_fd;</a>
<a name="ln2466">static char_u e_log_open_failed[] = N_(</a>
<a name="ln2467">    &quot;Could not open temporary log file for writing, displaying on stderr... &quot;);</a>
<a name="ln2468"> </a>
<a name="ln2469">/*</a>
<a name="ln2470"> * Print the postfix notation of the current regexp.</a>
<a name="ln2471"> */</a>
<a name="ln2472">static void nfa_postfix_dump(char_u *expr, int retval)</a>
<a name="ln2473">{</a>
<a name="ln2474">  int *p;</a>
<a name="ln2475">  FILE *f;</a>
<a name="ln2476"> </a>
<a name="ln2477">  f = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2478">  if (f != NULL) {</a>
<a name="ln2479">    fprintf(f, &quot;\n-------------------------\n&quot;);</a>
<a name="ln2480">    if (retval == FAIL) {</a>
<a name="ln2481">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine failed... \n&quot;);</a>
<a name="ln2482">    } else if (retval == OK) {</a>
<a name="ln2483">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine succeeded !\n&quot;);</a>
<a name="ln2484">    }</a>
<a name="ln2485">    fprintf(f, &quot;Regexp: \&quot;%s\&quot;\nPostfix notation (char): \&quot;&quot;, expr);</a>
<a name="ln2486">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++) {</a>
<a name="ln2487">      nfa_set_code(*p);</a>
<a name="ln2488">      fprintf(f, &quot;%s, &quot;, code);</a>
<a name="ln2489">    }</a>
<a name="ln2490">    fprintf(f, &quot;\&quot;\nPostfix notation (int): &quot;);</a>
<a name="ln2491">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++)</a>
<a name="ln2492">      fprintf(f, &quot;%d &quot;, *p);</a>
<a name="ln2493">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln2494">    fclose(f);</a>
<a name="ln2495">  }</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498">/*</a>
<a name="ln2499"> * Print the NFA starting with a root node &quot;state&quot;.</a>
<a name="ln2500"> */</a>
<a name="ln2501">static void nfa_print_state(FILE *debugf, nfa_state_T *state)</a>
<a name="ln2502">{</a>
<a name="ln2503">  garray_T indent;</a>
<a name="ln2504"> </a>
<a name="ln2505">  ga_init(&amp;indent, 1, 64);</a>
<a name="ln2506">  ga_append(&amp;indent, '\0');</a>
<a name="ln2507">  nfa_print_state2(debugf, state, &amp;indent);</a>
<a name="ln2508">  ga_clear(&amp;indent);</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">static void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)</a>
<a name="ln2512">{</a>
<a name="ln2513">  char_u  *p;</a>
<a name="ln2514"> </a>
<a name="ln2515">  if (state == NULL)</a>
<a name="ln2516">    return;</a>
<a name="ln2517"> </a>
<a name="ln2518">  fprintf(debugf, &quot;(%2d)&quot;, abs(state-&gt;id));</a>
<a name="ln2519"> </a>
<a name="ln2520">  /* Output indent */</a>
<a name="ln2521">  p = (char_u *)indent-&gt;ga_data;</a>
<a name="ln2522">  if (indent-&gt;ga_len &gt;= 3) {</a>
<a name="ln2523">    int last = indent-&gt;ga_len - 3;</a>
<a name="ln2524">    char_u save[2];</a>
<a name="ln2525"> </a>
<a name="ln2526">    STRNCPY(save, &amp;p[last], 2);</a>
<a name="ln2527">    STRNCPY(&amp;p[last], &quot;+-&quot;, 2);</a>
<a name="ln2528">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2529">    STRNCPY(&amp;p[last], save, 2);</a>
<a name="ln2530">  } else</a>
<a name="ln2531">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2532"> </a>
<a name="ln2533">  nfa_set_code(state-&gt;c);</a>
<a name="ln2534">  fprintf(debugf, &quot;%s (%d) (id=%d) val=%d\n&quot;,</a>
<a name="ln2535">      code,</a>
<a name="ln2536">      state-&gt;c,</a>
<a name="ln2537">      abs(state-&gt;id),</a>
<a name="ln2538">      state-&gt;val);</a>
<a name="ln2539">  if (state-&gt;id &lt; 0)</a>
<a name="ln2540">    return;</a>
<a name="ln2541"> </a>
<a name="ln2542">  state-&gt;id = abs(state-&gt;id) * -1;</a>
<a name="ln2543"> </a>
<a name="ln2544">  /* grow indent for state-&gt;out */</a>
<a name="ln2545">  indent-&gt;ga_len -= 1;</a>
<a name="ln2546">  if (state-&gt;out1)</a>
<a name="ln2547">    ga_concat(indent, (char_u *)&quot;| &quot;);</a>
<a name="ln2548">  else</a>
<a name="ln2549">    ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2550">  ga_append(indent, '\0');</a>
<a name="ln2551"> </a>
<a name="ln2552">  nfa_print_state2(debugf, state-&gt;out, indent);</a>
<a name="ln2553"> </a>
<a name="ln2554">  /* replace last part of indent for state-&gt;out1 */</a>
<a name="ln2555">  indent-&gt;ga_len -= 3;</a>
<a name="ln2556">  ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2557">  ga_append(indent, '\0');</a>
<a name="ln2558"> </a>
<a name="ln2559">  nfa_print_state2(debugf, state-&gt;out1, indent);</a>
<a name="ln2560"> </a>
<a name="ln2561">  /* shrink indent */</a>
<a name="ln2562">  indent-&gt;ga_len -= 3;</a>
<a name="ln2563">  ga_append(indent, '\0');</a>
<a name="ln2564">}</a>
<a name="ln2565"> </a>
<a name="ln2566">/*</a>
<a name="ln2567"> * Print the NFA state machine.</a>
<a name="ln2568"> */</a>
<a name="ln2569">static void nfa_dump(nfa_regprog_T *prog)</a>
<a name="ln2570">{</a>
<a name="ln2571">  FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2572"> </a>
<a name="ln2573">  if (debugf != NULL) {</a>
<a name="ln2574">    nfa_print_state(debugf, prog-&gt;start);</a>
<a name="ln2575"> </a>
<a name="ln2576">    if (prog-&gt;reganch)</a>
<a name="ln2577">      fprintf(debugf, &quot;reganch: %d\n&quot;, prog-&gt;reganch);</a>
<a name="ln2578">    if (prog-&gt;regstart != NUL)</a>
<a name="ln2579">      fprintf(debugf, &quot;regstart: %c (decimal: %d)\n&quot;,</a>
<a name="ln2580">          prog-&gt;regstart, prog-&gt;regstart);</a>
<a name="ln2581">    if (prog-&gt;match_text != NULL)</a>
<a name="ln2582">      fprintf(debugf, &quot;match_text: \&quot;%s\&quot;\n&quot;, prog-&gt;match_text);</a>
<a name="ln2583"> </a>
<a name="ln2584">    fclose(debugf);</a>
<a name="ln2585">  }</a>
<a name="ln2586">}</a>
<a name="ln2587">#endif      /* REGEXP_DEBUG */</a>
<a name="ln2588"> </a>
<a name="ln2589">/*</a>
<a name="ln2590"> * Parse r.e. @expr and convert it into postfix form.</a>
<a name="ln2591"> * Return the postfix string on success, NULL otherwise.</a>
<a name="ln2592"> */</a>
<a name="ln2593">static int *re2post(void)</a>
<a name="ln2594">{</a>
<a name="ln2595">  if (nfa_reg(REG_NOPAREN) == FAIL)</a>
<a name="ln2596">    return NULL;</a>
<a name="ln2597">  EMIT(NFA_MOPEN);</a>
<a name="ln2598">  return post_start;</a>
<a name="ln2599">}</a>
<a name="ln2600"> </a>
<a name="ln2601">/* NB. Some of the code below is inspired by Russ's. */</a>
<a name="ln2602"> </a>
<a name="ln2603">/*</a>
<a name="ln2604"> * Represents an NFA state plus zero or one or two arrows exiting.</a>
<a name="ln2605"> * if c == MATCH, no arrows out; matching state.</a>
<a name="ln2606"> * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).</a>
<a name="ln2607"> * If c &lt; 256, labeled arrow with character c to out.</a>
<a name="ln2608"> */</a>
<a name="ln2609"> </a>
<a name="ln2610">static nfa_state_T      *state_ptr; /* points to nfa_prog-&gt;state */</a>
<a name="ln2611"> </a>
<a name="ln2612">/*</a>
<a name="ln2613"> * Allocate and initialize nfa_state_T.</a>
<a name="ln2614"> */</a>
<a name="ln2615">static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)</a>
<a name="ln2616">{</a>
<a name="ln2617">  nfa_state_T *s;</a>
<a name="ln2618"> </a>
<a name="ln2619">  if (istate &gt;= nstate)</a>
<a name="ln2620">    return NULL;</a>
<a name="ln2621"> </a>
<a name="ln2622">  s = &amp;state_ptr[istate++];</a>
<a name="ln2623"> </a>
<a name="ln2624">  s-&gt;c    = c;</a>
<a name="ln2625">  s-&gt;out  = out;</a>
<a name="ln2626">  s-&gt;out1 = out1;</a>
<a name="ln2627">  s-&gt;val  = 0;</a>
<a name="ln2628"> </a>
<a name="ln2629">  s-&gt;id   = istate;</a>
<a name="ln2630">  s-&gt;lastlist[0] = 0;</a>
<a name="ln2631">  s-&gt;lastlist[1] = 0;</a>
<a name="ln2632"> </a>
<a name="ln2633">  return s;</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636">/*</a>
<a name="ln2637"> * A partially built NFA without the matching state filled in.</a>
<a name="ln2638"> * Frag_T.start points at the start state.</a>
<a name="ln2639"> * Frag_T.out is a list of places that need to be set to the</a>
<a name="ln2640"> * next state for this fragment.</a>
<a name="ln2641"> */</a>
<a name="ln2642"> </a>
<a name="ln2643"> </a>
<a name="ln2644">/*</a>
<a name="ln2645"> * Initialize a Frag_T struct and return it.</a>
<a name="ln2646"> */</a>
<a name="ln2647">static Frag_T frag(nfa_state_T *start, Ptrlist *out)</a>
<a name="ln2648">{</a>
<a name="ln2649">  Frag_T n;</a>
<a name="ln2650"> </a>
<a name="ln2651">  n.start = start;</a>
<a name="ln2652">  n.out = out;</a>
<a name="ln2653">  return n;</a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">/*</a>
<a name="ln2657"> * Create singleton list containing just outp.</a>
<a name="ln2658"> */</a>
<a name="ln2659">static Ptrlist *list1(nfa_state_T **outp)</a>
<a name="ln2660">{</a>
<a name="ln2661">  Ptrlist *l;</a>
<a name="ln2662"> </a>
<a name="ln2663">  l = (Ptrlist *)outp;</a>
<a name="ln2664">  l-&gt;next = NULL;</a>
<a name="ln2665">  return l;</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">/*</a>
<a name="ln2669"> * Patch the list of states at out to point to start.</a>
<a name="ln2670"> */</a>
<a name="ln2671">static void patch(Ptrlist *l, nfa_state_T *s)</a>
<a name="ln2672">{</a>
<a name="ln2673">  Ptrlist *next;</a>
<a name="ln2674"> </a>
<a name="ln2675">  for (; l; l = next) {</a>
<a name="ln2676">    next = l-&gt;next;</a>
<a name="ln2677">    l-&gt;s = s;</a>
<a name="ln2678">  }</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681"> </a>
<a name="ln2682">/*</a>
<a name="ln2683"> * Join the two lists l1 and l2, returning the combination.</a>
<a name="ln2684"> */</a>
<a name="ln2685">static Ptrlist *append(Ptrlist *l1, Ptrlist *l2)</a>
<a name="ln2686">{</a>
<a name="ln2687">  Ptrlist *oldl1;</a>
<a name="ln2688"> </a>
<a name="ln2689">  oldl1 = l1;</a>
<a name="ln2690">  while (l1-&gt;next)</a>
<a name="ln2691">    l1 = l1-&gt;next;</a>
<a name="ln2692">  l1-&gt;next = l2;</a>
<a name="ln2693">  return oldl1;</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">/*</a>
<a name="ln2697"> * Stack used for transforming postfix form into NFA.</a>
<a name="ln2698"> */</a>
<a name="ln2699">static Frag_T empty;</a>
<a name="ln2700"> </a>
<a name="ln2701">static void st_error(int *postfix, int *end, int *p)</a>
<a name="ln2702">{</a>
<a name="ln2703">#ifdef NFA_REGEXP_ERROR_LOG</a>
<a name="ln2704">  FILE *df;</a>
<a name="ln2705">  int *p2;</a>
<a name="ln2706"> </a>
<a name="ln2707">  df = fopen(NFA_REGEXP_ERROR_LOG, &quot;a&quot;);</a>
<a name="ln2708">  if (df) {</a>
<a name="ln2709">    fprintf(df, &quot;Error popping the stack!\n&quot;);</a>
<a name="ln2710">#ifdef REGEXP_DEBUG</a>
<a name="ln2711">    fprintf(df, &quot;Current regexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln2712">#endif</a>
<a name="ln2713">    fprintf(df, &quot;Postfix form is: &quot;);</a>
<a name="ln2714">#ifdef REGEXP_DEBUG</a>
<a name="ln2715">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2716">      nfa_set_code(*p2);</a>
<a name="ln2717">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2718">    }</a>
<a name="ln2719">    nfa_set_code(*p);</a>
<a name="ln2720">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2721">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2722">      nfa_set_code(*p2);</a>
<a name="ln2723">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2724">    }</a>
<a name="ln2725">#else</a>
<a name="ln2726">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2727">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2728">    }</a>
<a name="ln2729">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2730">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2731">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2732">    }</a>
<a name="ln2733">#endif</a>
<a name="ln2734">    fprintf(df, &quot;\n--------------------------\n&quot;);</a>
<a name="ln2735">    fclose(df);</a>
<a name="ln2736">  }</a>
<a name="ln2737">#endif</a>
<a name="ln2738">  EMSG(_(&quot;E874: (NFA) Could not pop the stack!&quot;));</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">/*</a>
<a name="ln2742"> * Push an item onto the stack.</a>
<a name="ln2743"> */</a>
<a name="ln2744">static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)</a>
<a name="ln2745">{</a>
<a name="ln2746">  Frag_T *stackp = *p;</a>
<a name="ln2747"> </a>
<a name="ln2748">  if (stackp &gt;= stack_end)</a>
<a name="ln2749">    return;</a>
<a name="ln2750">  *stackp = s;</a>
<a name="ln2751">  *p = *p + 1;</a>
<a name="ln2752">}</a>
<a name="ln2753"> </a>
<a name="ln2754">/*</a>
<a name="ln2755"> * Pop an item from the stack.</a>
<a name="ln2756"> */</a>
<a name="ln2757">static Frag_T st_pop(Frag_T **p, Frag_T *stack)</a>
<a name="ln2758">{</a>
<a name="ln2759">  Frag_T *stackp;</a>
<a name="ln2760"> </a>
<a name="ln2761">  *p = *p - 1;</a>
<a name="ln2762">  stackp = *p;</a>
<a name="ln2763">  if (stackp &lt; stack)</a>
<a name="ln2764">    return empty;</a>
<a name="ln2765">  return **p;</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768">/*</a>
<a name="ln2769"> * Estimate the maximum byte length of anything matching &quot;state&quot;.</a>
<a name="ln2770"> * When unknown or unlimited return -1.</a>
<a name="ln2771"> */</a>
<a name="ln2772">static int nfa_max_width(nfa_state_T *startstate, int depth)</a>
<a name="ln2773">{</a>
<a name="ln2774">  int l, r;</a>
<a name="ln2775">  nfa_state_T     *state = startstate;</a>
<a name="ln2776">  int len = 0;</a>
<a name="ln2777"> </a>
<a name="ln2778">  /* detect looping in a NFA_SPLIT */</a>
<a name="ln2779">  if (depth &gt; 4)</a>
<a name="ln2780">    return -1;</a>
<a name="ln2781"> </a>
<a name="ln2782">  while (state != NULL) {</a>
<a name="ln2783">    switch (state-&gt;c) {</a>
<a name="ln2784">    case NFA_END_INVISIBLE:</a>
<a name="ln2785">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln2786">      /* the end, return what we have */</a>
<a name="ln2787">      return len;</a>
<a name="ln2788"> </a>
<a name="ln2789">    case NFA_SPLIT:</a>
<a name="ln2790">      /* two alternatives, use the maximum */</a>
<a name="ln2791">      l = nfa_max_width(state-&gt;out, depth + 1);</a>
<a name="ln2792">      r = nfa_max_width(state-&gt;out1, depth + 1);</a>
<a name="ln2793">      if (l &lt; 0 || r &lt; 0)</a>
<a name="ln2794">        return -1;</a>
<a name="ln2795">      return len + (l &gt; r ? l : r);</a>
<a name="ln2796"> </a>
<a name="ln2797">    case NFA_ANY:</a>
<a name="ln2798">    case NFA_START_COLL:</a>
<a name="ln2799">    case NFA_START_NEG_COLL:</a>
<a name="ln2800">      // Matches some character, including composing chars.</a>
<a name="ln2801">      len += MB_MAXBYTES;</a>
<a name="ln2802">      if (state-&gt;c != NFA_ANY) {</a>
<a name="ln2803">        // Skip over the characters.</a>
<a name="ln2804">        state = state-&gt;out1-&gt;out;</a>
<a name="ln2805">        continue;</a>
<a name="ln2806">      }</a>
<a name="ln2807">      break;</a>
<a name="ln2808"> </a>
<a name="ln2809">    case NFA_DIGIT:</a>
<a name="ln2810">    case NFA_WHITE:</a>
<a name="ln2811">    case NFA_HEX:</a>
<a name="ln2812">    case NFA_OCTAL:</a>
<a name="ln2813">      /* ascii */</a>
<a name="ln2814">      ++len;</a>
<a name="ln2815">      break;</a>
<a name="ln2816"> </a>
<a name="ln2817">    case NFA_IDENT:</a>
<a name="ln2818">    case NFA_SIDENT:</a>
<a name="ln2819">    case NFA_KWORD:</a>
<a name="ln2820">    case NFA_SKWORD:</a>
<a name="ln2821">    case NFA_FNAME:</a>
<a name="ln2822">    case NFA_SFNAME:</a>
<a name="ln2823">    case NFA_PRINT:</a>
<a name="ln2824">    case NFA_SPRINT:</a>
<a name="ln2825">    case NFA_NWHITE:</a>
<a name="ln2826">    case NFA_NDIGIT:</a>
<a name="ln2827">    case NFA_NHEX:</a>
<a name="ln2828">    case NFA_NOCTAL:</a>
<a name="ln2829">    case NFA_WORD:</a>
<a name="ln2830">    case NFA_NWORD:</a>
<a name="ln2831">    case NFA_HEAD:</a>
<a name="ln2832">    case NFA_NHEAD:</a>
<a name="ln2833">    case NFA_ALPHA:</a>
<a name="ln2834">    case NFA_NALPHA:</a>
<a name="ln2835">    case NFA_LOWER:</a>
<a name="ln2836">    case NFA_NLOWER:</a>
<a name="ln2837">    case NFA_UPPER:</a>
<a name="ln2838">    case NFA_NUPPER:</a>
<a name="ln2839">    case NFA_LOWER_IC:</a>
<a name="ln2840">    case NFA_NLOWER_IC:</a>
<a name="ln2841">    case NFA_UPPER_IC:</a>
<a name="ln2842">    case NFA_NUPPER_IC:</a>
<a name="ln2843">    case NFA_ANY_COMPOSING:</a>
<a name="ln2844">      // possibly non-ascii</a>
<a name="ln2845">      len += 3;</a>
<a name="ln2846">      break;</a>
<a name="ln2847"> </a>
<a name="ln2848">    case NFA_START_INVISIBLE:</a>
<a name="ln2849">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2850">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2851">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2852">      /* zero-width, out1 points to the END state */</a>
<a name="ln2853">      state = state-&gt;out1-&gt;out;</a>
<a name="ln2854">      continue;</a>
<a name="ln2855"> </a>
<a name="ln2856">    case NFA_BACKREF1:</a>
<a name="ln2857">    case NFA_BACKREF2:</a>
<a name="ln2858">    case NFA_BACKREF3:</a>
<a name="ln2859">    case NFA_BACKREF4:</a>
<a name="ln2860">    case NFA_BACKREF5:</a>
<a name="ln2861">    case NFA_BACKREF6:</a>
<a name="ln2862">    case NFA_BACKREF7:</a>
<a name="ln2863">    case NFA_BACKREF8:</a>
<a name="ln2864">    case NFA_BACKREF9:</a>
<a name="ln2865">    case NFA_ZREF1:</a>
<a name="ln2866">    case NFA_ZREF2:</a>
<a name="ln2867">    case NFA_ZREF3:</a>
<a name="ln2868">    case NFA_ZREF4:</a>
<a name="ln2869">    case NFA_ZREF5:</a>
<a name="ln2870">    case NFA_ZREF6:</a>
<a name="ln2871">    case NFA_ZREF7:</a>
<a name="ln2872">    case NFA_ZREF8:</a>
<a name="ln2873">    case NFA_ZREF9:</a>
<a name="ln2874">    case NFA_NEWL:</a>
<a name="ln2875">    case NFA_SKIP:</a>
<a name="ln2876">      /* unknown width */</a>
<a name="ln2877">      return -1;</a>
<a name="ln2878"> </a>
<a name="ln2879">    case NFA_BOL:</a>
<a name="ln2880">    case NFA_EOL:</a>
<a name="ln2881">    case NFA_BOF:</a>
<a name="ln2882">    case NFA_EOF:</a>
<a name="ln2883">    case NFA_BOW:</a>
<a name="ln2884">    case NFA_EOW:</a>
<a name="ln2885">    case NFA_MOPEN:</a>
<a name="ln2886">    case NFA_MOPEN1:</a>
<a name="ln2887">    case NFA_MOPEN2:</a>
<a name="ln2888">    case NFA_MOPEN3:</a>
<a name="ln2889">    case NFA_MOPEN4:</a>
<a name="ln2890">    case NFA_MOPEN5:</a>
<a name="ln2891">    case NFA_MOPEN6:</a>
<a name="ln2892">    case NFA_MOPEN7:</a>
<a name="ln2893">    case NFA_MOPEN8:</a>
<a name="ln2894">    case NFA_MOPEN9:</a>
<a name="ln2895">    case NFA_ZOPEN:</a>
<a name="ln2896">    case NFA_ZOPEN1:</a>
<a name="ln2897">    case NFA_ZOPEN2:</a>
<a name="ln2898">    case NFA_ZOPEN3:</a>
<a name="ln2899">    case NFA_ZOPEN4:</a>
<a name="ln2900">    case NFA_ZOPEN5:</a>
<a name="ln2901">    case NFA_ZOPEN6:</a>
<a name="ln2902">    case NFA_ZOPEN7:</a>
<a name="ln2903">    case NFA_ZOPEN8:</a>
<a name="ln2904">    case NFA_ZOPEN9:</a>
<a name="ln2905">    case NFA_ZCLOSE:</a>
<a name="ln2906">    case NFA_ZCLOSE1:</a>
<a name="ln2907">    case NFA_ZCLOSE2:</a>
<a name="ln2908">    case NFA_ZCLOSE3:</a>
<a name="ln2909">    case NFA_ZCLOSE4:</a>
<a name="ln2910">    case NFA_ZCLOSE5:</a>
<a name="ln2911">    case NFA_ZCLOSE6:</a>
<a name="ln2912">    case NFA_ZCLOSE7:</a>
<a name="ln2913">    case NFA_ZCLOSE8:</a>
<a name="ln2914">    case NFA_ZCLOSE9:</a>
<a name="ln2915">    case NFA_MCLOSE:</a>
<a name="ln2916">    case NFA_MCLOSE1:</a>
<a name="ln2917">    case NFA_MCLOSE2:</a>
<a name="ln2918">    case NFA_MCLOSE3:</a>
<a name="ln2919">    case NFA_MCLOSE4:</a>
<a name="ln2920">    case NFA_MCLOSE5:</a>
<a name="ln2921">    case NFA_MCLOSE6:</a>
<a name="ln2922">    case NFA_MCLOSE7:</a>
<a name="ln2923">    case NFA_MCLOSE8:</a>
<a name="ln2924">    case NFA_MCLOSE9:</a>
<a name="ln2925">    case NFA_NOPEN:</a>
<a name="ln2926">    case NFA_NCLOSE:</a>
<a name="ln2927"> </a>
<a name="ln2928">    case NFA_LNUM_GT:</a>
<a name="ln2929">    case NFA_LNUM_LT:</a>
<a name="ln2930">    case NFA_COL_GT:</a>
<a name="ln2931">    case NFA_COL_LT:</a>
<a name="ln2932">    case NFA_VCOL_GT:</a>
<a name="ln2933">    case NFA_VCOL_LT:</a>
<a name="ln2934">    case NFA_MARK_GT:</a>
<a name="ln2935">    case NFA_MARK_LT:</a>
<a name="ln2936">    case NFA_VISUAL:</a>
<a name="ln2937">    case NFA_LNUM:</a>
<a name="ln2938">    case NFA_CURSOR:</a>
<a name="ln2939">    case NFA_COL:</a>
<a name="ln2940">    case NFA_VCOL:</a>
<a name="ln2941">    case NFA_MARK:</a>
<a name="ln2942"> </a>
<a name="ln2943">    case NFA_ZSTART:</a>
<a name="ln2944">    case NFA_ZEND:</a>
<a name="ln2945">    case NFA_OPT_CHARS:</a>
<a name="ln2946">    case NFA_EMPTY:</a>
<a name="ln2947">    case NFA_START_PATTERN:</a>
<a name="ln2948">    case NFA_END_PATTERN:</a>
<a name="ln2949">    case NFA_COMPOSING:</a>
<a name="ln2950">    case NFA_END_COMPOSING:</a>
<a name="ln2951">      /* zero-width */</a>
<a name="ln2952">      break;</a>
<a name="ln2953"> </a>
<a name="ln2954">    default:</a>
<a name="ln2955">      if (state-&gt;c &lt; 0)</a>
<a name="ln2956">        /* don't know what this is */</a>
<a name="ln2957">        return -1;</a>
<a name="ln2958">      /* normal character */</a>
<a name="ln2959">      len += MB_CHAR2LEN(state-&gt;c);</a>
<a name="ln2960">      break;</a>
<a name="ln2961">    }</a>
<a name="ln2962"> </a>
<a name="ln2963">    /* normal way to continue */</a>
<a name="ln2964">    state = state-&gt;out;</a>
<a name="ln2965">  }</a>
<a name="ln2966"> </a>
<a name="ln2967">  /* unrecognized, &quot;cannot happen&quot; */</a>
<a name="ln2968">  return -1;</a>
<a name="ln2969">}</a>
<a name="ln2970"> </a>
<a name="ln2971">/*</a>
<a name="ln2972"> * Convert a postfix form into its equivalent NFA.</a>
<a name="ln2973"> * Return the NFA start state on success, NULL otherwise.</a>
<a name="ln2974"> */</a>
<a name="ln2975">static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size)</a>
<a name="ln2976">{</a>
<a name="ln2977">  int         *p;</a>
<a name="ln2978">  int mopen;</a>
<a name="ln2979">  int mclose;</a>
<a name="ln2980">  Frag_T      *stack = NULL;</a>
<a name="ln2981">  Frag_T      *stackp = NULL;</a>
<a name="ln2982">  Frag_T      *stack_end = NULL;</a>
<a name="ln2983">  Frag_T e1;</a>
<a name="ln2984">  Frag_T e2;</a>
<a name="ln2985">  Frag_T e;</a>
<a name="ln2986">  nfa_state_T *s;</a>
<a name="ln2987">  nfa_state_T *s1;</a>
<a name="ln2988">  nfa_state_T *matchstate;</a>
<a name="ln2989">  nfa_state_T *ret = NULL;</a>
<a name="ln2990"> </a>
<a name="ln2991">  if (postfix == NULL)</a>
<a name="ln2992">    return NULL;</a>
<a name="ln2993"> </a>
<a name="ln2994">#define PUSH(s)     st_push((s), &amp;stackp, stack_end)</a>
<a name="ln2995">#define POP()       st_pop(&amp;stackp, stack); \</a>
<a name="ln2996">  if (stackp &lt; stack) { \</a>
<a name="ln2997">    st_error(postfix, end, p); \</a>
<a name="ln2998">    xfree(stack); \</a>
<a name="ln2999">    return NULL; \</a>
<a name="ln3000">  }</a>
<a name="ln3001"> </a>
<a name="ln3002">  if (nfa_calc_size == false) {</a>
<a name="ln3003">    // Allocate space for the stack. Max states on the stack: &quot;nstate&quot;.</a>
<a name="ln3004">    stack = xmalloc((nstate + 1) * sizeof(Frag_T));</a>
<a name="ln3005">    stackp = stack;</a>
<a name="ln3006">    stack_end = stack + (nstate + 1);</a>
<a name="ln3007">  }</a>
<a name="ln3008"> </a>
<a name="ln3009">  for (p = postfix; p &lt; end; ++p) {</a>
<a name="ln3010">    switch (*p) {</a>
<a name="ln3011">    case NFA_CONCAT:</a>
<a name="ln3012">      // Concatenation.</a>
<a name="ln3013">      // Pay attention: this operator does not exist in the r.e. itself</a>
<a name="ln3014">      // (it is implicit, really).  It is added when r.e. is translated</a>
<a name="ln3015">      // to postfix form in re2post().</a>
<a name="ln3016">      if (nfa_calc_size == true) {</a>
<a name="ln3017">        // nstate += 0;</a>
<a name="ln3018">        break;</a>
<a name="ln3019">      }</a>
<a name="ln3020">      e2 = POP();</a>
<a name="ln3021">      e1 = POP();</a>
<a name="ln3022">      patch(e1.out, e2.start);</a>
<a name="ln3023">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3024">      break;</a>
<a name="ln3025"> </a>
<a name="ln3026">    case NFA_OR:</a>
<a name="ln3027">      // Alternation</a>
<a name="ln3028">      if (nfa_calc_size == true) {</a>
<a name="ln3029">        nstate++;</a>
<a name="ln3030">        break;</a>
<a name="ln3031">      }</a>
<a name="ln3032">      e2 = POP();</a>
<a name="ln3033">      e1 = POP();</a>
<a name="ln3034">      s = alloc_state(NFA_SPLIT, e1.start, e2.start);</a>
<a name="ln3035">      if (s == NULL)</a>
<a name="ln3036">        goto theend;</a>
<a name="ln3037">      PUSH(frag(s, append(e1.out, e2.out)));</a>
<a name="ln3038">      break;</a>
<a name="ln3039"> </a>
<a name="ln3040">    case NFA_STAR:</a>
<a name="ln3041">      // Zero or more, prefer more</a>
<a name="ln3042">      if (nfa_calc_size == true) {</a>
<a name="ln3043">        nstate++;</a>
<a name="ln3044">        break;</a>
<a name="ln3045">      }</a>
<a name="ln3046">      e = POP();</a>
<a name="ln3047">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3048">      if (s == NULL)</a>
<a name="ln3049">        goto theend;</a>
<a name="ln3050">      patch(e.out, s);</a>
<a name="ln3051">      PUSH(frag(s, list1(&amp;s-&gt;out1)));</a>
<a name="ln3052">      break;</a>
<a name="ln3053"> </a>
<a name="ln3054">    case NFA_STAR_NONGREEDY:</a>
<a name="ln3055">      // Zero or more, prefer zero</a>
<a name="ln3056">      if (nfa_calc_size == true) {</a>
<a name="ln3057">        nstate++;</a>
<a name="ln3058">        break;</a>
<a name="ln3059">      }</a>
<a name="ln3060">      e = POP();</a>
<a name="ln3061">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3062">      if (s == NULL)</a>
<a name="ln3063">        goto theend;</a>
<a name="ln3064">      patch(e.out, s);</a>
<a name="ln3065">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3066">      break;</a>
<a name="ln3067"> </a>
<a name="ln3068">    case NFA_QUEST:</a>
<a name="ln3069">      // one or zero atoms=&gt; greedy match</a>
<a name="ln3070">      if (nfa_calc_size == true) {</a>
<a name="ln3071">        nstate++;</a>
<a name="ln3072">        break;</a>
<a name="ln3073">      }</a>
<a name="ln3074">      e = POP();</a>
<a name="ln3075">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3076">      if (s == NULL)</a>
<a name="ln3077">        goto theend;</a>
<a name="ln3078">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out1))));</a>
<a name="ln3079">      break;</a>
<a name="ln3080"> </a>
<a name="ln3081">    case NFA_QUEST_NONGREEDY:</a>
<a name="ln3082">      // zero or one atoms =&gt; non-greedy match</a>
<a name="ln3083">      if (nfa_calc_size == true) {</a>
<a name="ln3084">        nstate++;</a>
<a name="ln3085">        break;</a>
<a name="ln3086">      }</a>
<a name="ln3087">      e = POP();</a>
<a name="ln3088">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3089">      if (s == NULL)</a>
<a name="ln3090">        goto theend;</a>
<a name="ln3091">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out))));</a>
<a name="ln3092">      break;</a>
<a name="ln3093"> </a>
<a name="ln3094">    case NFA_END_COLL:</a>
<a name="ln3095">    case NFA_END_NEG_COLL:</a>
<a name="ln3096">      /* On the stack is the sequence starting with NFA_START_COLL or</a>
<a name="ln3097">       * NFA_START_NEG_COLL and all possible characters. Patch it to</a>
<a name="ln3098">       * add the output to the start. */</a>
<a name="ln3099">      if (nfa_calc_size == true) {</a>
<a name="ln3100">        nstate++;</a>
<a name="ln3101">        break;</a>
<a name="ln3102">      }</a>
<a name="ln3103">      e = POP();</a>
<a name="ln3104">      s = alloc_state(NFA_END_COLL, NULL, NULL);</a>
<a name="ln3105">      if (s == NULL)</a>
<a name="ln3106">        goto theend;</a>
<a name="ln3107">      patch(e.out, s);</a>
<a name="ln3108">      e.start-&gt;out1 = s;</a>
<a name="ln3109">      PUSH(frag(e.start, list1(&amp;s-&gt;out)));</a>
<a name="ln3110">      break;</a>
<a name="ln3111"> </a>
<a name="ln3112">    case NFA_RANGE:</a>
<a name="ln3113">      // Before this are two characters, the low and high end of a</a>
<a name="ln3114">      // range.  Turn them into two states with MIN and MAX.</a>
<a name="ln3115">      if (nfa_calc_size == true) {</a>
<a name="ln3116">        // nstate += 0;</a>
<a name="ln3117">        break;</a>
<a name="ln3118">      }</a>
<a name="ln3119">      e2 = POP();</a>
<a name="ln3120">      e1 = POP();</a>
<a name="ln3121">      e2.start-&gt;val = e2.start-&gt;c;</a>
<a name="ln3122">      e2.start-&gt;c = NFA_RANGE_MAX;</a>
<a name="ln3123">      e1.start-&gt;val = e1.start-&gt;c;</a>
<a name="ln3124">      e1.start-&gt;c = NFA_RANGE_MIN;</a>
<a name="ln3125">      patch(e1.out, e2.start);</a>
<a name="ln3126">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3127">      break;</a>
<a name="ln3128"> </a>
<a name="ln3129">    case NFA_EMPTY:</a>
<a name="ln3130">      // 0-length, used in a repetition with max/min count of 0</a>
<a name="ln3131">      if (nfa_calc_size == true) {</a>
<a name="ln3132">        nstate++;</a>
<a name="ln3133">        break;</a>
<a name="ln3134">      }</a>
<a name="ln3135">      s = alloc_state(NFA_EMPTY, NULL, NULL);</a>
<a name="ln3136">      if (s == NULL)</a>
<a name="ln3137">        goto theend;</a>
<a name="ln3138">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3139">      break;</a>
<a name="ln3140"> </a>
<a name="ln3141">    case NFA_OPT_CHARS:</a>
<a name="ln3142">    {</a>
<a name="ln3143">      int n;</a>
<a name="ln3144"> </a>
<a name="ln3145">      // \%[abc] implemented as:</a>
<a name="ln3146">      //    NFA_SPLIT</a>
<a name="ln3147">      //    +-CHAR(a)</a>
<a name="ln3148">      //    | +-NFA_SPLIT</a>
<a name="ln3149">      //    |   +-CHAR(b)</a>
<a name="ln3150">      //    |   | +-NFA_SPLIT</a>
<a name="ln3151">      //    |   |   +-CHAR(c)</a>
<a name="ln3152">      //    |   |   | +-next</a>
<a name="ln3153">      //    |   |   +- next</a>
<a name="ln3154">      //    |   +- next</a>
<a name="ln3155">      //    +- next</a>
<a name="ln3156">      n = *++p;  // get number of characters</a>
<a name="ln3157">      if (nfa_calc_size == true) {</a>
<a name="ln3158">        nstate += n;</a>
<a name="ln3159">        break;</a>
<a name="ln3160">      }</a>
<a name="ln3161">      s = NULL;       /* avoid compiler warning */</a>
<a name="ln3162">      e1.out = NULL;       /* stores list with out1's */</a>
<a name="ln3163">      s1 = NULL;       /* previous NFA_SPLIT to connect to */</a>
<a name="ln3164">      while (n-- &gt; 0) {</a>
<a name="ln3165">        e = POP();         /* get character */</a>
<a name="ln3166">        s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3167">        if (s == NULL)</a>
<a name="ln3168">          goto theend;</a>
<a name="ln3169">        if (e1.out == NULL)</a>
<a name="ln3170">          e1 = e;</a>
<a name="ln3171">        patch(e.out, s1);</a>
<a name="ln3172">        append(e1.out, list1(&amp;s-&gt;out1));</a>
<a name="ln3173">        s1 = s;</a>
<a name="ln3174">      }</a>
<a name="ln3175">      PUSH(frag(s, e1.out));</a>
<a name="ln3176">      break;</a>
<a name="ln3177">    }</a>
<a name="ln3178"> </a>
<a name="ln3179">    case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3180">    case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3181">    case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3182">    case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3183">    case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln3184">    {</a>
<a name="ln3185">      int before = (*p == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln3186">                    || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);</a>
<a name="ln3187">      int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);</a>
<a name="ln3188">      int start_state;</a>
<a name="ln3189">      int end_state;</a>
<a name="ln3190">      int n = 0;</a>
<a name="ln3191">      nfa_state_T *zend;</a>
<a name="ln3192">      nfa_state_T *skip;</a>
<a name="ln3193"> </a>
<a name="ln3194">      switch (*p) {</a>
<a name="ln3195">      case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3196">        start_state = NFA_START_INVISIBLE;</a>
<a name="ln3197">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3198">        break;</a>
<a name="ln3199">      case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3200">        start_state = NFA_START_INVISIBLE_NEG;</a>
<a name="ln3201">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3202">        break;</a>
<a name="ln3203">      case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3204">        start_state = NFA_START_INVISIBLE_BEFORE;</a>
<a name="ln3205">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3206">        break;</a>
<a name="ln3207">      case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3208">        start_state = NFA_START_INVISIBLE_BEFORE_NEG;</a>
<a name="ln3209">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3210">        break;</a>
<a name="ln3211">      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */</a>
<a name="ln3212">        start_state = NFA_START_PATTERN;</a>
<a name="ln3213">        end_state = NFA_END_PATTERN;</a>
<a name="ln3214">        break;</a>
<a name="ln3215">      }</a>
<a name="ln3216"> </a>
<a name="ln3217">      if (before)</a>
<a name="ln3218">        n = *++p;         /* get the count */</a>
<a name="ln3219"> </a>
<a name="ln3220">      /* The \@= operator: match the preceding atom with zero width.</a>
<a name="ln3221">       * The \@! operator: no match for the preceding atom.</a>
<a name="ln3222">       * The \@&lt;= operator: match for the preceding atom.</a>
<a name="ln3223">       * The \@&lt;! operator: no match for the preceding atom.</a>
<a name="ln3224">       * Surrounds the preceding atom with START_INVISIBLE and</a>
<a name="ln3225">       * END_INVISIBLE, similarly to MOPEN. */</a>
<a name="ln3226"> </a>
<a name="ln3227">      if (nfa_calc_size == true) {</a>
<a name="ln3228">        nstate += pattern ? 4 : 2;</a>
<a name="ln3229">        break;</a>
<a name="ln3230">      }</a>
<a name="ln3231">      e = POP();</a>
<a name="ln3232">      s1 = alloc_state(end_state, NULL, NULL);</a>
<a name="ln3233">      if (s1 == NULL)</a>
<a name="ln3234">        goto theend;</a>
<a name="ln3235"> </a>
<a name="ln3236">      s = alloc_state(start_state, e.start, s1);</a>
<a name="ln3237">      if (s == NULL)</a>
<a name="ln3238">        goto theend;</a>
<a name="ln3239">      if (pattern) {</a>
<a name="ln3240">        /* NFA_ZEND -&gt; NFA_END_PATTERN -&gt; NFA_SKIP -&gt; what follows. */</a>
<a name="ln3241">        skip = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3242">        if (skip == NULL) {</a>
<a name="ln3243">          goto theend;</a>
<a name="ln3244">        }</a>
<a name="ln3245">        zend = alloc_state(NFA_ZEND, s1, NULL);</a>
<a name="ln3246">        if (zend == NULL) {</a>
<a name="ln3247">          goto theend;</a>
<a name="ln3248">        }</a>
<a name="ln3249">        s1-&gt;out= skip;</a>
<a name="ln3250">        patch(e.out, zend);</a>
<a name="ln3251">        PUSH(frag(s, list1(&amp;skip-&gt;out)));</a>
<a name="ln3252">      } else {</a>
<a name="ln3253">        patch(e.out, s1);</a>
<a name="ln3254">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3255">        if (before) {</a>
<a name="ln3256">          if (n &lt;= 0)</a>
<a name="ln3257">            /* See if we can guess the maximum width, it avoids a</a>
<a name="ln3258">             * lot of pointless tries. */</a>
<a name="ln3259">            n = nfa_max_width(e.start, 0);</a>
<a name="ln3260">          s-&gt;val = n;           /* store the count */</a>
<a name="ln3261">        }</a>
<a name="ln3262">      }</a>
<a name="ln3263">      break;</a>
<a name="ln3264">    }</a>
<a name="ln3265"> </a>
<a name="ln3266">    case NFA_COMPOSING:         // char with composing char</a>
<a name="ln3267">      FALLTHROUGH;</a>
<a name="ln3268"> </a>
<a name="ln3269">    case NFA_MOPEN:     /* \( \) Submatch */</a>
<a name="ln3270">    case NFA_MOPEN1:</a>
<a name="ln3271">    case NFA_MOPEN2:</a>
<a name="ln3272">    case NFA_MOPEN3:</a>
<a name="ln3273">    case NFA_MOPEN4:</a>
<a name="ln3274">    case NFA_MOPEN5:</a>
<a name="ln3275">    case NFA_MOPEN6:</a>
<a name="ln3276">    case NFA_MOPEN7:</a>
<a name="ln3277">    case NFA_MOPEN8:</a>
<a name="ln3278">    case NFA_MOPEN9:</a>
<a name="ln3279">    case NFA_ZOPEN:     /* \z( \) Submatch */</a>
<a name="ln3280">    case NFA_ZOPEN1:</a>
<a name="ln3281">    case NFA_ZOPEN2:</a>
<a name="ln3282">    case NFA_ZOPEN3:</a>
<a name="ln3283">    case NFA_ZOPEN4:</a>
<a name="ln3284">    case NFA_ZOPEN5:</a>
<a name="ln3285">    case NFA_ZOPEN6:</a>
<a name="ln3286">    case NFA_ZOPEN7:</a>
<a name="ln3287">    case NFA_ZOPEN8:</a>
<a name="ln3288">    case NFA_ZOPEN9:</a>
<a name="ln3289">    case NFA_NOPEN:     // \%( \) &quot;Invisible Submatch&quot;</a>
<a name="ln3290">      if (nfa_calc_size == true) {</a>
<a name="ln3291">        nstate += 2;</a>
<a name="ln3292">        break;</a>
<a name="ln3293">      }</a>
<a name="ln3294"> </a>
<a name="ln3295">      mopen = *p;</a>
<a name="ln3296">      switch (*p) {</a>
<a name="ln3297">      case NFA_NOPEN: mclose = NFA_NCLOSE; break;</a>
<a name="ln3298">      case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;</a>
<a name="ln3299">      case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;</a>
<a name="ln3300">      case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;</a>
<a name="ln3301">      case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;</a>
<a name="ln3302">      case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;</a>
<a name="ln3303">      case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;</a>
<a name="ln3304">      case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;</a>
<a name="ln3305">      case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;</a>
<a name="ln3306">      case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;</a>
<a name="ln3307">      case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;</a>
<a name="ln3308">      case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;</a>
<a name="ln3309">      default:</a>
<a name="ln3310">        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */</a>
<a name="ln3311">        mclose = *p + NSUBEXP;</a>
<a name="ln3312">        break;</a>
<a name="ln3313">      }</a>
<a name="ln3314"> </a>
<a name="ln3315">      /* Allow &quot;NFA_MOPEN&quot; as a valid postfix representation for</a>
<a name="ln3316">       * the empty regexp &quot;&quot;. In this case, the NFA will be</a>
<a name="ln3317">       * NFA_MOPEN -&gt; NFA_MCLOSE. Note that this also allows</a>
<a name="ln3318">       * empty groups of parenthesis, and empty mbyte chars */</a>
<a name="ln3319">      if (stackp == stack) {</a>
<a name="ln3320">        s = alloc_state(mopen, NULL, NULL);</a>
<a name="ln3321">        if (s == NULL)</a>
<a name="ln3322">          goto theend;</a>
<a name="ln3323">        s1 = alloc_state(mclose, NULL, NULL);</a>
<a name="ln3324">        if (s1 == NULL)</a>
<a name="ln3325">          goto theend;</a>
<a name="ln3326">        patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3327">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3328">        break;</a>
<a name="ln3329">      }</a>
<a name="ln3330"> </a>
<a name="ln3331">      /* At least one node was emitted before NFA_MOPEN, so</a>
<a name="ln3332">       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */</a>
<a name="ln3333">      e = POP();</a>
<a name="ln3334">      s = alloc_state(mopen, e.start, NULL);         /* `(' */</a>
<a name="ln3335">      if (s == NULL)</a>
<a name="ln3336">        goto theend;</a>
<a name="ln3337"> </a>
<a name="ln3338">      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */</a>
<a name="ln3339">      if (s1 == NULL)</a>
<a name="ln3340">        goto theend;</a>
<a name="ln3341">      patch(e.out, s1);</a>
<a name="ln3342"> </a>
<a name="ln3343">      if (mopen == NFA_COMPOSING)</a>
<a name="ln3344">        /* COMPOSING-&gt;out1 = END_COMPOSING */</a>
<a name="ln3345">        patch(list1(&amp;s-&gt;out1), s1);</a>
<a name="ln3346"> </a>
<a name="ln3347">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3348">      break;</a>
<a name="ln3349"> </a>
<a name="ln3350">    case NFA_BACKREF1:</a>
<a name="ln3351">    case NFA_BACKREF2:</a>
<a name="ln3352">    case NFA_BACKREF3:</a>
<a name="ln3353">    case NFA_BACKREF4:</a>
<a name="ln3354">    case NFA_BACKREF5:</a>
<a name="ln3355">    case NFA_BACKREF6:</a>
<a name="ln3356">    case NFA_BACKREF7:</a>
<a name="ln3357">    case NFA_BACKREF8:</a>
<a name="ln3358">    case NFA_BACKREF9:</a>
<a name="ln3359">    case NFA_ZREF1:</a>
<a name="ln3360">    case NFA_ZREF2:</a>
<a name="ln3361">    case NFA_ZREF3:</a>
<a name="ln3362">    case NFA_ZREF4:</a>
<a name="ln3363">    case NFA_ZREF5:</a>
<a name="ln3364">    case NFA_ZREF6:</a>
<a name="ln3365">    case NFA_ZREF7:</a>
<a name="ln3366">    case NFA_ZREF8:</a>
<a name="ln3367">    case NFA_ZREF9:</a>
<a name="ln3368">      if (nfa_calc_size == true) {</a>
<a name="ln3369">        nstate += 2;</a>
<a name="ln3370">        break;</a>
<a name="ln3371">      }</a>
<a name="ln3372">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3373">      if (s == NULL)</a>
<a name="ln3374">        goto theend;</a>
<a name="ln3375">      s1 = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3376">      if (s1 == NULL)</a>
<a name="ln3377">        goto theend;</a>
<a name="ln3378">      patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3379">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3380">      break;</a>
<a name="ln3381"> </a>
<a name="ln3382">    case NFA_LNUM:</a>
<a name="ln3383">    case NFA_LNUM_GT:</a>
<a name="ln3384">    case NFA_LNUM_LT:</a>
<a name="ln3385">    case NFA_VCOL:</a>
<a name="ln3386">    case NFA_VCOL_GT:</a>
<a name="ln3387">    case NFA_VCOL_LT:</a>
<a name="ln3388">    case NFA_COL:</a>
<a name="ln3389">    case NFA_COL_GT:</a>
<a name="ln3390">    case NFA_COL_LT:</a>
<a name="ln3391">    case NFA_MARK:</a>
<a name="ln3392">    case NFA_MARK_GT:</a>
<a name="ln3393">    case NFA_MARK_LT:</a>
<a name="ln3394">    {</a>
<a name="ln3395">      int n = *++p;       /* lnum, col or mark name */</a>
<a name="ln3396"> </a>
<a name="ln3397">      if (nfa_calc_size == true) {</a>
<a name="ln3398">        nstate += 1;</a>
<a name="ln3399">        break;</a>
<a name="ln3400">      }</a>
<a name="ln3401">      s = alloc_state(p[-1], NULL, NULL);</a>
<a name="ln3402">      if (s == NULL)</a>
<a name="ln3403">        goto theend;</a>
<a name="ln3404">      s-&gt;val = n;</a>
<a name="ln3405">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3406">      break;</a>
<a name="ln3407">    }</a>
<a name="ln3408"> </a>
<a name="ln3409">    case NFA_ZSTART:</a>
<a name="ln3410">    case NFA_ZEND:</a>
<a name="ln3411">    default:</a>
<a name="ln3412">      // Operands</a>
<a name="ln3413">      if (nfa_calc_size == true) {</a>
<a name="ln3414">        nstate++;</a>
<a name="ln3415">        break;</a>
<a name="ln3416">      }</a>
<a name="ln3417">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3418">      if (s == NULL)</a>
<a name="ln3419">        goto theend;</a>
<a name="ln3420">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3421">      break;</a>
<a name="ln3422"> </a>
<a name="ln3423">    }     /* switch(*p) */</a>
<a name="ln3424"> </a>
<a name="ln3425">  }   /* for(p = postfix; *p; ++p) */</a>
<a name="ln3426"> </a>
<a name="ln3427">  if (nfa_calc_size == true) {</a>
<a name="ln3428">    nstate++;</a>
<a name="ln3429">    goto theend;        /* Return value when counting size is ignored anyway */</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  e = POP();</a>
<a name="ln3433">  if (stackp != stack) {</a>
<a name="ln3434">    xfree(stack);</a>
<a name="ln3435">    EMSG_RET_NULL(_(&quot;E875: (NFA regexp) (While converting from postfix to NFA),&quot;</a>
<a name="ln3436">                    &quot;too many states left on stack&quot;));</a>
<a name="ln3437">  }</a>
<a name="ln3438"> </a>
<a name="ln3439">  if (istate &gt;= nstate) {</a>
<a name="ln3440">    xfree(stack);</a>
<a name="ln3441">    EMSG_RET_NULL(_(&quot;E876: (NFA regexp) &quot;</a>
<a name="ln3442">                    &quot;Not enough space to store the whole NFA &quot;));</a>
<a name="ln3443">  }</a>
<a name="ln3444"> </a>
<a name="ln3445">  matchstate = &amp;state_ptr[istate++];   /* the match state */</a>
<a name="ln3446">  matchstate-&gt;c = NFA_MATCH;</a>
<a name="ln3447">  matchstate-&gt;out = matchstate-&gt;out1 = NULL;</a>
<a name="ln3448">  matchstate-&gt;id = 0;</a>
<a name="ln3449"> </a>
<a name="ln3450">  patch(e.out, matchstate);</a>
<a name="ln3451">  ret = e.start;</a>
<a name="ln3452"> </a>
<a name="ln3453">theend:</a>
<a name="ln3454">  xfree(stack);</a>
<a name="ln3455">  return ret;</a>
<a name="ln3456"> </a>
<a name="ln3457">#undef POP1</a>
<a name="ln3458">#undef PUSH1</a>
<a name="ln3459">#undef POP2</a>
<a name="ln3460">#undef PUSH2</a>
<a name="ln3461">#undef POP</a>
<a name="ln3462">#undef PUSH</a>
<a name="ln3463">}</a>
<a name="ln3464"> </a>
<a name="ln3465">/*</a>
<a name="ln3466"> * After building the NFA program, inspect it to add optimization hints.</a>
<a name="ln3467"> */</a>
<a name="ln3468">static void nfa_postprocess(nfa_regprog_T *prog)</a>
<a name="ln3469">{</a>
<a name="ln3470">  int i;</a>
<a name="ln3471">  int c;</a>
<a name="ln3472"> </a>
<a name="ln3473">  for (i = 0; i &lt; prog-&gt;nstate; ++i) {</a>
<a name="ln3474">    c = prog-&gt;state[i].c;</a>
<a name="ln3475">    if (c == NFA_START_INVISIBLE</a>
<a name="ln3476">        || c == NFA_START_INVISIBLE_NEG</a>
<a name="ln3477">        || c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3478">        || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3479">      int directly;</a>
<a name="ln3480"> </a>
<a name="ln3481">      // Do it directly when what follows is possibly the end of the</a>
<a name="ln3482">      // match.</a>
<a name="ln3483">      if (match_follows(prog-&gt;state[i].out1-&gt;out, 0)) {</a>
<a name="ln3484">        directly = true;</a>
<a name="ln3485">      } else {</a>
<a name="ln3486">        int ch_invisible = failure_chance(prog-&gt;state[i].out, 0);</a>
<a name="ln3487">        int ch_follows = failure_chance(prog-&gt;state[i].out1-&gt;out, 0);</a>
<a name="ln3488"> </a>
<a name="ln3489">        /* Postpone when the invisible match is expensive or has a</a>
<a name="ln3490">         * lower chance of failing. */</a>
<a name="ln3491">        if (c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3492">            || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3493">          /* &quot;before&quot; matches are very expensive when</a>
<a name="ln3494">           * unbounded, always prefer what follows then,</a>
<a name="ln3495">           * unless what follows will always match.</a>
<a name="ln3496">           * Otherwise strongly prefer what follows. */</a>
<a name="ln3497">          if (prog-&gt;state[i].val &lt;= 0 &amp;&amp; ch_follows &gt; 0) {</a>
<a name="ln3498">            directly = false;</a>
<a name="ln3499">          } else {</a>
<a name="ln3500">            directly = ch_follows * 10 &lt; ch_invisible;</a>
<a name="ln3501">          }</a>
<a name="ln3502">        } else {</a>
<a name="ln3503">          /* normal invisible, first do the one with the</a>
<a name="ln3504">           * highest failure chance */</a>
<a name="ln3505">          directly = ch_follows &lt; ch_invisible;</a>
<a name="ln3506">        }</a>
<a name="ln3507">      }</a>
<a name="ln3508">      if (directly)</a>
<a name="ln3509">        /* switch to the _FIRST state */</a>
<a name="ln3510">        ++prog-&gt;state[i].c;</a>
<a name="ln3511">    }</a>
<a name="ln3512">  }</a>
<a name="ln3513">}</a>
<a name="ln3514"> </a>
<a name="ln3515">/****************************************************************</a>
<a name="ln3516">* NFA execution code.</a>
<a name="ln3517">****************************************************************/</a>
<a name="ln3518"> </a>
<a name="ln3519">/* Values for done in nfa_pim_T. */</a>
<a name="ln3520">#define NFA_PIM_UNUSED   0      /* pim not used */</a>
<a name="ln3521">#define NFA_PIM_TODO     1      /* pim not done yet */</a>
<a name="ln3522">#define NFA_PIM_MATCH    2      /* pim executed, matches */</a>
<a name="ln3523">#define NFA_PIM_NOMATCH  3      /* pim executed, no match */</a>
<a name="ln3524"> </a>
<a name="ln3525"> </a>
<a name="ln3526">#ifdef REGEXP_DEBUG</a>
<a name="ln3527">static void log_subsexpr(regsubs_T *subs)</a>
<a name="ln3528">{</a>
<a name="ln3529">  log_subexpr(&amp;subs-&gt;norm);</a>
<a name="ln3530">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3531">    log_subexpr(&amp;subs-&gt;synt);</a>
<a name="ln3532">  }</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">static void log_subexpr(regsub_T *sub)</a>
<a name="ln3536">{</a>
<a name="ln3537">  int j;</a>
<a name="ln3538"> </a>
<a name="ln3539">  for (j = 0; j &lt; sub-&gt;in_use; j++)</a>
<a name="ln3540">    if (REG_MULTI)</a>
<a name="ln3541">      fprintf(log_fd, &quot;*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\n&quot;,</a>
<a name="ln3542">          j,</a>
<a name="ln3543">          sub-&gt;list.multi[j].start_col,</a>
<a name="ln3544">          (int)sub-&gt;list.multi[j].start_lnum,</a>
<a name="ln3545">          sub-&gt;list.multi[j].end_col,</a>
<a name="ln3546">          (int)sub-&gt;list.multi[j].end_lnum);</a>
<a name="ln3547">    else {</a>
<a name="ln3548">      char *s = (char *)sub-&gt;list.line[j].start;</a>
<a name="ln3549">      char *e = (char *)sub-&gt;list.line[j].end;</a>
<a name="ln3550"> </a>
<a name="ln3551">      fprintf(log_fd, &quot;*** group %d, start: \&quot;%s\&quot;, end: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln3552">          j,</a>
<a name="ln3553">          s == NULL ? &quot;NULL&quot; : s,</a>
<a name="ln3554">          e == NULL ? &quot;NULL&quot; : e);</a>
<a name="ln3555">    }</a>
<a name="ln3556">}</a>
<a name="ln3557"> </a>
<a name="ln3558">static char *pim_info(const nfa_pim_T *pim)</a>
<a name="ln3559">{</a>
<a name="ln3560">  static char buf[30];</a>
<a name="ln3561"> </a>
<a name="ln3562">  if (pim == NULL || pim-&gt;result == NFA_PIM_UNUSED) {</a>
<a name="ln3563">    buf[0] = NUL;</a>
<a name="ln3564">  } else {</a>
<a name="ln3565">    snprintf(buf, sizeof(buf), &quot; PIM col %d&quot;,</a>
<a name="ln3566">             REG_MULTI</a>
<a name="ln3567">             ? (int)pim-&gt;end.pos.col</a>
<a name="ln3568">             : (int)(pim-&gt;end.ptr - rex.input));</a>
<a name="ln3569">  }</a>
<a name="ln3570">  return buf;</a>
<a name="ln3571">}</a>
<a name="ln3572"> </a>
<a name="ln3573">#endif</a>
<a name="ln3574"> </a>
<a name="ln3575">// Used during execution: whether a match has been found.</a>
<a name="ln3576">static int nfa_match;</a>
<a name="ln3577">static proftime_T *nfa_time_limit;</a>
<a name="ln3578">static int *nfa_timed_out;</a>
<a name="ln3579">static int nfa_time_count;</a>
<a name="ln3580"> </a>
<a name="ln3581">// Copy postponed invisible match info from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3582">static void copy_pim(nfa_pim_T *to, nfa_pim_T *from)</a>
<a name="ln3583">{</a>
<a name="ln3584">  to-&gt;result = from-&gt;result;</a>
<a name="ln3585">  to-&gt;state = from-&gt;state;</a>
<a name="ln3586">  copy_sub(&amp;to-&gt;subs.norm, &amp;from-&gt;subs.norm);</a>
<a name="ln3587">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3588">    copy_sub(&amp;to-&gt;subs.synt, &amp;from-&gt;subs.synt);</a>
<a name="ln3589">  }</a>
<a name="ln3590">  to-&gt;end = from-&gt;end;</a>
<a name="ln3591">}</a>
<a name="ln3592"> </a>
<a name="ln3593">static void clear_sub(regsub_T *sub)</a>
<a name="ln3594">{</a>
<a name="ln3595">  if (REG_MULTI) {</a>
<a name="ln3596">    // Use 0xff to set lnum to -1</a>
<a name="ln3597">    memset(sub-&gt;list.multi, 0xff,</a>
<a name="ln3598">           sizeof(struct multipos) * rex.nfa_nsubexpr);</a>
<a name="ln3599">  } else {</a>
<a name="ln3600">    memset(sub-&gt;list.line, 0, sizeof(struct linepos) * rex.nfa_nsubexpr);</a>
<a name="ln3601">  }</a>
<a name="ln3602">  sub-&gt;in_use = 0;</a>
<a name="ln3603">}</a>
<a name="ln3604"> </a>
<a name="ln3605">/*</a>
<a name="ln3606"> * Copy the submatches from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3607"> */</a>
<a name="ln3608">static void copy_sub(regsub_T *to, regsub_T *from)</a>
<a name="ln3609">{</a>
<a name="ln3610">  to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3611">  if (from-&gt;in_use &gt; 0) {</a>
<a name="ln3612">    /* Copy the match start and end positions. */</a>
<a name="ln3613">    if (REG_MULTI)</a>
<a name="ln3614">      memmove(&amp;to-&gt;list.multi[0],</a>
<a name="ln3615">          &amp;from-&gt;list.multi[0],</a>
<a name="ln3616">          sizeof(struct multipos) * from-&gt;in_use);</a>
<a name="ln3617">    else</a>
<a name="ln3618">      memmove(&amp;to-&gt;list.line[0],</a>
<a name="ln3619">          &amp;from-&gt;list.line[0],</a>
<a name="ln3620">          sizeof(struct linepos) * from-&gt;in_use);</a>
<a name="ln3621">  }</a>
<a name="ln3622">}</a>
<a name="ln3623"> </a>
<a name="ln3624">/*</a>
<a name="ln3625"> * Like copy_sub() but exclude the main match.</a>
<a name="ln3626"> */</a>
<a name="ln3627">static void copy_sub_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3628">{</a>
<a name="ln3629">  if (to-&gt;in_use &lt; from-&gt;in_use)</a>
<a name="ln3630">    to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3631">  if (from-&gt;in_use &gt; 1) {</a>
<a name="ln3632">    /* Copy the match start and end positions. */</a>
<a name="ln3633">    if (REG_MULTI)</a>
<a name="ln3634">      memmove(&amp;to-&gt;list.multi[1],</a>
<a name="ln3635">          &amp;from-&gt;list.multi[1],</a>
<a name="ln3636">          sizeof(struct multipos) * (from-&gt;in_use - 1));</a>
<a name="ln3637">    else</a>
<a name="ln3638">      memmove(&amp;to-&gt;list.line[1],</a>
<a name="ln3639">          &amp;from-&gt;list.line[1],</a>
<a name="ln3640">          sizeof(struct linepos) * (from-&gt;in_use - 1));</a>
<a name="ln3641">  }</a>
<a name="ln3642">}</a>
<a name="ln3643"> </a>
<a name="ln3644">/*</a>
<a name="ln3645"> * Like copy_sub() but only do the end of the main match if \ze is present.</a>
<a name="ln3646"> */</a>
<a name="ln3647">static void copy_ze_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3648">{</a>
<a name="ln3649">  if (rex.nfa_has_zend) {</a>
<a name="ln3650">    if (REG_MULTI) {</a>
<a name="ln3651">      if (from-&gt;list.multi[0].end_lnum &gt;= 0){</a>
<a name="ln3652">        to-&gt;list.multi[0].end_lnum = from-&gt;list.multi[0].end_lnum;</a>
<a name="ln3653">        to-&gt;list.multi[0].end_col = from-&gt;list.multi[0].end_col;</a>
<a name="ln3654">      }</a>
<a name="ln3655">    } else {</a>
<a name="ln3656">      if (from-&gt;list.line[0].end != NULL)</a>
<a name="ln3657">        to-&gt;list.line[0].end = from-&gt;list.line[0].end;</a>
<a name="ln3658">    }</a>
<a name="ln3659">  }</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662">// Return true if &quot;sub1&quot; and &quot;sub2&quot; have the same start positions.</a>
<a name="ln3663">// When using back-references also check the end position.</a>
<a name="ln3664">static bool sub_equal(regsub_T *sub1, regsub_T *sub2)</a>
<a name="ln3665">{</a>
<a name="ln3666">  int i;</a>
<a name="ln3667">  int todo;</a>
<a name="ln3668">  linenr_T s1;</a>
<a name="ln3669">  linenr_T s2;</a>
<a name="ln3670">  char_u      *sp1;</a>
<a name="ln3671">  char_u      *sp2;</a>
<a name="ln3672"> </a>
<a name="ln3673">  todo = sub1-&gt;in_use &gt; sub2-&gt;in_use ? sub1-&gt;in_use : sub2-&gt;in_use;</a>
<a name="ln3674">  if (REG_MULTI) {</a>
<a name="ln3675">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3676">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3677">        s1 = sub1-&gt;list.multi[i].start_lnum;</a>
<a name="ln3678">      } else {</a>
<a name="ln3679">        s1 = -1;</a>
<a name="ln3680">      }</a>
<a name="ln3681">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3682">        s2 = sub2-&gt;list.multi[i].start_lnum;</a>
<a name="ln3683">      } else {</a>
<a name="ln3684">        s2 = -1;</a>
<a name="ln3685">      }</a>
<a name="ln3686">      if (s1 != s2) {</a>
<a name="ln3687">        return false;</a>
<a name="ln3688">      }</a>
<a name="ln3689">      if (s1 != -1 &amp;&amp; sub1-&gt;list.multi[i].start_col</a>
<a name="ln3690">          != sub2-&gt;list.multi[i].start_col) {</a>
<a name="ln3691">        return false;</a>
<a name="ln3692">      }</a>
<a name="ln3693">      if (rex.nfa_has_backref) {</a>
<a name="ln3694">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3695">          s1 = sub1-&gt;list.multi[i].end_lnum;</a>
<a name="ln3696">        } else {</a>
<a name="ln3697">          s1 = -1;</a>
<a name="ln3698">        }</a>
<a name="ln3699">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3700">          s2 = sub2-&gt;list.multi[i].end_lnum;</a>
<a name="ln3701">        } else {</a>
<a name="ln3702">          s2 = -1;</a>
<a name="ln3703">        }</a>
<a name="ln3704">        if (s1 != s2) {</a>
<a name="ln3705">          return false;</a>
<a name="ln3706">        }</a>
<a name="ln3707">        if (s1 != -1</a>
<a name="ln3708">            &amp;&amp; sub1-&gt;list.multi[i].end_col != sub2-&gt;list.multi[i].end_col) {</a>
<a name="ln3709">          return false;</a>
<a name="ln3710">        }</a>
<a name="ln3711">      }</a>
<a name="ln3712">    }</a>
<a name="ln3713">  } else {</a>
<a name="ln3714">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3715">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3716">        sp1 = sub1-&gt;list.line[i].start;</a>
<a name="ln3717">      } else {</a>
<a name="ln3718">        sp1 = NULL;</a>
<a name="ln3719">      }</a>
<a name="ln3720">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3721">        sp2 = sub2-&gt;list.line[i].start;</a>
<a name="ln3722">      } else {</a>
<a name="ln3723">        sp2 = NULL;</a>
<a name="ln3724">      }</a>
<a name="ln3725">      if (sp1 != sp2) {</a>
<a name="ln3726">        return false;</a>
<a name="ln3727">      }</a>
<a name="ln3728">      if (rex.nfa_has_backref) {</a>
<a name="ln3729">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3730">          sp1 = sub1-&gt;list.line[i].end;</a>
<a name="ln3731">        } else {</a>
<a name="ln3732">          sp1 = NULL;</a>
<a name="ln3733">        }</a>
<a name="ln3734">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3735">          sp2 = sub2-&gt;list.line[i].end;</a>
<a name="ln3736">        } else {</a>
<a name="ln3737">          sp2 = NULL;</a>
<a name="ln3738">        }</a>
<a name="ln3739">        if (sp1 != sp2) {</a>
<a name="ln3740">          return false;</a>
<a name="ln3741">        }</a>
<a name="ln3742">      }</a>
<a name="ln3743">    }</a>
<a name="ln3744">  }</a>
<a name="ln3745"> </a>
<a name="ln3746">  return true;</a>
<a name="ln3747">}</a>
<a name="ln3748"> </a>
<a name="ln3749">#ifdef REGEXP_DEBUG</a>
<a name="ln3750">static void report_state(char *action,</a>
<a name="ln3751">    regsub_T *sub,</a>
<a name="ln3752">    nfa_state_T *state,</a>
<a name="ln3753">    int lid,</a>
<a name="ln3754">    nfa_pim_T *pim) {</a>
<a name="ln3755">  int col;</a>
<a name="ln3756"> </a>
<a name="ln3757">  if (sub-&gt;in_use &lt;= 0) {</a>
<a name="ln3758">    col = -1;</a>
<a name="ln3759">  } else if (REG_MULTI) {</a>
<a name="ln3760">    col = sub-&gt;list.multi[0].start_col;</a>
<a name="ln3761">  } else {</a>
<a name="ln3762">    col = (int)(sub-&gt;list.line[0].start - rex.line);</a>
<a name="ln3763">  }</a>
<a name="ln3764">  nfa_set_code(state-&gt;c);</a>
<a name="ln3765">  fprintf(log_fd, &quot;&gt; %s state %d to list %d. char %d: %s (start col %d)%s\n&quot;,</a>
<a name="ln3766">          action, abs(state-&gt;id), lid, state-&gt;c, code, col,</a>
<a name="ln3767">          pim_info(pim));</a>
<a name="ln3768">}</a>
<a name="ln3769"> </a>
<a name="ln3770">#endif</a>
<a name="ln3771"> </a>
<a name="ln3772">// Return true if the same state is already in list &quot;l&quot; with the same</a>
<a name="ln3773">// positions as &quot;subs&quot;.</a>
<a name="ln3774">static bool has_state_with_pos(</a>
<a name="ln3775">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3776">    nfa_state_T *state,   // state to update</a>
<a name="ln3777">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln3778">    nfa_pim_T *pim        // postponed match or NULL</a>
<a name="ln3779">)</a>
<a name="ln3780">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln3781">{</a>
<a name="ln3782">  for (int i = 0; i &lt; l-&gt;n; i++) {</a>
<a name="ln3783">    nfa_thread_T *thread = &amp;l-&gt;t[i];</a>
<a name="ln3784">    if (thread-&gt;state-&gt;id == state-&gt;id</a>
<a name="ln3785">        &amp;&amp; sub_equal(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm)</a>
<a name="ln3786">        &amp;&amp; (!rex.nfa_has_zsubexpr</a>
<a name="ln3787">            || sub_equal(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt))</a>
<a name="ln3788">        &amp;&amp; pim_equal(&amp;thread-&gt;pim, pim)) {</a>
<a name="ln3789">      return true;</a>
<a name="ln3790">    }</a>
<a name="ln3791">  }</a>
<a name="ln3792">  return false;</a>
<a name="ln3793">}</a>
<a name="ln3794"> </a>
<a name="ln3795">// Return true if &quot;one&quot; and &quot;two&quot; are equal.  That includes when both are not</a>
<a name="ln3796">// set.</a>
<a name="ln3797">static bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two)</a>
<a name="ln3798">{</a>
<a name="ln3799">  const bool one_unused = (one == NULL || one-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3800">  const bool two_unused = (two == NULL || two-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3801"> </a>
<a name="ln3802">  if (one_unused) {</a>
<a name="ln3803">    // one is unused: equal when two is also unused</a>
<a name="ln3804">    return two_unused;</a>
<a name="ln3805">  }</a>
<a name="ln3806">  if (two_unused) {</a>
<a name="ln3807">    // one is used and two is not: not equal</a>
<a name="ln3808">    return false;</a>
<a name="ln3809">  }</a>
<a name="ln3810">  // compare the state id</a>
<a name="ln3811">  if (one-&gt;state-&gt;id != two-&gt;state-&gt;id) {</a>
<a name="ln3812">    return false;</a>
<a name="ln3813">  }</a>
<a name="ln3814">  // compare the position</a>
<a name="ln3815">  if (REG_MULTI) {</a>
<a name="ln3816">    return one-&gt;end.pos.lnum == two-&gt;end.pos.lnum</a>
<a name="ln3817">           &amp;&amp; one-&gt;end.pos.col == two-&gt;end.pos.col;</a>
<a name="ln3818">  }</a>
<a name="ln3819">  return one-&gt;end.ptr == two-&gt;end.ptr;</a>
<a name="ln3820">}</a>
<a name="ln3821"> </a>
<a name="ln3822">// Return true if &quot;state&quot; leads to a NFA_MATCH without advancing the input.</a>
<a name="ln3823">static bool match_follows(const nfa_state_T *startstate, int depth)</a>
<a name="ln3824">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3825">{</a>
<a name="ln3826">  const nfa_state_T *state = startstate;</a>
<a name="ln3827"> </a>
<a name="ln3828">  // avoid too much recursion</a>
<a name="ln3829">  if (depth &gt; 10) {</a>
<a name="ln3830">    return false;</a>
<a name="ln3831">  }</a>
<a name="ln3832">  while (state != NULL) {</a>
<a name="ln3833">    switch (state-&gt;c) {</a>
<a name="ln3834">    case NFA_MATCH:</a>
<a name="ln3835">    case NFA_MCLOSE:</a>
<a name="ln3836">    case NFA_END_INVISIBLE:</a>
<a name="ln3837">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln3838">    case NFA_END_PATTERN:</a>
<a name="ln3839">      return true;</a>
<a name="ln3840"> </a>
<a name="ln3841">    case NFA_SPLIT:</a>
<a name="ln3842">      return match_follows(state-&gt;out, depth + 1)</a>
<a name="ln3843">             || match_follows(state-&gt;out1, depth + 1);</a>
<a name="ln3844"> </a>
<a name="ln3845">    case NFA_START_INVISIBLE:</a>
<a name="ln3846">    case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln3847">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln3848">    case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln3849">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln3850">    case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln3851">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln3852">    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln3853">    case NFA_COMPOSING:</a>
<a name="ln3854">      /* skip ahead to next state */</a>
<a name="ln3855">      state = state-&gt;out1-&gt;out;</a>
<a name="ln3856">      continue;</a>
<a name="ln3857"> </a>
<a name="ln3858">    case NFA_ANY:</a>
<a name="ln3859">    case NFA_ANY_COMPOSING:</a>
<a name="ln3860">    case NFA_IDENT:</a>
<a name="ln3861">    case NFA_SIDENT:</a>
<a name="ln3862">    case NFA_KWORD:</a>
<a name="ln3863">    case NFA_SKWORD:</a>
<a name="ln3864">    case NFA_FNAME:</a>
<a name="ln3865">    case NFA_SFNAME:</a>
<a name="ln3866">    case NFA_PRINT:</a>
<a name="ln3867">    case NFA_SPRINT:</a>
<a name="ln3868">    case NFA_WHITE:</a>
<a name="ln3869">    case NFA_NWHITE:</a>
<a name="ln3870">    case NFA_DIGIT:</a>
<a name="ln3871">    case NFA_NDIGIT:</a>
<a name="ln3872">    case NFA_HEX:</a>
<a name="ln3873">    case NFA_NHEX:</a>
<a name="ln3874">    case NFA_OCTAL:</a>
<a name="ln3875">    case NFA_NOCTAL:</a>
<a name="ln3876">    case NFA_WORD:</a>
<a name="ln3877">    case NFA_NWORD:</a>
<a name="ln3878">    case NFA_HEAD:</a>
<a name="ln3879">    case NFA_NHEAD:</a>
<a name="ln3880">    case NFA_ALPHA:</a>
<a name="ln3881">    case NFA_NALPHA:</a>
<a name="ln3882">    case NFA_LOWER:</a>
<a name="ln3883">    case NFA_NLOWER:</a>
<a name="ln3884">    case NFA_UPPER:</a>
<a name="ln3885">    case NFA_NUPPER:</a>
<a name="ln3886">    case NFA_LOWER_IC:</a>
<a name="ln3887">    case NFA_NLOWER_IC:</a>
<a name="ln3888">    case NFA_UPPER_IC:</a>
<a name="ln3889">    case NFA_NUPPER_IC:</a>
<a name="ln3890">    case NFA_START_COLL:</a>
<a name="ln3891">    case NFA_START_NEG_COLL:</a>
<a name="ln3892">    case NFA_NEWL:</a>
<a name="ln3893">      // state will advance input</a>
<a name="ln3894">      return false;</a>
<a name="ln3895"> </a>
<a name="ln3896">    default:</a>
<a name="ln3897">      if (state-&gt;c &gt; 0) {</a>
<a name="ln3898">        // state will advance input</a>
<a name="ln3899">        return false;</a>
<a name="ln3900">      }</a>
<a name="ln3901">      // Others: zero-width or possibly zero-width, might still find</a>
<a name="ln3902">      // a match at the same position, keep looking.</a>
<a name="ln3903">      break;</a>
<a name="ln3904">    }</a>
<a name="ln3905">    state = state-&gt;out;</a>
<a name="ln3906">  }</a>
<a name="ln3907">  return false;</a>
<a name="ln3908">}</a>
<a name="ln3909"> </a>
<a name="ln3910"> </a>
<a name="ln3911">// Return true if &quot;state&quot; is already in list &quot;l&quot;.</a>
<a name="ln3912">static bool state_in_list(</a>
<a name="ln3913">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3914">    nfa_state_T *state,   // state to update</a>
<a name="ln3915">    regsubs_T *subs       // pointers to subexpressions</a>
<a name="ln3916">)</a>
<a name="ln3917">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3918">{</a>
<a name="ln3919">  if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id) {</a>
<a name="ln3920">    if (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL)) {</a>
<a name="ln3921">      return true;</a>
<a name="ln3922">    }</a>
<a name="ln3923">  }</a>
<a name="ln3924">  return false;</a>
<a name="ln3925">}</a>
<a name="ln3926"> </a>
<a name="ln3927">// Offset used for &quot;off&quot; by addstate_here().</a>
<a name="ln3928">#define ADDSTATE_HERE_OFFSET 10</a>
<a name="ln3929"> </a>
<a name="ln3930">// Add &quot;state&quot; and possibly what follows to state list &quot;.&quot;.</a>
<a name="ln3931">// Returns &quot;subs_arg&quot;, possibly copied into temp_subs.</a>
<a name="ln3932">// Returns NULL when recursiveness is too deep.</a>
<a name="ln3933">static regsubs_T *addstate(</a>
<a name="ln3934">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3935">    nfa_state_T *state,   // state to update</a>
<a name="ln3936">    regsubs_T *subs_arg,  // pointers to subexpressions</a>
<a name="ln3937">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln3938">    int off_arg)          // byte offset, when -1 go to next line</a>
<a name="ln3939">  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3940">{</a>
<a name="ln3941">  int subidx;</a>
<a name="ln3942">  int off = off_arg;</a>
<a name="ln3943">  int add_here = false;</a>
<a name="ln3944">  int listindex = 0;</a>
<a name="ln3945">  int k;</a>
<a name="ln3946">  int found = false;</a>
<a name="ln3947">  nfa_thread_T        *thread;</a>
<a name="ln3948">  struct multipos     save_multipos;</a>
<a name="ln3949">  int save_in_use;</a>
<a name="ln3950">  char_u              *save_ptr;</a>
<a name="ln3951">  int i;</a>
<a name="ln3952">  regsub_T            *sub;</a>
<a name="ln3953">  regsubs_T           *subs = subs_arg;</a>
<a name="ln3954">  static regsubs_T temp_subs;</a>
<a name="ln3955">#ifdef REGEXP_DEBUG</a>
<a name="ln3956">  int did_print = false;</a>
<a name="ln3957">#endif</a>
<a name="ln3958">  static int depth = 0;</a>
<a name="ln3959"> </a>
<a name="ln3960">  // This function is called recursively.  When the depth is too much we run</a>
<a name="ln3961">  // out of stack and crash, limit recursiveness here.</a>
<a name="ln3962">  if (++depth &gt;= 5000 || subs == NULL) {</a>
<a name="ln3963">    depth--;</a>
<a name="ln3964">    return NULL;</a>
<a name="ln3965">  }</a>
<a name="ln3966"> </a>
<a name="ln3967">  if (off_arg &lt;= -ADDSTATE_HERE_OFFSET) {</a>
<a name="ln3968">    add_here = true;</a>
<a name="ln3969">    off = 0;</a>
<a name="ln3970">    listindex = -(off_arg + ADDSTATE_HERE_OFFSET);</a>
<a name="ln3971">  }</a>
<a name="ln3972"> </a>
<a name="ln3973">  switch (state-&gt;c) {</a>
<a name="ln3974">  case NFA_NCLOSE:</a>
<a name="ln3975">  case NFA_MCLOSE:</a>
<a name="ln3976">  case NFA_MCLOSE1:</a>
<a name="ln3977">  case NFA_MCLOSE2:</a>
<a name="ln3978">  case NFA_MCLOSE3:</a>
<a name="ln3979">  case NFA_MCLOSE4:</a>
<a name="ln3980">  case NFA_MCLOSE5:</a>
<a name="ln3981">  case NFA_MCLOSE6:</a>
<a name="ln3982">  case NFA_MCLOSE7:</a>
<a name="ln3983">  case NFA_MCLOSE8:</a>
<a name="ln3984">  case NFA_MCLOSE9:</a>
<a name="ln3985">  case NFA_ZCLOSE:</a>
<a name="ln3986">  case NFA_ZCLOSE1:</a>
<a name="ln3987">  case NFA_ZCLOSE2:</a>
<a name="ln3988">  case NFA_ZCLOSE3:</a>
<a name="ln3989">  case NFA_ZCLOSE4:</a>
<a name="ln3990">  case NFA_ZCLOSE5:</a>
<a name="ln3991">  case NFA_ZCLOSE6:</a>
<a name="ln3992">  case NFA_ZCLOSE7:</a>
<a name="ln3993">  case NFA_ZCLOSE8:</a>
<a name="ln3994">  case NFA_ZCLOSE9:</a>
<a name="ln3995">  case NFA_MOPEN:</a>
<a name="ln3996">  case NFA_ZEND:</a>
<a name="ln3997">  case NFA_SPLIT:</a>
<a name="ln3998">  case NFA_EMPTY:</a>
<a name="ln3999">    /* These nodes are not added themselves but their &quot;out&quot; and/or</a>
<a name="ln4000">     * &quot;out1&quot; may be added below.  */</a>
<a name="ln4001">    break;</a>
<a name="ln4002"> </a>
<a name="ln4003">  case NFA_BOL:</a>
<a name="ln4004">  case NFA_BOF:</a>
<a name="ln4005">    // &quot;^&quot; won't match past end-of-line, don't bother trying.</a>
<a name="ln4006">    // Except when at the end of the line, or when we are going to the</a>
<a name="ln4007">    // next line for a look-behind match.</a>
<a name="ln4008">    if (rex.input &gt; rex.line</a>
<a name="ln4009">        &amp;&amp; *rex.input != NUL</a>
<a name="ln4010">        &amp;&amp; (nfa_endp == NULL</a>
<a name="ln4011">            || !REG_MULTI</a>
<a name="ln4012">            || rex.lnum == nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln4013">      goto skip_add;</a>
<a name="ln4014">    }</a>
<a name="ln4015">    FALLTHROUGH;</a>
<a name="ln4016"> </a>
<a name="ln4017">  case NFA_MOPEN1:</a>
<a name="ln4018">  case NFA_MOPEN2:</a>
<a name="ln4019">  case NFA_MOPEN3:</a>
<a name="ln4020">  case NFA_MOPEN4:</a>
<a name="ln4021">  case NFA_MOPEN5:</a>
<a name="ln4022">  case NFA_MOPEN6:</a>
<a name="ln4023">  case NFA_MOPEN7:</a>
<a name="ln4024">  case NFA_MOPEN8:</a>
<a name="ln4025">  case NFA_MOPEN9:</a>
<a name="ln4026">  case NFA_ZOPEN:</a>
<a name="ln4027">  case NFA_ZOPEN1:</a>
<a name="ln4028">  case NFA_ZOPEN2:</a>
<a name="ln4029">  case NFA_ZOPEN3:</a>
<a name="ln4030">  case NFA_ZOPEN4:</a>
<a name="ln4031">  case NFA_ZOPEN5:</a>
<a name="ln4032">  case NFA_ZOPEN6:</a>
<a name="ln4033">  case NFA_ZOPEN7:</a>
<a name="ln4034">  case NFA_ZOPEN8:</a>
<a name="ln4035">  case NFA_ZOPEN9:</a>
<a name="ln4036">  case NFA_NOPEN:</a>
<a name="ln4037">  case NFA_ZSTART:</a>
<a name="ln4038">  /* These nodes need to be added so that we can bail out when it</a>
<a name="ln4039">   * was added to this list before at the same position to avoid an</a>
<a name="ln4040">   * endless loop for &quot;\(\)*&quot; */</a>
<a name="ln4041"> </a>
<a name="ln4042">  default:</a>
<a name="ln4043">    if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id &amp;&amp; state-&gt;c != NFA_SKIP) {</a>
<a name="ln4044">      /* This state is already in the list, don't add it again,</a>
<a name="ln4045">       * unless it is an MOPEN that is used for a backreference or</a>
<a name="ln4046">       * when there is a PIM. For NFA_MATCH check the position,</a>
<a name="ln4047">       * lower position is preferred. */</a>
<a name="ln4048">      if (!rex.nfa_has_backref &amp;&amp; pim == NULL &amp;&amp; !l-&gt;has_pim</a>
<a name="ln4049">          &amp;&amp; state-&gt;c != NFA_MATCH) {</a>
<a name="ln4050"> </a>
<a name="ln4051">        /* When called from addstate_here() do insert before</a>
<a name="ln4052">         * existing states. */</a>
<a name="ln4053">        if (add_here) {</a>
<a name="ln4054">          for (k = 0; k &lt; l-&gt;n &amp;&amp; k &lt; listindex; ++k) {</a>
<a name="ln4055">            if (l-&gt;t[k].state-&gt;id == state-&gt;id) {</a>
<a name="ln4056">              found = true;</a>
<a name="ln4057">              break;</a>
<a name="ln4058">            }</a>
<a name="ln4059">          }</a>
<a name="ln4060">        }</a>
<a name="ln4061"> </a>
<a name="ln4062">        if (!add_here || found) {</a>
<a name="ln4063">skip_add:</a>
<a name="ln4064">#ifdef REGEXP_DEBUG</a>
<a name="ln4065">          nfa_set_code(state-&gt;c);</a>
<a name="ln4066">          fprintf(log_fd, &quot;&gt; Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\n&quot;,</a>
<a name="ln4067">                  abs(state-&gt;id), l-&gt;id, state-&gt;c, code,</a>
<a name="ln4068">                  pim == NULL ? &quot;NULL&quot; : &quot;yes&quot;, l-&gt;has_pim, found);</a>
<a name="ln4069">#endif</a>
<a name="ln4070">        depth--;</a>
<a name="ln4071">        return subs;</a>
<a name="ln4072">        }</a>
<a name="ln4073">      }</a>
<a name="ln4074"> </a>
<a name="ln4075">      /* Do not add the state again when it exists with the same</a>
<a name="ln4076">       * positions. */</a>
<a name="ln4077">      if (has_state_with_pos(l, state, subs, pim))</a>
<a name="ln4078">        goto skip_add;</a>
<a name="ln4079">    }</a>
<a name="ln4080"> </a>
<a name="ln4081">    // When there are backreferences or PIMs the number of states may</a>
<a name="ln4082">    // be (a lot) bigger than anticipated.</a>
<a name="ln4083">    if (l-&gt;n == l-&gt;len) {</a>
<a name="ln4084">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4085">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4086"> </a>
<a name="ln4087">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4088">        EMSG(_(e_maxmempat));</a>
<a name="ln4089">        depth--;</a>
<a name="ln4090">        return NULL;</a>
<a name="ln4091">      }</a>
<a name="ln4092">      if (subs != &amp;temp_subs) {</a>
<a name="ln4093">        // &quot;subs&quot; may point into the current array, need to make a</a>
<a name="ln4094">        // copy before it becomes invalid.</a>
<a name="ln4095">        copy_sub(&amp;temp_subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4096">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4097">          copy_sub(&amp;temp_subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4098">        }</a>
<a name="ln4099">        subs = &amp;temp_subs;</a>
<a name="ln4100">      }</a>
<a name="ln4101"> </a>
<a name="ln4102">      nfa_thread_T *const newt = xrealloc(l-&gt;t, newsize);</a>
<a name="ln4103">      l-&gt;t = newt;</a>
<a name="ln4104">      l-&gt;len = newlen;</a>
<a name="ln4105">    }</a>
<a name="ln4106"> </a>
<a name="ln4107">    /* add the state to the list */</a>
<a name="ln4108">    state-&gt;lastlist[nfa_ll_index] = l-&gt;id;</a>
<a name="ln4109">    thread = &amp;l-&gt;t[l-&gt;n++];</a>
<a name="ln4110">    thread-&gt;state = state;</a>
<a name="ln4111">    if (pim == NULL)</a>
<a name="ln4112">      thread-&gt;pim.result = NFA_PIM_UNUSED;</a>
<a name="ln4113">    else {</a>
<a name="ln4114">      copy_pim(&amp;thread-&gt;pim, pim);</a>
<a name="ln4115">      l-&gt;has_pim = true;</a>
<a name="ln4116">    }</a>
<a name="ln4117">    copy_sub(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4118">    if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4119">      copy_sub(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4120">    }</a>
<a name="ln4121">#ifdef REGEXP_DEBUG</a>
<a name="ln4122">    report_state(&quot;Adding&quot;, &amp;thread-&gt;subs.norm, state, l-&gt;id, pim);</a>
<a name="ln4123">    did_print = true;</a>
<a name="ln4124">#endif</a>
<a name="ln4125">  }</a>
<a name="ln4126"> </a>
<a name="ln4127">#ifdef REGEXP_DEBUG</a>
<a name="ln4128">  if (!did_print)</a>
<a name="ln4129">    report_state(&quot;Processing&quot;, &amp;subs-&gt;norm, state, l-&gt;id, pim);</a>
<a name="ln4130">#endif</a>
<a name="ln4131">  switch (state-&gt;c) {</a>
<a name="ln4132">  case NFA_MATCH:</a>
<a name="ln4133">    break;</a>
<a name="ln4134"> </a>
<a name="ln4135">  case NFA_SPLIT:</a>
<a name="ln4136">    /* order matters here */</a>
<a name="ln4137">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4138">    subs = addstate(l, state-&gt;out1, subs, pim, off_arg);</a>
<a name="ln4139">    break;</a>
<a name="ln4140"> </a>
<a name="ln4141">  case NFA_EMPTY:</a>
<a name="ln4142">  case NFA_NOPEN:</a>
<a name="ln4143">  case NFA_NCLOSE:</a>
<a name="ln4144">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4145">    break;</a>
<a name="ln4146"> </a>
<a name="ln4147">  case NFA_MOPEN:</a>
<a name="ln4148">  case NFA_MOPEN1:</a>
<a name="ln4149">  case NFA_MOPEN2:</a>
<a name="ln4150">  case NFA_MOPEN3:</a>
<a name="ln4151">  case NFA_MOPEN4:</a>
<a name="ln4152">  case NFA_MOPEN5:</a>
<a name="ln4153">  case NFA_MOPEN6:</a>
<a name="ln4154">  case NFA_MOPEN7:</a>
<a name="ln4155">  case NFA_MOPEN8:</a>
<a name="ln4156">  case NFA_MOPEN9:</a>
<a name="ln4157">  case NFA_ZOPEN:</a>
<a name="ln4158">  case NFA_ZOPEN1:</a>
<a name="ln4159">  case NFA_ZOPEN2:</a>
<a name="ln4160">  case NFA_ZOPEN3:</a>
<a name="ln4161">  case NFA_ZOPEN4:</a>
<a name="ln4162">  case NFA_ZOPEN5:</a>
<a name="ln4163">  case NFA_ZOPEN6:</a>
<a name="ln4164">  case NFA_ZOPEN7:</a>
<a name="ln4165">  case NFA_ZOPEN8:</a>
<a name="ln4166">  case NFA_ZOPEN9:</a>
<a name="ln4167">  case NFA_ZSTART:</a>
<a name="ln4168">    if (state-&gt;c == NFA_ZSTART) {</a>
<a name="ln4169">      subidx = 0;</a>
<a name="ln4170">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4171">    } else if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4172">      subidx = state-&gt;c - NFA_ZOPEN;</a>
<a name="ln4173">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4174">    } else {</a>
<a name="ln4175">      subidx = state-&gt;c - NFA_MOPEN;</a>
<a name="ln4176">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4177">    }</a>
<a name="ln4178"> </a>
<a name="ln4179">    /* avoid compiler warnings */</a>
<a name="ln4180">    save_ptr = NULL;</a>
<a name="ln4181">    memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4182"> </a>
<a name="ln4183">    /* Set the position (with &quot;off&quot; added) in the subexpression.  Save</a>
<a name="ln4184">     * and restore it when it was in use.  Otherwise fill any gap. */</a>
<a name="ln4185">    if (REG_MULTI) {</a>
<a name="ln4186">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4187">        save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4188">        save_in_use = -1;</a>
<a name="ln4189">      } else {</a>
<a name="ln4190">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4191">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4192">          sub-&gt;list.multi[i].start_lnum = -1;</a>
<a name="ln4193">          sub-&gt;list.multi[i].end_lnum = -1;</a>
<a name="ln4194">        }</a>
<a name="ln4195">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4196">      }</a>
<a name="ln4197">      if (off == -1) {</a>
<a name="ln4198">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum + 1;</a>
<a name="ln4199">        sub-&gt;list.multi[subidx].start_col = 0;</a>
<a name="ln4200">      } else {</a>
<a name="ln4201">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum;</a>
<a name="ln4202">        sub-&gt;list.multi[subidx].start_col =</a>
<a name="ln4203">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4204">      }</a>
<a name="ln4205">      sub-&gt;list.multi[subidx].end_lnum = -1;</a>
<a name="ln4206">    } else {</a>
<a name="ln4207">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4208">        save_ptr = sub-&gt;list.line[subidx].start;</a>
<a name="ln4209">        save_in_use = -1;</a>
<a name="ln4210">      } else {</a>
<a name="ln4211">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4212">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4213">          sub-&gt;list.line[i].start = NULL;</a>
<a name="ln4214">          sub-&gt;list.line[i].end = NULL;</a>
<a name="ln4215">        }</a>
<a name="ln4216">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4217">      }</a>
<a name="ln4218">      sub-&gt;list.line[subidx].start = rex.input + off;</a>
<a name="ln4219">    }</a>
<a name="ln4220"> </a>
<a name="ln4221">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4222">    if (subs == NULL) {</a>
<a name="ln4223">      break;</a>
<a name="ln4224">    }</a>
<a name="ln4225">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4226">    if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4227">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4228">    } else {</a>
<a name="ln4229">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4230">    }</a>
<a name="ln4231"> </a>
<a name="ln4232">    if (save_in_use == -1) {</a>
<a name="ln4233">      if (REG_MULTI) {</a>
<a name="ln4234">        sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4235">      }</a>
<a name="ln4236">      else</a>
<a name="ln4237">        sub-&gt;list.line[subidx].start = save_ptr;</a>
<a name="ln4238">    } else</a>
<a name="ln4239">      sub-&gt;in_use = save_in_use;</a>
<a name="ln4240">    break;</a>
<a name="ln4241"> </a>
<a name="ln4242">  case NFA_MCLOSE:</a>
<a name="ln4243">    if (rex.nfa_has_zend</a>
<a name="ln4244">        &amp;&amp; (REG_MULTI</a>
<a name="ln4245">            ? subs-&gt;norm.list.multi[0].end_lnum &gt;= 0</a>
<a name="ln4246">            : subs-&gt;norm.list.line[0].end != NULL)) {</a>
<a name="ln4247">      // Do not overwrite the position set by \ze.</a>
<a name="ln4248">      subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4249">      break;</a>
<a name="ln4250">    }</a>
<a name="ln4251">    FALLTHROUGH;</a>
<a name="ln4252">  case NFA_MCLOSE1:</a>
<a name="ln4253">  case NFA_MCLOSE2:</a>
<a name="ln4254">  case NFA_MCLOSE3:</a>
<a name="ln4255">  case NFA_MCLOSE4:</a>
<a name="ln4256">  case NFA_MCLOSE5:</a>
<a name="ln4257">  case NFA_MCLOSE6:</a>
<a name="ln4258">  case NFA_MCLOSE7:</a>
<a name="ln4259">  case NFA_MCLOSE8:</a>
<a name="ln4260">  case NFA_MCLOSE9:</a>
<a name="ln4261">  case NFA_ZCLOSE:</a>
<a name="ln4262">  case NFA_ZCLOSE1:</a>
<a name="ln4263">  case NFA_ZCLOSE2:</a>
<a name="ln4264">  case NFA_ZCLOSE3:</a>
<a name="ln4265">  case NFA_ZCLOSE4:</a>
<a name="ln4266">  case NFA_ZCLOSE5:</a>
<a name="ln4267">  case NFA_ZCLOSE6:</a>
<a name="ln4268">  case NFA_ZCLOSE7:</a>
<a name="ln4269">  case NFA_ZCLOSE8:</a>
<a name="ln4270">  case NFA_ZCLOSE9:</a>
<a name="ln4271">  case NFA_ZEND:</a>
<a name="ln4272">    if (state-&gt;c == NFA_ZEND) {</a>
<a name="ln4273">      subidx = 0;</a>
<a name="ln4274">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4275">    } else if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4276">      subidx = state-&gt;c - NFA_ZCLOSE;</a>
<a name="ln4277">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4278">    } else {</a>
<a name="ln4279">      subidx = state-&gt;c - NFA_MCLOSE;</a>
<a name="ln4280">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4281">    }</a>
<a name="ln4282"> </a>
<a name="ln4283">    /* We don't fill in gaps here, there must have been an MOPEN that</a>
<a name="ln4284">     * has done that. */</a>
<a name="ln4285">    save_in_use = sub-&gt;in_use;</a>
<a name="ln4286">    if (sub-&gt;in_use &lt;= subidx)</a>
<a name="ln4287">      sub-&gt;in_use = subidx + 1;</a>
<a name="ln4288">    if (REG_MULTI) {</a>
<a name="ln4289">      save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4290">      if (off == -1) {</a>
<a name="ln4291">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum + 1;</a>
<a name="ln4292">        sub-&gt;list.multi[subidx].end_col = 0;</a>
<a name="ln4293">      } else {</a>
<a name="ln4294">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum;</a>
<a name="ln4295">        sub-&gt;list.multi[subidx].end_col =</a>
<a name="ln4296">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4297">      }</a>
<a name="ln4298">      /* avoid compiler warnings */</a>
<a name="ln4299">      save_ptr = NULL;</a>
<a name="ln4300">    } else {</a>
<a name="ln4301">      save_ptr = sub-&gt;list.line[subidx].end;</a>
<a name="ln4302">      sub-&gt;list.line[subidx].end = rex.input + off;</a>
<a name="ln4303">      // avoid compiler warnings</a>
<a name="ln4304">      memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4305">    }</a>
<a name="ln4306"> </a>
<a name="ln4307">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4308">    if (subs == NULL) {</a>
<a name="ln4309">      break;</a>
<a name="ln4310">    }</a>
<a name="ln4311">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4312">    if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4313">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4314">    } else {</a>
<a name="ln4315">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4316">    }</a>
<a name="ln4317"> </a>
<a name="ln4318">    if (REG_MULTI) {</a>
<a name="ln4319">      sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4320">    }</a>
<a name="ln4321">    else</a>
<a name="ln4322">      sub-&gt;list.line[subidx].end = save_ptr;</a>
<a name="ln4323">    sub-&gt;in_use = save_in_use;</a>
<a name="ln4324">    break;</a>
<a name="ln4325">  }</a>
<a name="ln4326">  depth--;</a>
<a name="ln4327">  return subs;</a>
<a name="ln4328">}</a>
<a name="ln4329"> </a>
<a name="ln4330">/*</a>
<a name="ln4331"> * Like addstate(), but the new state(s) are put at position &quot;*ip&quot;.</a>
<a name="ln4332"> * Used for zero-width matches, next state to use is the added one.</a>
<a name="ln4333"> * This makes sure the order of states to be tried does not change, which</a>
<a name="ln4334"> * matters for alternatives.</a>
<a name="ln4335"> */</a>
<a name="ln4336">static regsubs_T *addstate_here(</a>
<a name="ln4337">    nfa_list_T *l,        // runtime state list</a>
<a name="ln4338">    nfa_state_T *state,   // state to update</a>
<a name="ln4339">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln4340">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln4341">    int *ip</a>
<a name="ln4342">)</a>
<a name="ln4343">  FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4344">{</a>
<a name="ln4345">  int tlen = l-&gt;n;</a>
<a name="ln4346">  int count;</a>
<a name="ln4347">  int listidx = *ip;</a>
<a name="ln4348"> </a>
<a name="ln4349">  /* First add the state(s) at the end, so that we know how many there are.</a>
<a name="ln4350">   * Pass the listidx as offset (avoids adding another argument to</a>
<a name="ln4351">   * addstate(). */</a>
<a name="ln4352">  regsubs_T *r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);</a>
<a name="ln4353">  if (r == NULL) {</a>
<a name="ln4354">    return NULL;</a>
<a name="ln4355">  }</a>
<a name="ln4356"> </a>
<a name="ln4357">  // when &quot;*ip&quot; was at the end of the list, nothing to do</a>
<a name="ln4358">  if (listidx + 1 == tlen) {</a>
<a name="ln4359">    return r;</a>
<a name="ln4360">  }</a>
<a name="ln4361"> </a>
<a name="ln4362">  // re-order to put the new state at the current position</a>
<a name="ln4363">  count = l-&gt;n - tlen;</a>
<a name="ln4364">  if (count == 0) {</a>
<a name="ln4365">    return r;  // no state got added</a>
<a name="ln4366">  }</a>
<a name="ln4367">  if (count == 1) {</a>
<a name="ln4368">    // overwrite the current state</a>
<a name="ln4369">    l-&gt;t[listidx] = l-&gt;t[l-&gt;n - 1];</a>
<a name="ln4370">  } else if (count &gt; 1) {</a>
<a name="ln4371">    if (l-&gt;n + count - 1 &gt;= l-&gt;len) {</a>
<a name="ln4372">      /* not enough space to move the new states, reallocate the list</a>
<a name="ln4373">       * and move the states to the right position */</a>
<a name="ln4374">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4375">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4376"> </a>
<a name="ln4377">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4378">        EMSG(_(e_maxmempat));</a>
<a name="ln4379">        return NULL;</a>
<a name="ln4380">      }</a>
<a name="ln4381">      nfa_thread_T *const newl = xmalloc(newsize);</a>
<a name="ln4382">      l-&gt;len = newlen;</a>
<a name="ln4383">      memmove(&amp;(newl[0]),</a>
<a name="ln4384">          &amp;(l-&gt;t[0]),</a>
<a name="ln4385">          sizeof(nfa_thread_T) * listidx);</a>
<a name="ln4386">      memmove(&amp;(newl[listidx]),</a>
<a name="ln4387">          &amp;(l-&gt;t[l-&gt;n - count]),</a>
<a name="ln4388">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4389">      memmove(&amp;(newl[listidx + count]),</a>
<a name="ln4390">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4391">          sizeof(nfa_thread_T) * (l-&gt;n - count - listidx - 1));</a>
<a name="ln4392">      xfree(l-&gt;t);</a>
<a name="ln4393">      l-&gt;t = newl;</a>
<a name="ln4394">    } else {</a>
<a name="ln4395">      /* make space for new states, then move them from the</a>
<a name="ln4396">       * end to the current position */</a>
<a name="ln4397">      memmove(&amp;(l-&gt;t[listidx + count]),</a>
<a name="ln4398">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4399">          sizeof(nfa_thread_T) * (l-&gt;n - listidx - 1));</a>
<a name="ln4400">      memmove(&amp;(l-&gt;t[listidx]),</a>
<a name="ln4401">          &amp;(l-&gt;t[l-&gt;n - 1]),</a>
<a name="ln4402">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4403">    }</a>
<a name="ln4404">  }</a>
<a name="ln4405">  --l-&gt;n;</a>
<a name="ln4406">  *ip = listidx - 1;</a>
<a name="ln4407"> </a>
<a name="ln4408">  return r;</a>
<a name="ln4409">}</a>
<a name="ln4410"> </a>
<a name="ln4411">/*</a>
<a name="ln4412"> * Check character class &quot;class&quot; against current character c.</a>
<a name="ln4413"> */</a>
<a name="ln4414">static int check_char_class(int class, int c)</a>
<a name="ln4415">{</a>
<a name="ln4416">  switch (class) {</a>
<a name="ln4417">  case NFA_CLASS_ALNUM:</a>
<a name="ln4418">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalnum(c)) {</a>
<a name="ln4419">      return OK;</a>
<a name="ln4420">    }</a>
<a name="ln4421">    break;</a>
<a name="ln4422">  case NFA_CLASS_ALPHA:</a>
<a name="ln4423">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalpha(c)) {</a>
<a name="ln4424">      return OK;</a>
<a name="ln4425">    }</a>
<a name="ln4426">    break;</a>
<a name="ln4427">  case NFA_CLASS_BLANK:</a>
<a name="ln4428">    if (c == ' ' || c == '\t')</a>
<a name="ln4429">      return OK;</a>
<a name="ln4430">    break;</a>
<a name="ln4431">  case NFA_CLASS_CNTRL:</a>
<a name="ln4432">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; iscntrl(c)) {</a>
<a name="ln4433">      return OK;</a>
<a name="ln4434">    }</a>
<a name="ln4435">    break;</a>
<a name="ln4436">  case NFA_CLASS_DIGIT:</a>
<a name="ln4437">    if (ascii_isdigit(c))</a>
<a name="ln4438">      return OK;</a>
<a name="ln4439">    break;</a>
<a name="ln4440">  case NFA_CLASS_GRAPH:</a>
<a name="ln4441">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; isgraph(c)) {</a>
<a name="ln4442">      return OK;</a>
<a name="ln4443">    }</a>
<a name="ln4444">    break;</a>
<a name="ln4445">  case NFA_CLASS_LOWER:</a>
<a name="ln4446">    if (mb_islower(c) &amp;&amp; c != 170 &amp;&amp; c != 186) {</a>
<a name="ln4447">      return OK;</a>
<a name="ln4448">    }</a>
<a name="ln4449">    break;</a>
<a name="ln4450">  case NFA_CLASS_PRINT:</a>
<a name="ln4451">    if (vim_isprintc(c))</a>
<a name="ln4452">      return OK;</a>
<a name="ln4453">    break;</a>
<a name="ln4454">  case NFA_CLASS_PUNCT:</a>
<a name="ln4455">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; ispunct(c)) {</a>
<a name="ln4456">      return OK;</a>
<a name="ln4457">    }</a>
<a name="ln4458">    break;</a>
<a name="ln4459">  case NFA_CLASS_SPACE:</a>
<a name="ln4460">    if ((c &gt;= 9 &amp;&amp; c &lt;= 13) || (c == ' '))</a>
<a name="ln4461">      return OK;</a>
<a name="ln4462">    break;</a>
<a name="ln4463">  case NFA_CLASS_UPPER:</a>
<a name="ln4464">    if (mb_isupper(c)) {</a>
<a name="ln4465">      return OK;</a>
<a name="ln4466">    }</a>
<a name="ln4467">    break;</a>
<a name="ln4468">  case NFA_CLASS_XDIGIT:</a>
<a name="ln4469">    if (ascii_isxdigit(c))</a>
<a name="ln4470">      return OK;</a>
<a name="ln4471">    break;</a>
<a name="ln4472">  case NFA_CLASS_TAB:</a>
<a name="ln4473">    if (c == '\t')</a>
<a name="ln4474">      return OK;</a>
<a name="ln4475">    break;</a>
<a name="ln4476">  case NFA_CLASS_RETURN:</a>
<a name="ln4477">    if (c == '\r')</a>
<a name="ln4478">      return OK;</a>
<a name="ln4479">    break;</a>
<a name="ln4480">  case NFA_CLASS_BACKSPACE:</a>
<a name="ln4481">    if (c == '\b')</a>
<a name="ln4482">      return OK;</a>
<a name="ln4483">    break;</a>
<a name="ln4484">  case NFA_CLASS_ESCAPE:</a>
<a name="ln4485">    if (c == ESC) {</a>
<a name="ln4486">      return OK;</a>
<a name="ln4487">    }</a>
<a name="ln4488">    break;</a>
<a name="ln4489">  case NFA_CLASS_IDENT:</a>
<a name="ln4490">    if (vim_isIDc(c)) {</a>
<a name="ln4491">      return OK;</a>
<a name="ln4492">    }</a>
<a name="ln4493">    break;</a>
<a name="ln4494">  case NFA_CLASS_KEYWORD:</a>
<a name="ln4495">    if (reg_iswordc(c)) {</a>
<a name="ln4496">      return OK;</a>
<a name="ln4497">    }</a>
<a name="ln4498">    break;</a>
<a name="ln4499">  case NFA_CLASS_FNAME:</a>
<a name="ln4500">    if (vim_isfilec(c)) {</a>
<a name="ln4501">      return OK;</a>
<a name="ln4502">    }</a>
<a name="ln4503">    break;</a>
<a name="ln4504"> </a>
<a name="ln4505">  default:</a>
<a name="ln4506">    // should not be here :P</a>
<a name="ln4507">    IEMSGN(_(e_ill_char_class), class);</a>
<a name="ln4508">    return FAIL;</a>
<a name="ln4509">  }</a>
<a name="ln4510">  return FAIL;</a>
<a name="ln4511">}</a>
<a name="ln4512"> </a>
<a name="ln4513">/*</a>
<a name="ln4514"> * Check for a match with subexpression &quot;subidx&quot;.</a>
<a name="ln4515"> * Return true if it matches.</a>
<a name="ln4516"> */</a>
<a name="ln4517">static int </a>
<a name="ln4518">match_backref (</a>
<a name="ln4519">    regsub_T *sub,           /* pointers to subexpressions */</a>
<a name="ln4520">    int subidx,</a>
<a name="ln4521">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4522">)</a>
<a name="ln4523">{</a>
<a name="ln4524">  int len;</a>
<a name="ln4525"> </a>
<a name="ln4526">  if (sub-&gt;in_use &lt;= subidx) {</a>
<a name="ln4527">retempty:</a>
<a name="ln4528">    /* backref was not set, match an empty string */</a>
<a name="ln4529">    *bytelen = 0;</a>
<a name="ln4530">    return true;</a>
<a name="ln4531">  }</a>
<a name="ln4532"> </a>
<a name="ln4533">  if (REG_MULTI) {</a>
<a name="ln4534">    if (sub-&gt;list.multi[subidx].start_lnum &lt; 0</a>
<a name="ln4535">        || sub-&gt;list.multi[subidx].end_lnum &lt; 0)</a>
<a name="ln4536">      goto retempty;</a>
<a name="ln4537">    if (sub-&gt;list.multi[subidx].start_lnum == rex.lnum</a>
<a name="ln4538">        &amp;&amp; sub-&gt;list.multi[subidx].end_lnum == rex.lnum) {</a>
<a name="ln4539">      len = sub-&gt;list.multi[subidx].end_col</a>
<a name="ln4540">            - sub-&gt;list.multi[subidx].start_col;</a>
<a name="ln4541">      if (cstrncmp(rex.line + sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4542">                   rex.input, &amp;len) == 0) {</a>
<a name="ln4543">        *bytelen = len;</a>
<a name="ln4544">        return true;</a>
<a name="ln4545">      }</a>
<a name="ln4546">    } else {</a>
<a name="ln4547">      if (match_with_backref(sub-&gt;list.multi[subidx].start_lnum,</a>
<a name="ln4548">                             sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4549">                             sub-&gt;list.multi[subidx].end_lnum,</a>
<a name="ln4550">                             sub-&gt;list.multi[subidx].end_col,</a>
<a name="ln4551">                             bytelen) == RA_MATCH) {</a>
<a name="ln4552">        return true;</a>
<a name="ln4553">      }</a>
<a name="ln4554">    }</a>
<a name="ln4555">  } else {</a>
<a name="ln4556">    if (sub-&gt;list.line[subidx].start == NULL</a>
<a name="ln4557">        || sub-&gt;list.line[subidx].end == NULL)</a>
<a name="ln4558">      goto retempty;</a>
<a name="ln4559">    len = (int)(sub-&gt;list.line[subidx].end - sub-&gt;list.line[subidx].start);</a>
<a name="ln4560">    if (cstrncmp(sub-&gt;list.line[subidx].start, rex.input, &amp;len) == 0) {</a>
<a name="ln4561">      *bytelen = len;</a>
<a name="ln4562">      return true;</a>
<a name="ln4563">    }</a>
<a name="ln4564">  }</a>
<a name="ln4565">  return false;</a>
<a name="ln4566">}</a>
<a name="ln4567"> </a>
<a name="ln4568"> </a>
<a name="ln4569"> </a>
<a name="ln4570">/*</a>
<a name="ln4571"> * Check for a match with \z subexpression &quot;subidx&quot;.</a>
<a name="ln4572"> * Return true if it matches.</a>
<a name="ln4573"> */</a>
<a name="ln4574">static int </a>
<a name="ln4575">match_zref (</a>
<a name="ln4576">    int subidx,</a>
<a name="ln4577">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4578">)</a>
<a name="ln4579">{</a>
<a name="ln4580">  int len;</a>
<a name="ln4581"> </a>
<a name="ln4582">  cleanup_zsubexpr();</a>
<a name="ln4583">  if (re_extmatch_in == NULL || re_extmatch_in-&gt;matches[subidx] == NULL) {</a>
<a name="ln4584">    /* backref was not set, match an empty string */</a>
<a name="ln4585">    *bytelen = 0;</a>
<a name="ln4586">    return true;</a>
<a name="ln4587">  }</a>
<a name="ln4588"> </a>
<a name="ln4589">  len = (int)STRLEN(re_extmatch_in-&gt;matches[subidx]);</a>
<a name="ln4590">  if (cstrncmp(re_extmatch_in-&gt;matches[subidx], rex.input, &amp;len) == 0) {</a>
<a name="ln4591">    *bytelen = len;</a>
<a name="ln4592">    return true;</a>
<a name="ln4593">  }</a>
<a name="ln4594">  return false;</a>
<a name="ln4595">}</a>
<a name="ln4596"> </a>
<a name="ln4597">/*</a>
<a name="ln4598"> * Save list IDs for all NFA states of &quot;prog&quot; into &quot;list&quot;.</a>
<a name="ln4599"> * Also reset the IDs to zero.</a>
<a name="ln4600"> * Only used for the recursive value lastlist[1].</a>
<a name="ln4601"> */</a>
<a name="ln4602">static void nfa_save_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4603">{</a>
<a name="ln4604">  int i;</a>
<a name="ln4605">  nfa_state_T     *p;</a>
<a name="ln4606"> </a>
<a name="ln4607">  /* Order in the list is reverse, it's a bit faster that way. */</a>
<a name="ln4608">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4609">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4610">    list[i] = p-&gt;lastlist[1];</a>
<a name="ln4611">    p-&gt;lastlist[1] = 0;</a>
<a name="ln4612">    ++p;</a>
<a name="ln4613">  }</a>
<a name="ln4614">}</a>
<a name="ln4615"> </a>
<a name="ln4616">/*</a>
<a name="ln4617"> * Restore list IDs from &quot;list&quot; to all NFA states.</a>
<a name="ln4618"> */</a>
<a name="ln4619">static void nfa_restore_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4620">{</a>
<a name="ln4621">  int i;</a>
<a name="ln4622">  nfa_state_T     *p;</a>
<a name="ln4623"> </a>
<a name="ln4624">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4625">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4626">    p-&gt;lastlist[1] = list[i];</a>
<a name="ln4627">    ++p;</a>
<a name="ln4628">  }</a>
<a name="ln4629">}</a>
<a name="ln4630"> </a>
<a name="ln4631">static bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos)</a>
<a name="ln4632">{</a>
<a name="ln4633">  if (op == 1) return pos &gt; val;</a>
<a name="ln4634">  if (op == 2) return pos &lt; val;</a>
<a name="ln4635">  return val == pos;</a>
<a name="ln4636">}</a>
<a name="ln4637"> </a>
<a name="ln4638"> </a>
<a name="ln4639">/*</a>
<a name="ln4640"> * Recursively call nfa_regmatch()</a>
<a name="ln4641"> * &quot;pim&quot; is NULL or contains info about a Postponed Invisible Match (start</a>
<a name="ln4642"> * position).</a>
<a name="ln4643"> */</a>
<a name="ln4644">static int recursive_regmatch(</a>
<a name="ln4645">    nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog,</a>
<a name="ln4646">    regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len)</a>
<a name="ln4647">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7)</a>
<a name="ln4648">{</a>
<a name="ln4649">  const int save_reginput_col = (int)(rex.input - rex.line);</a>
<a name="ln4650">  const int save_reglnum = rex.lnum;</a>
<a name="ln4651">  const int save_nfa_match = nfa_match;</a>
<a name="ln4652">  const int save_nfa_listid = rex.nfa_listid;</a>
<a name="ln4653">  save_se_T *const save_nfa_endp = nfa_endp;</a>
<a name="ln4654">  save_se_T endpos;</a>
<a name="ln4655">  save_se_T   *endposp = NULL;</a>
<a name="ln4656">  int need_restore = false;</a>
<a name="ln4657"> </a>
<a name="ln4658">  if (pim != NULL) {</a>
<a name="ln4659">    // start at the position where the postponed match was</a>
<a name="ln4660">    if (REG_MULTI) {</a>
<a name="ln4661">      rex.input = rex.line + pim-&gt;end.pos.col;</a>
<a name="ln4662">    } else {</a>
<a name="ln4663">      rex.input = pim-&gt;end.ptr;</a>
<a name="ln4664">    }</a>
<a name="ln4665">  }</a>
<a name="ln4666"> </a>
<a name="ln4667">  if (state-&gt;c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln4668">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln4669">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln4670">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln4671">    // The recursive match must end at the current position. When &quot;pim&quot; is</a>
<a name="ln4672">    // not NULL it specifies the current position.</a>
<a name="ln4673">    endposp = &amp;endpos;</a>
<a name="ln4674">    if (REG_MULTI) {</a>
<a name="ln4675">      if (pim == NULL) {</a>
<a name="ln4676">        endpos.se_u.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln4677">        endpos.se_u.pos.lnum = rex.lnum;</a>
<a name="ln4678">      } else {</a>
<a name="ln4679">        endpos.se_u.pos = pim-&gt;end.pos;</a>
<a name="ln4680">      }</a>
<a name="ln4681">    } else {</a>
<a name="ln4682">      if (pim == NULL) {</a>
<a name="ln4683">        endpos.se_u.ptr = rex.input;</a>
<a name="ln4684">      } else {</a>
<a name="ln4685">        endpos.se_u.ptr = pim-&gt;end.ptr;</a>
<a name="ln4686">      }</a>
<a name="ln4687">    }</a>
<a name="ln4688"> </a>
<a name="ln4689">    // Go back the specified number of bytes, or as far as the</a>
<a name="ln4690">    // start of the previous line, to try matching &quot;\@&lt;=&quot; or</a>
<a name="ln4691">    // not matching &quot;\@&lt;!&quot;. This is very inefficient, limit the number of</a>
<a name="ln4692">    // bytes if possible.</a>
<a name="ln4693">    if (state-&gt;val &lt;= 0) {</a>
<a name="ln4694">      if (REG_MULTI) {</a>
<a name="ln4695">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4696">        if (rex.line == NULL) {</a>
<a name="ln4697">          // can't go before the first line</a>
<a name="ln4698">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4699">        }</a>
<a name="ln4700">      }</a>
<a name="ln4701">      rex.input = rex.line;</a>
<a name="ln4702">    } else {</a>
<a name="ln4703">      if (REG_MULTI &amp;&amp; (int)(rex.input - rex.line) &lt; state-&gt;val) {</a>
<a name="ln4704">        // Not enough bytes in this line, go to end of</a>
<a name="ln4705">        // previous line.</a>
<a name="ln4706">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4707">        if (rex.line == NULL) {</a>
<a name="ln4708">          // can't go before the first line</a>
<a name="ln4709">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4710">          rex.input = rex.line;</a>
<a name="ln4711">        } else {</a>
<a name="ln4712">          rex.input = rex.line + STRLEN(rex.line);</a>
<a name="ln4713">        }</a>
<a name="ln4714">      }</a>
<a name="ln4715">      if ((int)(rex.input - rex.line) &gt;= state-&gt;val) {</a>
<a name="ln4716">        rex.input -= state-&gt;val;</a>
<a name="ln4717">        rex.input -= utf_head_off(rex.line, rex.input);</a>
<a name="ln4718">      } else {</a>
<a name="ln4719">        rex.input = rex.line;</a>
<a name="ln4720">      }</a>
<a name="ln4721">    }</a>
<a name="ln4722">  }</a>
<a name="ln4723"> </a>
<a name="ln4724">#ifdef REGEXP_DEBUG</a>
<a name="ln4725">  if (log_fd != stderr)</a>
<a name="ln4726">    fclose(log_fd);</a>
<a name="ln4727">  log_fd = NULL;</a>
<a name="ln4728">#endif</a>
<a name="ln4729">  // Have to clear the lastlist field of the NFA nodes, so that</a>
<a name="ln4730">  // nfa_regmatch() and addstate() can run properly after recursion.</a>
<a name="ln4731">  if (nfa_ll_index == 1) {</a>
<a name="ln4732">    // Already calling nfa_regmatch() recursively.  Save the lastlist[1]</a>
<a name="ln4733">    // values and clear them.</a>
<a name="ln4734">    if (*listids == NULL || *listids_len &lt; prog-&gt;nstate) {</a>
<a name="ln4735">      xfree(*listids);</a>
<a name="ln4736">      *listids = xmalloc(sizeof(**listids) * prog-&gt;nstate);</a>
<a name="ln4737">      *listids_len = prog-&gt;nstate;</a>
<a name="ln4738">    }</a>
<a name="ln4739">    nfa_save_listids(prog, *listids);</a>
<a name="ln4740">    need_restore = true;</a>
<a name="ln4741">    // any value of rex.nfa_listid will do</a>
<a name="ln4742">  } else {</a>
<a name="ln4743">    // First recursive nfa_regmatch() call, switch to the second lastlist</a>
<a name="ln4744">    // entry.  Make sure rex.nfa_listid is different from a previous</a>
<a name="ln4745">    // recursive call, because some states may still have this ID.</a>
<a name="ln4746">    nfa_ll_index++;</a>
<a name="ln4747">    if (rex.nfa_listid &lt;= rex.nfa_alt_listid) {</a>
<a name="ln4748">      rex.nfa_listid = rex.nfa_alt_listid;</a>
<a name="ln4749">    }</a>
<a name="ln4750">  }</a>
<a name="ln4751"> </a>
<a name="ln4752">  // Call nfa_regmatch() to check if the current concat matches at this</a>
<a name="ln4753">  // position. The concat ends with the node NFA_END_INVISIBLE</a>
<a name="ln4754">  nfa_endp = endposp;</a>
<a name="ln4755">  const int result = nfa_regmatch(prog, state-&gt;out, submatch, m);</a>
<a name="ln4756"> </a>
<a name="ln4757">  if (need_restore) {</a>
<a name="ln4758">    nfa_restore_listids(prog, *listids);</a>
<a name="ln4759">  } else {</a>
<a name="ln4760">    nfa_ll_index--;</a>
<a name="ln4761">    rex.nfa_alt_listid = rex.nfa_listid;</a>
<a name="ln4762">  }</a>
<a name="ln4763"> </a>
<a name="ln4764">  // restore position in input text</a>
<a name="ln4765">  rex.lnum = save_reglnum;</a>
<a name="ln4766">  if (REG_MULTI) {</a>
<a name="ln4767">    rex.line = reg_getline(rex.lnum);</a>
<a name="ln4768">  }</a>
<a name="ln4769">  rex.input = rex.line + save_reginput_col;</a>
<a name="ln4770">  if (result != NFA_TOO_EXPENSIVE) {</a>
<a name="ln4771">    nfa_match = save_nfa_match;</a>
<a name="ln4772">    rex.nfa_listid = save_nfa_listid;</a>
<a name="ln4773">  }</a>
<a name="ln4774">  nfa_endp = save_nfa_endp;</a>
<a name="ln4775"> </a>
<a name="ln4776">#ifdef REGEXP_DEBUG</a>
<a name="ln4777">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln4778">  if (log_fd != NULL) {</a>
<a name="ln4779">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4780">    fprintf(log_fd, &quot;FINISHED RUNNING nfa_regmatch() recursively\n&quot;);</a>
<a name="ln4781">    fprintf(log_fd, &quot;MATCH = %s\n&quot;, !result ? &quot;false&quot; : &quot;OK&quot;);</a>
<a name="ln4782">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4783">  } else {</a>
<a name="ln4784">    EMSG(_(e_log_open_failed));</a>
<a name="ln4785">    log_fd = stderr;</a>
<a name="ln4786">  }</a>
<a name="ln4787">#endif</a>
<a name="ln4788"> </a>
<a name="ln4789">  return result;</a>
<a name="ln4790">}</a>
<a name="ln4791"> </a>
<a name="ln4792"> </a>
<a name="ln4793">/*</a>
<a name="ln4794"> * Estimate the chance of a match with &quot;state&quot; failing.</a>
<a name="ln4795"> * empty match: 0</a>
<a name="ln4796"> * NFA_ANY: 1</a>
<a name="ln4797"> * specific character: 99</a>
<a name="ln4798"> */</a>
<a name="ln4799">static int failure_chance(nfa_state_T *state, int depth)</a>
<a name="ln4800">{</a>
<a name="ln4801">  int c = state-&gt;c;</a>
<a name="ln4802">  int l, r;</a>
<a name="ln4803"> </a>
<a name="ln4804">  /* detect looping */</a>
<a name="ln4805">  if (depth &gt; 4)</a>
<a name="ln4806">    return 1;</a>
<a name="ln4807"> </a>
<a name="ln4808">  switch (c) {</a>
<a name="ln4809">  case NFA_SPLIT:</a>
<a name="ln4810">    if (state-&gt;out-&gt;c == NFA_SPLIT || state-&gt;out1-&gt;c == NFA_SPLIT)</a>
<a name="ln4811">      /* avoid recursive stuff */</a>
<a name="ln4812">      return 1;</a>
<a name="ln4813">    /* two alternatives, use the lowest failure chance */</a>
<a name="ln4814">    l = failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4815">    r = failure_chance(state-&gt;out1, depth + 1);</a>
<a name="ln4816">    return l &lt; r ? l : r;</a>
<a name="ln4817"> </a>
<a name="ln4818">  case NFA_ANY:</a>
<a name="ln4819">    /* matches anything, unlikely to fail */</a>
<a name="ln4820">    return 1;</a>
<a name="ln4821"> </a>
<a name="ln4822">  case NFA_MATCH:</a>
<a name="ln4823">  case NFA_MCLOSE:</a>
<a name="ln4824">  case NFA_ANY_COMPOSING:</a>
<a name="ln4825">    /* empty match works always */</a>
<a name="ln4826">    return 0;</a>
<a name="ln4827"> </a>
<a name="ln4828">  case NFA_START_INVISIBLE:</a>
<a name="ln4829">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln4830">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln4831">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln4832">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln4833">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln4834">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln4835">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln4836">  case NFA_START_PATTERN:</a>
<a name="ln4837">    /* recursive regmatch is expensive, use low failure chance */</a>
<a name="ln4838">    return 5;</a>
<a name="ln4839"> </a>
<a name="ln4840">  case NFA_BOL:</a>
<a name="ln4841">  case NFA_EOL:</a>
<a name="ln4842">  case NFA_BOF:</a>
<a name="ln4843">  case NFA_EOF:</a>
<a name="ln4844">  case NFA_NEWL:</a>
<a name="ln4845">    return 99;</a>
<a name="ln4846"> </a>
<a name="ln4847">  case NFA_BOW:</a>
<a name="ln4848">  case NFA_EOW:</a>
<a name="ln4849">    return 90;</a>
<a name="ln4850"> </a>
<a name="ln4851">  case NFA_MOPEN:</a>
<a name="ln4852">  case NFA_MOPEN1:</a>
<a name="ln4853">  case NFA_MOPEN2:</a>
<a name="ln4854">  case NFA_MOPEN3:</a>
<a name="ln4855">  case NFA_MOPEN4:</a>
<a name="ln4856">  case NFA_MOPEN5:</a>
<a name="ln4857">  case NFA_MOPEN6:</a>
<a name="ln4858">  case NFA_MOPEN7:</a>
<a name="ln4859">  case NFA_MOPEN8:</a>
<a name="ln4860">  case NFA_MOPEN9:</a>
<a name="ln4861">  case NFA_ZOPEN:</a>
<a name="ln4862">  case NFA_ZOPEN1:</a>
<a name="ln4863">  case NFA_ZOPEN2:</a>
<a name="ln4864">  case NFA_ZOPEN3:</a>
<a name="ln4865">  case NFA_ZOPEN4:</a>
<a name="ln4866">  case NFA_ZOPEN5:</a>
<a name="ln4867">  case NFA_ZOPEN6:</a>
<a name="ln4868">  case NFA_ZOPEN7:</a>
<a name="ln4869">  case NFA_ZOPEN8:</a>
<a name="ln4870">  case NFA_ZOPEN9:</a>
<a name="ln4871">  case NFA_ZCLOSE:</a>
<a name="ln4872">  case NFA_ZCLOSE1:</a>
<a name="ln4873">  case NFA_ZCLOSE2:</a>
<a name="ln4874">  case NFA_ZCLOSE3:</a>
<a name="ln4875">  case NFA_ZCLOSE4:</a>
<a name="ln4876">  case NFA_ZCLOSE5:</a>
<a name="ln4877">  case NFA_ZCLOSE6:</a>
<a name="ln4878">  case NFA_ZCLOSE7:</a>
<a name="ln4879">  case NFA_ZCLOSE8:</a>
<a name="ln4880">  case NFA_ZCLOSE9:</a>
<a name="ln4881">  case NFA_NOPEN:</a>
<a name="ln4882">  case NFA_MCLOSE1:</a>
<a name="ln4883">  case NFA_MCLOSE2:</a>
<a name="ln4884">  case NFA_MCLOSE3:</a>
<a name="ln4885">  case NFA_MCLOSE4:</a>
<a name="ln4886">  case NFA_MCLOSE5:</a>
<a name="ln4887">  case NFA_MCLOSE6:</a>
<a name="ln4888">  case NFA_MCLOSE7:</a>
<a name="ln4889">  case NFA_MCLOSE8:</a>
<a name="ln4890">  case NFA_MCLOSE9:</a>
<a name="ln4891">  case NFA_NCLOSE:</a>
<a name="ln4892">    return failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4893"> </a>
<a name="ln4894">  case NFA_BACKREF1:</a>
<a name="ln4895">  case NFA_BACKREF2:</a>
<a name="ln4896">  case NFA_BACKREF3:</a>
<a name="ln4897">  case NFA_BACKREF4:</a>
<a name="ln4898">  case NFA_BACKREF5:</a>
<a name="ln4899">  case NFA_BACKREF6:</a>
<a name="ln4900">  case NFA_BACKREF7:</a>
<a name="ln4901">  case NFA_BACKREF8:</a>
<a name="ln4902">  case NFA_BACKREF9:</a>
<a name="ln4903">  case NFA_ZREF1:</a>
<a name="ln4904">  case NFA_ZREF2:</a>
<a name="ln4905">  case NFA_ZREF3:</a>
<a name="ln4906">  case NFA_ZREF4:</a>
<a name="ln4907">  case NFA_ZREF5:</a>
<a name="ln4908">  case NFA_ZREF6:</a>
<a name="ln4909">  case NFA_ZREF7:</a>
<a name="ln4910">  case NFA_ZREF8:</a>
<a name="ln4911">  case NFA_ZREF9:</a>
<a name="ln4912">    /* backreferences don't match in many places */</a>
<a name="ln4913">    return 94;</a>
<a name="ln4914"> </a>
<a name="ln4915">  case NFA_LNUM_GT:</a>
<a name="ln4916">  case NFA_LNUM_LT:</a>
<a name="ln4917">  case NFA_COL_GT:</a>
<a name="ln4918">  case NFA_COL_LT:</a>
<a name="ln4919">  case NFA_VCOL_GT:</a>
<a name="ln4920">  case NFA_VCOL_LT:</a>
<a name="ln4921">  case NFA_MARK_GT:</a>
<a name="ln4922">  case NFA_MARK_LT:</a>
<a name="ln4923">  case NFA_VISUAL:</a>
<a name="ln4924">    /* before/after positions don't match very often */</a>
<a name="ln4925">    return 85;</a>
<a name="ln4926"> </a>
<a name="ln4927">  case NFA_LNUM:</a>
<a name="ln4928">    return 90;</a>
<a name="ln4929"> </a>
<a name="ln4930">  case NFA_CURSOR:</a>
<a name="ln4931">  case NFA_COL:</a>
<a name="ln4932">  case NFA_VCOL:</a>
<a name="ln4933">  case NFA_MARK:</a>
<a name="ln4934">    /* specific positions rarely match */</a>
<a name="ln4935">    return 98;</a>
<a name="ln4936"> </a>
<a name="ln4937">  case NFA_COMPOSING:</a>
<a name="ln4938">    return 95;</a>
<a name="ln4939"> </a>
<a name="ln4940">  default:</a>
<a name="ln4941">    if (c &gt; 0)</a>
<a name="ln4942">      /* character match fails often */</a>
<a name="ln4943">      return 95;</a>
<a name="ln4944">  }</a>
<a name="ln4945"> </a>
<a name="ln4946">  /* something else, includes character classes */</a>
<a name="ln4947">  return 50;</a>
<a name="ln4948">}</a>
<a name="ln4949"> </a>
<a name="ln4950">/*</a>
<a name="ln4951"> * Skip until the char &quot;c&quot; we know a match must start with.</a>
<a name="ln4952"> */</a>
<a name="ln4953">static int skip_to_start(int c, colnr_T *colp)</a>
<a name="ln4954">{</a>
<a name="ln4955">  const char_u *const s = cstrchr(rex.line + *colp, c);</a>
<a name="ln4956">  if (s == NULL) {</a>
<a name="ln4957">    return FAIL;</a>
<a name="ln4958">  }</a>
<a name="ln4959">  *colp = (int)(s - rex.line);</a>
<a name="ln4960">  return OK;</a>
<a name="ln4961">}</a>
<a name="ln4962"> </a>
<a name="ln4963">/*</a>
<a name="ln4964"> * Check for a match with match_text.</a>
<a name="ln4965"> * Called after skip_to_start() has found regstart.</a>
<a name="ln4966"> * Returns zero for no match, 1 for a match.</a>
<a name="ln4967"> */</a>
<a name="ln4968">static long find_match_text(colnr_T startcol, int regstart, char_u *match_text)</a>
<a name="ln4969">{</a>
<a name="ln4970">#define PTR2LEN(x) utf_ptr2len(x)</a>
<a name="ln4971"> </a>
<a name="ln4972">  colnr_T col = startcol;</a>
<a name="ln4973">  int regstart_len = PTR2LEN(rex.line + startcol);</a>
<a name="ln4974"> </a>
<a name="ln4975">  for (;;) {</a>
<a name="ln4976">    bool match = true;</a>
<a name="ln4977">    char_u *s1 = match_text;</a>
<a name="ln4978">    char_u *s2 = rex.line + col + regstart_len;  // skip regstart</a>
<a name="ln4979">    while (*s1) {</a>
<a name="ln4980">      int c1_len = PTR2LEN(s1);</a>
<a name="ln4981">      int c1 = PTR2CHAR(s1);</a>
<a name="ln4982">      int c2_len = PTR2LEN(s2);</a>
<a name="ln4983">      int c2 = PTR2CHAR(s2);</a>
<a name="ln4984"> </a>
<a name="ln4985">      if ((c1 != c2 &amp;&amp; (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))</a>
<a name="ln4986">          || c1_len != c2_len) {</a>
<a name="ln4987">        match = false;</a>
<a name="ln4988">        break;</a>
<a name="ln4989">      }</a>
<a name="ln4990">      s1 += c1_len;</a>
<a name="ln4991">      s2 += c2_len;</a>
<a name="ln4992">    }</a>
<a name="ln4993">    if (match</a>
<a name="ln4994">        // check that no composing char follows</a>
<a name="ln4995">        &amp;&amp; !utf_iscomposing(PTR2CHAR(s2))) {</a>
<a name="ln4996">      cleanup_subexpr();</a>
<a name="ln4997">      if (REG_MULTI) {</a>
<a name="ln4998">        rex.reg_startpos[0].lnum = rex.lnum;</a>
<a name="ln4999">        rex.reg_startpos[0].col = col;</a>
<a name="ln5000">        rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln5001">        rex.reg_endpos[0].col = s2 - rex.line;</a>
<a name="ln5002">      } else {</a>
<a name="ln5003">        rex.reg_startp[0] = rex.line + col;</a>
<a name="ln5004">        rex.reg_endp[0] = s2;</a>
<a name="ln5005">      }</a>
<a name="ln5006">      return 1L;</a>
<a name="ln5007">    }</a>
<a name="ln5008"> </a>
<a name="ln5009">    // Try finding regstart after the current match.</a>
<a name="ln5010">    col += regstart_len;  // skip regstart</a>
<a name="ln5011">    if (skip_to_start(regstart, &amp;col) == FAIL) {</a>
<a name="ln5012">      break;</a>
<a name="ln5013">    }</a>
<a name="ln5014">  }</a>
<a name="ln5015">  return 0L;</a>
<a name="ln5016"> </a>
<a name="ln5017">#undef PTR2LEN</a>
<a name="ln5018">}</a>
<a name="ln5019"> </a>
<a name="ln5020">static int nfa_did_time_out(void)</a>
<a name="ln5021">{</a>
<a name="ln5022">  if (nfa_time_limit != NULL &amp;&amp; profile_passed_limit(*nfa_time_limit)) {</a>
<a name="ln5023">    if (nfa_timed_out != NULL) {</a>
<a name="ln5024">      *nfa_timed_out = true;</a>
<a name="ln5025">    }</a>
<a name="ln5026">    return true;</a>
<a name="ln5027">  }</a>
<a name="ln5028">  return false;</a>
<a name="ln5029">}</a>
<a name="ln5030"> </a>
<a name="ln5031">/// Main matching routine.</a>
<a name="ln5032">///</a>
<a name="ln5033">/// Run NFA to determine whether it matches rex.input.</a>
<a name="ln5034">///</a>
<a name="ln5035">/// When &quot;nfa_endp&quot; is not NULL it is a required end-of-match position.</a>
<a name="ln5036">///</a>
<a name="ln5037">/// Return true if there is a match, false if there is no match,</a>
<a name="ln5038">/// NFA_TOO_EXPENSIVE if we end up with too many states.</a>
<a name="ln5039">/// When there is a match &quot;submatch&quot; contains the positions.</a>
<a name="ln5040">///</a>
<a name="ln5041">/// Note: Caller must ensure that: start != NULL.</a>
<a name="ln5042">static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start,</a>
<a name="ln5043">                        regsubs_T *submatch, regsubs_T *m)</a>
<a name="ln5044">  FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln5045">{</a>
<a name="ln5046">  int result = false;</a>
<a name="ln5047">  int flag = 0;</a>
<a name="ln5048">  bool go_to_nextline = false;</a>
<a name="ln5049">  nfa_thread_T *t;</a>
<a name="ln5050">  nfa_list_T list[2];</a>
<a name="ln5051">  int listidx;</a>
<a name="ln5052">  nfa_list_T  *thislist;</a>
<a name="ln5053">  nfa_list_T  *nextlist;</a>
<a name="ln5054">  int         *listids = NULL;</a>
<a name="ln5055">  int listids_len = 0;</a>
<a name="ln5056">  nfa_state_T *add_state;</a>
<a name="ln5057">  bool add_here;</a>
<a name="ln5058">  int add_count;</a>
<a name="ln5059">  int add_off = 0;</a>
<a name="ln5060">  int toplevel = start-&gt;c == NFA_MOPEN;</a>
<a name="ln5061">  regsubs_T *r;</a>
<a name="ln5062">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5063">  FILE        *debug = fopen(NFA_REGEXP_DEBUG_LOG, &quot;a&quot;);</a>
<a name="ln5064"> </a>
<a name="ln5065">  if (debug == NULL) {</a>
<a name="ln5066">    EMSG2(&quot;(NFA) COULD NOT OPEN %s!&quot;, NFA_REGEXP_DEBUG_LOG);</a>
<a name="ln5067">    return false;</a>
<a name="ln5068">  }</a>
<a name="ln5069">#endif</a>
<a name="ln5070">  // Some patterns may take a long time to match, especially when using</a>
<a name="ln5071">  // recursive_regmatch(). Allow interrupting them with CTRL-C.</a>
<a name="ln5072">  fast_breakcheck();</a>
<a name="ln5073">  if (got_int) {</a>
<a name="ln5074">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5075">    fclose(debug);</a>
<a name="ln5076">#endif</a>
<a name="ln5077">    return false;</a>
<a name="ln5078">  }</a>
<a name="ln5079">  if (nfa_did_time_out()) {</a>
<a name="ln5080">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5081">    fclose(debug);</a>
<a name="ln5082">#endif</a>
<a name="ln5083">    return false;</a>
<a name="ln5084">  }</a>
<a name="ln5085"> </a>
<a name="ln5086">  nfa_match = false;</a>
<a name="ln5087"> </a>
<a name="ln5088">  // Allocate memory for the lists of nodes.</a>
<a name="ln5089">  size_t size = (prog-&gt;nstate + 1) * sizeof(nfa_thread_T);</a>
<a name="ln5090">  list[0].t = xmalloc(size);</a>
<a name="ln5091">  list[0].len = prog-&gt;nstate + 1;</a>
<a name="ln5092">  list[1].t = xmalloc(size);</a>
<a name="ln5093">  list[1].len = prog-&gt;nstate + 1;</a>
<a name="ln5094"> </a>
<a name="ln5095">#ifdef REGEXP_DEBUG</a>
<a name="ln5096">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln5097">  if (log_fd != NULL) {</a>
<a name="ln5098">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5099">    nfa_set_code(start-&gt;c);</a>
<a name="ln5100">    fprintf(log_fd, &quot; RUNNING nfa_regmatch() starting with state %d, code %s\n&quot;,</a>
<a name="ln5101">        abs(start-&gt;id), code);</a>
<a name="ln5102">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5103">  } else {</a>
<a name="ln5104">    EMSG(_(e_log_open_failed));</a>
<a name="ln5105">    log_fd = stderr;</a>
<a name="ln5106">  }</a>
<a name="ln5107">#endif</a>
<a name="ln5108"> </a>
<a name="ln5109">  thislist = &amp;list[0];</a>
<a name="ln5110">  thislist-&gt;n = 0;</a>
<a name="ln5111">  thislist-&gt;has_pim = false;</a>
<a name="ln5112">  nextlist = &amp;list[1];</a>
<a name="ln5113">  nextlist-&gt;n = 0;</a>
<a name="ln5114">  nextlist-&gt;has_pim = false;</a>
<a name="ln5115">#ifdef REGEXP_DEBUG</a>
<a name="ln5116">  fprintf(log_fd, &quot;(---) STARTSTATE first\n&quot;);</a>
<a name="ln5117">#endif</a>
<a name="ln5118">  thislist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5119"> </a>
<a name="ln5120">  // Inline optimized code for addstate(thislist, start, m, 0) if we know</a>
<a name="ln5121">  // it's the first MOPEN.</a>
<a name="ln5122">  if (toplevel) {</a>
<a name="ln5123">    if (REG_MULTI) {</a>
<a name="ln5124">      m-&gt;norm.list.multi[0].start_lnum = rex.lnum;</a>
<a name="ln5125">      m-&gt;norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln5126">    } else {</a>
<a name="ln5127">      m-&gt;norm.list.line[0].start = rex.input;</a>
<a name="ln5128">    }</a>
<a name="ln5129">    m-&gt;norm.in_use = 1;</a>
<a name="ln5130">    r = addstate(thislist, start-&gt;out, m, NULL, 0);</a>
<a name="ln5131">  } else {</a>
<a name="ln5132">    r = addstate(thislist, start, m, NULL, 0);</a>
<a name="ln5133">  }</a>
<a name="ln5134">  if (r == NULL) {</a>
<a name="ln5135">    nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5136">    goto theend;</a>
<a name="ln5137">  }</a>
<a name="ln5138"> </a>
<a name="ln5139">#define ADD_STATE_IF_MATCH(state) \</a>
<a name="ln5140">  if (result) { \</a>
<a name="ln5141">    add_state = state-&gt;out; \</a>
<a name="ln5142">    add_off = clen; \</a>
<a name="ln5143">  }</a>
<a name="ln5144"> </a>
<a name="ln5145">  /*</a>
<a name="ln5146">   * Run for each character.</a>
<a name="ln5147">   */</a>
<a name="ln5148">  for (;; ) {</a>
<a name="ln5149">    int curc = utf_ptr2char(rex.input);</a>
<a name="ln5150">    int clen = utfc_ptr2len(rex.input);</a>
<a name="ln5151">    if (curc == NUL) {</a>
<a name="ln5152">      clen = 0;</a>
<a name="ln5153">      go_to_nextline = false;</a>
<a name="ln5154">    }</a>
<a name="ln5155"> </a>
<a name="ln5156">    /* swap lists */</a>
<a name="ln5157">    thislist = &amp;list[flag];</a>
<a name="ln5158">    nextlist = &amp;list[flag ^= 1];</a>
<a name="ln5159">    nextlist-&gt;n = 0;                // clear nextlist</a>
<a name="ln5160">    nextlist-&gt;has_pim = false;</a>
<a name="ln5161">    rex.nfa_listid++;</a>
<a name="ln5162">    if (prog-&gt;re_engine == AUTOMATIC_ENGINE</a>
<a name="ln5163">        &amp;&amp; (rex.nfa_listid &gt;= NFA_MAX_STATES)) {</a>
<a name="ln5164">      // Too many states, retry with old engine.</a>
<a name="ln5165">      nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5166">      goto theend;</a>
<a name="ln5167">    }</a>
<a name="ln5168"> </a>
<a name="ln5169">    thislist-&gt;id = rex.nfa_listid;</a>
<a name="ln5170">    nextlist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5171"> </a>
<a name="ln5172">#ifdef REGEXP_DEBUG</a>
<a name="ln5173">    fprintf(log_fd, &quot;------------------------------------------\n&quot;);</a>
<a name="ln5174">    fprintf(log_fd, &quot;&gt;&gt;&gt; Reginput is \&quot;%s\&quot;\n&quot;, rex.input);</a>
<a name="ln5175">    fprintf(log_fd,</a>
<a name="ln5176">            &quot;&gt;&gt;&gt; Advanced one character... Current char is %c (code %d) \n&quot;,</a>
<a name="ln5177">            curc,</a>
<a name="ln5178">            (int)curc);</a>
<a name="ln5179">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist has %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln5180">    {</a>
<a name="ln5181">      int i;</a>
<a name="ln5182"> </a>
<a name="ln5183">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln5184">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln5185">    }</a>
<a name="ln5186">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln5187">#endif</a>
<a name="ln5188"> </a>
<a name="ln5189">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5190">    fprintf(debug, &quot;\n-------------------\n&quot;);</a>
<a name="ln5191">#endif</a>
<a name="ln5192">    /*</a>
<a name="ln5193">     * If the state lists are empty we can stop.</a>
<a name="ln5194">     */</a>
<a name="ln5195">    if (thislist-&gt;n == 0)</a>
<a name="ln5196">      break;</a>
<a name="ln5197"> </a>
<a name="ln5198">    // compute nextlist</a>
<a name="ln5199">    for (listidx = 0; listidx &lt; thislist-&gt;n; listidx++) {</a>
<a name="ln5200">      // If the list gets very long there probably is something wrong.</a>
<a name="ln5201">      // At least allow interrupting with CTRL-C.</a>
<a name="ln5202">      fast_breakcheck();</a>
<a name="ln5203">      if (got_int) {</a>
<a name="ln5204">        break;</a>
<a name="ln5205">      }</a>
<a name="ln5206">      if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln5207">        nfa_time_count = 0;</a>
<a name="ln5208">        if (nfa_did_time_out()) {</a>
<a name="ln5209">          break;</a>
<a name="ln5210">        }</a>
<a name="ln5211">      }</a>
<a name="ln5212">      t = &amp;thislist-&gt;t[listidx];</a>
<a name="ln5213"> </a>
<a name="ln5214">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5215">      nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5216">      fprintf(debug, &quot;%s, &quot;, code);</a>
<a name="ln5217">#endif</a>
<a name="ln5218">#ifdef REGEXP_DEBUG</a>
<a name="ln5219">      {</a>
<a name="ln5220">        int col;</a>
<a name="ln5221"> </a>
<a name="ln5222">        if (t-&gt;subs.norm.in_use &lt;= 0) {</a>
<a name="ln5223">          col = -1;</a>
<a name="ln5224">        } else if (REG_MULTI) {</a>
<a name="ln5225">          col = t-&gt;subs.norm.list.multi[0].start_col;</a>
<a name="ln5226">        } else {</a>
<a name="ln5227">          col = (int)(t-&gt;subs.norm.list.line[0].start - rex.line);</a>
<a name="ln5228">        }</a>
<a name="ln5229">        nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5230">        fprintf(log_fd, &quot;(%d) char %d %s (start col %d)%s... \n&quot;,</a>
<a name="ln5231">                abs(t-&gt;state-&gt;id), (int)t-&gt;state-&gt;c, code, col,</a>
<a name="ln5232">                pim_info(&amp;t-&gt;pim));</a>
<a name="ln5233">      }</a>
<a name="ln5234">#endif</a>
<a name="ln5235"> </a>
<a name="ln5236">      /*</a>
<a name="ln5237">       * Handle the possible codes of the current state.</a>
<a name="ln5238">       * The most important is NFA_MATCH.</a>
<a name="ln5239">       */</a>
<a name="ln5240">      add_state = NULL;</a>
<a name="ln5241">      add_here = false;</a>
<a name="ln5242">      add_count = 0;</a>
<a name="ln5243">      switch (t-&gt;state-&gt;c) {</a>
<a name="ln5244">      case NFA_MATCH:</a>
<a name="ln5245">      {</a>
<a name="ln5246">        // If the match is not at the start of the line, ends before a</a>
<a name="ln5247">        // composing characters and rex.reg_icombine is not set, that</a>
<a name="ln5248">        // is not really a match.</a>
<a name="ln5249">        if (!rex.reg_icombine</a>
<a name="ln5250">            &amp;&amp; rex.input != rex.line</a>
<a name="ln5251">            &amp;&amp; utf_iscomposing(curc)) {</a>
<a name="ln5252">          break;</a>
<a name="ln5253">        }</a>
<a name="ln5254">        nfa_match = true;</a>
<a name="ln5255">        copy_sub(&amp;submatch-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5256">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5257">          copy_sub(&amp;submatch-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5258">        }</a>
<a name="ln5259">#ifdef REGEXP_DEBUG</a>
<a name="ln5260">        log_subsexpr(&amp;t-&gt;subs);</a>
<a name="ln5261">#endif</a>
<a name="ln5262">        // Found the left-most longest match, do not look at any other</a>
<a name="ln5263">        // states at this position.  When the list of states is going</a>
<a name="ln5264">        // to be empty quit without advancing, so that &quot;rex.input&quot; is</a>
<a name="ln5265">        // correct.</a>
<a name="ln5266">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5267">          clen = 0;</a>
<a name="ln5268">        }</a>
<a name="ln5269">        goto nextchar;</a>
<a name="ln5270">      }</a>
<a name="ln5271"> </a>
<a name="ln5272">      case NFA_END_INVISIBLE:</a>
<a name="ln5273">      case NFA_END_INVISIBLE_NEG:</a>
<a name="ln5274">      case NFA_END_PATTERN:</a>
<a name="ln5275">        // This is only encountered after a NFA_START_INVISIBLE or</a>
<a name="ln5276">        // NFA_START_INVISIBLE_BEFORE node.</a>
<a name="ln5277">        // They surround a zero-width group, used with &quot;\@=&quot;, &quot;\&amp;&quot;,</a>
<a name="ln5278">        // &quot;\@!&quot;, &quot;\@&lt;=&quot; and &quot;\@&lt;!&quot;.</a>
<a name="ln5279">        // If we got here, it means that the current &quot;invisible&quot; group</a>
<a name="ln5280">        // finished successfully, so return control to the parent</a>
<a name="ln5281">        // nfa_regmatch().  For a look-behind match only when it ends</a>
<a name="ln5282">        // in the position in &quot;nfa_endp&quot;.</a>
<a name="ln5283">        // Submatches are stored in *m, and used in the parent call.</a>
<a name="ln5284">#ifdef REGEXP_DEBUG</a>
<a name="ln5285">        if (nfa_endp != NULL) {</a>
<a name="ln5286">          if (REG_MULTI) {</a>
<a name="ln5287">            fprintf(log_fd,</a>
<a name="ln5288">                    &quot;Current lnum: %d, endp lnum: %d;&quot;</a>
<a name="ln5289">                    &quot; current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5290">                    (int)rex.lnum,</a>
<a name="ln5291">                    (int)nfa_endp-&gt;se_u.pos.lnum,</a>
<a name="ln5292">                    (int)(rex.input - rex.line),</a>
<a name="ln5293">                    nfa_endp-&gt;se_u.pos.col);</a>
<a name="ln5294">          } else {</a>
<a name="ln5295">            fprintf(log_fd, &quot;Current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5296">                    (int)(rex.input - rex.line),</a>
<a name="ln5297">                    (int)(nfa_endp-&gt;se_u.ptr - rex.input));</a>
<a name="ln5298">          }</a>
<a name="ln5299">        }</a>
<a name="ln5300">#endif</a>
<a name="ln5301">        // If &quot;nfa_endp&quot; is set it's only a match if it ends at</a>
<a name="ln5302">        // &quot;nfa_endp&quot;</a>
<a name="ln5303">        if (nfa_endp != NULL</a>
<a name="ln5304">            &amp;&amp; (REG_MULTI</a>
<a name="ln5305">                ? (rex.lnum != nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln5306">                   || (int)(rex.input - rex.line) != nfa_endp-&gt;se_u.pos.col)</a>
<a name="ln5307">                : rex.input != nfa_endp-&gt;se_u.ptr)) {</a>
<a name="ln5308">          break;</a>
<a name="ln5309">        }</a>
<a name="ln5310">        // do not set submatches for \@!</a>
<a name="ln5311">        if (t-&gt;state-&gt;c != NFA_END_INVISIBLE_NEG) {</a>
<a name="ln5312">          copy_sub(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5313">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5314">            copy_sub(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5315">          }</a>
<a name="ln5316">        }</a>
<a name="ln5317">#ifdef REGEXP_DEBUG</a>
<a name="ln5318">        fprintf(log_fd, &quot;Match found:\n&quot;);</a>
<a name="ln5319">        log_subsexpr(m);</a>
<a name="ln5320">#endif</a>
<a name="ln5321">        nfa_match = true;</a>
<a name="ln5322">        // See comment above at &quot;goto nextchar&quot;.</a>
<a name="ln5323">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5324">          clen = 0;</a>
<a name="ln5325">        }</a>
<a name="ln5326">        goto nextchar;</a>
<a name="ln5327"> </a>
<a name="ln5328">      case NFA_START_INVISIBLE:</a>
<a name="ln5329">      case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln5330">      case NFA_START_INVISIBLE_NEG:</a>
<a name="ln5331">      case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln5332">      case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln5333">      case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln5334">      case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln5335">      case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln5336">      {</a>
<a name="ln5337">#ifdef REGEXP_DEBUG</a>
<a name="ln5338">        fprintf(log_fd, &quot;Failure chance invisible: %d, what follows: %d\n&quot;,</a>
<a name="ln5339">            failure_chance(t-&gt;state-&gt;out, 0),</a>
<a name="ln5340">            failure_chance(t-&gt;state-&gt;out1-&gt;out, 0));</a>
<a name="ln5341">#endif</a>
<a name="ln5342">        // Do it directly if there already is a PIM or when</a>
<a name="ln5343">        // nfa_postprocess() detected it will work better.</a>
<a name="ln5344">        if (t-&gt;pim.result != NFA_PIM_UNUSED</a>
<a name="ln5345">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_FIRST</a>
<a name="ln5346">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5347">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln5348">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln5349">          int in_use = m-&gt;norm.in_use;</a>
<a name="ln5350"> </a>
<a name="ln5351">          // Copy submatch info for the recursive call, opposite</a>
<a name="ln5352">          // of what happens on success below.</a>
<a name="ln5353">          copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5354">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5355">            copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5356">          }</a>
<a name="ln5357">          // First try matching the invisible match, then what</a>
<a name="ln5358">          // follows.</a>
<a name="ln5359">          result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5360">                                      &amp;listids, &amp;listids_len);</a>
<a name="ln5361">          if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5362">            nfa_match = result;</a>
<a name="ln5363">            goto theend;</a>
<a name="ln5364">          }</a>
<a name="ln5365"> </a>
<a name="ln5366">          // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln5367">          // false</a>
<a name="ln5368">          if (result != (t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln5369">                         || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5370">                         || t-&gt;state-&gt;c</a>
<a name="ln5371">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln5372">                         || t-&gt;state-&gt;c</a>
<a name="ln5373">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln5374">            // Copy submatch info from the recursive call</a>
<a name="ln5375">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5376">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5377">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5378">            }</a>
<a name="ln5379">            // If the pattern has \ze and it matched in the</a>
<a name="ln5380">            // sub pattern, use it.</a>
<a name="ln5381">            copy_ze_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5382"> </a>
<a name="ln5383">            // t-&gt;state-&gt;out1 is the corresponding</a>
<a name="ln5384">            // END_INVISIBLE node; Add its out to the current</a>
<a name="ln5385">            // list (zero-width match).</a>
<a name="ln5386">            add_here = true;</a>
<a name="ln5387">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5388">          }</a>
<a name="ln5389">          m-&gt;norm.in_use = in_use;</a>
<a name="ln5390">        } else {</a>
<a name="ln5391">          nfa_pim_T pim;</a>
<a name="ln5392"> </a>
<a name="ln5393">          // First try matching what follows.  Only if a match</a>
<a name="ln5394">          // is found verify the invisible match matches.  Add a</a>
<a name="ln5395">          // nfa_pim_T to the following states, it contains info</a>
<a name="ln5396">          // about the invisible match.</a>
<a name="ln5397">          pim.state = t-&gt;state;</a>
<a name="ln5398">          pim.result = NFA_PIM_TODO;</a>
<a name="ln5399">          pim.subs.norm.in_use = 0;</a>
<a name="ln5400">          pim.subs.synt.in_use = 0;</a>
<a name="ln5401">          if (REG_MULTI) {</a>
<a name="ln5402">            pim.end.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln5403">            pim.end.pos.lnum = rex.lnum;</a>
<a name="ln5404">          } else {</a>
<a name="ln5405">            pim.end.ptr = rex.input;</a>
<a name="ln5406">          }</a>
<a name="ln5407">          // t-&gt;state-&gt;out1 is the corresponding END_INVISIBLE</a>
<a name="ln5408">          // node; Add its out to the current list (zero-width</a>
<a name="ln5409">          // match).</a>
<a name="ln5410">          if (addstate_here(thislist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs,</a>
<a name="ln5411">                            &amp;pim, &amp;listidx) == NULL) {</a>
<a name="ln5412">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5413">            goto theend;</a>
<a name="ln5414">          }</a>
<a name="ln5415">        }</a>
<a name="ln5416">      }</a>
<a name="ln5417">      break;</a>
<a name="ln5418"> </a>
<a name="ln5419">      case NFA_START_PATTERN:</a>
<a name="ln5420">      {</a>
<a name="ln5421">        nfa_state_T *skip = NULL;</a>
<a name="ln5422">#ifdef REGEXP_DEBUG</a>
<a name="ln5423">        int skip_lid = 0;</a>
<a name="ln5424">#endif</a>
<a name="ln5425"> </a>
<a name="ln5426">        // There is no point in trying to match the pattern if the</a>
<a name="ln5427">        // output state is not going to be added to the list.</a>
<a name="ln5428">        if (state_in_list(nextlist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5429">          skip = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5430">#ifdef REGEXP_DEBUG</a>
<a name="ln5431">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5432">#endif</a>
<a name="ln5433">        } else if (state_in_list(nextlist,</a>
<a name="ln5434">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5435">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5436">#ifdef REGEXP_DEBUG</a>
<a name="ln5437">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5438">#endif</a>
<a name="ln5439">        } else if (state_in_list(thislist,</a>
<a name="ln5440">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5441">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5442">#ifdef REGEXP_DEBUG</a>
<a name="ln5443">          skip_lid = thislist-&gt;id;</a>
<a name="ln5444">#endif</a>
<a name="ln5445">        }</a>
<a name="ln5446">        if (skip != NULL) {</a>
<a name="ln5447">#ifdef REGEXP_DEBUG</a>
<a name="ln5448">          nfa_set_code(skip-&gt;c);</a>
<a name="ln5449">          fprintf(</a>
<a name="ln5450">              log_fd,</a>
<a name="ln5451">              &quot;&gt; Not trying to match pattern, output state %d is already in list %d. char %d: %s\n&quot;,</a>
<a name="ln5452">              abs(skip-&gt;id), skip_lid, skip-&gt;c, code);</a>
<a name="ln5453">#endif</a>
<a name="ln5454">          break;</a>
<a name="ln5455">        }</a>
<a name="ln5456">        // Copy submatch info to the recursive call, opposite of what</a>
<a name="ln5457">        // happens afterwards.</a>
<a name="ln5458">        copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5459">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5460">          copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5461">        }</a>
<a name="ln5462"> </a>
<a name="ln5463">        // First try matching the pattern.</a>
<a name="ln5464">        result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5465">                                    &amp;listids, &amp;listids_len);</a>
<a name="ln5466">        if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5467">          nfa_match = result;</a>
<a name="ln5468">          goto theend;</a>
<a name="ln5469">        }</a>
<a name="ln5470">        if (result) {</a>
<a name="ln5471">          int bytelen;</a>
<a name="ln5472"> </a>
<a name="ln5473">#ifdef REGEXP_DEBUG</a>
<a name="ln5474">          fprintf(log_fd, &quot;NFA_START_PATTERN matches:\n&quot;);</a>
<a name="ln5475">          log_subsexpr(m);</a>
<a name="ln5476">#endif</a>
<a name="ln5477">          // Copy submatch info from the recursive call</a>
<a name="ln5478">          copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5479">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5480">            copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5481">          }</a>
<a name="ln5482">          // Now we need to skip over the matched text and then</a>
<a name="ln5483">          // continue with what follows.</a>
<a name="ln5484">          if (REG_MULTI) {</a>
<a name="ln5485">            // TODO(RE): multi-line match</a>
<a name="ln5486">            bytelen = m-&gt;norm.list.multi[0].end_col</a>
<a name="ln5487">                      - (int)(rex.input - rex.line);</a>
<a name="ln5488">          } else {</a>
<a name="ln5489">            bytelen = (int)(m-&gt;norm.list.line[0].end - rex.input);</a>
<a name="ln5490">          }</a>
<a name="ln5491"> </a>
<a name="ln5492">#ifdef REGEXP_DEBUG</a>
<a name="ln5493">          fprintf(log_fd, &quot;NFA_START_PATTERN length: %d\n&quot;, bytelen);</a>
<a name="ln5494">#endif</a>
<a name="ln5495">          if (bytelen == 0) {</a>
<a name="ln5496">            // empty match, output of corresponding</a>
<a name="ln5497">            // NFA_END_PATTERN/NFA_SKIP to be used at current</a>
<a name="ln5498">            // position</a>
<a name="ln5499">            add_here = true;</a>
<a name="ln5500">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5501">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5502">            // match current character, output of corresponding</a>
<a name="ln5503">            // NFA_END_PATTERN to be used at next position.</a>
<a name="ln5504">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5505">            add_off = clen;</a>
<a name="ln5506">          } else {</a>
<a name="ln5507">            // skip over the matched characters, set character</a>
<a name="ln5508">            // count in NFA_SKIP</a>
<a name="ln5509">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5510">            add_off = bytelen;</a>
<a name="ln5511">            add_count = bytelen - clen;</a>
<a name="ln5512">          }</a>
<a name="ln5513">        }</a>
<a name="ln5514">        break;</a>
<a name="ln5515">      }</a>
<a name="ln5516"> </a>
<a name="ln5517">      case NFA_BOL:</a>
<a name="ln5518">        if (rex.input == rex.line) {</a>
<a name="ln5519">          add_here = true;</a>
<a name="ln5520">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5521">        }</a>
<a name="ln5522">        break;</a>
<a name="ln5523"> </a>
<a name="ln5524">      case NFA_EOL:</a>
<a name="ln5525">        if (curc == NUL) {</a>
<a name="ln5526">          add_here = true;</a>
<a name="ln5527">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5528">        }</a>
<a name="ln5529">        break;</a>
<a name="ln5530"> </a>
<a name="ln5531">      case NFA_BOW:</a>
<a name="ln5532">        result = true;</a>
<a name="ln5533"> </a>
<a name="ln5534">        if (curc == NUL) {</a>
<a name="ln5535">          result = false;</a>
<a name="ln5536">        } else {</a>
<a name="ln5537">          int this_class;</a>
<a name="ln5538"> </a>
<a name="ln5539">          // Get class of current and previous char (if it exists).</a>
<a name="ln5540">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5541">          if (this_class &lt;= 1) {</a>
<a name="ln5542">            result = false;</a>
<a name="ln5543">          } else if (reg_prev_class() == this_class) {</a>
<a name="ln5544">            result = false;</a>
<a name="ln5545">          }</a>
<a name="ln5546">        }</a>
<a name="ln5547">        if (result) {</a>
<a name="ln5548">          add_here = true;</a>
<a name="ln5549">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5550">        }</a>
<a name="ln5551">        break;</a>
<a name="ln5552"> </a>
<a name="ln5553">      case NFA_EOW:</a>
<a name="ln5554">        result = true;</a>
<a name="ln5555">        if (rex.input == rex.line) {</a>
<a name="ln5556">          result = false;</a>
<a name="ln5557">        } else {</a>
<a name="ln5558">          int this_class, prev_class;</a>
<a name="ln5559"> </a>
<a name="ln5560">          // Get class of current and previous char (if it exists).</a>
<a name="ln5561">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5562">          prev_class = reg_prev_class();</a>
<a name="ln5563">          if (this_class == prev_class</a>
<a name="ln5564">              || prev_class == 0 || prev_class == 1) {</a>
<a name="ln5565">            result = false;</a>
<a name="ln5566">          }</a>
<a name="ln5567">        }</a>
<a name="ln5568">        if (result) {</a>
<a name="ln5569">          add_here = true;</a>
<a name="ln5570">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5571">        }</a>
<a name="ln5572">        break;</a>
<a name="ln5573"> </a>
<a name="ln5574">      case NFA_BOF:</a>
<a name="ln5575">        if (rex.lnum == 0 &amp;&amp; rex.input == rex.line</a>
<a name="ln5576">            &amp;&amp; (!REG_MULTI || rex.reg_firstlnum == 1)) {</a>
<a name="ln5577">          add_here = true;</a>
<a name="ln5578">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5579">        }</a>
<a name="ln5580">        break;</a>
<a name="ln5581"> </a>
<a name="ln5582">      case NFA_EOF:</a>
<a name="ln5583">        if (rex.lnum == rex.reg_maxline &amp;&amp; curc == NUL) {</a>
<a name="ln5584">          add_here = true;</a>
<a name="ln5585">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5586">        }</a>
<a name="ln5587">        break;</a>
<a name="ln5588"> </a>
<a name="ln5589">      case NFA_COMPOSING:</a>
<a name="ln5590">      {</a>
<a name="ln5591">        int mc = curc;</a>
<a name="ln5592">        int len = 0;</a>
<a name="ln5593">        nfa_state_T *end;</a>
<a name="ln5594">        nfa_state_T *sta;</a>
<a name="ln5595">        int cchars[MAX_MCO];</a>
<a name="ln5596">        int ccount = 0;</a>
<a name="ln5597">        int j;</a>
<a name="ln5598"> </a>
<a name="ln5599">        sta = t-&gt;state-&gt;out;</a>
<a name="ln5600">        len = 0;</a>
<a name="ln5601">        if (utf_iscomposing(sta-&gt;c)) {</a>
<a name="ln5602">          // Only match composing character(s), ignore base</a>
<a name="ln5603">          // character.  Used for &quot;.{composing}&quot; and &quot;{composing}&quot;</a>
<a name="ln5604">          // (no preceding character).</a>
<a name="ln5605">          len += mb_char2len(mc);</a>
<a name="ln5606">        }</a>
<a name="ln5607">        if (rex.reg_icombine &amp;&amp; len == 0) {</a>
<a name="ln5608">          // If \Z was present, then ignore composing characters.</a>
<a name="ln5609">          // When ignoring the base character this always matches.</a>
<a name="ln5610">          if (sta-&gt;c != curc) {</a>
<a name="ln5611">            result = FAIL;</a>
<a name="ln5612">          } else {</a>
<a name="ln5613">            result = OK;</a>
<a name="ln5614">          }</a>
<a name="ln5615">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5616">            sta = sta-&gt;out;</a>
<a name="ln5617">          }</a>
<a name="ln5618">        } else if (len &gt; 0 || mc == sta-&gt;c) {</a>
<a name="ln5619">          // Check base character matches first, unless ignored.</a>
<a name="ln5620">          if (len == 0) {</a>
<a name="ln5621">            len += mb_char2len(mc);</a>
<a name="ln5622">            sta = sta-&gt;out;</a>
<a name="ln5623">          }</a>
<a name="ln5624"> </a>
<a name="ln5625">          // We don't care about the order of composing characters.</a>
<a name="ln5626">          // Get them into cchars[] first.</a>
<a name="ln5627">          while (len &lt; clen) {</a>
<a name="ln5628">            mc = utf_ptr2char(rex.input + len);</a>
<a name="ln5629">            cchars[ccount++] = mc;</a>
<a name="ln5630">            len += mb_char2len(mc);</a>
<a name="ln5631">            if (ccount == MAX_MCO)</a>
<a name="ln5632">              break;</a>
<a name="ln5633">          }</a>
<a name="ln5634"> </a>
<a name="ln5635">          // Check that each composing char in the pattern matches a</a>
<a name="ln5636">          // composing char in the text.  We do not check if all</a>
<a name="ln5637">          // composing chars are matched.</a>
<a name="ln5638">          result = OK;</a>
<a name="ln5639">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5640">            for (j = 0; j &lt; ccount; ++j)</a>
<a name="ln5641">              if (cchars[j] == sta-&gt;c)</a>
<a name="ln5642">                break;</a>
<a name="ln5643">            if (j == ccount) {</a>
<a name="ln5644">              result = FAIL;</a>
<a name="ln5645">              break;</a>
<a name="ln5646">            }</a>
<a name="ln5647">            sta = sta-&gt;out;</a>
<a name="ln5648">          }</a>
<a name="ln5649">        } else</a>
<a name="ln5650">          result = FAIL;</a>
<a name="ln5651"> </a>
<a name="ln5652">        end = t-&gt;state-&gt;out1;               // NFA_END_COMPOSING</a>
<a name="ln5653">        ADD_STATE_IF_MATCH(end);</a>
<a name="ln5654">        break;</a>
<a name="ln5655">      }</a>
<a name="ln5656"> </a>
<a name="ln5657">      case NFA_NEWL:</a>
<a name="ln5658">        if (curc == NUL &amp;&amp; !rex.reg_line_lbr &amp;&amp; REG_MULTI</a>
<a name="ln5659">            &amp;&amp; rex.lnum &lt;= rex.reg_maxline) {</a>
<a name="ln5660">          go_to_nextline = true;</a>
<a name="ln5661">          // Pass -1 for the offset, which means taking the position</a>
<a name="ln5662">          // at the start of the next line.</a>
<a name="ln5663">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5664">          add_off = -1;</a>
<a name="ln5665">        } else if (curc == '\n' &amp;&amp; rex.reg_line_lbr) {</a>
<a name="ln5666">          // match \n as if it is an ordinary character</a>
<a name="ln5667">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5668">          add_off = 1;</a>
<a name="ln5669">        }</a>
<a name="ln5670">        break;</a>
<a name="ln5671"> </a>
<a name="ln5672">      case NFA_START_COLL:</a>
<a name="ln5673">      case NFA_START_NEG_COLL:</a>
<a name="ln5674">      {</a>
<a name="ln5675">        // What follows is a list of characters, until NFA_END_COLL.</a>
<a name="ln5676">        // One of them must match or none of them must match.</a>
<a name="ln5677">        nfa_state_T     *state;</a>
<a name="ln5678">        int result_if_matched;</a>
<a name="ln5679">        int c1, c2;</a>
<a name="ln5680"> </a>
<a name="ln5681">        // Never match EOL. If it's part of the collection it is added</a>
<a name="ln5682">        // as a separate state with an OR.</a>
<a name="ln5683">        if (curc == NUL) {</a>
<a name="ln5684">          break;</a>
<a name="ln5685">        }</a>
<a name="ln5686"> </a>
<a name="ln5687">        state = t-&gt;state-&gt;out;</a>
<a name="ln5688">        result_if_matched = (t-&gt;state-&gt;c == NFA_START_COLL);</a>
<a name="ln5689">        for (;; ) {</a>
<a name="ln5690">          if (state-&gt;c == NFA_END_COLL) {</a>
<a name="ln5691">            result = !result_if_matched;</a>
<a name="ln5692">            break;</a>
<a name="ln5693">          }</a>
<a name="ln5694">          if (state-&gt;c == NFA_RANGE_MIN) {</a>
<a name="ln5695">            c1 = state-&gt;val;</a>
<a name="ln5696">            state = state-&gt;out;             // advance to NFA_RANGE_MAX</a>
<a name="ln5697">            c2 = state-&gt;val;</a>
<a name="ln5698">#ifdef REGEXP_DEBUG</a>
<a name="ln5699">            fprintf(log_fd, &quot;NFA_RANGE_MIN curc=%d c1=%d c2=%d\n&quot;,</a>
<a name="ln5700">                curc, c1, c2);</a>
<a name="ln5701">#endif</a>
<a name="ln5702">            if (curc &gt;= c1 &amp;&amp; curc &lt;= c2) {</a>
<a name="ln5703">              result = result_if_matched;</a>
<a name="ln5704">              break;</a>
<a name="ln5705">            }</a>
<a name="ln5706">            if (rex.reg_ic) {</a>
<a name="ln5707">              int curc_low = utf_fold(curc);</a>
<a name="ln5708">              int done = false;</a>
<a name="ln5709"> </a>
<a name="ln5710">              for (; c1 &lt;= c2; c1++) {</a>
<a name="ln5711">                if (utf_fold(c1) == curc_low) {</a>
<a name="ln5712">                  result = result_if_matched;</a>
<a name="ln5713">                  done = true;</a>
<a name="ln5714">                  break;</a>
<a name="ln5715">                }</a>
<a name="ln5716">              }</a>
<a name="ln5717">              if (done) {</a>
<a name="ln5718">                break;</a>
<a name="ln5719">              }</a>
<a name="ln5720">            }</a>
<a name="ln5721">          } else if (state-&gt;c &lt; 0 ? check_char_class(state-&gt;c, curc)</a>
<a name="ln5722">                     : (curc == state-&gt;c</a>
<a name="ln5723">                        || (rex.reg_ic</a>
<a name="ln5724">                            &amp;&amp; utf_fold(curc) == utf_fold(state-&gt;c)))) {</a>
<a name="ln5725">            result = result_if_matched;</a>
<a name="ln5726">            break;</a>
<a name="ln5727">          }</a>
<a name="ln5728">          state = state-&gt;out;</a>
<a name="ln5729">        }</a>
<a name="ln5730">        if (result) {</a>
<a name="ln5731">          // next state is in out of the NFA_END_COLL, out1 of</a>
<a name="ln5732">          // START points to the END state</a>
<a name="ln5733">          add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5734">          add_off = clen;</a>
<a name="ln5735">        }</a>
<a name="ln5736">        break;</a>
<a name="ln5737">      }</a>
<a name="ln5738"> </a>
<a name="ln5739">      case NFA_ANY:</a>
<a name="ln5740">        // Any char except '\0', (end of input) does not match.</a>
<a name="ln5741">        if (curc &gt; 0) {</a>
<a name="ln5742">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5743">          add_off = clen;</a>
<a name="ln5744">        }</a>
<a name="ln5745">        break;</a>
<a name="ln5746"> </a>
<a name="ln5747">      case NFA_ANY_COMPOSING:</a>
<a name="ln5748">        // On a composing character skip over it.  Otherwise do</a>
<a name="ln5749">        // nothing.  Always matches.</a>
<a name="ln5750">        if (utf_iscomposing(curc)) {</a>
<a name="ln5751">          add_off = clen;</a>
<a name="ln5752">        } else {</a>
<a name="ln5753">          add_here = true;</a>
<a name="ln5754">          add_off = 0;</a>
<a name="ln5755">        }</a>
<a name="ln5756">        add_state = t-&gt;state-&gt;out;</a>
<a name="ln5757">        break;</a>
<a name="ln5758"> </a>
<a name="ln5759">      // Character classes like \a for alpha, \d for digit etc.</a>
<a name="ln5760">      case NFA_IDENT:           //  \i</a>
<a name="ln5761">        result = vim_isIDc(curc);</a>
<a name="ln5762">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5763">        break;</a>
<a name="ln5764"> </a>
<a name="ln5765">      case NFA_SIDENT:          //  \I</a>
<a name="ln5766">        result = !ascii_isdigit(curc) &amp;&amp; vim_isIDc(curc);</a>
<a name="ln5767">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5768">        break;</a>
<a name="ln5769"> </a>
<a name="ln5770">      case NFA_KWORD:           //  \k</a>
<a name="ln5771">        result = vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5772">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5773">        break;</a>
<a name="ln5774"> </a>
<a name="ln5775">      case NFA_SKWORD:          //  \K</a>
<a name="ln5776">        result = !ascii_isdigit(curc)</a>
<a name="ln5777">                 &amp;&amp; vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5778">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5779">        break;</a>
<a name="ln5780"> </a>
<a name="ln5781">      case NFA_FNAME:           //  \f</a>
<a name="ln5782">        result = vim_isfilec(curc);</a>
<a name="ln5783">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5784">        break;</a>
<a name="ln5785"> </a>
<a name="ln5786">      case NFA_SFNAME:          //  \F</a>
<a name="ln5787">        result = !ascii_isdigit(curc) &amp;&amp; vim_isfilec(curc);</a>
<a name="ln5788">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5789">        break;</a>
<a name="ln5790"> </a>
<a name="ln5791">      case NFA_PRINT:           //  \p</a>
<a name="ln5792">        result = vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5793">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5794">        break;</a>
<a name="ln5795"> </a>
<a name="ln5796">      case NFA_SPRINT:          //  \P</a>
<a name="ln5797">        result = !ascii_isdigit(curc) &amp;&amp; vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5798">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5799">        break;</a>
<a name="ln5800"> </a>
<a name="ln5801">      case NFA_WHITE:           //  \s</a>
<a name="ln5802">        result = ascii_iswhite(curc);</a>
<a name="ln5803">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5804">        break;</a>
<a name="ln5805"> </a>
<a name="ln5806">      case NFA_NWHITE:          //  \S</a>
<a name="ln5807">        result = curc != NUL &amp;&amp; !ascii_iswhite(curc);</a>
<a name="ln5808">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5809">        break;</a>
<a name="ln5810"> </a>
<a name="ln5811">      case NFA_DIGIT:           //  \d</a>
<a name="ln5812">        result = ri_digit(curc);</a>
<a name="ln5813">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5814">        break;</a>
<a name="ln5815"> </a>
<a name="ln5816">      case NFA_NDIGIT:          //  \D</a>
<a name="ln5817">        result = curc != NUL &amp;&amp; !ri_digit(curc);</a>
<a name="ln5818">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5819">        break;</a>
<a name="ln5820"> </a>
<a name="ln5821">      case NFA_HEX:             //  \x</a>
<a name="ln5822">        result = ri_hex(curc);</a>
<a name="ln5823">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5824">        break;</a>
<a name="ln5825"> </a>
<a name="ln5826">      case NFA_NHEX:            //  \X</a>
<a name="ln5827">        result = curc != NUL &amp;&amp; !ri_hex(curc);</a>
<a name="ln5828">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5829">        break;</a>
<a name="ln5830"> </a>
<a name="ln5831">      case NFA_OCTAL:           //  \o</a>
<a name="ln5832">        result = ri_octal(curc);</a>
<a name="ln5833">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5834">        break;</a>
<a name="ln5835"> </a>
<a name="ln5836">      case NFA_NOCTAL:          //  \O</a>
<a name="ln5837">        result = curc != NUL &amp;&amp; !ri_octal(curc);</a>
<a name="ln5838">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5839">        break;</a>
<a name="ln5840"> </a>
<a name="ln5841">      case NFA_WORD:            //  \w</a>
<a name="ln5842">        result = ri_word(curc);</a>
<a name="ln5843">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5844">        break;</a>
<a name="ln5845"> </a>
<a name="ln5846">      case NFA_NWORD:           //  \W</a>
<a name="ln5847">        result = curc != NUL &amp;&amp; !ri_word(curc);</a>
<a name="ln5848">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5849">        break;</a>
<a name="ln5850"> </a>
<a name="ln5851">      case NFA_HEAD:            //  \h</a>
<a name="ln5852">        result = ri_head(curc);</a>
<a name="ln5853">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5854">        break;</a>
<a name="ln5855"> </a>
<a name="ln5856">      case NFA_NHEAD:           //  \H</a>
<a name="ln5857">        result = curc != NUL &amp;&amp; !ri_head(curc);</a>
<a name="ln5858">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5859">        break;</a>
<a name="ln5860"> </a>
<a name="ln5861">      case NFA_ALPHA:           //  \a</a>
<a name="ln5862">        result = ri_alpha(curc);</a>
<a name="ln5863">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5864">        break;</a>
<a name="ln5865"> </a>
<a name="ln5866">      case NFA_NALPHA:          //  \A</a>
<a name="ln5867">        result = curc != NUL &amp;&amp; !ri_alpha(curc);</a>
<a name="ln5868">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5869">        break;</a>
<a name="ln5870"> </a>
<a name="ln5871">      case NFA_LOWER:           //  \l</a>
<a name="ln5872">        result = ri_lower(curc);</a>
<a name="ln5873">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5874">        break;</a>
<a name="ln5875"> </a>
<a name="ln5876">      case NFA_NLOWER:          //  \L</a>
<a name="ln5877">        result = curc != NUL &amp;&amp; !ri_lower(curc);</a>
<a name="ln5878">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5879">        break;</a>
<a name="ln5880"> </a>
<a name="ln5881">      case NFA_UPPER:           //  \u</a>
<a name="ln5882">        result = ri_upper(curc);</a>
<a name="ln5883">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5884">        break;</a>
<a name="ln5885"> </a>
<a name="ln5886">      case NFA_NUPPER:          // \U</a>
<a name="ln5887">        result = curc != NUL &amp;&amp; !ri_upper(curc);</a>
<a name="ln5888">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5889">        break;</a>
<a name="ln5890"> </a>
<a name="ln5891">      case NFA_LOWER_IC:        // [a-z]</a>
<a name="ln5892">        result = ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc));</a>
<a name="ln5893">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5894">        break;</a>
<a name="ln5895"> </a>
<a name="ln5896">      case NFA_NLOWER_IC:       // [^a-z]</a>
<a name="ln5897">        result = curc != NUL</a>
<a name="ln5898">                 &amp;&amp; !(ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc)));</a>
<a name="ln5899">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5900">        break;</a>
<a name="ln5901"> </a>
<a name="ln5902">      case NFA_UPPER_IC:        // [A-Z]</a>
<a name="ln5903">        result = ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc));</a>
<a name="ln5904">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5905">        break;</a>
<a name="ln5906"> </a>
<a name="ln5907">      case NFA_NUPPER_IC:       // [^A-Z]</a>
<a name="ln5908">        result = curc != NUL</a>
<a name="ln5909">                 &amp;&amp; !(ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc)));</a>
<a name="ln5910">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5911">        break;</a>
<a name="ln5912"> </a>
<a name="ln5913">      case NFA_BACKREF1:</a>
<a name="ln5914">      case NFA_BACKREF2:</a>
<a name="ln5915">      case NFA_BACKREF3:</a>
<a name="ln5916">      case NFA_BACKREF4:</a>
<a name="ln5917">      case NFA_BACKREF5:</a>
<a name="ln5918">      case NFA_BACKREF6:</a>
<a name="ln5919">      case NFA_BACKREF7:</a>
<a name="ln5920">      case NFA_BACKREF8:</a>
<a name="ln5921">      case NFA_BACKREF9:</a>
<a name="ln5922">      case NFA_ZREF1:</a>
<a name="ln5923">      case NFA_ZREF2:</a>
<a name="ln5924">      case NFA_ZREF3:</a>
<a name="ln5925">      case NFA_ZREF4:</a>
<a name="ln5926">      case NFA_ZREF5:</a>
<a name="ln5927">      case NFA_ZREF6:</a>
<a name="ln5928">      case NFA_ZREF7:</a>
<a name="ln5929">      case NFA_ZREF8:</a>
<a name="ln5930">      case NFA_ZREF9:</a>
<a name="ln5931">        // \1 .. \9  \z1 .. \z9</a>
<a name="ln5932">      {</a>
<a name="ln5933">        int subidx;</a>
<a name="ln5934">        int bytelen;</a>
<a name="ln5935"> </a>
<a name="ln5936">        if (t-&gt;state-&gt;c &lt;= NFA_BACKREF9) {</a>
<a name="ln5937">          subidx = t-&gt;state-&gt;c - NFA_BACKREF1 + 1;</a>
<a name="ln5938">          result = match_backref(&amp;t-&gt;subs.norm, subidx, &amp;bytelen);</a>
<a name="ln5939">        } else {</a>
<a name="ln5940">          subidx = t-&gt;state-&gt;c - NFA_ZREF1 + 1;</a>
<a name="ln5941">          result = match_zref(subidx, &amp;bytelen);</a>
<a name="ln5942">        }</a>
<a name="ln5943"> </a>
<a name="ln5944">        if (result) {</a>
<a name="ln5945">          if (bytelen == 0) {</a>
<a name="ln5946">            // empty match always works, output of NFA_SKIP to be</a>
<a name="ln5947">            // used next</a>
<a name="ln5948">            add_here = true;</a>
<a name="ln5949">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5950">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5951">            // match current character, jump ahead to out of</a>
<a name="ln5952">            // NFA_SKIP</a>
<a name="ln5953">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5954">            add_off = clen;</a>
<a name="ln5955">          } else {</a>
<a name="ln5956">            // skip over the matched characters, set character</a>
<a name="ln5957">            // count in NFA_SKIP</a>
<a name="ln5958">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln5959">            add_off = bytelen;</a>
<a name="ln5960">            add_count = bytelen - clen;</a>
<a name="ln5961">          }</a>
<a name="ln5962">        }</a>
<a name="ln5963">        break;</a>
<a name="ln5964">      }</a>
<a name="ln5965">      case NFA_SKIP:</a>
<a name="ln5966">        // character of previous matching \1 .. \9  or \@&gt;</a>
<a name="ln5967">        if (t-&gt;count - clen &lt;= 0) {</a>
<a name="ln5968">          // end of match, go to what follows</a>
<a name="ln5969">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5970">          add_off = clen;</a>
<a name="ln5971">        } else {</a>
<a name="ln5972">          // add state again with decremented count</a>
<a name="ln5973">          add_state = t-&gt;state;</a>
<a name="ln5974">          add_off = 0;</a>
<a name="ln5975">          add_count = t-&gt;count - clen;</a>
<a name="ln5976">        }</a>
<a name="ln5977">        break;</a>
<a name="ln5978"> </a>
<a name="ln5979">      case NFA_LNUM:</a>
<a name="ln5980">      case NFA_LNUM_GT:</a>
<a name="ln5981">      case NFA_LNUM_LT:</a>
<a name="ln5982">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln5983">               &amp;&amp; !((rex.reg_firstlnum &gt; 0</a>
<a name="ln5984">                     &amp;&amp; rex.lnum &gt; LONG_MAX - rex.reg_firstlnum)</a>
<a name="ln5985">                    || (rex.reg_firstlnum &lt; 0</a>
<a name="ln5986">                        &amp;&amp; rex.lnum &lt; LONG_MIN + rex.reg_firstlnum))</a>
<a name="ln5987">               &amp;&amp; rex.lnum + rex.reg_firstlnum &gt;= 0);</a>
<a name="ln5988">        result = (REG_MULTI</a>
<a name="ln5989">                  &amp;&amp; nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln5990">                                    t-&gt;state-&gt;c - NFA_LNUM,</a>
<a name="ln5991">                                    (uintmax_t)(rex.lnum + rex.reg_firstlnum)));</a>
<a name="ln5992">        if (result) {</a>
<a name="ln5993">          add_here = true;</a>
<a name="ln5994">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5995">        }</a>
<a name="ln5996">        break;</a>
<a name="ln5997"> </a>
<a name="ln5998">      case NFA_COL:</a>
<a name="ln5999">      case NFA_COL_GT:</a>
<a name="ln6000">      case NFA_COL_LT:</a>
<a name="ln6001">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln6002">               &amp;&amp; rex.input &gt;= rex.line</a>
<a name="ln6003">               &amp;&amp; (uintmax_t)(rex.input - rex.line) &lt;= UINTMAX_MAX - 1);</a>
<a name="ln6004">        result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6005">                                t-&gt;state-&gt;c - NFA_COL,</a>
<a name="ln6006">                                (uintmax_t)(rex.input - rex.line + 1));</a>
<a name="ln6007">        if (result) {</a>
<a name="ln6008">          add_here = true;</a>
<a name="ln6009">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6010">        }</a>
<a name="ln6011">        break;</a>
<a name="ln6012"> </a>
<a name="ln6013">      case NFA_VCOL:</a>
<a name="ln6014">      case NFA_VCOL_GT:</a>
<a name="ln6015">      case NFA_VCOL_LT:</a>
<a name="ln6016">        {</a>
<a name="ln6017">          int op = t-&gt;state-&gt;c - NFA_VCOL;</a>
<a name="ln6018">          colnr_T col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln6019"> </a>
<a name="ln6020">          // Bail out quickly when there can't be a match, avoid the overhead of</a>
<a name="ln6021">          // win_linetabsize() on long lines.</a>
<a name="ln6022">          if (op != 1 &amp;&amp; col &gt; t-&gt;state-&gt;val * MB_MAXBYTES) {</a>
<a name="ln6023">            break;</a>
<a name="ln6024">          }</a>
<a name="ln6025"> </a>
<a name="ln6026">          result = false;</a>
<a name="ln6027">          win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;</a>
<a name="ln6028">          if (op == 1 &amp;&amp; col - 1 &gt; t-&gt;state-&gt;val &amp;&amp; col &gt; 100) {</a>
<a name="ln6029">            long ts = wp-&gt;w_buffer-&gt;b_p_ts;</a>
<a name="ln6030"> </a>
<a name="ln6031">            // Guess that a character won't use more columns than 'tabstop',</a>
<a name="ln6032">            // with a minimum of 4.</a>
<a name="ln6033">            if (ts &lt; 4) {</a>
<a name="ln6034">              ts = 4;</a>
<a name="ln6035">            }</a>
<a name="ln6036">            result = col &gt; t-&gt;state-&gt;val * ts;</a>
<a name="ln6037">          }</a>
<a name="ln6038">          if (!result) {</a>
<a name="ln6039">            uintmax_t lts = win_linetabsize(wp, rex.line, col);</a>
<a name="ln6040">            assert(t-&gt;state-&gt;val &gt;= 0);</a>
<a name="ln6041">            result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val, op, lts + 1);</a>
<a name="ln6042">          }</a>
<a name="ln6043">          if (result) {</a>
<a name="ln6044">            add_here = true;</a>
<a name="ln6045">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6046">          }</a>
<a name="ln6047">        }</a>
<a name="ln6048">        break;</a>
<a name="ln6049"> </a>
<a name="ln6050">      case NFA_MARK:</a>
<a name="ln6051">      case NFA_MARK_GT:</a>
<a name="ln6052">      case NFA_MARK_LT:</a>
<a name="ln6053">      {</a>
<a name="ln6054">        pos_T *pos = getmark_buf(rex.reg_buf, t-&gt;state-&gt;val, false);</a>
<a name="ln6055"> </a>
<a name="ln6056">        // Compare the mark position to the match position.</a>
<a name="ln6057">        result = (pos != NULL                        // mark doesn't exist</a>
<a name="ln6058">                  &amp;&amp; pos-&gt;lnum &gt; 0          // mark isn't set in reg_buf</a>
<a name="ln6059">                  &amp;&amp; (pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6060">                      ? (pos-&gt;col == (colnr_T)(rex.input - rex.line)</a>
<a name="ln6061">                         ? t-&gt;state-&gt;c == NFA_MARK</a>
<a name="ln6062">                         : (pos-&gt;col &lt; (colnr_T)(rex.input - rex.line)</a>
<a name="ln6063">                            ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6064">                            : t-&gt;state-&gt;c == NFA_MARK_LT))</a>
<a name="ln6065">                      : (pos-&gt;lnum &lt; rex.lnum + rex.reg_firstlnum</a>
<a name="ln6066">                         ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6067">                         : t-&gt;state-&gt;c == NFA_MARK_LT)));</a>
<a name="ln6068">        if (result) {</a>
<a name="ln6069">          add_here = true;</a>
<a name="ln6070">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6071">        }</a>
<a name="ln6072">        break;</a>
<a name="ln6073">      }</a>
<a name="ln6074"> </a>
<a name="ln6075">      case NFA_CURSOR:</a>
<a name="ln6076">        result = rex.reg_win != NULL</a>
<a name="ln6077">          &amp;&amp; (rex.lnum + rex.reg_firstlnum == rex.reg_win-&gt;w_cursor.lnum)</a>
<a name="ln6078">          &amp;&amp; ((colnr_T)(rex.input - rex.line) == rex.reg_win-&gt;w_cursor.col);</a>
<a name="ln6079">        if (result) {</a>
<a name="ln6080">          add_here = true;</a>
<a name="ln6081">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6082">        }</a>
<a name="ln6083">        break;</a>
<a name="ln6084"> </a>
<a name="ln6085">      case NFA_VISUAL:</a>
<a name="ln6086">        result = reg_match_visual();</a>
<a name="ln6087">        if (result) {</a>
<a name="ln6088">          add_here = true;</a>
<a name="ln6089">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6090">        }</a>
<a name="ln6091">        break;</a>
<a name="ln6092"> </a>
<a name="ln6093">      case NFA_MOPEN1:</a>
<a name="ln6094">      case NFA_MOPEN2:</a>
<a name="ln6095">      case NFA_MOPEN3:</a>
<a name="ln6096">      case NFA_MOPEN4:</a>
<a name="ln6097">      case NFA_MOPEN5:</a>
<a name="ln6098">      case NFA_MOPEN6:</a>
<a name="ln6099">      case NFA_MOPEN7:</a>
<a name="ln6100">      case NFA_MOPEN8:</a>
<a name="ln6101">      case NFA_MOPEN9:</a>
<a name="ln6102">      case NFA_ZOPEN:</a>
<a name="ln6103">      case NFA_ZOPEN1:</a>
<a name="ln6104">      case NFA_ZOPEN2:</a>
<a name="ln6105">      case NFA_ZOPEN3:</a>
<a name="ln6106">      case NFA_ZOPEN4:</a>
<a name="ln6107">      case NFA_ZOPEN5:</a>
<a name="ln6108">      case NFA_ZOPEN6:</a>
<a name="ln6109">      case NFA_ZOPEN7:</a>
<a name="ln6110">      case NFA_ZOPEN8:</a>
<a name="ln6111">      case NFA_ZOPEN9:</a>
<a name="ln6112">      case NFA_NOPEN:</a>
<a name="ln6113">      case NFA_ZSTART:</a>
<a name="ln6114">        // These states are only added to be able to bail out when</a>
<a name="ln6115">        // they are added again, nothing is to be done.</a>
<a name="ln6116">        break;</a>
<a name="ln6117"> </a>
<a name="ln6118">      default:          // regular character</a>
<a name="ln6119">      {</a>
<a name="ln6120">        int c = t-&gt;state-&gt;c;</a>
<a name="ln6121"> </a>
<a name="ln6122">#ifdef REGEXP_DEBUG</a>
<a name="ln6123">        if (c &lt; 0) {</a>
<a name="ln6124">          IEMSGN(&quot;INTERNAL: Negative state char: %&quot; PRId64, c);</a>
<a name="ln6125">        }</a>
<a name="ln6126">#endif</a>
<a name="ln6127">        result = (c == curc);</a>
<a name="ln6128"> </a>
<a name="ln6129">        if (!result &amp;&amp; rex.reg_ic) {</a>
<a name="ln6130">          result = utf_fold(c) == utf_fold(curc);</a>
<a name="ln6131">        }</a>
<a name="ln6132"> </a>
<a name="ln6133">        // If rex.reg_icombine is not set only skip over the character</a>
<a name="ln6134">        // itself.  When it is set skip over composing characters.</a>
<a name="ln6135">        if (result &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6136">          clen = utf_ptr2len(rex.input);</a>
<a name="ln6137">        }</a>
<a name="ln6138"> </a>
<a name="ln6139">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln6140">        break;</a>
<a name="ln6141">      }</a>
<a name="ln6142">      }       // switch (t-&gt;state-&gt;c)</a>
<a name="ln6143"> </a>
<a name="ln6144">      if (add_state != NULL) {</a>
<a name="ln6145">        nfa_pim_T *pim;</a>
<a name="ln6146">        nfa_pim_T pim_copy;</a>
<a name="ln6147"> </a>
<a name="ln6148">        if (t-&gt;pim.result == NFA_PIM_UNUSED)</a>
<a name="ln6149">          pim = NULL;</a>
<a name="ln6150">        else</a>
<a name="ln6151">          pim = &amp;t-&gt;pim;</a>
<a name="ln6152"> </a>
<a name="ln6153">        // Handle the postponed invisible match if the match might end</a>
<a name="ln6154">        // without advancing and before the end of the line.</a>
<a name="ln6155">        if (pim != NULL &amp;&amp; (clen == 0 || match_follows(add_state, 0))) {</a>
<a name="ln6156">          if (pim-&gt;result == NFA_PIM_TODO) {</a>
<a name="ln6157">#ifdef REGEXP_DEBUG</a>
<a name="ln6158">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6159">            fprintf(log_fd, &quot;==================================\n&quot;);</a>
<a name="ln6160">            fprintf(log_fd, &quot;Postponed recursive nfa_regmatch()\n&quot;);</a>
<a name="ln6161">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6162">#endif</a>
<a name="ln6163">            result = recursive_regmatch(pim-&gt;state, pim, prog, submatch, m,</a>
<a name="ln6164">                                        &amp;listids, &amp;listids_len);</a>
<a name="ln6165">            pim-&gt;result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;</a>
<a name="ln6166">            // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln6167">            // false</a>
<a name="ln6168">            if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6169">                           || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6170">                           || pim-&gt;state-&gt;c</a>
<a name="ln6171">                           == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6172">                           || pim-&gt;state-&gt;c</a>
<a name="ln6173">                           == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6174">              // Copy submatch info from the recursive call</a>
<a name="ln6175">              copy_sub_off(&amp;pim-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln6176">              if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6177">                copy_sub_off(&amp;pim-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln6178">              }</a>
<a name="ln6179">            }</a>
<a name="ln6180">          } else {</a>
<a name="ln6181">            result = (pim-&gt;result == NFA_PIM_MATCH);</a>
<a name="ln6182">#ifdef REGEXP_DEBUG</a>
<a name="ln6183">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6184">            fprintf(</a>
<a name="ln6185">                log_fd,</a>
<a name="ln6186">                &quot;Using previous recursive nfa_regmatch() result, result == %d\n&quot;,</a>
<a name="ln6187">                pim-&gt;result);</a>
<a name="ln6188">            fprintf(log_fd, &quot;MATCH = %s\n&quot;, result ? &quot;OK&quot; : &quot;false&quot;);</a>
<a name="ln6189">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6190">#endif</a>
<a name="ln6191">          }</a>
<a name="ln6192"> </a>
<a name="ln6193">          // for \@! and \@&lt;! it is a match when result is false</a>
<a name="ln6194">          if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6195">                         || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6196">                         || pim-&gt;state-&gt;c</a>
<a name="ln6197">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6198">                         || pim-&gt;state-&gt;c</a>
<a name="ln6199">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6200">            // Copy submatch info from the recursive call</a>
<a name="ln6201">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;pim-&gt;subs.norm);</a>
<a name="ln6202">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6203">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;pim-&gt;subs.synt);</a>
<a name="ln6204">            }</a>
<a name="ln6205">          } else {</a>
<a name="ln6206">            // look-behind match failed, don't add the state</a>
<a name="ln6207">            continue;</a>
<a name="ln6208">          }</a>
<a name="ln6209"> </a>
<a name="ln6210">          // Postponed invisible match was handled, don't add it to</a>
<a name="ln6211">          // following states.</a>
<a name="ln6212">          pim = NULL;</a>
<a name="ln6213">        }</a>
<a name="ln6214"> </a>
<a name="ln6215">        // If &quot;pim&quot; points into l-&gt;t it will become invalid when</a>
<a name="ln6216">        // adding the state causes the list to be reallocated.  Make a</a>
<a name="ln6217">        // local copy to avoid that.</a>
<a name="ln6218">        if (pim == &amp;t-&gt;pim) {</a>
<a name="ln6219">          copy_pim(&amp;pim_copy, pim);</a>
<a name="ln6220">          pim = &amp;pim_copy;</a>
<a name="ln6221">        }</a>
<a name="ln6222"> </a>
<a name="ln6223">        if (add_here) {</a>
<a name="ln6224">          r = addstate_here(thislist, add_state, &amp;t-&gt;subs, pim, &amp;listidx);</a>
<a name="ln6225">        } else {</a>
<a name="ln6226">          r = addstate(nextlist, add_state, &amp;t-&gt;subs, pim, add_off);</a>
<a name="ln6227">          if (add_count &gt; 0) {</a>
<a name="ln6228">            nextlist-&gt;t[nextlist-&gt;n - 1].count = add_count;</a>
<a name="ln6229">          }</a>
<a name="ln6230">        }</a>
<a name="ln6231">        if (r == NULL) {</a>
<a name="ln6232">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6233">          goto theend;</a>
<a name="ln6234">        }</a>
<a name="ln6235">      }</a>
<a name="ln6236">    }     // for (thislist = thislist; thislist-&gt;state; thislist++)</a>
<a name="ln6237"> </a>
<a name="ln6238">    // Look for the start of a match in the current position by adding the</a>
<a name="ln6239">    // start state to the list of states.</a>
<a name="ln6240">    // The first found match is the leftmost one, thus the order of states</a>
<a name="ln6241">    // matters!</a>
<a name="ln6242">    // Do not add the start state in recursive calls of nfa_regmatch(),</a>
<a name="ln6243">    // because recursive calls should only start in the first position.</a>
<a name="ln6244">    // Unless &quot;nfa_endp&quot; is not NULL, then we match the end position.</a>
<a name="ln6245">    // Also don't start a match past the first line.</a>
<a name="ln6246">    if (!nfa_match</a>
<a name="ln6247">        &amp;&amp; ((toplevel</a>
<a name="ln6248">             &amp;&amp; rex.lnum == 0</a>
<a name="ln6249">             &amp;&amp; clen != 0</a>
<a name="ln6250">             &amp;&amp; (rex.reg_maxcol == 0</a>
<a name="ln6251">                 || (colnr_T)(rex.input - rex.line) &lt; rex.reg_maxcol))</a>
<a name="ln6252">            || (nfa_endp != NULL</a>
<a name="ln6253">                &amp;&amp; (REG_MULTI</a>
<a name="ln6254">                    ? (rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6255">                       || (rex.lnum == nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6256">                           &amp;&amp; (int)(rex.input - rex.line)</a>
<a name="ln6257">                           &lt; nfa_endp-&gt;se_u.pos.col))</a>
<a name="ln6258">                    : rex.input &lt; nfa_endp-&gt;se_u.ptr)))) {</a>
<a name="ln6259">#ifdef REGEXP_DEBUG</a>
<a name="ln6260">      fprintf(log_fd, &quot;(---) STARTSTATE\n&quot;);</a>
<a name="ln6261">#endif</a>
<a name="ln6262">      // Inline optimized code for addstate() if we know the state is</a>
<a name="ln6263">      // the first MOPEN.</a>
<a name="ln6264">      if (toplevel) {</a>
<a name="ln6265">        int add = true;</a>
<a name="ln6266"> </a>
<a name="ln6267">        if (prog-&gt;regstart != NUL &amp;&amp; clen != 0) {</a>
<a name="ln6268">          if (nextlist-&gt;n == 0) {</a>
<a name="ln6269">            colnr_T col = (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6270"> </a>
<a name="ln6271">            // Nextlist is empty, we can skip ahead to the</a>
<a name="ln6272">            // character that must appear at the start.</a>
<a name="ln6273">            if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL) {</a>
<a name="ln6274">              break;</a>
<a name="ln6275">            }</a>
<a name="ln6276">#ifdef REGEXP_DEBUG</a>
<a name="ln6277">            fprintf(log_fd, &quot;  Skipping ahead %d bytes to regstart\n&quot;,</a>
<a name="ln6278">                    col - ((colnr_T)(rex.input - rex.line) + clen));</a>
<a name="ln6279">#endif</a>
<a name="ln6280">            rex.input = rex.line + col - clen;</a>
<a name="ln6281">          } else {</a>
<a name="ln6282">            // Checking if the required start character matches is</a>
<a name="ln6283">            // cheaper than adding a state that won't match.</a>
<a name="ln6284">            const int c = PTR2CHAR(rex.input + clen);</a>
<a name="ln6285">            if (c != prog-&gt;regstart</a>
<a name="ln6286">                &amp;&amp; (!rex.reg_ic</a>
<a name="ln6287">                    || utf_fold(c) != utf_fold(prog-&gt;regstart))) {</a>
<a name="ln6288">#ifdef REGEXP_DEBUG</a>
<a name="ln6289">              fprintf(log_fd,</a>
<a name="ln6290">                  &quot;  Skipping start state, regstart does not match\n&quot;);</a>
<a name="ln6291">#endif</a>
<a name="ln6292">              add = false;</a>
<a name="ln6293">            }</a>
<a name="ln6294">          }</a>
<a name="ln6295">        }</a>
<a name="ln6296"> </a>
<a name="ln6297">        if (add) {</a>
<a name="ln6298">          if (REG_MULTI) {</a>
<a name="ln6299">            m-&gt;norm.list.multi[0].start_col =</a>
<a name="ln6300">              (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6301">          } else {</a>
<a name="ln6302">            m-&gt;norm.list.line[0].start = rex.input + clen;</a>
<a name="ln6303">          }</a>
<a name="ln6304">          if (addstate(nextlist, start-&gt;out, m, NULL, clen) == NULL) {</a>
<a name="ln6305">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6306">            goto theend;</a>
<a name="ln6307">          }</a>
<a name="ln6308">        }</a>
<a name="ln6309">      } else {</a>
<a name="ln6310">        if (addstate(nextlist, start, m, NULL, clen) == NULL) {</a>
<a name="ln6311">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6312">          goto theend;</a>
<a name="ln6313">        }</a>
<a name="ln6314">      }</a>
<a name="ln6315">    }</a>
<a name="ln6316"> </a>
<a name="ln6317">#ifdef REGEXP_DEBUG</a>
<a name="ln6318">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist had %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln6319">    {</a>
<a name="ln6320">      int i;</a>
<a name="ln6321"> </a>
<a name="ln6322">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln6323">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln6324">    }</a>
<a name="ln6325">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6326">#endif</a>
<a name="ln6327"> </a>
<a name="ln6328">nextchar:</a>
<a name="ln6329">    // Advance to the next character, or advance to the next line, or</a>
<a name="ln6330">    // finish.</a>
<a name="ln6331">    if (clen != 0) {</a>
<a name="ln6332">      rex.input += clen;</a>
<a name="ln6333">    } else if (go_to_nextline || (nfa_endp != NULL &amp;&amp; REG_MULTI</a>
<a name="ln6334">                                  &amp;&amp; rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln6335">      reg_nextline();</a>
<a name="ln6336">    } else {</a>
<a name="ln6337">      break;</a>
<a name="ln6338">    }</a>
<a name="ln6339"> </a>
<a name="ln6340">    // Allow interrupting with CTRL-C.</a>
<a name="ln6341">    line_breakcheck();</a>
<a name="ln6342">    if (got_int) {</a>
<a name="ln6343">      break;</a>
<a name="ln6344">    }</a>
<a name="ln6345">    // Check for timeout once every twenty times to avoid overhead.</a>
<a name="ln6346">    if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln6347">      nfa_time_count = 0;</a>
<a name="ln6348">      if (nfa_did_time_out()) {</a>
<a name="ln6349">        break;</a>
<a name="ln6350">      }</a>
<a name="ln6351">    }</a>
<a name="ln6352">  }</a>
<a name="ln6353"> </a>
<a name="ln6354">#ifdef REGEXP_DEBUG</a>
<a name="ln6355">  if (log_fd != stderr)</a>
<a name="ln6356">    fclose(log_fd);</a>
<a name="ln6357">  log_fd = NULL;</a>
<a name="ln6358">#endif</a>
<a name="ln6359"> </a>
<a name="ln6360">theend:</a>
<a name="ln6361">  // Free memory</a>
<a name="ln6362">  xfree(list[0].t);</a>
<a name="ln6363">  xfree(list[1].t);</a>
<a name="ln6364">  xfree(listids);</a>
<a name="ln6365">#undef ADD_STATE_IF_MATCH</a>
<a name="ln6366">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln6367">  fclose(debug);</a>
<a name="ln6368">#endif</a>
<a name="ln6369"> </a>
<a name="ln6370">  return nfa_match;</a>
<a name="ln6371">}</a>
<a name="ln6372"> </a>
<a name="ln6373">// Try match of &quot;prog&quot; with at rex.line[&quot;col&quot;].</a>
<a name="ln6374">// Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6375">static long nfa_regtry(nfa_regprog_T *prog,</a>
<a name="ln6376">                       colnr_T col,</a>
<a name="ln6377">                       proftime_T *tm,    // timeout limit or NULL</a>
<a name="ln6378">                       int *timed_out)    // flag set on timeout or NULL</a>
<a name="ln6379">{</a>
<a name="ln6380">  int i;</a>
<a name="ln6381">  regsubs_T subs, m;</a>
<a name="ln6382">  nfa_state_T *start = prog-&gt;start;</a>
<a name="ln6383">#ifdef REGEXP_DEBUG</a>
<a name="ln6384">  FILE        *f;</a>
<a name="ln6385">#endif</a>
<a name="ln6386"> </a>
<a name="ln6387">  rex.input = rex.line + col;</a>
<a name="ln6388">  nfa_time_limit = tm;</a>
<a name="ln6389">  nfa_timed_out = timed_out;</a>
<a name="ln6390">  nfa_time_count = 0;</a>
<a name="ln6391"> </a>
<a name="ln6392">#ifdef REGEXP_DEBUG</a>
<a name="ln6393">  f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6394">  if (f != NULL) {</a>
<a name="ln6395">    fprintf(f,</a>
<a name="ln6396">        &quot;\n\n\t=======================================================\n&quot;);</a>
<a name="ln6397">#ifdef REGEXP_DEBUG</a>
<a name="ln6398">    fprintf(f, &quot;\tRegexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln6399">#endif</a>
<a name="ln6400">    fprintf(f, &quot;\tInput text is \&quot;%s\&quot; \n&quot;, rex.input);</a>
<a name="ln6401">    fprintf(f, &quot;\t=======================================================\n\n&quot;);</a>
<a name="ln6402">    nfa_print_state(f, start);</a>
<a name="ln6403">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln6404">    fclose(f);</a>
<a name="ln6405">  } else {</a>
<a name="ln6406">    EMSG(&quot;Could not open temporary log file for writing&quot;);</a>
<a name="ln6407">  }</a>
<a name="ln6408">#endif</a>
<a name="ln6409"> </a>
<a name="ln6410">  clear_sub(&amp;subs.norm);</a>
<a name="ln6411">  clear_sub(&amp;m.norm);</a>
<a name="ln6412">  clear_sub(&amp;subs.synt);</a>
<a name="ln6413">  clear_sub(&amp;m.synt);</a>
<a name="ln6414"> </a>
<a name="ln6415">  int result = nfa_regmatch(prog, start, &amp;subs, &amp;m);</a>
<a name="ln6416">  if (!result) {</a>
<a name="ln6417">    return 0;</a>
<a name="ln6418">  } else if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln6419">    return result;</a>
<a name="ln6420">  }</a>
<a name="ln6421"> </a>
<a name="ln6422">  cleanup_subexpr();</a>
<a name="ln6423">  if (REG_MULTI) {</a>
<a name="ln6424">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6425">      rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;</a>
<a name="ln6426">      rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;</a>
<a name="ln6427"> </a>
<a name="ln6428">      rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;</a>
<a name="ln6429">      rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;</a>
<a name="ln6430">    }</a>
<a name="ln6431"> </a>
<a name="ln6432">    if (rex.reg_startpos[0].lnum &lt; 0) {</a>
<a name="ln6433">      rex.reg_startpos[0].lnum = 0;</a>
<a name="ln6434">      rex.reg_startpos[0].col = col;</a>
<a name="ln6435">    }</a>
<a name="ln6436">    if (rex.reg_endpos[0].lnum &lt; 0) {</a>
<a name="ln6437">      // pattern has a \ze but it didn't match, use current end</a>
<a name="ln6438">      rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln6439">      rex.reg_endpos[0].col = (int)(rex.input - rex.line);</a>
<a name="ln6440">    } else {</a>
<a name="ln6441">      // Use line number of &quot;\ze&quot;.</a>
<a name="ln6442">      rex.lnum = rex.reg_endpos[0].lnum;</a>
<a name="ln6443">    }</a>
<a name="ln6444">  } else {</a>
<a name="ln6445">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6446">      rex.reg_startp[i] = subs.norm.list.line[i].start;</a>
<a name="ln6447">      rex.reg_endp[i] = subs.norm.list.line[i].end;</a>
<a name="ln6448">    }</a>
<a name="ln6449"> </a>
<a name="ln6450">    if (rex.reg_startp[0] == NULL) {</a>
<a name="ln6451">      rex.reg_startp[0] = rex.line + col;</a>
<a name="ln6452">    }</a>
<a name="ln6453">    if (rex.reg_endp[0] == NULL) {</a>
<a name="ln6454">      rex.reg_endp[0] = rex.input;</a>
<a name="ln6455">    }</a>
<a name="ln6456">  }</a>
<a name="ln6457"> </a>
<a name="ln6458">  /* Package any found \z(...\) matches for export. Default is none. */</a>
<a name="ln6459">  unref_extmatch(re_extmatch_out);</a>
<a name="ln6460">  re_extmatch_out = NULL;</a>
<a name="ln6461"> </a>
<a name="ln6462">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6463">    cleanup_zsubexpr();</a>
<a name="ln6464">    re_extmatch_out = make_extmatch();</a>
<a name="ln6465">    // Loop over \z1, \z2, etc.  There is no \z0.</a>
<a name="ln6466">    for (i = 1; i &lt; subs.synt.in_use; i++) {</a>
<a name="ln6467">      if (REG_MULTI) {</a>
<a name="ln6468">        struct multipos *mpos = &amp;subs.synt.list.multi[i];</a>
<a name="ln6469"> </a>
<a name="ln6470">        // Only accept single line matches that are valid.</a>
<a name="ln6471">        if (mpos-&gt;start_lnum &gt;= 0</a>
<a name="ln6472">            &amp;&amp; mpos-&gt;start_lnum == mpos-&gt;end_lnum</a>
<a name="ln6473">            &amp;&amp; mpos-&gt;end_col &gt;= mpos-&gt;start_col) {</a>
<a name="ln6474">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6475">            vim_strnsave(reg_getline(mpos-&gt;start_lnum) + mpos-&gt;start_col,</a>
<a name="ln6476">                         mpos-&gt;end_col - mpos-&gt;start_col);</a>
<a name="ln6477">        }</a>
<a name="ln6478">      } else {</a>
<a name="ln6479">        struct linepos *lpos = &amp;subs.synt.list.line[i];</a>
<a name="ln6480"> </a>
<a name="ln6481">        if (lpos-&gt;start != NULL &amp;&amp; lpos-&gt;end != NULL)</a>
<a name="ln6482">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6483">            vim_strnsave(lpos-&gt;start, lpos-&gt;end - lpos-&gt;start);</a>
<a name="ln6484">      }</a>
<a name="ln6485">    }</a>
<a name="ln6486">  }</a>
<a name="ln6487"> </a>
<a name="ln6488">  return 1 + rex.lnum;</a>
<a name="ln6489">}</a>
<a name="ln6490"> </a>
<a name="ln6491">/// Match a regexp against a string (&quot;line&quot; points to the string) or multiple</a>
<a name="ln6492">/// lines (&quot;line&quot; is NULL, use reg_getline()).</a>
<a name="ln6493">///</a>
<a name="ln6494">/// @param line String in which to search or NULL</a>
<a name="ln6495">/// @param startcol Column to start looking for match</a>
<a name="ln6496">/// @param tm Timeout limit or NULL</a>
<a name="ln6497">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6498">///</a>
<a name="ln6499">/// @return &lt;= 0 if there is no match and number of lines contained in the</a>
<a name="ln6500">/// match otherwise.</a>
<a name="ln6501">static long nfa_regexec_both(char_u *line, colnr_T startcol,</a>
<a name="ln6502">                             proftime_T *tm, int *timed_out)</a>
<a name="ln6503">{</a>
<a name="ln6504">  nfa_regprog_T   *prog;</a>
<a name="ln6505">  long retval = 0L;</a>
<a name="ln6506">  colnr_T col = startcol;</a>
<a name="ln6507"> </a>
<a name="ln6508">  if (REG_MULTI) {</a>
<a name="ln6509">    prog = (nfa_regprog_T *)rex.reg_mmatch-&gt;regprog;</a>
<a name="ln6510">    line = reg_getline((linenr_T)0);  // relative to the cursor</a>
<a name="ln6511">    rex.reg_startpos = rex.reg_mmatch-&gt;startpos;</a>
<a name="ln6512">    rex.reg_endpos = rex.reg_mmatch-&gt;endpos;</a>
<a name="ln6513">  } else {</a>
<a name="ln6514">    prog = (nfa_regprog_T *)rex.reg_match-&gt;regprog;</a>
<a name="ln6515">    rex.reg_startp = rex.reg_match-&gt;startp;</a>
<a name="ln6516">    rex.reg_endp = rex.reg_match-&gt;endp;</a>
<a name="ln6517">  }</a>
<a name="ln6518"> </a>
<a name="ln6519">  /* Be paranoid... */</a>
<a name="ln6520">  if (prog == NULL || line == NULL) {</a>
<a name="ln6521">    IEMSG(_(e_null));</a>
<a name="ln6522">    goto theend;</a>
<a name="ln6523">  }</a>
<a name="ln6524"> </a>
<a name="ln6525">  // If pattern contains &quot;\c&quot; or &quot;\C&quot;: overrule value of rex.reg_ic</a>
<a name="ln6526">  if (prog-&gt;regflags &amp; RF_ICASE) {</a>
<a name="ln6527">    rex.reg_ic = true;</a>
<a name="ln6528">  } else if (prog-&gt;regflags &amp; RF_NOICASE) {</a>
<a name="ln6529">    rex.reg_ic = false;</a>
<a name="ln6530">  }</a>
<a name="ln6531"> </a>
<a name="ln6532">  // If pattern contains &quot;\Z&quot; overrule value of rex.reg_icombine</a>
<a name="ln6533">  if (prog-&gt;regflags &amp; RF_ICOMBINE) {</a>
<a name="ln6534">    rex.reg_icombine = true;</a>
<a name="ln6535">  }</a>
<a name="ln6536"> </a>
<a name="ln6537">  rex.line = line;</a>
<a name="ln6538">  rex.lnum = 0;  // relative to line</a>
<a name="ln6539"> </a>
<a name="ln6540">  rex.nfa_has_zend = prog-&gt;has_zend;</a>
<a name="ln6541">  rex.nfa_has_backref = prog-&gt;has_backref;</a>
<a name="ln6542">  rex.nfa_nsubexpr = prog-&gt;nsubexp;</a>
<a name="ln6543">  rex.nfa_listid = 1;</a>
<a name="ln6544">  rex.nfa_alt_listid = 2;</a>
<a name="ln6545">#ifdef REGEXP_DEBUG</a>
<a name="ln6546">  nfa_regengine.expr = prog-&gt;pattern;</a>
<a name="ln6547">#endif</a>
<a name="ln6548"> </a>
<a name="ln6549">  if (prog-&gt;reganch &amp;&amp; col &gt; 0)</a>
<a name="ln6550">    return 0L;</a>
<a name="ln6551"> </a>
<a name="ln6552">  rex.need_clear_subexpr = true;</a>
<a name="ln6553">  // Clear the external match subpointers if necessary.</a>
<a name="ln6554">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6555">    rex.nfa_has_zsubexpr = true;</a>
<a name="ln6556">    rex.need_clear_zsubexpr = true;</a>
<a name="ln6557">  } else {</a>
<a name="ln6558">    rex.nfa_has_zsubexpr = false;</a>
<a name="ln6559">    rex.need_clear_zsubexpr = false;</a>
<a name="ln6560">  }</a>
<a name="ln6561"> </a>
<a name="ln6562">  if (prog-&gt;regstart != NUL) {</a>
<a name="ln6563">    /* Skip ahead until a character we know the match must start with.</a>
<a name="ln6564">     * When there is none there is no match. */</a>
<a name="ln6565">    if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL)</a>
<a name="ln6566">      return 0L;</a>
<a name="ln6567"> </a>
<a name="ln6568">    // If match_text is set it contains the full text that must match.</a>
<a name="ln6569">    // Nothing else to try. Doesn't handle combining chars well.</a>
<a name="ln6570">    if (prog-&gt;match_text != NULL &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6571">      return find_match_text(col, prog-&gt;regstart, prog-&gt;match_text);</a>
<a name="ln6572">    }</a>
<a name="ln6573">  }</a>
<a name="ln6574"> </a>
<a name="ln6575">  // If the start column is past the maximum column: no need to try.</a>
<a name="ln6576">  if (rex.reg_maxcol &gt; 0 &amp;&amp; col &gt;= rex.reg_maxcol) {</a>
<a name="ln6577">    goto theend;</a>
<a name="ln6578">  }</a>
<a name="ln6579"> </a>
<a name="ln6580">  // Set the &quot;nstate&quot; used by nfa_regcomp() to zero to trigger an error when</a>
<a name="ln6581">  // it's accidentally used during execution.</a>
<a name="ln6582">  nstate = 0;</a>
<a name="ln6583">  for (int i = 0; i &lt; prog-&gt;nstate; i++) {</a>
<a name="ln6584">    prog-&gt;state[i].id = i;</a>
<a name="ln6585">    prog-&gt;state[i].lastlist[0] = 0;</a>
<a name="ln6586">    prog-&gt;state[i].lastlist[1] = 0;</a>
<a name="ln6587">  }</a>
<a name="ln6588"> </a>
<a name="ln6589">  retval = nfa_regtry(prog, col, tm, timed_out);</a>
<a name="ln6590"> </a>
<a name="ln6591">#ifdef REGEXP_DEBUG</a>
<a name="ln6592">  nfa_regengine.expr = NULL;</a>
<a name="ln6593">#endif</a>
<a name="ln6594"> </a>
<a name="ln6595">theend:</a>
<a name="ln6596">  if (retval &gt; 0) {</a>
<a name="ln6597">    // Make sure the end is never before the start.  Can happen when \zs and</a>
<a name="ln6598">    // \ze are used.</a>
<a name="ln6599">    if (REG_MULTI) {</a>
<a name="ln6600">      const lpos_T *const start = &amp;rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6601">      const lpos_T *const end = &amp;rex.reg_mmatch-&gt;endpos[0];</a>
<a name="ln6602"> </a>
<a name="ln6603">      if (end-&gt;lnum &lt; start-&gt;lnum</a>
<a name="ln6604">          || (end-&gt;lnum == start-&gt;lnum &amp;&amp; end-&gt;col &lt; start-&gt;col)) {</a>
<a name="ln6605">        rex.reg_mmatch-&gt;endpos[0] = rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6606">      }</a>
<a name="ln6607">    } else {</a>
<a name="ln6608">      if (rex.reg_match-&gt;endp[0] &lt; rex.reg_match-&gt;startp[0]) {</a>
<a name="ln6609">        rex.reg_match-&gt;endp[0] = rex.reg_match-&gt;startp[0];</a>
<a name="ln6610">      }</a>
<a name="ln6611">    }</a>
<a name="ln6612">  }</a>
<a name="ln6613"> </a>
<a name="ln6614">  return retval;</a>
<a name="ln6615">}</a>
<a name="ln6616"> </a>
<a name="ln6617">/*</a>
<a name="ln6618"> * Compile a regular expression into internal code for the NFA matcher.</a>
<a name="ln6619"> * Returns the program in allocated space.  Returns NULL for an error.</a>
<a name="ln6620"> */</a>
<a name="ln6621">static regprog_T *nfa_regcomp(char_u *expr, int re_flags)</a>
<a name="ln6622">{</a>
<a name="ln6623">  nfa_regprog_T       *prog = NULL;</a>
<a name="ln6624">  int                 *postfix;</a>
<a name="ln6625"> </a>
<a name="ln6626">  if (expr == NULL)</a>
<a name="ln6627">    return NULL;</a>
<a name="ln6628"> </a>
<a name="ln6629">#ifdef REGEXP_DEBUG</a>
<a name="ln6630">  nfa_regengine.expr = expr;</a>
<a name="ln6631">#endif</a>
<a name="ln6632">  nfa_re_flags = re_flags;</a>
<a name="ln6633"> </a>
<a name="ln6634">  init_class_tab();</a>
<a name="ln6635"> </a>
<a name="ln6636">  nfa_regcomp_start(expr, re_flags);</a>
<a name="ln6637"> </a>
<a name="ln6638">  // Build postfix form of the regexp. Needed to build the NFA</a>
<a name="ln6639">  // (and count its size).</a>
<a name="ln6640">  postfix = re2post();</a>
<a name="ln6641">  if (postfix == NULL) {</a>
<a name="ln6642">    goto fail;              // Cascaded (syntax?) error</a>
<a name="ln6643">  }</a>
<a name="ln6644"> </a>
<a name="ln6645">  /*</a>
<a name="ln6646">   * In order to build the NFA, we parse the input regexp twice:</a>
<a name="ln6647">   * 1. first pass to count size (so we can allocate space)</a>
<a name="ln6648">   * 2. second to emit code</a>
<a name="ln6649">   */</a>
<a name="ln6650">#ifdef REGEXP_DEBUG</a>
<a name="ln6651">  {</a>
<a name="ln6652">    FILE *f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6653"> </a>
<a name="ln6654">    if (f != NULL) {</a>
<a name="ln6655">      fprintf(f,</a>
<a name="ln6656">              &quot;\n*****************************\n\n\n\n\t&quot;</a>
<a name="ln6657">              &quot;Compiling regexp \&quot;%s\&quot;... hold on !\n&quot;,</a>
<a name="ln6658">              expr);</a>
<a name="ln6659">      fclose(f);</a>
<a name="ln6660">    }</a>
<a name="ln6661">  }</a>
<a name="ln6662">#endif</a>
<a name="ln6663"> </a>
<a name="ln6664">  /*</a>
<a name="ln6665">   * PASS 1</a>
<a name="ln6666">   * Count number of NFA states in &quot;nstate&quot;. Do not build the NFA.</a>
<a name="ln6667">   */</a>
<a name="ln6668">  post2nfa(postfix, post_ptr, true);</a>
<a name="ln6669"> </a>
<a name="ln6670">  /* allocate the regprog with space for the compiled regexp */</a>
<a name="ln6671">  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);</a>
<a name="ln6672">  prog = xmalloc(prog_size);</a>
<a name="ln6673">  state_ptr = prog-&gt;state;</a>
<a name="ln6674">  prog-&gt;re_in_use = false;</a>
<a name="ln6675"> </a>
<a name="ln6676">  /*</a>
<a name="ln6677">   * PASS 2</a>
<a name="ln6678">   * Build the NFA</a>
<a name="ln6679">   */</a>
<a name="ln6680">  prog-&gt;start = post2nfa(postfix, post_ptr, false);</a>
<a name="ln6681">  if (prog-&gt;start == NULL) {</a>
<a name="ln6682">    goto fail;</a>
<a name="ln6683">  }</a>
<a name="ln6684">  prog-&gt;regflags = regflags;</a>
<a name="ln6685">  prog-&gt;engine = &amp;nfa_regengine;</a>
<a name="ln6686">  prog-&gt;nstate = nstate;</a>
<a name="ln6687">  prog-&gt;has_zend = rex.nfa_has_zend;</a>
<a name="ln6688">  prog-&gt;has_backref = rex.nfa_has_backref;</a>
<a name="ln6689">  prog-&gt;nsubexp = regnpar;</a>
<a name="ln6690"> </a>
<a name="ln6691">  nfa_postprocess(prog);</a>
<a name="ln6692"> </a>
<a name="ln6693">  prog-&gt;reganch = nfa_get_reganch(prog-&gt;start, 0);</a>
<a name="ln6694">  prog-&gt;regstart = nfa_get_regstart(prog-&gt;start, 0);</a>
<a name="ln6695">  prog-&gt;match_text = nfa_get_match_text(prog-&gt;start);</a>
<a name="ln6696"> </a>
<a name="ln6697">#ifdef REGEXP_DEBUG</a>
<a name="ln6698">  nfa_postfix_dump(expr, OK);</a>
<a name="ln6699">  nfa_dump(prog);</a>
<a name="ln6700">#endif</a>
<a name="ln6701">  /* Remember whether this pattern has any \z specials in it. */</a>
<a name="ln6702">  prog-&gt;reghasz = re_has_z;</a>
<a name="ln6703">  prog-&gt;pattern = vim_strsave(expr);</a>
<a name="ln6704">#ifdef REGEXP_DEBUG</a>
<a name="ln6705">  nfa_regengine.expr = NULL;</a>
<a name="ln6706">#endif</a>
<a name="ln6707"> </a>
<a name="ln6708">out:</a>
<a name="ln6709">  xfree(post_start);</a>
<a name="ln6710">  post_start = post_ptr = post_end = NULL;</a>
<a name="ln6711">  state_ptr = NULL;</a>
<a name="ln6712">  return (regprog_T *)prog;</a>
<a name="ln6713"> </a>
<a name="ln6714">fail:</a>
<a name="ln6715">  XFREE_CLEAR(prog);</a>
<a name="ln6716">#ifdef REGEXP_DEBUG</a>
<a name="ln6717">  nfa_postfix_dump(expr, FAIL);</a>
<a name="ln6718">  nfa_regengine.expr = NULL;</a>
<a name="ln6719">#endif</a>
<a name="ln6720">  goto out;</a>
<a name="ln6721">}</a>
<a name="ln6722"> </a>
<a name="ln6723">/*</a>
<a name="ln6724"> * Free a compiled regexp program, returned by nfa_regcomp().</a>
<a name="ln6725"> */</a>
<a name="ln6726">static void nfa_regfree(regprog_T *prog)</a>
<a name="ln6727">{</a>
<a name="ln6728">  if (prog != NULL) {</a>
<a name="ln6729">    xfree(((nfa_regprog_T *)prog)-&gt;match_text);</a>
<a name="ln6730">    xfree(((nfa_regprog_T *)prog)-&gt;pattern);</a>
<a name="ln6731">    xfree(prog);</a>
<a name="ln6732">  }</a>
<a name="ln6733">}</a>
<a name="ln6734"> </a>
<a name="ln6735">/*</a>
<a name="ln6736"> * Match a regexp against a string.</a>
<a name="ln6737"> * &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by nfa_regcomp().</a>
<a name="ln6738"> * Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6739"> * If &quot;line_lbr&quot; is true, consider a &quot;\n&quot; in &quot;line&quot; to be a line break.</a>
<a name="ln6740"> *</a>
<a name="ln6741"> * Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6742"> */</a>
<a name="ln6743">static int </a>
<a name="ln6744">nfa_regexec_nl (</a>
<a name="ln6745">    regmatch_T *rmp,</a>
<a name="ln6746">    char_u *line,      /* string to match against */</a>
<a name="ln6747">    colnr_T col,       /* column to start looking for match */</a>
<a name="ln6748">    bool line_lbr</a>
<a name="ln6749">)</a>
<a name="ln6750">{</a>
<a name="ln6751">  rex.reg_match = rmp;</a>
<a name="ln6752">  rex.reg_mmatch = NULL;</a>
<a name="ln6753">  rex.reg_maxline = 0;</a>
<a name="ln6754">  rex.reg_line_lbr = line_lbr;</a>
<a name="ln6755">  rex.reg_buf = curbuf;</a>
<a name="ln6756">  rex.reg_win = NULL;</a>
<a name="ln6757">  rex.reg_ic = rmp-&gt;rm_ic;</a>
<a name="ln6758">  rex.reg_icombine = false;</a>
<a name="ln6759">  rex.reg_maxcol = 0;</a>
<a name="ln6760">  return nfa_regexec_both(line, col, NULL, NULL);</a>
<a name="ln6761">}</a>
<a name="ln6762"> </a>
<a name="ln6763">/// Matches a regexp against multiple lines.</a>
<a name="ln6764">/// &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by vim_regcomp().</a>
<a name="ln6765">/// Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6766">///</a>
<a name="ln6767">/// @param win Window in which to search or NULL</a>
<a name="ln6768">/// @param buf Buffer in which to search</a>
<a name="ln6769">/// @param lnum Number of line to start looking for match</a>
<a name="ln6770">/// @param col Column to start looking for match</a>
<a name="ln6771">/// @param tm Timeout limit or NULL</a>
<a name="ln6772">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6773">///</a>
<a name="ln6774">/// @return &lt;= 0 if there is no match and number of lines contained in the match</a>
<a name="ln6775">/// otherwise.</a>
<a name="ln6776">///</a>
<a name="ln6777">/// @note The body is the same as bt_regexec() except for nfa_regexec_both()</a>
<a name="ln6778">///</a>
<a name="ln6779">/// @warning</a>
<a name="ln6780">/// Match may actually be in another line. e.g.:</a>
<a name="ln6781">/// when r.e. is \nc, cursor is at 'a' and the text buffer looks like</a>
<a name="ln6782">///</a>
<a name="ln6783">/// @par</a>
<a name="ln6784">///</a>
<a name="ln6785">///     +-------------------------+</a>
<a name="ln6786">///     |a                        |</a>
<a name="ln6787">///     |b                        |</a>
<a name="ln6788">///     |c                        |</a>
<a name="ln6789">///     |                         |</a>
<a name="ln6790">///     +-------------------------+</a>
<a name="ln6791">///</a>
<a name="ln6792">/// @par</a>
<a name="ln6793">/// then nfa_regexec_multi() returns 3. while the original vim_regexec_multi()</a>
<a name="ln6794">/// returns 0 and a second call at line 2 will return 2.</a>
<a name="ln6795">///</a>
<a name="ln6796">/// @par</a>
<a name="ln6797">/// FIXME if this behavior is not compatible.</a>
<a name="ln6798">static long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,</a>
<a name="ln6799">                              linenr_T lnum, colnr_T col,</a>
<a name="ln6800">                              proftime_T *tm, int *timed_out)</a>
<a name="ln6801">{</a>
<a name="ln6802">  rex.reg_match = NULL;</a>
<a name="ln6803">  rex.reg_mmatch = rmp;</a>
<a name="ln6804">  rex.reg_buf = buf;</a>
<a name="ln6805">  rex.reg_win = win;</a>
<a name="ln6806">  rex.reg_firstlnum = lnum;</a>
<a name="ln6807">  rex.reg_maxline = rex.reg_buf-&gt;b_ml.ml_line_count - lnum;</a>
<a name="ln6808">  rex.reg_line_lbr = false;</a>
<a name="ln6809">  rex.reg_ic = rmp-&gt;rmm_ic;</a>
<a name="ln6810">  rex.reg_icombine = false;</a>
<a name="ln6811">  rex.reg_maxcol = rmp-&gt;rmm_maxcol;</a>
<a name="ln6812"> </a>
<a name="ln6813">  return nfa_regexec_both(NULL, col, tm, timed_out);</a>
<a name="ln6814">}</a>

</code></pre>
<div class="balloon" rel="6168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pim->result' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

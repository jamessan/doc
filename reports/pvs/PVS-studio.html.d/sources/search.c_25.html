
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>search.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * search.c: code for normal mode searching commands</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;limits.h&gt;             /* for INT_MAX on MSVC */</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/search.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/charset.h&quot;</a>
<a name="ln19">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln20">#include &quot;nvim/edit.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln25">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln26">#include &quot;nvim/fold.h&quot;</a>
<a name="ln27">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln28">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln29">#include &quot;nvim/indent.h&quot;</a>
<a name="ln30">#include &quot;nvim/main.h&quot;</a>
<a name="ln31">#include &quot;nvim/mark.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/memline.h&quot;</a>
<a name="ln34">#include &quot;nvim/memory.h&quot;</a>
<a name="ln35">#include &quot;nvim/message.h&quot;</a>
<a name="ln36">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln37">#include &quot;nvim/move.h&quot;</a>
<a name="ln38">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln39">#include &quot;nvim/normal.h&quot;</a>
<a name="ln40">#include &quot;nvim/option.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln43">#include &quot;nvim/screen.h&quot;</a>
<a name="ln44">#include &quot;nvim/strings.h&quot;</a>
<a name="ln45">#include &quot;nvim/ui.h&quot;</a>
<a name="ln46">#include &quot;nvim/window.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln51"># include &quot;search.c.generated.h&quot;</a>
<a name="ln52">#endif</a>
<a name="ln53">/*</a>
<a name="ln54"> * This file contains various searching-related routines. These fall into</a>
<a name="ln55"> * three groups:</a>
<a name="ln56"> * 1. string searches (for /, ?, n, and N)</a>
<a name="ln57"> * 2. character searches within a single line (for f, F, t, T, etc)</a>
<a name="ln58"> * 3. &quot;other&quot; kinds of searches like the '%' command, and 'word' searches.</a>
<a name="ln59"> */</a>
<a name="ln60"> </a>
<a name="ln61">/*</a>
<a name="ln62"> * String searches</a>
<a name="ln63"> *</a>
<a name="ln64"> * The string search functions are divided into two levels:</a>
<a name="ln65"> * lowest:  searchit(); uses a pos_T for starting position and found match.</a>
<a name="ln66"> * Highest: do_search(); uses curwin-&gt;w_cursor; calls searchit().</a>
<a name="ln67"> *</a>
<a name="ln68"> * The last search pattern is remembered for repeating the same search.</a>
<a name="ln69"> * This pattern is shared between the :g, :s, ? and / commands.</a>
<a name="ln70"> * This is in search_regcomp().</a>
<a name="ln71"> *</a>
<a name="ln72"> * The actual string matching is done using a heavily modified version of</a>
<a name="ln73"> * Henry Spencer's regular expression library.  See regexp.c.</a>
<a name="ln74"> */</a>
<a name="ln75"> </a>
<a name="ln76">/*</a>
<a name="ln77"> * Two search patterns are remembered: One for the :substitute command and</a>
<a name="ln78"> * one for other searches.  last_idx points to the one that was used the last</a>
<a name="ln79"> * time.</a>
<a name="ln80"> */</a>
<a name="ln81">static struct spat spats[2] =</a>
<a name="ln82">{</a>
<a name="ln83">  // Last used search pattern</a>
<a name="ln84">  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},</a>
<a name="ln85">  // Last used substitute pattern</a>
<a name="ln86">  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">static int last_idx = 0;        /* index in spats[] for RE_LAST */</a>
<a name="ln90"> </a>
<a name="ln91">static char_u lastc[2] = { NUL, NUL };    // last character searched for</a>
<a name="ln92">static Direction lastcdir = FORWARD;      // last direction of character search</a>
<a name="ln93">static int last_t_cmd = true;             // last search t_cmd</a>
<a name="ln94">static char_u lastc_bytes[MB_MAXBYTES + 1];</a>
<a name="ln95">static int lastc_bytelen = 1;             // &gt;1 for multi-byte char</a>
<a name="ln96"> </a>
<a name="ln97">// copy of spats[], for keeping the search patterns while executing autocmds</a>
<a name="ln98">static struct spat saved_spats[2];</a>
<a name="ln99">static int saved_spats_last_idx = 0;</a>
<a name="ln100">static bool saved_spats_no_hlsearch = false;</a>
<a name="ln101"> </a>
<a name="ln102">static char_u       *mr_pattern = NULL;    // pattern used by search_regcomp()</a>
<a name="ln103">static int mr_pattern_alloced = false;     // mr_pattern was allocated</a>
<a name="ln104"> </a>
<a name="ln105">/*</a>
<a name="ln106"> * Type used by find_pattern_in_path() to remember which included files have</a>
<a name="ln107"> * been searched already.</a>
<a name="ln108"> */</a>
<a name="ln109">typedef struct SearchedFile {</a>
<a name="ln110">  FILE        *fp;              /* File pointer */</a>
<a name="ln111">  char_u      *name;            /* Full name of file */</a>
<a name="ln112">  linenr_T lnum;                /* Line we were up to in file */</a>
<a name="ln113">  int matched;                  /* Found a match in this file */</a>
<a name="ln114">} SearchedFile;</a>
<a name="ln115"> </a>
<a name="ln116">/*</a>
<a name="ln117"> * translate search pattern for vim_regcomp()</a>
<a name="ln118"> *</a>
<a name="ln119"> * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)</a>
<a name="ln120"> * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)</a>
<a name="ln121"> * pat_save == RE_BOTH: save pat in both patterns (:global command)</a>
<a name="ln122"> * pat_use  == RE_SEARCH: use previous search pattern if &quot;pat&quot; is NULL</a>
<a name="ln123"> * pat_use  == RE_SUBST: use previous substitute pattern if &quot;pat&quot; is NULL</a>
<a name="ln124"> * pat_use  == RE_LAST: use last used pattern if &quot;pat&quot; is NULL</a>
<a name="ln125"> * options &amp; SEARCH_HIS: put search string in history</a>
<a name="ln126"> * options &amp; SEARCH_KEEP: keep previous search pattern</a>
<a name="ln127"> *</a>
<a name="ln128"> * returns FAIL if failed, OK otherwise.</a>
<a name="ln129"> */</a>
<a name="ln130">int</a>
<a name="ln131">search_regcomp(</a>
<a name="ln132">    char_u *pat,</a>
<a name="ln133">    int pat_save,</a>
<a name="ln134">    int pat_use,</a>
<a name="ln135">    int options,</a>
<a name="ln136">    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */</a>
<a name="ln137">)</a>
<a name="ln138">{</a>
<a name="ln139">  int magic;</a>
<a name="ln140">  int i;</a>
<a name="ln141"> </a>
<a name="ln142">  rc_did_emsg = FALSE;</a>
<a name="ln143">  magic = p_magic;</a>
<a name="ln144"> </a>
<a name="ln145">  /*</a>
<a name="ln146">   * If no pattern given, use a previously defined pattern.</a>
<a name="ln147">   */</a>
<a name="ln148">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln149">    if (pat_use == RE_LAST)</a>
<a name="ln150">      i = last_idx;</a>
<a name="ln151">    else</a>
<a name="ln152">      i = pat_use;</a>
<a name="ln153">    if (spats[i].pat == NULL) {         /* pattern was never defined */</a>
<a name="ln154">      if (pat_use == RE_SUBST)</a>
<a name="ln155">        EMSG(_(e_nopresub));</a>
<a name="ln156">      else</a>
<a name="ln157">        EMSG(_(e_noprevre));</a>
<a name="ln158">      rc_did_emsg = TRUE;</a>
<a name="ln159">      return FAIL;</a>
<a name="ln160">    }</a>
<a name="ln161">    pat = spats[i].pat;</a>
<a name="ln162">    magic = spats[i].magic;</a>
<a name="ln163">    no_smartcase = spats[i].no_scs;</a>
<a name="ln164">  } else if (options &amp; SEARCH_HIS)      /* put new pattern in history */</a>
<a name="ln165">    add_to_history(HIST_SEARCH, pat, TRUE, NUL);</a>
<a name="ln166"> </a>
<a name="ln167">  if (mr_pattern_alloced) {</a>
<a name="ln168">    xfree(mr_pattern);</a>
<a name="ln169">    mr_pattern_alloced = FALSE;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln173">    mr_pattern = reverse_text(pat);</a>
<a name="ln174">    mr_pattern_alloced = TRUE;</a>
<a name="ln175">  } else</a>
<a name="ln176">    mr_pattern = pat;</a>
<a name="ln177"> </a>
<a name="ln178">  /*</a>
<a name="ln179">   * Save the currently used pattern in the appropriate place,</a>
<a name="ln180">   * unless the pattern should not be remembered.</a>
<a name="ln181">   */</a>
<a name="ln182">  if (!(options &amp; SEARCH_KEEP) &amp;&amp; !cmdmod.keeppatterns) {</a>
<a name="ln183">    /* search or global command */</a>
<a name="ln184">    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)</a>
<a name="ln185">      save_re_pat(RE_SEARCH, pat, magic);</a>
<a name="ln186">    /* substitute or global command */</a>
<a name="ln187">    if (pat_save == RE_SUBST || pat_save == RE_BOTH)</a>
<a name="ln188">      save_re_pat(RE_SUBST, pat, magic);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  regmatch-&gt;rmm_ic = ignorecase(pat);</a>
<a name="ln192">  regmatch-&gt;rmm_maxcol = 0;</a>
<a name="ln193">  regmatch-&gt;regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);</a>
<a name="ln194">  if (regmatch-&gt;regprog == NULL)</a>
<a name="ln195">    return FAIL;</a>
<a name="ln196">  return OK;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/*</a>
<a name="ln200"> * Get search pattern used by search_regcomp().</a>
<a name="ln201"> */</a>
<a name="ln202">char_u *get_search_pat(void)</a>
<a name="ln203">{</a>
<a name="ln204">  return mr_pattern;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">/*</a>
<a name="ln208"> * Reverse text into allocated memory.</a>
<a name="ln209"> * Returns the allocated string.</a>
<a name="ln210"> *</a>
<a name="ln211"> * TODO(philix): move reverse_text() to strings.c</a>
<a name="ln212"> */</a>
<a name="ln213">char_u *reverse_text(char_u *s) FUNC_ATTR_NONNULL_RET</a>
<a name="ln214">{</a>
<a name="ln215">  /*</a>
<a name="ln216">   * Reverse the pattern.</a>
<a name="ln217">   */</a>
<a name="ln218">  size_t len = STRLEN(s);</a>
<a name="ln219">  char_u *rev = xmalloc(len + 1);</a>
<a name="ln220">  size_t rev_i = len;</a>
<a name="ln221">  for (size_t s_i = 0; s_i &lt; len; s_i++) {</a>
<a name="ln222">    const int mb_len = utfc_ptr2len(s + s_i);</a>
<a name="ln223">    rev_i -= mb_len;</a>
<a name="ln224">    memmove(rev + rev_i, s + s_i, mb_len);</a>
<a name="ln225">    s_i += mb_len - 1;</a>
<a name="ln226">  }</a>
<a name="ln227">  rev[len] = NUL;</a>
<a name="ln228"> </a>
<a name="ln229">  return rev;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">void save_re_pat(int idx, char_u *pat, int magic)</a>
<a name="ln233">{</a>
<a name="ln234">  if (spats[idx].pat != pat) {</a>
<a name="ln235">    free_spat(&amp;spats[idx]);</a>
<a name="ln236">    spats[idx].pat = vim_strsave(pat);</a>
<a name="ln237">    spats[idx].magic = magic;</a>
<a name="ln238">    spats[idx].no_scs = no_smartcase;</a>
<a name="ln239">    spats[idx].timestamp = os_time();</a>
<a name="ln240">    spats[idx].additional_data = NULL;</a>
<a name="ln241">    last_idx = idx;</a>
<a name="ln242">    /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln243">    if (p_hls)</a>
<a name="ln244">      redraw_all_later(SOME_VALID);</a>
<a name="ln245">    set_no_hlsearch(false);</a>
<a name="ln246">  }</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/*</a>
<a name="ln250"> * Save the search patterns, so they can be restored later.</a>
<a name="ln251"> * Used before/after executing autocommands and user functions.</a>
<a name="ln252"> */</a>
<a name="ln253">static int save_level = 0;</a>
<a name="ln254"> </a>
<a name="ln255">void save_search_patterns(void)</a>
<a name="ln256">{</a>
<a name="ln257">  if (save_level++ == 0) {</a>
<a name="ln258">    saved_spats[0] = spats[0];</a>
<a name="ln259">    if (spats[0].pat != NULL)</a>
<a name="ln260">      saved_spats[0].pat = vim_strsave(spats[0].pat);</a>
<a name="ln261">    saved_spats[1] = spats[1];</a>
<a name="ln262">    if (spats[1].pat != NULL)</a>
<a name="ln263">      saved_spats[1].pat = vim_strsave(spats[1].pat);</a>
<a name="ln264">    saved_spats_last_idx = last_idx;</a>
<a name="ln265">    saved_spats_no_hlsearch = no_hlsearch;</a>
<a name="ln266">  }</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void restore_search_patterns(void)</a>
<a name="ln270">{</a>
<a name="ln271">  if (--save_level == 0) {</a>
<a name="ln272">    free_spat(&amp;spats[0]);</a>
<a name="ln273">    spats[0] = saved_spats[0];</a>
<a name="ln274">    set_vv_searchforward();</a>
<a name="ln275">    free_spat(&amp;spats[1]);</a>
<a name="ln276">    spats[1] = saved_spats[1];</a>
<a name="ln277">    last_idx = saved_spats_last_idx;</a>
<a name="ln278">    set_no_hlsearch(saved_spats_no_hlsearch);</a>
<a name="ln279">  }</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">static inline void free_spat(struct spat *const spat)</a>
<a name="ln283">{</a>
<a name="ln284">  xfree(spat-&gt;pat);</a>
<a name="ln285">  tv_dict_unref(spat-&gt;additional_data);</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">#if defined(EXITFREE)</a>
<a name="ln289">void free_search_patterns(void)</a>
<a name="ln290">{</a>
<a name="ln291">  free_spat(&amp;spats[0]);</a>
<a name="ln292">  free_spat(&amp;spats[1]);</a>
<a name="ln293"> </a>
<a name="ln294">  memset(spats, 0, sizeof(spats));</a>
<a name="ln295"> </a>
<a name="ln296">  if (mr_pattern_alloced) {</a>
<a name="ln297">    xfree(mr_pattern);</a>
<a name="ln298">    mr_pattern_alloced = FALSE;</a>
<a name="ln299">    mr_pattern = NULL;</a>
<a name="ln300">  }</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">#endif</a>
<a name="ln304"> </a>
<a name="ln305">// copy of spats[RE_SEARCH], for keeping the search patterns while incremental</a>
<a name="ln306">// searching</a>
<a name="ln307">static struct spat saved_last_search_spat;</a>
<a name="ln308">static int did_save_last_search_spat = 0;</a>
<a name="ln309">static int saved_last_idx = 0;</a>
<a name="ln310">static bool saved_no_hlsearch = false;</a>
<a name="ln311"> </a>
<a name="ln312">/// Save and restore the search pattern for incremental highlight search</a>
<a name="ln313">/// feature.</a>
<a name="ln314">///</a>
<a name="ln315">/// It's similar to but different from save_search_patterns() and</a>
<a name="ln316">/// restore_search_patterns(), because the search pattern must be restored when</a>
<a name="ln317">/// cancelling incremental searching even if it's called inside user functions.</a>
<a name="ln318">void save_last_search_pattern(void)</a>
<a name="ln319">{</a>
<a name="ln320">  if (++did_save_last_search_spat != 1) {</a>
<a name="ln321">    // nested call, nothing to do</a>
<a name="ln322">    return;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  saved_last_search_spat = spats[RE_SEARCH];</a>
<a name="ln326">  if (spats[RE_SEARCH].pat != NULL) {</a>
<a name="ln327">    saved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);</a>
<a name="ln328">  }</a>
<a name="ln329">  saved_last_idx = last_idx;</a>
<a name="ln330">  saved_no_hlsearch = no_hlsearch;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">void restore_last_search_pattern(void)</a>
<a name="ln334">{</a>
<a name="ln335">  if (--did_save_last_search_spat &gt; 0) {</a>
<a name="ln336">    // nested call, nothing to do</a>
<a name="ln337">    return;</a>
<a name="ln338">  }</a>
<a name="ln339">  if (did_save_last_search_spat != 0) {</a>
<a name="ln340">    iemsg(&quot;restore_last_search_pattern() called more often than&quot;</a>
<a name="ln341">          &quot; save_last_search_pattern()&quot;);</a>
<a name="ln342">    return;</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  xfree(spats[RE_SEARCH].pat);</a>
<a name="ln346">  spats[RE_SEARCH] = saved_last_search_spat;</a>
<a name="ln347">  saved_last_search_spat.pat = NULL;</a>
<a name="ln348">  set_vv_searchforward();</a>
<a name="ln349">  last_idx = saved_last_idx;</a>
<a name="ln350">  set_no_hlsearch(saved_no_hlsearch);</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">char_u *last_search_pattern(void)</a>
<a name="ln354">{</a>
<a name="ln355">  return spats[RE_SEARCH].pat;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">/*</a>
<a name="ln359"> * Return TRUE when case should be ignored for search pattern &quot;pat&quot;.</a>
<a name="ln360"> * Uses the 'ignorecase' and 'smartcase' options.</a>
<a name="ln361"> */</a>
<a name="ln362">int ignorecase(char_u *pat)</a>
<a name="ln363">{</a>
<a name="ln364">  return ignorecase_opt(pat, p_ic, p_scs);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">/// As ignorecase() put pass the &quot;ic&quot; and &quot;scs&quot; flags.</a>
<a name="ln368">int ignorecase_opt(char_u *pat, int ic_in, int scs)</a>
<a name="ln369">{</a>
<a name="ln370">  int ic = ic_in;</a>
<a name="ln371">  if (ic &amp;&amp; !no_smartcase &amp;&amp; scs</a>
<a name="ln372">      &amp;&amp; !(ctrl_x_mode_not_default() &amp;&amp; curbuf-&gt;b_p_inf)</a>
<a name="ln373">      ) {</a>
<a name="ln374">    ic = !pat_has_uppercase(pat);</a>
<a name="ln375">  }</a>
<a name="ln376">  no_smartcase = false;</a>
<a name="ln377"> </a>
<a name="ln378">  return ic;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">/// Returns true if pattern `pat` has an uppercase character.</a>
<a name="ln382">bool pat_has_uppercase(char_u *pat)</a>
<a name="ln383">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln384">{</a>
<a name="ln385">  char_u *p = pat;</a>
<a name="ln386"> </a>
<a name="ln387">  while (*p != NUL) {</a>
<a name="ln388">    const int l = mb_ptr2len(p);</a>
<a name="ln389"> </a>
<a name="ln390">    if (l &gt; 1) {</a>
<a name="ln391">      if (mb_isupper(utf_ptr2char(p))) {</a>
<a name="ln392">        return true;</a>
<a name="ln393">      }</a>
<a name="ln394">      p += l;</a>
<a name="ln395">    } else if (*p == '\\') {</a>
<a name="ln396">      if (p[1] == '_' &amp;&amp; p[2] != NUL) {  // skip &quot;\_X&quot;</a>
<a name="ln397">        p += 3;</a>
<a name="ln398">      } else if (p[1] == '%' &amp;&amp; p[2] != NUL) {  // skip &quot;\%X&quot;</a>
<a name="ln399">        p += 3;</a>
<a name="ln400">      } else if (p[1] != NUL) {  // skip &quot;\X&quot;</a>
<a name="ln401">        p += 2;</a>
<a name="ln402">      } else {</a>
<a name="ln403">        p += 1;</a>
<a name="ln404">      }</a>
<a name="ln405">    } else if (mb_isupper(*p)) {</a>
<a name="ln406">      return true;</a>
<a name="ln407">    } else {</a>
<a name="ln408">      p++;</a>
<a name="ln409">    }</a>
<a name="ln410">  }</a>
<a name="ln411">  return false;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">const char *last_csearch(void)</a>
<a name="ln415">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln416">{</a>
<a name="ln417">  return (const char *)lastc_bytes;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">int last_csearch_forward(void)</a>
<a name="ln421">{</a>
<a name="ln422">  return lastcdir == FORWARD;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">int last_csearch_until(void)</a>
<a name="ln426">{</a>
<a name="ln427">  return last_t_cmd == TRUE;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">void set_last_csearch(int c, char_u *s, int len)</a>
<a name="ln431">{</a>
<a name="ln432">  *lastc = c;</a>
<a name="ln433">  lastc_bytelen = len;</a>
<a name="ln434">  if (len)</a>
<a name="ln435">    memcpy(lastc_bytes, s, len);</a>
<a name="ln436">  else</a>
<a name="ln437">    memset(lastc_bytes, 0, sizeof(lastc_bytes));</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">void set_csearch_direction(Direction cdir)</a>
<a name="ln441">{</a>
<a name="ln442">  lastcdir = cdir;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">void set_csearch_until(int t_cmd)</a>
<a name="ln446">{</a>
<a name="ln447">  last_t_cmd = t_cmd;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">char_u *last_search_pat(void)</a>
<a name="ln451">{</a>
<a name="ln452">  return spats[last_idx].pat;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">/*</a>
<a name="ln456"> * Reset search direction to forward.  For &quot;gd&quot; and &quot;gD&quot; commands.</a>
<a name="ln457"> */</a>
<a name="ln458">void reset_search_dir(void)</a>
<a name="ln459">{</a>
<a name="ln460">  spats[0].off.dir = '/';</a>
<a name="ln461">  set_vv_searchforward();</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">/*</a>
<a name="ln465"> * Set the last search pattern.  For &quot;:let @/ =&quot; and ShaDa file.</a>
<a name="ln466"> * Also set the saved search pattern, so that this works in an autocommand.</a>
<a name="ln467"> */</a>
<a name="ln468">void set_last_search_pat(const char_u *s, int idx, int magic, int setlast)</a>
<a name="ln469">{</a>
<a name="ln470">  free_spat(&amp;spats[idx]);</a>
<a name="ln471">  /* An empty string means that nothing should be matched. */</a>
<a name="ln472">  if (*s == NUL)</a>
<a name="ln473">    spats[idx].pat = NULL;</a>
<a name="ln474">  else</a>
<a name="ln475">    spats[idx].pat = (char_u *) xstrdup((char *) s);</a>
<a name="ln476">  spats[idx].timestamp = os_time();</a>
<a name="ln477">  spats[idx].additional_data = NULL;</a>
<a name="ln478">  spats[idx].magic = magic;</a>
<a name="ln479">  spats[idx].no_scs = FALSE;</a>
<a name="ln480">  spats[idx].off.dir = '/';</a>
<a name="ln481">  set_vv_searchforward();</a>
<a name="ln482">  spats[idx].off.line = FALSE;</a>
<a name="ln483">  spats[idx].off.end = FALSE;</a>
<a name="ln484">  spats[idx].off.off = 0;</a>
<a name="ln485">  if (setlast)</a>
<a name="ln486">    last_idx = idx;</a>
<a name="ln487">  if (save_level) {</a>
<a name="ln488">    free_spat(&amp;saved_spats[idx]);</a>
<a name="ln489">    saved_spats[idx] = spats[0];</a>
<a name="ln490">    if (spats[idx].pat == NULL)</a>
<a name="ln491">      saved_spats[idx].pat = NULL;</a>
<a name="ln492">    else</a>
<a name="ln493">      saved_spats[idx].pat = vim_strsave(spats[idx].pat);</a>
<a name="ln494">    saved_spats_last_idx = last_idx;</a>
<a name="ln495">  }</a>
<a name="ln496">  /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln497">  if (p_hls &amp;&amp; idx == last_idx &amp;&amp; !no_hlsearch)</a>
<a name="ln498">    redraw_all_later(SOME_VALID);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">/*</a>
<a name="ln502"> * Get a regexp program for the last used search pattern.</a>
<a name="ln503"> * This is used for highlighting all matches in a window.</a>
<a name="ln504"> * Values returned in regmatch-&gt;regprog and regmatch-&gt;rmm_ic.</a>
<a name="ln505"> */</a>
<a name="ln506">void last_pat_prog(regmmatch_T *regmatch)</a>
<a name="ln507">{</a>
<a name="ln508">  if (spats[last_idx].pat == NULL) {</a>
<a name="ln509">    regmatch-&gt;regprog = NULL;</a>
<a name="ln510">    return;</a>
<a name="ln511">  }</a>
<a name="ln512">  ++emsg_off;           /* So it doesn't beep if bad expr */</a>
<a name="ln513">  (void)search_regcomp((char_u *)&quot;&quot;, 0, last_idx, SEARCH_KEEP, regmatch);</a>
<a name="ln514">  --emsg_off;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">/// lowest level search function.</a>
<a name="ln518">/// Search for 'count'th occurrence of pattern &quot;pat&quot; in direction &quot;dir&quot;.</a>
<a name="ln519">/// Start at position &quot;pos&quot; and return the found position in &quot;pos&quot;.</a>
<a name="ln520">///</a>
<a name="ln521">/// if (options &amp; SEARCH_MSG) == 0 don't give any messages</a>
<a name="ln522">/// if (options &amp; SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages</a>
<a name="ln523">/// if (options &amp; SEARCH_MSG) == SEARCH_MSG give all messages</a>
<a name="ln524">/// if (options &amp; SEARCH_HIS) put search pattern in history</a>
<a name="ln525">/// if (options &amp; SEARCH_END) return position at end of match</a>
<a name="ln526">/// if (options &amp; SEARCH_START) accept match at pos itself</a>
<a name="ln527">/// if (options &amp; SEARCH_KEEP) keep previous search pattern</a>
<a name="ln528">/// if (options &amp; SEARCH_FOLD) match only once in a closed fold</a>
<a name="ln529">/// if (options &amp; SEARCH_PEEK) check for typed char, cancel search</a>
<a name="ln530">/// if (options &amp; SEARCH_COL) start at pos-&gt;col instead of zero</a>
<a name="ln531">///</a>
<a name="ln532">/// @returns FAIL (zero) for failure, non-zero for success.</a>
<a name="ln533">///          the index of the first matching</a>
<a name="ln534">///          subpattern plus one; one if there was none.</a>
<a name="ln535">int searchit(</a>
<a name="ln536">    win_T       *win,          // window to search in; can be NULL for a</a>
<a name="ln537">                               // buffer without a window!</a>
<a name="ln538">    buf_T       *buf,</a>
<a name="ln539">    pos_T       *pos,</a>
<a name="ln540">    pos_T       *end_pos,      // set to end of the match, unless NULL</a>
<a name="ln541">    Direction dir,</a>
<a name="ln542">    char_u      *pat,</a>
<a name="ln543">    long count,</a>
<a name="ln544">    int options,</a>
<a name="ln545">    int pat_use,               // which pattern to use when &quot;pat&quot; is empty</a>
<a name="ln546">    searchit_arg_T *extra_arg  // optional extra arguments, can be NULL</a>
<a name="ln547">)</a>
<a name="ln548">{</a>
<a name="ln549">  int found;</a>
<a name="ln550">  linenr_T lnum;                /* no init to shut up Apollo cc */</a>
<a name="ln551">  regmmatch_T regmatch;</a>
<a name="ln552">  char_u      *ptr;</a>
<a name="ln553">  colnr_T matchcol;</a>
<a name="ln554">  lpos_T endpos;</a>
<a name="ln555">  lpos_T matchpos;</a>
<a name="ln556">  int loop;</a>
<a name="ln557">  pos_T start_pos;</a>
<a name="ln558">  int at_first_line;</a>
<a name="ln559">  int extra_col;</a>
<a name="ln560">  int start_char_len;</a>
<a name="ln561">  int match_ok;</a>
<a name="ln562">  long nmatched;</a>
<a name="ln563">  int submatch = 0;</a>
<a name="ln564">  bool first_match = true;</a>
<a name="ln565">  int save_called_emsg = called_emsg;</a>
<a name="ln566">  int break_loop = false;</a>
<a name="ln567">  linenr_T stop_lnum = 0;  // stop after this line number when != 0</a>
<a name="ln568">  proftime_T *tm = NULL;   // timeout limit or NULL</a>
<a name="ln569">  int *timed_out = NULL;   // set when timed out or NULL</a>
<a name="ln570"> </a>
<a name="ln571">  if (extra_arg != NULL) {</a>
<a name="ln572">      stop_lnum = extra_arg-&gt;sa_stop_lnum;</a>
<a name="ln573">      tm = extra_arg-&gt;sa_tm;</a>
<a name="ln574">      timed_out = &amp;extra_arg-&gt;sa_timed_out;</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  if (search_regcomp(pat, RE_SEARCH, pat_use,</a>
<a name="ln578">          (options &amp; (SEARCH_HIS + SEARCH_KEEP)), &amp;regmatch) == FAIL) {</a>
<a name="ln579">    if ((options &amp; SEARCH_MSG) &amp;&amp; !rc_did_emsg)</a>
<a name="ln580">      EMSG2(_(&quot;E383: Invalid search string: %s&quot;), mr_pattern);</a>
<a name="ln581">    return FAIL;</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  /*</a>
<a name="ln585">   * find the string</a>
<a name="ln586">   */</a>
<a name="ln587">  called_emsg = FALSE;</a>
<a name="ln588">  do {  /* loop for count */</a>
<a name="ln589">    // When not accepting a match at the start position set &quot;extra_col&quot; to a</a>
<a name="ln590">    // non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL + 1</a>
<a name="ln591">    // is zero.</a>
<a name="ln592">    if (pos-&gt;col == MAXCOL) {</a>
<a name="ln593">      start_char_len = 0;</a>
<a name="ln594">    } else if (pos-&gt;lnum &gt;= 1</a>
<a name="ln595">               &amp;&amp; pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count</a>
<a name="ln596">               &amp;&amp; pos-&gt;col &lt; MAXCOL - 2) {</a>
<a name="ln597">      // Watch out for the &quot;col&quot; being MAXCOL - 2, used in a closed fold.</a>
<a name="ln598">      ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln599">      if ((int)STRLEN(ptr) &lt;= pos-&gt;col) {</a>
<a name="ln600">        start_char_len = 1;</a>
<a name="ln601">      } else {</a>
<a name="ln602">        start_char_len = utfc_ptr2len(ptr + pos-&gt;col);</a>
<a name="ln603">      }</a>
<a name="ln604">    } else {</a>
<a name="ln605">      start_char_len = 1;</a>
<a name="ln606">    }</a>
<a name="ln607">    if (dir == FORWARD) {</a>
<a name="ln608">      extra_col = (options &amp; SEARCH_START) ? 0 : start_char_len;</a>
<a name="ln609">    } else {</a>
<a name="ln610">      extra_col = (options &amp; SEARCH_START) ? start_char_len : 0;</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">    start_pos = *pos;           /* remember start pos for detecting no match */</a>
<a name="ln614">    found = 0;                  /* default: not found */</a>
<a name="ln615">    at_first_line = TRUE;       /* default: start in first line */</a>
<a name="ln616">    if (pos-&gt;lnum == 0) {       /* correct lnum for when starting in line 0 */</a>
<a name="ln617">      pos-&gt;lnum = 1;</a>
<a name="ln618">      pos-&gt;col = 0;</a>
<a name="ln619">      at_first_line = FALSE;        /* not in first line now */</a>
<a name="ln620">    }</a>
<a name="ln621"> </a>
<a name="ln622">    /*</a>
<a name="ln623">     * Start searching in current line, unless searching backwards and</a>
<a name="ln624">     * we're in column 0.</a>
<a name="ln625">     * If we are searching backwards, in column 0, and not including the</a>
<a name="ln626">     * current position, gain some efficiency by skipping back a line.</a>
<a name="ln627">     * Otherwise begin the search in the current line.</a>
<a name="ln628">     */</a>
<a name="ln629">    if (dir == BACKWARD &amp;&amp; start_pos.col == 0</a>
<a name="ln630">        &amp;&amp; (options &amp; SEARCH_START) == 0) {</a>
<a name="ln631">      lnum = pos-&gt;lnum - 1;</a>
<a name="ln632">      at_first_line = FALSE;</a>
<a name="ln633">    } else</a>
<a name="ln634">      lnum = pos-&gt;lnum;</a>
<a name="ln635"> </a>
<a name="ln636">    for (loop = 0; loop &lt;= 1; ++loop) {     /* loop twice if 'wrapscan' set */</a>
<a name="ln637">      for (; lnum &gt; 0 &amp;&amp; lnum &lt;= buf-&gt;b_ml.ml_line_count;</a>
<a name="ln638">           lnum += dir, at_first_line = FALSE) {</a>
<a name="ln639">        /* Stop after checking &quot;stop_lnum&quot;, if it's set. */</a>
<a name="ln640">        if (stop_lnum != 0 &amp;&amp; (dir == FORWARD</a>
<a name="ln641">                               ? lnum &gt; stop_lnum : lnum &lt; stop_lnum))</a>
<a name="ln642">          break;</a>
<a name="ln643">        /* Stop after passing the &quot;tm&quot; time limit. */</a>
<a name="ln644">        if (tm != NULL &amp;&amp; profile_passed_limit(*tm))</a>
<a name="ln645">          break;</a>
<a name="ln646"> </a>
<a name="ln647">        // Look for a match somewhere in line &quot;lnum&quot;.</a>
<a name="ln648">        colnr_T col = at_first_line &amp;&amp; (options &amp; SEARCH_COL) ? pos-&gt;col : 0;</a>
<a name="ln649">        nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln650">                                     lnum, col, tm, timed_out);</a>
<a name="ln651">        // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln652">        if (regmatch.regprog == NULL) {</a>
<a name="ln653">          break;</a>
<a name="ln654">        }</a>
<a name="ln655">        // Abort searching on an error (e.g., out of stack).</a>
<a name="ln656">        if (called_emsg || (timed_out != NULL &amp;&amp; *timed_out)) {</a>
<a name="ln657">          break;</a>
<a name="ln658">        }</a>
<a name="ln659">        if (nmatched &gt; 0) {</a>
<a name="ln660">          /* match may actually be in another line when using \zs */</a>
<a name="ln661">          matchpos = regmatch.startpos[0];</a>
<a name="ln662">          endpos = regmatch.endpos[0];</a>
<a name="ln663">          submatch = first_submatch(&amp;regmatch);</a>
<a name="ln664">          /* &quot;lnum&quot; may be past end of buffer for &quot;\n\zs&quot;. */</a>
<a name="ln665">          if (lnum + matchpos.lnum &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln666">            ptr = (char_u *)&quot;&quot;;</a>
<a name="ln667">          else</a>
<a name="ln668">            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);</a>
<a name="ln669"> </a>
<a name="ln670">          /*</a>
<a name="ln671">           * Forward search in the first line: match should be after</a>
<a name="ln672">           * the start position. If not, continue at the end of the</a>
<a name="ln673">           * match (this is vi compatible) or on the next char.</a>
<a name="ln674">           */</a>
<a name="ln675">          if (dir == FORWARD &amp;&amp; at_first_line) {</a>
<a name="ln676">            match_ok = TRUE;</a>
<a name="ln677">            /*</a>
<a name="ln678">             * When the match starts in a next line it's certainly</a>
<a name="ln679">             * past the start position.</a>
<a name="ln680">             * When match lands on a NUL the cursor will be put</a>
<a name="ln681">             * one back afterwards, compare with that position,</a>
<a name="ln682">             * otherwise &quot;/$&quot; will get stuck on end of line.</a>
<a name="ln683">             */</a>
<a name="ln684">            while (matchpos.lnum == 0</a>
<a name="ln685">                   &amp;&amp; (((options &amp; SEARCH_END) &amp;&amp; first_match)</a>
<a name="ln686">                       ?  (nmatched == 1</a>
<a name="ln687">                           &amp;&amp; (int)endpos.col - 1</a>
<a name="ln688">                           &lt; (int)start_pos.col + extra_col)</a>
<a name="ln689">                       : ((int)matchpos.col</a>
<a name="ln690">                          - (ptr[matchpos.col] == NUL)</a>
<a name="ln691">                          &lt; (int)start_pos.col + extra_col))) {</a>
<a name="ln692">              /*</a>
<a name="ln693">               * If vi-compatible searching, continue at the end</a>
<a name="ln694">               * of the match, otherwise continue one position</a>
<a name="ln695">               * forward.</a>
<a name="ln696">               */</a>
<a name="ln697">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln698">                if (nmatched &gt; 1) {</a>
<a name="ln699">                  /* end is in next line, thus no match in</a>
<a name="ln700">                   * this line */</a>
<a name="ln701">                  match_ok = FALSE;</a>
<a name="ln702">                  break;</a>
<a name="ln703">                }</a>
<a name="ln704">                matchcol = endpos.col;</a>
<a name="ln705">                // for empty match (matchcol == matchpos.col): advance one char</a>
<a name="ln706">              } else {</a>
<a name="ln707">                // Prepare to start after first matched character.</a>
<a name="ln708">                matchcol = matchpos.col;</a>
<a name="ln709">              }</a>
<a name="ln710"> </a>
<a name="ln711">              if (matchcol == matchpos.col &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln712">                matchcol += utfc_ptr2len(ptr + matchcol);</a>
<a name="ln713">              }</a>
<a name="ln714"> </a>
<a name="ln715">              if (matchcol == 0 &amp;&amp; (options &amp; SEARCH_START)) {</a>
<a name="ln716">                break;</a>
<a name="ln717">              }</a>
<a name="ln718"> </a>
<a name="ln719">              if (ptr[matchcol] == NUL</a>
<a name="ln720">                  || (nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln721">                                                   lnum, matchcol, tm,</a>
<a name="ln722">                                                   timed_out)) == 0) {</a>
<a name="ln723">                match_ok = false;</a>
<a name="ln724">                break;</a>
<a name="ln725">              }</a>
<a name="ln726">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln727">              if (regmatch.regprog == NULL) {</a>
<a name="ln728">                break;</a>
<a name="ln729">              }</a>
<a name="ln730">              matchpos = regmatch.startpos[0];</a>
<a name="ln731">              endpos = regmatch.endpos[0];</a>
<a name="ln732">              submatch = first_submatch(&amp;regmatch);</a>
<a name="ln733"> </a>
<a name="ln734">              // This while-loop only works with matchpos.lnum == 0.</a>
<a name="ln735">              // For bigger values the next line pointer ptr might not be a</a>
<a name="ln736">              // buffer line.</a>
<a name="ln737">              if (matchpos.lnum != 0) {</a>
<a name="ln738">                break;</a>
<a name="ln739">              }</a>
<a name="ln740">              // Need to get the line pointer again, a multi-line search may</a>
<a name="ln741">              // have made it invalid.</a>
<a name="ln742">              ptr = ml_get_buf(buf, lnum, false);</a>
<a name="ln743">            }</a>
<a name="ln744">            if (!match_ok)</a>
<a name="ln745">              continue;</a>
<a name="ln746">          }</a>
<a name="ln747">          if (dir == BACKWARD) {</a>
<a name="ln748">            /*</a>
<a name="ln749">             * Now, if there are multiple matches on this line,</a>
<a name="ln750">             * we have to get the last one. Or the last one before</a>
<a name="ln751">             * the cursor, if we're on that line.</a>
<a name="ln752">             * When putting the new cursor at the end, compare</a>
<a name="ln753">             * relative to the end of the match.</a>
<a name="ln754">             */</a>
<a name="ln755">            match_ok = FALSE;</a>
<a name="ln756">            for (;; ) {</a>
<a name="ln757">              /* Remember a position that is before the start</a>
<a name="ln758">               * position, we use it if it's the last match in</a>
<a name="ln759">               * the line.  Always accept a position after</a>
<a name="ln760">               * wrapping around. */</a>
<a name="ln761">              if (loop</a>
<a name="ln762">                  || ((options &amp; SEARCH_END)</a>
<a name="ln763">                      ? (lnum + regmatch.endpos[0].lnum</a>
<a name="ln764">                         &lt; start_pos.lnum</a>
<a name="ln765">                         || (lnum + regmatch.endpos[0].lnum</a>
<a name="ln766">                             == start_pos.lnum</a>
<a name="ln767">                             &amp;&amp; (int)regmatch.endpos[0].col - 1</a>
<a name="ln768">                             &lt; (int)start_pos.col + extra_col))</a>
<a name="ln769">                      : (lnum + regmatch.startpos[0].lnum</a>
<a name="ln770">                         &lt; start_pos.lnum</a>
<a name="ln771">                         || (lnum + regmatch.startpos[0].lnum</a>
<a name="ln772">                             == start_pos.lnum</a>
<a name="ln773">                             &amp;&amp; (int)regmatch.startpos[0].col</a>
<a name="ln774">                             &lt; (int)start_pos.col + extra_col)))) {</a>
<a name="ln775">                match_ok = true;</a>
<a name="ln776">                matchpos = regmatch.startpos[0];</a>
<a name="ln777">                endpos = regmatch.endpos[0];</a>
<a name="ln778">                submatch = first_submatch(&amp;regmatch);</a>
<a name="ln779">              } else</a>
<a name="ln780">                break;</a>
<a name="ln781"> </a>
<a name="ln782">              // We found a valid match, now check if there is</a>
<a name="ln783">              // another one after it.</a>
<a name="ln784">              // If vi-compatible searching, continue at the end</a>
<a name="ln785">              // of the match, otherwise continue one position</a>
<a name="ln786">              // forward.</a>
<a name="ln787">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln788">                if (nmatched &gt; 1) {</a>
<a name="ln789">                  break;</a>
<a name="ln790">                }</a>
<a name="ln791">                matchcol = endpos.col;</a>
<a name="ln792">                // for empty match: advance one char</a>
<a name="ln793">                if (matchcol == matchpos.col</a>
<a name="ln794">                    &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln795">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln796">                }</a>
<a name="ln797">              } else {</a>
<a name="ln798">                // Stop when the match is in a next line.</a>
<a name="ln799">                if (matchpos.lnum &gt; 0) {</a>
<a name="ln800">                  break;</a>
<a name="ln801">                }</a>
<a name="ln802">                matchcol = matchpos.col;</a>
<a name="ln803">                if (ptr[matchcol] != NUL) {</a>
<a name="ln804">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln805">                }</a>
<a name="ln806">              }</a>
<a name="ln807">              if (ptr[matchcol] == NUL</a>
<a name="ln808">                  || (nmatched = vim_regexec_multi(</a>
<a name="ln809">                      &amp;regmatch, win, buf, lnum + matchpos.lnum, matchcol,</a>
<a name="ln810">                      tm, timed_out)) == 0) {</a>
<a name="ln811">                  // If the search timed out, we did find a match</a>
<a name="ln812">                  // but it might be the wrong one, so that's not</a>
<a name="ln813">                  // OK.</a>
<a name="ln814">                  if (tm != NULL &amp;&amp; profile_passed_limit(*tm)) {</a>
<a name="ln815">                      match_ok = false;</a>
<a name="ln816">                  }</a>
<a name="ln817">                  break;</a>
<a name="ln818">              }</a>
<a name="ln819">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln820">              if (regmatch.regprog == NULL) {</a>
<a name="ln821">                break;</a>
<a name="ln822">              }</a>
<a name="ln823">              // Need to get the line pointer again, a</a>
<a name="ln824">              // multi-line search may have made it invalid.</a>
<a name="ln825">              ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);</a>
<a name="ln826">            }</a>
<a name="ln827"> </a>
<a name="ln828">            /*</a>
<a name="ln829">             * If there is only a match after the cursor, skip</a>
<a name="ln830">             * this match.</a>
<a name="ln831">             */</a>
<a name="ln832">            if (!match_ok)</a>
<a name="ln833">              continue;</a>
<a name="ln834">          }</a>
<a name="ln835"> </a>
<a name="ln836">          /* With the SEARCH_END option move to the last character</a>
<a name="ln837">           * of the match.  Don't do it for an empty match, end</a>
<a name="ln838">           * should be same as start then. */</a>
<a name="ln839">          if ((options &amp; SEARCH_END) &amp;&amp; !(options &amp; SEARCH_NOOF)</a>
<a name="ln840">              &amp;&amp; !(matchpos.lnum == endpos.lnum</a>
<a name="ln841">                   &amp;&amp; matchpos.col == endpos.col)) {</a>
<a name="ln842">            /* For a match in the first column, set the position</a>
<a name="ln843">             * on the NUL in the previous line. */</a>
<a name="ln844">            pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln845">            pos-&gt;col = endpos.col;</a>
<a name="ln846">            if (endpos.col == 0) {</a>
<a name="ln847">              if (pos-&gt;lnum &gt; 1) {              /* just in case */</a>
<a name="ln848">                --pos-&gt;lnum;</a>
<a name="ln849">                pos-&gt;col = (colnr_T)STRLEN(ml_get_buf(buf,</a>
<a name="ln850">                        pos-&gt;lnum, FALSE));</a>
<a name="ln851">              }</a>
<a name="ln852">            } else {</a>
<a name="ln853">              pos-&gt;col--;</a>
<a name="ln854">              if (pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln855">                ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln856">                pos-&gt;col -= utf_head_off(ptr, ptr + pos-&gt;col);</a>
<a name="ln857">              }</a>
<a name="ln858">            }</a>
<a name="ln859">            if (end_pos != NULL) {</a>
<a name="ln860">              end_pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln861">              end_pos-&gt;col = matchpos.col;</a>
<a name="ln862">            }</a>
<a name="ln863">          } else {</a>
<a name="ln864">            pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln865">            pos-&gt;col = matchpos.col;</a>
<a name="ln866">            if (end_pos != NULL) {</a>
<a name="ln867">              end_pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln868">              end_pos-&gt;col = endpos.col;</a>
<a name="ln869">            }</a>
<a name="ln870">          }</a>
<a name="ln871">          pos-&gt;coladd = 0;</a>
<a name="ln872">          if (end_pos != NULL) {</a>
<a name="ln873">            end_pos-&gt;coladd = 0;</a>
<a name="ln874">          }</a>
<a name="ln875">          found = 1;</a>
<a name="ln876">          first_match = false;</a>
<a name="ln877"> </a>
<a name="ln878">          /* Set variables used for 'incsearch' highlighting. */</a>
<a name="ln879">          search_match_lines = endpos.lnum - matchpos.lnum;</a>
<a name="ln880">          search_match_endcol = endpos.col;</a>
<a name="ln881">          break;</a>
<a name="ln882">        }</a>
<a name="ln883">        line_breakcheck();              /* stop if ctrl-C typed */</a>
<a name="ln884">        if (got_int)</a>
<a name="ln885">          break;</a>
<a name="ln886"> </a>
<a name="ln887">        /* Cancel searching if a character was typed.  Used for</a>
<a name="ln888">         * 'incsearch'.  Don't check too often, that would slowdown</a>
<a name="ln889">         * searching too much. */</a>
<a name="ln890">        if ((options &amp; SEARCH_PEEK)</a>
<a name="ln891">            &amp;&amp; ((lnum - pos-&gt;lnum) &amp; 0x3f) == 0</a>
<a name="ln892">            &amp;&amp; char_avail()) {</a>
<a name="ln893">          break_loop = TRUE;</a>
<a name="ln894">          break;</a>
<a name="ln895">        }</a>
<a name="ln896"> </a>
<a name="ln897">        if (loop &amp;&amp; lnum == start_pos.lnum)</a>
<a name="ln898">          break;                    /* if second loop, stop where started */</a>
<a name="ln899">      }</a>
<a name="ln900">      at_first_line = FALSE;</a>
<a name="ln901"> </a>
<a name="ln902">      // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln903">      if (regmatch.regprog == NULL) {</a>
<a name="ln904">        break;</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">      // Stop the search if wrapscan isn't set, &quot;stop_lnum&quot; is</a>
<a name="ln908">      // specified, after an interrupt, after a match and after looping</a>
<a name="ln909">      // twice.</a>
<a name="ln910">      if (!p_ws || stop_lnum != 0 || got_int || called_emsg</a>
<a name="ln911">          || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln912">          || break_loop</a>
<a name="ln913">          || found || loop) {</a>
<a name="ln914">        break;</a>
<a name="ln915">      }</a>
<a name="ln916">      //</a>
<a name="ln917">      // If 'wrapscan' is set we continue at the other end of the file.</a>
<a name="ln918">      // If 'shortmess' does not contain 's', we give a message.</a>
<a name="ln919">      // This message is also remembered in keep_msg for when the screen</a>
<a name="ln920">      // is redrawn. The keep_msg is cleared whenever another message is</a>
<a name="ln921">      // written.</a>
<a name="ln922">      //</a>
<a name="ln923">      if (dir == BACKWARD) {        // start second loop at the other end</a>
<a name="ln924">        lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln925">      } else {</a>
<a name="ln926">        lnum = 1;</a>
<a name="ln927">      }</a>
<a name="ln928">      if (!shortmess(SHM_SEARCH) &amp;&amp; (options &amp; SEARCH_MSG)) {</a>
<a name="ln929">        give_warning((char_u *)_(dir == BACKWARD</a>
<a name="ln930">                                 ? top_bot_msg : bot_top_msg), true);</a>
<a name="ln931">      }</a>
<a name="ln932">      if (extra_arg != NULL) {</a>
<a name="ln933">        extra_arg-&gt;sa_wrapped = true;</a>
<a name="ln934">      }</a>
<a name="ln935">    }</a>
<a name="ln936">    if (got_int || called_emsg</a>
<a name="ln937">        || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln938">        || break_loop</a>
<a name="ln939">        ) {</a>
<a name="ln940">      break;</a>
<a name="ln941">    }</a>
<a name="ln942">  } while (--count &gt; 0 &amp;&amp; found);   // stop after count matches or no match</a>
<a name="ln943"> </a>
<a name="ln944">  vim_regfree(regmatch.regprog);</a>
<a name="ln945"> </a>
<a name="ln946">  called_emsg |= save_called_emsg;</a>
<a name="ln947"> </a>
<a name="ln948">  if (!found) {             /* did not find it */</a>
<a name="ln949">    if (got_int)</a>
<a name="ln950">      EMSG(_(e_interr));</a>
<a name="ln951">    else if ((options &amp; SEARCH_MSG) == SEARCH_MSG) {</a>
<a name="ln952">      if (p_ws)</a>
<a name="ln953">        EMSG2(_(e_patnotf2), mr_pattern);</a>
<a name="ln954">      else if (lnum == 0)</a>
<a name="ln955">        EMSG2(_(&quot;E384: search hit TOP without match for: %s&quot;),</a>
<a name="ln956">            mr_pattern);</a>
<a name="ln957">      else</a>
<a name="ln958">        EMSG2(_(&quot;E385: search hit BOTTOM without match for: %s&quot;),</a>
<a name="ln959">            mr_pattern);</a>
<a name="ln960">    }</a>
<a name="ln961">    return FAIL;</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  /* A pattern like &quot;\n\zs&quot; may go past the last line. */</a>
<a name="ln965">  if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln966">    pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln967">    pos-&gt;col = (int)STRLEN(ml_get_buf(buf, pos-&gt;lnum, FALSE));</a>
<a name="ln968">    if (pos-&gt;col &gt; 0)</a>
<a name="ln969">      --pos-&gt;col;</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  return submatch + 1;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">void set_search_direction(int cdir)</a>
<a name="ln976">{</a>
<a name="ln977">  spats[0].off.dir = cdir;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">static void set_vv_searchforward(void)</a>
<a name="ln981">{</a>
<a name="ln982">  set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">// Return the number of the first subpat that matched.</a>
<a name="ln986">// Return zero if none of them matched.</a>
<a name="ln987">static int first_submatch(regmmatch_T *rp)</a>
<a name="ln988">{</a>
<a name="ln989">  int submatch;</a>
<a name="ln990"> </a>
<a name="ln991">  for (submatch = 1;; ++submatch) {</a>
<a name="ln992">    if (rp-&gt;startpos[submatch].lnum &gt;= 0)</a>
<a name="ln993">      break;</a>
<a name="ln994">    if (submatch == 9) {</a>
<a name="ln995">      submatch = 0;</a>
<a name="ln996">      break;</a>
<a name="ln997">    }</a>
<a name="ln998">  }</a>
<a name="ln999">  return submatch;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002">/*</a>
<a name="ln1003"> * Highest level string search function.</a>
<a name="ln1004"> * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'</a>
<a name="ln1005"> *		  If 'dirc' is 0: use previous dir.</a>
<a name="ln1006"> *    If 'pat' is NULL or empty : use previous string.</a>
<a name="ln1007"> *    If 'options &amp; SEARCH_REV' : go in reverse of previous dir.</a>
<a name="ln1008"> *    If 'options &amp; SEARCH_ECHO': echo the search command and handle options</a>
<a name="ln1009"> *    If 'options &amp; SEARCH_MSG' : may give error message</a>
<a name="ln1010"> *    If 'options &amp; SEARCH_OPT' : interpret optional flags</a>
<a name="ln1011"> *    If 'options &amp; SEARCH_HIS' : put search pattern in history</a>
<a name="ln1012"> *    If 'options &amp; SEARCH_NOOF': don't add offset to position</a>
<a name="ln1013"> *    If 'options &amp; SEARCH_MARK': set previous context mark</a>
<a name="ln1014"> *    If 'options &amp; SEARCH_KEEP': keep previous search pattern</a>
<a name="ln1015"> *    If 'options &amp; SEARCH_START': accept match at curpos itself</a>
<a name="ln1016"> *    If 'options &amp; SEARCH_PEEK': check for typed char, cancel search</a>
<a name="ln1017"> *</a>
<a name="ln1018"> * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this</a>
<a name="ln1019"> * makes the movement linewise without moving the match position.</a>
<a name="ln1020"> *</a>
<a name="ln1021"> * Return 0 for failure, 1 for found, 2 for found and line offset added.</a>
<a name="ln1022"> */</a>
<a name="ln1023">int do_search(</a>
<a name="ln1024">    oparg_T         *oap,           /* can be NULL */</a>
<a name="ln1025">    int dirc,                       /* '/' or '?' */</a>
<a name="ln1026">    char_u          *pat,</a>
<a name="ln1027">    long count,</a>
<a name="ln1028">    int options,</a>
<a name="ln1029">    searchit_arg_T  *sia        // optional arguments or NULL</a>
<a name="ln1030">)</a>
<a name="ln1031">{</a>
<a name="ln1032">  pos_T pos;                    /* position of the last match */</a>
<a name="ln1033">  char_u          *searchstr;</a>
<a name="ln1034">  struct soffset old_off;</a>
<a name="ln1035">  int retval;                   /* Return value */</a>
<a name="ln1036">  char_u          *p;</a>
<a name="ln1037">  long c;</a>
<a name="ln1038">  char_u          *dircp;</a>
<a name="ln1039">  char_u          *strcopy = NULL;</a>
<a name="ln1040">  char_u          *ps;</a>
<a name="ln1041">  char_u          *msgbuf = NULL;</a>
<a name="ln1042">  size_t          len;</a>
<a name="ln1043">  bool            has_offset = false;</a>
<a name="ln1044">#define SEARCH_STAT_BUF_LEN 12</a>
<a name="ln1045"> </a>
<a name="ln1046">  /*</a>
<a name="ln1047">   * A line offset is not remembered, this is vi compatible.</a>
<a name="ln1048">   */</a>
<a name="ln1049">  if (spats[0].off.line &amp;&amp; vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {</a>
<a name="ln1050">    spats[0].off.line = FALSE;</a>
<a name="ln1051">    spats[0].off.off = 0;</a>
<a name="ln1052">  }</a>
<a name="ln1053"> </a>
<a name="ln1054">  /*</a>
<a name="ln1055">   * Save the values for when (options &amp; SEARCH_KEEP) is used.</a>
<a name="ln1056">   * (there is no &quot;if ()&quot; around this because gcc wants them initialized)</a>
<a name="ln1057">   */</a>
<a name="ln1058">  old_off = spats[0].off;</a>
<a name="ln1059"> </a>
<a name="ln1060">  pos = curwin-&gt;w_cursor;       /* start searching at the cursor position */</a>
<a name="ln1061"> </a>
<a name="ln1062">  /*</a>
<a name="ln1063">   * Find out the direction of the search.</a>
<a name="ln1064">   */</a>
<a name="ln1065">  if (dirc == 0)</a>
<a name="ln1066">    dirc = spats[0].off.dir;</a>
<a name="ln1067">  else {</a>
<a name="ln1068">    spats[0].off.dir = dirc;</a>
<a name="ln1069">    set_vv_searchforward();</a>
<a name="ln1070">  }</a>
<a name="ln1071">  if (options &amp; SEARCH_REV) {</a>
<a name="ln1072">    if (dirc == '/')</a>
<a name="ln1073">      dirc = '?';</a>
<a name="ln1074">    else</a>
<a name="ln1075">      dirc = '/';</a>
<a name="ln1076">  }</a>
<a name="ln1077"> </a>
<a name="ln1078">  /* If the cursor is in a closed fold, don't find another match in the same</a>
<a name="ln1079">   * fold. */</a>
<a name="ln1080">  if (dirc == '/') {</a>
<a name="ln1081">    if (hasFolding(pos.lnum, NULL, &amp;pos.lnum))</a>
<a name="ln1082">      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */</a>
<a name="ln1083">  } else {</a>
<a name="ln1084">    if (hasFolding(pos.lnum, &amp;pos.lnum, NULL))</a>
<a name="ln1085">      pos.col = 0;</a>
<a name="ln1086">  }</a>
<a name="ln1087"> </a>
<a name="ln1088">  /*</a>
<a name="ln1089">   * Turn 'hlsearch' highlighting back on.</a>
<a name="ln1090">   */</a>
<a name="ln1091">  if (no_hlsearch &amp;&amp; !(options &amp; SEARCH_KEEP)) {</a>
<a name="ln1092">    redraw_all_later(SOME_VALID);</a>
<a name="ln1093">    set_no_hlsearch(false);</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  /*</a>
<a name="ln1097">   * Repeat the search when pattern followed by ';', e.g. &quot;/foo/;?bar&quot;.</a>
<a name="ln1098">   */</a>
<a name="ln1099">  for (;; ) {</a>
<a name="ln1100">    bool show_top_bot_msg = false;</a>
<a name="ln1101"> </a>
<a name="ln1102">    searchstr = pat;</a>
<a name="ln1103">    dircp = NULL;</a>
<a name="ln1104">    /* use previous pattern */</a>
<a name="ln1105">    if (pat == NULL || *pat == NUL || *pat == dirc) {</a>
<a name="ln1106">      if (spats[RE_SEARCH].pat == NULL) {           // no previous pattern</a>
<a name="ln1107">        searchstr = spats[RE_SUBST].pat;</a>
<a name="ln1108">        if (searchstr == NULL) {</a>
<a name="ln1109">          EMSG(_(e_noprevre));</a>
<a name="ln1110">          retval = 0;</a>
<a name="ln1111">          goto end_do_search;</a>
<a name="ln1112">        }</a>
<a name="ln1113">      } else {</a>
<a name="ln1114">        /* make search_regcomp() use spats[RE_SEARCH].pat */</a>
<a name="ln1115">        searchstr = (char_u *)&quot;&quot;;</a>
<a name="ln1116">      }</a>
<a name="ln1117">    }</a>
<a name="ln1118"> </a>
<a name="ln1119">    if (pat != NULL &amp;&amp; *pat != NUL) {   /* look for (new) offset */</a>
<a name="ln1120">      /*</a>
<a name="ln1121">       * Find end of regular expression.</a>
<a name="ln1122">       * If there is a matching '/' or '?', toss it.</a>
<a name="ln1123">       */</a>
<a name="ln1124">      ps = strcopy;</a>
<a name="ln1125">      p = skip_regexp(pat, dirc, p_magic, &amp;strcopy);</a>
<a name="ln1126">      if (strcopy != ps) {</a>
<a name="ln1127">        /* made a copy of &quot;pat&quot; to change &quot;\?&quot; to &quot;?&quot; */</a>
<a name="ln1128">        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));</a>
<a name="ln1129">        pat = strcopy;</a>
<a name="ln1130">        searchstr = strcopy;</a>
<a name="ln1131">      }</a>
<a name="ln1132">      if (*p == dirc) {</a>
<a name="ln1133">        dircp = p;              /* remember where we put the NUL */</a>
<a name="ln1134">        *p++ = NUL;</a>
<a name="ln1135">      }</a>
<a name="ln1136">      spats[0].off.line = FALSE;</a>
<a name="ln1137">      spats[0].off.end = FALSE;</a>
<a name="ln1138">      spats[0].off.off = 0;</a>
<a name="ln1139">      // Check for a line offset or a character offset.</a>
<a name="ln1140">      // For get_address (echo off) we don't check for a character</a>
<a name="ln1141">      // offset, because it is meaningless and the 's' could be a</a>
<a name="ln1142">      // substitute command.</a>
<a name="ln1143">      if (*p == '+' || *p == '-' || ascii_isdigit(*p)) {</a>
<a name="ln1144">        spats[0].off.line = true;</a>
<a name="ln1145">      } else if ((options &amp; SEARCH_OPT)</a>
<a name="ln1146">                 &amp;&amp; (*p == 'e' || *p == 's' || *p == 'b')) {</a>
<a name="ln1147">        if (*p == 'e') {  // end</a>
<a name="ln1148">          spats[0].off.end = true;</a>
<a name="ln1149">        }</a>
<a name="ln1150">        p++;</a>
<a name="ln1151">      }</a>
<a name="ln1152">      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */</a>
<a name="ln1153">        /* 'nr' or '+nr' or '-nr' */</a>
<a name="ln1154">        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))</a>
<a name="ln1155">          spats[0].off.off = atol((char *)p);</a>
<a name="ln1156">        else if (*p == '-')                 /* single '-' */</a>
<a name="ln1157">          spats[0].off.off = -1;</a>
<a name="ln1158">        else                                /* single '+' */</a>
<a name="ln1159">          spats[0].off.off = 1;</a>
<a name="ln1160">        ++p;</a>
<a name="ln1161">        while (ascii_isdigit(*p))           /* skip number */</a>
<a name="ln1162">          ++p;</a>
<a name="ln1163">      }</a>
<a name="ln1164"> </a>
<a name="ln1165">      /* compute length of search command for get_address() */</a>
<a name="ln1166">      searchcmdlen += (int)(p - pat);</a>
<a name="ln1167"> </a>
<a name="ln1168">      pat = p;                              /* put pat after search command */</a>
<a name="ln1169">    }</a>
<a name="ln1170"> </a>
<a name="ln1171">    if ((options &amp; SEARCH_ECHO) &amp;&amp; messaging() &amp;&amp; !msg_silent</a>
<a name="ln1172">        &amp;&amp; (!cmd_silent || !shortmess(SHM_SEARCHCOUNT))) {</a>
<a name="ln1173">      char_u      *trunc;</a>
<a name="ln1174">      char_u      off_buf[40];</a>
<a name="ln1175">      size_t      off_len = 0;</a>
<a name="ln1176"> </a>
<a name="ln1177">      // Compute msg_row early.</a>
<a name="ln1178">      msg_start();</a>
<a name="ln1179"> </a>
<a name="ln1180">      // Get the offset, so we know how long it is.</a>
<a name="ln1181">      if (!cmd_silent</a>
<a name="ln1182">          &amp;&amp; (spats[0].off.line || spats[0].off.end || spats[0].off.off)) {</a>
<a name="ln1183">        p = off_buf;  // -V507</a>
<a name="ln1184">        *p++ = dirc;</a>
<a name="ln1185">        if (spats[0].off.end) {</a>
<a name="ln1186">          *p++ = 'e';</a>
<a name="ln1187">        } else if (!spats[0].off.line) {</a>
<a name="ln1188">          *p++ = 's';</a>
<a name="ln1189">        }</a>
<a name="ln1190">        if (spats[0].off.off &gt; 0 || spats[0].off.line) {</a>
<a name="ln1191">          *p++ = '+';</a>
<a name="ln1192">        }</a>
<a name="ln1193">        *p = NUL;</a>
<a name="ln1194">        if (spats[0].off.off != 0 || spats[0].off.line) {</a>
<a name="ln1195">          snprintf((char *)p, sizeof(off_buf) - 1 - (p - off_buf),</a>
<a name="ln1196">                   &quot;%&quot; PRId64, spats[0].off.off);</a>
<a name="ln1197">        }</a>
<a name="ln1198">        off_len = STRLEN(off_buf);</a>
<a name="ln1199">      }</a>
<a name="ln1200"> </a>
<a name="ln1201">      if (*searchstr == NUL) {</a>
<a name="ln1202">        p = spats[0].pat;</a>
<a name="ln1203">      } else {</a>
<a name="ln1204">        p = searchstr;</a>
<a name="ln1205">      }</a>
<a name="ln1206"> </a>
<a name="ln1207">      if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent) {</a>
<a name="ln1208">        // Reserve enough space for the search pattern + offset +</a>
<a name="ln1209">        // search stat.  Use all the space available, so that the</a>
<a name="ln1210">        // search state is right aligned.  If there is not enough space</a>
<a name="ln1211">        // msg_strtrunc() will shorten in the middle.</a>
<a name="ln1212">        if (ui_has(kUIMessages)) {</a>
<a name="ln1213">          len = 0;  // adjusted below</a>
<a name="ln1214">        } else if (msg_scrolled != 0 &amp;&amp; !cmd_silent) {</a>
<a name="ln1215">          // Use all the columns.</a>
<a name="ln1216">          len = (Rows - msg_row) * Columns - 1;</a>
<a name="ln1217">        } else {</a>
<a name="ln1218">          // Use up to 'showcmd' column.</a>
<a name="ln1219">          len = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln1220">        }</a>
<a name="ln1221">        if (len &lt; STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3) {</a>
<a name="ln1222">          len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;</a>
<a name="ln1223">        }</a>
<a name="ln1224">      } else {</a>
<a name="ln1225">        // Reserve enough space for the search pattern + offset.</a>
<a name="ln1226">        len = STRLEN(p) + off_len + 3;</a>
<a name="ln1227">      }</a>
<a name="ln1228"> </a>
<a name="ln1229">      xfree(msgbuf);</a>
<a name="ln1230">      msgbuf = xmalloc(len);</a>
<a name="ln1231">      memset(msgbuf, ' ', len);</a>
<a name="ln1232">      msgbuf[len - 1] = NUL;</a>
<a name="ln1233"> </a>
<a name="ln1234">      // do not fill the msgbuf buffer, if cmd_silent is set, leave it</a>
<a name="ln1235">      // empty for the search_stat feature.</a>
<a name="ln1236">      if (!cmd_silent) {</a>
<a name="ln1237">        msgbuf[0] = dirc;</a>
<a name="ln1238">        if (utf_iscomposing(utf_ptr2char(p))) {</a>
<a name="ln1239">          // Use a space to draw the composing char on.</a>
<a name="ln1240">          msgbuf[1] = ' ';</a>
<a name="ln1241">          memmove(msgbuf + 2, p, STRLEN(p));</a>
<a name="ln1242">        } else {</a>
<a name="ln1243">          memmove(msgbuf + 1, p, STRLEN(p));</a>
<a name="ln1244">        }</a>
<a name="ln1245">        if (off_len &gt; 0) {</a>
<a name="ln1246">          memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);</a>
<a name="ln1247">        }</a>
<a name="ln1248"> </a>
<a name="ln1249">        trunc = msg_strtrunc(msgbuf, true);</a>
<a name="ln1250">        if (trunc != NULL) {</a>
<a name="ln1251">          xfree(msgbuf);</a>
<a name="ln1252">          msgbuf = trunc;</a>
<a name="ln1253">        }</a>
<a name="ln1254"> </a>
<a name="ln1255">        // The search pattern could be shown on the right in rightleft</a>
<a name="ln1256">        // mode, but the 'ruler' and 'showcmd' area use it too, thus</a>
<a name="ln1257">        // it would be blanked out again very soon.  Show it on the</a>
<a name="ln1258">        // left, but do reverse the text.</a>
<a name="ln1259">        if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln1260">          char_u *r = reverse_text(trunc != NULL ? trunc : msgbuf);</a>
<a name="ln1261">          xfree(msgbuf);</a>
<a name="ln1262">          msgbuf = r;</a>
<a name="ln1263">          // move reversed text to beginning of buffer</a>
<a name="ln1264">          while (*r == ' ') {</a>
<a name="ln1265">            r++;</a>
<a name="ln1266">          }</a>
<a name="ln1267">          size_t pat_len = msgbuf + STRLEN(msgbuf) - r;</a>
<a name="ln1268">          memmove(msgbuf, r, pat_len);</a>
<a name="ln1269">          // overwrite old text</a>
<a name="ln1270">          if ((size_t)(r - msgbuf) &gt;= pat_len) {</a>
<a name="ln1271">            memset(r, ' ', pat_len);</a>
<a name="ln1272">          } else {</a>
<a name="ln1273">            memset(msgbuf + pat_len, ' ', r - msgbuf);</a>
<a name="ln1274">          }</a>
<a name="ln1275">        }</a>
<a name="ln1276">        msg_outtrans(msgbuf);</a>
<a name="ln1277">        msg_clr_eos();</a>
<a name="ln1278">        msg_check();</a>
<a name="ln1279"> </a>
<a name="ln1280">        gotocmdline(false);</a>
<a name="ln1281">        ui_flush();</a>
<a name="ln1282">        msg_nowait = true;  // don't wait for this message</a>
<a name="ln1283">      }</a>
<a name="ln1284">    }</a>
<a name="ln1285"> </a>
<a name="ln1286">    /*</a>
<a name="ln1287">     * If there is a character offset, subtract it from the current</a>
<a name="ln1288">     * position, so we don't get stuck at &quot;?pat?e+2&quot; or &quot;/pat/s-2&quot;.</a>
<a name="ln1289">     * Skip this if pos.col is near MAXCOL (closed fold).</a>
<a name="ln1290">     * This is not done for a line offset, because then we would not be vi</a>
<a name="ln1291">     * compatible.</a>
<a name="ln1292">     */</a>
<a name="ln1293">    if (!spats[0].off.line &amp;&amp; spats[0].off.off &amp;&amp; pos.col &lt; MAXCOL - 2) {</a>
<a name="ln1294">      if (spats[0].off.off &gt; 0) {</a>
<a name="ln1295">        for (c = spats[0].off.off; c; --c)</a>
<a name="ln1296">          if (decl(&amp;pos) == -1)</a>
<a name="ln1297">            break;</a>
<a name="ln1298">        if (c) {                        /* at start of buffer */</a>
<a name="ln1299">          pos.lnum = 0;                 /* allow lnum == 0 here */</a>
<a name="ln1300">          pos.col = MAXCOL;</a>
<a name="ln1301">        }</a>
<a name="ln1302">      } else {</a>
<a name="ln1303">        for (c = spats[0].off.off; c; ++c)</a>
<a name="ln1304">          if (incl(&amp;pos) == -1)</a>
<a name="ln1305">            break;</a>
<a name="ln1306">        if (c) {                        /* at end of buffer */</a>
<a name="ln1307">          pos.lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln1308">          pos.col = 0;</a>
<a name="ln1309">        }</a>
<a name="ln1310">      }</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    c = searchit(curwin, curbuf, &amp;pos, NULL, dirc == '/' ? FORWARD : BACKWARD,</a>
<a name="ln1314">                 searchstr, count,</a>
<a name="ln1315">                 (spats[0].off.end * SEARCH_END</a>
<a name="ln1316">                  + (options</a>
<a name="ln1317">                     &amp; (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS + SEARCH_MSG</a>
<a name="ln1318">                        + SEARCH_START</a>
<a name="ln1319">                        + ((pat != NULL &amp;&amp; *pat == ';') ? 0 : SEARCH_NOOF)))),</a>
<a name="ln1320">                 RE_LAST, sia);</a>
<a name="ln1321"> </a>
<a name="ln1322">    if (dircp != NULL) {</a>
<a name="ln1323">      *dircp = dirc;  // restore second '/' or '?' for normal_cmd()</a>
<a name="ln1324">    }</a>
<a name="ln1325"> </a>
<a name="ln1326">    if (!shortmess(SHM_SEARCH)</a>
<a name="ln1327">        &amp;&amp; ((dirc == '/' &amp;&amp; lt(pos, curwin-&gt;w_cursor))</a>
<a name="ln1328">            || (dirc == '?' &amp;&amp; lt(curwin-&gt;w_cursor, pos)))) {</a>
<a name="ln1329">      show_top_bot_msg = true;</a>
<a name="ln1330">    }</a>
<a name="ln1331"> </a>
<a name="ln1332">    if (c == FAIL) {</a>
<a name="ln1333">      retval = 0;</a>
<a name="ln1334">      goto end_do_search;</a>
<a name="ln1335">    }</a>
<a name="ln1336">    if (spats[0].off.end &amp;&amp; oap != NULL)</a>
<a name="ln1337">      oap-&gt;inclusive = true;        /* 'e' includes last character */</a>
<a name="ln1338"> </a>
<a name="ln1339">    retval = 1;                     /* pattern found */</a>
<a name="ln1340"> </a>
<a name="ln1341">    /*</a>
<a name="ln1342">     * Add character and/or line offset</a>
<a name="ln1343">     */</a>
<a name="ln1344">    if (!(options &amp; SEARCH_NOOF) || (pat != NULL &amp;&amp; *pat == ';')) {</a>
<a name="ln1345">      pos_T org_pos = pos;</a>
<a name="ln1346"> </a>
<a name="ln1347">      if (spats[0].off.line) {  // Add the offset to the line number.</a>
<a name="ln1348">        c = pos.lnum + spats[0].off.off;</a>
<a name="ln1349">        if (c &lt; 1)</a>
<a name="ln1350">          pos.lnum = 1;</a>
<a name="ln1351">        else if (c &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1352">          pos.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1353">        else</a>
<a name="ln1354">          pos.lnum = c;</a>
<a name="ln1355">        pos.col = 0;</a>
<a name="ln1356"> </a>
<a name="ln1357">        retval = 2;                 /* pattern found, line offset added */</a>
<a name="ln1358">      } else if (pos.col &lt; MAXCOL - 2) {      /* just in case */</a>
<a name="ln1359">        /* to the right, check for end of file */</a>
<a name="ln1360">        c = spats[0].off.off;</a>
<a name="ln1361">        if (c &gt; 0) {</a>
<a name="ln1362">          while (c-- &gt; 0)</a>
<a name="ln1363">            if (incl(&amp;pos) == -1)</a>
<a name="ln1364">              break;</a>
<a name="ln1365">        }</a>
<a name="ln1366">        /* to the left, check for start of file */</a>
<a name="ln1367">        else {</a>
<a name="ln1368">          while (c++ &lt; 0)</a>
<a name="ln1369">            if (decl(&amp;pos) == -1)</a>
<a name="ln1370">              break;</a>
<a name="ln1371">        }</a>
<a name="ln1372">      }</a>
<a name="ln1373">      if (!equalpos(pos, org_pos)) {</a>
<a name="ln1374">        has_offset = true;</a>
<a name="ln1375">      }</a>
<a name="ln1376">    }</a>
<a name="ln1377"> </a>
<a name="ln1378">    // Show [1/15] if 'S' is not in 'shortmess'.</a>
<a name="ln1379">    if ((options &amp; SEARCH_ECHO)</a>
<a name="ln1380">        &amp;&amp; messaging()</a>
<a name="ln1381">        &amp;&amp; !msg_silent</a>
<a name="ln1382">        &amp;&amp; c != FAIL</a>
<a name="ln1383">        &amp;&amp; !shortmess(SHM_SEARCHCOUNT)</a>
<a name="ln1384">        &amp;&amp; msgbuf != NULL) {</a>
<a name="ln1385">      search_stat(dirc, &amp;pos, show_top_bot_msg, msgbuf,</a>
<a name="ln1386">                  (count != 1</a>
<a name="ln1387">                   || has_offset</a>
<a name="ln1388">                   || (!(fdo_flags &amp; FDO_SEARCH)</a>
<a name="ln1389">                       &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL, NULL))));</a>
<a name="ln1390">    }</a>
<a name="ln1391"> </a>
<a name="ln1392">    // The search command can be followed by a ';' to do another search.</a>
<a name="ln1393">    // For example: &quot;/pat/;/foo/+3;?bar&quot;</a>
<a name="ln1394">    // This is like doing another search command, except:</a>
<a name="ln1395">    // - The remembered direction '/' or '?' is from the first search.</a>
<a name="ln1396">    // - When an error happens the cursor isn't moved at all.</a>
<a name="ln1397">    // Don't do this when called by get_address() (it handles ';' itself).</a>
<a name="ln1398">    if (!(options &amp; SEARCH_OPT) || pat == NULL || *pat != ';') {</a>
<a name="ln1399">      break;</a>
<a name="ln1400">    }</a>
<a name="ln1401"> </a>
<a name="ln1402">    dirc = *++pat;</a>
<a name="ln1403">    if (dirc != '?' &amp;&amp; dirc != '/') {</a>
<a name="ln1404">      retval = 0;</a>
<a name="ln1405">      EMSG(_(&quot;E386: Expected '?' or '/'  after ';'&quot;));</a>
<a name="ln1406">      goto end_do_search;</a>
<a name="ln1407">    }</a>
<a name="ln1408">    ++pat;</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  if (options &amp; SEARCH_MARK)</a>
<a name="ln1412">    setpcmark();</a>
<a name="ln1413">  curwin-&gt;w_cursor = pos;</a>
<a name="ln1414">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln1415"> </a>
<a name="ln1416">end_do_search:</a>
<a name="ln1417">  if ((options &amp; SEARCH_KEEP) || cmdmod.keeppatterns)</a>
<a name="ln1418">    spats[0].off = old_off;</a>
<a name="ln1419">  xfree(msgbuf);</a>
<a name="ln1420"> </a>
<a name="ln1421">  return retval;</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">/*</a>
<a name="ln1425"> * search_for_exact_line(buf, pos, dir, pat)</a>
<a name="ln1426"> *</a>
<a name="ln1427"> * Search for a line starting with the given pattern (ignoring leading</a>
<a name="ln1428"> * white-space), starting from pos and going in direction &quot;dir&quot;. &quot;pos&quot; will</a>
<a name="ln1429"> * contain the position of the match found.    Blank lines match only if</a>
<a name="ln1430"> * ADDING is set.  If p_ic is set then the pattern must be in lowercase.</a>
<a name="ln1431"> * Return OK for success, or FAIL if no line found.</a>
<a name="ln1432"> */</a>
<a name="ln1433">int search_for_exact_line(buf_T *buf, pos_T *pos, Direction dir, char_u *pat)</a>
<a name="ln1434">{</a>
<a name="ln1435">  linenr_T start = 0;</a>
<a name="ln1436">  char_u      *ptr;</a>
<a name="ln1437">  char_u      *p;</a>
<a name="ln1438"> </a>
<a name="ln1439">  if (buf-&gt;b_ml.ml_line_count == 0)</a>
<a name="ln1440">    return FAIL;</a>
<a name="ln1441">  for (;; ) {</a>
<a name="ln1442">    pos-&gt;lnum += dir;</a>
<a name="ln1443">    if (pos-&gt;lnum &lt; 1) {</a>
<a name="ln1444">      if (p_ws) {</a>
<a name="ln1445">        pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1446">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1447">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1448">      } else {</a>
<a name="ln1449">        pos-&gt;lnum = 1;</a>
<a name="ln1450">        break;</a>
<a name="ln1451">      }</a>
<a name="ln1452">    } else if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1453">      if (p_ws) {</a>
<a name="ln1454">        pos-&gt;lnum = 1;</a>
<a name="ln1455">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1456">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1457">      } else {</a>
<a name="ln1458">        pos-&gt;lnum = 1;</a>
<a name="ln1459">        break;</a>
<a name="ln1460">      }</a>
<a name="ln1461">    }</a>
<a name="ln1462">    if (pos-&gt;lnum == start)</a>
<a name="ln1463">      break;</a>
<a name="ln1464">    if (start == 0)</a>
<a name="ln1465">      start = pos-&gt;lnum;</a>
<a name="ln1466">    ptr = ml_get_buf(buf, pos-&gt;lnum, FALSE);</a>
<a name="ln1467">    p = skipwhite(ptr);</a>
<a name="ln1468">    pos-&gt;col = (colnr_T) (p - ptr);</a>
<a name="ln1469"> </a>
<a name="ln1470">    /* when adding lines the matching line may be empty but it is not</a>
<a name="ln1471">     * ignored because we are interested in the next line -- Acevedo */</a>
<a name="ln1472">    if ((compl_cont_status &amp; CONT_ADDING)</a>
<a name="ln1473">        &amp;&amp; !(compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln1474">      if (mb_strcmp_ic((bool)p_ic, (const char *)p, (const char *)pat) == 0) {</a>
<a name="ln1475">        return OK;</a>
<a name="ln1476">      }</a>
<a name="ln1477">    } else if (*p != NUL) {  // Ignore empty lines.</a>
<a name="ln1478">      // Expanding lines or words.</a>
<a name="ln1479">      assert(compl_length &gt;= 0);</a>
<a name="ln1480">      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)</a>
<a name="ln1481">           : STRNCMP(p, pat, compl_length)) == 0)</a>
<a name="ln1482">        return OK;</a>
<a name="ln1483">    }</a>
<a name="ln1484">  }</a>
<a name="ln1485">  return FAIL;</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">/*</a>
<a name="ln1489"> * Character Searches</a>
<a name="ln1490"> */</a>
<a name="ln1491"> </a>
<a name="ln1492">/*</a>
<a name="ln1493"> * Search for a character in a line.  If &quot;t_cmd&quot; is FALSE, move to the</a>
<a name="ln1494"> * position of the character, otherwise move to just before the char.</a>
<a name="ln1495"> * Do this &quot;cap-&gt;count1&quot; times.</a>
<a name="ln1496"> * Return FAIL or OK.</a>
<a name="ln1497"> */</a>
<a name="ln1498">int searchc(cmdarg_T *cap, int t_cmd)</a>
<a name="ln1499">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1500">{</a>
<a name="ln1501">  int c = cap-&gt;nchar;                   // char to search for</a>
<a name="ln1502">  Direction dir = cap-&gt;arg;             // TRUE for searching forward</a>
<a name="ln1503">  long count = cap-&gt;count1;             // repeat count</a>
<a name="ln1504">  int col;</a>
<a name="ln1505">  char_u              *p;</a>
<a name="ln1506">  int len;</a>
<a name="ln1507">  int stop = TRUE;</a>
<a name="ln1508"> </a>
<a name="ln1509">  if (c != NUL) {       /* normal search: remember args for repeat */</a>
<a name="ln1510">    if (!KeyStuffed) {      /* don't remember when redoing */</a>
<a name="ln1511">      *lastc = c;</a>
<a name="ln1512">      set_csearch_direction(dir);</a>
<a name="ln1513">      set_csearch_until(t_cmd);</a>
<a name="ln1514">      lastc_bytelen = utf_char2bytes(c, lastc_bytes);</a>
<a name="ln1515">      if (cap-&gt;ncharC1 != 0) {</a>
<a name="ln1516">        lastc_bytelen += utf_char2bytes(cap-&gt;ncharC1,</a>
<a name="ln1517">                                        lastc_bytes + lastc_bytelen);</a>
<a name="ln1518">        if (cap-&gt;ncharC2 != 0) {</a>
<a name="ln1519">          lastc_bytelen += utf_char2bytes(cap-&gt;ncharC2,</a>
<a name="ln1520">                                          lastc_bytes + lastc_bytelen);</a>
<a name="ln1521">        }</a>
<a name="ln1522">      }</a>
<a name="ln1523">    }</a>
<a name="ln1524">  } else {            // repeat previous search</a>
<a name="ln1525">    if (*lastc == NUL &amp;&amp; lastc_bytelen == 1) {</a>
<a name="ln1526">      return FAIL;</a>
<a name="ln1527">    }</a>
<a name="ln1528">    if (dir) {        // repeat in opposite direction</a>
<a name="ln1529">      dir = -lastcdir;</a>
<a name="ln1530">    } else {</a>
<a name="ln1531">      dir = lastcdir;</a>
<a name="ln1532">    }</a>
<a name="ln1533">    t_cmd = last_t_cmd;</a>
<a name="ln1534">    c = *lastc;</a>
<a name="ln1535">    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */</a>
<a name="ln1536"> </a>
<a name="ln1537">    /* Force a move of at least one char, so &quot;;&quot; and &quot;,&quot; will move the</a>
<a name="ln1538">     * cursor, even if the cursor is right in front of char we are looking</a>
<a name="ln1539">     * at. */</a>
<a name="ln1540">    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL &amp;&amp; count == 1 &amp;&amp; t_cmd)</a>
<a name="ln1541">      stop = FALSE;</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  if (dir == BACKWARD)</a>
<a name="ln1545">    cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln1546">  else</a>
<a name="ln1547">    cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln1548"> </a>
<a name="ln1549">  p = get_cursor_line_ptr();</a>
<a name="ln1550">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln1551">  len = (int)STRLEN(p);</a>
<a name="ln1552"> </a>
<a name="ln1553">  while (count--) {</a>
<a name="ln1554">    for (;; ) {</a>
<a name="ln1555">      if (dir &gt; 0) {</a>
<a name="ln1556">        col += utfc_ptr2len(p + col);</a>
<a name="ln1557">        if (col &gt;= len) {</a>
<a name="ln1558">          return FAIL;</a>
<a name="ln1559">        }</a>
<a name="ln1560">      } else {</a>
<a name="ln1561">        if (col == 0) {</a>
<a name="ln1562">          return FAIL;</a>
<a name="ln1563">        }</a>
<a name="ln1564">        col -= utf_head_off(p, p + col - 1) + 1;</a>
<a name="ln1565">      }</a>
<a name="ln1566">      if (lastc_bytelen == 1) {</a>
<a name="ln1567">        if (p[col] == c &amp;&amp; stop) {</a>
<a name="ln1568">          break;</a>
<a name="ln1569">        }</a>
<a name="ln1570">      } else if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0 &amp;&amp; stop) {</a>
<a name="ln1571">        break;</a>
<a name="ln1572">      }</a>
<a name="ln1573">      stop = true;</a>
<a name="ln1574">    }</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  if (t_cmd) {</a>
<a name="ln1578">    // Backup to before the character (possibly double-byte).</a>
<a name="ln1579">    col -= dir;</a>
<a name="ln1580">    if (dir &lt; 0) {</a>
<a name="ln1581">      // Landed on the search char which is lastc_bytelen long.</a>
<a name="ln1582">      col += lastc_bytelen - 1;</a>
<a name="ln1583">    } else {</a>
<a name="ln1584">      // To previous char, which may be multi-byte.</a>
<a name="ln1585">      col -= utf_head_off(p, p + col);</a>
<a name="ln1586">    }</a>
<a name="ln1587">  }</a>
<a name="ln1588">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1589"> </a>
<a name="ln1590">  return OK;</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">/*</a>
<a name="ln1594"> * &quot;Other&quot; Searches</a>
<a name="ln1595"> */</a>
<a name="ln1596"> </a>
<a name="ln1597">/*</a>
<a name="ln1598"> * findmatch - find the matching paren or brace</a>
<a name="ln1599"> *</a>
<a name="ln1600"> * Improvement over vi: Braces inside quotes are ignored.</a>
<a name="ln1601"> */</a>
<a name="ln1602">pos_T *findmatch(oparg_T *oap, int initc)</a>
<a name="ln1603">{</a>
<a name="ln1604">  return findmatchlimit(oap, initc, 0, 0);</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">// Return true if the character before &quot;linep[col]&quot; equals &quot;ch&quot;.</a>
<a name="ln1608">// Return false if &quot;col&quot; is zero.</a>
<a name="ln1609">// Update &quot;*prevcol&quot; to the column of the previous character, unless &quot;prevcol&quot;</a>
<a name="ln1610">// is NULL.</a>
<a name="ln1611">// Handles multibyte string correctly.</a>
<a name="ln1612">static bool check_prevcol(char_u *linep, int col, int ch, int *prevcol)</a>
<a name="ln1613">{</a>
<a name="ln1614">  col--;</a>
<a name="ln1615">  if (col &gt; 0) {</a>
<a name="ln1616">    col -= utf_head_off(linep, linep + col);</a>
<a name="ln1617">  }</a>
<a name="ln1618">  if (prevcol) {</a>
<a name="ln1619">    *prevcol = col;</a>
<a name="ln1620">  }</a>
<a name="ln1621">  return (col &gt;= 0 &amp;&amp; linep[col] == ch) ? true : false;</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">/*</a>
<a name="ln1625"> * Raw string start is found at linep[startpos.col - 1].</a>
<a name="ln1626"> * Return true if the matching end can be found between startpos and endpos.</a>
<a name="ln1627"> */</a>
<a name="ln1628">static bool find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)</a>
<a name="ln1629">{</a>
<a name="ln1630">  char_u *p;</a>
<a name="ln1631">  char_u *delim_copy;</a>
<a name="ln1632">  size_t delim_len;</a>
<a name="ln1633">  linenr_T lnum;</a>
<a name="ln1634"> </a>
<a name="ln1635">  for (p = linep + startpos-&gt;col + 1; *p &amp;&amp; *p != '('; p++) {}</a>
<a name="ln1636"> </a>
<a name="ln1637">  delim_len = (p - linep) - startpos-&gt;col - 1;</a>
<a name="ln1638">  delim_copy = vim_strnsave(linep + startpos-&gt;col + 1, delim_len);</a>
<a name="ln1639">  bool found = false;</a>
<a name="ln1640">  for (lnum = startpos-&gt;lnum; lnum &lt;= endpos-&gt;lnum; lnum++) {</a>
<a name="ln1641">    char_u *line = ml_get(lnum);</a>
<a name="ln1642"> </a>
<a name="ln1643">    for (p = line + (lnum == startpos-&gt;lnum ? startpos-&gt;col + 1 : 0); *p; p++) {</a>
<a name="ln1644">      if (lnum == endpos-&gt;lnum &amp;&amp; (colnr_T)(p - line) &gt;= endpos-&gt;col) {</a>
<a name="ln1645">        break;</a>
<a name="ln1646">      }</a>
<a name="ln1647">      if (*p == ')'</a>
<a name="ln1648">          &amp;&amp; STRNCMP(delim_copy, p + 1, delim_len) == 0</a>
<a name="ln1649">          &amp;&amp; p[delim_len + 1] == '&quot;') {</a>
<a name="ln1650">        found = true;</a>
<a name="ln1651">        break;</a>
<a name="ln1652">      }</a>
<a name="ln1653">    }</a>
<a name="ln1654">    if (found) {</a>
<a name="ln1655">      break;</a>
<a name="ln1656">    }</a>
<a name="ln1657">  }</a>
<a name="ln1658">  xfree(delim_copy);</a>
<a name="ln1659">  return found;</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662">/// Check matchpairs option for &quot;*initc&quot;.</a>
<a name="ln1663">/// If there is a match set &quot;*initc&quot; to the matching character and &quot;*findc&quot; to</a>
<a name="ln1664">/// the opposite character.  Set &quot;*backwards&quot; to the direction.</a>
<a name="ln1665">/// When &quot;switchit&quot; is true swap the direction.</a>
<a name="ln1666">static void find_mps_values(int *initc, int *findc, bool *backwards,</a>
<a name="ln1667">                            bool switchit)</a>
<a name="ln1668">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1669">{</a>
<a name="ln1670">  char_u *ptr = curbuf-&gt;b_p_mps;</a>
<a name="ln1671"> </a>
<a name="ln1672">  while (*ptr != NUL) {</a>
<a name="ln1673">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1674">      if (switchit) {</a>
<a name="ln1675">        *findc = *initc;</a>
<a name="ln1676">        *initc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1677">        *backwards = true;</a>
<a name="ln1678">      } else {</a>
<a name="ln1679">        *findc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1680">        *backwards = false;</a>
<a name="ln1681">      }</a>
<a name="ln1682">      return;</a>
<a name="ln1683">    }</a>
<a name="ln1684">    char_u *prev = ptr;</a>
<a name="ln1685">    ptr += utfc_ptr2len(ptr) + 1;</a>
<a name="ln1686">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1687">      if (switchit) {</a>
<a name="ln1688">        *findc = *initc;</a>
<a name="ln1689">        *initc = utf_ptr2char(prev);</a>
<a name="ln1690">        *backwards = false;</a>
<a name="ln1691">      } else {</a>
<a name="ln1692">        *findc = utf_ptr2char(prev);</a>
<a name="ln1693">        *backwards = true;</a>
<a name="ln1694">      }</a>
<a name="ln1695">      return;</a>
<a name="ln1696">    }</a>
<a name="ln1697">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1698">    if (*ptr == ',') {</a>
<a name="ln1699">      ptr++;</a>
<a name="ln1700">    }</a>
<a name="ln1701">  }</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">/*</a>
<a name="ln1705"> * findmatchlimit -- find the matching paren or brace, if it exists within</a>
<a name="ln1706"> * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling</a>
<a name="ln1707"> * off the edge of the file.</a>
<a name="ln1708"> *</a>
<a name="ln1709"> * &quot;initc&quot; is the character to find a match for.  NUL means to find the</a>
<a name="ln1710"> * character at or after the cursor. Special values:</a>
<a name="ln1711"> * '*'  look for C-style comment / *</a>
<a name="ln1712"> * '/'  look for C-style comment / *, ignoring comment-end</a>
<a name="ln1713"> * '#'  look for preprocessor directives</a>
<a name="ln1714"> * 'R'  look for raw string start: R&quot;delim(text)delim&quot; (only backwards)</a>
<a name="ln1715"> *</a>
<a name="ln1716"> * flags: FM_BACKWARD	search backwards (when initc is '/', '*' or '#')</a>
<a name="ln1717"> *	  FM_FORWARD	search forwards (when initc is '/', '*' or '#')</a>
<a name="ln1718"> *	  FM_BLOCKSTOP	stop at start/end of block ({ or } in column 0)</a>
<a name="ln1719"> *	  FM_SKIPCOMM	skip comments (not implemented yet!)</a>
<a name="ln1720"> *</a>
<a name="ln1721"> * &quot;oap&quot; is only used to set oap-&gt;motion_type for a linewise motion, it can be</a>
<a name="ln1722"> * NULL</a>
<a name="ln1723"> */</a>
<a name="ln1724"> </a>
<a name="ln1725">pos_T *findmatchlimit(oparg_T *oap, int initc, int flags, int64_t maxtravel)</a>
<a name="ln1726">{</a>
<a name="ln1727">  static pos_T pos;                     // current search position</a>
<a name="ln1728">  int findc = 0;                        // matching brace</a>
<a name="ln1729">  int count = 0;                        // cumulative number of braces</a>
<a name="ln1730">  bool backwards = false;               // init for gcc</a>
<a name="ln1731">  bool raw_string = false;              // search for raw string</a>
<a name="ln1732">  bool inquote = false;                 // true when inside quotes</a>
<a name="ln1733">  char_u      *ptr;</a>
<a name="ln1734">  int hash_dir = 0;                     // Direction searched for # things</a>
<a name="ln1735">  int comment_dir = 0;                  // Direction searched for comments</a>
<a name="ln1736">  int traveled = 0;                     // how far we've searched so far</a>
<a name="ln1737">  bool ignore_cend = false;             // ignore comment end</a>
<a name="ln1738">  int match_escaped = 0;                // search for escaped match</a>
<a name="ln1739">  int dir;                              // Direction to search</a>
<a name="ln1740">  int comment_col = MAXCOL;             // start of / / comment</a>
<a name="ln1741">  bool lispcomm = false;                // inside of Lisp-style comment</a>
<a name="ln1742">  bool lisp = curbuf-&gt;b_p_lisp;         // engage Lisp-specific hacks ;)</a>
<a name="ln1743"> </a>
<a name="ln1744">  pos = curwin-&gt;w_cursor;</a>
<a name="ln1745">  pos.coladd = 0;</a>
<a name="ln1746">  char_u *linep = ml_get(pos.lnum);     // pointer to current line</a>
<a name="ln1747"> </a>
<a name="ln1748">  // vi compatible matching</a>
<a name="ln1749">  bool cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);</a>
<a name="ln1750">  // don't recognize backslashes</a>
<a name="ln1751">  bool cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);</a>
<a name="ln1752"> </a>
<a name="ln1753">  /* Direction to search when initc is '/', '*' or '#' */</a>
<a name="ln1754">  if (flags &amp; FM_BACKWARD)</a>
<a name="ln1755">    dir = BACKWARD;</a>
<a name="ln1756">  else if (flags &amp; FM_FORWARD)</a>
<a name="ln1757">    dir = FORWARD;</a>
<a name="ln1758">  else</a>
<a name="ln1759">    dir = 0;</a>
<a name="ln1760"> </a>
<a name="ln1761">  /*</a>
<a name="ln1762">   * if initc given, look in the table for the matching character</a>
<a name="ln1763">   * '/' and '*' are special cases: look for start or end of comment.</a>
<a name="ln1764">   * When '/' is used, we ignore running backwards into a star-slash, for</a>
<a name="ln1765">   * &quot;[*&quot; command, we just want to find any comment.</a>
<a name="ln1766">   */</a>
<a name="ln1767">  if (initc == '/' || initc == '*' || initc == 'R') {</a>
<a name="ln1768">    comment_dir = dir;</a>
<a name="ln1769">    if (initc == '/')</a>
<a name="ln1770">      ignore_cend = true;</a>
<a name="ln1771">    backwards = (dir == FORWARD) ? false : true;</a>
<a name="ln1772">    raw_string = (initc == 'R');</a>
<a name="ln1773">    initc = NUL;</a>
<a name="ln1774">  } else if (initc != '#' &amp;&amp; initc != NUL) {</a>
<a name="ln1775">    find_mps_values(&amp;initc, &amp;findc, &amp;backwards, true);</a>
<a name="ln1776">    if (findc == NUL) {</a>
<a name="ln1777">      return NULL;</a>
<a name="ln1778">    }</a>
<a name="ln1779">  } else {</a>
<a name="ln1780">    /*</a>
<a name="ln1781">     * Either initc is '#', or no initc was given and we need to look</a>
<a name="ln1782">     * under the cursor.</a>
<a name="ln1783">     */</a>
<a name="ln1784">    if (initc == '#') {</a>
<a name="ln1785">      hash_dir = dir;</a>
<a name="ln1786">    } else {</a>
<a name="ln1787">      /*</a>
<a name="ln1788">       * initc was not given, must look for something to match under</a>
<a name="ln1789">       * or near the cursor.</a>
<a name="ln1790">       * Only check for special things when 'cpo' doesn't have '%'.</a>
<a name="ln1791">       */</a>
<a name="ln1792">      if (!cpo_match) {</a>
<a name="ln1793">        /* Are we before or at #if, #else etc.? */</a>
<a name="ln1794">        ptr = skipwhite(linep);</a>
<a name="ln1795">        if (*ptr == '#' &amp;&amp; pos.col &lt;= (colnr_T)(ptr - linep)) {</a>
<a name="ln1796">          ptr = skipwhite(ptr + 1);</a>
<a name="ln1797">          if (   STRNCMP(ptr, &quot;if&quot;, 2) == 0</a>
<a name="ln1798">                 || STRNCMP(ptr, &quot;endif&quot;, 5) == 0</a>
<a name="ln1799">                 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1800">            hash_dir = 1;</a>
<a name="ln1801">        }</a>
<a name="ln1802">        /* Are we on a comment? */</a>
<a name="ln1803">        else if (linep[pos.col] == '/') {</a>
<a name="ln1804">          if (linep[pos.col + 1] == '*') {</a>
<a name="ln1805">            comment_dir = FORWARD;</a>
<a name="ln1806">            backwards = false;</a>
<a name="ln1807">            pos.col++;</a>
<a name="ln1808">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '*') {</a>
<a name="ln1809">            comment_dir = BACKWARD;</a>
<a name="ln1810">            backwards = true;</a>
<a name="ln1811">            pos.col--;</a>
<a name="ln1812">          }</a>
<a name="ln1813">        } else if (linep[pos.col] == '*') {</a>
<a name="ln1814">          if (linep[pos.col + 1] == '/') {</a>
<a name="ln1815">            comment_dir = BACKWARD;</a>
<a name="ln1816">            backwards = true;</a>
<a name="ln1817">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '/') {</a>
<a name="ln1818">            comment_dir = FORWARD;</a>
<a name="ln1819">            backwards = false;</a>
<a name="ln1820">          }</a>
<a name="ln1821">        }</a>
<a name="ln1822">      }</a>
<a name="ln1823"> </a>
<a name="ln1824">      /*</a>
<a name="ln1825">       * If we are not on a comment or the # at the start of a line, then</a>
<a name="ln1826">       * look for brace anywhere on this line after the cursor.</a>
<a name="ln1827">       */</a>
<a name="ln1828">      if (!hash_dir &amp;&amp; !comment_dir) {</a>
<a name="ln1829">        /*</a>
<a name="ln1830">         * Find the brace under or after the cursor.</a>
<a name="ln1831">         * If beyond the end of the line, use the last character in</a>
<a name="ln1832">         * the line.</a>
<a name="ln1833">         */</a>
<a name="ln1834">        if (linep[pos.col] == NUL &amp;&amp; pos.col)</a>
<a name="ln1835">          --pos.col;</a>
<a name="ln1836">        for (;; ) {</a>
<a name="ln1837">          initc = PTR2CHAR(linep + pos.col);</a>
<a name="ln1838">          if (initc == NUL)</a>
<a name="ln1839">            break;</a>
<a name="ln1840"> </a>
<a name="ln1841">          find_mps_values(&amp;initc, &amp;findc, &amp;backwards, false);</a>
<a name="ln1842">          if (findc) {</a>
<a name="ln1843">            break;</a>
<a name="ln1844">          }</a>
<a name="ln1845">          pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln1846">        }</a>
<a name="ln1847">        if (!findc) {</a>
<a name="ln1848">          /* no brace in the line, maybe use &quot;  #if&quot; then */</a>
<a name="ln1849">          if (!cpo_match &amp;&amp; *skipwhite(linep) == '#')</a>
<a name="ln1850">            hash_dir = 1;</a>
<a name="ln1851">          else</a>
<a name="ln1852">            return NULL;</a>
<a name="ln1853">        } else if (!cpo_bsl) {</a>
<a name="ln1854">          int col, bslcnt = 0;</a>
<a name="ln1855"> </a>
<a name="ln1856">          /* Set &quot;match_escaped&quot; if there are an odd number of</a>
<a name="ln1857">           * backslashes. */</a>
<a name="ln1858">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln1859">            bslcnt++;</a>
<a name="ln1860">          match_escaped = (bslcnt &amp; 1);</a>
<a name="ln1861">        }</a>
<a name="ln1862">      }</a>
<a name="ln1863">    }</a>
<a name="ln1864">    if (hash_dir) {</a>
<a name="ln1865">      /*</a>
<a name="ln1866">       * Look for matching #if, #else, #elif, or #endif</a>
<a name="ln1867">       */</a>
<a name="ln1868">      if (oap != NULL) {</a>
<a name="ln1869">        oap-&gt;motion_type = kMTLineWise;  // Linewise for this case only</a>
<a name="ln1870">      }</a>
<a name="ln1871">      if (initc != '#') {</a>
<a name="ln1872">        ptr = skipwhite(skipwhite(linep) + 1);</a>
<a name="ln1873">        if (STRNCMP(ptr, &quot;if&quot;, 2) == 0 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1874">          hash_dir = 1;</a>
<a name="ln1875">        else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1876">          hash_dir = -1;</a>
<a name="ln1877">        else</a>
<a name="ln1878">          return NULL;</a>
<a name="ln1879">      }</a>
<a name="ln1880">      pos.col = 0;</a>
<a name="ln1881">      while (!got_int) {</a>
<a name="ln1882">        if (hash_dir &gt; 0) {</a>
<a name="ln1883">          if (pos.lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1884">            break;</a>
<a name="ln1885">        } else if (pos.lnum == 1)</a>
<a name="ln1886">          break;</a>
<a name="ln1887">        pos.lnum += hash_dir;</a>
<a name="ln1888">        linep = ml_get(pos.lnum);</a>
<a name="ln1889">        line_breakcheck();              /* check for CTRL-C typed */</a>
<a name="ln1890">        ptr = skipwhite(linep);</a>
<a name="ln1891">        if (*ptr != '#')</a>
<a name="ln1892">          continue;</a>
<a name="ln1893">        pos.col = (colnr_T) (ptr - linep);</a>
<a name="ln1894">        ptr = skipwhite(ptr + 1);</a>
<a name="ln1895">        if (hash_dir &gt; 0) {</a>
<a name="ln1896">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0)</a>
<a name="ln1897">            count++;</a>
<a name="ln1898">          else if (STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1899">            if (count == 0)</a>
<a name="ln1900">              return &amp;pos;</a>
<a name="ln1901">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0) {</a>
<a name="ln1902">            if (count == 0)</a>
<a name="ln1903">              return &amp;pos;</a>
<a name="ln1904">            count--;</a>
<a name="ln1905">          }</a>
<a name="ln1906">        } else {</a>
<a name="ln1907">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0) {</a>
<a name="ln1908">            if (count == 0)</a>
<a name="ln1909">              return &amp;pos;</a>
<a name="ln1910">            count--;</a>
<a name="ln1911">          } else if (initc == '#' &amp;&amp; STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1912">            if (count == 0)</a>
<a name="ln1913">              return &amp;pos;</a>
<a name="ln1914">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1915">            count++;</a>
<a name="ln1916">        }</a>
<a name="ln1917">      }</a>
<a name="ln1918">      return NULL;</a>
<a name="ln1919">    }</a>
<a name="ln1920">  }</a>
<a name="ln1921"> </a>
<a name="ln1922">  // This is just guessing: when 'rightleft' is set, search for a matching</a>
<a name="ln1923">  // paren/brace in the other direction.</a>
<a name="ln1924">  if (curwin-&gt;w_p_rl &amp;&amp; vim_strchr((char_u *)&quot;()[]{}&lt;&gt;&quot;, initc) != NULL) {</a>
<a name="ln1925">    backwards = !backwards;</a>
<a name="ln1926">  }</a>
<a name="ln1927"> </a>
<a name="ln1928">  int do_quotes = -1;                 // check for quotes in current line</a>
<a name="ln1929">  int at_start;                       // do_quotes value at start position</a>
<a name="ln1930">  TriState start_in_quotes = kNone;   // start position is in quotes</a>
<a name="ln1931">  pos_T match_pos;                    // Where last slash-star was found</a>
<a name="ln1932">  clearpos(&amp;match_pos);</a>
<a name="ln1933"> </a>
<a name="ln1934">  /* backward search: Check if this line contains a single-line comment */</a>
<a name="ln1935">  if ((backwards &amp;&amp; comment_dir)</a>
<a name="ln1936">      || lisp</a>
<a name="ln1937">      )</a>
<a name="ln1938">    comment_col = check_linecomment(linep);</a>
<a name="ln1939">  if (lisp &amp;&amp; comment_col != MAXCOL &amp;&amp; pos.col &gt; (colnr_T)comment_col) {</a>
<a name="ln1940">    lispcomm = true;        // find match inside this comment</a>
<a name="ln1941">  }</a>
<a name="ln1942">  while (!got_int) {</a>
<a name="ln1943">    /*</a>
<a name="ln1944">     * Go to the next position, forward or backward. We could use</a>
<a name="ln1945">     * inc() and dec() here, but that is much slower</a>
<a name="ln1946">     */</a>
<a name="ln1947">    if (backwards) {</a>
<a name="ln1948">      /* char to match is inside of comment, don't search outside */</a>
<a name="ln1949">      if (lispcomm &amp;&amp; pos.col &lt; (colnr_T)comment_col)</a>
<a name="ln1950">        break;</a>
<a name="ln1951">      if (pos.col == 0) {               /* at start of line, go to prev. one */</a>
<a name="ln1952">        if (pos.lnum == 1)              /* start of file */</a>
<a name="ln1953">          break;</a>
<a name="ln1954">        --pos.lnum;</a>
<a name="ln1955"> </a>
<a name="ln1956">        if (maxtravel &gt; 0 &amp;&amp; ++traveled &gt; maxtravel)</a>
<a name="ln1957">          break;</a>
<a name="ln1958"> </a>
<a name="ln1959">        linep = ml_get(pos.lnum);</a>
<a name="ln1960">        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */</a>
<a name="ln1961">        do_quotes = -1;</a>
<a name="ln1962">        line_breakcheck();</a>
<a name="ln1963"> </a>
<a name="ln1964">        /* Check if this line contains a single-line comment */</a>
<a name="ln1965">        if (comment_dir</a>
<a name="ln1966">            || lisp</a>
<a name="ln1967">            )</a>
<a name="ln1968">          comment_col = check_linecomment(linep);</a>
<a name="ln1969">        /* skip comment */</a>
<a name="ln1970">        if (lisp &amp;&amp; comment_col != MAXCOL)</a>
<a name="ln1971">          pos.col = comment_col;</a>
<a name="ln1972">      } else {</a>
<a name="ln1973">        pos.col--;</a>
<a name="ln1974">        pos.col -= utf_head_off(linep, linep + pos.col);</a>
<a name="ln1975">      }</a>
<a name="ln1976">    } else {                          /* forward search */</a>
<a name="ln1977">      if (linep[pos.col] == NUL</a>
<a name="ln1978">          /* at end of line, go to next one */</a>
<a name="ln1979">          /* don't search for match in comment */</a>
<a name="ln1980">          || (lisp &amp;&amp; comment_col != MAXCOL</a>
<a name="ln1981">              &amp;&amp; pos.col == (colnr_T)comment_col)</a>
<a name="ln1982">          ) {</a>
<a name="ln1983">        if (pos.lnum == curbuf-&gt;b_ml.ml_line_count          /* end of file */</a>
<a name="ln1984">            /* line is exhausted and comment with it,</a>
<a name="ln1985">             * don't search for match in code */</a>
<a name="ln1986">            || lispcomm</a>
<a name="ln1987">            )</a>
<a name="ln1988">          break;</a>
<a name="ln1989">        ++pos.lnum;</a>
<a name="ln1990"> </a>
<a name="ln1991">        if (maxtravel &amp;&amp; traveled++ &gt; maxtravel)</a>
<a name="ln1992">          break;</a>
<a name="ln1993"> </a>
<a name="ln1994">        linep = ml_get(pos.lnum);</a>
<a name="ln1995">        pos.col = 0;</a>
<a name="ln1996">        do_quotes = -1;</a>
<a name="ln1997">        line_breakcheck();</a>
<a name="ln1998">        if (lisp)           /* find comment pos in new line */</a>
<a name="ln1999">          comment_col = check_linecomment(linep);</a>
<a name="ln2000">      } else {</a>
<a name="ln2001">        pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln2002">      }</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    // If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.</a>
<a name="ln2006">    if (pos.col == 0 &amp;&amp; (flags &amp; FM_BLOCKSTOP)</a>
<a name="ln2007">        &amp;&amp; (linep[0] == '{' || linep[0] == '}')) {</a>
<a name="ln2008">      if (linep[0] == findc &amp;&amp; count == 0) {  // match!</a>
<a name="ln2009">        return &amp;pos;</a>
<a name="ln2010">      }</a>
<a name="ln2011">      break;  // out of scope</a>
<a name="ln2012">    }</a>
<a name="ln2013"> </a>
<a name="ln2014">    if (comment_dir) {</a>
<a name="ln2015">      /* Note: comments do not nest, and we ignore quotes in them */</a>
<a name="ln2016">      /* TODO: ignore comment brackets inside strings */</a>
<a name="ln2017">      if (comment_dir == FORWARD) {</a>
<a name="ln2018">        if (linep[pos.col] == '*' &amp;&amp; linep[pos.col + 1] == '/') {</a>
<a name="ln2019">          pos.col++;</a>
<a name="ln2020">          return &amp;pos;</a>
<a name="ln2021">        }</a>
<a name="ln2022">      } else {    /* Searching backwards */</a>
<a name="ln2023">        /*</a>
<a name="ln2024">         * A comment may contain / * or / /, it may also start or end</a>
<a name="ln2025">         * with / * /. Ignore a / * after / / and after *.</a>
<a name="ln2026">         */</a>
<a name="ln2027">        if (pos.col == 0)</a>
<a name="ln2028">          continue;</a>
<a name="ln2029">        else if (raw_string)</a>
<a name="ln2030">        {</a>
<a name="ln2031">          if (linep[pos.col - 1] == 'R'</a>
<a name="ln2032">              &amp;&amp; linep[pos.col] == '&quot;'</a>
<a name="ln2033">              &amp;&amp; vim_strchr(linep + pos.col + 1, '(') != NULL)</a>
<a name="ln2034">          {</a>
<a name="ln2035">            /* Possible start of raw string. Now that we have the</a>
<a name="ln2036">             * delimiter we can check if it ends before where we</a>
<a name="ln2037">             * started searching, or before the previously found</a>
<a name="ln2038">             * raw string start. */</a>
<a name="ln2039">            if (!find_rawstring_end(linep, &amp;pos,</a>
<a name="ln2040">                  count &gt; 0 ? &amp;match_pos : &amp;curwin-&gt;w_cursor))</a>
<a name="ln2041">            {</a>
<a name="ln2042">              count++;</a>
<a name="ln2043">              match_pos = pos;</a>
<a name="ln2044">              match_pos.col--;</a>
<a name="ln2045">            }</a>
<a name="ln2046">            linep = ml_get(pos.lnum); /* may have been released */</a>
<a name="ln2047">          }</a>
<a name="ln2048">        } else if (  linep[pos.col - 1] == '/'</a>
<a name="ln2049">                   &amp;&amp; linep[pos.col] == '*'</a>
<a name="ln2050">                   &amp;&amp; (pos.col == 1 || linep[pos.col - 2] != '*')</a>
<a name="ln2051">                   &amp;&amp; (int)pos.col &lt; comment_col) {</a>
<a name="ln2052">          count++;</a>
<a name="ln2053">          match_pos = pos;</a>
<a name="ln2054">          match_pos.col--;</a>
<a name="ln2055">        } else if (linep[pos.col - 1] == '*' &amp;&amp; linep[pos.col] == '/') {</a>
<a name="ln2056">          if (count &gt; 0)</a>
<a name="ln2057">            pos = match_pos;</a>
<a name="ln2058">          else if (pos.col &gt; 1 &amp;&amp; linep[pos.col - 2] == '/'</a>
<a name="ln2059">                   &amp;&amp; (int)pos.col &lt;= comment_col)</a>
<a name="ln2060">            pos.col -= 2;</a>
<a name="ln2061">          else if (ignore_cend)</a>
<a name="ln2062">            continue;</a>
<a name="ln2063">          else</a>
<a name="ln2064">            return NULL;</a>
<a name="ln2065">          return &amp;pos;</a>
<a name="ln2066">        }</a>
<a name="ln2067">      }</a>
<a name="ln2068">      continue;</a>
<a name="ln2069">    }</a>
<a name="ln2070"> </a>
<a name="ln2071">    /*</a>
<a name="ln2072">     * If smart matching ('cpoptions' does not contain '%'), braces inside</a>
<a name="ln2073">     * of quotes are ignored, but only if there is an even number of</a>
<a name="ln2074">     * quotes in the line.</a>
<a name="ln2075">     */</a>
<a name="ln2076">    if (cpo_match)</a>
<a name="ln2077">      do_quotes = 0;</a>
<a name="ln2078">    else if (do_quotes == -1) {</a>
<a name="ln2079">      /*</a>
<a name="ln2080">       * Count the number of quotes in the line, skipping \&quot; and '&quot;'.</a>
<a name="ln2081">       * Watch out for &quot;\\&quot;.</a>
<a name="ln2082">       */</a>
<a name="ln2083">      at_start = do_quotes;</a>
<a name="ln2084">      for (ptr = linep; *ptr; ++ptr) {</a>
<a name="ln2085">        if (ptr == linep + pos.col + backwards)</a>
<a name="ln2086">          at_start = (do_quotes &amp; 1);</a>
<a name="ln2087">        if (*ptr == '&quot;'</a>
<a name="ln2088">            &amp;&amp; (ptr == linep || ptr[-1] != '\'' || ptr[1] != '\''))</a>
<a name="ln2089">          ++do_quotes;</a>
<a name="ln2090">        if (*ptr == '\\' &amp;&amp; ptr[1] != NUL)</a>
<a name="ln2091">          ++ptr;</a>
<a name="ln2092">      }</a>
<a name="ln2093">      do_quotes &amp;= 1;               /* result is 1 with even number of quotes */</a>
<a name="ln2094"> </a>
<a name="ln2095">      /*</a>
<a name="ln2096">       * If we find an uneven count, check current line and previous</a>
<a name="ln2097">       * one for a '\' at the end.</a>
<a name="ln2098">       */</a>
<a name="ln2099">      if (!do_quotes) {</a>
<a name="ln2100">        inquote = false;</a>
<a name="ln2101">        if (ptr[-1] == '\\') {</a>
<a name="ln2102">          do_quotes = 1;</a>
<a name="ln2103">          if (start_in_quotes == kNone) {</a>
<a name="ln2104">            // Do we need to use at_start here?</a>
<a name="ln2105">            inquote = true;</a>
<a name="ln2106">            start_in_quotes = kTrue;</a>
<a name="ln2107">          } else if (backwards) {</a>
<a name="ln2108">            inquote = true;</a>
<a name="ln2109">          }</a>
<a name="ln2110">        }</a>
<a name="ln2111">        if (pos.lnum &gt; 1) {</a>
<a name="ln2112">          ptr = ml_get(pos.lnum - 1);</a>
<a name="ln2113">          if (*ptr &amp;&amp; *(ptr + STRLEN(ptr) - 1) == '\\') {</a>
<a name="ln2114">            do_quotes = 1;</a>
<a name="ln2115">            if (start_in_quotes == kNone) {</a>
<a name="ln2116">              inquote = at_start;</a>
<a name="ln2117">              if (inquote) {</a>
<a name="ln2118">                start_in_quotes = kTrue;</a>
<a name="ln2119">              }</a>
<a name="ln2120">            } else if (!backwards) {</a>
<a name="ln2121">              inquote = true;</a>
<a name="ln2122">            }</a>
<a name="ln2123">          }</a>
<a name="ln2124"> </a>
<a name="ln2125">          /* ml_get() only keeps one line, need to get linep again */</a>
<a name="ln2126">          linep = ml_get(pos.lnum);</a>
<a name="ln2127">        }</a>
<a name="ln2128">      }</a>
<a name="ln2129">    }</a>
<a name="ln2130">    if (start_in_quotes == kNone) {</a>
<a name="ln2131">      start_in_quotes = kFalse;</a>
<a name="ln2132">    }</a>
<a name="ln2133"> </a>
<a name="ln2134">    /*</a>
<a name="ln2135">     * If 'smartmatch' is set:</a>
<a name="ln2136">     *   Things inside quotes are ignored by setting 'inquote'.  If we</a>
<a name="ln2137">     *   find a quote without a preceding '\' invert 'inquote'.  At the</a>
<a name="ln2138">     *   end of a line not ending in '\' we reset 'inquote'.</a>
<a name="ln2139">     *</a>
<a name="ln2140">     *   In lines with an uneven number of quotes (without preceding '\')</a>
<a name="ln2141">     *   we do not know which part to ignore. Therefore we only set</a>
<a name="ln2142">     *   inquote if the number of quotes in a line is even, unless this</a>
<a name="ln2143">     *   line or the previous one ends in a '\'.  Complicated, isn't it?</a>
<a name="ln2144">     */</a>
<a name="ln2145">    const int c = PTR2CHAR(linep + pos.col);</a>
<a name="ln2146">    switch (c) {</a>
<a name="ln2147">    case NUL:</a>
<a name="ln2148">      /* at end of line without trailing backslash, reset inquote */</a>
<a name="ln2149">      if (pos.col == 0 || linep[pos.col - 1] != '\\') {</a>
<a name="ln2150">        inquote = false;</a>
<a name="ln2151">        start_in_quotes = kFalse;</a>
<a name="ln2152">      }</a>
<a name="ln2153">      break;</a>
<a name="ln2154"> </a>
<a name="ln2155">    case '&quot;':</a>
<a name="ln2156">      /* a quote that is preceded with an odd number of backslashes is</a>
<a name="ln2157">       * ignored */</a>
<a name="ln2158">      if (do_quotes) {</a>
<a name="ln2159">        int col;</a>
<a name="ln2160"> </a>
<a name="ln2161">        for (col = pos.col - 1; col &gt;= 0; --col)</a>
<a name="ln2162">          if (linep[col] != '\\')</a>
<a name="ln2163">            break;</a>
<a name="ln2164">        if ((((int)pos.col - 1 - col) &amp; 1) == 0) {</a>
<a name="ln2165">          inquote = !inquote;</a>
<a name="ln2166">          start_in_quotes = kFalse;</a>
<a name="ln2167">        }</a>
<a name="ln2168">      }</a>
<a name="ln2169">      break;</a>
<a name="ln2170"> </a>
<a name="ln2171">    /*</a>
<a name="ln2172">     * If smart matching ('cpoptions' does not contain '%'):</a>
<a name="ln2173">     *   Skip things in single quotes: 'x' or '\x'.  Be careful for single</a>
<a name="ln2174">     *   single quotes, eg jon's.  Things like '\233' or '\x3f' are not</a>
<a name="ln2175">     *   skipped, there is never a brace in them.</a>
<a name="ln2176">     *   Ignore this when finding matches for `'.</a>
<a name="ln2177">     */</a>
<a name="ln2178">    case '\'':</a>
<a name="ln2179">      if (!cpo_match &amp;&amp; initc != '\'' &amp;&amp; findc != '\'') {</a>
<a name="ln2180">        if (backwards) {</a>
<a name="ln2181">          if (pos.col &gt; 1) {</a>
<a name="ln2182">            if (linep[pos.col - 2] == '\'') {</a>
<a name="ln2183">              pos.col -= 2;</a>
<a name="ln2184">              break;</a>
<a name="ln2185">            } else if (linep[pos.col - 2] == '\\'</a>
<a name="ln2186">                       &amp;&amp; pos.col &gt; 2 &amp;&amp; linep[pos.col - 3] == '\'') {</a>
<a name="ln2187">              pos.col -= 3;</a>
<a name="ln2188">              break;</a>
<a name="ln2189">            }</a>
<a name="ln2190">          }</a>
<a name="ln2191">        } else if (linep[pos.col + 1]) {  // forward search</a>
<a name="ln2192">          if (linep[pos.col + 1] == '\\'</a>
<a name="ln2193">              &amp;&amp; linep[pos.col + 2] &amp;&amp; linep[pos.col + 3] == '\'') {</a>
<a name="ln2194">            pos.col += 3;</a>
<a name="ln2195">            break;</a>
<a name="ln2196">          } else if (linep[pos.col + 2] == '\'') {</a>
<a name="ln2197">            pos.col += 2;</a>
<a name="ln2198">            break;</a>
<a name="ln2199">          }</a>
<a name="ln2200">        }</a>
<a name="ln2201">      }</a>
<a name="ln2202">      FALLTHROUGH;</a>
<a name="ln2203"> </a>
<a name="ln2204">    default:</a>
<a name="ln2205">      /*</a>
<a name="ln2206">       * For Lisp skip over backslashed (), {} and [].</a>
<a name="ln2207">       * (actually, we skip #\( et al)</a>
<a name="ln2208">       */</a>
<a name="ln2209">      if (curbuf-&gt;b_p_lisp</a>
<a name="ln2210">          &amp;&amp; vim_strchr((char_u *)&quot;(){}[]&quot;, c) != NULL</a>
<a name="ln2211">          &amp;&amp; pos.col &gt; 1</a>
<a name="ln2212">          &amp;&amp; check_prevcol(linep, pos.col, '\\', NULL)</a>
<a name="ln2213">          &amp;&amp; check_prevcol(linep, pos.col - 1, '#', NULL))</a>
<a name="ln2214">        break;</a>
<a name="ln2215"> </a>
<a name="ln2216">      /* Check for match outside of quotes, and inside of</a>
<a name="ln2217">       * quotes when the start is also inside of quotes. */</a>
<a name="ln2218">      if ((!inquote || start_in_quotes == kTrue)</a>
<a name="ln2219">          &amp;&amp; (c == initc || c == findc)) {</a>
<a name="ln2220">        int col, bslcnt = 0;</a>
<a name="ln2221"> </a>
<a name="ln2222">        if (!cpo_bsl) {</a>
<a name="ln2223">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln2224">            bslcnt++;</a>
<a name="ln2225">        }</a>
<a name="ln2226">        /* Only accept a match when 'M' is in 'cpo' or when escaping</a>
<a name="ln2227">         * is what we expect. */</a>
<a name="ln2228">        if (cpo_bsl || (bslcnt &amp; 1) == match_escaped) {</a>
<a name="ln2229">          if (c == initc)</a>
<a name="ln2230">            count++;</a>
<a name="ln2231">          else {</a>
<a name="ln2232">            if (count == 0)</a>
<a name="ln2233">              return &amp;pos;</a>
<a name="ln2234">            count--;</a>
<a name="ln2235">          }</a>
<a name="ln2236">        }</a>
<a name="ln2237">      }</a>
<a name="ln2238">    }</a>
<a name="ln2239">  }</a>
<a name="ln2240"> </a>
<a name="ln2241">  if (comment_dir == BACKWARD &amp;&amp; count &gt; 0) {</a>
<a name="ln2242">    pos = match_pos;</a>
<a name="ln2243">    return &amp;pos;</a>
<a name="ln2244">  }</a>
<a name="ln2245">  return (pos_T *)NULL;         /* never found it */</a>
<a name="ln2246">}</a>
<a name="ln2247"> </a>
<a name="ln2248">/*</a>
<a name="ln2249"> * Check if line[] contains a / / comment.</a>
<a name="ln2250"> * Return MAXCOL if not, otherwise return the column.</a>
<a name="ln2251"> * TODO: skip strings.</a>
<a name="ln2252"> */</a>
<a name="ln2253">static int check_linecomment(const char_u *line)</a>
<a name="ln2254">{</a>
<a name="ln2255">  const char_u *p = line;  // scan from start</a>
<a name="ln2256">  // skip Lispish one-line comments</a>
<a name="ln2257">  if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln2258">    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */</a>
<a name="ln2259">      int in_str = FALSE;       /* inside of string */</a>
<a name="ln2260"> </a>
<a name="ln2261">      while ((p = vim_strpbrk(p, (char_u *)&quot;\&quot;;&quot;)) != NULL) {</a>
<a name="ln2262">        if (*p == '&quot;') {</a>
<a name="ln2263">          if (in_str) {</a>
<a name="ln2264">            if (*(p - 1) != '\\')             /* skip escaped quote */</a>
<a name="ln2265">              in_str = FALSE;</a>
<a name="ln2266">          } else if (p == line || ((p - line) &gt;= 2</a>
<a name="ln2267">                                   /* skip #\&quot; form */</a>
<a name="ln2268">                                   &amp;&amp; *(p - 1) != '\\' &amp;&amp; *(p - 2) != '#'))</a>
<a name="ln2269">            in_str = TRUE;</a>
<a name="ln2270">        } else if (!in_str &amp;&amp; ((p - line) &lt; 2</a>
<a name="ln2271">                               || (*(p - 1) != '\\' &amp;&amp; *(p - 2) != '#')))</a>
<a name="ln2272">          break;                /* found! */</a>
<a name="ln2273">        ++p;</a>
<a name="ln2274">      }</a>
<a name="ln2275">    } else</a>
<a name="ln2276">      p = NULL;</a>
<a name="ln2277">  } else</a>
<a name="ln2278">    while ((p = vim_strchr(p, '/')) != NULL) {</a>
<a name="ln2279">      /* accept a double /, unless it's preceded with * and followed by *,</a>
<a name="ln2280">       * because * / / * is an end and start of a C comment */</a>
<a name="ln2281">      if (p[1] == '/' &amp;&amp; (p == line || p[-1] != '*' || p[2] != '*'))</a>
<a name="ln2282">        break;</a>
<a name="ln2283">      ++p;</a>
<a name="ln2284">    }</a>
<a name="ln2285"> </a>
<a name="ln2286">  if (p == NULL)</a>
<a name="ln2287">    return MAXCOL;</a>
<a name="ln2288">  return (int)(p - line);</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">/*</a>
<a name="ln2292"> * Move cursor briefly to character matching the one under the cursor.</a>
<a name="ln2293"> * Used for Insert mode and &quot;r&quot; command.</a>
<a name="ln2294"> * Show the match only if it is visible on the screen.</a>
<a name="ln2295"> * If there isn't a match, then beep.</a>
<a name="ln2296"> */</a>
<a name="ln2297">void</a>
<a name="ln2298">showmatch(</a>
<a name="ln2299">    int c                      // char to show match for</a>
<a name="ln2300">)</a>
<a name="ln2301">{</a>
<a name="ln2302">  pos_T       *lpos, save_cursor;</a>
<a name="ln2303">  pos_T mpos;</a>
<a name="ln2304">  colnr_T vcol;</a>
<a name="ln2305">  long *so = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2306">  long *siso = curwin-&gt;w_p_siso &gt;= 0 ? &amp;curwin-&gt;w_p_siso : &amp;p_siso;</a>
<a name="ln2307">  long save_so;</a>
<a name="ln2308">  long save_siso;</a>
<a name="ln2309">  int save_state;</a>
<a name="ln2310">  colnr_T save_dollar_vcol;</a>
<a name="ln2311">  char_u      *p;</a>
<a name="ln2312"> </a>
<a name="ln2313">  /*</a>
<a name="ln2314">   * Only show match for chars in the 'matchpairs' option.</a>
<a name="ln2315">   */</a>
<a name="ln2316">  /* 'matchpairs' is &quot;x:y,x:y&quot; */</a>
<a name="ln2317">  for (p = curbuf-&gt;b_p_mps; *p != NUL; ++p) {</a>
<a name="ln2318">    if (PTR2CHAR(p) == c &amp;&amp; (curwin-&gt;w_p_rl ^ p_ri))</a>
<a name="ln2319">      break;</a>
<a name="ln2320">    p += utfc_ptr2len(p) + 1;</a>
<a name="ln2321">    if (PTR2CHAR(p) == c &amp;&amp; !(curwin-&gt;w_p_rl ^ p_ri)) {</a>
<a name="ln2322">      break;</a>
<a name="ln2323">    }</a>
<a name="ln2324">    p += utfc_ptr2len(p);</a>
<a name="ln2325">    if (*p == NUL) {</a>
<a name="ln2326">      return;</a>
<a name="ln2327">    }</a>
<a name="ln2328">  }</a>
<a name="ln2329"> </a>
<a name="ln2330">  if ((lpos = findmatch(NULL, NUL)) == NULL) {  // no match, so beep</a>
<a name="ln2331">    vim_beep(BO_MATCH);</a>
<a name="ln2332">  } else if (lpos-&gt;lnum &gt;= curwin-&gt;w_topline</a>
<a name="ln2333">      &amp;&amp; lpos-&gt;lnum &lt; curwin-&gt;w_botline) {</a>
<a name="ln2334">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln2335">      getvcol(curwin, lpos, NULL, &amp;vcol, NULL);</a>
<a name="ln2336">    }</a>
<a name="ln2337">    if (curwin-&gt;w_p_wrap</a>
<a name="ln2338">        || (vcol &gt;= curwin-&gt;w_leftcol</a>
<a name="ln2339">            &amp;&amp; vcol &lt; curwin-&gt;w_leftcol + curwin-&gt;w_width_inner)) {</a>
<a name="ln2340">      mpos = *lpos;  // save the pos, update_screen() may change it</a>
<a name="ln2341">      save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2342">      save_so = *so;</a>
<a name="ln2343">      save_siso = *siso;</a>
<a name="ln2344">      // Handle &quot;$&quot; in 'cpo': If the ')' is typed on top of the &quot;$&quot;,</a>
<a name="ln2345">      // stop displaying the &quot;$&quot;.</a>
<a name="ln2346">      if (dollar_vcol &gt;= 0 &amp;&amp; dollar_vcol == curwin-&gt;w_virtcol) {</a>
<a name="ln2347">        dollar_vcol = -1;</a>
<a name="ln2348">      }</a>
<a name="ln2349">      curwin-&gt;w_virtcol++;              // do display ')' just before &quot;$&quot;</a>
<a name="ln2350">      update_screen(VALID);             // show the new char first</a>
<a name="ln2351"> </a>
<a name="ln2352">      save_dollar_vcol = dollar_vcol;</a>
<a name="ln2353">      save_state = State;</a>
<a name="ln2354">      State = SHOWMATCH;</a>
<a name="ln2355">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2356">      curwin-&gt;w_cursor = mpos;          // move to matching char</a>
<a name="ln2357">      *so = 0;                          // don't use 'scrolloff' here</a>
<a name="ln2358">      *siso = 0;                        // don't use 'sidescrolloff' here</a>
<a name="ln2359">      showruler(false);</a>
<a name="ln2360">      setcursor();</a>
<a name="ln2361">      ui_flush();</a>
<a name="ln2362">      /* Restore dollar_vcol(), because setcursor() may call curs_rows()</a>
<a name="ln2363">       * which resets it if the matching position is in a previous line</a>
<a name="ln2364">       * and has a higher column number. */</a>
<a name="ln2365">      dollar_vcol = save_dollar_vcol;</a>
<a name="ln2366"> </a>
<a name="ln2367">      /*</a>
<a name="ln2368">       * brief pause, unless 'm' is present in 'cpo' and a character is</a>
<a name="ln2369">       * available.</a>
<a name="ln2370">       */</a>
<a name="ln2371">      if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL)</a>
<a name="ln2372">        os_delay(p_mat * 100L, true);</a>
<a name="ln2373">      else if (!char_avail())</a>
<a name="ln2374">        os_delay(p_mat * 100L, false);</a>
<a name="ln2375">      curwin-&gt;w_cursor = save_cursor;           // restore cursor position</a>
<a name="ln2376">      *so = save_so;</a>
<a name="ln2377">      *siso = save_siso;</a>
<a name="ln2378">      State = save_state;</a>
<a name="ln2379">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2380">    }</a>
<a name="ln2381">  }</a>
<a name="ln2382">}</a>
<a name="ln2383"> </a>
<a name="ln2384">// Find the start of the next sentence, searching in the direction specified</a>
<a name="ln2385">// by the &quot;dir&quot; argument.  The cursor is positioned on the start of the next</a>
<a name="ln2386">// sentence when found.  If the next sentence is found, return OK.  Return FAIL</a>
<a name="ln2387">// otherwise.  See &quot;:h sentence&quot; for the precise definition of a &quot;sentence&quot;</a>
<a name="ln2388">// text object.</a>
<a name="ln2389">int findsent(Direction dir, long count)</a>
<a name="ln2390">{</a>
<a name="ln2391">  pos_T pos, tpos;</a>
<a name="ln2392">  int c;</a>
<a name="ln2393">  int         (*func)(pos_T *);</a>
<a name="ln2394">  bool noskip = false;              // do not skip blanks</a>
<a name="ln2395"> </a>
<a name="ln2396">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2397">  if (dir == FORWARD)</a>
<a name="ln2398">    func = incl;</a>
<a name="ln2399">  else</a>
<a name="ln2400">    func = decl;</a>
<a name="ln2401"> </a>
<a name="ln2402">  while (count--) {</a>
<a name="ln2403">    const pos_T prev_pos = pos;</a>
<a name="ln2404"> </a>
<a name="ln2405">    // if on an empty line, skip up to a non-empty line</a>
<a name="ln2406">    if (gchar_pos(&amp;pos) == NUL) {</a>
<a name="ln2407">      do {</a>
<a name="ln2408">        if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2409">          break;</a>
<a name="ln2410">        }</a>
<a name="ln2411">      } while (gchar_pos(&amp;pos) == NUL);</a>
<a name="ln2412">      if (dir == FORWARD) {</a>
<a name="ln2413">        goto found;</a>
<a name="ln2414">      }</a>
<a name="ln2415">    // if on the start of a paragraph or a section and searching forward,</a>
<a name="ln2416">    // go to the next line</a>
<a name="ln2417">    } else if (dir == FORWARD &amp;&amp; pos.col == 0</a>
<a name="ln2418">               &amp;&amp; startPS(pos.lnum, NUL, false)) {</a>
<a name="ln2419">      if (pos.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2420">        return FAIL;</a>
<a name="ln2421">      }</a>
<a name="ln2422">      pos.lnum++;</a>
<a name="ln2423">      goto found;</a>
<a name="ln2424">    } else if (dir == BACKWARD) {</a>
<a name="ln2425">      decl(&amp;pos);</a>
<a name="ln2426">    }</a>
<a name="ln2427"> </a>
<a name="ln2428">    // go back to the previous non-white non-punctuation character</a>
<a name="ln2429">    bool found_dot = false;</a>
<a name="ln2430">    while (c = gchar_pos(&amp;pos), ascii_iswhite(c)</a>
<a name="ln2431">           || vim_strchr((char_u *)&quot;.!?)]\&quot;'&quot;, c) != NULL) {</a>
<a name="ln2432">      tpos = pos;</a>
<a name="ln2433">      if (decl(&amp;tpos) == -1 || (LINEEMPTY(tpos.lnum) &amp;&amp; dir == FORWARD)) {</a>
<a name="ln2434">        break;</a>
<a name="ln2435">      }</a>
<a name="ln2436">      if (found_dot) {</a>
<a name="ln2437">        break;</a>
<a name="ln2438">      }</a>
<a name="ln2439">      if (vim_strchr((char_u *) &quot;.!?&quot;, c) != NULL) {</a>
<a name="ln2440">        found_dot = true;</a>
<a name="ln2441">      }</a>
<a name="ln2442">      if (vim_strchr((char_u *) &quot;)]\&quot;'&quot;, c) != NULL</a>
<a name="ln2443">          &amp;&amp; vim_strchr((char_u *) &quot;.!?)]\&quot;'&quot;, gchar_pos(&amp;tpos)) == NULL) {</a>
<a name="ln2444">        break;</a>
<a name="ln2445">      }</a>
<a name="ln2446">      decl(&amp;pos);</a>
<a name="ln2447">    }</a>
<a name="ln2448"> </a>
<a name="ln2449">    // remember the line where the search started</a>
<a name="ln2450">    const int startlnum = pos.lnum;</a>
<a name="ln2451">    const bool cpo_J = vim_strchr(p_cpo, CPO_ENDOFSENT) != NULL;</a>
<a name="ln2452"> </a>
<a name="ln2453">    for (;; ) {                 /* find end of sentence */</a>
<a name="ln2454">      c = gchar_pos(&amp;pos);</a>
<a name="ln2455">      if (c == NUL || (pos.col == 0 &amp;&amp; startPS(pos.lnum, NUL, FALSE))) {</a>
<a name="ln2456">        if (dir == BACKWARD &amp;&amp; pos.lnum != startlnum)</a>
<a name="ln2457">          ++pos.lnum;</a>
<a name="ln2458">        break;</a>
<a name="ln2459">      }</a>
<a name="ln2460">      if (c == '.' || c == '!' || c == '?') {</a>
<a name="ln2461">        tpos = pos;</a>
<a name="ln2462">        do</a>
<a name="ln2463">          if ((c = inc(&amp;tpos)) == -1)</a>
<a name="ln2464">            break;</a>
<a name="ln2465">        while (vim_strchr((char_u *)&quot;)]\&quot;'&quot;, c = gchar_pos(&amp;tpos))</a>
<a name="ln2466">               != NULL);</a>
<a name="ln2467">        if (c == -1  || (!cpo_J &amp;&amp; (c == ' ' || c == '\t')) || c == NUL</a>
<a name="ln2468">            || (cpo_J &amp;&amp; (c == ' ' &amp;&amp; inc(&amp;tpos) &gt;= 0</a>
<a name="ln2469">                          &amp;&amp; gchar_pos(&amp;tpos) == ' '))) {</a>
<a name="ln2470">          pos = tpos;</a>
<a name="ln2471">          if (gchar_pos(&amp;pos) == NUL)           /* skip NUL at EOL */</a>
<a name="ln2472">            inc(&amp;pos);</a>
<a name="ln2473">          break;</a>
<a name="ln2474">        }</a>
<a name="ln2475">      }</a>
<a name="ln2476">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2477">        if (count)</a>
<a name="ln2478">          return FAIL;</a>
<a name="ln2479">        noskip = true;</a>
<a name="ln2480">        break;</a>
<a name="ln2481">      }</a>
<a name="ln2482">    }</a>
<a name="ln2483">found:</a>
<a name="ln2484">    /* skip white space */</a>
<a name="ln2485">    while (!noskip &amp;&amp; ((c = gchar_pos(&amp;pos)) == ' ' || c == '\t'))</a>
<a name="ln2486">      if (incl(&amp;pos) == -1)</a>
<a name="ln2487">        break;</a>
<a name="ln2488"> </a>
<a name="ln2489">    if (equalpos(prev_pos, pos)) {</a>
<a name="ln2490">      // didn't actually move, advance one character and try again</a>
<a name="ln2491">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2492">        if (count) {</a>
<a name="ln2493">          return FAIL;</a>
<a name="ln2494">        }</a>
<a name="ln2495">        break;</a>
<a name="ln2496">      }</a>
<a name="ln2497">      count++;</a>
<a name="ln2498">    }</a>
<a name="ln2499">  }</a>
<a name="ln2500"> </a>
<a name="ln2501">  setpcmark();</a>
<a name="ln2502">  curwin-&gt;w_cursor = pos;</a>
<a name="ln2503">  return OK;</a>
<a name="ln2504">}</a>
<a name="ln2505"> </a>
<a name="ln2506">/*</a>
<a name="ln2507"> * Find the next paragraph or section in direction 'dir'.</a>
<a name="ln2508"> * Paragraphs are currently supposed to be separated by empty lines.</a>
<a name="ln2509"> * If 'what' is NUL we go to the next paragraph.</a>
<a name="ln2510"> * If 'what' is '{' or '}' we go to the next section.</a>
<a name="ln2511"> * If 'both' is TRUE also stop at '}'.</a>
<a name="ln2512"> * Return TRUE if the next paragraph or section was found.</a>
<a name="ln2513"> */</a>
<a name="ln2514">bool</a>
<a name="ln2515">findpar (</a>
<a name="ln2516">    bool *pincl,        /* Return: true if last char is to be included */</a>
<a name="ln2517">    int dir,</a>
<a name="ln2518">    long count,</a>
<a name="ln2519">    int what,</a>
<a name="ln2520">    int both</a>
<a name="ln2521">)</a>
<a name="ln2522">{</a>
<a name="ln2523">  linenr_T curr;</a>
<a name="ln2524">  bool did_skip;            /* true after separating lines have been skipped */</a>
<a name="ln2525">  bool first;               /* true on first line */</a>
<a name="ln2526">  linenr_T fold_first;      /* first line of a closed fold */</a>
<a name="ln2527">  linenr_T fold_last;       /* last line of a closed fold */</a>
<a name="ln2528">  bool fold_skipped;        /* true if a closed fold was skipped this</a>
<a name="ln2529">                               iteration */</a>
<a name="ln2530"> </a>
<a name="ln2531">  curr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2532"> </a>
<a name="ln2533">  while (count--) {</a>
<a name="ln2534">    did_skip = false;</a>
<a name="ln2535">    for (first = true;; first = false) {</a>
<a name="ln2536">      if (*ml_get(curr) != NUL)</a>
<a name="ln2537">        did_skip = true;</a>
<a name="ln2538"> </a>
<a name="ln2539">      /* skip folded lines */</a>
<a name="ln2540">      fold_skipped = false;</a>
<a name="ln2541">      if (first &amp;&amp; hasFolding(curr, &amp;fold_first, &amp;fold_last)) {</a>
<a name="ln2542">        curr = ((dir &gt; 0) ? fold_last : fold_first) + dir;</a>
<a name="ln2543">        fold_skipped = true;</a>
<a name="ln2544">      }</a>
<a name="ln2545"> </a>
<a name="ln2546">      if (!first &amp;&amp; did_skip &amp;&amp; startPS(curr, what, both))</a>
<a name="ln2547">        break;</a>
<a name="ln2548"> </a>
<a name="ln2549">      if (fold_skipped)</a>
<a name="ln2550">        curr -= dir;</a>
<a name="ln2551">      if ((curr += dir) &lt; 1 || curr &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2552">        if (count)</a>
<a name="ln2553">          return false;</a>
<a name="ln2554">        curr -= dir;</a>
<a name="ln2555">        break;</a>
<a name="ln2556">      }</a>
<a name="ln2557">    }</a>
<a name="ln2558">  }</a>
<a name="ln2559">  setpcmark();</a>
<a name="ln2560">  if (both &amp;&amp; *ml_get(curr) == '}')     /* include line with '}' */</a>
<a name="ln2561">    ++curr;</a>
<a name="ln2562">  curwin-&gt;w_cursor.lnum = curr;</a>
<a name="ln2563">  if (curr == curbuf-&gt;b_ml.ml_line_count &amp;&amp; what != '}') {</a>
<a name="ln2564">    char_u *line = ml_get(curr);</a>
<a name="ln2565"> </a>
<a name="ln2566">    // Put the cursor on the last character in the last line and make the</a>
<a name="ln2567">    // motion inclusive.</a>
<a name="ln2568">    if ((curwin-&gt;w_cursor.col = (colnr_T)STRLEN(line)) != 0) {</a>
<a name="ln2569">      curwin-&gt;w_cursor.col--;</a>
<a name="ln2570">      curwin-&gt;w_cursor.col -= utf_head_off(line, line + curwin-&gt;w_cursor.col);</a>
<a name="ln2571">      *pincl = true;</a>
<a name="ln2572">    }</a>
<a name="ln2573">  } else</a>
<a name="ln2574">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2575">  return true;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">/*</a>
<a name="ln2579"> * check if the string 's' is a nroff macro that is in option 'opt'</a>
<a name="ln2580"> */</a>
<a name="ln2581">static int inmacro(char_u *opt, char_u *s)</a>
<a name="ln2582">{</a>
<a name="ln2583">  char_u      *macro;</a>
<a name="ln2584"> </a>
<a name="ln2585">  for (macro = opt; macro[0]; ++macro) {</a>
<a name="ln2586">    /* Accept two characters in the option being equal to two characters</a>
<a name="ln2587">     * in the line.  A space in the option matches with a space in the</a>
<a name="ln2588">     * line or the line having ended. */</a>
<a name="ln2589">    if (       (macro[0] == s[0]</a>
<a name="ln2590">                || (macro[0] == ' '</a>
<a name="ln2591">                    &amp;&amp; (s[0] == NUL || s[0] == ' ')))</a>
<a name="ln2592">               &amp;&amp; (macro[1] == s[1]</a>
<a name="ln2593">                   || ((macro[1] == NUL || macro[1] == ' ')</a>
<a name="ln2594">                       &amp;&amp; (s[0] == NUL || s[1] == NUL || s[1] == ' '))))</a>
<a name="ln2595">      break;</a>
<a name="ln2596">    ++macro;</a>
<a name="ln2597">    if (macro[0] == NUL)</a>
<a name="ln2598">      break;</a>
<a name="ln2599">  }</a>
<a name="ln2600">  return macro[0] != NUL;</a>
<a name="ln2601">}</a>
<a name="ln2602"> </a>
<a name="ln2603">/*</a>
<a name="ln2604"> * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.</a>
<a name="ln2605"> * If 'para' is '{' or '}' only check for sections.</a>
<a name="ln2606"> * If 'both' is TRUE also stop at '}'</a>
<a name="ln2607"> */</a>
<a name="ln2608">int startPS(linenr_T lnum, int para, int both)</a>
<a name="ln2609">{</a>
<a name="ln2610">  char_u      *s;</a>
<a name="ln2611"> </a>
<a name="ln2612">  s = ml_get(lnum);</a>
<a name="ln2613">  if (*s == para || *s == '\f' || (both &amp;&amp; *s == '}')) {</a>
<a name="ln2614">    return true;</a>
<a name="ln2615">  }</a>
<a name="ln2616">  if (*s == '.' &amp;&amp; (inmacro(p_sections, s + 1)</a>
<a name="ln2617">                    || (!para &amp;&amp; inmacro(p_para, s + 1)))) {</a>
<a name="ln2618">    return true;</a>
<a name="ln2619">  }</a>
<a name="ln2620">  return false;</a>
<a name="ln2621">}</a>
<a name="ln2622"> </a>
<a name="ln2623">/*</a>
<a name="ln2624"> * The following routines do the word searches performed by the 'w', 'W',</a>
<a name="ln2625"> * 'b', 'B', 'e', and 'E' commands.</a>
<a name="ln2626"> */</a>
<a name="ln2627"> </a>
<a name="ln2628">/*</a>
<a name="ln2629"> * To perform these searches, characters are placed into one of three</a>
<a name="ln2630"> * classes, and transitions between classes determine word boundaries.</a>
<a name="ln2631"> *</a>
<a name="ln2632"> * The classes are:</a>
<a name="ln2633"> *</a>
<a name="ln2634"> * 0 - white space</a>
<a name="ln2635"> * 1 - punctuation</a>
<a name="ln2636"> * 2 or higher - keyword characters (letters, digits and underscore)</a>
<a name="ln2637"> */</a>
<a name="ln2638"> </a>
<a name="ln2639">static int cls_bigword;         /* TRUE for &quot;W&quot;, &quot;B&quot; or &quot;E&quot; */</a>
<a name="ln2640"> </a>
<a name="ln2641">/*</a>
<a name="ln2642"> * cls() - returns the class of character at curwin-&gt;w_cursor</a>
<a name="ln2643"> *</a>
<a name="ln2644"> * If a 'W', 'B', or 'E' motion is being done (cls_bigword == TRUE), chars</a>
<a name="ln2645"> * from class 2 and higher are reported as class 1 since only white space</a>
<a name="ln2646"> * boundaries are of interest.</a>
<a name="ln2647"> */</a>
<a name="ln2648">static int cls(void)</a>
<a name="ln2649">{</a>
<a name="ln2650">  int c;</a>
<a name="ln2651"> </a>
<a name="ln2652">  c = gchar_cursor();</a>
<a name="ln2653">  if (c == ' ' || c == '\t' || c == NUL) {</a>
<a name="ln2654">    return 0;</a>
<a name="ln2655">  }</a>
<a name="ln2656"> </a>
<a name="ln2657">  c = utf_class(c);</a>
<a name="ln2658"> </a>
<a name="ln2659">  // If cls_bigword is TRUE, report all non-blanks as class 1.</a>
<a name="ln2660">  if (c != 0 &amp;&amp; cls_bigword) {</a>
<a name="ln2661">    return 1;</a>
<a name="ln2662">  }</a>
<a name="ln2663">  return c;</a>
<a name="ln2664">}</a>
<a name="ln2665"> </a>
<a name="ln2666">/*</a>
<a name="ln2667"> * fwd_word(count, type, eol) - move forward one word</a>
<a name="ln2668"> *</a>
<a name="ln2669"> * Returns FAIL if the cursor was already at the end of the file.</a>
<a name="ln2670"> * If eol is TRUE, last word stops at end of line (for operators).</a>
<a name="ln2671"> */</a>
<a name="ln2672">int</a>
<a name="ln2673">fwd_word(</a>
<a name="ln2674">    long count,</a>
<a name="ln2675">    int bigword,                /* &quot;W&quot;, &quot;E&quot; or &quot;B&quot; */</a>
<a name="ln2676">    int eol</a>
<a name="ln2677">)</a>
<a name="ln2678">{</a>
<a name="ln2679">  int sclass;               /* starting class */</a>
<a name="ln2680">  int i;</a>
<a name="ln2681">  int last_line;</a>
<a name="ln2682"> </a>
<a name="ln2683">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2684">  cls_bigword = bigword;</a>
<a name="ln2685">  while (--count &gt;= 0) {</a>
<a name="ln2686">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2687">     * last line. */</a>
<a name="ln2688">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum))</a>
<a name="ln2689">      coladvance((colnr_T)MAXCOL);</a>
<a name="ln2690">    sclass = cls();</a>
<a name="ln2691"> </a>
<a name="ln2692">    /*</a>
<a name="ln2693">     * We always move at least one character, unless on the last</a>
<a name="ln2694">     * character in the buffer.</a>
<a name="ln2695">     */</a>
<a name="ln2696">    last_line = (curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln2697">    i = inc_cursor();</a>
<a name="ln2698">    if (i == -1 || (i &gt;= 1 &amp;&amp; last_line))     /* started at last char in file */</a>
<a name="ln2699">      return FAIL;</a>
<a name="ln2700">    if (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0)          /* started at last char in line */</a>
<a name="ln2701">      return OK;</a>
<a name="ln2702"> </a>
<a name="ln2703">    /*</a>
<a name="ln2704">     * Go one char past end of current word (if any)</a>
<a name="ln2705">     */</a>
<a name="ln2706">    if (sclass != 0)</a>
<a name="ln2707">      while (cls() == sclass) {</a>
<a name="ln2708">        i = inc_cursor();</a>
<a name="ln2709">        if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2710">          return OK;</a>
<a name="ln2711">      }</a>
<a name="ln2712"> </a>
<a name="ln2713">    /*</a>
<a name="ln2714">     * go to next non-white</a>
<a name="ln2715">     */</a>
<a name="ln2716">    while (cls() == 0) {</a>
<a name="ln2717">      /*</a>
<a name="ln2718">       * We'll stop if we land on a blank line</a>
<a name="ln2719">       */</a>
<a name="ln2720">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; *get_cursor_line_ptr() == NUL)</a>
<a name="ln2721">        break;</a>
<a name="ln2722"> </a>
<a name="ln2723">      i = inc_cursor();</a>
<a name="ln2724">      if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2725">        return OK;</a>
<a name="ln2726">    }</a>
<a name="ln2727">  }</a>
<a name="ln2728">  return OK;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">/*</a>
<a name="ln2732"> * bck_word() - move backward 'count' words</a>
<a name="ln2733"> *</a>
<a name="ln2734"> * If stop is TRUE and we are already on the start of a word, move one less.</a>
<a name="ln2735"> *</a>
<a name="ln2736"> * Returns FAIL if top of the file was reached.</a>
<a name="ln2737"> */</a>
<a name="ln2738">int bck_word(long count, int bigword, int stop)</a>
<a name="ln2739">{</a>
<a name="ln2740">  int sclass;               /* starting class */</a>
<a name="ln2741"> </a>
<a name="ln2742">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2743">  cls_bigword = bigword;</a>
<a name="ln2744">  while (--count &gt;= 0) {</a>
<a name="ln2745">    /* When inside a range of folded lines, move to the first char of the</a>
<a name="ln2746">     * first line. */</a>
<a name="ln2747">    if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum, NULL))</a>
<a name="ln2748">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2749">    sclass = cls();</a>
<a name="ln2750">    if (dec_cursor() == -1)             /* started at start of file */</a>
<a name="ln2751">      return FAIL;</a>
<a name="ln2752"> </a>
<a name="ln2753">    if (!stop || sclass == cls() || sclass == 0) {</a>
<a name="ln2754">      /*</a>
<a name="ln2755">       * Skip white space before the word.</a>
<a name="ln2756">       * Stop on an empty line.</a>
<a name="ln2757">       */</a>
<a name="ln2758">      while (cls() == 0) {</a>
<a name="ln2759">        if (curwin-&gt;w_cursor.col == 0</a>
<a name="ln2760">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2761">          goto finished;</a>
<a name="ln2762">        }</a>
<a name="ln2763">        if (dec_cursor() == -1) {       // hit start of file, stop here</a>
<a name="ln2764">          return OK;</a>
<a name="ln2765">        }</a>
<a name="ln2766">      }</a>
<a name="ln2767"> </a>
<a name="ln2768">      /*</a>
<a name="ln2769">       * Move backward to start of this word.</a>
<a name="ln2770">       */</a>
<a name="ln2771">      if (skip_chars(cls(), BACKWARD))</a>
<a name="ln2772">        return OK;</a>
<a name="ln2773">    }</a>
<a name="ln2774"> </a>
<a name="ln2775">    inc_cursor();                       /* overshot - forward one */</a>
<a name="ln2776">finished:</a>
<a name="ln2777">    stop = FALSE;</a>
<a name="ln2778">  }</a>
<a name="ln2779">  return OK;</a>
<a name="ln2780">}</a>
<a name="ln2781"> </a>
<a name="ln2782">/*</a>
<a name="ln2783"> * end_word() - move to the end of the word</a>
<a name="ln2784"> *</a>
<a name="ln2785"> * There is an apparent bug in the 'e' motion of the real vi. At least on the</a>
<a name="ln2786"> * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'</a>
<a name="ln2787"> * motion crosses blank lines. When the real vi crosses a blank line in an</a>
<a name="ln2788"> * 'e' motion, the cursor is placed on the FIRST character of the next</a>
<a name="ln2789"> * non-blank line. The 'E' command, however, works correctly. Since this</a>
<a name="ln2790"> * appears to be a bug, I have not duplicated it here.</a>
<a name="ln2791"> *</a>
<a name="ln2792"> * Returns FAIL if end of the file was reached.</a>
<a name="ln2793"> *</a>
<a name="ln2794"> * If stop is TRUE and we are already on the end of a word, move one less.</a>
<a name="ln2795"> * If empty is TRUE stop on an empty line.</a>
<a name="ln2796"> */</a>
<a name="ln2797">int end_word(long count, int bigword, int stop, int empty)</a>
<a name="ln2798">{</a>
<a name="ln2799">  int sclass;               /* starting class */</a>
<a name="ln2800"> </a>
<a name="ln2801">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2802">  cls_bigword = bigword;</a>
<a name="ln2803">  while (--count &gt;= 0) {</a>
<a name="ln2804">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2805">     * last line. */</a>
<a name="ln2806">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum))</a>
<a name="ln2807">      coladvance((colnr_T)MAXCOL);</a>
<a name="ln2808">    sclass = cls();</a>
<a name="ln2809">    if (inc_cursor() == -1)</a>
<a name="ln2810">      return FAIL;</a>
<a name="ln2811"> </a>
<a name="ln2812">    /*</a>
<a name="ln2813">     * If we're in the middle of a word, we just have to move to the end</a>
<a name="ln2814">     * of it.</a>
<a name="ln2815">     */</a>
<a name="ln2816">    if (cls() == sclass &amp;&amp; sclass != 0) {</a>
<a name="ln2817">      /*</a>
<a name="ln2818">       * Move forward to end of the current word</a>
<a name="ln2819">       */</a>
<a name="ln2820">      if (skip_chars(sclass, FORWARD))</a>
<a name="ln2821">        return FAIL;</a>
<a name="ln2822">    } else if (!stop || sclass == 0) {</a>
<a name="ln2823">      /*</a>
<a name="ln2824">       * We were at the end of a word. Go to the end of the next word.</a>
<a name="ln2825">       * First skip white space, if 'empty' is TRUE, stop at empty line.</a>
<a name="ln2826">       */</a>
<a name="ln2827">      while (cls() == 0) {</a>
<a name="ln2828">        if (empty &amp;&amp; curwin-&gt;w_cursor.col == 0</a>
<a name="ln2829">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2830">          goto finished;</a>
<a name="ln2831">        }</a>
<a name="ln2832">        if (inc_cursor() == -1) {           // hit end of file, stop here</a>
<a name="ln2833">          return FAIL;</a>
<a name="ln2834">        }</a>
<a name="ln2835">      }</a>
<a name="ln2836"> </a>
<a name="ln2837">      /*</a>
<a name="ln2838">       * Move forward to the end of this word.</a>
<a name="ln2839">       */</a>
<a name="ln2840">      if (skip_chars(cls(), FORWARD))</a>
<a name="ln2841">        return FAIL;</a>
<a name="ln2842">    }</a>
<a name="ln2843">    dec_cursor();                       /* overshot - one char backward */</a>
<a name="ln2844">finished:</a>
<a name="ln2845">    stop = FALSE;                       /* we move only one word less */</a>
<a name="ln2846">  }</a>
<a name="ln2847">  return OK;</a>
<a name="ln2848">}</a>
<a name="ln2849"> </a>
<a name="ln2850">/*</a>
<a name="ln2851"> * Move back to the end of the word.</a>
<a name="ln2852"> *</a>
<a name="ln2853"> * Returns FAIL if start of the file was reached.</a>
<a name="ln2854"> */</a>
<a name="ln2855">int</a>
<a name="ln2856">bckend_word(</a>
<a name="ln2857">    long count,</a>
<a name="ln2858">    int bigword,                /* TRUE for &quot;B&quot; */</a>
<a name="ln2859">    int eol                    /* TRUE: stop at end of line. */</a>
<a name="ln2860">)</a>
<a name="ln2861">{</a>
<a name="ln2862">  int sclass;               /* starting class */</a>
<a name="ln2863">  int i;</a>
<a name="ln2864"> </a>
<a name="ln2865">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2866">  cls_bigword = bigword;</a>
<a name="ln2867">  while (--count &gt;= 0) {</a>
<a name="ln2868">    sclass = cls();</a>
<a name="ln2869">    if ((i = dec_cursor()) == -1)</a>
<a name="ln2870">      return FAIL;</a>
<a name="ln2871">    if (eol &amp;&amp; i == 1)</a>
<a name="ln2872">      return OK;</a>
<a name="ln2873"> </a>
<a name="ln2874">    /*</a>
<a name="ln2875">     * Move backward to before the start of this word.</a>
<a name="ln2876">     */</a>
<a name="ln2877">    if (sclass != 0) {</a>
<a name="ln2878">      while (cls() == sclass)</a>
<a name="ln2879">        if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1))</a>
<a name="ln2880">          return OK;</a>
<a name="ln2881">    }</a>
<a name="ln2882"> </a>
<a name="ln2883">    /*</a>
<a name="ln2884">     * Move backward to end of the previous word</a>
<a name="ln2885">     */</a>
<a name="ln2886">    while (cls() == 0) {</a>
<a name="ln2887">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2888">        break;</a>
<a name="ln2889">      }</a>
<a name="ln2890">      if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1)) {</a>
<a name="ln2891">        return OK;</a>
<a name="ln2892">      }</a>
<a name="ln2893">    }</a>
<a name="ln2894">  }</a>
<a name="ln2895">  return OK;</a>
<a name="ln2896">}</a>
<a name="ln2897"> </a>
<a name="ln2898">/*</a>
<a name="ln2899"> * Skip a row of characters of the same class.</a>
<a name="ln2900"> * Return TRUE when end-of-file reached, FALSE otherwise.</a>
<a name="ln2901"> */</a>
<a name="ln2902">static int skip_chars(int cclass, int dir)</a>
<a name="ln2903">{</a>
<a name="ln2904">  while (cls() == cclass)</a>
<a name="ln2905">    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)</a>
<a name="ln2906">      return TRUE;</a>
<a name="ln2907">  return FALSE;</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910">/*</a>
<a name="ln2911"> * Go back to the start of the word or the start of white space</a>
<a name="ln2912"> */</a>
<a name="ln2913">static void back_in_line(void)</a>
<a name="ln2914">{</a>
<a name="ln2915">  int sclass;                       /* starting class */</a>
<a name="ln2916"> </a>
<a name="ln2917">  sclass = cls();</a>
<a name="ln2918">  for (;; ) {</a>
<a name="ln2919">    if (curwin-&gt;w_cursor.col == 0)          /* stop at start of line */</a>
<a name="ln2920">      break;</a>
<a name="ln2921">    dec_cursor();</a>
<a name="ln2922">    if (cls() != sclass) {                  /* stop at start of word */</a>
<a name="ln2923">      inc_cursor();</a>
<a name="ln2924">      break;</a>
<a name="ln2925">    }</a>
<a name="ln2926">  }</a>
<a name="ln2927">}</a>
<a name="ln2928"> </a>
<a name="ln2929">static void find_first_blank(pos_T *posp)</a>
<a name="ln2930">{</a>
<a name="ln2931">  int c;</a>
<a name="ln2932"> </a>
<a name="ln2933">  while (decl(posp) != -1) {</a>
<a name="ln2934">    c = gchar_pos(posp);</a>
<a name="ln2935">    if (!ascii_iswhite(c)) {</a>
<a name="ln2936">      incl(posp);</a>
<a name="ln2937">      break;</a>
<a name="ln2938">    }</a>
<a name="ln2939">  }</a>
<a name="ln2940">}</a>
<a name="ln2941"> </a>
<a name="ln2942">/*</a>
<a name="ln2943"> * Skip count/2 sentences and count/2 separating white spaces.</a>
<a name="ln2944"> */</a>
<a name="ln2945">static void</a>
<a name="ln2946">findsent_forward(</a>
<a name="ln2947">    long count,</a>
<a name="ln2948">    int at_start_sent              /* cursor is at start of sentence */</a>
<a name="ln2949">)</a>
<a name="ln2950">{</a>
<a name="ln2951">  while (count--) {</a>
<a name="ln2952">    findsent(FORWARD, 1L);</a>
<a name="ln2953">    if (at_start_sent)</a>
<a name="ln2954">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2955">    if (count == 0 || at_start_sent)</a>
<a name="ln2956">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2957">    at_start_sent = !at_start_sent;</a>
<a name="ln2958">  }</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">/*</a>
<a name="ln2962"> * Find word under cursor, cursor at end.</a>
<a name="ln2963"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln2964"> */</a>
<a name="ln2965">int</a>
<a name="ln2966">current_word(</a>
<a name="ln2967">    oparg_T *oap,</a>
<a name="ln2968">    long count,</a>
<a name="ln2969">    int include,                    /* TRUE: include word and white space */</a>
<a name="ln2970">    int bigword                    /* FALSE == word, TRUE == WORD */</a>
<a name="ln2971">)</a>
<a name="ln2972">{</a>
<a name="ln2973">  pos_T start_pos;</a>
<a name="ln2974">  pos_T pos;</a>
<a name="ln2975">  bool inclusive = true;</a>
<a name="ln2976">  int include_white = FALSE;</a>
<a name="ln2977"> </a>
<a name="ln2978">  cls_bigword = bigword;</a>
<a name="ln2979">  clearpos(&amp;start_pos);</a>
<a name="ln2980"> </a>
<a name="ln2981">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln2982">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln2983">    dec_cursor();</a>
<a name="ln2984"> </a>
<a name="ln2985">  /*</a>
<a name="ln2986">   * When Visual mode is not active, or when the VIsual area is only one</a>
<a name="ln2987">   * character, select the word and/or white space under the cursor.</a>
<a name="ln2988">   */</a>
<a name="ln2989">  if (!VIsual_active || equalpos(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2990">    /*</a>
<a name="ln2991">     * Go to start of current word or white space.</a>
<a name="ln2992">     */</a>
<a name="ln2993">    back_in_line();</a>
<a name="ln2994">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln2995"> </a>
<a name="ln2996">    /*</a>
<a name="ln2997">     * If the start is on white space, and white space should be included</a>
<a name="ln2998">     * (&quot;	word&quot;), or start is not on white space, and white space should</a>
<a name="ln2999">     * not be included (&quot;word&quot;), find end of word.</a>
<a name="ln3000">     */</a>
<a name="ln3001">    if ((cls() == 0) == include) {</a>
<a name="ln3002">      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3003">        return FAIL;</a>
<a name="ln3004">    } else {</a>
<a name="ln3005">      /*</a>
<a name="ln3006">       * If the start is not on white space, and white space should be</a>
<a name="ln3007">       * included (&quot;word	 &quot;), or start is on white space and white</a>
<a name="ln3008">       * space should not be included (&quot;	 &quot;), find start of word.</a>
<a name="ln3009">       * If we end up in the first column of the next line (single char</a>
<a name="ln3010">       * word) back up to end of the line.</a>
<a name="ln3011">       */</a>
<a name="ln3012">      fwd_word(1L, bigword, TRUE);</a>
<a name="ln3013">      if (curwin-&gt;w_cursor.col == 0)</a>
<a name="ln3014">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3015">      else</a>
<a name="ln3016">        oneleft();</a>
<a name="ln3017"> </a>
<a name="ln3018">      if (include)</a>
<a name="ln3019">        include_white = TRUE;</a>
<a name="ln3020">    }</a>
<a name="ln3021"> </a>
<a name="ln3022">    if (VIsual_active) {</a>
<a name="ln3023">      /* should do something when inclusive == false ! */</a>
<a name="ln3024">      VIsual = start_pos;</a>
<a name="ln3025">      redraw_curbuf_later(INVERTED);            /* update the inversion */</a>
<a name="ln3026">    } else {</a>
<a name="ln3027">      oap-&gt;start = start_pos;</a>
<a name="ln3028">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3029">    }</a>
<a name="ln3030">    --count;</a>
<a name="ln3031">  }</a>
<a name="ln3032"> </a>
<a name="ln3033">  /*</a>
<a name="ln3034">   * When count is still &gt; 0, extend with more objects.</a>
<a name="ln3035">   */</a>
<a name="ln3036">  while (count &gt; 0) {</a>
<a name="ln3037">    inclusive = true;</a>
<a name="ln3038">    if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln3039">      /*</a>
<a name="ln3040">       * In Visual mode, with cursor at start: move cursor back.</a>
<a name="ln3041">       */</a>
<a name="ln3042">      if (decl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3043">        return FAIL;</a>
<a name="ln3044">      if (include != (cls() != 0)) {</a>
<a name="ln3045">        if (bck_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3046">          return FAIL;</a>
<a name="ln3047">      } else {</a>
<a name="ln3048">        if (bckend_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3049">          return FAIL;</a>
<a name="ln3050">        (void)incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3051">      }</a>
<a name="ln3052">    } else {</a>
<a name="ln3053">      /*</a>
<a name="ln3054">       * Move cursor forward one word and/or white area.</a>
<a name="ln3055">       */</a>
<a name="ln3056">      if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3057">        return FAIL;</a>
<a name="ln3058">      if (include != (cls() == 0)) {</a>
<a name="ln3059">        if (fwd_word(1L, bigword, TRUE) == FAIL &amp;&amp; count &gt; 1)</a>
<a name="ln3060">          return FAIL;</a>
<a name="ln3061">        /*</a>
<a name="ln3062">         * If end is just past a new-line, we don't want to include</a>
<a name="ln3063">         * the first character on the line.</a>
<a name="ln3064">         * Put cursor on last char of white.</a>
<a name="ln3065">         */</a>
<a name="ln3066">        if (oneleft() == FAIL)</a>
<a name="ln3067">          inclusive = false;</a>
<a name="ln3068">      } else {</a>
<a name="ln3069">        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3070">          return FAIL;</a>
<a name="ln3071">      }</a>
<a name="ln3072">    }</a>
<a name="ln3073">    --count;</a>
<a name="ln3074">  }</a>
<a name="ln3075"> </a>
<a name="ln3076">  if (include_white &amp;&amp; (cls() != 0</a>
<a name="ln3077">                        || (curwin-&gt;w_cursor.col == 0 &amp;&amp; !inclusive))) {</a>
<a name="ln3078">    /*</a>
<a name="ln3079">     * If we don't include white space at the end, move the start</a>
<a name="ln3080">     * to include some white space there. This makes &quot;daw&quot; work</a>
<a name="ln3081">     * better on the last word in a sentence (and &quot;2daw&quot; on last-but-one</a>
<a name="ln3082">     * word).  Also when &quot;2daw&quot; deletes &quot;word.&quot; at the end of the line</a>
<a name="ln3083">     * (cursor is at start of next line).</a>
<a name="ln3084">     * But don't delete white space at start of line (indent).</a>
<a name="ln3085">     */</a>
<a name="ln3086">    pos = curwin-&gt;w_cursor;     /* save cursor position */</a>
<a name="ln3087">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3088">    if (oneleft() == OK) {</a>
<a name="ln3089">      back_in_line();</a>
<a name="ln3090">      if (cls() == 0 &amp;&amp; curwin-&gt;w_cursor.col &gt; 0) {</a>
<a name="ln3091">        if (VIsual_active)</a>
<a name="ln3092">          VIsual = curwin-&gt;w_cursor;</a>
<a name="ln3093">        else</a>
<a name="ln3094">          oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln3095">      }</a>
<a name="ln3096">    }</a>
<a name="ln3097">    curwin-&gt;w_cursor = pos;     /* put cursor back at end */</a>
<a name="ln3098">  }</a>
<a name="ln3099"> </a>
<a name="ln3100">  if (VIsual_active) {</a>
<a name="ln3101">    if (*p_sel == 'e' &amp;&amp; inclusive &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln3102">      inc_cursor();</a>
<a name="ln3103">    if (VIsual_mode == 'V') {</a>
<a name="ln3104">      VIsual_mode = 'v';</a>
<a name="ln3105">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln3106">    }</a>
<a name="ln3107">  } else</a>
<a name="ln3108">    oap-&gt;inclusive = inclusive;</a>
<a name="ln3109"> </a>
<a name="ln3110">  return OK;</a>
<a name="ln3111">}</a>
<a name="ln3112"> </a>
<a name="ln3113">/*</a>
<a name="ln3114"> * Find sentence(s) under the cursor, cursor at end.</a>
<a name="ln3115"> * When Visual active, extend it by one or more sentences.</a>
<a name="ln3116"> */</a>
<a name="ln3117">int current_sent(oparg_T *oap, long count, int include)</a>
<a name="ln3118">{</a>
<a name="ln3119">  pos_T start_pos;</a>
<a name="ln3120">  pos_T pos;</a>
<a name="ln3121">  int start_blank;</a>
<a name="ln3122">  int c;</a>
<a name="ln3123">  int at_start_sent;</a>
<a name="ln3124">  long ncount;</a>
<a name="ln3125"> </a>
<a name="ln3126">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3127">  pos = start_pos;</a>
<a name="ln3128">  findsent(FORWARD, 1L);        /* Find start of next sentence. */</a>
<a name="ln3129"> </a>
<a name="ln3130">  /*</a>
<a name="ln3131">   * When the Visual area is bigger than one character: Extend it.</a>
<a name="ln3132">   */</a>
<a name="ln3133">  if (VIsual_active &amp;&amp; !equalpos(start_pos, VIsual)) {</a>
<a name="ln3134">extend:</a>
<a name="ln3135">    if (lt(start_pos, VIsual)) {</a>
<a name="ln3136">      /*</a>
<a name="ln3137">       * Cursor at start of Visual area.</a>
<a name="ln3138">       * Find out where we are:</a>
<a name="ln3139">       * - in the white space before a sentence</a>
<a name="ln3140">       * - in a sentence or just after it</a>
<a name="ln3141">       * - at the start of a sentence</a>
<a name="ln3142">       */</a>
<a name="ln3143">      at_start_sent = TRUE;</a>
<a name="ln3144">      decl(&amp;pos);</a>
<a name="ln3145">      while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3146">        c = gchar_pos(&amp;pos);</a>
<a name="ln3147">        if (!ascii_iswhite(c)) {</a>
<a name="ln3148">          at_start_sent = FALSE;</a>
<a name="ln3149">          break;</a>
<a name="ln3150">        }</a>
<a name="ln3151">        incl(&amp;pos);</a>
<a name="ln3152">      }</a>
<a name="ln3153">      if (!at_start_sent) {</a>
<a name="ln3154">        findsent(BACKWARD, 1L);</a>
<a name="ln3155">        if (equalpos(curwin-&gt;w_cursor, start_pos))</a>
<a name="ln3156">          at_start_sent = TRUE;            /* exactly at start of sentence */</a>
<a name="ln3157">        else</a>
<a name="ln3158">          /* inside a sentence, go to its end (start of next) */</a>
<a name="ln3159">          findsent(FORWARD, 1L);</a>
<a name="ln3160">      }</a>
<a name="ln3161">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3162">        count *= 2;</a>
<a name="ln3163">      while (count--) {</a>
<a name="ln3164">        if (at_start_sent)</a>
<a name="ln3165">          find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3166">        c = gchar_cursor();</a>
<a name="ln3167">        if (!at_start_sent || (!include &amp;&amp; !ascii_iswhite(c)))</a>
<a name="ln3168">          findsent(BACKWARD, 1L);</a>
<a name="ln3169">        at_start_sent = !at_start_sent;</a>
<a name="ln3170">      }</a>
<a name="ln3171">    } else {</a>
<a name="ln3172">      /*</a>
<a name="ln3173">       * Cursor at end of Visual area.</a>
<a name="ln3174">       * Find out where we are:</a>
<a name="ln3175">       * - just before a sentence</a>
<a name="ln3176">       * - just before or in the white space before a sentence</a>
<a name="ln3177">       * - in a sentence</a>
<a name="ln3178">       */</a>
<a name="ln3179">      incl(&amp;pos);</a>
<a name="ln3180">      at_start_sent = TRUE;</a>
<a name="ln3181">      if (!equalpos(pos, curwin-&gt;w_cursor)) {     /* not just before a sentence */</a>
<a name="ln3182">        at_start_sent = FALSE;</a>
<a name="ln3183">        while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3184">          c = gchar_pos(&amp;pos);</a>
<a name="ln3185">          if (!ascii_iswhite(c)) {</a>
<a name="ln3186">            at_start_sent = TRUE;</a>
<a name="ln3187">            break;</a>
<a name="ln3188">          }</a>
<a name="ln3189">          incl(&amp;pos);</a>
<a name="ln3190">        }</a>
<a name="ln3191">        if (at_start_sent)              /* in the sentence */</a>
<a name="ln3192">          findsent(BACKWARD, 1L);</a>
<a name="ln3193">        else                    /* in/before white before a sentence */</a>
<a name="ln3194">          curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3195">      }</a>
<a name="ln3196"> </a>
<a name="ln3197">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3198">        count *= 2;</a>
<a name="ln3199">      findsent_forward(count, at_start_sent);</a>
<a name="ln3200">      if (*p_sel == 'e')</a>
<a name="ln3201">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln3202">    }</a>
<a name="ln3203">    return OK;</a>
<a name="ln3204">  }</a>
<a name="ln3205"> </a>
<a name="ln3206">  /*</a>
<a name="ln3207">   * If the cursor started on a blank, check if it is just before the start</a>
<a name="ln3208">   * of the next sentence.</a>
<a name="ln3209">   */</a>
<a name="ln3210">  while (c = gchar_pos(&amp;pos), ascii_iswhite(c))</a>
<a name="ln3211">    incl(&amp;pos);</a>
<a name="ln3212">  if (equalpos(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3213">    start_blank = TRUE;</a>
<a name="ln3214">    find_first_blank(&amp;start_pos);       /* go back to first blank */</a>
<a name="ln3215">  } else {</a>
<a name="ln3216">    start_blank = FALSE;</a>
<a name="ln3217">    findsent(BACKWARD, 1L);</a>
<a name="ln3218">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3219">  }</a>
<a name="ln3220">  if (include)</a>
<a name="ln3221">    ncount = count * 2;</a>
<a name="ln3222">  else {</a>
<a name="ln3223">    ncount = count;</a>
<a name="ln3224">    if (start_blank)</a>
<a name="ln3225">      --ncount;</a>
<a name="ln3226">  }</a>
<a name="ln3227">  if (ncount &gt; 0)</a>
<a name="ln3228">    findsent_forward(ncount, TRUE);</a>
<a name="ln3229">  else</a>
<a name="ln3230">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3231"> </a>
<a name="ln3232">  if (include) {</a>
<a name="ln3233">    /*</a>
<a name="ln3234">     * If the blank in front of the sentence is included, exclude the</a>
<a name="ln3235">     * blanks at the end of the sentence, go back to the first blank.</a>
<a name="ln3236">     * If there are no trailing blanks, try to include leading blanks.</a>
<a name="ln3237">     */</a>
<a name="ln3238">    if (start_blank) {</a>
<a name="ln3239">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3240">      c = gchar_pos(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3241">      if (ascii_iswhite(c))</a>
<a name="ln3242">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3243">    } else if (c = gchar_cursor(), !ascii_iswhite(c))</a>
<a name="ln3244">      find_first_blank(&amp;start_pos);</a>
<a name="ln3245">  }</a>
<a name="ln3246"> </a>
<a name="ln3247">  if (VIsual_active) {</a>
<a name="ln3248">    /* Avoid getting stuck with &quot;is&quot; on a single space before a sentence. */</a>
<a name="ln3249">    if (equalpos(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3250">      goto extend;</a>
<a name="ln3251">    if (*p_sel == 'e')</a>
<a name="ln3252">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3253">    VIsual = start_pos;</a>
<a name="ln3254">    VIsual_mode = 'v';</a>
<a name="ln3255">    redraw_cmdline = true;    // show mode later</a>
<a name="ln3256">    redraw_curbuf_later(INVERTED);      // update the inversion</a>
<a name="ln3257">  } else {</a>
<a name="ln3258">    /* include a newline after the sentence, if there is one */</a>
<a name="ln3259">    if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3260">      oap-&gt;inclusive = true;</a>
<a name="ln3261">    else</a>
<a name="ln3262">      oap-&gt;inclusive = false;</a>
<a name="ln3263">    oap-&gt;start = start_pos;</a>
<a name="ln3264">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3265">  }</a>
<a name="ln3266">  return OK;</a>
<a name="ln3267">}</a>
<a name="ln3268"> </a>
<a name="ln3269">/*</a>
<a name="ln3270"> * Find block under the cursor, cursor at end.</a>
<a name="ln3271"> * &quot;what&quot; and &quot;other&quot; are two matching parenthesis/brace/etc.</a>
<a name="ln3272"> */</a>
<a name="ln3273">int</a>
<a name="ln3274">current_block(</a>
<a name="ln3275">    oparg_T *oap,</a>
<a name="ln3276">    long count,</a>
<a name="ln3277">    int include,                    /* TRUE == include white space */</a>
<a name="ln3278">    int what,                       /* '(', '{', etc. */</a>
<a name="ln3279">    int other                      /* ')', '}', etc. */</a>
<a name="ln3280">)</a>
<a name="ln3281">{</a>
<a name="ln3282">  pos_T old_pos;</a>
<a name="ln3283">  pos_T       *pos = NULL;</a>
<a name="ln3284">  pos_T start_pos;</a>
<a name="ln3285">  pos_T       *end_pos;</a>
<a name="ln3286">  pos_T old_start, old_end;</a>
<a name="ln3287">  char_u      *save_cpo;</a>
<a name="ln3288">  int sol = FALSE;                      /* '{' at start of line */</a>
<a name="ln3289"> </a>
<a name="ln3290">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3291">  old_end = curwin-&gt;w_cursor;           /* remember where we started */</a>
<a name="ln3292">  old_start = old_end;</a>
<a name="ln3293"> </a>
<a name="ln3294">  /*</a>
<a name="ln3295">   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.</a>
<a name="ln3296">   */</a>
<a name="ln3297">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3298">    setpcmark();</a>
<a name="ln3299">    if (what == '{')                    /* ignore indent */</a>
<a name="ln3300">      while (inindent(1))</a>
<a name="ln3301">        if (inc_cursor() != 0)</a>
<a name="ln3302">          break;</a>
<a name="ln3303">    if (gchar_cursor() == what)</a>
<a name="ln3304">      /* cursor on '(' or '{', move cursor just after it */</a>
<a name="ln3305">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3306">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3307">    old_start = VIsual;</a>
<a name="ln3308">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3309">  } else</a>
<a name="ln3310">    old_end = VIsual;</a>
<a name="ln3311"> </a>
<a name="ln3312">  // Search backwards for unclosed '(', '{', etc..</a>
<a name="ln3313">  // Put this position in start_pos.</a>
<a name="ln3314">  // Ignore quotes here.  Keep the &quot;M&quot; flag in 'cpo', as that is what the</a>
<a name="ln3315">  // user wants.</a>
<a name="ln3316">  save_cpo = p_cpo;</a>
<a name="ln3317">  p_cpo = (char_u *)(vim_strchr(p_cpo, CPO_MATCHBSL) != NULL ? &quot;%M&quot; : &quot;%&quot;);</a>
<a name="ln3318">  while (count-- &gt; 0) {</a>
<a name="ln3319">    if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3320">      break;</a>
<a name="ln3321">    }</a>
<a name="ln3322">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln3323">    start_pos = *pos;  // the findmatch for end_pos will overwrite *pos</a>
<a name="ln3324">  }</a>
<a name="ln3325">  p_cpo = save_cpo;</a>
<a name="ln3326"> </a>
<a name="ln3327">  /*</a>
<a name="ln3328">   * Search for matching ')', '}', etc.</a>
<a name="ln3329">   * Put this position in curwin-&gt;w_cursor.</a>
<a name="ln3330">   */</a>
<a name="ln3331">  if (pos == NULL || (end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3332">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3333">    return FAIL;</a>
<a name="ln3334">  }</a>
<a name="ln3335">  curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3336"> </a>
<a name="ln3337">  // Try to exclude the '(', '{', ')', '}', etc. when &quot;include&quot; is FALSE.</a>
<a name="ln3338">  // If the ending '}', ')' or ']' is only preceded by indent, skip that</a>
<a name="ln3339">  // indent. But only if the resulting area is not smaller than what we</a>
<a name="ln3340">  // started with.</a>
<a name="ln3341">  while (!include) {</a>
<a name="ln3342">    incl(&amp;start_pos);</a>
<a name="ln3343">    sol = (curwin-&gt;w_cursor.col == 0);</a>
<a name="ln3344">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3345">    while (inindent(1)) {</a>
<a name="ln3346">      sol = TRUE;</a>
<a name="ln3347">      if (decl(&amp;curwin-&gt;w_cursor) != 0) {</a>
<a name="ln3348">        break;</a>
<a name="ln3349">      }</a>
<a name="ln3350">    }</a>
<a name="ln3351"> </a>
<a name="ln3352">    /*</a>
<a name="ln3353">     * In Visual mode, when the resulting area is not bigger than what we</a>
<a name="ln3354">     * started with, extend it to the next block, and then exclude again.</a>
<a name="ln3355">     */</a>
<a name="ln3356">    if (!lt(start_pos, old_start) &amp;&amp; !lt(old_end, curwin-&gt;w_cursor)</a>
<a name="ln3357">        &amp;&amp; VIsual_active) {</a>
<a name="ln3358">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3359">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3360">      if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3361">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3362">        return FAIL;</a>
<a name="ln3363">      }</a>
<a name="ln3364">      start_pos = *pos;</a>
<a name="ln3365">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln3366">      if ((end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3367">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3368">        return FAIL;</a>
<a name="ln3369">      }</a>
<a name="ln3370">      curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3371">    } else</a>
<a name="ln3372">      break;</a>
<a name="ln3373">  }</a>
<a name="ln3374"> </a>
<a name="ln3375">  if (VIsual_active) {</a>
<a name="ln3376">    if (*p_sel == 'e') {</a>
<a name="ln3377">      inc(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3378">    }</a>
<a name="ln3379">    if (sol &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3380">      inc(&amp;curwin-&gt;w_cursor);  // include the line break</a>
<a name="ln3381">    }</a>
<a name="ln3382">    VIsual = start_pos;</a>
<a name="ln3383">    VIsual_mode = 'v';</a>
<a name="ln3384">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3385">    showmode();</a>
<a name="ln3386">  } else {</a>
<a name="ln3387">    oap-&gt;start = start_pos;</a>
<a name="ln3388">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3389">    oap-&gt;inclusive = false;</a>
<a name="ln3390">    if (sol)</a>
<a name="ln3391">      incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3392">    else if (ltoreq(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3393">      /* Include the character under the cursor. */</a>
<a name="ln3394">      oap-&gt;inclusive = true;</a>
<a name="ln3395">    else</a>
<a name="ln3396">      /* End is before the start (no text in between &lt;&gt;, [], etc.): don't</a>
<a name="ln3397">       * operate on any text. */</a>
<a name="ln3398">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3399">  }</a>
<a name="ln3400"> </a>
<a name="ln3401">  return OK;</a>
<a name="ln3402">}</a>
<a name="ln3403"> </a>
<a name="ln3404"> </a>
<a name="ln3405">/*</a>
<a name="ln3406"> * Return TRUE if the cursor is on a &quot;&lt;aaa&gt;&quot; tag.  Ignore &quot;&lt;aaa/&gt;&quot;.</a>
<a name="ln3407"> * When &quot;end_tag&quot; is TRUE return TRUE if the cursor is on &quot;&lt;/aaa&gt;&quot;.</a>
<a name="ln3408"> */</a>
<a name="ln3409">static int in_html_tag(int end_tag)</a>
<a name="ln3410">{</a>
<a name="ln3411">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3412">  char_u      *p;</a>
<a name="ln3413">  int c;</a>
<a name="ln3414">  int lc = NUL;</a>
<a name="ln3415">  pos_T pos;</a>
<a name="ln3416"> </a>
<a name="ln3417">  for (p = line + curwin-&gt;w_cursor.col; p &gt; line; ) {</a>
<a name="ln3418">    if (*p == '&lt;') {           // find '&lt;' under/before cursor</a>
<a name="ln3419">      break;</a>
<a name="ln3420">    }</a>
<a name="ln3421">    MB_PTR_BACK(line, p);</a>
<a name="ln3422">    if (*p == '&gt;') {           // find '&gt;' before cursor</a>
<a name="ln3423">      break;</a>
<a name="ln3424">    }</a>
<a name="ln3425">  }</a>
<a name="ln3426">  if (*p != '&lt;') {</a>
<a name="ln3427">    return false;</a>
<a name="ln3428">  }</a>
<a name="ln3429"> </a>
<a name="ln3430">  pos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3431">  pos.col = (colnr_T)(p - line);</a>
<a name="ln3432"> </a>
<a name="ln3433">  MB_PTR_ADV(p);</a>
<a name="ln3434">  if (end_tag) {</a>
<a name="ln3435">    // check that there is a '/' after the '&lt;'</a>
<a name="ln3436">    return *p == '/';</a>
<a name="ln3437">  }</a>
<a name="ln3438"> </a>
<a name="ln3439">  /* check that there is no '/' after the '&lt;' */</a>
<a name="ln3440">  if (*p == '/')</a>
<a name="ln3441">    return FALSE;</a>
<a name="ln3442"> </a>
<a name="ln3443">  /* check that the matching '&gt;' is not preceded by '/' */</a>
<a name="ln3444">  for (;; ) {</a>
<a name="ln3445">    if (inc(&amp;pos) &lt; 0)</a>
<a name="ln3446">      return FALSE;</a>
<a name="ln3447">    c = *ml_get_pos(&amp;pos);</a>
<a name="ln3448">    if (c == '&gt;')</a>
<a name="ln3449">      break;</a>
<a name="ln3450">    lc = c;</a>
<a name="ln3451">  }</a>
<a name="ln3452">  return lc != '/';</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455">/*</a>
<a name="ln3456"> * Find tag block under the cursor, cursor at end.</a>
<a name="ln3457"> */</a>
<a name="ln3458">int</a>
<a name="ln3459">current_tagblock(</a>
<a name="ln3460">    oparg_T *oap,</a>
<a name="ln3461">    long count_arg,</a>
<a name="ln3462">    bool include                  // true == include white space</a>
<a name="ln3463">)</a>
<a name="ln3464">{</a>
<a name="ln3465">  long count = count_arg;</a>
<a name="ln3466">  pos_T old_pos;</a>
<a name="ln3467">  pos_T start_pos;</a>
<a name="ln3468">  pos_T end_pos;</a>
<a name="ln3469">  pos_T old_start, old_end;</a>
<a name="ln3470">  char_u      *p;</a>
<a name="ln3471">  char_u      *cp;</a>
<a name="ln3472">  int len;</a>
<a name="ln3473">  bool do_include = include;</a>
<a name="ln3474">  bool save_p_ws = p_ws;</a>
<a name="ln3475">  int retval = FAIL;</a>
<a name="ln3476">  int is_inclusive = true;</a>
<a name="ln3477"> </a>
<a name="ln3478">  p_ws = false;</a>
<a name="ln3479"> </a>
<a name="ln3480">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3481">  old_end = curwin-&gt;w_cursor;               /* remember where we started */</a>
<a name="ln3482">  old_start = old_end;</a>
<a name="ln3483">  if (!VIsual_active || *p_sel == 'e')</a>
<a name="ln3484">    decl(&amp;old_end);                         /* old_end is inclusive */</a>
<a name="ln3485"> </a>
<a name="ln3486">  /*</a>
<a name="ln3487">   * If we start on &quot;&lt;aaa&gt;&quot; select that block.</a>
<a name="ln3488">   */</a>
<a name="ln3489">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3490">    setpcmark();</a>
<a name="ln3491"> </a>
<a name="ln3492">    /* ignore indent */</a>
<a name="ln3493">    while (inindent(1))</a>
<a name="ln3494">      if (inc_cursor() != 0)</a>
<a name="ln3495">        break;</a>
<a name="ln3496"> </a>
<a name="ln3497">    if (in_html_tag(FALSE)) {</a>
<a name="ln3498">      /* cursor on start tag, move to its '&gt;' */</a>
<a name="ln3499">      while (*get_cursor_pos_ptr() != '&gt;')</a>
<a name="ln3500">        if (inc_cursor() &lt; 0)</a>
<a name="ln3501">          break;</a>
<a name="ln3502">    } else if (in_html_tag(TRUE)) {</a>
<a name="ln3503">      /* cursor on end tag, move to just before it */</a>
<a name="ln3504">      while (*get_cursor_pos_ptr() != '&lt;')</a>
<a name="ln3505">        if (dec_cursor() &lt; 0)</a>
<a name="ln3506">          break;</a>
<a name="ln3507">      dec_cursor();</a>
<a name="ln3508">      old_end = curwin-&gt;w_cursor;</a>
<a name="ln3509">    }</a>
<a name="ln3510">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3511">    old_start = VIsual;</a>
<a name="ln3512">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3513">  } else</a>
<a name="ln3514">    old_end = VIsual;</a>
<a name="ln3515"> </a>
<a name="ln3516">again:</a>
<a name="ln3517">  /*</a>
<a name="ln3518">   * Search backwards for unclosed &quot;&lt;aaa&gt;&quot;.</a>
<a name="ln3519">   * Put this position in start_pos.</a>
<a name="ln3520">   */</a>
<a name="ln3521">  for (long n = 0; n &lt; count; n++) {</a>
<a name="ln3522">    if (do_searchpair(</a>
<a name="ln3523">        &quot;&lt;[^ \t&gt;/!]\\+\\%(\\_s\\_[^&gt;]\\{-}[^/]&gt;\\|$\\|\\_s\\=&gt;\\)&quot;,</a>
<a name="ln3524">        &quot;&quot;,</a>
<a name="ln3525">        &quot;&lt;/[^&gt;]*&gt;&quot;, BACKWARD, NULL, 0,</a>
<a name="ln3526">        NULL, (linenr_T)0, 0L) &lt;= 0) {</a>
<a name="ln3527">      curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3528">      goto theend;</a>
<a name="ln3529">    }</a>
<a name="ln3530">  }</a>
<a name="ln3531">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3532"> </a>
<a name="ln3533">  /*</a>
<a name="ln3534">   * Search for matching &quot;&lt;/aaa&gt;&quot;.  First isolate the &quot;aaa&quot;.</a>
<a name="ln3535">   */</a>
<a name="ln3536">  inc_cursor();</a>
<a name="ln3537">  p = get_cursor_pos_ptr();</a>
<a name="ln3538">  for (cp = p;</a>
<a name="ln3539">       *cp != NUL &amp;&amp; *cp != '&gt;' &amp;&amp; !ascii_iswhite(*cp);</a>
<a name="ln3540">       MB_PTR_ADV(cp)) {</a>
<a name="ln3541">  }</a>
<a name="ln3542">  len = (int)(cp - p);</a>
<a name="ln3543">  if (len == 0) {</a>
<a name="ln3544">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3545">    goto theend;</a>
<a name="ln3546">  }</a>
<a name="ln3547">  const size_t spat_len = len + 39;</a>
<a name="ln3548">  char *const spat = xmalloc(spat_len);</a>
<a name="ln3549">  const size_t epat_len = len + 9;</a>
<a name="ln3550">  char *const epat = xmalloc(epat_len);</a>
<a name="ln3551">  snprintf(spat, spat_len,</a>
<a name="ln3552">           &quot;&lt;%.*s\\&gt;\\%%(\\_s\\_[^&gt;]\\{-}\\_[^/]&gt;\\|\\_s\\?&gt;\\)\\c&quot;, len, p);</a>
<a name="ln3553">  snprintf(epat, epat_len, &quot;&lt;/%.*s&gt;\\c&quot;, len, p);</a>
<a name="ln3554"> </a>
<a name="ln3555">  const int r = do_searchpair(spat, &quot;&quot;, epat, FORWARD, NULL,</a>
<a name="ln3556">                              0, NULL, (linenr_T)0, 0L);</a>
<a name="ln3557"> </a>
<a name="ln3558">  xfree(spat);</a>
<a name="ln3559">  xfree(epat);</a>
<a name="ln3560"> </a>
<a name="ln3561">  if (r &lt; 1 || lt(curwin-&gt;w_cursor, old_end)) {</a>
<a name="ln3562">    /* Can't find other end or it's before the previous end.  Could be a</a>
<a name="ln3563">     * HTML tag that doesn't have a matching end.  Search backwards for</a>
<a name="ln3564">     * another starting tag. */</a>
<a name="ln3565">    count = 1;</a>
<a name="ln3566">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3567">    goto again;</a>
<a name="ln3568">  }</a>
<a name="ln3569"> </a>
<a name="ln3570">  if (do_include) {</a>
<a name="ln3571">    // Include up to the '&gt;'.</a>
<a name="ln3572">    while (*get_cursor_pos_ptr() != '&gt;') {</a>
<a name="ln3573">      if (inc_cursor() &lt; 0) {</a>
<a name="ln3574">        break;</a>
<a name="ln3575">      }</a>
<a name="ln3576">    }</a>
<a name="ln3577">  } else {</a>
<a name="ln3578">    char_u *c = get_cursor_pos_ptr();</a>
<a name="ln3579">    // Exclude the '&lt;' of the end tag.</a>
<a name="ln3580">    // If the closing tag is on new line, do not decrement cursor, but make</a>
<a name="ln3581">    // operation exclusive, so that the linefeed will be selected</a>
<a name="ln3582">    if (*c == '&lt;' &amp;&amp; !VIsual_active &amp;&amp; curwin-&gt;w_cursor.col == 0) {</a>
<a name="ln3583">      // do not decrement cursor</a>
<a name="ln3584">      is_inclusive = false;</a>
<a name="ln3585">    } else if (*c == '&lt;') {</a>
<a name="ln3586">      dec_cursor();</a>
<a name="ln3587">    }</a>
<a name="ln3588">  }</a>
<a name="ln3589">  end_pos = curwin-&gt;w_cursor;</a>
<a name="ln3590"> </a>
<a name="ln3591">  if (!do_include) {</a>
<a name="ln3592">    /* Exclude the start tag. */</a>
<a name="ln3593">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3594">    while (inc_cursor() &gt;= 0)</a>
<a name="ln3595">      if (*get_cursor_pos_ptr() == '&gt;') {</a>
<a name="ln3596">        inc_cursor();</a>
<a name="ln3597">        start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3598">        break;</a>
<a name="ln3599">      }</a>
<a name="ln3600">    curwin-&gt;w_cursor = end_pos;</a>
<a name="ln3601"> </a>
<a name="ln3602">    // If we are in Visual mode and now have the same text as before set</a>
<a name="ln3603">    // &quot;do_include&quot; and try again.</a>
<a name="ln3604">    if (VIsual_active</a>
<a name="ln3605">        &amp;&amp; equalpos(start_pos, old_start)</a>
<a name="ln3606">        &amp;&amp; equalpos(end_pos, old_end)) {</a>
<a name="ln3607">      do_include = true;</a>
<a name="ln3608">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3609">      count = count_arg;</a>
<a name="ln3610">      goto again;</a>
<a name="ln3611">    }</a>
<a name="ln3612">  }</a>
<a name="ln3613"> </a>
<a name="ln3614">  if (VIsual_active) {</a>
<a name="ln3615">    /* If the end is before the start there is no text between tags, select</a>
<a name="ln3616">     * the char under the cursor. */</a>
<a name="ln3617">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3618">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3619">    } else if (*p_sel == 'e') {</a>
<a name="ln3620">      inc_cursor();</a>
<a name="ln3621">    }</a>
<a name="ln3622">    VIsual = start_pos;</a>
<a name="ln3623">    VIsual_mode = 'v';</a>
<a name="ln3624">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3625">    showmode();</a>
<a name="ln3626">  } else {</a>
<a name="ln3627">    oap-&gt;start = start_pos;</a>
<a name="ln3628">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3629">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3630">      /* End is before the start: there is no text between tags; operate</a>
<a name="ln3631">       * on an empty area. */</a>
<a name="ln3632">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3633">      oap-&gt;inclusive = false;</a>
<a name="ln3634">    } else {</a>
<a name="ln3635">      oap-&gt;inclusive = is_inclusive;</a>
<a name="ln3636">    }</a>
<a name="ln3637">  }</a>
<a name="ln3638">  retval = OK;</a>
<a name="ln3639"> </a>
<a name="ln3640">theend:</a>
<a name="ln3641">  p_ws = save_p_ws;</a>
<a name="ln3642">  return retval;</a>
<a name="ln3643">}</a>
<a name="ln3644"> </a>
<a name="ln3645">int</a>
<a name="ln3646">current_par(</a>
<a name="ln3647">    oparg_T *oap,</a>
<a name="ln3648">    long count,</a>
<a name="ln3649">    int include,                    /* TRUE == include white space */</a>
<a name="ln3650">    int type                       /* 'p' for paragraph, 'S' for section */</a>
<a name="ln3651">)</a>
<a name="ln3652">{</a>
<a name="ln3653">  linenr_T start_lnum;</a>
<a name="ln3654">  linenr_T end_lnum;</a>
<a name="ln3655">  int white_in_front;</a>
<a name="ln3656">  int dir;</a>
<a name="ln3657">  int start_is_white;</a>
<a name="ln3658">  int prev_start_is_white;</a>
<a name="ln3659">  int retval = OK;</a>
<a name="ln3660">  int do_white = FALSE;</a>
<a name="ln3661">  int t;</a>
<a name="ln3662">  int i;</a>
<a name="ln3663"> </a>
<a name="ln3664">  if (type == 'S')          /* not implemented yet */</a>
<a name="ln3665">    return FAIL;</a>
<a name="ln3666"> </a>
<a name="ln3667">  start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3668"> </a>
<a name="ln3669">  /*</a>
<a name="ln3670">   * When visual area is more than one line: extend it.</a>
<a name="ln3671">   */</a>
<a name="ln3672">  if (VIsual_active &amp;&amp; start_lnum != VIsual.lnum) {</a>
<a name="ln3673">extend:</a>
<a name="ln3674">    if (start_lnum &lt; VIsual.lnum)</a>
<a name="ln3675">      dir = BACKWARD;</a>
<a name="ln3676">    else</a>
<a name="ln3677">      dir = FORWARD;</a>
<a name="ln3678">    for (i = count; --i &gt;= 0; ) {</a>
<a name="ln3679">      if (start_lnum ==</a>
<a name="ln3680">          (dir == BACKWARD ? 1 : curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln3681">        retval = FAIL;</a>
<a name="ln3682">        break;</a>
<a name="ln3683">      }</a>
<a name="ln3684"> </a>
<a name="ln3685">      prev_start_is_white = -1;</a>
<a name="ln3686">      for (t = 0; t &lt; 2; ++t) {</a>
<a name="ln3687">        start_lnum += dir;</a>
<a name="ln3688">        start_is_white = linewhite(start_lnum);</a>
<a name="ln3689">        if (prev_start_is_white == start_is_white) {</a>
<a name="ln3690">          start_lnum -= dir;</a>
<a name="ln3691">          break;</a>
<a name="ln3692">        }</a>
<a name="ln3693">        for (;; ) {</a>
<a name="ln3694">          if (start_lnum == (dir == BACKWARD</a>
<a name="ln3695">                             ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3696">            break;</a>
<a name="ln3697">          if (start_is_white != linewhite(start_lnum + dir)</a>
<a name="ln3698">              || (!start_is_white</a>
<a name="ln3699">                  &amp;&amp; startPS(start_lnum + (dir &gt; 0</a>
<a name="ln3700">                                           ? 1 : 0), 0, 0)))</a>
<a name="ln3701">            break;</a>
<a name="ln3702">          start_lnum += dir;</a>
<a name="ln3703">        }</a>
<a name="ln3704">        if (!include)</a>
<a name="ln3705">          break;</a>
<a name="ln3706">        if (start_lnum == (dir == BACKWARD</a>
<a name="ln3707">                           ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3708">          break;</a>
<a name="ln3709">        prev_start_is_white = start_is_white;</a>
<a name="ln3710">      }</a>
<a name="ln3711">    }</a>
<a name="ln3712">    curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln3713">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3714">    return retval;</a>
<a name="ln3715">  }</a>
<a name="ln3716"> </a>
<a name="ln3717">  /*</a>
<a name="ln3718">   * First move back to the start_lnum of the paragraph or white lines</a>
<a name="ln3719">   */</a>
<a name="ln3720">  white_in_front = linewhite(start_lnum);</a>
<a name="ln3721">  while (start_lnum &gt; 1) {</a>
<a name="ln3722">    if (white_in_front) {           /* stop at first white line */</a>
<a name="ln3723">      if (!linewhite(start_lnum - 1))</a>
<a name="ln3724">        break;</a>
<a name="ln3725">    } else {          /* stop at first non-white line of start of paragraph */</a>
<a name="ln3726">      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))</a>
<a name="ln3727">        break;</a>
<a name="ln3728">    }</a>
<a name="ln3729">    --start_lnum;</a>
<a name="ln3730">  }</a>
<a name="ln3731"> </a>
<a name="ln3732">  /*</a>
<a name="ln3733">   * Move past the end of any white lines.</a>
<a name="ln3734">   */</a>
<a name="ln3735">  end_lnum = start_lnum;</a>
<a name="ln3736">  while (end_lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; linewhite(end_lnum))</a>
<a name="ln3737">    ++end_lnum;</a>
<a name="ln3738"> </a>
<a name="ln3739">  --end_lnum;</a>
<a name="ln3740">  i = count;</a>
<a name="ln3741">  if (!include &amp;&amp; white_in_front)</a>
<a name="ln3742">    --i;</a>
<a name="ln3743">  while (i--) {</a>
<a name="ln3744">    if (end_lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3745">      return FAIL;</a>
<a name="ln3746"> </a>
<a name="ln3747">    if (!include)</a>
<a name="ln3748">      do_white = linewhite(end_lnum + 1);</a>
<a name="ln3749"> </a>
<a name="ln3750">    if (include || !do_white) {</a>
<a name="ln3751">      ++end_lnum;</a>
<a name="ln3752">      /*</a>
<a name="ln3753">       * skip to end of paragraph</a>
<a name="ln3754">       */</a>
<a name="ln3755">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3756">             &amp;&amp; !linewhite(end_lnum + 1)</a>
<a name="ln3757">             &amp;&amp; !startPS(end_lnum + 1, 0, 0))</a>
<a name="ln3758">        ++end_lnum;</a>
<a name="ln3759">    }</a>
<a name="ln3760"> </a>
<a name="ln3761">    if (i == 0 &amp;&amp; white_in_front &amp;&amp; include)</a>
<a name="ln3762">      break;</a>
<a name="ln3763"> </a>
<a name="ln3764">    /*</a>
<a name="ln3765">     * skip to end of white lines after paragraph</a>
<a name="ln3766">     */</a>
<a name="ln3767">    if (include || do_white)</a>
<a name="ln3768">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3769">             &amp;&amp; linewhite(end_lnum + 1))</a>
<a name="ln3770">        ++end_lnum;</a>
<a name="ln3771">  }</a>
<a name="ln3772"> </a>
<a name="ln3773">  /*</a>
<a name="ln3774">   * If there are no empty lines at the end, try to find some empty lines at</a>
<a name="ln3775">   * the start (unless that has been done already).</a>
<a name="ln3776">   */</a>
<a name="ln3777">  if (!white_in_front &amp;&amp; !linewhite(end_lnum) &amp;&amp; include)</a>
<a name="ln3778">    while (start_lnum &gt; 1 &amp;&amp; linewhite(start_lnum - 1))</a>
<a name="ln3779">      --start_lnum;</a>
<a name="ln3780"> </a>
<a name="ln3781">  if (VIsual_active) {</a>
<a name="ln3782">    // Problem: when doing &quot;Vipipip&quot; nothing happens in a single white</a>
<a name="ln3783">    // line, we get stuck there.  Trap this here.</a>
<a name="ln3784">    if (VIsual_mode == 'V' &amp;&amp; start_lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3785">      goto extend;</a>
<a name="ln3786">    }</a>
<a name="ln3787">    if (VIsual.lnum != start_lnum) {</a>
<a name="ln3788">        VIsual.lnum = start_lnum;</a>
<a name="ln3789">        VIsual.col = 0;</a>
<a name="ln3790">    }</a>
<a name="ln3791">    VIsual_mode = 'V';</a>
<a name="ln3792">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3793">    showmode();</a>
<a name="ln3794">  } else {</a>
<a name="ln3795">    oap-&gt;start.lnum = start_lnum;</a>
<a name="ln3796">    oap-&gt;start.col = 0;</a>
<a name="ln3797">    oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln3798">  }</a>
<a name="ln3799">  curwin-&gt;w_cursor.lnum = end_lnum;</a>
<a name="ln3800">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3801"> </a>
<a name="ln3802">  return OK;</a>
<a name="ln3803">}</a>
<a name="ln3804"> </a>
<a name="ln3805"> </a>
<a name="ln3806">/*</a>
<a name="ln3807"> * Search quote char from string line[col].</a>
<a name="ln3808"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3809"> * as a quote.</a>
<a name="ln3810"> * Returns column number of &quot;quotechar&quot; or -1 when not found.</a>
<a name="ln3811"> */</a>
<a name="ln3812">static int</a>
<a name="ln3813">find_next_quote(</a>
<a name="ln3814">    char_u *line,</a>
<a name="ln3815">    int col,</a>
<a name="ln3816">    int quotechar,</a>
<a name="ln3817">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3818">)</a>
<a name="ln3819">{</a>
<a name="ln3820">  int c;</a>
<a name="ln3821"> </a>
<a name="ln3822">  for (;; ) {</a>
<a name="ln3823">    c = line[col];</a>
<a name="ln3824">    if (c == NUL) {</a>
<a name="ln3825">      return -1;</a>
<a name="ln3826">    } else if (escape != NULL &amp;&amp; vim_strchr(escape, c)) {</a>
<a name="ln3827">      col++;</a>
<a name="ln3828">    } else if (c == quotechar) {</a>
<a name="ln3829">      break;</a>
<a name="ln3830">    }</a>
<a name="ln3831">    col += mb_ptr2len(line + col);</a>
<a name="ln3832">  }</a>
<a name="ln3833">  return col;</a>
<a name="ln3834">}</a>
<a name="ln3835"> </a>
<a name="ln3836">/*</a>
<a name="ln3837"> * Search backwards in &quot;line&quot; from column &quot;col_start&quot; to find &quot;quotechar&quot;.</a>
<a name="ln3838"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3839"> * as a quote.</a>
<a name="ln3840"> * Return the found column or zero.</a>
<a name="ln3841"> */</a>
<a name="ln3842">static int</a>
<a name="ln3843">find_prev_quote(</a>
<a name="ln3844">    char_u *line,</a>
<a name="ln3845">    int col_start,</a>
<a name="ln3846">    int quotechar,</a>
<a name="ln3847">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3848">)</a>
<a name="ln3849">{</a>
<a name="ln3850">  int n;</a>
<a name="ln3851"> </a>
<a name="ln3852">  while (col_start &gt; 0) {</a>
<a name="ln3853">    col_start--;</a>
<a name="ln3854">    col_start -= utf_head_off(line, line + col_start);</a>
<a name="ln3855">    n = 0;</a>
<a name="ln3856">    if (escape != NULL)</a>
<a name="ln3857">      while (col_start - n &gt; 0 &amp;&amp; vim_strchr(escape,</a>
<a name="ln3858">                 line[col_start - n - 1]) != NULL)</a>
<a name="ln3859">        ++n;</a>
<a name="ln3860">    if (n &amp; 1)</a>
<a name="ln3861">      col_start -= n;           /* uneven number of escape chars, skip it */</a>
<a name="ln3862">    else if (line[col_start] == quotechar)</a>
<a name="ln3863">      break;</a>
<a name="ln3864">  }</a>
<a name="ln3865">  return col_start;</a>
<a name="ln3866">}</a>
<a name="ln3867"> </a>
<a name="ln3868">// Find quote under the cursor, cursor at end.</a>
<a name="ln3869">// Returns true if found, else false.</a>
<a name="ln3870">bool current_quote(</a>
<a name="ln3871">    oparg_T *oap,</a>
<a name="ln3872">    long count,</a>
<a name="ln3873">    bool include,                 // true == include quote char</a>
<a name="ln3874">    int quotechar                 // Quote character</a>
<a name="ln3875">)</a>
<a name="ln3876">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3877">{</a>
<a name="ln3878">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3879">  int col_end;</a>
<a name="ln3880">  int col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3881">  bool inclusive = false;</a>
<a name="ln3882">  bool vis_empty = true;                // Visual selection &lt;= 1 char</a>
<a name="ln3883">  bool vis_bef_curs = false;            // Visual starts before cursor</a>
<a name="ln3884">  bool did_exclusive_adj = false;       // adjusted pos for 'selection'</a>
<a name="ln3885">  bool inside_quotes = false;           // Looks like &quot;i'&quot; done before</a>
<a name="ln3886">  bool selected_quote = false;          // Has quote inside selection</a>
<a name="ln3887">  int i;</a>
<a name="ln3888">  bool restore_vis_bef = false;         // resotre VIsual on abort</a>
<a name="ln3889"> </a>
<a name="ln3890">  // When 'selection' is &quot;exclusive&quot; move the cursor to where it would be</a>
<a name="ln3891">  // with 'selection' &quot;inclusive&quot;, so that the logic is the same for both.</a>
<a name="ln3892">  // The cursor then is moved forward after adjusting the area.</a>
<a name="ln3893">  if (VIsual_active) {</a>
<a name="ln3894">    // this only works within one line</a>
<a name="ln3895">    if (VIsual.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3896">        return false;</a>
<a name="ln3897">    }</a>
<a name="ln3898"> </a>
<a name="ln3899">    vis_bef_curs = lt(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3900">    vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3901">    if (*p_sel == 'e') {</a>
<a name="ln3902">      if (vis_bef_curs) {</a>
<a name="ln3903">        dec_cursor();</a>
<a name="ln3904">        did_exclusive_adj = true;</a>
<a name="ln3905">      } else if (!vis_empty) {</a>
<a name="ln3906">        dec(&amp;VIsual);</a>
<a name="ln3907">        did_exclusive_adj = true;</a>
<a name="ln3908">      }</a>
<a name="ln3909">      vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3910">      if (!vis_bef_curs &amp;&amp; !vis_empty) {</a>
<a name="ln3911">        // VIsual needs to be start of Visual selection.</a>
<a name="ln3912">        pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln3913"> </a>
<a name="ln3914">        curwin-&gt;w_cursor = VIsual;</a>
<a name="ln3915">        VIsual = t;</a>
<a name="ln3916">        vis_bef_curs = true;</a>
<a name="ln3917">        restore_vis_bef = true;</a>
<a name="ln3918">      }</a>
<a name="ln3919">    }</a>
<a name="ln3920">  }</a>
<a name="ln3921"> </a>
<a name="ln3922">  if (!vis_empty) {</a>
<a name="ln3923">    /* Check if the existing selection exactly spans the text inside</a>
<a name="ln3924">     * quotes. */</a>
<a name="ln3925">    if (vis_bef_curs) {</a>
<a name="ln3926">      inside_quotes = VIsual.col &gt; 0</a>
<a name="ln3927">                      &amp;&amp; line[VIsual.col - 1] == quotechar</a>
<a name="ln3928">                      &amp;&amp; line[curwin-&gt;w_cursor.col] != NUL</a>
<a name="ln3929">                      &amp;&amp; line[curwin-&gt;w_cursor.col + 1] == quotechar;</a>
<a name="ln3930">      i = VIsual.col;</a>
<a name="ln3931">      col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3932">    } else {</a>
<a name="ln3933">      inside_quotes = curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3934">                      &amp;&amp; line[curwin-&gt;w_cursor.col - 1] == quotechar</a>
<a name="ln3935">                      &amp;&amp; line[VIsual.col] != NUL</a>
<a name="ln3936">                      &amp;&amp; line[VIsual.col + 1] == quotechar;</a>
<a name="ln3937">      i = curwin-&gt;w_cursor.col;</a>
<a name="ln3938">      col_end = VIsual.col;</a>
<a name="ln3939">    }</a>
<a name="ln3940"> </a>
<a name="ln3941">    /* Find out if we have a quote in the selection. */</a>
<a name="ln3942">    while (i &lt;= col_end)</a>
<a name="ln3943">      if (line[i++] == quotechar) {</a>
<a name="ln3944">        selected_quote = true;</a>
<a name="ln3945">        break;</a>
<a name="ln3946">      }</a>
<a name="ln3947">  }</a>
<a name="ln3948"> </a>
<a name="ln3949">  if (!vis_empty &amp;&amp; line[col_start] == quotechar) {</a>
<a name="ln3950">    /* Already selecting something and on a quote character.  Find the</a>
<a name="ln3951">     * next quoted string. */</a>
<a name="ln3952">    if (vis_bef_curs) {</a>
<a name="ln3953">      /* Assume we are on a closing quote: move to after the next</a>
<a name="ln3954">       * opening quote. */</a>
<a name="ln3955">      col_start = find_next_quote(line, col_start + 1, quotechar, NULL);</a>
<a name="ln3956">      if (col_start &lt; 0) {</a>
<a name="ln3957">        goto abort_search;</a>
<a name="ln3958">      }</a>
<a name="ln3959">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln3960">          curbuf-&gt;b_p_qe);</a>
<a name="ln3961">      if (col_end &lt; 0) {</a>
<a name="ln3962">        /* We were on a starting quote perhaps? */</a>
<a name="ln3963">        col_end = col_start;</a>
<a name="ln3964">        col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3965">      }</a>
<a name="ln3966">    } else {</a>
<a name="ln3967">      col_end = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3968">      if (line[col_end] != quotechar) {</a>
<a name="ln3969">        goto abort_search;</a>
<a name="ln3970">      }</a>
<a name="ln3971">      col_start = find_prev_quote(line, col_end, quotechar,</a>
<a name="ln3972">          curbuf-&gt;b_p_qe);</a>
<a name="ln3973">      if (line[col_start] != quotechar) {</a>
<a name="ln3974">        /* We were on an ending quote perhaps? */</a>
<a name="ln3975">        col_start = col_end;</a>
<a name="ln3976">        col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3977">      }</a>
<a name="ln3978">    }</a>
<a name="ln3979">  } else if (line[col_start] == quotechar</a>
<a name="ln3980">             || !vis_empty</a>
<a name="ln3981">             ) {</a>
<a name="ln3982">    int first_col = col_start;</a>
<a name="ln3983"> </a>
<a name="ln3984">    if (!vis_empty) {</a>
<a name="ln3985">      if (vis_bef_curs)</a>
<a name="ln3986">        first_col = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3987">      else</a>
<a name="ln3988">        first_col = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3989">    }</a>
<a name="ln3990">    /* The cursor is on a quote, we don't know if it's the opening or</a>
<a name="ln3991">     * closing quote.  Search from the start of the line to find out.</a>
<a name="ln3992">     * Also do this when there is a Visual area, a' may leave the cursor</a>
<a name="ln3993">     * in between two strings. */</a>
<a name="ln3994">    col_start = 0;</a>
<a name="ln3995">    for (;; ) {</a>
<a name="ln3996">      /* Find open quote character. */</a>
<a name="ln3997">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3998">      if (col_start &lt; 0 || col_start &gt; first_col) {</a>
<a name="ln3999">        goto abort_search;</a>
<a name="ln4000">      }</a>
<a name="ln4001">      // Find close quote character.</a>
<a name="ln4002">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4003">          curbuf-&gt;b_p_qe);</a>
<a name="ln4004">      if (col_end &lt; 0) {</a>
<a name="ln4005">        goto abort_search;</a>
<a name="ln4006">      }</a>
<a name="ln4007">      // If is cursor between start and end quote character, it is</a>
<a name="ln4008">      // target text object.</a>
<a name="ln4009">      if (col_start &lt;= first_col &amp;&amp; first_col &lt;= col_end) {</a>
<a name="ln4010">        break;</a>
<a name="ln4011">      }</a>
<a name="ln4012">      col_start = col_end + 1;</a>
<a name="ln4013">    }</a>
<a name="ln4014">  } else {</a>
<a name="ln4015">    /* Search backward for a starting quote. */</a>
<a name="ln4016">    col_start = find_prev_quote(line, col_start, quotechar, curbuf-&gt;b_p_qe);</a>
<a name="ln4017">    if (line[col_start] != quotechar) {</a>
<a name="ln4018">      /* No quote before the cursor, look after the cursor. */</a>
<a name="ln4019">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln4020">      if (col_start &lt; 0) {</a>
<a name="ln4021">        goto abort_search;</a>
<a name="ln4022">      }</a>
<a name="ln4023">    }</a>
<a name="ln4024"> </a>
<a name="ln4025">    /* Find close quote character. */</a>
<a name="ln4026">    col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4027">                              curbuf-&gt;b_p_qe);</a>
<a name="ln4028">    if (col_end &lt; 0) {</a>
<a name="ln4029">      goto abort_search;</a>
<a name="ln4030">    }</a>
<a name="ln4031">  }</a>
<a name="ln4032"> </a>
<a name="ln4033">  // When &quot;include&quot; is true, include spaces after closing quote or before</a>
<a name="ln4034">  // the starting quote.</a>
<a name="ln4035">  if (include) {</a>
<a name="ln4036">    if (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4037">      while (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4038">        ++col_end;</a>
<a name="ln4039">    else</a>
<a name="ln4040">      while (col_start &gt; 0 &amp;&amp; ascii_iswhite(line[col_start - 1]))</a>
<a name="ln4041">        --col_start;</a>
<a name="ln4042">  }</a>
<a name="ln4043"> </a>
<a name="ln4044">  /* Set start position.  After vi&quot; another i&quot; must include the &quot;.</a>
<a name="ln4045">   * For v2i&quot; include the quotes. */</a>
<a name="ln4046">  if (!include &amp;&amp; count &lt; 2</a>
<a name="ln4047">      &amp;&amp; (vis_empty || !inside_quotes)</a>
<a name="ln4048">      )</a>
<a name="ln4049">    ++col_start;</a>
<a name="ln4050">  curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4051">  if (VIsual_active) {</a>
<a name="ln4052">    /* Set the start of the Visual area when the Visual area was empty, we</a>
<a name="ln4053">     * were just inside quotes or the Visual area didn't start at a quote</a>
<a name="ln4054">     * and didn't include a quote.</a>
<a name="ln4055">     */</a>
<a name="ln4056">    if (vis_empty</a>
<a name="ln4057">        || (vis_bef_curs</a>
<a name="ln4058">            &amp;&amp; !selected_quote</a>
<a name="ln4059">            &amp;&amp; (inside_quotes</a>
<a name="ln4060">                || (line[VIsual.col] != quotechar</a>
<a name="ln4061">                    &amp;&amp; (VIsual.col == 0</a>
<a name="ln4062">                        || line[VIsual.col - 1] != quotechar))))) {</a>
<a name="ln4063">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4064">      redraw_curbuf_later(INVERTED);</a>
<a name="ln4065">    }</a>
<a name="ln4066">  } else {</a>
<a name="ln4067">    oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln4068">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln4069">  }</a>
<a name="ln4070"> </a>
<a name="ln4071">  /* Set end position. */</a>
<a name="ln4072">  curwin-&gt;w_cursor.col = col_end;</a>
<a name="ln4073">  if ((include || count &gt; 1</a>
<a name="ln4074">       /* After vi&quot; another i&quot; must include the &quot;. */</a>
<a name="ln4075">       || (!vis_empty &amp;&amp; inside_quotes)</a>
<a name="ln4076">       ) &amp;&amp; inc_cursor() == 2)</a>
<a name="ln4077">    inclusive = true;</a>
<a name="ln4078">  if (VIsual_active) {</a>
<a name="ln4079">    if (vis_empty || vis_bef_curs) {</a>
<a name="ln4080">      // decrement cursor when 'selection' is not exclusive</a>
<a name="ln4081">      if (*p_sel != 'e') {</a>
<a name="ln4082">        dec_cursor();</a>
<a name="ln4083">      }</a>
<a name="ln4084">    } else {</a>
<a name="ln4085">      /* Cursor is at start of Visual area.  Set the end of the Visual</a>
<a name="ln4086">       * area when it was just inside quotes or it didn't end at a</a>
<a name="ln4087">       * quote. */</a>
<a name="ln4088">      if (inside_quotes</a>
<a name="ln4089">          || (!selected_quote</a>
<a name="ln4090">              &amp;&amp; line[VIsual.col] != quotechar</a>
<a name="ln4091">              &amp;&amp; (line[VIsual.col] == NUL</a>
<a name="ln4092">                  || line[VIsual.col + 1] != quotechar))) {</a>
<a name="ln4093">        dec_cursor();</a>
<a name="ln4094">        VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4095">      }</a>
<a name="ln4096">      curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4097">    }</a>
<a name="ln4098">    if (VIsual_mode == 'V') {</a>
<a name="ln4099">      VIsual_mode = 'v';</a>
<a name="ln4100">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln4101">    }</a>
<a name="ln4102">  } else {</a>
<a name="ln4103">    /* Set inclusive and other oap's flags. */</a>
<a name="ln4104">    oap-&gt;inclusive = inclusive;</a>
<a name="ln4105">  }</a>
<a name="ln4106"> </a>
<a name="ln4107">  return true;</a>
<a name="ln4108"> </a>
<a name="ln4109">abort_search:</a>
<a name="ln4110">  if (VIsual_active &amp;&amp; *p_sel == 'e') {</a>
<a name="ln4111">    if (did_exclusive_adj) {</a>
<a name="ln4112">      inc_cursor();</a>
<a name="ln4113">    }</a>
<a name="ln4114">    if (restore_vis_bef) {</a>
<a name="ln4115">       pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln4116"> </a>
<a name="ln4117">       curwin-&gt;w_cursor = VIsual;</a>
<a name="ln4118">       VIsual = t;</a>
<a name="ln4119">    }</a>
<a name="ln4120">  }</a>
<a name="ln4121">  return false;</a>
<a name="ln4122">}</a>
<a name="ln4123"> </a>
<a name="ln4124"> </a>
<a name="ln4125"> </a>
<a name="ln4126">/*</a>
<a name="ln4127"> * Find next search match under cursor, cursor at end.</a>
<a name="ln4128"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln4129"> */</a>
<a name="ln4130">int</a>
<a name="ln4131">current_search(</a>
<a name="ln4132">    long count,</a>
<a name="ln4133">    bool forward  // true for forward, false for backward</a>
<a name="ln4134">)</a>
<a name="ln4135">{</a>
<a name="ln4136">  bool old_p_ws = p_ws;</a>
<a name="ln4137">  pos_T save_VIsual = VIsual;</a>
<a name="ln4138"> </a>
<a name="ln4139">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln4140">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln4141">    dec_cursor();</a>
<a name="ln4142"> </a>
<a name="ln4143">  pos_T end_pos;                // end position of the pattern match</a>
<a name="ln4144">  pos_T orig_pos;               // position of the cursor at beginning</a>
<a name="ln4145">  pos_T pos;                    // position after the pattern</a>
<a name="ln4146">  int result;                   // result of various function calls</a>
<a name="ln4147"> </a>
<a name="ln4148">  // When searching forward and the cursor is at the start of the Visual</a>
<a name="ln4149">  // area, skip the first search backward, otherwise it doesn't move.</a>
<a name="ln4150">  const bool skip_first_backward = forward &amp;&amp; VIsual_active</a>
<a name="ln4151">    &amp;&amp; lt(curwin-&gt;w_cursor, VIsual);</a>
<a name="ln4152"> </a>
<a name="ln4153">  orig_pos = pos = curwin-&gt;w_cursor;</a>
<a name="ln4154">  if (VIsual_active) {</a>
<a name="ln4155">    // Searching further will extend the match.</a>
<a name="ln4156">    if (forward) {</a>
<a name="ln4157">      incl(&amp;pos);</a>
<a name="ln4158">    } else {</a>
<a name="ln4159">      decl(&amp;pos);</a>
<a name="ln4160">    }</a>
<a name="ln4161">  }</a>
<a name="ln4162"> </a>
<a name="ln4163">  // Is the pattern is zero-width?, this time, don't care about the direction</a>
<a name="ln4164">  int zero_width = is_zero_width(spats[last_idx].pat, true, &amp;curwin-&gt;w_cursor,</a>
<a name="ln4165">                                 FORWARD);</a>
<a name="ln4166">  if (zero_width == -1) {</a>
<a name="ln4167">    return FAIL;  // pattern not found</a>
<a name="ln4168">  }</a>
<a name="ln4169"> </a>
<a name="ln4170">  // The trick is to first search backwards and then search forward again,</a>
<a name="ln4171">  // so that a match at the current cursor position will be correctly</a>
<a name="ln4172">  // captured.  When &quot;forward&quot; is false do it the other way around.</a>
<a name="ln4173">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln4174">    int dir;</a>
<a name="ln4175">    if (forward) {</a>
<a name="ln4176">      if (i == 0 &amp;&amp; skip_first_backward) {</a>
<a name="ln4177">        continue;</a>
<a name="ln4178">      }</a>
<a name="ln4179">      dir = i;</a>
<a name="ln4180">    } else {</a>
<a name="ln4181">      dir = !i;</a>
<a name="ln4182">    }</a>
<a name="ln4183"> </a>
<a name="ln4184">    int flags = 0;</a>
<a name="ln4185"> </a>
<a name="ln4186">    if (!dir &amp;&amp; !zero_width) {</a>
<a name="ln4187">      flags = SEARCH_END;</a>
<a name="ln4188">    }</a>
<a name="ln4189">    end_pos = pos;</a>
<a name="ln4190"> </a>
<a name="ln4191">    // wrapping should not occur in the first round</a>
<a name="ln4192">    if (i == 0) {</a>
<a name="ln4193">      p_ws = false;</a>
<a name="ln4194">    }</a>
<a name="ln4195"> </a>
<a name="ln4196">    result = searchit(curwin, curbuf, &amp;pos, &amp;end_pos,</a>
<a name="ln4197">                      (dir ? FORWARD : BACKWARD),</a>
<a name="ln4198">                      spats[last_idx].pat, i ? count : 1,</a>
<a name="ln4199">                      SEARCH_KEEP | flags, RE_SEARCH, NULL);</a>
<a name="ln4200"> </a>
<a name="ln4201">    p_ws = old_p_ws;</a>
<a name="ln4202"> </a>
<a name="ln4203">    // First search may fail, but then start searching from the</a>
<a name="ln4204">    // beginning of the file (cursor might be on the search match)</a>
<a name="ln4205">    // except when Visual mode is active, so that extending the visual</a>
<a name="ln4206">    // selection works.</a>
<a name="ln4207">    if (i == 1 &amp;&amp; !result) {  // not found, abort */</a>
<a name="ln4208">      curwin-&gt;w_cursor = orig_pos;</a>
<a name="ln4209">      if (VIsual_active)</a>
<a name="ln4210">        VIsual = save_VIsual;</a>
<a name="ln4211">      return FAIL;</a>
<a name="ln4212">    } else if (i == 0 &amp;&amp; !result) {</a>
<a name="ln4213">      if (forward) {  // try again from start of buffer</a>
<a name="ln4214">        clearpos(&amp;pos);</a>
<a name="ln4215">      } else {  // try again from end of buffer</a>
<a name="ln4216">                // searching backwards, so set pos to last line and col</a>
<a name="ln4217">        pos.lnum = curwin-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln4218">        pos.col  = (colnr_T)STRLEN(</a>
<a name="ln4219">            ml_get(curwin-&gt;w_buffer-&gt;b_ml.ml_line_count));</a>
<a name="ln4220">      }</a>
<a name="ln4221">    }</a>
<a name="ln4222">  }</a>
<a name="ln4223"> </a>
<a name="ln4224">  pos_T start_pos = pos;</a>
<a name="ln4225"> </a>
<a name="ln4226">  if (!VIsual_active) {</a>
<a name="ln4227">    VIsual = start_pos;</a>
<a name="ln4228">  }</a>
<a name="ln4229"> </a>
<a name="ln4230">  // put the cursor after the match</a>
<a name="ln4231">  curwin-&gt;w_cursor = end_pos;</a>
<a name="ln4232">  if (lt(VIsual, end_pos) &amp;&amp; forward) {</a>
<a name="ln4233">    if (skip_first_backward) {</a>
<a name="ln4234">      // put the cursor on the start of the match</a>
<a name="ln4235">      curwin-&gt;w_cursor = pos;</a>
<a name="ln4236">    } else {</a>
<a name="ln4237">      // put the cursor on last character of match</a>
<a name="ln4238">      dec_cursor();</a>
<a name="ln4239">    }</a>
<a name="ln4240">  } else if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual) &amp;&amp; forward) {</a>
<a name="ln4241">    curwin-&gt;w_cursor = pos;   // put the cursor on the start of the match</a>
<a name="ln4242">  }</a>
<a name="ln4243">  VIsual_active = true;</a>
<a name="ln4244">  VIsual_mode = 'v';</a>
<a name="ln4245"> </a>
<a name="ln4246">  if (*p_sel == 'e') {</a>
<a name="ln4247">    // Correction for exclusive selection depends on the direction.</a>
<a name="ln4248">    if (forward &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln4249">      inc_cursor();</a>
<a name="ln4250">    } else if (!forward &amp;&amp; ltoreq(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln4251">      inc(&amp;VIsual);</a>
<a name="ln4252">    }</a>
<a name="ln4253">  }</a>
<a name="ln4254"> </a>
<a name="ln4255">  if (fdo_flags &amp; FDO_SEARCH &amp;&amp; KeyTyped) {</a>
<a name="ln4256">    foldOpenCursor();</a>
<a name="ln4257">  }</a>
<a name="ln4258"> </a>
<a name="ln4259">  may_start_select('c');</a>
<a name="ln4260">  setmouse();</a>
<a name="ln4261">  redraw_curbuf_later(INVERTED);</a>
<a name="ln4262">  showmode();</a>
<a name="ln4263"> </a>
<a name="ln4264">  return OK;</a>
<a name="ln4265">}</a>
<a name="ln4266"> </a>
<a name="ln4267">/// Check if the pattern is zero-width.</a>
<a name="ln4268">/// If move is true, check from the beginning of the buffer,</a>
<a name="ln4269">/// else from position &quot;cur&quot;.</a>
<a name="ln4270">/// &quot;direction&quot; is FORWARD or BACKWARD.</a>
<a name="ln4271">/// Returns TRUE, FALSE or -1 for failure.</a>
<a name="ln4272">static int</a>
<a name="ln4273">is_zero_width(char_u *pattern, int move, pos_T *cur, Direction direction)</a>
<a name="ln4274">{</a>
<a name="ln4275">  regmmatch_T regmatch;</a>
<a name="ln4276">  int nmatched = 0;</a>
<a name="ln4277">  int result = -1;</a>
<a name="ln4278">  pos_T pos;</a>
<a name="ln4279">  int save_called_emsg = called_emsg;</a>
<a name="ln4280">  int flag = 0;</a>
<a name="ln4281"> </a>
<a name="ln4282">  if (pattern == NULL) {</a>
<a name="ln4283">    pattern = spats[last_idx].pat;</a>
<a name="ln4284">  }</a>
<a name="ln4285"> </a>
<a name="ln4286">  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,</a>
<a name="ln4287">          SEARCH_KEEP, &amp;regmatch) == FAIL)</a>
<a name="ln4288">    return -1;</a>
<a name="ln4289"> </a>
<a name="ln4290">  // init startcol correctly</a>
<a name="ln4291">  regmatch.startpos[0].col = -1;</a>
<a name="ln4292">  // move to match</a>
<a name="ln4293">  if (move) {</a>
<a name="ln4294">    clearpos(&amp;pos);</a>
<a name="ln4295">  } else {</a>
<a name="ln4296">    pos = *cur;</a>
<a name="ln4297">    // accept a match at the cursor position</a>
<a name="ln4298">    flag = SEARCH_START;</a>
<a name="ln4299">  }</a>
<a name="ln4300">  if (searchit(curwin, curbuf, &amp;pos, NULL, direction, pattern, 1,</a>
<a name="ln4301">               SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL) {</a>
<a name="ln4302">    // Zero-width pattern should match somewhere, then we can check if</a>
<a name="ln4303">    // start and end are in the same position.</a>
<a name="ln4304">    called_emsg = false;</a>
<a name="ln4305">    do {</a>
<a name="ln4306">      regmatch.startpos[0].col++;</a>
<a name="ln4307">      nmatched = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4308">                                   pos.lnum, regmatch.startpos[0].col,</a>
<a name="ln4309">                                   NULL, NULL);</a>
<a name="ln4310">      if (nmatched != 0) {</a>
<a name="ln4311">        break;</a>
<a name="ln4312">      }</a>
<a name="ln4313">    } while (regmatch.regprog != NULL</a>
<a name="ln4314">             &amp;&amp; direction == FORWARD</a>
<a name="ln4315">             ? regmatch.startpos[0].col &lt; pos.col</a>
<a name="ln4316">             : regmatch.startpos[0].col &gt; pos.col);</a>
<a name="ln4317"> </a>
<a name="ln4318">    if (!called_emsg) {</a>
<a name="ln4319">      result = (nmatched != 0</a>
<a name="ln4320">                &amp;&amp; regmatch.startpos[0].lnum == regmatch.endpos[0].lnum</a>
<a name="ln4321">                &amp;&amp; regmatch.startpos[0].col == regmatch.endpos[0].col);</a>
<a name="ln4322">    }</a>
<a name="ln4323">  }</a>
<a name="ln4324"> </a>
<a name="ln4325">  called_emsg |= save_called_emsg;</a>
<a name="ln4326">  vim_regfree(regmatch.regprog);</a>
<a name="ln4327">  return result;</a>
<a name="ln4328">}</a>
<a name="ln4329"> </a>
<a name="ln4330">/*</a>
<a name="ln4331"> * return TRUE if line 'lnum' is empty or has white chars only.</a>
<a name="ln4332"> */</a>
<a name="ln4333">int linewhite(linenr_T lnum)</a>
<a name="ln4334">{</a>
<a name="ln4335">  char_u  *p;</a>
<a name="ln4336"> </a>
<a name="ln4337">  p = skipwhite(ml_get(lnum));</a>
<a name="ln4338">  return *p == NUL;</a>
<a name="ln4339">}</a>
<a name="ln4340"> </a>
<a name="ln4341">// Add the search count &quot;[3/19]&quot; to &quot;msgbuf&quot;.</a>
<a name="ln4342">// When &quot;recompute&quot; is true Always recompute the numbers.</a>
<a name="ln4343">static void search_stat(int dirc, pos_T *pos,</a>
<a name="ln4344">                        bool show_top_bot_msg, char_u *msgbuf, bool recompute)</a>
<a name="ln4345">{</a>
<a name="ln4346">    int       save_ws = p_ws;</a>
<a name="ln4347">    int       wraparound = false;</a>
<a name="ln4348">    pos_T     p = (*pos);</a>
<a name="ln4349">    static  pos_T   lastpos = { 0, 0, 0 };</a>
<a name="ln4350">    static int      cur = 0;</a>
<a name="ln4351">    static int      cnt = 0;</a>
<a name="ln4352">    static int      chgtick = 0;</a>
<a name="ln4353">    static char_u   *lastpat = NULL;</a>
<a name="ln4354">    static buf_T    *lbuf = NULL;</a>
<a name="ln4355">    proftime_T  start;</a>
<a name="ln4356">#define OUT_OF_TIME 999</a>
<a name="ln4357"> </a>
<a name="ln4358">    wraparound = ((dirc == '?' &amp;&amp; lt(lastpos, p))</a>
<a name="ln4359">                  || (dirc == '/' &amp;&amp; lt(p, lastpos)));</a>
<a name="ln4360"> </a>
<a name="ln4361">    // If anything relevant changed the count has to be recomputed.</a>
<a name="ln4362">    // STRNICMP ignores case, but we should not ignore case.</a>
<a name="ln4363">    // Unfortunately, there is no STRNICMP function.</a>
<a name="ln4364">    if (!(chgtick == buf_get_changedtick(curbuf)</a>
<a name="ln4365">          &amp;&amp; lastpat != NULL  // supress clang/NULL passed as nonnull parameter</a>
<a name="ln4366">          &amp;&amp; STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0</a>
<a name="ln4367">          &amp;&amp; STRLEN(lastpat) == STRLEN(spats[last_idx].pat)</a>
<a name="ln4368">          &amp;&amp; equalpos(lastpos, curwin-&gt;w_cursor)</a>
<a name="ln4369">          &amp;&amp; lbuf == curbuf)</a>
<a name="ln4370">        || wraparound || cur &lt; 0 || cur &gt; 99 || recompute) {</a>
<a name="ln4371">      cur = 0;</a>
<a name="ln4372">      cnt = 0;</a>
<a name="ln4373">      clearpos(&amp;lastpos);</a>
<a name="ln4374">      lbuf = curbuf;</a>
<a name="ln4375">    }</a>
<a name="ln4376"> </a>
<a name="ln4377">    if (equalpos(lastpos, curwin-&gt;w_cursor) &amp;&amp; !wraparound</a>
<a name="ln4378">        &amp;&amp; (dirc == '/' ? cur &lt; cnt : cur &gt; 0)) {</a>
<a name="ln4379">      cur += dirc == '/' ? 1 : -1;</a>
<a name="ln4380">    } else {</a>
<a name="ln4381">      p_ws = false;</a>
<a name="ln4382">      start = profile_setlimit(20L);</a>
<a name="ln4383">      while (!got_int &amp;&amp; searchit(curwin, curbuf, &amp;lastpos, NULL,</a>
<a name="ln4384">                                  FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST,</a>
<a name="ln4385">                                  NULL) != FAIL) {</a>
<a name="ln4386">        // Stop after passing the time limit.</a>
<a name="ln4387">        if (profile_passed_limit(start)) {</a>
<a name="ln4388">          cnt = OUT_OF_TIME;</a>
<a name="ln4389">          cur = OUT_OF_TIME;</a>
<a name="ln4390">          break;</a>
<a name="ln4391">        }</a>
<a name="ln4392">        cnt++;</a>
<a name="ln4393">        if (ltoreq(lastpos, p)) {</a>
<a name="ln4394">          cur++;</a>
<a name="ln4395">        }</a>
<a name="ln4396">        fast_breakcheck();</a>
<a name="ln4397">        if (cnt &gt; 99) {</a>
<a name="ln4398">          break;</a>
<a name="ln4399">        }</a>
<a name="ln4400">      }</a>
<a name="ln4401">      if (got_int) {</a>
<a name="ln4402">        cur = -1;  // abort</a>
<a name="ln4403">      }</a>
<a name="ln4404">    }</a>
<a name="ln4405">    if (cur &gt; 0) {</a>
<a name="ln4406">      char t[SEARCH_STAT_BUF_LEN] = &quot;&quot;;</a>
<a name="ln4407">      int len;</a>
<a name="ln4408"> </a>
<a name="ln4409">      if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln4410">        if (cur == OUT_OF_TIME) {</a>
<a name="ln4411">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?\?/?]&quot;);</a>
<a name="ln4412">        } else if (cnt &gt; 99 &amp;&amp; cur &gt; 99) {</a>
<a name="ln4413">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/&gt;99]&quot;);</a>
<a name="ln4414">        } else if (cnt &gt; 99) {</a>
<a name="ln4415">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/%d]&quot;, cur);</a>
<a name="ln4416">        } else {</a>
<a name="ln4417">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;, cnt, cur);</a>
<a name="ln4418">        }</a>
<a name="ln4419">      } else {</a>
<a name="ln4420">        if (cur == OUT_OF_TIME) {</a>
<a name="ln4421">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?/??]&quot;);</a>
<a name="ln4422">        } else if (cnt &gt; 99 &amp;&amp; cur &gt; 99) {</a>
<a name="ln4423">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;99/&gt;99]&quot;);</a>
<a name="ln4424">        } else if (cnt &gt; 99) {</a>
<a name="ln4425">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/&gt;99]&quot;, cur);</a>
<a name="ln4426">        } else {</a>
<a name="ln4427">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;, cur, cnt);</a>
<a name="ln4428">        }</a>
<a name="ln4429">      }</a>
<a name="ln4430"> </a>
<a name="ln4431">      len = STRLEN(t);</a>
<a name="ln4432">      if (show_top_bot_msg &amp;&amp; len + 2 &lt; SEARCH_STAT_BUF_LEN) {</a>
<a name="ln4433">        memmove(t + 2, t, len);</a>
<a name="ln4434">        t[0] = 'W';</a>
<a name="ln4435">        t[1] = ' ';</a>
<a name="ln4436">        len += 2;</a>
<a name="ln4437">      }</a>
<a name="ln4438"> </a>
<a name="ln4439">      memmove(msgbuf + STRLEN(msgbuf) - len, t, len);</a>
<a name="ln4440">      if (dirc == '?' &amp;&amp; cur == 100) {</a>
<a name="ln4441">        cur = -1;</a>
<a name="ln4442">      }</a>
<a name="ln4443"> </a>
<a name="ln4444">      xfree(lastpat);</a>
<a name="ln4445">      lastpat = vim_strsave(spats[last_idx].pat);</a>
<a name="ln4446">      chgtick = buf_get_changedtick(curbuf);</a>
<a name="ln4447">      lbuf    = curbuf;</a>
<a name="ln4448">      lastpos = p;</a>
<a name="ln4449"> </a>
<a name="ln4450">      // keep the message even after redraw, but don't put in history</a>
<a name="ln4451">      msg_hist_off = true;</a>
<a name="ln4452">      msg_ext_set_kind(&quot;search_count&quot;);</a>
<a name="ln4453">      give_warning(msgbuf, false);</a>
<a name="ln4454">      msg_hist_off = false;</a>
<a name="ln4455">    }</a>
<a name="ln4456">    p_ws = save_ws;</a>
<a name="ln4457">}</a>
<a name="ln4458"> </a>
<a name="ln4459">/*</a>
<a name="ln4460"> * Find identifiers or defines in included files.</a>
<a name="ln4461"> * If p_ic &amp;&amp; (compl_cont_status &amp; CONT_SOL) then ptr must be in lowercase.</a>
<a name="ln4462"> */</a>
<a name="ln4463">void</a>
<a name="ln4464">find_pattern_in_path(</a>
<a name="ln4465">    char_u *ptr,            // pointer to search pattern</a>
<a name="ln4466">    Direction dir,          // direction of expansion</a>
<a name="ln4467">    size_t len,             // length of search pattern</a>
<a name="ln4468">    bool whole,             // match whole words only</a>
<a name="ln4469">    bool skip_comments,     // don't match inside comments</a>
<a name="ln4470">    int type,               // Type of search; are we looking for a type?</a>
<a name="ln4471">                            // a macro?</a>
<a name="ln4472">    long count,</a>
<a name="ln4473">    int action,             // What to do when we find it</a>
<a name="ln4474">    linenr_T start_lnum,    // first line to start searching</a>
<a name="ln4475">    linenr_T end_lnum       // last line for searching</a>
<a name="ln4476">)</a>
<a name="ln4477">{</a>
<a name="ln4478">  SearchedFile *files;                  /* Stack of included files */</a>
<a name="ln4479">  SearchedFile *bigger;                 /* When we need more space */</a>
<a name="ln4480">  int max_path_depth = 50;</a>
<a name="ln4481">  long match_count = 1;</a>
<a name="ln4482"> </a>
<a name="ln4483">  char_u      *pat;</a>
<a name="ln4484">  char_u      *new_fname;</a>
<a name="ln4485">  char_u      *curr_fname = curbuf-&gt;b_fname;</a>
<a name="ln4486">  char_u      *prev_fname = NULL;</a>
<a name="ln4487">  linenr_T lnum;</a>
<a name="ln4488">  int depth;</a>
<a name="ln4489">  int depth_displayed;                  /* For type==CHECK_PATH */</a>
<a name="ln4490">  int old_files;</a>
<a name="ln4491">  int already_searched;</a>
<a name="ln4492">  char_u      *file_line;</a>
<a name="ln4493">  char_u      *line;</a>
<a name="ln4494">  char_u      *p;</a>
<a name="ln4495">  char_u save_char;</a>
<a name="ln4496">  int define_matched;</a>
<a name="ln4497">  regmatch_T regmatch;</a>
<a name="ln4498">  regmatch_T incl_regmatch;</a>
<a name="ln4499">  regmatch_T def_regmatch;</a>
<a name="ln4500">  int matched = FALSE;</a>
<a name="ln4501">  int did_show = FALSE;</a>
<a name="ln4502">  int found = FALSE;</a>
<a name="ln4503">  int i;</a>
<a name="ln4504">  char_u      *already = NULL;</a>
<a name="ln4505">  char_u      *startp = NULL;</a>
<a name="ln4506">  char_u      *inc_opt = NULL;</a>
<a name="ln4507">  win_T       *curwin_save = NULL;</a>
<a name="ln4508">  const int l_g_do_tagpreview = g_do_tagpreview;</a>
<a name="ln4509"> </a>
<a name="ln4510">  regmatch.regprog = NULL;</a>
<a name="ln4511">  incl_regmatch.regprog = NULL;</a>
<a name="ln4512">  def_regmatch.regprog = NULL;</a>
<a name="ln4513"> </a>
<a name="ln4514">  file_line = xmalloc(LSIZE);</a>
<a name="ln4515"> </a>
<a name="ln4516">  if (type != CHECK_PATH &amp;&amp; type != FIND_DEFINE</a>
<a name="ln4517">      /* when CONT_SOL is set compare &quot;ptr&quot; with the beginning of the line</a>
<a name="ln4518">       * is faster than quote_meta/regcomp/regexec &quot;ptr&quot; -- Acevedo */</a>
<a name="ln4519">      &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4520">      ) {</a>
<a name="ln4521">    pat = xmalloc(len + 5);</a>
<a name="ln4522">    assert(len &lt;= INT_MAX);</a>
<a name="ln4523">    sprintf((char *)pat, whole ? &quot;\\&lt;%.*s\\&gt;&quot; : &quot;%.*s&quot;, (int)len, ptr);</a>
<a name="ln4524">    /* ignore case according to p_ic, p_scs and pat */</a>
<a name="ln4525">    regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln4526">    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4527">    xfree(pat);</a>
<a name="ln4528">    if (regmatch.regprog == NULL)</a>
<a name="ln4529">      goto fpip_end;</a>
<a name="ln4530">  }</a>
<a name="ln4531">  inc_opt = (*curbuf-&gt;b_p_inc == NUL) ? p_inc : curbuf-&gt;b_p_inc;</a>
<a name="ln4532">  if (*inc_opt != NUL) {</a>
<a name="ln4533">    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4534">    if (incl_regmatch.regprog == NULL)</a>
<a name="ln4535">      goto fpip_end;</a>
<a name="ln4536">    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */</a>
<a name="ln4537">  }</a>
<a name="ln4538">  if (type == FIND_DEFINE &amp;&amp; (*curbuf-&gt;b_p_def != NUL || *p_def != NUL)) {</a>
<a name="ln4539">    def_regmatch.regprog = vim_regcomp(*curbuf-&gt;b_p_def == NUL</a>
<a name="ln4540">        ? p_def : curbuf-&gt;b_p_def, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4541">    if (def_regmatch.regprog == NULL)</a>
<a name="ln4542">      goto fpip_end;</a>
<a name="ln4543">    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */</a>
<a name="ln4544">  }</a>
<a name="ln4545">  files = xcalloc(max_path_depth, sizeof(SearchedFile));</a>
<a name="ln4546">  old_files = max_path_depth;</a>
<a name="ln4547">  depth = depth_displayed = -1;</a>
<a name="ln4548"> </a>
<a name="ln4549">  lnum = start_lnum;</a>
<a name="ln4550">  if (end_lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4551">    end_lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4552">  if (lnum &gt; end_lnum)                  /* do at least one line */</a>
<a name="ln4553">    lnum = end_lnum;</a>
<a name="ln4554">  line = ml_get(lnum);</a>
<a name="ln4555"> </a>
<a name="ln4556">  for (;; ) {</a>
<a name="ln4557">    if (incl_regmatch.regprog != NULL</a>
<a name="ln4558">        &amp;&amp; vim_regexec(&amp;incl_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4559">      char_u *p_fname = (curr_fname == curbuf-&gt;b_fname)</a>
<a name="ln4560">                        ? curbuf-&gt;b_ffname : curr_fname;</a>
<a name="ln4561"> </a>
<a name="ln4562">      if (inc_opt != NULL &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL)</a>
<a name="ln4563">        /* Use text from '\zs' to '\ze' (or end) of 'include'. */</a>
<a name="ln4564">        new_fname = find_file_name_in_path(incl_regmatch.startp[0],</a>
<a name="ln4565">                                           (size_t)(incl_regmatch.endp[0]</a>
<a name="ln4566">                                                    - incl_regmatch.startp[0]),</a>
<a name="ln4567">                                           FNAME_EXP|FNAME_INCL|FNAME_REL,</a>
<a name="ln4568">                                           1L, p_fname);</a>
<a name="ln4569">      else</a>
<a name="ln4570">        /* Use text after match with 'include'. */</a>
<a name="ln4571">        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,</a>
<a name="ln4572">            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);</a>
<a name="ln4573">      already_searched = FALSE;</a>
<a name="ln4574">      if (new_fname != NULL) {</a>
<a name="ln4575">        // Check whether we have already searched in this file</a>
<a name="ln4576">        for (i = 0;; i++) {</a>
<a name="ln4577">          if (i == depth + 1) {</a>
<a name="ln4578">            i = old_files;</a>
<a name="ln4579">          }</a>
<a name="ln4580">          if (i == max_path_depth) {</a>
<a name="ln4581">            break;</a>
<a name="ln4582">          }</a>
<a name="ln4583">          if (path_full_compare(new_fname, files[i].name,</a>
<a name="ln4584">                                true, true) &amp; kEqualFiles) {</a>
<a name="ln4585">            if (type != CHECK_PATH</a>
<a name="ln4586">                &amp;&amp; action == ACTION_SHOW_ALL &amp;&amp; files[i].matched) {</a>
<a name="ln4587">              msg_putchar('\n');  // cursor below last one */</a>
<a name="ln4588">              if (!got_int) {  // don't display if 'q' typed at &quot;--more--&quot;</a>
<a name="ln4589">                               // message</a>
<a name="ln4590">                msg_home_replace_hl(new_fname);</a>
<a name="ln4591">                MSG_PUTS(_(&quot; (includes previously listed match)&quot;));</a>
<a name="ln4592">                prev_fname = NULL;</a>
<a name="ln4593">              }</a>
<a name="ln4594">            }</a>
<a name="ln4595">            XFREE_CLEAR(new_fname);</a>
<a name="ln4596">            already_searched = true;</a>
<a name="ln4597">            break;</a>
<a name="ln4598">          }</a>
<a name="ln4599">        }</a>
<a name="ln4600">      }</a>
<a name="ln4601"> </a>
<a name="ln4602">      if (type == CHECK_PATH &amp;&amp; (action == ACTION_SHOW_ALL</a>
<a name="ln4603">                                 || (new_fname == NULL &amp;&amp; !already_searched))) {</a>
<a name="ln4604">        if (did_show) {</a>
<a name="ln4605">          msg_putchar('\n');  // cursor below last one</a>
<a name="ln4606">        } else {</a>
<a name="ln4607">          gotocmdline(true);  // cursor at status line</a>
<a name="ln4608">          MSG_PUTS_TITLE(_(&quot;--- Included files &quot;));</a>
<a name="ln4609">          if (action != ACTION_SHOW_ALL) {</a>
<a name="ln4610">            MSG_PUTS_TITLE(_(&quot;not found &quot;));</a>
<a name="ln4611">          }</a>
<a name="ln4612">          MSG_PUTS_TITLE(_(&quot;in path ---\n&quot;));</a>
<a name="ln4613">        }</a>
<a name="ln4614">        did_show = TRUE;</a>
<a name="ln4615">        while (depth_displayed &lt; depth &amp;&amp; !got_int) {</a>
<a name="ln4616">          ++depth_displayed;</a>
<a name="ln4617">          for (i = 0; i &lt; depth_displayed; i++)</a>
<a name="ln4618">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4619">          msg_home_replace(files[depth_displayed].name);</a>
<a name="ln4620">          MSG_PUTS(&quot; --&gt;\n&quot;);</a>
<a name="ln4621">        }</a>
<a name="ln4622">        if (!got_int) {                     /* don't display if 'q' typed</a>
<a name="ln4623">                                               for &quot;--more--&quot; message */</a>
<a name="ln4624">          for (i = 0; i &lt;= depth_displayed; i++)</a>
<a name="ln4625">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4626">          if (new_fname != NULL) {</a>
<a name="ln4627">            /* using &quot;new_fname&quot; is more reliable, e.g., when</a>
<a name="ln4628">             * 'includeexpr' is set. */</a>
<a name="ln4629">            msg_outtrans_attr(new_fname, HL_ATTR(HLF_D));</a>
<a name="ln4630">          } else {</a>
<a name="ln4631">            /*</a>
<a name="ln4632">             * Isolate the file name.</a>
<a name="ln4633">             * Include the surrounding &quot;&quot; or &lt;&gt; if present.</a>
<a name="ln4634">             */</a>
<a name="ln4635">            if (inc_opt != NULL</a>
<a name="ln4636">                &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL) {</a>
<a name="ln4637">              /* pattern contains \zs, use the match */</a>
<a name="ln4638">              p = incl_regmatch.startp[0];</a>
<a name="ln4639">              i = (int)(incl_regmatch.endp[0]</a>
<a name="ln4640">                        - incl_regmatch.startp[0]);</a>
<a name="ln4641">            } else {</a>
<a name="ln4642">              /* find the file name after the end of the match */</a>
<a name="ln4643">              for (p = incl_regmatch.endp[0];</a>
<a name="ln4644">                   *p &amp;&amp; !vim_isfilec(*p); p++)</a>
<a name="ln4645">                ;</a>
<a name="ln4646">              for (i = 0; vim_isfilec(p[i]); i++)</a>
<a name="ln4647">                ;</a>
<a name="ln4648">            }</a>
<a name="ln4649"> </a>
<a name="ln4650">            if (i == 0) {</a>
<a name="ln4651">              /* Nothing found, use the rest of the line. */</a>
<a name="ln4652">              p = incl_regmatch.endp[0];</a>
<a name="ln4653">              i = (int)STRLEN(p);</a>
<a name="ln4654">            }</a>
<a name="ln4655">            /* Avoid checking before the start of the line, can</a>
<a name="ln4656">             * happen if \zs appears in the regexp. */</a>
<a name="ln4657">            else if (p &gt; line) {</a>
<a name="ln4658">              if (p[-1] == '&quot;' || p[-1] == '&lt;') {</a>
<a name="ln4659">                --p;</a>
<a name="ln4660">                ++i;</a>
<a name="ln4661">              }</a>
<a name="ln4662">              if (p[i] == '&quot;' || p[i] == '&gt;')</a>
<a name="ln4663">                ++i;</a>
<a name="ln4664">            }</a>
<a name="ln4665">            save_char = p[i];</a>
<a name="ln4666">            p[i] = NUL;</a>
<a name="ln4667">            msg_outtrans_attr(p, HL_ATTR(HLF_D));</a>
<a name="ln4668">            p[i] = save_char;</a>
<a name="ln4669">          }</a>
<a name="ln4670"> </a>
<a name="ln4671">          if (new_fname == NULL &amp;&amp; action == ACTION_SHOW_ALL) {</a>
<a name="ln4672">            if (already_searched)</a>
<a name="ln4673">              MSG_PUTS(_(&quot;  (Already listed)&quot;));</a>
<a name="ln4674">            else</a>
<a name="ln4675">              MSG_PUTS(_(&quot;  NOT FOUND&quot;));</a>
<a name="ln4676">          }</a>
<a name="ln4677">        }</a>
<a name="ln4678">        ui_flush();                /* output each line directly */</a>
<a name="ln4679">      }</a>
<a name="ln4680"> </a>
<a name="ln4681">      if (new_fname != NULL) {</a>
<a name="ln4682">        /* Push the new file onto the file stack */</a>
<a name="ln4683">        if (depth + 1 == old_files) {</a>
<a name="ln4684">          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));</a>
<a name="ln4685">          for (i = 0; i &lt;= depth; i++)</a>
<a name="ln4686">            bigger[i] = files[i];</a>
<a name="ln4687">          for (i = depth + 1; i &lt; old_files + max_path_depth; i++) {</a>
<a name="ln4688">            bigger[i].fp = NULL;</a>
<a name="ln4689">            bigger[i].name = NULL;</a>
<a name="ln4690">            bigger[i].lnum = 0;</a>
<a name="ln4691">            bigger[i].matched = FALSE;</a>
<a name="ln4692">          }</a>
<a name="ln4693">          for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln4694">            bigger[i + max_path_depth] = files[i];</a>
<a name="ln4695">          old_files += max_path_depth;</a>
<a name="ln4696">          max_path_depth *= 2;</a>
<a name="ln4697">          xfree(files);</a>
<a name="ln4698">          files = bigger;</a>
<a name="ln4699">        }</a>
<a name="ln4700">        if ((files[depth + 1].fp = os_fopen((char *)new_fname, &quot;r&quot;)) == NULL) {</a>
<a name="ln4701">          xfree(new_fname);</a>
<a name="ln4702">        } else {</a>
<a name="ln4703">          if (++depth == old_files) {</a>
<a name="ln4704">            // Something wrong. We will forget one of our already visited files</a>
<a name="ln4705">            // now.</a>
<a name="ln4706">            xfree(files[old_files].name);</a>
<a name="ln4707">            ++old_files;</a>
<a name="ln4708">          }</a>
<a name="ln4709">          files[depth].name = curr_fname = new_fname;</a>
<a name="ln4710">          files[depth].lnum = 0;</a>
<a name="ln4711">          files[depth].matched = FALSE;</a>
<a name="ln4712">          if (action == ACTION_EXPAND) {</a>
<a name="ln4713">            msg_hist_off = true;                // reset in msg_trunc_attr()</a>
<a name="ln4714">            vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln4715">                         _(&quot;Scanning included file: %s&quot;),</a>
<a name="ln4716">                         (char *)new_fname);</a>
<a name="ln4717">            msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln4718">          } else if (p_verbose &gt;= 5) {</a>
<a name="ln4719">            verbose_enter();</a>
<a name="ln4720">            smsg(_(&quot;Searching included file %s&quot;),</a>
<a name="ln4721">                (char *)new_fname);</a>
<a name="ln4722">            verbose_leave();</a>
<a name="ln4723">          }</a>
<a name="ln4724"> </a>
<a name="ln4725">        }</a>
<a name="ln4726">      }</a>
<a name="ln4727">    } else {</a>
<a name="ln4728">      /*</a>
<a name="ln4729">       * Check if the line is a define (type == FIND_DEFINE)</a>
<a name="ln4730">       */</a>
<a name="ln4731">      p = line;</a>
<a name="ln4732">search_line:</a>
<a name="ln4733">      define_matched = FALSE;</a>
<a name="ln4734">      if (def_regmatch.regprog != NULL</a>
<a name="ln4735">          &amp;&amp; vim_regexec(&amp;def_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4736">        /*</a>
<a name="ln4737">         * Pattern must be first identifier after 'define', so skip</a>
<a name="ln4738">         * to that position before checking for match of pattern.  Also</a>
<a name="ln4739">         * don't let it match beyond the end of this identifier.</a>
<a name="ln4740">         */</a>
<a name="ln4741">        p = def_regmatch.endp[0];</a>
<a name="ln4742">        while (*p &amp;&amp; !vim_iswordc(*p))</a>
<a name="ln4743">          p++;</a>
<a name="ln4744">        define_matched = TRUE;</a>
<a name="ln4745">      }</a>
<a name="ln4746"> </a>
<a name="ln4747">      /*</a>
<a name="ln4748">       * Look for a match.  Don't do this if we are looking for a</a>
<a name="ln4749">       * define and this line didn't match define_prog above.</a>
<a name="ln4750">       */</a>
<a name="ln4751">      if (def_regmatch.regprog == NULL || define_matched) {</a>
<a name="ln4752">        if (define_matched</a>
<a name="ln4753">            || (compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4754">            ) {</a>
<a name="ln4755">          /* compare the first &quot;len&quot; chars from &quot;ptr&quot; */</a>
<a name="ln4756">          startp = skipwhite(p);</a>
<a name="ln4757">          if (p_ic) {</a>
<a name="ln4758">            matched = !mb_strnicmp(startp, ptr, len);</a>
<a name="ln4759">          }</a>
<a name="ln4760">          else</a>
<a name="ln4761">            matched = !STRNCMP(startp, ptr, len);</a>
<a name="ln4762">          if (matched &amp;&amp; define_matched &amp;&amp; whole</a>
<a name="ln4763">              &amp;&amp; vim_iswordc(startp[len]))</a>
<a name="ln4764">            matched = FALSE;</a>
<a name="ln4765">        } else if (regmatch.regprog != NULL</a>
<a name="ln4766">                   &amp;&amp; vim_regexec(&amp;regmatch, line, (colnr_T)(p - line))) {</a>
<a name="ln4767">          matched = TRUE;</a>
<a name="ln4768">          startp = regmatch.startp[0];</a>
<a name="ln4769">          // Check if the line is not a comment line (unless we are</a>
<a name="ln4770">          // looking for a define).  A line starting with &quot;# define&quot;</a>
<a name="ln4771">          // is not considered to be a comment line.</a>
<a name="ln4772">          if (skip_comments) {</a>
<a name="ln4773">            if ((*line != '#'</a>
<a name="ln4774">                 || STRNCMP(skipwhite(line + 1), &quot;define&quot;, 6) != 0)</a>
<a name="ln4775">                &amp;&amp; get_leader_len(line, NULL, false, true)) {</a>
<a name="ln4776">              matched = false;</a>
<a name="ln4777">            }</a>
<a name="ln4778"> </a>
<a name="ln4779">            /*</a>
<a name="ln4780">             * Also check for a &quot;/ *&quot; or &quot;/ /&quot; before the match.</a>
<a name="ln4781">             * Skips lines like &quot;int backwards;  / * normal index</a>
<a name="ln4782">             * * /&quot; when looking for &quot;normal&quot;.</a>
<a name="ln4783">             * Note: Doesn't skip &quot;/ *&quot; in comments.</a>
<a name="ln4784">             */</a>
<a name="ln4785">            p = skipwhite(line);</a>
<a name="ln4786">            if (matched</a>
<a name="ln4787">                || (p[0] == '/' &amp;&amp; p[1] == '*') || p[0] == '*')</a>
<a name="ln4788">              for (p = line; *p &amp;&amp; p &lt; startp; ++p) {</a>
<a name="ln4789">                if (matched</a>
<a name="ln4790">                    &amp;&amp; p[0] == '/'</a>
<a name="ln4791">                    &amp;&amp; (p[1] == '*' || p[1] == '/')) {</a>
<a name="ln4792">                  matched = FALSE;</a>
<a name="ln4793">                  /* After &quot;//&quot; all text is comment */</a>
<a name="ln4794">                  if (p[1] == '/')</a>
<a name="ln4795">                    break;</a>
<a name="ln4796">                  ++p;</a>
<a name="ln4797">                } else if (!matched &amp;&amp; p[0] == '*' &amp;&amp; p[1] == '/') {</a>
<a name="ln4798">                  /* Can find match after &quot;* /&quot;. */</a>
<a name="ln4799">                  matched = TRUE;</a>
<a name="ln4800">                  ++p;</a>
<a name="ln4801">                }</a>
<a name="ln4802">              }</a>
<a name="ln4803">          }</a>
<a name="ln4804">        }</a>
<a name="ln4805">      }</a>
<a name="ln4806">    }</a>
<a name="ln4807">    if (matched) {</a>
<a name="ln4808">      if (action == ACTION_EXPAND) {</a>
<a name="ln4809">        bool cont_s_ipos = false;</a>
<a name="ln4810">        char_u  *aux;</a>
<a name="ln4811"> </a>
<a name="ln4812">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum)</a>
<a name="ln4813">          break;</a>
<a name="ln4814">        found = TRUE;</a>
<a name="ln4815">        aux = p = startp;</a>
<a name="ln4816">        if (compl_cont_status &amp; CONT_ADDING) {</a>
<a name="ln4817">          p += compl_length;</a>
<a name="ln4818">          if (vim_iswordp(p))</a>
<a name="ln4819">            goto exit_matched;</a>
<a name="ln4820">          p = find_word_start(p);</a>
<a name="ln4821">        }</a>
<a name="ln4822">        p = find_word_end(p);</a>
<a name="ln4823">        i = (int)(p - aux);</a>
<a name="ln4824"> </a>
<a name="ln4825">        if ((compl_cont_status &amp; CONT_ADDING) &amp;&amp; i == compl_length) {</a>
<a name="ln4826">          /* IOSIZE &gt; compl_length, so the STRNCPY works */</a>
<a name="ln4827">          STRNCPY(IObuff, aux, i);</a>
<a name="ln4828"> </a>
<a name="ln4829">          /* Get the next line: when &quot;depth&quot; &lt; 0  from the current</a>
<a name="ln4830">           * buffer, otherwise from the included file.  Jump to</a>
<a name="ln4831">           * exit_matched when past the last line. */</a>
<a name="ln4832">          if (depth &lt; 0) {</a>
<a name="ln4833">            if (lnum &gt;= end_lnum)</a>
<a name="ln4834">              goto exit_matched;</a>
<a name="ln4835">            line = ml_get(++lnum);</a>
<a name="ln4836">          } else if (vim_fgets(line = file_line,</a>
<a name="ln4837">                         LSIZE, files[depth].fp))</a>
<a name="ln4838">            goto exit_matched;</a>
<a name="ln4839"> </a>
<a name="ln4840">          /* we read a line, set &quot;already&quot; to check this &quot;line&quot; later</a>
<a name="ln4841">           * if depth &gt;= 0 we'll increase files[depth].lnum far</a>
<a name="ln4842">           * bellow  -- Acevedo */</a>
<a name="ln4843">          already = aux = p = skipwhite(line);</a>
<a name="ln4844">          p = find_word_start(p);</a>
<a name="ln4845">          p = find_word_end(p);</a>
<a name="ln4846">          if (p &gt; aux) {</a>
<a name="ln4847">            if (*aux != ')' &amp;&amp; IObuff[i-1] != TAB) {</a>
<a name="ln4848">              if (IObuff[i-1] != ' ')</a>
<a name="ln4849">                IObuff[i++] = ' ';</a>
<a name="ln4850">              /* IObuf =~ &quot;\(\k\|\i\).* &quot;, thus i &gt;= 2*/</a>
<a name="ln4851">              if (p_js</a>
<a name="ln4852">                  &amp;&amp; (IObuff[i-2] == '.'</a>
<a name="ln4853">                      || IObuff[i-2] == '?'</a>
<a name="ln4854">                      || IObuff[i-2] == '!')) {</a>
<a name="ln4855">                IObuff[i++] = ' ';</a>
<a name="ln4856">              }</a>
<a name="ln4857">            }</a>
<a name="ln4858">            /* copy as much as possible of the new word */</a>
<a name="ln4859">            if (p - aux &gt;= IOSIZE - i)</a>
<a name="ln4860">              p = aux + IOSIZE - i - 1;</a>
<a name="ln4861">            STRNCPY(IObuff + i, aux, p - aux);</a>
<a name="ln4862">            i += (int)(p - aux);</a>
<a name="ln4863">            cont_s_ipos = true;</a>
<a name="ln4864">          }</a>
<a name="ln4865">          IObuff[i] = NUL;</a>
<a name="ln4866">          aux = IObuff;</a>
<a name="ln4867"> </a>
<a name="ln4868">          if (i == compl_length)</a>
<a name="ln4869">            goto exit_matched;</a>
<a name="ln4870">        }</a>
<a name="ln4871"> </a>
<a name="ln4872">        const int add_r = ins_compl_add_infercase(</a>
<a name="ln4873">            aux, i, p_ic, curr_fname == curbuf-&gt;b_fname ? NULL : curr_fname,</a>
<a name="ln4874">            dir, cont_s_ipos);</a>
<a name="ln4875">        if (add_r == OK) {</a>
<a name="ln4876">          // if dir was BACKWARD then honor it just once</a>
<a name="ln4877">          dir = FORWARD;</a>
<a name="ln4878">        } else if (add_r == FAIL) {</a>
<a name="ln4879">          break;</a>
<a name="ln4880">        }</a>
<a name="ln4881">      } else if (action == ACTION_SHOW_ALL) {</a>
<a name="ln4882">        found = TRUE;</a>
<a name="ln4883">        if (!did_show)</a>
<a name="ln4884">          gotocmdline(TRUE);                    /* cursor at status line */</a>
<a name="ln4885">        if (curr_fname != prev_fname) {</a>
<a name="ln4886">          if (did_show)</a>
<a name="ln4887">            msg_putchar('\n');                  /* cursor below last one */</a>
<a name="ln4888">          if (!got_int)                         /* don't display if 'q' typed</a>
<a name="ln4889">                                                    at &quot;--more--&quot; message */</a>
<a name="ln4890">            msg_home_replace_hl(curr_fname);</a>
<a name="ln4891">          prev_fname = curr_fname;</a>
<a name="ln4892">        }</a>
<a name="ln4893">        did_show = TRUE;</a>
<a name="ln4894">        if (!got_int)</a>
<a name="ln4895">          show_pat_in_path(line, type, TRUE, action,</a>
<a name="ln4896">              (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln4897">              (depth == -1) ? &amp;lnum : &amp;files[depth].lnum,</a>
<a name="ln4898">              match_count++);</a>
<a name="ln4899"> </a>
<a name="ln4900">        /* Set matched flag for this file and all the ones that</a>
<a name="ln4901">         * include it */</a>
<a name="ln4902">        for (i = 0; i &lt;= depth; ++i)</a>
<a name="ln4903">          files[i].matched = TRUE;</a>
<a name="ln4904">      } else if (--count &lt;= 0) {</a>
<a name="ln4905">        found = TRUE;</a>
<a name="ln4906">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln4907">            &amp;&amp; l_g_do_tagpreview == 0</a>
<a name="ln4908">            )</a>
<a name="ln4909">          EMSG(_(&quot;E387: Match is on current line&quot;));</a>
<a name="ln4910">        else if (action == ACTION_SHOW) {</a>
<a name="ln4911">          show_pat_in_path(line, type, did_show, action,</a>
<a name="ln4912">              (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln4913">              (depth == -1) ? &amp;lnum : &amp;files[depth].lnum, 1L);</a>
<a name="ln4914">          did_show = TRUE;</a>
<a name="ln4915">        } else {</a>
<a name="ln4916">          /* &quot;:psearch&quot; uses the preview window */</a>
<a name="ln4917">          if (l_g_do_tagpreview != 0) {</a>
<a name="ln4918">            curwin_save = curwin;</a>
<a name="ln4919">            prepare_tagpreview(true);</a>
<a name="ln4920">          }</a>
<a name="ln4921">          if (action == ACTION_SPLIT) {</a>
<a name="ln4922">            if (win_split(0, 0) == FAIL)</a>
<a name="ln4923">              break;</a>
<a name="ln4924">            RESET_BINDING(curwin);</a>
<a name="ln4925">          }</a>
<a name="ln4926">          if (depth == -1) {</a>
<a name="ln4927">            // match in current file</a>
<a name="ln4928">            if (l_g_do_tagpreview != 0) {</a>
<a name="ln4929">              if (!GETFILE_SUCCESS(getfile(curwin_save-&gt;w_buffer-&gt;b_fnum, NULL,</a>
<a name="ln4930">                                           NULL, true, lnum, false))) {</a>
<a name="ln4931">                break;    // failed to jump to file</a>
<a name="ln4932">              }</a>
<a name="ln4933">            } else {</a>
<a name="ln4934">              setpcmark();</a>
<a name="ln4935">            }</a>
<a name="ln4936">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4937">            check_cursor();</a>
<a name="ln4938">          } else {</a>
<a name="ln4939">            if (!GETFILE_SUCCESS(getfile(0, files[depth].name, NULL, true,</a>
<a name="ln4940">                                         files[depth].lnum, false))) {</a>
<a name="ln4941">              break;    // failed to jump to file</a>
<a name="ln4942">            }</a>
<a name="ln4943">            // autocommands may have changed the lnum, we don't</a>
<a name="ln4944">            // want that here</a>
<a name="ln4945">            curwin-&gt;w_cursor.lnum = files[depth].lnum;</a>
<a name="ln4946">          }</a>
<a name="ln4947">        }</a>
<a name="ln4948">        if (action != ACTION_SHOW) {</a>
<a name="ln4949">          curwin-&gt;w_cursor.col = (colnr_T)(startp - line);</a>
<a name="ln4950">          curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln4951">        }</a>
<a name="ln4952"> </a>
<a name="ln4953">        if (l_g_do_tagpreview != 0</a>
<a name="ln4954">            &amp;&amp; curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln4955">          /* Return cursor to where we were */</a>
<a name="ln4956">          validate_cursor();</a>
<a name="ln4957">          redraw_later(curwin, VALID);</a>
<a name="ln4958">          win_enter(curwin_save, true);</a>
<a name="ln4959">        }</a>
<a name="ln4960">        break;</a>
<a name="ln4961">      }</a>
<a name="ln4962">exit_matched:</a>
<a name="ln4963">      matched = FALSE;</a>
<a name="ln4964">      /* look for other matches in the rest of the line if we</a>
<a name="ln4965">       * are not at the end of it already */</a>
<a name="ln4966">      if (def_regmatch.regprog == NULL</a>
<a name="ln4967">          &amp;&amp; action == ACTION_EXPAND</a>
<a name="ln4968">          &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4969">          &amp;&amp; *startp != NUL</a>
<a name="ln4970">          &amp;&amp; *(p = startp + utfc_ptr2len(startp)) != NUL)</a>
<a name="ln4971">        goto search_line;</a>
<a name="ln4972">    }</a>
<a name="ln4973">    line_breakcheck();</a>
<a name="ln4974">    if (action == ACTION_EXPAND)</a>
<a name="ln4975">      ins_compl_check_keys(30, false);</a>
<a name="ln4976">    if (got_int || compl_interrupted)</a>
<a name="ln4977">      break;</a>
<a name="ln4978"> </a>
<a name="ln4979">    /*</a>
<a name="ln4980">     * Read the next line.  When reading an included file and encountering</a>
<a name="ln4981">     * end-of-file, close the file and continue in the file that included</a>
<a name="ln4982">     * it.</a>
<a name="ln4983">     */</a>
<a name="ln4984">    while (depth &gt;= 0 &amp;&amp; !already</a>
<a name="ln4985">           &amp;&amp; vim_fgets(line = file_line, LSIZE, files[depth].fp)) {</a>
<a name="ln4986">      fclose(files[depth].fp);</a>
<a name="ln4987">      --old_files;</a>
<a name="ln4988">      files[old_files].name = files[depth].name;</a>
<a name="ln4989">      files[old_files].matched = files[depth].matched;</a>
<a name="ln4990">      --depth;</a>
<a name="ln4991">      curr_fname = (depth == -1) ? curbuf-&gt;b_fname</a>
<a name="ln4992">                   : files[depth].name;</a>
<a name="ln4993">      if (depth &lt; depth_displayed)</a>
<a name="ln4994">        depth_displayed = depth;</a>
<a name="ln4995">    }</a>
<a name="ln4996">    if (depth &gt;= 0) {           /* we could read the line */</a>
<a name="ln4997">      files[depth].lnum++;</a>
<a name="ln4998">      /* Remove any CR and LF from the line. */</a>
<a name="ln4999">      i = (int)STRLEN(line);</a>
<a name="ln5000">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\n')</a>
<a name="ln5001">        line[--i] = NUL;</a>
<a name="ln5002">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\r')</a>
<a name="ln5003">        line[--i] = NUL;</a>
<a name="ln5004">    } else if (!already) {</a>
<a name="ln5005">      if (++lnum &gt; end_lnum)</a>
<a name="ln5006">        break;</a>
<a name="ln5007">      line = ml_get(lnum);</a>
<a name="ln5008">    }</a>
<a name="ln5009">    already = NULL;</a>
<a name="ln5010">  }</a>
<a name="ln5011">  /* End of big for (;;) loop. */</a>
<a name="ln5012"> </a>
<a name="ln5013">  /* Close any files that are still open. */</a>
<a name="ln5014">  for (i = 0; i &lt;= depth; i++) {</a>
<a name="ln5015">    fclose(files[i].fp);</a>
<a name="ln5016">    xfree(files[i].name);</a>
<a name="ln5017">  }</a>
<a name="ln5018">  for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln5019">    xfree(files[i].name);</a>
<a name="ln5020">  xfree(files);</a>
<a name="ln5021"> </a>
<a name="ln5022">  if (type == CHECK_PATH) {</a>
<a name="ln5023">    if (!did_show) {</a>
<a name="ln5024">      if (action != ACTION_SHOW_ALL)</a>
<a name="ln5025">        MSG(_(&quot;All included files were found&quot;));</a>
<a name="ln5026">      else</a>
<a name="ln5027">        MSG(_(&quot;No included files&quot;));</a>
<a name="ln5028">    }</a>
<a name="ln5029">  } else if (!found</a>
<a name="ln5030">             &amp;&amp; action != ACTION_EXPAND</a>
<a name="ln5031">             ) {</a>
<a name="ln5032">    if (got_int || compl_interrupted)</a>
<a name="ln5033">      EMSG(_(e_interr));</a>
<a name="ln5034">    else if (type == FIND_DEFINE)</a>
<a name="ln5035">      EMSG(_(&quot;E388: Couldn't find definition&quot;));</a>
<a name="ln5036">    else</a>
<a name="ln5037">      EMSG(_(&quot;E389: Couldn't find pattern&quot;));</a>
<a name="ln5038">  }</a>
<a name="ln5039">  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)</a>
<a name="ln5040">    msg_end();</a>
<a name="ln5041"> </a>
<a name="ln5042">fpip_end:</a>
<a name="ln5043">  xfree(file_line);</a>
<a name="ln5044">  vim_regfree(regmatch.regprog);</a>
<a name="ln5045">  vim_regfree(incl_regmatch.regprog);</a>
<a name="ln5046">  vim_regfree(def_regmatch.regprog);</a>
<a name="ln5047">}</a>
<a name="ln5048"> </a>
<a name="ln5049">static void show_pat_in_path(char_u *line, int type, int did_show, int action, FILE *fp, linenr_T *lnum, long count)</a>
<a name="ln5050">{</a>
<a name="ln5051">  char_u  *p;</a>
<a name="ln5052"> </a>
<a name="ln5053">  if (did_show)</a>
<a name="ln5054">    msg_putchar('\n');          /* cursor below last one */</a>
<a name="ln5055">  else if (!msg_silent)</a>
<a name="ln5056">    gotocmdline(TRUE);          /* cursor at status line */</a>
<a name="ln5057">  if (got_int)                  /* 'q' typed at &quot;--more--&quot; message */</a>
<a name="ln5058">    return;</a>
<a name="ln5059">  for (;; ) {</a>
<a name="ln5060">    p = line + STRLEN(line) - 1;</a>
<a name="ln5061">    if (fp != NULL) {</a>
<a name="ln5062">      /* We used fgets(), so get rid of newline at end */</a>
<a name="ln5063">      if (p &gt;= line &amp;&amp; *p == '\n')</a>
<a name="ln5064">        --p;</a>
<a name="ln5065">      if (p &gt;= line &amp;&amp; *p == '\r')</a>
<a name="ln5066">        --p;</a>
<a name="ln5067">      *(p + 1) = NUL;</a>
<a name="ln5068">    }</a>
<a name="ln5069">    if (action == ACTION_SHOW_ALL) {</a>
<a name="ln5070">      snprintf((char *)IObuff, IOSIZE, &quot;%3ld: &quot;, count);  // Show match nr.</a>
<a name="ln5071">      msg_puts((const char *)IObuff);</a>
<a name="ln5072">      snprintf((char *)IObuff, IOSIZE, &quot;%4ld&quot;, *lnum);  // Show line nr.</a>
<a name="ln5073">      // Highlight line numbers.</a>
<a name="ln5074">      msg_puts_attr((const char *)IObuff, HL_ATTR(HLF_N));</a>
<a name="ln5075">      msg_puts(&quot; &quot;);</a>
<a name="ln5076">    }</a>
<a name="ln5077">    msg_prt_line(line, FALSE);</a>
<a name="ln5078">    ui_flush();                        /* show one line at a time */</a>
<a name="ln5079"> </a>
<a name="ln5080">    /* Definition continues until line that doesn't end with '\' */</a>
<a name="ln5081">    if (got_int || type != FIND_DEFINE || p &lt; line || *p != '\\')</a>
<a name="ln5082">      break;</a>
<a name="ln5083"> </a>
<a name="ln5084">    if (fp != NULL) {</a>
<a name="ln5085">      if (vim_fgets(line, LSIZE, fp))       /* end of file */</a>
<a name="ln5086">        break;</a>
<a name="ln5087">      ++*lnum;</a>
<a name="ln5088">    } else {</a>
<a name="ln5089">      if (++*lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5090">        break;</a>
<a name="ln5091">      line = ml_get(*lnum);</a>
<a name="ln5092">    }</a>
<a name="ln5093">    msg_putchar('\n');</a>
<a name="ln5094">  }</a>
<a name="ln5095">}</a>
<a name="ln5096"> </a>
<a name="ln5097">/// Get last search pattern</a>
<a name="ln5098">void get_search_pattern(SearchPattern *const pat)</a>
<a name="ln5099">{</a>
<a name="ln5100">  memcpy(pat, &amp;(spats[0]), sizeof(spats[0]));</a>
<a name="ln5101">}</a>
<a name="ln5102"> </a>
<a name="ln5103">/// Get last substitute pattern</a>
<a name="ln5104">void get_substitute_pattern(SearchPattern *const pat)</a>
<a name="ln5105">{</a>
<a name="ln5106">  memcpy(pat, &amp;(spats[1]), sizeof(spats[1]));</a>
<a name="ln5107">  memset(&amp;(pat-&gt;off), 0, sizeof(pat-&gt;off));</a>
<a name="ln5108">}</a>
<a name="ln5109"> </a>
<a name="ln5110">/// Set last search pattern</a>
<a name="ln5111">void set_search_pattern(const SearchPattern pat)</a>
<a name="ln5112">{</a>
<a name="ln5113">  free_spat(&amp;spats[0]);</a>
<a name="ln5114">  memcpy(&amp;(spats[0]), &amp;pat, sizeof(spats[0]));</a>
<a name="ln5115">  set_vv_searchforward();</a>
<a name="ln5116">}</a>
<a name="ln5117"> </a>
<a name="ln5118">/// Set last substitute pattern</a>
<a name="ln5119">void set_substitute_pattern(const SearchPattern pat)</a>
<a name="ln5120">{</a>
<a name="ln5121">  free_spat(&amp;spats[1]);</a>
<a name="ln5122">  memcpy(&amp;(spats[1]), &amp;pat, sizeof(spats[1]));</a>
<a name="ln5123">  memset(&amp;(spats[1].off), 0, sizeof(spats[1].off));</a>
<a name="ln5124">}</a>
<a name="ln5125"> </a>
<a name="ln5126">/// Set last used search pattern</a>
<a name="ln5127">///</a>
<a name="ln5128">/// @param[in]  is_substitute_pattern  If true set substitute pattern as last</a>
<a name="ln5129">///                                    used. Otherwise sets search pattern.</a>
<a name="ln5130">void set_last_used_pattern(const bool is_substitute_pattern)</a>
<a name="ln5131">{</a>
<a name="ln5132">  last_idx = (is_substitute_pattern ? 1 : 0);</a>
<a name="ln5133">}</a>
<a name="ln5134"> </a>
<a name="ln5135">/// Returns true if search pattern was the last used one</a>
<a name="ln5136">bool search_was_last_used(void)</a>
<a name="ln5137">{</a>
<a name="ln5138">  return last_idx == 0;</a>
<a name="ln5139">}</a>

</code></pre>
<div class="balloon" rel="1528"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'dir' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

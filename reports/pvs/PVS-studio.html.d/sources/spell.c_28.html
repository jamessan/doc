
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALLWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln60">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln61">// it for every possible suggestion.</a>
<a name="ln62">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln63">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln64">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln65">#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)</a>
<a name="ln66"> </a>
<a name="ln67">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln68">// compute the maximum word score that can be used.</a>
<a name="ln69">#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;assert.h&gt;</a>
<a name="ln72">#include &lt;inttypes.h&gt;</a>
<a name="ln73">#include &lt;limits.h&gt;</a>
<a name="ln74">#include &lt;stdbool.h&gt;</a>
<a name="ln75">#include &lt;string.h&gt;</a>
<a name="ln76">#include &lt;stdlib.h&gt;</a>
<a name="ln77">#include &lt;wctype.h&gt;</a>
<a name="ln78"> </a>
<a name="ln79">/* for offsetof() */</a>
<a name="ln80">#include &lt;stddef.h&gt;</a>
<a name="ln81"> </a>
<a name="ln82">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln83">#include &quot;nvim/spell.h&quot;</a>
<a name="ln84">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln85">#include &quot;nvim/change.h&quot;</a>
<a name="ln86">#include &quot;nvim/charset.h&quot;</a>
<a name="ln87">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln88">#include &quot;nvim/edit.h&quot;</a>
<a name="ln89">#include &quot;nvim/eval.h&quot;</a>
<a name="ln90">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln91">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln92">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln93">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln94">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln95">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln96">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln97">#include &quot;nvim/mark.h&quot;</a>
<a name="ln98">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln99">#include &quot;nvim/memline.h&quot;</a>
<a name="ln100">#include &quot;nvim/memory.h&quot;</a>
<a name="ln101">#include &quot;nvim/message.h&quot;</a>
<a name="ln102">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln103">#include &quot;nvim/garray.h&quot;</a>
<a name="ln104">#include &quot;nvim/normal.h&quot;</a>
<a name="ln105">#include &quot;nvim/option.h&quot;</a>
<a name="ln106">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln107">#include &quot;nvim/path.h&quot;</a>
<a name="ln108">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln109">#include &quot;nvim/screen.h&quot;</a>
<a name="ln110">#include &quot;nvim/search.h&quot;</a>
<a name="ln111">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln112">#include &quot;nvim/strings.h&quot;</a>
<a name="ln113">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln114">#include &quot;nvim/undo.h&quot;</a>
<a name="ln115">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln116">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln117"> </a>
<a name="ln118">// only used for su_badflags</a>
<a name="ln119">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln120"> </a>
<a name="ln121">#define WF_CAPMASK (WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</a>
<a name="ln122"> </a>
<a name="ln123">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln124">#define SP_BANNED       -1</a>
<a name="ln125">#define SP_RARE         0</a>
<a name="ln126">#define SP_OK           1</a>
<a name="ln127">#define SP_LOCAL        2</a>
<a name="ln128">#define SP_BAD          3</a>
<a name="ln129"> </a>
<a name="ln130">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln131">// languages.</a>
<a name="ln132">slang_T *first_lang = NULL;</a>
<a name="ln133"> </a>
<a name="ln134">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln135">char_u *int_wordlist = NULL;</a>
<a name="ln136"> </a>
<a name="ln137">typedef struct wordcount_S {</a>
<a name="ln138">  uint16_t wc_count;                // nr of times word was seen</a>
<a name="ln139">  char_u wc_word[1];                // word, actually longer</a>
<a name="ln140">} wordcount_T;</a>
<a name="ln141"> </a>
<a name="ln142">#define WC_KEY_OFF   offsetof(wordcount_T, wc_word)</a>
<a name="ln143">#define HI2WC(hi)    ((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</a>
<a name="ln144">#define MAXWORDCOUNT 0xffff</a>
<a name="ln145"> </a>
<a name="ln146">// Information used when looking for suggestions.</a>
<a name="ln147">typedef struct suginfo_S {</a>
<a name="ln148">  garray_T su_ga;                   // suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln149">  int su_maxcount;                  // max. number of suggestions displayed</a>
<a name="ln150">  int su_maxscore;                  // maximum score for adding to su_ga</a>
<a name="ln151">  int su_sfmaxscore;                // idem, for when doing soundfold words</a>
<a name="ln152">  garray_T su_sga;                  // like su_ga, sound-folded scoring</a>
<a name="ln153">  char_u      *su_badptr;           // start of bad word in line</a>
<a name="ln154">  int su_badlen;                    // length of detected bad word in line</a>
<a name="ln155">  int su_badflags;                  // caps flags for bad word</a>
<a name="ln156">  char_u su_badword[MAXWLEN];       // bad word truncated at su_badlen</a>
<a name="ln157">  char_u su_fbadword[MAXWLEN];      // su_badword case-folded</a>
<a name="ln158">  char_u su_sal_badword[MAXWLEN];   // su_badword soundfolded</a>
<a name="ln159">  hashtab_T su_banned;              // table with banned words</a>
<a name="ln160">  slang_T     *su_sallang;          // default language for sound folding</a>
<a name="ln161">} suginfo_T;</a>
<a name="ln162"> </a>
<a name="ln163">// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln164">typedef struct {</a>
<a name="ln165">  char_u      *st_word;         // suggested word, allocated string</a>
<a name="ln166">  int st_wordlen;               // STRLEN(st_word)</a>
<a name="ln167">  int st_orglen;                // length of replaced text</a>
<a name="ln168">  int st_score;                 // lower is better</a>
<a name="ln169">  int st_altscore;              // used when st_score compares equal</a>
<a name="ln170">  bool st_salscore;             // st_score is for soundalike</a>
<a name="ln171">  bool st_had_bonus;            // bonus already included in score</a>
<a name="ln172">  slang_T     *st_slang;        // language used for sound folding</a>
<a name="ln173">} suggest_T;</a>
<a name="ln174"> </a>
<a name="ln175">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln176"> </a>
<a name="ln177">// True if a word appears in the list of banned words.</a>
<a name="ln178">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;su-&gt;su_banned, word)))</a>
<a name="ln179"> </a>
<a name="ln180">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln181">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln182">// may change and wrong suggestions may be removed later.</a>
<a name="ln183">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln184">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln185"> </a>
<a name="ln186">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln187">// of suggestions that are not going to be displayed.</a>
<a name="ln188">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln189"> </a>
<a name="ln190">// score for various changes</a>
<a name="ln191">#define SCORE_SPLIT     149     // split bad word</a>
<a name="ln192">#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS</a>
<a name="ln193">#define SCORE_ICASE     52      // slightly different case</a>
<a name="ln194">#define SCORE_REGION    200     // word is for different region</a>
<a name="ln195">#define SCORE_RARE      180     // rare word</a>
<a name="ln196">#define SCORE_SWAP      75      // swap two characters</a>
<a name="ln197">#define SCORE_SWAP3     110     // swap two characters in three</a>
<a name="ln198">#define SCORE_REP       65      // REP replacement</a>
<a name="ln199">#define SCORE_SUBST     93      // substitute a character</a>
<a name="ln200">#define SCORE_SIMILAR   33      // substitute a similar character</a>
<a name="ln201">#define SCORE_SUBCOMP   33      // substitute a composing character</a>
<a name="ln202">#define SCORE_DEL       94      // delete a character</a>
<a name="ln203">#define SCORE_DELDUP    66      // delete a duplicated character</a>
<a name="ln204">#define SCORE_DELCOMP   28      // delete a composing character</a>
<a name="ln205">#define SCORE_INS       96      // insert a character</a>
<a name="ln206">#define SCORE_INSDUP    67      // insert a duplicate character</a>
<a name="ln207">#define SCORE_INSCOMP   30      // insert a composing character</a>
<a name="ln208">#define SCORE_NONWORD   103     // change non-word to word char</a>
<a name="ln209"> </a>
<a name="ln210">#define SCORE_FILE      30      // suggestion from a file</a>
<a name="ln211">#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.</a>
<a name="ln212">                                // 350 allows for about three changes.</a>
<a name="ln213"> </a>
<a name="ln214">#define SCORE_COMMON1   30      // subtracted for words seen before</a>
<a name="ln215">#define SCORE_COMMON2   40      // subtracted for words often seen</a>
<a name="ln216">#define SCORE_COMMON3   50      // subtracted for words very often seen</a>
<a name="ln217">#define SCORE_THRES2    10      // word count threshold for COMMON2</a>
<a name="ln218">#define SCORE_THRES3    100     // word count threshold for COMMON3</a>
<a name="ln219"> </a>
<a name="ln220">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln221">// two changes.  With less then two changes it's slightly faster but we miss a</a>
<a name="ln222">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln223">#define SCORE_SFMAX1    200     // maximum score for first try</a>
<a name="ln224">#define SCORE_SFMAX2    300     // maximum score for second try</a>
<a name="ln225">#define SCORE_SFMAX3    400     // maximum score for third try</a>
<a name="ln226"> </a>
<a name="ln227">#define SCORE_BIG       SCORE_INS * 3   // big difference</a>
<a name="ln228">#define SCORE_MAXMAX    999999          // accept any score</a>
<a name="ln229">#define SCORE_LIMITMAX  350             // for spell_edit_score_limit()</a>
<a name="ln230"> </a>
<a name="ln231">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln232">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln233">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln234"> </a>
<a name="ln235">// Structure to store info for word matching.</a>
<a name="ln236">typedef struct matchinf_S {</a>
<a name="ln237">  langp_T     *mi_lp;                   // info for language and region</a>
<a name="ln238"> </a>
<a name="ln239">  // pointers to original text to be checked</a>
<a name="ln240">  char_u      *mi_word;                 // start of word being checked</a>
<a name="ln241">  char_u      *mi_end;                  // end of matching word so far</a>
<a name="ln242">  char_u      *mi_fend;                 // next char to be added to mi_fword</a>
<a name="ln243">  char_u      *mi_cend;                 // char after what was used for</a>
<a name="ln244">                                        // mi_capflags</a>
<a name="ln245"> </a>
<a name="ln246">  // case-folded text</a>
<a name="ln247">  char_u mi_fword[MAXWLEN + 1];         // mi_word case-folded</a>
<a name="ln248">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln249"> </a>
<a name="ln250">  // for when checking word after a prefix</a>
<a name="ln251">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln252">                                        // affixID/condition</a>
<a name="ln253">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln254">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln255">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln256">                                        // case</a>
<a name="ln257"> </a>
<a name="ln258">  // for when checking a compound word</a>
<a name="ln259">  int mi_compoff;                       // start of following word offset</a>
<a name="ln260">  char_u mi_compflags[MAXWLEN];         // flags for compound words used</a>
<a name="ln261">  int mi_complen;                       // nr of compound words used</a>
<a name="ln262">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln263"> </a>
<a name="ln264">  // others</a>
<a name="ln265">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln266">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln267">  win_T       *mi_win;                  // buffer being checked</a>
<a name="ln268"> </a>
<a name="ln269">  // for NOBREAK</a>
<a name="ln270">  int mi_result2;                       // &quot;mi_resul&quot; without following word</a>
<a name="ln271">  char_u      *mi_end2;                 // &quot;mi_end&quot; without following word</a>
<a name="ln272">} matchinf_T;</a>
<a name="ln273"> </a>
<a name="ln274">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln275">typedef struct spelload_S {</a>
<a name="ln276">  char_u sl_lang[MAXWLEN + 1];          // language name</a>
<a name="ln277">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln278">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln279">} spelload_T;</a>
<a name="ln280"> </a>
<a name="ln281">#define SY_MAXLEN   30</a>
<a name="ln282">typedef struct syl_item_S {</a>
<a name="ln283">  char_u sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln284">  int sy_len;</a>
<a name="ln285">} syl_item_T;</a>
<a name="ln286"> </a>
<a name="ln287">spelltab_T spelltab;</a>
<a name="ln288">int did_set_spelltab;</a>
<a name="ln289"> </a>
<a name="ln290">// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln291">// handled already.</a>
<a name="ln292">typedef struct {</a>
<a name="ln293">  short sft_score;              // lowest score used</a>
<a name="ln294">  char_u sft_word[1];           // soundfolded word, actually longer</a>
<a name="ln295">} sftword_T;</a>
<a name="ln296"> </a>
<a name="ln297">typedef struct {</a>
<a name="ln298">  int badi;</a>
<a name="ln299">  int goodi;</a>
<a name="ln300">  int score;</a>
<a name="ln301">} limitscore_T;</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln305"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln306">#endif</a>
<a name="ln307"> </a>
<a name="ln308">// values for ts_isdiff</a>
<a name="ln309">#define DIFF_NONE       0       // no different byte (yet)</a>
<a name="ln310">#define DIFF_YES        1       // different byte found</a>
<a name="ln311">#define DIFF_INSERT     2       // inserting character</a>
<a name="ln312"> </a>
<a name="ln313">// values for ts_flags</a>
<a name="ln314">#define TSF_PREFIXOK    1       // already checked that prefix is OK</a>
<a name="ln315">#define TSF_DIDSPLIT    2       // tried split at this point</a>
<a name="ln316">#define TSF_DIDDEL      4       // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln317"> </a>
<a name="ln318">// special values ts_prefixdepth</a>
<a name="ln319">#define PFD_NOPREFIX    0xff    // not using prefixes</a>
<a name="ln320">#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree</a>
<a name="ln321">#define PFD_NOTSPECIAL  0xfd    // highest value that's not special</a>
<a name="ln322"> </a>
<a name="ln323">// mode values for find_word</a>
<a name="ln324">#define FIND_FOLDWORD       0   // find word case-folded</a>
<a name="ln325">#define FIND_KEEPWORD       1   // find keep-case word</a>
<a name="ln326">#define FIND_PREFIX         2   // find word after prefix</a>
<a name="ln327">#define FIND_COMPOUND       3   // find case-folded compound word</a>
<a name="ln328">#define FIND_KEEPCOMPOUND   4   // find keep-case compound word</a>
<a name="ln329"> </a>
<a name="ln330">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln331"> </a>
<a name="ln332">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln333">static char_u *repl_from = NULL;</a>
<a name="ln334">static char_u *repl_to = NULL;</a>
<a name="ln335"> </a>
<a name="ln336">// Main spell-checking function.</a>
<a name="ln337">// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln338">// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln339">// non-word or when it's OK it remains unchanged.</a>
<a name="ln340">// This must only be called when 'spelllang' is not empty.</a>
<a name="ln341">//</a>
<a name="ln342">// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln343">// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln344">// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln345">// worry.</a>
<a name="ln346">//</a>
<a name="ln347">// Returns the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln348">// caller can skip over the word.</a>
<a name="ln349">size_t spell_check(</a>
<a name="ln350">    win_T *wp,                // current window</a>
<a name="ln351">    char_u *ptr,</a>
<a name="ln352">    hlf_T *attrp,</a>
<a name="ln353">    int *capcol,              // column to check for Capital</a>
<a name="ln354">    bool docount              // count good words</a>
<a name="ln355">)</a>
<a name="ln356">{</a>
<a name="ln357">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln358">                              // be passed to functions quickly.</a>
<a name="ln359">  size_t nrlen = 0;              // found a number first</a>
<a name="ln360">  int c;</a>
<a name="ln361">  size_t wrongcaplen = 0;</a>
<a name="ln362">  int lpi;</a>
<a name="ln363">  bool count_word = docount;</a>
<a name="ln364">  bool use_camel_case = *wp-&gt;w_s-&gt;b_p_spo != NUL;</a>
<a name="ln365">  bool camel_case = false;</a>
<a name="ln366"> </a>
<a name="ln367">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln368">  // then, skipping over the character.</a>
<a name="ln369">  if (*ptr &lt;= ' ') {</a>
<a name="ln370">    return 1;</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">  // Return here when loading language files failed.</a>
<a name="ln374">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln375">    return 1;</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378">  memset(&amp;mi, 0, sizeof(matchinf_T));</a>
<a name="ln379"> </a>
<a name="ln380">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln381">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln382">  // julifeest&quot;.</a>
<a name="ln383">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln384">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln385">      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);</a>
<a name="ln386">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln387">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln388">    } else {</a>
<a name="ln389">      mi.mi_end = skipdigits(ptr);</a>
<a name="ln390">    }</a>
<a name="ln391">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln392">  }</a>
<a name="ln393"> </a>
<a name="ln394">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln395">  mi.mi_word = ptr;</a>
<a name="ln396">  mi.mi_fend = ptr;</a>
<a name="ln397">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln398">    bool this_upper = false;  // init for gcc</a>
<a name="ln399"> </a>
<a name="ln400">    if (use_camel_case) {</a>
<a name="ln401">      c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln402">      this_upper = SPELL_ISUPPER(c);</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">    do {</a>
<a name="ln406">      MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln407">      if (use_camel_case) {</a>
<a name="ln408">        const bool prev_upper = this_upper;</a>
<a name="ln409">        c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln410">        this_upper = SPELL_ISUPPER(c);</a>
<a name="ln411">        camel_case = !prev_upper &amp;&amp; this_upper;</a>
<a name="ln412">      }</a>
<a name="ln413">    } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp)</a>
<a name="ln414">             &amp;&amp; !camel_case);</a>
<a name="ln415"> </a>
<a name="ln416">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln417">      // Check word starting with capital letter.</a>
<a name="ln418">      c = PTR2CHAR(ptr);</a>
<a name="ln419">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln420">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln421">      }</a>
<a name="ln422">    }</a>
<a name="ln423">  }</a>
<a name="ln424">  if (capcol != NULL) {</a>
<a name="ln425">    *capcol = -1;</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  // We always use the characters up to the next non-word character,</a>
<a name="ln429">  // also for bad words.</a>
<a name="ln430">  mi.mi_end = mi.mi_fend;</a>
<a name="ln431"> </a>
<a name="ln432">  // Check caps type later.</a>
<a name="ln433">  mi.mi_capflags = 0;</a>
<a name="ln434">  mi.mi_cend = NULL;</a>
<a name="ln435">  mi.mi_win = wp;</a>
<a name="ln436"> </a>
<a name="ln437">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln438">  // for the word end.</a>
<a name="ln439">  if (*mi.mi_fend != NUL) {</a>
<a name="ln440">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  (void)spell_casefold(ptr, (int)(mi.mi_fend - ptr), mi.mi_fword, MAXWLEN + 1);</a>
<a name="ln444">  mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);</a>
<a name="ln445"> </a>
<a name="ln446">  if (camel_case) {</a>
<a name="ln447">    // introduce a fake word end space into the folded word.</a>
<a name="ln448">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451">  // The word is bad unless we recognize it.</a>
<a name="ln452">  mi.mi_result = SP_BAD;</a>
<a name="ln453">  mi.mi_result2 = SP_BAD;</a>
<a name="ln454"> </a>
<a name="ln455">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln456">  // We check them all, because a word may be matched longer in another</a>
<a name="ln457">  // language.</a>
<a name="ln458">  for (lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln459">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln460"> </a>
<a name="ln461">    // If reloading fails the language is still in the list but everything</a>
<a name="ln462">    // has been cleared.</a>
<a name="ln463">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln464">      continue;</a>
<a name="ln465">    }</a>
<a name="ln466"> </a>
<a name="ln467">    // Check for a matching word in case-folded words.</a>
<a name="ln468">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln469"> </a>
<a name="ln470">    // Check for a matching word in keep-case words.</a>
<a name="ln471">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln472"> </a>
<a name="ln473">    // Check for matching prefixes.</a>
<a name="ln474">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln475"> </a>
<a name="ln476">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln477">    // word as a backup.</a>
<a name="ln478">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln479">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln480">      mi.mi_result = mi.mi_result2;</a>
<a name="ln481">      mi.mi_end = mi.mi_end2;</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln485">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln486">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln487">          (int)(mi.mi_end - ptr), 1);</a>
<a name="ln488">      count_word = false;</a>
<a name="ln489">    }</a>
<a name="ln490">  }</a>
<a name="ln491"> </a>
<a name="ln492">  if (mi.mi_result != SP_OK) {</a>
<a name="ln493">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln494">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln495">    if (nrlen &gt; 0) {</a>
<a name="ln496">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln497">        return nrlen;</a>
<a name="ln498">      }</a>
<a name="ln499">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln500">    // When we are at a non-word character there is no error, just</a>
<a name="ln501">    // skip over the character (try looking for a word after it).</a>
<a name="ln502">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln503">        regmatch_T regmatch;</a>
<a name="ln504"> </a>
<a name="ln505">        // Check for end of sentence.</a>
<a name="ln506">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln507">        regmatch.rm_ic = false;</a>
<a name="ln508">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln509">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln510">        if (r) {</a>
<a name="ln511">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln512">        }</a>
<a name="ln513">      }</a>
<a name="ln514"> </a>
<a name="ln515">      return (size_t)(utfc_ptr2len(ptr));</a>
<a name="ln516">    } else if (mi.mi_end == ptr) {</a>
<a name="ln517">      // Always include at least one character.  Required for when there</a>
<a name="ln518">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln519">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln520">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln521">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln522">      char_u      *p, *fp;</a>
<a name="ln523">      int save_result = mi.mi_result;</a>
<a name="ln524"> </a>
<a name="ln525">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln526">      // at which any word would be valid.</a>
<a name="ln527">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln528">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln529">        p = mi.mi_word;</a>
<a name="ln530">        fp = mi.mi_fword;</a>
<a name="ln531">        for (;;) {</a>
<a name="ln532">          MB_PTR_ADV(p);</a>
<a name="ln533">          MB_PTR_ADV(fp);</a>
<a name="ln534">          if (p &gt;= mi.mi_end) {</a>
<a name="ln535">            break;</a>
<a name="ln536">          }</a>
<a name="ln537">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln538">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln539">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln540">            mi.mi_end = p;</a>
<a name="ln541">            break;</a>
<a name="ln542">          }</a>
<a name="ln543">        }</a>
<a name="ln544">        mi.mi_result = save_result;</a>
<a name="ln545">      }</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln549">      *attrp = HLF_SPB;</a>
<a name="ln550">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln551">      *attrp = HLF_SPR;</a>
<a name="ln552">    } else {</a>
<a name="ln553">      *attrp = HLF_SPL;</a>
<a name="ln554">    }</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln558">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln559">    *attrp = HLF_SPC;</a>
<a name="ln560">    return wrongcaplen;</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln567">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln568">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln569">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln570">// tree.</a>
<a name="ln571">//</a>
<a name="ln572">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln573">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln574">{</a>
<a name="ln575">  int wlen = 0;</a>
<a name="ln576">  int flen;</a>
<a name="ln577">  char_u      *ptr;</a>
<a name="ln578">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln579">  char_u      *byts;</a>
<a name="ln580">  idx_T       *idxs;</a>
<a name="ln581"> </a>
<a name="ln582">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln583">    // Check for word with matching case in keep-case tree.</a>
<a name="ln584">    ptr = mip-&gt;mi_word;</a>
<a name="ln585">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln586">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln587">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln588"> </a>
<a name="ln589">    if (mode == FIND_KEEPCOMPOUND)</a>
<a name="ln590">      // Skip over the previously found word(s).</a>
<a name="ln591">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln592">  } else {</a>
<a name="ln593">    // Check for case-folded in case-folded tree.</a>
<a name="ln594">    ptr = mip-&gt;mi_fword;</a>
<a name="ln595">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln596">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln597">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln598"> </a>
<a name="ln599">    if (mode == FIND_PREFIX) {</a>
<a name="ln600">      // Skip over the prefix.</a>
<a name="ln601">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln602">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln603">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln604">      // Skip over the previously found word(s).</a>
<a name="ln605">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln606">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln607">    }</a>
<a name="ln608"> </a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  if (byts == NULL)</a>
<a name="ln612">    return;                     // array is empty</a>
<a name="ln613"> </a>
<a name="ln614">  idx_T arridx = 0;</a>
<a name="ln615">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln616">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln617">  int endidxcnt = 0;</a>
<a name="ln618">  int len;</a>
<a name="ln619">  int c;</a>
<a name="ln620"> </a>
<a name="ln621">  // Repeat advancing in the tree until:</a>
<a name="ln622">  // - there is a byte that doesn't match,</a>
<a name="ln623">  // - we reach the end of the tree,</a>
<a name="ln624">  // - or we reach the end of the line.</a>
<a name="ln625">  for (;; ) {</a>
<a name="ln626">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln627">      flen = fold_more(mip);</a>
<a name="ln628"> </a>
<a name="ln629">    len = byts[arridx++];</a>
<a name="ln630"> </a>
<a name="ln631">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln632">    // Remember this index, we first check for the longest word.</a>
<a name="ln633">    if (byts[arridx] == 0) {</a>
<a name="ln634">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln635">        // Must be a corrupted spell file.</a>
<a name="ln636">        EMSG(_(e_format));</a>
<a name="ln637">        return;</a>
<a name="ln638">      }</a>
<a name="ln639">      endlen[endidxcnt] = wlen;</a>
<a name="ln640">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln641">      --len;</a>
<a name="ln642"> </a>
<a name="ln643">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln644">      // combinations.</a>
<a name="ln645">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln646">        ++arridx;</a>
<a name="ln647">        --len;</a>
<a name="ln648">      }</a>
<a name="ln649">      if (len == 0)</a>
<a name="ln650">        break;              // no children, word must end here</a>
<a name="ln651">    }</a>
<a name="ln652"> </a>
<a name="ln653">    // Stop looking at end of the line.</a>
<a name="ln654">    if (ptr[wlen] == NUL)</a>
<a name="ln655">      break;</a>
<a name="ln656"> </a>
<a name="ln657">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln658">    c = ptr[wlen];</a>
<a name="ln659">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln660">      c = ' ';</a>
<a name="ln661">    idx_T lo = arridx;</a>
<a name="ln662">    idx_T hi = arridx + len - 1;</a>
<a name="ln663">    while (lo &lt; hi) {</a>
<a name="ln664">      idx_T m = (lo + hi) / 2;</a>
<a name="ln665">      if (byts[m] &gt; c)</a>
<a name="ln666">        hi = m - 1;</a>
<a name="ln667">      else if (byts[m] &lt; c)</a>
<a name="ln668">        lo = m + 1;</a>
<a name="ln669">      else {</a>
<a name="ln670">        lo = hi = m;</a>
<a name="ln671">        break;</a>
<a name="ln672">      }</a>
<a name="ln673">    }</a>
<a name="ln674"> </a>
<a name="ln675">    // Stop if there is no matching byte.</a>
<a name="ln676">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln677">      break;</a>
<a name="ln678"> </a>
<a name="ln679">    // Continue at the child (if there is one).</a>
<a name="ln680">    arridx = idxs[lo];</a>
<a name="ln681">    ++wlen;</a>
<a name="ln682">    --flen;</a>
<a name="ln683"> </a>
<a name="ln684">    // One space in the good word may stand for several spaces in the</a>
<a name="ln685">    // checked word.</a>
<a name="ln686">    if (c == ' ') {</a>
<a name="ln687">      for (;; ) {</a>
<a name="ln688">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln689">          flen = fold_more(mip);</a>
<a name="ln690">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB)</a>
<a name="ln691">          break;</a>
<a name="ln692">        ++wlen;</a>
<a name="ln693">        --flen;</a>
<a name="ln694">      }</a>
<a name="ln695">    }</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  char_u *p;</a>
<a name="ln699">  bool word_ends;</a>
<a name="ln700"> </a>
<a name="ln701">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln702">  // first.</a>
<a name="ln703">  while (endidxcnt &gt; 0) {</a>
<a name="ln704">    --endidxcnt;</a>
<a name="ln705">    arridx = endidx[endidxcnt];</a>
<a name="ln706">    wlen = endlen[endidxcnt];</a>
<a name="ln707"> </a>
<a name="ln708">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln709">      continue;             // not at first byte of character</a>
<a name="ln710">    }</a>
<a name="ln711">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln712">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak)</a>
<a name="ln713">        continue;                   // next char is a word character</a>
<a name="ln714">      word_ends = false;</a>
<a name="ln715">    } else</a>
<a name="ln716">      word_ends = true;</a>
<a name="ln717">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln718">    // has been found we try compound flags.</a>
<a name="ln719">    bool prefix_found = false;</a>
<a name="ln720"> </a>
<a name="ln721">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln722">      // Compute byte length in original word, length may change</a>
<a name="ln723">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln724">      // case-folded word is equal to the keep-case word.</a>
<a name="ln725">      p = mip-&gt;mi_word;</a>
<a name="ln726">      if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln727">        for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln728">          MB_PTR_ADV(p);</a>
<a name="ln729">        }</a>
<a name="ln730">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln731">      }</a>
<a name="ln732">    }</a>
<a name="ln733"> </a>
<a name="ln734">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln735">    // prefix ID.</a>
<a name="ln736">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln737">    // is a match.</a>
<a name="ln738">    for (len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0;</a>
<a name="ln739">         --len, ++arridx) {</a>
<a name="ln740">      uint32_t flags = idxs[arridx];</a>
<a name="ln741"> </a>
<a name="ln742">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln743">      // matches with what the word in the tree requires.</a>
<a name="ln744">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln745">      // don't bother to check.</a>
<a name="ln746">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln747">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln748">          // mi_capflags was set for a different word length, need</a>
<a name="ln749">          // to do it again.</a>
<a name="ln750">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln751">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln752">        }</a>
<a name="ln753"> </a>
<a name="ln754">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln755">            || !spell_valid_case(mip-&gt;mi_capflags, flags))</a>
<a name="ln756">          continue;</a>
<a name="ln757">      }</a>
<a name="ln758">      // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln759">      // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln760">      // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln761">      else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln762">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln763">            flags,</a>
<a name="ln764">            mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln765">            false);</a>
<a name="ln766">        if (c == 0)</a>
<a name="ln767">          continue;</a>
<a name="ln768"> </a>
<a name="ln769">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln770">        if (c &amp; WF_RAREPFX)</a>
<a name="ln771">          flags |= WF_RARE;</a>
<a name="ln772">        prefix_found = true;</a>
<a name="ln773">      }</a>
<a name="ln774"> </a>
<a name="ln775">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln776">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln777">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln778">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln779">          // need to know, so return.</a>
<a name="ln780">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln781">          break;</a>
<a name="ln782">        }</a>
<a name="ln783">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln784">                  || !word_ends)) {</a>
<a name="ln785">        // If there is no compound flag or the word is shorter than</a>
<a name="ln786">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln787">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln788">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln789">        // anyway.</a>
<a name="ln790">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln791">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen)</a>
<a name="ln792">          continue;</a>
<a name="ln793">        // For multi-byte chars check character length against</a>
<a name="ln794">        // COMPOUNDMIN.</a>
<a name="ln795">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln796">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln797">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln798">          continue;</a>
<a name="ln799">        }</a>
<a name="ln800"> </a>
<a name="ln801">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln802">        // maximum for syllables is specified.</a>
<a name="ln803">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln804">            &gt; slang-&gt;sl_compmax</a>
<a name="ln805">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN)</a>
<a name="ln806">          continue;</a>
<a name="ln807"> </a>
<a name="ln808">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln809">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln810">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF))</a>
<a name="ln811">          continue;</a>
<a name="ln812">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT))</a>
<a name="ln813">          continue;</a>
<a name="ln814"> </a>
<a name="ln815">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln816">        if (!byte_in_str(mip-&gt;mi_complen == 0</a>
<a name="ln817">                ? slang-&gt;sl_compstartflags</a>
<a name="ln818">                : slang-&gt;sl_compallflags,</a>
<a name="ln819">                ((unsigned)flags &gt;&gt; 24)))</a>
<a name="ln820">          continue;</a>
<a name="ln821"> </a>
<a name="ln822">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln823">        // discard the compound word.</a>
<a name="ln824">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat))</a>
<a name="ln825">          continue;</a>
<a name="ln826"> </a>
<a name="ln827">        if (mode == FIND_COMPOUND) {</a>
<a name="ln828">          int capflags;</a>
<a name="ln829"> </a>
<a name="ln830">          // Need to check the caps type of the appended compound</a>
<a name="ln831">          // word.</a>
<a name="ln832">          if (STRNCMP(ptr, mip-&gt;mi_word, mip-&gt;mi_compoff) != 0) {</a>
<a name="ln833">            // case folding may have changed the length</a>
<a name="ln834">            p = mip-&gt;mi_word;</a>
<a name="ln835">            for (char_u *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln836">              MB_PTR_ADV(p);</a>
<a name="ln837">            }</a>
<a name="ln838">          } else {</a>
<a name="ln839">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln840">          }</a>
<a name="ln841">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln842">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln843">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln844">            continue;</a>
<a name="ln845"> </a>
<a name="ln846">          if (capflags != WF_ALLCAP) {</a>
<a name="ln847">            // When the character before the word is a word</a>
<a name="ln848">            // character we do not accept a Onecap word.  We do</a>
<a name="ln849">            // accept a no-caps word, even when the dictionary</a>
<a name="ln850">            // word specifies ONECAP.</a>
<a name="ln851">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln852">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln853">                ? capflags == WF_ONECAP</a>
<a name="ln854">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln855">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln856">              continue;</a>
<a name="ln857">            }</a>
<a name="ln858">          }</a>
<a name="ln859">        }</a>
<a name="ln860"> </a>
<a name="ln861">        // If the word ends the sequence of compound flags of the</a>
<a name="ln862">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln863">        // the number of syllables must not be too large.</a>
<a name="ln864">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln865">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln866">        if (word_ends) {</a>
<a name="ln867">          char_u fword[MAXWLEN] = { 0 };</a>
<a name="ln868"> </a>
<a name="ln869">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln870">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln871">            if (ptr == mip-&gt;mi_word)</a>
<a name="ln872">              (void)spell_casefold(ptr, wlen, fword, MAXWLEN);</a>
<a name="ln873">            else</a>
<a name="ln874">              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);</a>
<a name="ln875">          }</a>
<a name="ln876">          if (!can_compound(slang, fword, mip-&gt;mi_compflags))</a>
<a name="ln877">            continue;</a>
<a name="ln878">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln879">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags))</a>
<a name="ln880">          // The compound flags collected so far do not match any</a>
<a name="ln881">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln882">          continue;</a>
<a name="ln883">      }</a>
<a name="ln884">      // Check NEEDCOMPOUND: can't use word without compounding.</a>
<a name="ln885">      else if (flags &amp; WF_NEEDCOMP)</a>
<a name="ln886">        continue;</a>
<a name="ln887"> </a>
<a name="ln888">      int nobreak_result = SP_OK;</a>
<a name="ln889"> </a>
<a name="ln890">      if (!word_ends) {</a>
<a name="ln891">        int save_result = mip-&gt;mi_result;</a>
<a name="ln892">        char_u  *save_end = mip-&gt;mi_end;</a>
<a name="ln893">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln894"> </a>
<a name="ln895">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln896">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln897">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln898">        // valid word follows.</a>
<a name="ln899">        // Recursive!</a>
<a name="ln900">        if (slang-&gt;sl_nobreak)</a>
<a name="ln901">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln902"> </a>
<a name="ln903">        // Find following word in case-folded tree.</a>
<a name="ln904">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln905">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln906">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln907">          // byte length in keep-case word.  Length may change when</a>
<a name="ln908">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln909">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln910">          p = mip-&gt;mi_fword;</a>
<a name="ln911">          if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln912">            for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln913">              MB_PTR_ADV(p);</a>
<a name="ln914">            }</a>
<a name="ln915">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln916">          }</a>
<a name="ln917">        }</a>
<a name="ln918">#if 0</a>
<a name="ln919">        c = mip-&gt;mi_compoff;</a>
<a name="ln920">#endif</a>
<a name="ln921">        ++mip-&gt;mi_complen;</a>
<a name="ln922">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln923">          ++mip-&gt;mi_compextra;</a>
<a name="ln924"> </a>
<a name="ln925">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln926">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln927">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln928">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln929">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln930">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln931">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak)</a>
<a name="ln932">              continue;</a>
<a name="ln933">          }</a>
<a name="ln934"> </a>
<a name="ln935">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln936"> </a>
<a name="ln937">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln938">          // need to find the longest match, thus try with keep-case</a>
<a name="ln939">          // and prefix too.</a>
<a name="ln940">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln941">            // Find following word in keep-case tree.</a>
<a name="ln942">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln943">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln944"> </a>
<a name="ln945">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln946">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln947">            // can't be a postponed prefix.</a>
<a name="ln948">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln949">              // Check for following word with prefix.</a>
<a name="ln950">              mip-&gt;mi_compoff = c;</a>
<a name="ln951">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln952">            }</a>
<a name="ln953">#endif</a>
<a name="ln954">          }</a>
<a name="ln955"> </a>
<a name="ln956">          if (!slang-&gt;sl_nobreak)</a>
<a name="ln957">            break;</a>
<a name="ln958">        }</a>
<a name="ln959">        --mip-&gt;mi_complen;</a>
<a name="ln960">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln961">          --mip-&gt;mi_compextra;</a>
<a name="ln962">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln963"> </a>
<a name="ln964">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln965">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln966">          mip-&gt;mi_result = save_result;</a>
<a name="ln967">          mip-&gt;mi_end = save_end;</a>
<a name="ln968">        } else {</a>
<a name="ln969">          if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln970">            break;</a>
<a name="ln971">          continue;</a>
<a name="ln972">        }</a>
<a name="ln973">      }</a>
<a name="ln974"> </a>
<a name="ln975">      int res = SP_BAD;</a>
<a name="ln976">      if (flags &amp; WF_BANNED)</a>
<a name="ln977">        res = SP_BANNED;</a>
<a name="ln978">      else if (flags &amp; WF_REGION) {</a>
<a name="ln979">        // Check region.</a>
<a name="ln980">        if ((mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0)</a>
<a name="ln981">          res = SP_OK;</a>
<a name="ln982">        else</a>
<a name="ln983">          res = SP_LOCAL;</a>
<a name="ln984">      } else if (flags &amp; WF_RARE)</a>
<a name="ln985">        res = SP_RARE;</a>
<a name="ln986">      else</a>
<a name="ln987">        res = SP_OK;</a>
<a name="ln988"> </a>
<a name="ln989">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln990">      // we separately keep the longest match without a following good</a>
<a name="ln991">      // word as a fall-back.</a>
<a name="ln992">      if (nobreak_result == SP_BAD) {</a>
<a name="ln993">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln994">          mip-&gt;mi_result2 = res;</a>
<a name="ln995">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln996">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln997">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln998">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln999">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln1000">        mip-&gt;mi_result = res;</a>
<a name="ln1001">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1002">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln1003">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1004"> </a>
<a name="ln1005">      if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1006">        break;</a>
<a name="ln1007">    }</a>
<a name="ln1008"> </a>
<a name="ln1009">    if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1010">      break;</a>
<a name="ln1011">  }</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln1015">// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln1016">// word.</a>
<a name="ln1017">// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln1018">// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln1019">static bool</a>
<a name="ln1020">match_checkcompoundpattern (</a>
<a name="ln1021">    char_u *ptr,</a>
<a name="ln1022">    int wlen,</a>
<a name="ln1023">    garray_T *gap      // &amp;sl_comppat</a>
<a name="ln1024">)</a>
<a name="ln1025">{</a>
<a name="ln1026">  char_u      *p;</a>
<a name="ln1027">  int len;</a>
<a name="ln1028"> </a>
<a name="ln1029">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln1030">    p = ((char_u **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln1031">    if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0) {</a>
<a name="ln1032">      // Second part matches at start of following compound word, now</a>
<a name="ln1033">      // check if first part matches at end of previous word.</a>
<a name="ln1034">      p = ((char_u **)gap-&gt;ga_data)[i];</a>
<a name="ln1035">      len = (int)STRLEN(p);</a>
<a name="ln1036">      if (len &lt;= wlen &amp;&amp; STRNCMP(ptr + wlen - len, p, len) == 0)</a>
<a name="ln1037">        return true;</a>
<a name="ln1038">    }</a>
<a name="ln1039">  }</a>
<a name="ln1040">  return false;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">// Returns true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln1044">// does not have too many syllables.</a>
<a name="ln1045">static bool can_compound(slang_T *slang, const char_u *word,</a>
<a name="ln1046">                         const char_u *flags)</a>
<a name="ln1047">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1048">{</a>
<a name="ln1049">  char_u uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln1050"> </a>
<a name="ln1051">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1052">    return false;</a>
<a name="ln1053">  }</a>
<a name="ln1054">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln1055">  char_u *p = uflags;</a>
<a name="ln1056">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1057">    p += utf_char2bytes(flags[i], p);</a>
<a name="ln1058">  }</a>
<a name="ln1059">  *p = NUL;</a>
<a name="ln1060">  p = uflags;</a>
<a name="ln1061">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1062">    return false;</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1066">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1067">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1068">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1069">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax)</a>
<a name="ln1070">    return (int)STRLEN(flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1071">  return true;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln1075">// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln1076">// lines if they don't contain wildcards.</a>
<a name="ln1077">static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)</a>
<a name="ln1078">{</a>
<a name="ln1079">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln1080">  // then it can't possibly compound.</a>
<a name="ln1081">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1082">          ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag))</a>
<a name="ln1083">    return false;</a>
<a name="ln1084"> </a>
<a name="ln1085">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln1086">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln1087">  // makes sense when we have two or more words.</a>
<a name="ln1088">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1089">    compflags[sp-&gt;ts_complen] = flag;</a>
<a name="ln1090">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1091">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln1092">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1093">    return v;</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  return true;</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1100">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1101">// collected so far can't possibly match any compound rule.</a>
<a name="ln1102">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1103">static bool match_compoundrule(slang_T *slang, char_u *compflags)</a>
<a name="ln1104">{</a>
<a name="ln1105">  char_u      *p;</a>
<a name="ln1106">  int i;</a>
<a name="ln1107">  int c;</a>
<a name="ln1108"> </a>
<a name="ln1109">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1110">  for (p = slang-&gt;sl_comprules; *p != NUL; ++p) {</a>
<a name="ln1111">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1112">    // them against the current rule entry</a>
<a name="ln1113">    for (i = 0;; ++i) {</a>
<a name="ln1114">      c = compflags[i];</a>
<a name="ln1115">      if (c == NUL)</a>
<a name="ln1116">        // found a rule that matches for the flags we have so far</a>
<a name="ln1117">        return true;</a>
<a name="ln1118">      if (*p == '/' || *p == NUL)</a>
<a name="ln1119">        break;          // end of rule, it's too short</a>
<a name="ln1120">      if (*p == '[') {</a>
<a name="ln1121">        bool match = false;</a>
<a name="ln1122"> </a>
<a name="ln1123">        // compare against all the flags in []</a>
<a name="ln1124">        ++p;</a>
<a name="ln1125">        while (*p != ']' &amp;&amp; *p != NUL)</a>
<a name="ln1126">          if (*p++ == c)</a>
<a name="ln1127">            match = true;</a>
<a name="ln1128">        if (!match)</a>
<a name="ln1129">          break;            // none matches</a>
<a name="ln1130">      } else if (*p != c)</a>
<a name="ln1131">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1132">      ++p;</a>
<a name="ln1133">    }</a>
<a name="ln1134"> </a>
<a name="ln1135">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1136">    p = vim_strchr(p, '/');</a>
<a name="ln1137">    if (p == NULL)</a>
<a name="ln1138">      break;</a>
<a name="ln1139">  }</a>
<a name="ln1140"> </a>
<a name="ln1141">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1142">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1143">  return false;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1147">// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1148">// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1149">static int</a>
<a name="ln1150">valid_word_prefix (</a>
<a name="ln1151">    int totprefcnt,                 // nr of prefix IDs</a>
<a name="ln1152">    int arridx,                     // idx in sl_pidxs[]</a>
<a name="ln1153">    int flags,</a>
<a name="ln1154">    char_u *word,</a>
<a name="ln1155">    slang_T *slang,</a>
<a name="ln1156">    bool cond_req                   // only use prefixes with a condition</a>
<a name="ln1157">)</a>
<a name="ln1158">{</a>
<a name="ln1159">  int prefcnt;</a>
<a name="ln1160">  int pidx;</a>
<a name="ln1161">  int prefid;</a>
<a name="ln1162"> </a>
<a name="ln1163">  prefid = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln1164">  for (prefcnt = totprefcnt - 1; prefcnt &gt;= 0; --prefcnt) {</a>
<a name="ln1165">    pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1166"> </a>
<a name="ln1167">    // Check the prefix ID.</a>
<a name="ln1168">    if (prefid != (pidx &amp; 0xff))</a>
<a name="ln1169">      continue;</a>
<a name="ln1170"> </a>
<a name="ln1171">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1172">    // suffix.</a>
<a name="ln1173">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC))</a>
<a name="ln1174">      continue;</a>
<a name="ln1175"> </a>
<a name="ln1176">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1177">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1178">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1179">    if (*rp != NULL) {</a>
<a name="ln1180">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1181">        continue;</a>
<a name="ln1182">      }</a>
<a name="ln1183">    } else if (cond_req)</a>
<a name="ln1184">      continue;</a>
<a name="ln1185"> </a>
<a name="ln1186">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1187">    return pidx;</a>
<a name="ln1188">  }</a>
<a name="ln1189">  return 0;</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1193">// If it does, then check the following word.</a>
<a name="ln1194">//</a>
<a name="ln1195">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1196">// prefix in a compound word.</a>
<a name="ln1197">//</a>
<a name="ln1198">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1199">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1200">{</a>
<a name="ln1201">  idx_T arridx = 0;</a>
<a name="ln1202">  int len;</a>
<a name="ln1203">  int wlen = 0;</a>
<a name="ln1204">  int flen;</a>
<a name="ln1205">  int c;</a>
<a name="ln1206">  char_u      *ptr;</a>
<a name="ln1207">  idx_T lo, hi, m;</a>
<a name="ln1208">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1209">  char_u      *byts;</a>
<a name="ln1210">  idx_T       *idxs;</a>
<a name="ln1211"> </a>
<a name="ln1212">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln1213">  if (byts == NULL)</a>
<a name="ln1214">    return;                     // array is empty</a>
<a name="ln1215"> </a>
<a name="ln1216">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1217">  // case-folded.</a>
<a name="ln1218">  ptr = mip-&gt;mi_fword;</a>
<a name="ln1219">  flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1220">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1221">    // Skip over the previously found word(s).</a>
<a name="ln1222">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1223">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1224">  }</a>
<a name="ln1225">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1226"> </a>
<a name="ln1227">  // Repeat advancing in the tree until:</a>
<a name="ln1228">  // - there is a byte that doesn't match,</a>
<a name="ln1229">  // - we reach the end of the tree,</a>
<a name="ln1230">  // - or we reach the end of the line.</a>
<a name="ln1231">  for (;; ) {</a>
<a name="ln1232">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln1233">      flen = fold_more(mip);</a>
<a name="ln1234"> </a>
<a name="ln1235">    len = byts[arridx++];</a>
<a name="ln1236"> </a>
<a name="ln1237">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1238">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1239">    if (byts[arridx] == 0) {</a>
<a name="ln1240">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1241">      // try them all, since we don't know which one will give the</a>
<a name="ln1242">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1243">      // of possible prefixes to find_word().</a>
<a name="ln1244">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1245">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1246">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1247">        ++arridx;</a>
<a name="ln1248">        --len;</a>
<a name="ln1249">      }</a>
<a name="ln1250">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1251"> </a>
<a name="ln1252">      // Find the word that comes after the prefix.</a>
<a name="ln1253">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1254">      if (mode == FIND_COMPOUND)</a>
<a name="ln1255">        // Skip over the previously found word(s).</a>
<a name="ln1256">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1257"> </a>
<a name="ln1258">      // Case-folded length may differ from original length.</a>
<a name="ln1259">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1260">                                      mip-&gt;mi_word);</a>
<a name="ln1261">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">      if (len == 0)</a>
<a name="ln1265">        break;              // no children, word must end here</a>
<a name="ln1266">    }</a>
<a name="ln1267"> </a>
<a name="ln1268">    // Stop looking at end of the line.</a>
<a name="ln1269">    if (ptr[wlen] == NUL)</a>
<a name="ln1270">      break;</a>
<a name="ln1271"> </a>
<a name="ln1272">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1273">    c = ptr[wlen];</a>
<a name="ln1274">    lo = arridx;</a>
<a name="ln1275">    hi = arridx + len - 1;</a>
<a name="ln1276">    while (lo &lt; hi) {</a>
<a name="ln1277">      m = (lo + hi) / 2;</a>
<a name="ln1278">      if (byts[m] &gt; c)</a>
<a name="ln1279">        hi = m - 1;</a>
<a name="ln1280">      else if (byts[m] &lt; c)</a>
<a name="ln1281">        lo = m + 1;</a>
<a name="ln1282">      else {</a>
<a name="ln1283">        lo = hi = m;</a>
<a name="ln1284">        break;</a>
<a name="ln1285">      }</a>
<a name="ln1286">    }</a>
<a name="ln1287"> </a>
<a name="ln1288">    // Stop if there is no matching byte.</a>
<a name="ln1289">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln1290">      break;</a>
<a name="ln1291"> </a>
<a name="ln1292">    // Continue at the child (if there is one).</a>
<a name="ln1293">    arridx = idxs[lo];</a>
<a name="ln1294">    ++wlen;</a>
<a name="ln1295">    --flen;</a>
<a name="ln1296">  }</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1300">// for efficiency.  Include the non-word character too.</a>
<a name="ln1301">// Return the length of the folded chars in bytes.</a>
<a name="ln1302">static int fold_more(matchinf_T *mip)</a>
<a name="ln1303">{</a>
<a name="ln1304">  int flen;</a>
<a name="ln1305">  char_u      *p;</a>
<a name="ln1306"> </a>
<a name="ln1307">  p = mip-&gt;mi_fend;</a>
<a name="ln1308">  do {</a>
<a name="ln1309">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1310">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1311"> </a>
<a name="ln1312">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1313">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1314">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1315">  }</a>
<a name="ln1316"> </a>
<a name="ln1317">  (void)spell_casefold(p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1318">      mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1319">      MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1320">  flen = (int)STRLEN(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1321">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1322">  return flen;</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1326">/// case.</a>
<a name="ln1327">///</a>
<a name="ln1328">/// @param wordflags Flags for the checked word.</a>
<a name="ln1329">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1330">static bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1331">{</a>
<a name="ln1332">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1333">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1334">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1335">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">// Returns true if spell checking is not enabled.</a>
<a name="ln1339">static bool no_spell_checking(win_T *wp)</a>
<a name="ln1340">{</a>
<a name="ln1341">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL</a>
<a name="ln1342">      || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1343">    EMSG(_(&quot;E756: Spell checking is not enabled&quot;));</a>
<a name="ln1344">    return true;</a>
<a name="ln1345">  }</a>
<a name="ln1346">  return false;</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349">// Moves to the next spell error.</a>
<a name="ln1350">// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1351">// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1352">// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1353">// to after badly spelled word before the cursor.</a>
<a name="ln1354">// Return 0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1355">size_t</a>
<a name="ln1356">spell_move_to (</a>
<a name="ln1357">    win_T *wp,</a>
<a name="ln1358">    int dir,                  // FORWARD or BACKWARD</a>
<a name="ln1359">    bool allwords,            // true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1360">    bool curline,</a>
<a name="ln1361">    hlf_T *attrp              // return: attributes of bad word or NULL</a>
<a name="ln1362">                              // (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1363">)</a>
<a name="ln1364">{</a>
<a name="ln1365">  linenr_T lnum;</a>
<a name="ln1366">  pos_T found_pos;</a>
<a name="ln1367">  size_t found_len = 0;</a>
<a name="ln1368">  char_u      *line;</a>
<a name="ln1369">  char_u      *p;</a>
<a name="ln1370">  char_u      *endp;</a>
<a name="ln1371">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1372">  size_t len;</a>
<a name="ln1373">  int has_syntax = syntax_present(wp);</a>
<a name="ln1374">  int col;</a>
<a name="ln1375">  bool can_spell;</a>
<a name="ln1376">  char_u      *buf = NULL;</a>
<a name="ln1377">  size_t buflen = 0;</a>
<a name="ln1378">  int skip = 0;</a>
<a name="ln1379">  int capcol = -1;</a>
<a name="ln1380">  bool found_one = false;</a>
<a name="ln1381">  bool wrapped = false;</a>
<a name="ln1382"> </a>
<a name="ln1383">  if (no_spell_checking(wp))</a>
<a name="ln1384">    return 0;</a>
<a name="ln1385"> </a>
<a name="ln1386">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1387">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1388">  //</a>
<a name="ln1389">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1390">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1391">  //</a>
<a name="ln1392">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1393">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1394">  // though...</a>
<a name="ln1395">  lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1396">  clearpos(&amp;found_pos);</a>
<a name="ln1397"> </a>
<a name="ln1398">  while (!got_int) {</a>
<a name="ln1399">    line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1400"> </a>
<a name="ln1401">    len = STRLEN(line);</a>
<a name="ln1402">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1403">      xfree(buf);</a>
<a name="ln1404">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1405">      buf = xmalloc(buflen);</a>
<a name="ln1406">    }</a>
<a name="ln1407">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1408"> </a>
<a name="ln1409">    // In first line check first word for Capital.</a>
<a name="ln1410">    if (lnum == 1)</a>
<a name="ln1411">      capcol = 0;</a>
<a name="ln1412"> </a>
<a name="ln1413">    // For checking first word with a capital skip white space.</a>
<a name="ln1414">    if (capcol == 0) {</a>
<a name="ln1415">      capcol = (int)getwhitecols(line);</a>
<a name="ln1416">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1417">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1418">      col = (int)getwhitecols(line);</a>
<a name="ln1419">      if (check_need_cap(lnum, col)) {</a>
<a name="ln1420">        capcol = col;</a>
<a name="ln1421">      }</a>
<a name="ln1422"> </a>
<a name="ln1423">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1424">      // one.</a>
<a name="ln1425">      line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1429">    // possible.</a>
<a name="ln1430">    STRCPY(buf, line);</a>
<a name="ln1431">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1432">      spell_cat_line(buf + STRLEN(buf),</a>
<a name="ln1433">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1, FALSE),</a>
<a name="ln1434">                     MAXWLEN);</a>
<a name="ln1435">    p = buf + skip;</a>
<a name="ln1436">    endp = buf + len;</a>
<a name="ln1437">    while (p &lt; endp) {</a>
<a name="ln1438">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1439">      // we wrapped around the end of the buffer.</a>
<a name="ln1440">      if (dir == BACKWARD</a>
<a name="ln1441">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1442">          &amp;&amp; !wrapped</a>
<a name="ln1443">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col)</a>
<a name="ln1444">        break;</a>
<a name="ln1445"> </a>
<a name="ln1446">      // start of word</a>
<a name="ln1447">      attr = HLF_COUNT;</a>
<a name="ln1448">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1449"> </a>
<a name="ln1450">      if (attr != HLF_COUNT) {</a>
<a name="ln1451">        // We found a bad word.  Check the attribute.</a>
<a name="ln1452">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1453">          // When searching forward only accept a bad word after</a>
<a name="ln1454">          // the cursor.</a>
<a name="ln1455">          if (dir == BACKWARD</a>
<a name="ln1456">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1457">              || wrapped</a>
<a name="ln1458">              || ((colnr_T)(curline</a>
<a name="ln1459">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1460">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1461">            if (has_syntax) {</a>
<a name="ln1462">              col = (int)(p - buf);</a>
<a name="ln1463">              (void)syn_get_id(wp, lnum, (colnr_T)col,</a>
<a name="ln1464">                  FALSE, &amp;can_spell, FALSE);</a>
<a name="ln1465">              if (!can_spell)</a>
<a name="ln1466">                attr = HLF_COUNT;</a>
<a name="ln1467">            } else</a>
<a name="ln1468">              can_spell = true;</a>
<a name="ln1469"> </a>
<a name="ln1470">            if (can_spell) {</a>
<a name="ln1471">              found_one = true;</a>
<a name="ln1472">              found_pos.lnum = lnum;</a>
<a name="ln1473">              found_pos.col = (int)(p - buf);</a>
<a name="ln1474">              found_pos.coladd = 0;</a>
<a name="ln1475">              if (dir == FORWARD) {</a>
<a name="ln1476">                // No need to search further.</a>
<a name="ln1477">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1478">                xfree(buf);</a>
<a name="ln1479">                if (attrp != NULL)</a>
<a name="ln1480">                  *attrp = attr;</a>
<a name="ln1481">                return len;</a>
<a name="ln1482">              } else if (curline) {</a>
<a name="ln1483">                // Insert mode completion: put cursor after</a>
<a name="ln1484">                // the bad word.</a>
<a name="ln1485">                assert(len &lt;= INT_MAX);</a>
<a name="ln1486">                found_pos.col += (int)len;</a>
<a name="ln1487">              }</a>
<a name="ln1488">              found_len = len;</a>
<a name="ln1489">            }</a>
<a name="ln1490">          } else</a>
<a name="ln1491">            found_one = true;</a>
<a name="ln1492">        }</a>
<a name="ln1493">      }</a>
<a name="ln1494"> </a>
<a name="ln1495">      // advance to character after the word</a>
<a name="ln1496">      p += len;</a>
<a name="ln1497">      assert(len &lt;= INT_MAX);</a>
<a name="ln1498">      capcol -= (int)len;</a>
<a name="ln1499">    }</a>
<a name="ln1500"> </a>
<a name="ln1501">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1502">      // Use the last match in the line (before the cursor).</a>
<a name="ln1503">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1504">      xfree(buf);</a>
<a name="ln1505">      return found_len;</a>
<a name="ln1506">    }</a>
<a name="ln1507"> </a>
<a name="ln1508">    if (curline) {</a>
<a name="ln1509">      break;            // only check cursor line</a>
<a name="ln1510">    }</a>
<a name="ln1511"> </a>
<a name="ln1512">    // If we are back at the starting line and searched it again there</a>
<a name="ln1513">    // is no match, give up.</a>
<a name="ln1514">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1515">      break;</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">    // Advance to next line.</a>
<a name="ln1519">    if (dir == BACKWARD) {</a>
<a name="ln1520">      if (lnum &gt; 1) {</a>
<a name="ln1521">        lnum--;</a>
<a name="ln1522">      } else if (!p_ws) {</a>
<a name="ln1523">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1524">      } else {</a>
<a name="ln1525">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1526">        // starting line again and accept the last match.</a>
<a name="ln1527">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1528">        wrapped = true;</a>
<a name="ln1529">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1530">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1531">      }</a>
<a name="ln1532">      capcol = -1;</a>
<a name="ln1533">    } else {</a>
<a name="ln1534">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1535">        ++lnum;</a>
<a name="ln1536">      else if (!p_ws)</a>
<a name="ln1537">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1538">      else {</a>
<a name="ln1539">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1540">        // starting line again and accept the first match.</a>
<a name="ln1541">        lnum = 1;</a>
<a name="ln1542">        wrapped = true;</a>
<a name="ln1543">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1544">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1545">      }</a>
<a name="ln1546"> </a>
<a name="ln1547">      // If we are back at the starting line and there is no match then</a>
<a name="ln1548">      // give up.</a>
<a name="ln1549">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1550">        break;</a>
<a name="ln1551">      }</a>
<a name="ln1552"> </a>
<a name="ln1553">      // Skip the characters at the start of the next line that were</a>
<a name="ln1554">      // included in a match crossing line boundaries.</a>
<a name="ln1555">      if (attr == HLF_COUNT)</a>
<a name="ln1556">        skip = (int)(p - endp);</a>
<a name="ln1557">      else</a>
<a name="ln1558">        skip = 0;</a>
<a name="ln1559"> </a>
<a name="ln1560">      // Capcol skips over the inserted space.</a>
<a name="ln1561">      --capcol;</a>
<a name="ln1562"> </a>
<a name="ln1563">      // But after empty line check first word in next line</a>
<a name="ln1564">      if (*skipwhite(line) == NUL)</a>
<a name="ln1565">        capcol = 0;</a>
<a name="ln1566">    }</a>
<a name="ln1567"> </a>
<a name="ln1568">    line_breakcheck();</a>
<a name="ln1569">  }</a>
<a name="ln1570"> </a>
<a name="ln1571">  xfree(buf);</a>
<a name="ln1572">  return 0;</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1576">// &quot;buf&quot;, blanking-out special characters.  Copy less then &quot;maxlen&quot; bytes.</a>
<a name="ln1577">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1578">// to skip those bytes if the word was OK.</a>
<a name="ln1579">void spell_cat_line(char_u *buf, char_u *line, int maxlen)</a>
<a name="ln1580">{</a>
<a name="ln1581">  char_u      *p;</a>
<a name="ln1582">  int n;</a>
<a name="ln1583"> </a>
<a name="ln1584">  p = skipwhite(line);</a>
<a name="ln1585">  while (vim_strchr((char_u *)&quot;*#/\&quot;\t&quot;, *p) != NULL)</a>
<a name="ln1586">    p = skipwhite(p + 1);</a>
<a name="ln1587"> </a>
<a name="ln1588">  if (*p != NUL) {</a>
<a name="ln1589">    // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1590">    // concatenate.</a>
<a name="ln1591">    n = (int)(p - line) + 1;</a>
<a name="ln1592">    if (n &lt; maxlen - 1) {</a>
<a name="ln1593">      memset(buf, ' ', n);</a>
<a name="ln1594">      STRLCPY(buf +  n, p, maxlen - n);</a>
<a name="ln1595">    }</a>
<a name="ln1596">  }</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1600">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1601">static void spell_load_lang(char_u *lang)</a>
<a name="ln1602">{</a>
<a name="ln1603">  char_u fname_enc[85];</a>
<a name="ln1604">  int r;</a>
<a name="ln1605">  spelload_T sl;</a>
<a name="ln1606">  int round;</a>
<a name="ln1607"> </a>
<a name="ln1608">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1609">  // It's truncated when an error is detected.</a>
<a name="ln1610">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1611">  sl.sl_slang = NULL;</a>
<a name="ln1612">  sl.sl_nobreak = false;</a>
<a name="ln1613"> </a>
<a name="ln1614">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1615">  // autocommand may load it then.</a>
<a name="ln1616">  for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln1617">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1618">    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1619">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1620">    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1621"> </a>
<a name="ln1622">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1623">      // Try loading the ASCII version.</a>
<a name="ln1624">      vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1625">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1626">      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1627"> </a>
<a name="ln1628">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1629">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</a>
<a name="ln1630">              curbuf-&gt;b_fname, FALSE, curbuf))</a>
<a name="ln1631">        continue;</a>
<a name="ln1632">      break;</a>
<a name="ln1633">    }</a>
<a name="ln1634">    break;</a>
<a name="ln1635">  }</a>
<a name="ln1636"> </a>
<a name="ln1637">  if (r == FAIL) {</a>
<a name="ln1638">    if (starting) {</a>
<a name="ln1639">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1640">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1641">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1642">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1643">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1644">               lang);</a>
<a name="ln1645">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1646">    } else {</a>
<a name="ln1647">      smsg(</a>
<a name="ln1648">        _(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1649">        lang, spell_enc(), lang);</a>
<a name="ln1650">    }</a>
<a name="ln1651">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1652">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1653">    STRCPY(fname_enc + STRLEN(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1654">    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1655">  }</a>
<a name="ln1656">}</a>
<a name="ln1657"> </a>
<a name="ln1658">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1659">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1660">char_u *spell_enc(void)</a>
<a name="ln1661">{</a>
<a name="ln1662"> </a>
<a name="ln1663">  if (STRLEN(p_enc) &lt; 60 &amp;&amp; STRCMP(p_enc, &quot;iso-8859-15&quot;) != 0)</a>
<a name="ln1664">    return p_enc;</a>
<a name="ln1665">  return (char_u *)&quot;latin1&quot;;</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1669">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1670">static void int_wordlist_spl(char_u *fname)</a>
<a name="ln1671">{</a>
<a name="ln1672">  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1673">      int_wordlist, spell_enc());</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1677">// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1678">slang_T *slang_alloc(char_u *lang)</a>
<a name="ln1679">{</a>
<a name="ln1680">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1681"> </a>
<a name="ln1682">  if (lang != NULL)</a>
<a name="ln1683">    lp-&gt;sl_name = vim_strsave(lang);</a>
<a name="ln1684">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1685">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1686">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1687">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1688">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1689"> </a>
<a name="ln1690">  return lp;</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1694">void slang_free(slang_T *lp)</a>
<a name="ln1695">{</a>
<a name="ln1696">  xfree(lp-&gt;sl_name);</a>
<a name="ln1697">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1698">  slang_clear(lp);</a>
<a name="ln1699">  xfree(lp);</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">/// Frees a salitem_T</a>
<a name="ln1703">static void free_salitem(salitem_T *smp) {</a>
<a name="ln1704">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1705">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1706">  xfree(smp-&gt;sm_to);</a>
<a name="ln1707">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1708">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1709">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">/// Frees a fromto_T</a>
<a name="ln1713">static void free_fromto(fromto_T *ftp) {</a>
<a name="ln1714">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1715">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1716">}</a>
<a name="ln1717"> </a>
<a name="ln1718">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1719">void slang_clear(slang_T *lp)</a>
<a name="ln1720">{</a>
<a name="ln1721">  garray_T    *gap;</a>
<a name="ln1722"> </a>
<a name="ln1723">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1724">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1725">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1726"> </a>
<a name="ln1727">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1728">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1729">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1730"> </a>
<a name="ln1731">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1732">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1733"> </a>
<a name="ln1734">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1735">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1736">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1737">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1738">  } else {</a>
<a name="ln1739">    // SAL items: free salitem_T items</a>
<a name="ln1740">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1741">  }</a>
<a name="ln1742"> </a>
<a name="ln1743">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; ++i) {</a>
<a name="ln1744">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1745">  }</a>
<a name="ln1746">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1747">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1748">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1749">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1750"> </a>
<a name="ln1751">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1752">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1753">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1754">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1755">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1756"> </a>
<a name="ln1757">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1758">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1759"> </a>
<a name="ln1760">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1761"> </a>
<a name="ln1762">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1763">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1764"> </a>
<a name="ln1765">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1766"> </a>
<a name="ln1767">  // Clear info from .sug file.</a>
<a name="ln1768">  slang_clear_sug(lp);</a>
<a name="ln1769"> </a>
<a name="ln1770">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1771">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1772">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1773">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1777">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1778">{</a>
<a name="ln1779">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1780">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1781">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1782">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1783">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1784">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1788">// Invoked through do_in_runtimepath().</a>
<a name="ln1789">static void spell_load_cb(char_u *fname, void *cookie)</a>
<a name="ln1790">{</a>
<a name="ln1791">  spelload_T  *slp = (spelload_T *)cookie;</a>
<a name="ln1792">  slang_T     *slang;</a>
<a name="ln1793"> </a>
<a name="ln1794">  slang = spell_load_file(fname, slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1795">  if (slang != NULL) {</a>
<a name="ln1796">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1797">    // &quot;.add&quot; files.</a>
<a name="ln1798">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add)</a>
<a name="ln1799">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1800">    else if (slang-&gt;sl_nobreak)</a>
<a name="ln1801">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1802"> </a>
<a name="ln1803">    slp-&gt;sl_slang = slang;</a>
<a name="ln1804">  }</a>
<a name="ln1805">}</a>
<a name="ln1806"> </a>
<a name="ln1807">/// Add a word to the hashtable of common words.</a>
<a name="ln1808">/// If it's already there then the counter is increased.</a>
<a name="ln1809">///</a>
<a name="ln1810">/// @param[in]  lp</a>
<a name="ln1811">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1812">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1813">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1814">void count_common_word(slang_T *lp, char_u *word, int len, int count)</a>
<a name="ln1815">{</a>
<a name="ln1816">  hash_T hash;</a>
<a name="ln1817">  hashitem_T  *hi;</a>
<a name="ln1818">  wordcount_T *wc;</a>
<a name="ln1819">  char_u buf[MAXWLEN];</a>
<a name="ln1820">  char_u      *p;</a>
<a name="ln1821"> </a>
<a name="ln1822">  if (len == -1) {</a>
<a name="ln1823">    p = word;</a>
<a name="ln1824">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1825">    return;</a>
<a name="ln1826">  } else {</a>
<a name="ln1827">    STRLCPY(buf, word, len + 1);</a>
<a name="ln1828">    p = buf;</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  hash = hash_hash(p);</a>
<a name="ln1832">  const size_t p_len = STRLEN(p);</a>
<a name="ln1833">  hi = hash_lookup(&amp;lp-&gt;sl_wordcount, (const char *)p, p_len, hash);</a>
<a name="ln1834">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1835">    wc = xmalloc(sizeof(wordcount_T) + p_len);</a>
<a name="ln1836">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1837">    wc-&gt;wc_count = count;</a>
<a name="ln1838">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1839">  } else {</a>
<a name="ln1840">    wc = HI2WC(hi);</a>
<a name="ln1841">    if ((wc-&gt;wc_count += count) &lt; (unsigned)count)      // check for overflow</a>
<a name="ln1842">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1843">  }</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">// Adjust the score of common words.</a>
<a name="ln1847">static int</a>
<a name="ln1848">score_wordcount_adj (</a>
<a name="ln1849">    slang_T *slang,</a>
<a name="ln1850">    int score,</a>
<a name="ln1851">    char_u *word,</a>
<a name="ln1852">    bool split                  // word was split, less bonus</a>
<a name="ln1853">)</a>
<a name="ln1854">{</a>
<a name="ln1855">  hashitem_T  *hi;</a>
<a name="ln1856">  wordcount_T *wc;</a>
<a name="ln1857">  int bonus;</a>
<a name="ln1858">  int newscore;</a>
<a name="ln1859"> </a>
<a name="ln1860">  hi = hash_find(&amp;slang-&gt;sl_wordcount, word);</a>
<a name="ln1861">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1862">    wc = HI2WC(hi);</a>
<a name="ln1863">    if (wc-&gt;wc_count &lt; SCORE_THRES2)</a>
<a name="ln1864">      bonus = SCORE_COMMON1;</a>
<a name="ln1865">    else if (wc-&gt;wc_count &lt; SCORE_THRES3)</a>
<a name="ln1866">      bonus = SCORE_COMMON2;</a>
<a name="ln1867">    else</a>
<a name="ln1868">      bonus = SCORE_COMMON3;</a>
<a name="ln1869">    if (split)</a>
<a name="ln1870">      newscore = score - bonus / 2;</a>
<a name="ln1871">    else</a>
<a name="ln1872">      newscore = score - bonus;</a>
<a name="ln1873">    if (newscore &lt; 0)</a>
<a name="ln1874">      return 0;</a>
<a name="ln1875">    return newscore;</a>
<a name="ln1876">  }</a>
<a name="ln1877">  return score;</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1881">// Like strchr() but independent of locale.</a>
<a name="ln1882">bool byte_in_str(char_u *str, int n)</a>
<a name="ln1883">{</a>
<a name="ln1884">  char_u      *p;</a>
<a name="ln1885"> </a>
<a name="ln1886">  for (p = str; *p != NUL; ++p)</a>
<a name="ln1887">    if (*p == n)</a>
<a name="ln1888">      return true;</a>
<a name="ln1889">  return false;</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1893">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1894">int init_syl_tab(slang_T *slang)</a>
<a name="ln1895">{</a>
<a name="ln1896">  char_u      *p;</a>
<a name="ln1897">  char_u      *s;</a>
<a name="ln1898">  int l;</a>
<a name="ln1899"> </a>
<a name="ln1900">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1901">  p = vim_strchr(slang-&gt;sl_syllable, '/');</a>
<a name="ln1902">  while (p != NULL) {</a>
<a name="ln1903">    *p++ = NUL;</a>
<a name="ln1904">    if (*p == NUL)          // trailing slash</a>
<a name="ln1905">      break;</a>
<a name="ln1906">    s = p;</a>
<a name="ln1907">    p = vim_strchr(p, '/');</a>
<a name="ln1908">    if (p == NULL)</a>
<a name="ln1909">      l = (int)STRLEN(s);</a>
<a name="ln1910">    else</a>
<a name="ln1911">      l = (int)(p - s);</a>
<a name="ln1912">    if (l &gt;= SY_MAXLEN)</a>
<a name="ln1913">      return SP_FORMERROR;</a>
<a name="ln1914"> </a>
<a name="ln1915">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1916">    STRLCPY(syl-&gt;sy_chars, s, l + 1);</a>
<a name="ln1917">    syl-&gt;sy_len = l;</a>
<a name="ln1918">  }</a>
<a name="ln1919">  return OK;</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1923">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1924">// Returns zero if syllables are not defines.</a>
<a name="ln1925">static int count_syllables(slang_T *slang, const char_u *word)</a>
<a name="ln1926">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1927">{</a>
<a name="ln1928">  int cnt = 0;</a>
<a name="ln1929">  bool skip = false;</a>
<a name="ln1930">  int len;</a>
<a name="ln1931">  syl_item_T  *syl;</a>
<a name="ln1932">  int c;</a>
<a name="ln1933"> </a>
<a name="ln1934">  if (slang-&gt;sl_syllable == NULL)</a>
<a name="ln1935">    return 0;</a>
<a name="ln1936"> </a>
<a name="ln1937">  for (const char_u *p = word; *p != NUL; p += len) {</a>
<a name="ln1938">    // When running into a space reset counter.</a>
<a name="ln1939">    if (*p == ' ') {</a>
<a name="ln1940">      len = 1;</a>
<a name="ln1941">      cnt = 0;</a>
<a name="ln1942">      continue;</a>
<a name="ln1943">    }</a>
<a name="ln1944"> </a>
<a name="ln1945">    // Find longest match of syllable items.</a>
<a name="ln1946">    len = 0;</a>
<a name="ln1947">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; ++i) {</a>
<a name="ln1948">      syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln1949">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln1950">          &amp;&amp; STRNCMP(p, syl-&gt;sy_chars, syl-&gt;sy_len) == 0)</a>
<a name="ln1951">        len = syl-&gt;sy_len;</a>
<a name="ln1952">    }</a>
<a name="ln1953">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln1954">      ++cnt;</a>
<a name="ln1955">      skip = false;</a>
<a name="ln1956">    } else {</a>
<a name="ln1957">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln1958">      c = utf_ptr2char(p);</a>
<a name="ln1959">      len = (*mb_ptr2len)(p);</a>
<a name="ln1960">      if (vim_strchr(slang-&gt;sl_syllable, c) == NULL)</a>
<a name="ln1961">        skip = false;               // No, search for next syllable</a>
<a name="ln1962">      else if (!skip) {</a>
<a name="ln1963">        ++cnt;                      // Yes, count it</a>
<a name="ln1964">        skip = true;                // don't count following syllable chars</a>
<a name="ln1965">      }</a>
<a name="ln1966">    }</a>
<a name="ln1967">  }</a>
<a name="ln1968">  return cnt;</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln1972">// Returns NULL if it's OK, an error message otherwise.</a>
<a name="ln1973">char_u *did_set_spelllang(win_T *wp)</a>
<a name="ln1974">{</a>
<a name="ln1975">  garray_T ga;</a>
<a name="ln1976">  char_u      *splp;</a>
<a name="ln1977">  char_u      *region;</a>
<a name="ln1978">  char_u region_cp[3];</a>
<a name="ln1979">  bool filename;</a>
<a name="ln1980">  int region_mask;</a>
<a name="ln1981">  slang_T     *slang;</a>
<a name="ln1982">  int c;</a>
<a name="ln1983">  char_u lang[MAXWLEN + 1];</a>
<a name="ln1984">  char_u spf_name[MAXPATHL];</a>
<a name="ln1985">  int len;</a>
<a name="ln1986">  char_u      *p;</a>
<a name="ln1987">  int round;</a>
<a name="ln1988">  char_u      *spf;</a>
<a name="ln1989">  char_u      *use_region = NULL;</a>
<a name="ln1990">  bool dont_use_region = false;</a>
<a name="ln1991">  bool nobreak = false;</a>
<a name="ln1992">  langp_T     *lp, *lp2;</a>
<a name="ln1993">  static bool recursive = false;</a>
<a name="ln1994">  char_u      *ret_msg = NULL;</a>
<a name="ln1995">  char_u      *spl_copy;</a>
<a name="ln1996"> </a>
<a name="ln1997">  bufref_T bufref;</a>
<a name="ln1998">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln1999"> </a>
<a name="ln2000">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln2001">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln2002">  // in which 'spell' is set.</a>
<a name="ln2003">  if (recursive)</a>
<a name="ln2004">    return NULL;</a>
<a name="ln2005">  recursive = true;</a>
<a name="ln2006"> </a>
<a name="ln2007">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln2008">  clear_midword(wp);</a>
<a name="ln2009"> </a>
<a name="ln2010">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln2011">  // it under our fingers.</a>
<a name="ln2012">  spl_copy = vim_strsave(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln2013"> </a>
<a name="ln2014">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln2015"> </a>
<a name="ln2016">  // Loop over comma separated language names.</a>
<a name="ln2017">  for (splp = spl_copy; *splp != NUL; ) {</a>
<a name="ln2018">    // Get one language name.</a>
<a name="ln2019">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln2020">    region = NULL;</a>
<a name="ln2021">    len = (int)STRLEN(lang);</a>
<a name="ln2022"> </a>
<a name="ln2023">    if (!valid_spelllang(lang)) {</a>
<a name="ln2024">      continue;</a>
<a name="ln2025">    }</a>
<a name="ln2026"> </a>
<a name="ln2027">    if (STRCMP(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln2028">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln2029">      continue;</a>
<a name="ln2030">    }</a>
<a name="ln2031"> </a>
<a name="ln2032">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln2033">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln2034">    // from the name.</a>
<a name="ln2035">    if (len &gt; 4 &amp;&amp; fnamecmp(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2036">      filename = true;</a>
<a name="ln2037"> </a>
<a name="ln2038">      // Locate a region and remove it from the file name.</a>
<a name="ln2039">      p = vim_strchr(path_tail(lang), '_');</a>
<a name="ln2040">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2041">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2042">        STRLCPY(region_cp, p + 1, 3);</a>
<a name="ln2043">        memmove(p, p + 3, len - (p - lang) - 2);</a>
<a name="ln2044">        region = region_cp;</a>
<a name="ln2045">      } else</a>
<a name="ln2046">        dont_use_region = true;</a>
<a name="ln2047"> </a>
<a name="ln2048">      // Check if we loaded this language before.</a>
<a name="ln2049">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2050">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2051">            == kEqualFiles) {</a>
<a name="ln2052">          break;</a>
<a name="ln2053">        }</a>
<a name="ln2054">      }</a>
<a name="ln2055">    } else {</a>
<a name="ln2056">      filename = false;</a>
<a name="ln2057">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2058">        region = lang + len - 2;</a>
<a name="ln2059">        lang[len - 3] = NUL;</a>
<a name="ln2060">      } else</a>
<a name="ln2061">        dont_use_region = true;</a>
<a name="ln2062"> </a>
<a name="ln2063">      // Check if we loaded this language before.</a>
<a name="ln2064">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next)</a>
<a name="ln2065">        if (STRICMP(lang, slang-&gt;sl_name) == 0)</a>
<a name="ln2066">          break;</a>
<a name="ln2067">    }</a>
<a name="ln2068"> </a>
<a name="ln2069">    if (region != NULL) {</a>
<a name="ln2070">      // If the region differs from what was used before then don't</a>
<a name="ln2071">      // use it for 'spellfile'.</a>
<a name="ln2072">      if (use_region != NULL &amp;&amp; STRCMP(region, use_region) != 0)</a>
<a name="ln2073">        dont_use_region = true;</a>
<a name="ln2074">      use_region = region;</a>
<a name="ln2075">    }</a>
<a name="ln2076"> </a>
<a name="ln2077">    // If not found try loading the language now.</a>
<a name="ln2078">    if (slang == NULL) {</a>
<a name="ln2079">      if (filename)</a>
<a name="ln2080">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2081">      else {</a>
<a name="ln2082">        spell_load_lang(lang);</a>
<a name="ln2083">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2084">        // destroying the buffer we are using...</a>
<a name="ln2085">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2086">          ret_msg =</a>
<a name="ln2087">            (char_u *)N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2088">          goto theend;</a>
<a name="ln2089">        }</a>
<a name="ln2090">      }</a>
<a name="ln2091">    }</a>
<a name="ln2092"> </a>
<a name="ln2093">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2094">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2095">      if (filename</a>
<a name="ln2096">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2097">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2098">        region_mask = REGION_ALL;</a>
<a name="ln2099">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2100">          // find region in sl_regions</a>
<a name="ln2101">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2102">          if (c == REGION_ALL) {</a>
<a name="ln2103">            if (slang-&gt;sl_add) {</a>
<a name="ln2104">              if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2105">                // This addition file is for other regions.</a>
<a name="ln2106">                region_mask = 0;</a>
<a name="ln2107">            } else</a>
<a name="ln2108">              // This is probably an error.  Give a warning and</a>
<a name="ln2109">              // accept the words anyway.</a>
<a name="ln2110">              smsg(_(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2111">                   region);</a>
<a name="ln2112">          } else</a>
<a name="ln2113">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2114">        }</a>
<a name="ln2115"> </a>
<a name="ln2116">        if (region_mask != 0) {</a>
<a name="ln2117">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2118">          p_-&gt;lp_slang = slang;</a>
<a name="ln2119">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2120"> </a>
<a name="ln2121">          use_midword(slang, wp);</a>
<a name="ln2122">          if (slang-&gt;sl_nobreak)</a>
<a name="ln2123">            nobreak = true;</a>
<a name="ln2124">        }</a>
<a name="ln2125">      }</a>
<a name="ln2126">    }</a>
<a name="ln2127">  }</a>
<a name="ln2128"> </a>
<a name="ln2129">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2130">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2131">  // round 2: load second name in 'spellfile.</a>
<a name="ln2132">  // etc.</a>
<a name="ln2133">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2134">  for (round = 0; round == 0 || *spf != NUL; ++round) {</a>
<a name="ln2135">    if (round == 0) {</a>
<a name="ln2136">      // Internal wordlist, if there is one.</a>
<a name="ln2137">      if (int_wordlist == NULL)</a>
<a name="ln2138">        continue;</a>
<a name="ln2139">      int_wordlist_spl(spf_name);</a>
<a name="ln2140">    } else {</a>
<a name="ln2141">      // One entry in 'spellfile'.</a>
<a name="ln2142">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2143">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2144"> </a>
<a name="ln2145">      // If it was already found above then skip it.</a>
<a name="ln2146">      for (c = 0; c &lt; ga.ga_len; ++c) {</a>
<a name="ln2147">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2148">        if (p != NULL</a>
<a name="ln2149">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2150">          break;</a>
<a name="ln2151">        }</a>
<a name="ln2152">      }</a>
<a name="ln2153">      if (c &lt; ga.ga_len)</a>
<a name="ln2154">        continue;</a>
<a name="ln2155">    }</a>
<a name="ln2156"> </a>
<a name="ln2157">    // Check if it was loaded already.</a>
<a name="ln2158">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2159">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2160">          == kEqualFiles) {</a>
<a name="ln2161">        break;</a>
<a name="ln2162">      }</a>
<a name="ln2163">    }</a>
<a name="ln2164">    if (slang == NULL) {</a>
<a name="ln2165">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2166">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2167">      // use an arbitrary name.</a>
<a name="ln2168">      if (round == 0)</a>
<a name="ln2169">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2170">      else {</a>
<a name="ln2171">        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);</a>
<a name="ln2172">        p = vim_strchr(lang, '.');</a>
<a name="ln2173">        if (p != NULL)</a>
<a name="ln2174">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2175">      }</a>
<a name="ln2176">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2177"> </a>
<a name="ln2178">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2179">      // files also have this.</a>
<a name="ln2180">      if (slang != NULL &amp;&amp; nobreak)</a>
<a name="ln2181">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2182">    }</a>
<a name="ln2183">    if (slang != NULL) {</a>
<a name="ln2184">      region_mask = REGION_ALL;</a>
<a name="ln2185">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2186">        // find region in sl_regions</a>
<a name="ln2187">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2188">        if (c != REGION_ALL)</a>
<a name="ln2189">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2190">        else if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2191">          // This spell file is for other regions.</a>
<a name="ln2192">          region_mask = 0;</a>
<a name="ln2193">      }</a>
<a name="ln2194"> </a>
<a name="ln2195">      if (region_mask != 0) {</a>
<a name="ln2196">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2197">        p_-&gt;lp_slang = slang;</a>
<a name="ln2198">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2199">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2200">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2201"> </a>
<a name="ln2202">        use_midword(slang, wp);</a>
<a name="ln2203">      }</a>
<a name="ln2204">    }</a>
<a name="ln2205">  }</a>
<a name="ln2206"> </a>
<a name="ln2207">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2208">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2209">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2210"> </a>
<a name="ln2211">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2212">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2213">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2214">  for (int i = 0; i &lt; ga.ga_len; ++i) {</a>
<a name="ln2215">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2216"> </a>
<a name="ln2217">    // sound folding</a>
<a name="ln2218">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal))</a>
<a name="ln2219">      // language does sound folding itself</a>
<a name="ln2220">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2221">    else</a>
<a name="ln2222">      // find first similar language that does sound folding</a>
<a name="ln2223">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2224">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2225">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2226">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2227">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2228">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2229">          break;</a>
<a name="ln2230">        }</a>
<a name="ln2231">      }</a>
<a name="ln2232"> </a>
<a name="ln2233">    // REP items</a>
<a name="ln2234">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep))</a>
<a name="ln2235">      // language has REP items itself</a>
<a name="ln2236">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2237">    else</a>
<a name="ln2238">      // find first similar language that has REP items</a>
<a name="ln2239">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2240">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2241">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2242">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2243">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2244">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2245">          break;</a>
<a name="ln2246">        }</a>
<a name="ln2247">      }</a>
<a name="ln2248">  }</a>
<a name="ln2249"> </a>
<a name="ln2250">theend:</a>
<a name="ln2251">  xfree(spl_copy);</a>
<a name="ln2252">  recursive = false;</a>
<a name="ln2253">  redraw_later(wp, NOT_VALID);</a>
<a name="ln2254">  return ret_msg;</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2258">static void clear_midword(win_T *wp)</a>
<a name="ln2259">{</a>
<a name="ln2260">  memset(wp-&gt;w_s-&gt;b_spell_ismw, 0, 256);</a>
<a name="ln2261">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2262">}</a>
<a name="ln2263"> </a>
<a name="ln2264">// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2265">// They add up to any currently used midword characters.</a>
<a name="ln2266">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2267">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2268">{</a>
<a name="ln2269">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2270">    return;</a>
<a name="ln2271">  }</a>
<a name="ln2272"> </a>
<a name="ln2273">  for (char_u *p = lp-&gt;sl_midword; *p != NUL; ) {</a>
<a name="ln2274">    const int c = utf_ptr2char(p);</a>
<a name="ln2275">    const int l = utfc_ptr2len(p);</a>
<a name="ln2276">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2277">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2278">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2279">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2280">      wp-&gt;w_s-&gt;b_spell_ismw_mb = vim_strnsave(p, l);</a>
<a name="ln2281">    } else {</a>
<a name="ln2282">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2283">      const int n = (int)STRLEN(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2284">      char_u *bp = vim_strnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, n + l);</a>
<a name="ln2285">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2286">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2287">      STRLCPY(bp + n, p, l + 1);</a>
<a name="ln2288">    }</a>
<a name="ln2289">    p += l;</a>
<a name="ln2290">  }</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2294">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2295">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2296">static int find_region(char_u *rp, char_u *region)</a>
<a name="ln2297">{</a>
<a name="ln2298">  int i;</a>
<a name="ln2299"> </a>
<a name="ln2300">  for (i = 0;; i += 2) {</a>
<a name="ln2301">    if (rp[i] == NUL)</a>
<a name="ln2302">      return REGION_ALL;</a>
<a name="ln2303">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1])</a>
<a name="ln2304">      break;</a>
<a name="ln2305">  }</a>
<a name="ln2306">  return i / 2;</a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309">/// Return case type of word:</a>
<a name="ln2310">/// w word       0</a>
<a name="ln2311">/// Word         WF_ONECAP</a>
<a name="ln2312">/// W WORD       WF_ALLCAP</a>
<a name="ln2313">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2314">///</a>
<a name="ln2315">/// @param[in]  word</a>
<a name="ln2316">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2317">///</a>
<a name="ln2318">/// @returns  Case type of word</a>
<a name="ln2319">int captype(char_u *word, char_u *end)</a>
<a name="ln2320">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2321">{</a>
<a name="ln2322">  char_u      *p;</a>
<a name="ln2323">  int firstcap;</a>
<a name="ln2324">  bool allcap;</a>
<a name="ln2325">  bool past_second = false;              // past second word char</a>
<a name="ln2326"> </a>
<a name="ln2327">  // find first letter</a>
<a name="ln2328">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2329">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2330">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2331">    }</a>
<a name="ln2332">  }</a>
<a name="ln2333">  int c = mb_ptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2334">  firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2335"> </a>
<a name="ln2336">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2337">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2338">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2339">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2340">      c = PTR2CHAR(p);</a>
<a name="ln2341">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2342">        // UUl -&gt; KEEPCAP</a>
<a name="ln2343">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2344">          return WF_KEEPCAP;</a>
<a name="ln2345">        }</a>
<a name="ln2346">        allcap = false;</a>
<a name="ln2347">      } else if (!allcap) {</a>
<a name="ln2348">        // UlU -&gt; KEEPCAP</a>
<a name="ln2349">        return WF_KEEPCAP;</a>
<a name="ln2350">      }</a>
<a name="ln2351">      past_second = true;</a>
<a name="ln2352">    }</a>
<a name="ln2353">  }</a>
<a name="ln2354"> </a>
<a name="ln2355">  if (allcap)</a>
<a name="ln2356">    return WF_ALLCAP;</a>
<a name="ln2357">  if (firstcap)</a>
<a name="ln2358">    return WF_ONECAP;</a>
<a name="ln2359">  return 0;</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362">// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln2363">// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln2364">// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln2365">static int badword_captype(char_u *word, char_u *end)</a>
<a name="ln2366">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2367">{</a>
<a name="ln2368">  int flags = captype(word, end);</a>
<a name="ln2369">  int c;</a>
<a name="ln2370">  int l, u;</a>
<a name="ln2371">  bool first;</a>
<a name="ln2372">  char_u      *p;</a>
<a name="ln2373"> </a>
<a name="ln2374">  if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2375">    // Count the number of UPPER and lower case letters.</a>
<a name="ln2376">    l = u = 0;</a>
<a name="ln2377">    first = false;</a>
<a name="ln2378">    for (p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2379">      c = PTR2CHAR(p);</a>
<a name="ln2380">      if (SPELL_ISUPPER(c)) {</a>
<a name="ln2381">        ++u;</a>
<a name="ln2382">        if (p == word)</a>
<a name="ln2383">          first = true;</a>
<a name="ln2384">      } else</a>
<a name="ln2385">        ++l;</a>
<a name="ln2386">    }</a>
<a name="ln2387"> </a>
<a name="ln2388">    // If there are more UPPER than lower case letters suggest an</a>
<a name="ln2389">    // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln2390">    // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln2391">    // require three upper case letters.</a>
<a name="ln2392">    if (u &gt; l &amp;&amp; u &gt; 2)</a>
<a name="ln2393">      flags |= WF_ALLCAP;</a>
<a name="ln2394">    else if (first)</a>
<a name="ln2395">      flags |= WF_ONECAP;</a>
<a name="ln2396"> </a>
<a name="ln2397">    if (u &gt;= 2 &amp;&amp; l &gt;= 2)       // maCARONI maCAroni</a>
<a name="ln2398">      flags |= WF_MIXCAP;</a>
<a name="ln2399">  }</a>
<a name="ln2400">  return flags;</a>
<a name="ln2401">}</a>
<a name="ln2402"> </a>
<a name="ln2403">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2404">void spell_delete_wordlist(void)</a>
<a name="ln2405">{</a>
<a name="ln2406">  char_u fname[MAXPATHL] = {0};</a>
<a name="ln2407"> </a>
<a name="ln2408">  if (int_wordlist != NULL) {</a>
<a name="ln2409">    os_remove((char *)int_wordlist);</a>
<a name="ln2410">    int_wordlist_spl(fname);</a>
<a name="ln2411">    os_remove((char *)fname);</a>
<a name="ln2412">    XFREE_CLEAR(int_wordlist);</a>
<a name="ln2413">  }</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">// Free all languages.</a>
<a name="ln2417">void spell_free_all(void)</a>
<a name="ln2418">{</a>
<a name="ln2419">  slang_T     *slang;</a>
<a name="ln2420"> </a>
<a name="ln2421">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2422">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2423">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2424">  }</a>
<a name="ln2425"> </a>
<a name="ln2426">  while (first_lang != NULL) {</a>
<a name="ln2427">    slang = first_lang;</a>
<a name="ln2428">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2429">    slang_free(slang);</a>
<a name="ln2430">  }</a>
<a name="ln2431"> </a>
<a name="ln2432">  spell_delete_wordlist();</a>
<a name="ln2433"> </a>
<a name="ln2434">  XFREE_CLEAR(repl_to);</a>
<a name="ln2435">  XFREE_CLEAR(repl_from);</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">// Clear all spelling tables and reload them.</a>
<a name="ln2439">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2440">void spell_reload(void)</a>
<a name="ln2441">{</a>
<a name="ln2442">  // Initialize the table for spell_iswordp().</a>
<a name="ln2443">  init_spell_chartab();</a>
<a name="ln2444"> </a>
<a name="ln2445">  // Unload all allocated memory.</a>
<a name="ln2446">  spell_free_all();</a>
<a name="ln2447"> </a>
<a name="ln2448">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2449">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2450">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2451">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2452">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2453">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2454">        (void)did_set_spelllang(wp);</a>
<a name="ln2455">        break;</a>
<a name="ln2456">      }</a>
<a name="ln2457">    }</a>
<a name="ln2458">  }</a>
<a name="ln2459">}</a>
<a name="ln2460"> </a>
<a name="ln2461"> </a>
<a name="ln2462">// Opposite of offset2bytes().</a>
<a name="ln2463">// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln2464">// Returns the offset.</a>
<a name="ln2465">static int bytes2offset(char_u **pp)</a>
<a name="ln2466">{</a>
<a name="ln2467">  char_u *p = *pp;</a>
<a name="ln2468">  int nr;</a>
<a name="ln2469">  int c;</a>
<a name="ln2470"> </a>
<a name="ln2471">  c = *p++;</a>
<a name="ln2472">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln2473">    nr = c - 1;</a>
<a name="ln2474">  } else if ((c &amp; 0xc0) == 0x80)   {    // 2 bytes</a>
<a name="ln2475">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln2476">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2477">  } else if ((c &amp; 0xe0) == 0xc0)   {    // 3 bytes</a>
<a name="ln2478">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln2479">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2480">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2481">  } else {                              // 4 bytes</a>
<a name="ln2482">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln2483">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2484">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2485">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2486">  }</a>
<a name="ln2487"> </a>
<a name="ln2488">  *pp = p;</a>
<a name="ln2489">  return nr;</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2493">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2494">// use.</a>
<a name="ln2495">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2496">// NULL and there is no undo info.</a>
<a name="ln2497">buf_T *open_spellbuf(void)</a>
<a name="ln2498">{</a>
<a name="ln2499">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2500"> </a>
<a name="ln2501">  buf-&gt;b_spell = true;</a>
<a name="ln2502">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2503">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2504">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2505">  }</a>
<a name="ln2506">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2507"> </a>
<a name="ln2508">  return buf;</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511">// Close the buffer used for spell info.</a>
<a name="ln2512">void close_spellbuf(buf_T *buf)</a>
<a name="ln2513">{</a>
<a name="ln2514">  if (buf != NULL) {</a>
<a name="ln2515">    ml_close(buf, TRUE);</a>
<a name="ln2516">    xfree(buf);</a>
<a name="ln2517">  }</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2521">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2522">{</a>
<a name="ln2523">  int i;</a>
<a name="ln2524"> </a>
<a name="ln2525">  // Init everything to false.</a>
<a name="ln2526">  memset(sp-&gt;st_isw, false, sizeof(sp-&gt;st_isw));</a>
<a name="ln2527">  memset(sp-&gt;st_isu, false, sizeof(sp-&gt;st_isu));</a>
<a name="ln2528"> </a>
<a name="ln2529">  for (i = 0; i &lt; 256; ++i) {</a>
<a name="ln2530">    sp-&gt;st_fold[i] = i;</a>
<a name="ln2531">    sp-&gt;st_upper[i] = i;</a>
<a name="ln2532">  }</a>
<a name="ln2533"> </a>
<a name="ln2534">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2535">  // that is done separately.</a>
<a name="ln2536">  for (i = '0'; i &lt;= '9'; ++i)</a>
<a name="ln2537">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2538">  for (i = 'A'; i &lt;= 'Z'; ++i) {</a>
<a name="ln2539">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2540">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2541">    sp-&gt;st_fold[i] = i + 0x20;</a>
<a name="ln2542">  }</a>
<a name="ln2543">  for (i = 'a'; i &lt;= 'z'; ++i) {</a>
<a name="ln2544">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2545">    sp-&gt;st_upper[i] = i - 0x20;</a>
<a name="ln2546">  }</a>
<a name="ln2547">}</a>
<a name="ln2548"> </a>
<a name="ln2549">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2550">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2551">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2552">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2553">void init_spell_chartab(void)</a>
<a name="ln2554">{</a>
<a name="ln2555">  int i;</a>
<a name="ln2556"> </a>
<a name="ln2557">  did_set_spelltab = false;</a>
<a name="ln2558">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2559">  for (i = 128; i &lt; 256; i++) {</a>
<a name="ln2560">    int f = utf_fold(i);</a>
<a name="ln2561">    int u = mb_toupper(i);</a>
<a name="ln2562"> </a>
<a name="ln2563">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2564">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2565">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2566">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2567">    // value for utf-8 to avoid this.</a>
<a name="ln2568">    spelltab.st_fold[i] = (f &lt; 256) ? f : i;</a>
<a name="ln2569">    spelltab.st_upper[i] = (u &lt; 256) ? u : i;</a>
<a name="ln2570">  }</a>
<a name="ln2571">}</a>
<a name="ln2572"> </a>
<a name="ln2573">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2574">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2575">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2576">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2577">///</a>
<a name="ln2578">/// @param wp Buffer used.</a>
<a name="ln2579">static bool spell_iswordp(const char_u *p, const win_T *wp)</a>
<a name="ln2580">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2581">{</a>
<a name="ln2582">  int c;</a>
<a name="ln2583"> </a>
<a name="ln2584">  const int l = utfc_ptr2len(p);</a>
<a name="ln2585">  const char_u *s = p;</a>
<a name="ln2586">  if (l == 1) {</a>
<a name="ln2587">    // be quick for ASCII</a>
<a name="ln2588">    if (wp-&gt;w_s-&gt;b_spell_ismw[*p]) {</a>
<a name="ln2589">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2590">    }</a>
<a name="ln2591">  } else {</a>
<a name="ln2592">    c = utf_ptr2char(p);</a>
<a name="ln2593">    if (c &lt; 256</a>
<a name="ln2594">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2595">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2596">           &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2597">      s = p + l;</a>
<a name="ln2598">    }</a>
<a name="ln2599">  }</a>
<a name="ln2600"> </a>
<a name="ln2601">  c = utf_ptr2char(s);</a>
<a name="ln2602">  if (c &gt; 255) {</a>
<a name="ln2603">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2604">  }</a>
<a name="ln2605">  return spelltab.st_isw[c];</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2609">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2610">bool spell_iswordp_nmw(const char_u *p, win_T *wp)</a>
<a name="ln2611">{</a>
<a name="ln2612">  int c = utf_ptr2char(p);</a>
<a name="ln2613">  if (c &gt; 255) {</a>
<a name="ln2614">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2615">  }</a>
<a name="ln2616">  return spelltab.st_isw[c];</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">// Returns true if word class indicates a word character.</a>
<a name="ln2620">// Only for characters above 255.</a>
<a name="ln2621">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2622">// See also utf_class() in mbyte.c.</a>
<a name="ln2623">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2624">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2625">{</a>
<a name="ln2626">  if (wp-&gt;w_s-&gt;b_cjk)</a>
<a name="ln2627">    // East Asian characters are not considered word characters.</a>
<a name="ln2628">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2629">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2633">// Wide version of spell_iswordp().</a>
<a name="ln2634">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2635">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2636">{</a>
<a name="ln2637">  const int *s;</a>
<a name="ln2638"> </a>
<a name="ln2639">  if (*p &lt; 256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p]</a>
<a name="ln2640">      : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2641">         &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, *p) != NULL))</a>
<a name="ln2642">    s = p + 1;</a>
<a name="ln2643">  else</a>
<a name="ln2644">    s = p;</a>
<a name="ln2645"> </a>
<a name="ln2646">  if (*s &gt; 255) {</a>
<a name="ln2647">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2648">  }</a>
<a name="ln2649">  return spelltab.st_isw[*s];</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2653">// Uses the character definitions from the .spl file.</a>
<a name="ln2654">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2655">// Returns FAIL when something wrong.</a>
<a name="ln2656">int spell_casefold(char_u *str, int len, char_u *buf, int buflen)</a>
<a name="ln2657">{</a>
<a name="ln2658">  if (len &gt;= buflen) {</a>
<a name="ln2659">    buf[0] = NUL;</a>
<a name="ln2660">    return FAIL;                // result will not fit</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  int outi = 0;</a>
<a name="ln2664"> </a>
<a name="ln2665">  // Fold one character at a time.</a>
<a name="ln2666">  for (char_u *p = str; p &lt; str + len; ) {</a>
<a name="ln2667">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2668">      buf[outi] = NUL;</a>
<a name="ln2669">      return FAIL;</a>
<a name="ln2670">    }</a>
<a name="ln2671">    const int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2672">    outi += utf_char2bytes(SPELL_TOFOLD(c), buf + outi);</a>
<a name="ln2673">  }</a>
<a name="ln2674">  buf[outi] = NUL;</a>
<a name="ln2675"> </a>
<a name="ln2676">  return OK;</a>
<a name="ln2677">}</a>
<a name="ln2678"> </a>
<a name="ln2679">// values for sps_flags</a>
<a name="ln2680">#define SPS_BEST    1</a>
<a name="ln2681">#define SPS_FAST    2</a>
<a name="ln2682">#define SPS_DOUBLE  4</a>
<a name="ln2683"> </a>
<a name="ln2684">static int sps_flags = SPS_BEST;        // flags from 'spellsuggest'</a>
<a name="ln2685">static int sps_limit = 9999;            // max nr of suggestions given</a>
<a name="ln2686"> </a>
<a name="ln2687">// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln2688">// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln2689">int spell_check_sps(void)</a>
<a name="ln2690">{</a>
<a name="ln2691">  char_u      *p;</a>
<a name="ln2692">  char_u      *s;</a>
<a name="ln2693">  char_u buf[MAXPATHL];</a>
<a name="ln2694">  int f;</a>
<a name="ln2695"> </a>
<a name="ln2696">  sps_flags = 0;</a>
<a name="ln2697">  sps_limit = 9999;</a>
<a name="ln2698"> </a>
<a name="ln2699">  for (p = p_sps; *p != NUL; ) {</a>
<a name="ln2700">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2701"> </a>
<a name="ln2702">    f = 0;</a>
<a name="ln2703">    if (ascii_isdigit(*buf)) {</a>
<a name="ln2704">      s = buf;</a>
<a name="ln2705">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2706">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln2707">        f = -1;</a>
<a name="ln2708">      }</a>
<a name="ln2709">    } else if (STRCMP(buf, &quot;best&quot;) == 0) {</a>
<a name="ln2710">      f = SPS_BEST;</a>
<a name="ln2711">    } else if (STRCMP(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln2712">      f = SPS_FAST;</a>
<a name="ln2713">    } else if (STRCMP(buf, &quot;double&quot;) == 0) {</a>
<a name="ln2714">      f = SPS_DOUBLE;</a>
<a name="ln2715">    } else if (STRNCMP(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln2716">               &amp;&amp; STRNCMP(buf, &quot;file:&quot;, 5) != 0) {</a>
<a name="ln2717">      f = -1;</a>
<a name="ln2718">    }</a>
<a name="ln2719"> </a>
<a name="ln2720">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln2721">      sps_flags = SPS_BEST;</a>
<a name="ln2722">      sps_limit = 9999;</a>
<a name="ln2723">      return FAIL;</a>
<a name="ln2724">    }</a>
<a name="ln2725">    if (f != 0)</a>
<a name="ln2726">      sps_flags = f;</a>
<a name="ln2727">  }</a>
<a name="ln2728"> </a>
<a name="ln2729">  if (sps_flags == 0)</a>
<a name="ln2730">    sps_flags = SPS_BEST;</a>
<a name="ln2731"> </a>
<a name="ln2732">  return OK;</a>
<a name="ln2733">}</a>
<a name="ln2734"> </a>
<a name="ln2735">// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln2736">// Give suggestions for the properly spelled word.</a>
<a name="ln2737">// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln2738">// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln2739">void spell_suggest(int count)</a>
<a name="ln2740">{</a>
<a name="ln2741">  char_u      *line;</a>
<a name="ln2742">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2743">  char_u wcopy[MAXWLEN + 2];</a>
<a name="ln2744">  char_u      *p;</a>
<a name="ln2745">  int c;</a>
<a name="ln2746">  suginfo_T sug;</a>
<a name="ln2747">  suggest_T   *stp;</a>
<a name="ln2748">  int mouse_used;</a>
<a name="ln2749">  int need_cap;</a>
<a name="ln2750">  int limit;</a>
<a name="ln2751">  int selected = count;</a>
<a name="ln2752">  int badlen = 0;</a>
<a name="ln2753">  int msg_scroll_save = msg_scroll;</a>
<a name="ln2754"> </a>
<a name="ln2755">  if (no_spell_checking(curwin))</a>
<a name="ln2756">    return;</a>
<a name="ln2757"> </a>
<a name="ln2758">  if (VIsual_active) {</a>
<a name="ln2759">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln2760">    // a multi-line selection.</a>
<a name="ln2761">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln2762">      vim_beep(BO_SPELL);</a>
<a name="ln2763">      return;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln2766">    if (badlen &lt; 0) {</a>
<a name="ln2767">      badlen = -badlen;</a>
<a name="ln2768">    } else {</a>
<a name="ln2769">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln2770">    }</a>
<a name="ln2771">    badlen++;</a>
<a name="ln2772">    end_visual_mode();</a>
<a name="ln2773">  } else</a>
<a name="ln2774">  // Find the start of the badly spelled word.</a>
<a name="ln2775">  if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln2776">      || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln2777">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln2778">    // cursor.</a>
<a name="ln2779">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2780">    line = get_cursor_line_ptr();</a>
<a name="ln2781">    p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln2782">    // Backup to before start of word.</a>
<a name="ln2783">    while (p &gt; line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2784">      MB_PTR_BACK(line, p);</a>
<a name="ln2785">    }</a>
<a name="ln2786">    // Forward to start of word.</a>
<a name="ln2787">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2788">      MB_PTR_ADV(p);</a>
<a name="ln2789">    }</a>
<a name="ln2790"> </a>
<a name="ln2791">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln2792">      beep_flush();</a>
<a name="ln2793">      return;</a>
<a name="ln2794">    }</a>
<a name="ln2795">    curwin-&gt;w_cursor.col = (colnr_T)(p - line);</a>
<a name="ln2796">  }</a>
<a name="ln2797"> </a>
<a name="ln2798">  // Get the word and its length.</a>
<a name="ln2799"> </a>
<a name="ln2800">  // Figure out if the word should be capitalised.</a>
<a name="ln2801">  need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln2802"> </a>
<a name="ln2803">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln2804">  line = vim_strsave(get_cursor_line_ptr());</a>
<a name="ln2805"> </a>
<a name="ln2806">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln2807">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln2808">  if (sps_limit &gt; (int)Rows - 2)</a>
<a name="ln2809">    limit = (int)Rows - 2;</a>
<a name="ln2810">  else</a>
<a name="ln2811">    limit = sps_limit;</a>
<a name="ln2812">  spell_find_suggest(line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln2813">      true, need_cap, true);</a>
<a name="ln2814"> </a>
<a name="ln2815">  if (GA_EMPTY(&amp;sug.su_ga))</a>
<a name="ln2816">    MSG(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln2817">  else if (count &gt; 0) {</a>
<a name="ln2818">    if (count &gt; sug.su_ga.ga_len)</a>
<a name="ln2819">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln2820">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln2821">  } else {</a>
<a name="ln2822">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln2823">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln2824">    if (cmdmsg_rl)</a>
<a name="ln2825">      msg_col = Columns - 1;</a>
<a name="ln2826"> </a>
<a name="ln2827">    // List the suggestions.</a>
<a name="ln2828">    msg_start();</a>
<a name="ln2829">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln2830">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln2831">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln2832">        sug.su_badlen, sug.su_badptr);</a>
<a name="ln2833">    if (cmdmsg_rl &amp;&amp; STRNCMP(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln2834">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln2835">      // untranslated message rightleft.</a>
<a name="ln2836">      vim_snprintf((char *)IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln2837">          sug.su_badlen, sug.su_badptr);</a>
<a name="ln2838">    }</a>
<a name="ln2839">    msg_puts((const char *)IObuff);</a>
<a name="ln2840">    msg_clr_eos();</a>
<a name="ln2841">    msg_putchar('\n');</a>
<a name="ln2842"> </a>
<a name="ln2843">    msg_scroll = TRUE;</a>
<a name="ln2844">    for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln2845">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln2846"> </a>
<a name="ln2847">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln2848">      // the not replaced part.</a>
<a name="ln2849">      STRLCPY(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln2850">      if (sug.su_badlen &gt; stp-&gt;st_orglen)</a>
<a name="ln2851">        STRLCPY(wcopy + stp-&gt;st_wordlen,</a>
<a name="ln2852">            sug.su_badptr + stp-&gt;st_orglen,</a>
<a name="ln2853">            sug.su_badlen - stp-&gt;st_orglen + 1);</a>
<a name="ln2854">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln2855">      if (cmdmsg_rl) {</a>
<a name="ln2856">        rl_mirror(IObuff);</a>
<a name="ln2857">      }</a>
<a name="ln2858">      msg_puts((const char *)IObuff);</a>
<a name="ln2859"> </a>
<a name="ln2860">      vim_snprintf((char *)IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln2861">      msg_puts((const char *)IObuff);</a>
<a name="ln2862"> </a>
<a name="ln2863">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln2864">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln2865">        vim_snprintf((char *)IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln2866">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln2867">        msg_puts((const char *)IObuff);</a>
<a name="ln2868">      }</a>
<a name="ln2869"> </a>
<a name="ln2870">      if (p_verbose &gt; 0) {</a>
<a name="ln2871">        // Add the score.</a>
<a name="ln2872">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST))</a>
<a name="ln2873">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln2874">              stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln2875">              stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln2876">        else</a>
<a name="ln2877">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln2878">              stp-&gt;st_score);</a>
<a name="ln2879">        if (cmdmsg_rl)</a>
<a name="ln2880">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln2881">          rl_mirror(IObuff + 1);</a>
<a name="ln2882">        msg_advance(30);</a>
<a name="ln2883">        msg_puts((const char *)IObuff);</a>
<a name="ln2884">      }</a>
<a name="ln2885">      msg_putchar('\n');</a>
<a name="ln2886">    }</a>
<a name="ln2887"> </a>
<a name="ln2888">    cmdmsg_rl = FALSE;</a>
<a name="ln2889">    msg_col = 0;</a>
<a name="ln2890">    // Ask for choice.</a>
<a name="ln2891">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln2892">    if (mouse_used)</a>
<a name="ln2893">      selected -= lines_left;</a>
<a name="ln2894">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln2895">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln2896">    msg_scroll = msg_scroll_save;</a>
<a name="ln2897">  }</a>
<a name="ln2898"> </a>
<a name="ln2899">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln2900">    // Save the from and to text for :spellrepall.</a>
<a name="ln2901">    XFREE_CLEAR(repl_from);</a>
<a name="ln2902">    XFREE_CLEAR(repl_to);</a>
<a name="ln2903"> </a>
<a name="ln2904">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln2905">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln2906">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln2907">      // repl_to.</a>
<a name="ln2908">      repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);</a>
<a name="ln2909">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln2910">          sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln2911">          sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2912">      repl_to = vim_strsave(IObuff);</a>
<a name="ln2913">    } else {</a>
<a name="ln2914">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln2915">      repl_from = vim_strnsave(sug.su_badptr, stp-&gt;st_orglen);</a>
<a name="ln2916">      repl_to = vim_strsave(stp-&gt;st_word);</a>
<a name="ln2917">    }</a>
<a name="ln2918"> </a>
<a name="ln2919">    // Replace the word.</a>
<a name="ln2920">    p = xmalloc(STRLEN(line) - stp-&gt;st_orglen + stp-&gt;st_wordlen + 1);</a>
<a name="ln2921">    c = (int)(sug.su_badptr - line);</a>
<a name="ln2922">    memmove(p, line, c);</a>
<a name="ln2923">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln2924">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2925"> </a>
<a name="ln2926">    // For redo we use a change-word command.</a>
<a name="ln2927">    ResetRedobuff();</a>
<a name="ln2928">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln2929">    AppendToRedobuffLit(p + c,</a>
<a name="ln2930">        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln2931">    AppendCharToRedobuff(ESC);</a>
<a name="ln2932"> </a>
<a name="ln2933">    // &quot;p&quot; may be freed here</a>
<a name="ln2934">    ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln2935">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln2936"> </a>
<a name="ln2937">    changed_bytes(curwin-&gt;w_cursor.lnum, c);</a>
<a name="ln2938">  } else</a>
<a name="ln2939">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2940"> </a>
<a name="ln2941">  spell_find_cleanup(&amp;sug);</a>
<a name="ln2942">  xfree(line);</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln2946">// capital.  This uses 'spellcapcheck' of the current buffer.</a>
<a name="ln2947">static bool check_need_cap(linenr_T lnum, colnr_T col)</a>
<a name="ln2948">{</a>
<a name="ln2949">  bool need_cap = false;</a>
<a name="ln2950">  char_u      *line;</a>
<a name="ln2951">  char_u      *line_copy = NULL;</a>
<a name="ln2952">  char_u      *p;</a>
<a name="ln2953">  colnr_T endcol;</a>
<a name="ln2954">  regmatch_T regmatch;</a>
<a name="ln2955"> </a>
<a name="ln2956">  if (curwin-&gt;w_s-&gt;b_cap_prog == NULL)</a>
<a name="ln2957">    return false;</a>
<a name="ln2958"> </a>
<a name="ln2959">  line = get_cursor_line_ptr();</a>
<a name="ln2960">  endcol = 0;</a>
<a name="ln2961">  if (getwhitecols(line) &gt;= (int)col) {</a>
<a name="ln2962">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln2963">    // ends there.</a>
<a name="ln2964">    if (lnum == 1)</a>
<a name="ln2965">      need_cap = true;</a>
<a name="ln2966">    else {</a>
<a name="ln2967">      line = ml_get(lnum - 1);</a>
<a name="ln2968">      if (*skipwhite(line) == NUL)</a>
<a name="ln2969">        need_cap = true;</a>
<a name="ln2970">      else {</a>
<a name="ln2971">        // Append a space in place of the line break.</a>
<a name="ln2972">        line_copy = concat_str(line, (char_u *)&quot; &quot;);</a>
<a name="ln2973">        line = line_copy;</a>
<a name="ln2974">        endcol = (colnr_T)STRLEN(line);</a>
<a name="ln2975">      }</a>
<a name="ln2976">    }</a>
<a name="ln2977">  } else {</a>
<a name="ln2978">    endcol = col;</a>
<a name="ln2979">  }</a>
<a name="ln2980"> </a>
<a name="ln2981">  if (endcol &gt; 0) {</a>
<a name="ln2982">    // Check if sentence ends before the bad word.</a>
<a name="ln2983">    regmatch.regprog = curwin-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln2984">    regmatch.rm_ic = FALSE;</a>
<a name="ln2985">    p = line + endcol;</a>
<a name="ln2986">    for (;; ) {</a>
<a name="ln2987">      MB_PTR_BACK(line, p);</a>
<a name="ln2988">      if (p == line || spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2989">        break;</a>
<a name="ln2990">      }</a>
<a name="ln2991">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln2992">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln2993">        need_cap = true;</a>
<a name="ln2994">        break;</a>
<a name="ln2995">      }</a>
<a name="ln2996">    }</a>
<a name="ln2997">    curwin-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln2998">  }</a>
<a name="ln2999"> </a>
<a name="ln3000">  xfree(line_copy);</a>
<a name="ln3001"> </a>
<a name="ln3002">  return need_cap;</a>
<a name="ln3003">}</a>
<a name="ln3004"> </a>
<a name="ln3005"> </a>
<a name="ln3006">// &quot;:spellrepall&quot;</a>
<a name="ln3007">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln3008">{</a>
<a name="ln3009">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3010">  char_u      *frompat;</a>
<a name="ln3011">  int addlen;</a>
<a name="ln3012">  char_u      *line;</a>
<a name="ln3013">  char_u      *p;</a>
<a name="ln3014">  bool save_ws = p_ws;</a>
<a name="ln3015">  linenr_T prev_lnum = 0;</a>
<a name="ln3016"> </a>
<a name="ln3017">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln3018">    EMSG(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln3019">    return;</a>
<a name="ln3020">  }</a>
<a name="ln3021">  addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));</a>
<a name="ln3022"> </a>
<a name="ln3023">  frompat = xmalloc(STRLEN(repl_from) + 7);</a>
<a name="ln3024">  sprintf((char *)frompat, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln3025">  p_ws = false;</a>
<a name="ln3026"> </a>
<a name="ln3027">  sub_nsubs = 0;</a>
<a name="ln3028">  sub_nlines = 0;</a>
<a name="ln3029">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln3030">  while (!got_int) {</a>
<a name="ln3031">    if (do_search(NULL, '/', frompat, 1L, SEARCH_KEEP, NULL) == 0</a>
<a name="ln3032">        || u_save_cursor() == FAIL) {</a>
<a name="ln3033">      break;</a>
<a name="ln3034">    }</a>
<a name="ln3035"> </a>
<a name="ln3036">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln3037">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln3038">    line = get_cursor_line_ptr();</a>
<a name="ln3039">    if (addlen &lt;= 0 || STRNCMP(line + curwin-&gt;w_cursor.col,</a>
<a name="ln3040">            repl_to, STRLEN(repl_to)) != 0) {</a>
<a name="ln3041">      p = xmalloc(STRLEN(line) + addlen + 1);</a>
<a name="ln3042">      memmove(p, line, curwin-&gt;w_cursor.col);</a>
<a name="ln3043">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln3044">      STRCAT(p, line + curwin-&gt;w_cursor.col + STRLEN(repl_from));</a>
<a name="ln3045">      ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln3046">      changed_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln3047"> </a>
<a name="ln3048">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln3049">        ++sub_nlines;</a>
<a name="ln3050">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3051">      }</a>
<a name="ln3052">      ++sub_nsubs;</a>
<a name="ln3053">    }</a>
<a name="ln3054">    curwin-&gt;w_cursor.col += (colnr_T)STRLEN(repl_to);</a>
<a name="ln3055">  }</a>
<a name="ln3056"> </a>
<a name="ln3057">  p_ws = save_ws;</a>
<a name="ln3058">  curwin-&gt;w_cursor = pos;</a>
<a name="ln3059">  xfree(frompat);</a>
<a name="ln3060"> </a>
<a name="ln3061">  if (sub_nsubs == 0)</a>
<a name="ln3062">    EMSG2(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln3063">  else</a>
<a name="ln3064">    do_sub_msg(false);</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067">// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln3068">// a list of allocated strings.</a>
<a name="ln3069">void</a>
<a name="ln3070">spell_suggest_list (</a>
<a name="ln3071">    garray_T *gap,</a>
<a name="ln3072">    char_u *word,</a>
<a name="ln3073">    int maxcount,                   // maximum nr of suggestions</a>
<a name="ln3074">    bool need_cap,                  // 'spellcapcheck' matched</a>
<a name="ln3075">    bool interactive</a>
<a name="ln3076">)</a>
<a name="ln3077">{</a>
<a name="ln3078">  suginfo_T sug;</a>
<a name="ln3079">  suggest_T   *stp;</a>
<a name="ln3080">  char_u      *wcopy;</a>
<a name="ln3081"> </a>
<a name="ln3082">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln3083"> </a>
<a name="ln3084">  // Make room in &quot;gap&quot;.</a>
<a name="ln3085">  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);</a>
<a name="ln3086">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln3087">  for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln3088">    stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln3089"> </a>
<a name="ln3090">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln3091">    // replaced part.</a>
<a name="ln3092">    wcopy = xmalloc(stp-&gt;st_wordlen</a>
<a name="ln3093">                    + STRLEN(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln3094">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln3095">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3096">    ((char_u **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln3097">  }</a>
<a name="ln3098"> </a>
<a name="ln3099">  spell_find_cleanup(&amp;sug);</a>
<a name="ln3100">}</a>
<a name="ln3101"> </a>
<a name="ln3102">// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln3103">// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln3104">// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln3105">// Note: does use info for the current window.</a>
<a name="ln3106">// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln3107">static void</a>
<a name="ln3108">spell_find_suggest (</a>
<a name="ln3109">    char_u *badptr,</a>
<a name="ln3110">    int badlen,                     // length of bad word or 0 if unknown</a>
<a name="ln3111">    suginfo_T *su,</a>
<a name="ln3112">    int maxcount,</a>
<a name="ln3113">    bool banbadword,                 // don't include badword in suggestions</a>
<a name="ln3114">    bool need_cap,                  // word should start with capital</a>
<a name="ln3115">    bool interactive</a>
<a name="ln3116">)</a>
<a name="ln3117">{</a>
<a name="ln3118">  hlf_T attr = HLF_COUNT;</a>
<a name="ln3119">  char_u buf[MAXPATHL];</a>
<a name="ln3120">  char_u      *p;</a>
<a name="ln3121">  bool do_combine = false;</a>
<a name="ln3122">  char_u      *sps_copy;</a>
<a name="ln3123">  static bool expr_busy = false;</a>
<a name="ln3124">  int c;</a>
<a name="ln3125">  langp_T     *lp;</a>
<a name="ln3126"> </a>
<a name="ln3127">  // Set the info in &quot;*su&quot;.</a>
<a name="ln3128">  memset(su, 0, sizeof(suginfo_T));</a>
<a name="ln3129">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3130">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3131">  if (*badptr == NUL)</a>
<a name="ln3132">    return;</a>
<a name="ln3133">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln3134"> </a>
<a name="ln3135">  su-&gt;su_badptr = badptr;</a>
<a name="ln3136">  if (badlen != 0)</a>
<a name="ln3137">    su-&gt;su_badlen = badlen;</a>
<a name="ln3138">  else {</a>
<a name="ln3139">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln3140">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln3141">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln3142">  }</a>
<a name="ln3143">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln3144">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln3145"> </a>
<a name="ln3146">  if (su-&gt;su_badlen &gt;= MAXWLEN)</a>
<a name="ln3147">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln3148">  STRLCPY(su-&gt;su_badword, su-&gt;su_badptr, su-&gt;su_badlen + 1);</a>
<a name="ln3149">  (void)spell_casefold(su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword, MAXWLEN);</a>
<a name="ln3150"> </a>
<a name="ln3151">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln3152">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln3153">  // computations.</a>
<a name="ln3154">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln3155"> </a>
<a name="ln3156">  // get caps flags for bad word</a>
<a name="ln3157">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln3158">      su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3159">  if (need_cap)</a>
<a name="ln3160">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln3161"> </a>
<a name="ln3162">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln3163">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln3164">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln3165">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln3166">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; ++i) {</a>
<a name="ln3167">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln3168">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln3169">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln3170">      break;</a>
<a name="ln3171">    }</a>
<a name="ln3172">  }</a>
<a name="ln3173"> </a>
<a name="ln3174">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln3175">  // have to do this many times.</a>
<a name="ln3176">  if (su-&gt;su_sallang != NULL)</a>
<a name="ln3177">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln3178">        su-&gt;su_sal_badword);</a>
<a name="ln3179"> </a>
<a name="ln3180">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln3181">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln3182">  // for that.</a>
<a name="ln3183">  c = PTR2CHAR(su-&gt;su_badptr);</a>
<a name="ln3184">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln3185">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln3186">    add_suggestion(su, &amp;su-&gt;su_ga, buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln3187">        0, true, su-&gt;su_sallang, false);</a>
<a name="ln3188">  }</a>
<a name="ln3189"> </a>
<a name="ln3190">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln3191">  if (banbadword)</a>
<a name="ln3192">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln3193"> </a>
<a name="ln3194">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln3195">  sps_copy = vim_strsave(p_sps);</a>
<a name="ln3196"> </a>
<a name="ln3197">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln3198">  for (p = sps_copy; *p != NUL; ) {</a>
<a name="ln3199">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln3200"> </a>
<a name="ln3201">    if (STRNCMP(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln3202">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln3203">      // when using spellsuggest() in the expression.</a>
<a name="ln3204">      if (!expr_busy) {</a>
<a name="ln3205">        expr_busy = true;</a>
<a name="ln3206">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln3207">        expr_busy = false;</a>
<a name="ln3208">      }</a>
<a name="ln3209">    } else if (STRNCMP(buf, &quot;file:&quot;, 5) == 0)</a>
<a name="ln3210">      // Use list of suggestions in a file.</a>
<a name="ln3211">      spell_suggest_file(su, buf + 5);</a>
<a name="ln3212">    else {</a>
<a name="ln3213">      // Use internal method.</a>
<a name="ln3214">      spell_suggest_intern(su, interactive);</a>
<a name="ln3215">      if (sps_flags &amp; SPS_DOUBLE)</a>
<a name="ln3216">        do_combine = true;</a>
<a name="ln3217">    }</a>
<a name="ln3218">  }</a>
<a name="ln3219"> </a>
<a name="ln3220">  xfree(sps_copy);</a>
<a name="ln3221"> </a>
<a name="ln3222">  if (do_combine)</a>
<a name="ln3223">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln3224">    // because sorting changes the order again.</a>
<a name="ln3225">    score_combine(su);</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln3229">static void spell_suggest_expr(suginfo_T *su, char_u *expr)</a>
<a name="ln3230">{</a>
<a name="ln3231">  int score;</a>
<a name="ln3232">  const char *p;</a>
<a name="ln3233"> </a>
<a name="ln3234">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln3235">  // suginfo_T.</a>
<a name="ln3236">  // First evaluate the expression and get the resulting list.</a>
<a name="ln3237">  list_T *const list = eval_spell_expr(su-&gt;su_badword, expr);</a>
<a name="ln3238">  if (list != NULL) {</a>
<a name="ln3239">    // Loop over the items in the list.</a>
<a name="ln3240">    TV_LIST_ITER(list, li, {</a>
<a name="ln3241">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln3242">        // Get the word and the score from the items.</a>
<a name="ln3243">        score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln3244">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3245">          add_suggestion(su, &amp;su-&gt;su_ga, (const char_u *)p, su-&gt;su_badlen,</a>
<a name="ln3246">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3247">        }</a>
<a name="ln3248">      }</a>
<a name="ln3249">    });</a>
<a name="ln3250">    tv_list_unref(list);</a>
<a name="ln3251">  }</a>
<a name="ln3252"> </a>
<a name="ln3253">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3254">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3255">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258">// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln3259">static void spell_suggest_file(suginfo_T *su, char_u *fname)</a>
<a name="ln3260">{</a>
<a name="ln3261">  FILE        *fd;</a>
<a name="ln3262">  char_u line[MAXWLEN * 2];</a>
<a name="ln3263">  char_u      *p;</a>
<a name="ln3264">  int len;</a>
<a name="ln3265">  char_u cword[MAXWLEN];</a>
<a name="ln3266"> </a>
<a name="ln3267">  // Open the file.</a>
<a name="ln3268">  fd = os_fopen((char *)fname, &quot;r&quot;);</a>
<a name="ln3269">  if (fd == NULL) {</a>
<a name="ln3270">    EMSG2(_(e_notopen), fname);</a>
<a name="ln3271">    return;</a>
<a name="ln3272">  }</a>
<a name="ln3273"> </a>
<a name="ln3274">  // Read it line by line.</a>
<a name="ln3275">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln3276">    line_breakcheck();</a>
<a name="ln3277"> </a>
<a name="ln3278">    p = vim_strchr(line, '/');</a>
<a name="ln3279">    if (p == NULL)</a>
<a name="ln3280">      continue;             // No Tab found, just skip the line.</a>
<a name="ln3281">    *p++ = NUL;</a>
<a name="ln3282">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln3283">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln3284">      for (len = 0; p[len] &gt;= ' '; ++len)</a>
<a name="ln3285">        ;</a>
<a name="ln3286">      p[len] = NUL;</a>
<a name="ln3287"> </a>
<a name="ln3288">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln3289">      // of the bad word.</a>
<a name="ln3290">      if (captype(p, NULL) == 0) {</a>
<a name="ln3291">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln3292">        p = cword;</a>
<a name="ln3293">      }</a>
<a name="ln3294"> </a>
<a name="ln3295">      add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln3296">          SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3297">    }</a>
<a name="ln3298">  }</a>
<a name="ln3299"> </a>
<a name="ln3300">  fclose(fd);</a>
<a name="ln3301"> </a>
<a name="ln3302">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3303">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3304">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3305">}</a>
<a name="ln3306"> </a>
<a name="ln3307">// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln3308">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln3309">{</a>
<a name="ln3310">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln3311">  suggest_load_files();</a>
<a name="ln3312"> </a>
<a name="ln3313">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln3314">  //</a>
<a name="ln3315">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln3316">  // tried.</a>
<a name="ln3317">  suggest_try_special(su);</a>
<a name="ln3318"> </a>
<a name="ln3319">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln3320">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln3321">  suggest_try_change(su);</a>
<a name="ln3322"> </a>
<a name="ln3323">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln3324">  if (sps_flags &amp; SPS_DOUBLE)</a>
<a name="ln3325">    score_comp_sal(su);</a>
<a name="ln3326"> </a>
<a name="ln3327">  // 3. Try finding sound-a-like words.</a>
<a name="ln3328">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln3329">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3330">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln3331">      // they sounds like.</a>
<a name="ln3332">      rescore_suggestions(su);</a>
<a name="ln3333"> </a>
<a name="ln3334">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln3335">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln3336">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln3337">    // cleanup_suggestions().</a>
<a name="ln3338">    // First find words with a small edit distance, because this is much</a>
<a name="ln3339">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln3340">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln3341">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln3342">    suggest_try_soundalike_prep();</a>
<a name="ln3343">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln3344">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln3345">    suggest_try_soundalike(su);</a>
<a name="ln3346">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3347">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln3348">      // changes to the soundfold word.</a>
<a name="ln3349">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln3350">      suggest_try_soundalike(su);</a>
<a name="ln3351">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3352">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln3353">        // more changes to the soundfold word.</a>
<a name="ln3354">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln3355">        suggest_try_soundalike(su);</a>
<a name="ln3356">      }</a>
<a name="ln3357">    }</a>
<a name="ln3358">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln3359">    suggest_try_soundalike_finish();</a>
<a name="ln3360">  }</a>
<a name="ln3361"> </a>
<a name="ln3362">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln3363">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln3364">  os_breakcheck();</a>
<a name="ln3365">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln3366">    (void)vgetc();</a>
<a name="ln3367">    got_int = FALSE;</a>
<a name="ln3368">  }</a>
<a name="ln3369"> </a>
<a name="ln3370">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln3371">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3372">      // Adjust the word score for how it sounds like.</a>
<a name="ln3373">      rescore_suggestions(su);</a>
<a name="ln3374"> </a>
<a name="ln3375">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3376">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3377">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3378">  }</a>
<a name="ln3379">}</a>
<a name="ln3380"> </a>
<a name="ln3381">// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln3382">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln3383">{</a>
<a name="ln3384"># define FREE_SUG_WORD(sug) xfree(sug-&gt;st_word)</a>
<a name="ln3385">  // Free the suggestions.</a>
<a name="ln3386">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3387">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3388"> </a>
<a name="ln3389">  // Free the banned words.</a>
<a name="ln3390">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln3394">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln3395">/// The result is NUL terminated.</a>
<a name="ln3396">///</a>
<a name="ln3397">/// @param[in]  word  source string to copy</a>
<a name="ln3398">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln3399">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln3400">void onecap_copy(char_u *word, char_u *wcopy, bool upper)</a>
<a name="ln3401">{</a>
<a name="ln3402">  char_u *p = word;</a>
<a name="ln3403">  int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln3404">  if (upper) {</a>
<a name="ln3405">    c = SPELL_TOUPPER(c);</a>
<a name="ln3406">  } else {</a>
<a name="ln3407">    c = SPELL_TOFOLD(c);</a>
<a name="ln3408">  }</a>
<a name="ln3409">  int l = utf_char2bytes(c, wcopy);</a>
<a name="ln3410">  STRLCPY(wcopy + l, p, MAXWLEN - l);</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln3414">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln3415">static void allcap_copy(char_u *word, char_u *wcopy)</a>
<a name="ln3416">{</a>
<a name="ln3417">  char_u *d = wcopy;</a>
<a name="ln3418">  for (char_u *s = word; *s != NUL; ) {</a>
<a name="ln3419">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3420"> </a>
<a name="ln3421">    if (c == 0xdf) {</a>
<a name="ln3422">      c = 'S';</a>
<a name="ln3423">      if (d - wcopy &gt;= MAXWLEN - 1)</a>
<a name="ln3424">        break;</a>
<a name="ln3425">      *d++ = c;</a>
<a name="ln3426">    } else</a>
<a name="ln3427">      c = SPELL_TOUPPER(c);</a>
<a name="ln3428"> </a>
<a name="ln3429">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln3430">      break;</a>
<a name="ln3431">    }</a>
<a name="ln3432">    d += utf_char2bytes(c, d);</a>
<a name="ln3433">  }</a>
<a name="ln3434">  *d = NUL;</a>
<a name="ln3435">}</a>
<a name="ln3436"> </a>
<a name="ln3437">// Try finding suggestions by recognizing specific situations.</a>
<a name="ln3438">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln3439">{</a>
<a name="ln3440">  char_u      *p;</a>
<a name="ln3441">  size_t len;</a>
<a name="ln3442">  int c;</a>
<a name="ln3443">  char_u word[MAXWLEN];</a>
<a name="ln3444"> </a>
<a name="ln3445">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln3446">  p = skiptowhite(su-&gt;su_fbadword);</a>
<a name="ln3447">  len = p - su-&gt;su_fbadword;</a>
<a name="ln3448">  p = skipwhite(p);</a>
<a name="ln3449">  if (STRLEN(p) == len &amp;&amp; STRNCMP(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln3450">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln3451">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln3452">    c = su-&gt;su_fbadword[len];</a>
<a name="ln3453">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln3454">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln3455">    su-&gt;su_fbadword[len] = c;</a>
<a name="ln3456"> </a>
<a name="ln3457">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln3458">    // character.</a>
<a name="ln3459">    add_suggestion(su, &amp;su-&gt;su_ga, word, su-&gt;su_badlen,</a>
<a name="ln3460">        RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3461">  }</a>
<a name="ln3462">}</a>
<a name="ln3463"> </a>
<a name="ln3464">// Measure how much time is spent in each state.</a>
<a name="ln3465">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln3466"> </a>
<a name="ln3467">#ifdef SUGGEST_PROFILE</a>
<a name="ln3468">proftime_T current;</a>
<a name="ln3469">proftime_T total;</a>
<a name="ln3470">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln3471">long counts[STATE_FINAL + 1];</a>
<a name="ln3472"> </a>
<a name="ln3473">  static void</a>
<a name="ln3474">prof_init(void)</a>
<a name="ln3475">{</a>
<a name="ln3476">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3477">    profile_zero(&amp;times[i]);</a>
<a name="ln3478">    counts[i] = 0;</a>
<a name="ln3479">  }</a>
<a name="ln3480">  profile_start(&amp;current);</a>
<a name="ln3481">  profile_start(&amp;total);</a>
<a name="ln3482">}</a>
<a name="ln3483"> </a>
<a name="ln3484">// call before changing state</a>
<a name="ln3485">  static void</a>
<a name="ln3486">prof_store(state_T state)</a>
<a name="ln3487">{</a>
<a name="ln3488">  profile_end(&amp;current);</a>
<a name="ln3489">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln3490">  counts[state]++;</a>
<a name="ln3491">  profile_start(&amp;current);</a>
<a name="ln3492">}</a>
<a name="ln3493"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln3494"> </a>
<a name="ln3495">  static void</a>
<a name="ln3496">prof_report(char *name)</a>
<a name="ln3497">{</a>
<a name="ln3498">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln3499"> </a>
<a name="ln3500">  profile_end(&amp;total);</a>
<a name="ln3501">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln3502">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln3503">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3504">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln3505">  }</a>
<a name="ln3506">  fclose(fd);</a>
<a name="ln3507">}</a>
<a name="ln3508">#else</a>
<a name="ln3509"># define PROF_STORE(state)</a>
<a name="ln3510">#endif</a>
<a name="ln3511"> </a>
<a name="ln3512">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3513"> </a>
<a name="ln3514">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln3515">{</a>
<a name="ln3516">  char_u fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln3517">  int n;</a>
<a name="ln3518">  char_u      *p;</a>
<a name="ln3519">  langp_T     *lp;</a>
<a name="ln3520"> </a>
<a name="ln3521">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln3522">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln3523">  // chars after the bad word may help.</a>
<a name="ln3524">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln3525">  n = (int)STRLEN(fword);</a>
<a name="ln3526">  p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln3527">  (void)spell_casefold(p, (int)STRLEN(p), fword + n, MAXWLEN - n);</a>
<a name="ln3528"> </a>
<a name="ln3529">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln3530">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3531"> </a>
<a name="ln3532">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln3533">    // everything has been cleared.</a>
<a name="ln3534">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL)</a>
<a name="ln3535">      continue;</a>
<a name="ln3536"> </a>
<a name="ln3537">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln3538">    //</a>
<a name="ln3539">#ifdef SUGGEST_PROFILE</a>
<a name="ln3540">    prof_init();</a>
<a name="ln3541">#endif</a>
<a name="ln3542">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln3543">#ifdef SUGGEST_PROFILE</a>
<a name="ln3544">    prof_report(&quot;try_change&quot;);</a>
<a name="ln3545">#endif</a>
<a name="ln3546">  }</a>
<a name="ln3547">}</a>
<a name="ln3548"> </a>
<a name="ln3549">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln3550">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln3551">  (stack[depth].ts_score + (add) &lt; su-&gt;su_maxscore)</a>
<a name="ln3552"> </a>
<a name="ln3553">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3554">//</a>
<a name="ln3555">// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln3556">// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln3557">// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln3558">// character, replace one and delete another.  The number of changes is</a>
<a name="ln3559">// limited by su-&gt;su_maxscore.</a>
<a name="ln3560">//</a>
<a name="ln3561">// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln3562">// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln3563">// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln3564">// The implementation in the article is simplified and requires a stack of</a>
<a name="ln3565">// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln3566">// the length of the word.</a>
<a name="ln3567">//</a>
<a name="ln3568">// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln3569">// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln3570">// that comes from one or more original words.  Each of these words may be</a>
<a name="ln3571">// added, this is done by add_sound_suggest().</a>
<a name="ln3572">// Don't use:</a>
<a name="ln3573">//      the prefix tree or the keep-case tree</a>
<a name="ln3574">//      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln3575">//      anything to do with upper and lower case</a>
<a name="ln3576">//      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln3577">//      banned words</a>
<a name="ln3578">//      word flags (rare, region, compounding)</a>
<a name="ln3579">//      word splitting for now</a>
<a name="ln3580">//      &quot;similar_chars()&quot;</a>
<a name="ln3581">//      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln3582">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)</a>
<a name="ln3583">{</a>
<a name="ln3584">  char_u tword[MAXWLEN];            // good word collected so far</a>
<a name="ln3585">  trystate_T stack[MAXWLEN];</a>
<a name="ln3586">  char_u preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln3587">                                    // concatenation of prefix compound</a>
<a name="ln3588">                                    // words and split word.  NUL terminated</a>
<a name="ln3589">                                    // when going deeper but not when coming</a>
<a name="ln3590">                                    // back.</a>
<a name="ln3591">  char_u compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln3592">  trystate_T  *sp;</a>
<a name="ln3593">  int newscore;</a>
<a name="ln3594">  int score;</a>
<a name="ln3595">  char_u      *byts, *fbyts, *pbyts;</a>
<a name="ln3596">  idx_T       *idxs, *fidxs, *pidxs;</a>
<a name="ln3597">  int depth;</a>
<a name="ln3598">  int c, c2, c3;</a>
<a name="ln3599">  int n = 0;</a>
<a name="ln3600">  int flags;</a>
<a name="ln3601">  garray_T    *gap;</a>
<a name="ln3602">  idx_T arridx;</a>
<a name="ln3603">  int len;</a>
<a name="ln3604">  char_u      *p;</a>
<a name="ln3605">  fromto_T    *ftp;</a>
<a name="ln3606">  int fl = 0, tl;</a>
<a name="ln3607">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln3608">  slang_T     *slang = lp-&gt;lp_slang;</a>
<a name="ln3609">  int fword_ends;</a>
<a name="ln3610">  bool goodword_ends;</a>
<a name="ln3611">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3612">  // Stores the name of the change made at each level.</a>
<a name="ln3613">  char_u changename[MAXWLEN][80];</a>
<a name="ln3614">#endif</a>
<a name="ln3615">  int breakcheckcount = 1000;</a>
<a name="ln3616">  bool compound_ok;</a>
<a name="ln3617"> </a>
<a name="ln3618">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln3619">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln3620">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln3621">  // word).</a>
<a name="ln3622">  depth = 0;</a>
<a name="ln3623">  sp = &amp;stack[0];</a>
<a name="ln3624">  memset(sp, 0, sizeof(trystate_T));  // -V512</a>
<a name="ln3625">  sp-&gt;ts_curi = 1;</a>
<a name="ln3626"> </a>
<a name="ln3627">  if (soundfold) {</a>
<a name="ln3628">    // Going through the soundfold tree.</a>
<a name="ln3629">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln3630">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln3631">    pbyts = NULL;</a>
<a name="ln3632">    pidxs = NULL;</a>
<a name="ln3633">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3634">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln3635">  } else {</a>
<a name="ln3636">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln3637">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln3638">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln3639">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln3640">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln3641">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln3642">    if (pbyts != NULL) {</a>
<a name="ln3643">      byts = pbyts;</a>
<a name="ln3644">      idxs = pidxs;</a>
<a name="ln3645">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln3646">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln3647">    } else {</a>
<a name="ln3648">      byts = fbyts;</a>
<a name="ln3649">      idxs = fidxs;</a>
<a name="ln3650">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3651">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln3652">    }</a>
<a name="ln3653">  }</a>
<a name="ln3654"> </a>
<a name="ln3655">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln3656">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln3657">  //   increase &quot;depth&quot;.</a>
<a name="ln3658">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln3659">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln3660">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3661">    sp = &amp;stack[depth];</a>
<a name="ln3662">    switch (sp-&gt;ts_state) {</a>
<a name="ln3663">    case STATE_START:</a>
<a name="ln3664">    case STATE_NOPREFIX:</a>
<a name="ln3665">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln3666">      // tword[] may end here.</a>
<a name="ln3667">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln3668">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln3669">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln3670"> </a>
<a name="ln3671">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln3672">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln3673">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; ++n)</a>
<a name="ln3674">          ;</a>
<a name="ln3675">        sp-&gt;ts_curi += n;</a>
<a name="ln3676"> </a>
<a name="ln3677">        // Always past NUL bytes now.</a>
<a name="ln3678">        n = (int)sp-&gt;ts_state;</a>
<a name="ln3679">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3680">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3681">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3682"> </a>
<a name="ln3683">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln3684">        // following word.</a>
<a name="ln3685">        if (byts[arridx] == 0 || n == (int)STATE_NOPREFIX) {</a>
<a name="ln3686">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln3687">          // Use the caps type until here for the prefix itself.</a>
<a name="ln3688">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln3689">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln3690">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln3691">              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3692">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3693">          sprintf(changename[depth], &quot;prefix&quot;);</a>
<a name="ln3694">#endif</a>
<a name="ln3695">          go_deeper(stack, depth, 0);</a>
<a name="ln3696">          ++depth;</a>
<a name="ln3697">          sp = &amp;stack[depth];</a>
<a name="ln3698">          sp-&gt;ts_prefixdepth = depth - 1;</a>
<a name="ln3699">          byts = fbyts;</a>
<a name="ln3700">          idxs = fidxs;</a>
<a name="ln3701">          sp-&gt;ts_arridx = 0;</a>
<a name="ln3702"> </a>
<a name="ln3703">          // Move the prefix to preword[] with the right case</a>
<a name="ln3704">          // and make find_keepcap_word() works.</a>
<a name="ln3705">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3706">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3707">              preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln3708">          sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln3709">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln3710">        }</a>
<a name="ln3711">        break;</a>
<a name="ln3712">      }</a>
<a name="ln3713"> </a>
<a name="ln3714">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln3715">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln3716">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3717">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3718">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3719">        break;</a>
<a name="ln3720">      }</a>
<a name="ln3721"> </a>
<a name="ln3722">      // End of word in tree.</a>
<a name="ln3723">      ++sp-&gt;ts_curi;                    // eat one NUL byte</a>
<a name="ln3724"> </a>
<a name="ln3725">      flags = (int)idxs[arridx];</a>
<a name="ln3726"> </a>
<a name="ln3727">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln3728">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln3729">        break;</a>
<a name="ln3730"> </a>
<a name="ln3731">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln3732">                    || (soundfold</a>
<a name="ln3733">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln3734">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln3735">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3736"> </a>
<a name="ln3737">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln3738">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln3739">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln3740">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln3741">        // can be used with this word.</a>
<a name="ln3742">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln3743">        // none this must be the first try without a prefix.</a>
<a name="ln3744">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln3745">        len = pbyts[n++];</a>
<a name="ln3746">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; ++c)</a>
<a name="ln3747">          ;</a>
<a name="ln3748">        if (c &gt; 0) {</a>
<a name="ln3749">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln3750">              tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln3751">          if (c == 0)</a>
<a name="ln3752">            break;</a>
<a name="ln3753"> </a>
<a name="ln3754">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln3755">          if (c &amp; WF_RAREPFX)</a>
<a name="ln3756">            flags |= WF_RARE;</a>
<a name="ln3757"> </a>
<a name="ln3758">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln3759">          // we run into the prefix flag first.</a>
<a name="ln3760">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln3761">          // when arriving at a compound flag.</a>
<a name="ln3762">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln3763">        }</a>
<a name="ln3764">      }</a>
<a name="ln3765"> </a>
<a name="ln3766">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln3767">      // appending another compound word below.</a>
<a name="ln3768">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln3769">          &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln3770">        goodword_ends = false;</a>
<a name="ln3771">      else</a>
<a name="ln3772">        goodword_ends = true;</a>
<a name="ln3773"> </a>
<a name="ln3774">      p = NULL;</a>
<a name="ln3775">      compound_ok = true;</a>
<a name="ln3776">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln3777">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln3778">          // There was a word before this word.  When there was no</a>
<a name="ln3779">          // change in this word (it was correct) add the first word</a>
<a name="ln3780">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln3781">          // need to check if a correct word follows.</a>
<a name="ln3782">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln3783">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3784">              &amp;&amp; STRNCMP(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln3785">                  tword + sp-&gt;ts_splitoff,</a>
<a name="ln3786">                  sp-&gt;ts_fidx - sp-&gt;ts_splitfidx) == 0) {</a>
<a name="ln3787">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln3788">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln3789">                preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3790">                sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3791">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln3792">            if (newscore &lt;= su-&gt;su_maxscore)</a>
<a name="ln3793">              add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3794">                  sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln3795">                  newscore, 0, false,</a>
<a name="ln3796">                  lp-&gt;lp_sallang, false);</a>
<a name="ln3797">            break;</a>
<a name="ln3798">          }</a>
<a name="ln3799">        } else {</a>
<a name="ln3800">          // There was a compound word before this word.  If this</a>
<a name="ln3801">          // word does not support compounding then give up</a>
<a name="ln3802">          // (splitting is tried for the word without compound</a>
<a name="ln3803">          // flag).</a>
<a name="ln3804">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln3805">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3806">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3807">            break;</a>
<a name="ln3808">          }</a>
<a name="ln3809">          // For multi-byte chars check character length against</a>
<a name="ln3810">          // COMPOUNDMIN.</a>
<a name="ln3811">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln3812">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln3813">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3814">            break;</a>
<a name="ln3815">          }</a>
<a name="ln3816"> </a>
<a name="ln3817">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3818">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln3819">          STRLCPY(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3820">              tword + sp-&gt;ts_splitoff,</a>
<a name="ln3821">              sp-&gt;ts_twordlen - sp-&gt;ts_splitoff + 1);</a>
<a name="ln3822"> </a>
<a name="ln3823">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln3824">          if (match_checkcompoundpattern(preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln3825">                  &amp;slang-&gt;sl_comppat))</a>
<a name="ln3826">            compound_ok = false;</a>
<a name="ln3827"> </a>
<a name="ln3828">          if (compound_ok) {</a>
<a name="ln3829">            p = preword;</a>
<a name="ln3830">            while (*skiptowhite(p) != NUL)</a>
<a name="ln3831">              p = skipwhite(skiptowhite(p));</a>
<a name="ln3832">            if (fword_ends &amp;&amp; !can_compound(slang, p,</a>
<a name="ln3833">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln3834">              // Compound is not allowed.  But it may still be</a>
<a name="ln3835">              // possible if we add another (short) word.</a>
<a name="ln3836">              compound_ok = false;</a>
<a name="ln3837">          }</a>
<a name="ln3838"> </a>
<a name="ln3839">          // Get pointer to last char of previous word.</a>
<a name="ln3840">          p = preword + sp-&gt;ts_prewordlen;</a>
<a name="ln3841">          MB_PTR_BACK(preword, p);</a>
<a name="ln3842">        }</a>
<a name="ln3843">      }</a>
<a name="ln3844"> </a>
<a name="ln3845">      // Form the word with proper case in preword.</a>
<a name="ln3846">      // If there is a word from a previous split, append.</a>
<a name="ln3847">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln3848">      if (soundfold)</a>
<a name="ln3849">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln3850">      else if (flags &amp; WF_KEEPCAP)</a>
<a name="ln3851">        // Must find the word in the keep-case tree.</a>
<a name="ln3852">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff,</a>
<a name="ln3853">            preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3854">      else {</a>
<a name="ln3855">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln3856">        // use that for the goodword too.  But if the badword is</a>
<a name="ln3857">        // allcap and it's only one char long use onecap.</a>
<a name="ln3858">        c = su-&gt;su_badflags;</a>
<a name="ln3859">        if ((c &amp; WF_ALLCAP)</a>
<a name="ln3860">            &amp;&amp; su-&gt;su_badlen == (*mb_ptr2len)(su-&gt;su_badptr)</a>
<a name="ln3861">            )</a>
<a name="ln3862">          c = WF_ONECAP;</a>
<a name="ln3863">        c |= flags;</a>
<a name="ln3864"> </a>
<a name="ln3865">        // When appending a compound word after a word character don't</a>
<a name="ln3866">        // use Onecap.</a>
<a name="ln3867">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin))</a>
<a name="ln3868">          c &amp;= ~WF_ONECAP;</a>
<a name="ln3869">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3870">            preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln3871">      }</a>
<a name="ln3872"> </a>
<a name="ln3873">      if (!soundfold) {</a>
<a name="ln3874">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln3875">        // word, thus remember it.</a>
<a name="ln3876">        if (flags &amp; WF_BANNED) {</a>
<a name="ln3877">          add_banned(su, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3878">          break;</a>
<a name="ln3879">        }</a>
<a name="ln3880">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln3881">             &amp;&amp; WAS_BANNED(su, preword + sp-&gt;ts_prewordlen))</a>
<a name="ln3882">            || WAS_BANNED(su, preword)) {</a>
<a name="ln3883">          if (slang-&gt;sl_compprog == NULL)</a>
<a name="ln3884">            break;</a>
<a name="ln3885">          // the word so far was banned but we may try compounding</a>
<a name="ln3886">          goodword_ends = false;</a>
<a name="ln3887">        }</a>
<a name="ln3888">      }</a>
<a name="ln3889"> </a>
<a name="ln3890">      newscore = 0;</a>
<a name="ln3891">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln3892">        if ((flags &amp; WF_REGION)</a>
<a name="ln3893">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln3894">          newscore += SCORE_REGION;</a>
<a name="ln3895">        if (flags &amp; WF_RARE)</a>
<a name="ln3896">          newscore += SCORE_RARE;</a>
<a name="ln3897"> </a>
<a name="ln3898">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln3899">                captype(preword + sp-&gt;ts_prewordlen, NULL)))</a>
<a name="ln3900">          newscore += SCORE_ICASE;</a>
<a name="ln3901">      }</a>
<a name="ln3902"> </a>
<a name="ln3903">      // TODO: how about splitting in the soundfold tree?</a>
<a name="ln3904">      if (fword_ends</a>
<a name="ln3905">          &amp;&amp; goodword_ends</a>
<a name="ln3906">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln3907">          &amp;&amp; compound_ok) {</a>
<a name="ln3908">        // The badword also ends: add suggestions.</a>
<a name="ln3909">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3910">        if (soundfold &amp;&amp; STRCMP(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln3911">          int j;</a>
<a name="ln3912"> </a>
<a name="ln3913">          // print the stack of changes that brought us here</a>
<a name="ln3914">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln3915">          for (j = 0; j &lt; depth; ++j)</a>
<a name="ln3916">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln3917">        }</a>
<a name="ln3918">#endif</a>
<a name="ln3919">        if (soundfold) {</a>
<a name="ln3920">          // For soundfolded words we need to find the original</a>
<a name="ln3921">          // words, the edit distance and then add them.</a>
<a name="ln3922">          add_sound_suggest(su, preword, sp-&gt;ts_score, lp);</a>
<a name="ln3923">        } else if (sp-&gt;ts_fidx &gt; 0)   {</a>
<a name="ln3924">          // Give a penalty when changing non-word char to word</a>
<a name="ln3925">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln3926">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln3927">          MB_PTR_BACK(fword, p);</a>
<a name="ln3928">          if (!spell_iswordp(p, curwin)) {</a>
<a name="ln3929">            p = preword + STRLEN(preword);</a>
<a name="ln3930">            MB_PTR_BACK(preword, p);</a>
<a name="ln3931">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln3932">              newscore += SCORE_NONWORD;</a>
<a name="ln3933">            }</a>
<a name="ln3934">          }</a>
<a name="ln3935"> </a>
<a name="ln3936">          // Give a bonus to words seen before.</a>
<a name="ln3937">          score = score_wordcount_adj(slang,</a>
<a name="ln3938">              sp-&gt;ts_score + newscore,</a>
<a name="ln3939">              preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3940">              sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3941"> </a>
<a name="ln3942">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln3943">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3944">            add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3945">                sp-&gt;ts_fidx - repextra,</a>
<a name="ln3946">                score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln3947"> </a>
<a name="ln3948">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln3949">              // We really don't know if the word should be</a>
<a name="ln3950">              // upper or lower case, add both.</a>
<a name="ln3951">              c = captype(preword, NULL);</a>
<a name="ln3952">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln3953">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3954">                    preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3955">                    c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln3956"> </a>
<a name="ln3957">                add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3958">                    sp-&gt;ts_fidx - repextra,</a>
<a name="ln3959">                    score + SCORE_ICASE, 0, false,</a>
<a name="ln3960">                    lp-&gt;lp_sallang, false);</a>
<a name="ln3961">              }</a>
<a name="ln3962">            }</a>
<a name="ln3963">          }</a>
<a name="ln3964">        }</a>
<a name="ln3965">      }</a>
<a name="ln3966"> </a>
<a name="ln3967">      // Try word split and/or compounding.</a>
<a name="ln3968">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln3969">          // Don't split in the middle of a character</a>
<a name="ln3970">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)</a>
<a name="ln3971">          ) {</a>
<a name="ln3972">        bool try_compound;</a>
<a name="ln3973">        int try_split;</a>
<a name="ln3974"> </a>
<a name="ln3975">        // If past the end of the bad word don't try a split.</a>
<a name="ln3976">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln3977">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln3978">        // different.  It's done like a split.</a>
<a name="ln3979">        // TODO: word split for soundfold words</a>
<a name="ln3980">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln3981">                    &amp;&amp; !soundfold;</a>
<a name="ln3982"> </a>
<a name="ln3983">        // Get here in several situations:</a>
<a name="ln3984">        // 1. The word in the tree ends:</a>
<a name="ln3985">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln3986">        //    a split by inserting a space.  For both check that a</a>
<a name="ln3987">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln3988">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln3989">        //    the next word is valid.</a>
<a name="ln3990">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln3991">        //    a swap).  No need to split, but do check that the</a>
<a name="ln3992">        //    following word is valid.</a>
<a name="ln3993">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln3994">        //    be possible to compound another (short) word.</a>
<a name="ln3995">        try_compound = false;</a>
<a name="ln3996">        if (!soundfold</a>
<a name="ln3997">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln3998">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln3999">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln4000">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln4001">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln4002">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln4003">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln4004">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln4005">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln4006">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln4007">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln4008">            &amp;&amp; (can_be_compound(sp, slang,</a>
<a name="ln4009">                    compflags, ((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln4010">          try_compound = true;</a>
<a name="ln4011">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln4012">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln4013">        }</a>
<a name="ln4014"> </a>
<a name="ln4015">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln4016">        // valid.</a>
<a name="ln4017">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln4018">          try_compound = true;</a>
<a name="ln4019">        } else if (!fword_ends</a>
<a name="ln4020">                   &amp;&amp; try_compound</a>
<a name="ln4021">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln4022">          // If we could add a compound word, and it's also possible to</a>
<a name="ln4023">          // split at this point, do the split first and set</a>
<a name="ln4024">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln4025">          try_compound = false;</a>
<a name="ln4026">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln4027">          --sp-&gt;ts_curi;                    // do the same NUL again</a>
<a name="ln4028">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln4029">        } else {</a>
<a name="ln4030">          sp-&gt;ts_flags &amp;= ~TSF_DIDSPLIT;</a>
<a name="ln4031">        }</a>
<a name="ln4032"> </a>
<a name="ln4033">        if (try_split || try_compound) {</a>
<a name="ln4034">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln4035">            // If we're going to split need to check that the</a>
<a name="ln4036">            // words so far are valid for compounding.  If there</a>
<a name="ln4037">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln4038">            // flag.</a>
<a name="ln4039">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln4040">                &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln4041">              break;</a>
<a name="ln4042">            p = preword;</a>
<a name="ln4043">            while (*skiptowhite(p) != NUL)</a>
<a name="ln4044">              p = skipwhite(skiptowhite(p));</a>
<a name="ln4045">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln4046">                &amp;&amp; !can_compound(slang, p,</a>
<a name="ln4047">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln4048">              break;</a>
<a name="ln4049"> </a>
<a name="ln4050">            if (slang-&gt;sl_nosplitsugs)</a>
<a name="ln4051">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln4052">            else</a>
<a name="ln4053">              newscore += SCORE_SPLIT;</a>
<a name="ln4054"> </a>
<a name="ln4055">            // Give a bonus to words seen before.</a>
<a name="ln4056">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln4057">                preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln4058">          }</a>
<a name="ln4059"> </a>
<a name="ln4060">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4061">            go_deeper(stack, depth, newscore);</a>
<a name="ln4062">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4063">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4064">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,</a>
<a name="ln4065">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4066">            else</a>
<a name="ln4067">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,</a>
<a name="ln4068">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4069">#endif</a>
<a name="ln4070">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln4071">            sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln4072">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4073">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln4074"> </a>
<a name="ln4075">            ++depth;</a>
<a name="ln4076">            sp = &amp;stack[depth];</a>
<a name="ln4077"> </a>
<a name="ln4078">            // Append a space to preword when splitting.</a>
<a name="ln4079">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4080">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln4081">            sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln4082">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln4083">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln4084"> </a>
<a name="ln4085">            // If the badword has a non-word character at this</a>
<a name="ln4086">            // position skip it.  That means replacing the</a>
<a name="ln4087">            // non-word character with a space.  Always skip a</a>
<a name="ln4088">            // character when the word ends.  But only when the</a>
<a name="ln4089">            // good word can end.</a>
<a name="ln4090">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln4091">                      + sp-&gt;ts_fidx,</a>
<a name="ln4092">                      curwin))</a>
<a name="ln4093">                 || fword_ends)</a>
<a name="ln4094">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4095">                &amp;&amp; goodword_ends) {</a>
<a name="ln4096">              int l;</a>
<a name="ln4097"> </a>
<a name="ln4098">              l = utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4099">              if (fword_ends) {</a>
<a name="ln4100">                // Copy the skipped character to preword.</a>
<a name="ln4101">                memmove(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4102">                    fword + sp-&gt;ts_fidx, l);</a>
<a name="ln4103">                sp-&gt;ts_prewordlen += l;</a>
<a name="ln4104">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln4105">              } else</a>
<a name="ln4106">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln4107">              sp-&gt;ts_fidx += l;</a>
<a name="ln4108">            }</a>
<a name="ln4109"> </a>
<a name="ln4110">            // When compounding include compound flag in</a>
<a name="ln4111">            // compflags[] (already set above).  When splitting we</a>
<a name="ln4112">            // may start compounding over again.</a>
<a name="ln4113">            if (try_compound)</a>
<a name="ln4114">              ++sp-&gt;ts_complen;</a>
<a name="ln4115">            else</a>
<a name="ln4116">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln4117">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln4118"> </a>
<a name="ln4119">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln4120">            // position</a>
<a name="ln4121">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln4122">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln4123">                su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln4124"> </a>
<a name="ln4125">            // Restart at top of the tree.</a>
<a name="ln4126">            sp-&gt;ts_arridx = 0;</a>
<a name="ln4127"> </a>
<a name="ln4128">            // If there are postponed prefixes, try these too.</a>
<a name="ln4129">            if (pbyts != NULL) {</a>
<a name="ln4130">              byts = pbyts;</a>
<a name="ln4131">              idxs = pidxs;</a>
<a name="ln4132">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln4133">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4134">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln4135">            }</a>
<a name="ln4136">          }</a>
<a name="ln4137">        }</a>
<a name="ln4138">      }</a>
<a name="ln4139">      break;</a>
<a name="ln4140"> </a>
<a name="ln4141">    case STATE_SPLITUNDO:</a>
<a name="ln4142">      // Undo the changes done for word split or compound word.</a>
<a name="ln4143">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4144"> </a>
<a name="ln4145">      // Continue looking for NUL bytes.</a>
<a name="ln4146">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4147">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln4148"> </a>
<a name="ln4149">      // In case we went into the prefix tree.</a>
<a name="ln4150">      byts = fbyts;</a>
<a name="ln4151">      idxs = fidxs;</a>
<a name="ln4152">      break;</a>
<a name="ln4153"> </a>
<a name="ln4154">    case STATE_ENDNUL:</a>
<a name="ln4155">      // Past the NUL bytes in the node.</a>
<a name="ln4156">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4157">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln4158">          &amp;&amp; sp-&gt;ts_tcharlen == 0</a>
<a name="ln4159">          ) {</a>
<a name="ln4160">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln4161">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4162">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4163">        break;</a>
<a name="ln4164">      }</a>
<a name="ln4165">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4166">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln4167">      FALLTHROUGH;</a>
<a name="ln4168"> </a>
<a name="ln4169">    case STATE_PLAIN:</a>
<a name="ln4170">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln4171">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln4172">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln4173">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln4174">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln4175">        // already changed bytes skip the other tricks.</a>
<a name="ln4176">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4177">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln4178">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4179">        } else {</a>
<a name="ln4180">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4181">        }</a>
<a name="ln4182">      } else {</a>
<a name="ln4183">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln4184">        c = byts[arridx];</a>
<a name="ln4185"> </a>
<a name="ln4186">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln4187">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln4188">        // when the byte was already changed.  And don't try when we</a>
<a name="ln4189">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln4190">        // delete + substitute.</a>
<a name="ln4191">        if (c == fword[sp-&gt;ts_fidx]</a>
<a name="ln4192">            || (sp-&gt;ts_tcharlen &gt; 0 &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)</a>
<a name="ln4193">            )</a>
<a name="ln4194">          newscore = 0;</a>
<a name="ln4195">        else</a>
<a name="ln4196">          newscore = SCORE_SUBST;</a>
<a name="ln4197">        if ((newscore == 0</a>
<a name="ln4198">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln4199">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln4200">                     || c != fword[sp-&gt;ts_delidx])))</a>
<a name="ln4201">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4202">          go_deeper(stack, depth, newscore);</a>
<a name="ln4203">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4204">          if (newscore &gt; 0)</a>
<a name="ln4205">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,</a>
<a name="ln4206">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4207">                fword[sp-&gt;ts_fidx], c);</a>
<a name="ln4208">          else</a>
<a name="ln4209">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,</a>
<a name="ln4210">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4211">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln4212">#endif</a>
<a name="ln4213">          ++depth;</a>
<a name="ln4214">          sp = &amp;stack[depth];</a>
<a name="ln4215">          ++sp-&gt;ts_fidx;</a>
<a name="ln4216">          tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4217">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln4218">          if (newscore == SCORE_SUBST) {</a>
<a name="ln4219">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln4220">          }</a>
<a name="ln4221">          // Multi-byte characters are a bit complicated to</a>
<a name="ln4222">          // handle: They differ when any of the bytes differ</a>
<a name="ln4223">          // and then their length may also differ.</a>
<a name="ln4224">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln4225">            // First byte.</a>
<a name="ln4226">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln4227">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln4228">            sp-&gt;ts_fcharstart = sp-&gt;ts_fidx - 1;</a>
<a name="ln4229">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln4230">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln4231">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT) {</a>
<a name="ln4232">            // When inserting trail bytes don't advance in the</a>
<a name="ln4233">            // bad word.</a>
<a name="ln4234">            sp-&gt;ts_fidx--;</a>
<a name="ln4235">          }</a>
<a name="ln4236">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln4237">            // Last byte of character.</a>
<a name="ln4238">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln4239">              // Correct ts_fidx for the byte length of the</a>
<a name="ln4240">              // character (we didn't check that before).</a>
<a name="ln4241">              sp-&gt;ts_fidx = sp-&gt;ts_fcharstart</a>
<a name="ln4242">                            + utfc_ptr2len(fword + sp-&gt;ts_fcharstart);</a>
<a name="ln4243"> </a>
<a name="ln4244">              // For changing a composing character adjust</a>
<a name="ln4245">              // the score from SCORE_SUBST to</a>
<a name="ln4246">              // SCORE_SUBCOMP.</a>
<a name="ln4247">              if (utf_iscomposing(utf_ptr2char(tword + sp-&gt;ts_twordlen</a>
<a name="ln4248">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln4249">                  &amp;&amp; utf_iscomposing(utf_ptr2char(fword</a>
<a name="ln4250">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4251">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln4252">              } else if (</a>
<a name="ln4253">                  !soundfold</a>
<a name="ln4254">                  &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln4255">                  &amp;&amp; similar_chars(</a>
<a name="ln4256">                      slang,</a>
<a name="ln4257">                      utf_ptr2char(tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen),</a>
<a name="ln4258">                      utf_ptr2char(fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4259">                // For a similar character adjust score from</a>
<a name="ln4260">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln4261">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln4262">              }</a>
<a name="ln4263">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln4264">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln4265">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln4266">              c = utf_ptr2char(p);</a>
<a name="ln4267">              if (utf_iscomposing(c)) {</a>
<a name="ln4268">                // Inserting a composing char doesn't</a>
<a name="ln4269">                // count that much.</a>
<a name="ln4270">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln4271">              } else {</a>
<a name="ln4272">                // If the previous character was the same,</a>
<a name="ln4273">                // thus doubling a character, give a bonus</a>
<a name="ln4274">                // to the score.  Also for the soundfold</a>
<a name="ln4275">                // tree (might seem illogical but does</a>
<a name="ln4276">                // give better scores).</a>
<a name="ln4277">                MB_PTR_BACK(tword, p);</a>
<a name="ln4278">                if (c == utf_ptr2char(p)) {</a>
<a name="ln4279">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4280">                }</a>
<a name="ln4281">              }</a>
<a name="ln4282">            }</a>
<a name="ln4283"> </a>
<a name="ln4284">            // Starting a new char, reset the length.</a>
<a name="ln4285">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln4286">          }</a>
<a name="ln4287">        }</a>
<a name="ln4288">      }</a>
<a name="ln4289">      break;</a>
<a name="ln4290"> </a>
<a name="ln4291">    case STATE_DEL:</a>
<a name="ln4292">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln4293">      // delete/insert/swap a character.</a>
<a name="ln4294">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln4295">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4296">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4297">        break;</a>
<a name="ln4298">      }</a>
<a name="ln4299">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln4300">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4301">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln4302">      sp-&gt;ts_curi = 1;</a>
<a name="ln4303">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*')</a>
<a name="ln4304">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln4305">        // soundalike_score().</a>
<a name="ln4306">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln4307">      else</a>
<a name="ln4308">        newscore = SCORE_DEL;</a>
<a name="ln4309">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4310">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4311">        go_deeper(stack, depth, newscore);</a>
<a name="ln4312">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4313">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,</a>
<a name="ln4314">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4315">            fword[sp-&gt;ts_fidx]);</a>
<a name="ln4316">#endif</a>
<a name="ln4317">        ++depth;</a>
<a name="ln4318"> </a>
<a name="ln4319">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln4320">        // inserting it again.</a>
<a name="ln4321">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln4322">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln4323"> </a>
<a name="ln4324">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln4325">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln4326">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln4327">        // results.</a>
<a name="ln4328">        c = utf_ptr2char(fword + sp-&gt;ts_fidx);</a>
<a name="ln4329">        stack[depth].ts_fidx += utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4330">        if (utf_iscomposing(c)) {</a>
<a name="ln4331">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln4332">        } else if (c == utf_ptr2char(fword + stack[depth].ts_fidx)) {</a>
<a name="ln4333">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln4334">        }</a>
<a name="ln4335"> </a>
<a name="ln4336">        break;</a>
<a name="ln4337">      }</a>
<a name="ln4338">      FALLTHROUGH;</a>
<a name="ln4339"> </a>
<a name="ln4340">    case STATE_INS_PREP:</a>
<a name="ln4341">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln4342">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln4343">        // a substitute is always cheaper.</a>
<a name="ln4344">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4345">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4346">        break;</a>
<a name="ln4347">      }</a>
<a name="ln4348"> </a>
<a name="ln4349">      // skip over NUL bytes</a>
<a name="ln4350">      n = sp-&gt;ts_arridx;</a>
<a name="ln4351">      for (;; ) {</a>
<a name="ln4352">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4353">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln4354">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4355">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4356">          break;</a>
<a name="ln4357">        }</a>
<a name="ln4358">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln4359">          // Found a byte to insert.</a>
<a name="ln4360">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4361">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln4362">          break;</a>
<a name="ln4363">        }</a>
<a name="ln4364">        ++sp-&gt;ts_curi;</a>
<a name="ln4365">      }</a>
<a name="ln4366">      break;</a>
<a name="ln4367"> </a>
<a name="ln4368">    case STATE_INS:</a>
<a name="ln4369">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln4370">      // node.</a>
<a name="ln4371">      n = sp-&gt;ts_arridx;</a>
<a name="ln4372">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4373">        // Done all bytes at this node, go to next state.</a>
<a name="ln4374">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4375">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4376">        break;</a>
<a name="ln4377">      }</a>
<a name="ln4378"> </a>
<a name="ln4379">      // Do one more byte at this node, but:</a>
<a name="ln4380">      // - Skip NUL bytes.</a>
<a name="ln4381">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln4382">      //   accepting that byte is always better.</a>
<a name="ln4383">      n += sp-&gt;ts_curi++;</a>
<a name="ln4384">      c = byts[n];</a>
<a name="ln4385">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*')</a>
<a name="ln4386">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln4387">        // see soundalike_score().</a>
<a name="ln4388">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln4389">      else</a>
<a name="ln4390">        newscore = SCORE_INS;</a>
<a name="ln4391">      if (c != fword[sp-&gt;ts_fidx]</a>
<a name="ln4392">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4393">        go_deeper(stack, depth, newscore);</a>
<a name="ln4394">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4395">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,</a>
<a name="ln4396">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4397">            c);</a>
<a name="ln4398">#endif</a>
<a name="ln4399">        ++depth;</a>
<a name="ln4400">        sp = &amp;stack[depth];</a>
<a name="ln4401">        tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4402">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln4403">        fl = MB_BYTE2LEN(c);</a>
<a name="ln4404">        if (fl &gt; 1) {</a>
<a name="ln4405">          // There are following bytes for the same character.</a>
<a name="ln4406">          // We must find all bytes before trying</a>
<a name="ln4407">          // delete/insert/swap/etc.</a>
<a name="ln4408">          sp-&gt;ts_tcharlen = fl;</a>
<a name="ln4409">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln4410">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln4411">        }</a>
<a name="ln4412">        if (fl == 1) {</a>
<a name="ln4413">          // If the previous character was the same, thus doubling a</a>
<a name="ln4414">          // character, give a bonus to the score.  Also for</a>
<a name="ln4415">          // soundfold words (illogical but does give a better</a>
<a name="ln4416">          // score).</a>
<a name="ln4417">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln4418">              &amp;&amp; tword[sp-&gt;ts_twordlen - 2] == c)</a>
<a name="ln4419">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4420">        }</a>
<a name="ln4421">      }</a>
<a name="ln4422">      break;</a>
<a name="ln4423"> </a>
<a name="ln4424">    case STATE_SWAP:</a>
<a name="ln4425">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln4426">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln4427">      // STATE_UNSWAP.</a>
<a name="ln4428">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4429">      c = *p;</a>
<a name="ln4430">      if (c == NUL) {</a>
<a name="ln4431">        // End of word, can't swap or replace.</a>
<a name="ln4432">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4433">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4434">        break;</a>
<a name="ln4435">      }</a>
<a name="ln4436"> </a>
<a name="ln4437">      // Don't swap if the first character is not a word character.</a>
<a name="ln4438">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln4439">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4440">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4441">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4442">        break;</a>
<a name="ln4443">      }</a>
<a name="ln4444"> </a>
<a name="ln4445">      n = MB_CPTR2LEN(p);</a>
<a name="ln4446">      c = utf_ptr2char(p);</a>
<a name="ln4447">      if (p[n] == NUL) {</a>
<a name="ln4448">        c2 = NUL;</a>
<a name="ln4449">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln4450">        c2 = c;  // don't swap non-word char</a>
<a name="ln4451">      } else {</a>
<a name="ln4452">        c2 = utf_ptr2char(p + n);</a>
<a name="ln4453">      }</a>
<a name="ln4454"> </a>
<a name="ln4455">      // When the second character is NUL we can't swap.</a>
<a name="ln4456">      if (c2 == NUL) {</a>
<a name="ln4457">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4458">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4459">        break;</a>
<a name="ln4460">      }</a>
<a name="ln4461"> </a>
<a name="ln4462">      // When characters are identical, swap won't do anything.</a>
<a name="ln4463">      // Also get here if the second char is not a word character.</a>
<a name="ln4464">      if (c == c2) {</a>
<a name="ln4465">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4466">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln4467">        break;</a>
<a name="ln4468">      }</a>
<a name="ln4469">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln4470">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln4471">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4472">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln4473">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln4474">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4475">                 c, c2);</a>
<a name="ln4476">#endif</a>
<a name="ln4477">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4478">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln4479">        depth++;</a>
<a name="ln4480">        fl = mb_char2len(c2);</a>
<a name="ln4481">        memmove(p, p + n, fl);</a>
<a name="ln4482">        utf_char2bytes(c, p + fl);</a>
<a name="ln4483">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4484">      } else {</a>
<a name="ln4485">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln4486">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4487">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4488">      }</a>
<a name="ln4489">      break;</a>
<a name="ln4490"> </a>
<a name="ln4491">    case STATE_UNSWAP:</a>
<a name="ln4492">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln4493">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4494">      n = utfc_ptr2len(p);</a>
<a name="ln4495">      c = utf_ptr2char(p + n);</a>
<a name="ln4496">      memmove(p + utfc_ptr2len(p + n), p, n);</a>
<a name="ln4497">      utf_char2bytes(c, p);</a>
<a name="ln4498"> </a>
<a name="ln4499">      FALLTHROUGH;</a>
<a name="ln4500"> </a>
<a name="ln4501">    case STATE_SWAP3:</a>
<a name="ln4502">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln4503">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln4504">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4505">      n = MB_CPTR2LEN(p);</a>
<a name="ln4506">      c = utf_ptr2char(p);</a>
<a name="ln4507">      fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4508">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4509">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln4510">        c3 = c;  // don't swap non-word char</a>
<a name="ln4511">      } else {</a>
<a name="ln4512">        c3 = utf_ptr2char(p + n + fl);</a>
<a name="ln4513">      }</a>
<a name="ln4514"> </a>
<a name="ln4515">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln4516">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln4517">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln4518">      // Also skip when c3 is NUL.</a>
<a name="ln4519">      // Also get here when the third character is not a word character.</a>
<a name="ln4520">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln4521">      if (c == c3 || c3 == NUL) {</a>
<a name="ln4522">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4523">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4524">        break;</a>
<a name="ln4525">      }</a>
<a name="ln4526">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4527">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4528">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4529">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,</a>
<a name="ln4530">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4531">            c, c3);</a>
<a name="ln4532">#endif</a>
<a name="ln4533">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4534">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln4535">        depth++;</a>
<a name="ln4536">        tl = mb_char2len(c3);</a>
<a name="ln4537">        memmove(p, p + n + fl, tl);</a>
<a name="ln4538">        utf_char2bytes(c2, p + tl);</a>
<a name="ln4539">        utf_char2bytes(c, p + fl + tl);</a>
<a name="ln4540">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl + tl;</a>
<a name="ln4541">      } else {</a>
<a name="ln4542">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4543">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4544">      }</a>
<a name="ln4545">      break;</a>
<a name="ln4546"> </a>
<a name="ln4547">    case STATE_UNSWAP3:</a>
<a name="ln4548">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln4549">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4550">      n = utfc_ptr2len(p);</a>
<a name="ln4551">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4552">      fl = utfc_ptr2len(p + n);</a>
<a name="ln4553">      c = utf_ptr2char(p + n + fl);</a>
<a name="ln4554">      tl = utfc_ptr2len(p + n + fl);</a>
<a name="ln4555">      memmove(p + fl + tl, p, n);</a>
<a name="ln4556">      utf_char2bytes(c, p);</a>
<a name="ln4557">      utf_char2bytes(c2, p + tl);</a>
<a name="ln4558">      p = p + tl;</a>
<a name="ln4559"> </a>
<a name="ln4560">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4561">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln4562">        // third char were already checked at swap and swap3.</a>
<a name="ln4563">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4564">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4565">        break;</a>
<a name="ln4566">      }</a>
<a name="ln4567"> </a>
<a name="ln4568">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln4569">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln4570">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4571">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4572">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4573">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4574">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,</a>
<a name="ln4575">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4576">            p[0], p[1], p[2]);</a>
<a name="ln4577">#endif</a>
<a name="ln4578">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4579">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln4580">        ++depth;</a>
<a name="ln4581">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4582">        n = MB_CPTR2LEN(p);</a>
<a name="ln4583">        c = utf_ptr2char(p);</a>
<a name="ln4584">        fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4585">        fl += MB_CPTR2LEN(p + n + fl);</a>
<a name="ln4586">        memmove(p, p + n, fl);</a>
<a name="ln4587">        utf_char2bytes(c, p + fl);</a>
<a name="ln4588">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4589">      } else {</a>
<a name="ln4590">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4591">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4592">      }</a>
<a name="ln4593">      break;</a>
<a name="ln4594"> </a>
<a name="ln4595">    case STATE_UNROT3L:</a>
<a name="ln4596">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln4597">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4598">      n = utfc_ptr2len(p);</a>
<a name="ln4599">      n += utfc_ptr2len(p + n);</a>
<a name="ln4600">      c = utf_ptr2char(p + n);</a>
<a name="ln4601">      tl = utfc_ptr2len(p + n);</a>
<a name="ln4602">      memmove(p + tl, p, n);</a>
<a name="ln4603">      utf_char2bytes(c, p);</a>
<a name="ln4604"> </a>
<a name="ln4605">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln4606">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln4607">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4608">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4609">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4610">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4611">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,</a>
<a name="ln4612">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4613">            p[0], p[1], p[2]);</a>
<a name="ln4614">#endif</a>
<a name="ln4615">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4616">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln4617">        ++depth;</a>
<a name="ln4618">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4619">        n = MB_CPTR2LEN(p);</a>
<a name="ln4620">        n += MB_CPTR2LEN(p + n);</a>
<a name="ln4621">        c = utf_ptr2char(p + n);</a>
<a name="ln4622">        tl = MB_CPTR2LEN(p + n);</a>
<a name="ln4623">        memmove(p + tl, p, n);</a>
<a name="ln4624">        utf_char2bytes(c, p);</a>
<a name="ln4625">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + tl;</a>
<a name="ln4626">      } else {</a>
<a name="ln4627">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4628">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4629">      }</a>
<a name="ln4630">      break;</a>
<a name="ln4631"> </a>
<a name="ln4632">    case STATE_UNROT3R:</a>
<a name="ln4633">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln4634">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4635">      c = utf_ptr2char(p);</a>
<a name="ln4636">      tl = utfc_ptr2len(p);</a>
<a name="ln4637">      n = utfc_ptr2len(p + tl);</a>
<a name="ln4638">      n += utfc_ptr2len(p + tl + n);</a>
<a name="ln4639">      memmove(p, p + tl, n);</a>
<a name="ln4640">      utf_char2bytes(c, p + n);</a>
<a name="ln4641"> </a>
<a name="ln4642">      FALLTHROUGH;</a>
<a name="ln4643"> </a>
<a name="ln4644">    case STATE_REP_INI:</a>
<a name="ln4645">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln4646">      // Quickly skip if:</a>
<a name="ln4647">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln4648">      // - the score is going to be too high anyway</a>
<a name="ln4649">      // - already applied a REP item or swapped here</a>
<a name="ln4650">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln4651">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln4652">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln4653">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4654">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4655">        break;</a>
<a name="ln4656">      }</a>
<a name="ln4657"> </a>
<a name="ln4658">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln4659">      // match.  If the index is -1 there is none.</a>
<a name="ln4660">      if (soundfold)</a>
<a name="ln4661">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4662">      else</a>
<a name="ln4663">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4664"> </a>
<a name="ln4665">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln4666">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4667">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4668">        break;</a>
<a name="ln4669">      }</a>
<a name="ln4670"> </a>
<a name="ln4671">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4672">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4673">      FALLTHROUGH;</a>
<a name="ln4674"> </a>
<a name="ln4675">    case STATE_REP:</a>
<a name="ln4676">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln4677">      // replace the characters and check if the resulting word is</a>
<a name="ln4678">      // valid.</a>
<a name="ln4679">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4680"> </a>
<a name="ln4681">      if (soundfold)</a>
<a name="ln4682">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4683">      else</a>
<a name="ln4684">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4685">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln4686">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln4687">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln4688">          // past possible matching entries</a>
<a name="ln4689">          sp-&gt;ts_curi = gap-&gt;ga_len;</a>
<a name="ln4690">          break;</a>
<a name="ln4691">        }</a>
<a name="ln4692">        if (STRNCMP(ftp-&gt;ft_from, p, STRLEN(ftp-&gt;ft_from)) == 0</a>
<a name="ln4693">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln4694">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln4695">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4696">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,</a>
<a name="ln4697">              sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4698">              ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln4699">#endif</a>
<a name="ln4700">          // Need to undo this afterwards.</a>
<a name="ln4701">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4702">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln4703"> </a>
<a name="ln4704">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln4705">          ++depth;</a>
<a name="ln4706">          fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4707">          tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4708">          if (fl != tl) {</a>
<a name="ln4709">            STRMOVE(p + tl, p + fl);</a>
<a name="ln4710">            repextra += tl - fl;</a>
<a name="ln4711">          }</a>
<a name="ln4712">          memmove(p, ftp-&gt;ft_to, tl);</a>
<a name="ln4713">          stack[depth].ts_fidxtry = sp-&gt;ts_fidx + tl;</a>
<a name="ln4714">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln4715">          break;</a>
<a name="ln4716">        }</a>
<a name="ln4717">      }</a>
<a name="ln4718"> </a>
<a name="ln4719">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP)</a>
<a name="ln4720">        // No (more) matches.</a>
<a name="ln4721">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4722">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4723"> </a>
<a name="ln4724">      break;</a>
<a name="ln4725"> </a>
<a name="ln4726">    case STATE_REP_UNDO:</a>
<a name="ln4727">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln4728">      if (soundfold)</a>
<a name="ln4729">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4730">      else</a>
<a name="ln4731">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4732">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln4733">      fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4734">      tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4735">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4736">      if (fl != tl) {</a>
<a name="ln4737">        STRMOVE(p + fl, p + tl);</a>
<a name="ln4738">        repextra -= tl - fl;</a>
<a name="ln4739">      }</a>
<a name="ln4740">      memmove(p, ftp-&gt;ft_from, fl);</a>
<a name="ln4741">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4742">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4743">      break;</a>
<a name="ln4744"> </a>
<a name="ln4745">    default:</a>
<a name="ln4746">      // Did all possible states at this level, go up one level.</a>
<a name="ln4747">      --depth;</a>
<a name="ln4748"> </a>
<a name="ln4749">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln4750">        // Continue in or go back to the prefix tree.</a>
<a name="ln4751">        byts = pbyts;</a>
<a name="ln4752">        idxs = pidxs;</a>
<a name="ln4753">      }</a>
<a name="ln4754"> </a>
<a name="ln4755">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln4756">      if (--breakcheckcount == 0) {</a>
<a name="ln4757">        os_breakcheck();</a>
<a name="ln4758">        breakcheckcount = 1000;</a>
<a name="ln4759">      }</a>
<a name="ln4760">    }</a>
<a name="ln4761">  }</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764"> </a>
<a name="ln4765">// Go one level deeper in the tree.</a>
<a name="ln4766">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln4767">{</a>
<a name="ln4768">  stack[depth + 1] = stack[depth];</a>
<a name="ln4769">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln4770">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln4771">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln4772">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln4773">}</a>
<a name="ln4774"> </a>
<a name="ln4775">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln4776">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln4777">static int nofold_len(char_u *fword, int flen, char_u *word)</a>
<a name="ln4778">{</a>
<a name="ln4779">  char_u      *p;</a>
<a name="ln4780">  int i = 0;</a>
<a name="ln4781"> </a>
<a name="ln4782">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln4783">    i++;</a>
<a name="ln4784">  }</a>
<a name="ln4785">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln4786">    i--;</a>
<a name="ln4787">  }</a>
<a name="ln4788">  return (int)(p - word);</a>
<a name="ln4789">}</a>
<a name="ln4790"> </a>
<a name="ln4791">// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln4792">// words and put it in &quot;kword&quot;.</a>
<a name="ln4793">// Theoretically there could be several keep-case words that result in the</a>
<a name="ln4794">// same case-folded word, but we only find one...</a>
<a name="ln4795">static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)</a>
<a name="ln4796">{</a>
<a name="ln4797">  char_u uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln4798">  int depth;</a>
<a name="ln4799">  idx_T tryidx;</a>
<a name="ln4800"> </a>
<a name="ln4801">  // The following arrays are used at each depth in the tree.</a>
<a name="ln4802">  idx_T arridx[MAXWLEN];</a>
<a name="ln4803">  int round[MAXWLEN];</a>
<a name="ln4804">  int fwordidx[MAXWLEN];</a>
<a name="ln4805">  int uwordidx[MAXWLEN];</a>
<a name="ln4806">  int kwordlen[MAXWLEN];</a>
<a name="ln4807"> </a>
<a name="ln4808">  int flen, ulen;</a>
<a name="ln4809">  int l;</a>
<a name="ln4810">  int len;</a>
<a name="ln4811">  int c;</a>
<a name="ln4812">  idx_T lo, hi, m;</a>
<a name="ln4813">  char_u      *p;</a>
<a name="ln4814">  char_u      *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln4815">  idx_T       *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln4816"> </a>
<a name="ln4817">  if (byts == NULL) {</a>
<a name="ln4818">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln4819">    *kword = NUL;</a>
<a name="ln4820">    return;</a>
<a name="ln4821">  }</a>
<a name="ln4822"> </a>
<a name="ln4823">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln4824">  allcap_copy(fword, uword);</a>
<a name="ln4825"> </a>
<a name="ln4826">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln4827">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln4828">  // may change the byte length of a multi-byte character...</a>
<a name="ln4829">  depth = 0;</a>
<a name="ln4830">  arridx[0] = 0;</a>
<a name="ln4831">  round[0] = 0;</a>
<a name="ln4832">  fwordidx[0] = 0;</a>
<a name="ln4833">  uwordidx[0] = 0;</a>
<a name="ln4834">  kwordlen[0] = 0;</a>
<a name="ln4835">  while (depth &gt;= 0) {</a>
<a name="ln4836">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln4837">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln4838">      // here we have found a match.</a>
<a name="ln4839">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln4840">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln4841">        return;</a>
<a name="ln4842">      }</a>
<a name="ln4843"> </a>
<a name="ln4844">      // kword is getting too long, continue one level up</a>
<a name="ln4845">      --depth;</a>
<a name="ln4846">    } else if (++round[depth] &gt; 2)   {</a>
<a name="ln4847">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln4848">      // level up</a>
<a name="ln4849">      --depth;</a>
<a name="ln4850">    } else {</a>
<a name="ln4851">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln4852">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln4853">      flen = MB_CPTR2LEN(fword + fwordidx[depth]);</a>
<a name="ln4854">      ulen = MB_CPTR2LEN(uword + uwordidx[depth]);</a>
<a name="ln4855">      if (round[depth] == 1) {</a>
<a name="ln4856">        p = fword + fwordidx[depth];</a>
<a name="ln4857">        l = flen;</a>
<a name="ln4858">      } else {</a>
<a name="ln4859">        p = uword + uwordidx[depth];</a>
<a name="ln4860">        l = ulen;</a>
<a name="ln4861">      }</a>
<a name="ln4862"> </a>
<a name="ln4863">      for (tryidx = arridx[depth]; l &gt; 0; --l) {</a>
<a name="ln4864">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln4865">        len = byts[tryidx++];</a>
<a name="ln4866">        c = *p++;</a>
<a name="ln4867">        lo = tryidx;</a>
<a name="ln4868">        hi = tryidx + len - 1;</a>
<a name="ln4869">        while (lo &lt; hi) {</a>
<a name="ln4870">          m = (lo + hi) / 2;</a>
<a name="ln4871">          if (byts[m] &gt; c)</a>
<a name="ln4872">            hi = m - 1;</a>
<a name="ln4873">          else if (byts[m] &lt; c)</a>
<a name="ln4874">            lo = m + 1;</a>
<a name="ln4875">          else {</a>
<a name="ln4876">            lo = hi = m;</a>
<a name="ln4877">            break;</a>
<a name="ln4878">          }</a>
<a name="ln4879">        }</a>
<a name="ln4880"> </a>
<a name="ln4881">        // Stop if there is no matching byte.</a>
<a name="ln4882">        if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln4883">          break;</a>
<a name="ln4884"> </a>
<a name="ln4885">        // Continue at the child (if there is one).</a>
<a name="ln4886">        tryidx = idxs[lo];</a>
<a name="ln4887">      }</a>
<a name="ln4888"> </a>
<a name="ln4889">      if (l == 0) {</a>
<a name="ln4890">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln4891">        // level deeper.</a>
<a name="ln4892">        if (round[depth] == 1) {</a>
<a name="ln4893">          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],</a>
<a name="ln4894">              flen);</a>
<a name="ln4895">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln4896">        } else {</a>
<a name="ln4897">          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],</a>
<a name="ln4898">              ulen);</a>
<a name="ln4899">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln4900">        }</a>
<a name="ln4901">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln4902">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln4903"> </a>
<a name="ln4904">        ++depth;</a>
<a name="ln4905">        arridx[depth] = tryidx;</a>
<a name="ln4906">        round[depth] = 0;</a>
<a name="ln4907">      }</a>
<a name="ln4908">    }</a>
<a name="ln4909">  }</a>
<a name="ln4910"> </a>
<a name="ln4911">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln4912">  *kword = NUL;</a>
<a name="ln4913">}</a>
<a name="ln4914"> </a>
<a name="ln4915">// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln4916">// su-&gt;su_sga.</a>
<a name="ln4917">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln4918">{</a>
<a name="ln4919">  langp_T     *lp;</a>
<a name="ln4920">  char_u badsound[MAXWLEN];</a>
<a name="ln4921">  int i;</a>
<a name="ln4922">  suggest_T   *stp;</a>
<a name="ln4923">  suggest_T   *sstp;</a>
<a name="ln4924">  int score;</a>
<a name="ln4925"> </a>
<a name="ln4926">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln4927"> </a>
<a name="ln4928">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln4929">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln4930">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln4931">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln4932">      // soundfold the bad word</a>
<a name="ln4933">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln4934"> </a>
<a name="ln4935">      for (i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln4936">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln4937"> </a>
<a name="ln4938">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln4939">        // sound-a-like score.</a>
<a name="ln4940">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln4941">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln4942">          // Add the suggestion.</a>
<a name="ln4943">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln4944">          sstp-&gt;st_word = vim_strsave(stp-&gt;st_word);</a>
<a name="ln4945">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln4946">          sstp-&gt;st_score = score;</a>
<a name="ln4947">          sstp-&gt;st_altscore = 0;</a>
<a name="ln4948">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln4949">          ++su-&gt;su_sga.ga_len;</a>
<a name="ln4950">        }</a>
<a name="ln4951">      }</a>
<a name="ln4952">      break;</a>
<a name="ln4953">    }</a>
<a name="ln4954">  }</a>
<a name="ln4955">}</a>
<a name="ln4956"> </a>
<a name="ln4957">// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln4958">// They are entwined.</a>
<a name="ln4959">static void score_combine(suginfo_T *su)</a>
<a name="ln4960">{</a>
<a name="ln4961">  garray_T ga;</a>
<a name="ln4962">  garray_T    *gap;</a>
<a name="ln4963">  langp_T     *lp;</a>
<a name="ln4964">  suggest_T   *stp;</a>
<a name="ln4965">  char_u      *p;</a>
<a name="ln4966">  char_u badsound[MAXWLEN];</a>
<a name="ln4967">  int round;</a>
<a name="ln4968">  slang_T     *slang = NULL;</a>
<a name="ln4969"> </a>
<a name="ln4970">  // Add the alternate score to su_ga.</a>
<a name="ln4971">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln4972">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln4973">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln4974">      // soundfold the bad word</a>
<a name="ln4975">      slang = lp-&gt;lp_slang;</a>
<a name="ln4976">      spell_soundfold(slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln4977"> </a>
<a name="ln4978">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln4979">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln4980">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, badsound);</a>
<a name="ln4981">        if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln4982">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln4983">        else</a>
<a name="ln4984">          stp-&gt;st_score = (stp-&gt;st_score * 3</a>
<a name="ln4985">                           + stp-&gt;st_altscore) / 4;</a>
<a name="ln4986">        stp-&gt;st_salscore = false;</a>
<a name="ln4987">      }</a>
<a name="ln4988">      break;</a>
<a name="ln4989">    }</a>
<a name="ln4990">  }</a>
<a name="ln4991"> </a>
<a name="ln4992">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln4993">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln4994">        su-&gt;su_maxcount);</a>
<a name="ln4995">    return;</a>
<a name="ln4996">  }</a>
<a name="ln4997"> </a>
<a name="ln4998">  // Add the alternate score to su_sga.</a>
<a name="ln4999">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5000">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln5001">    stp-&gt;st_altscore = spell_edit_score(slang,</a>
<a name="ln5002">        su-&gt;su_badword, stp-&gt;st_word);</a>
<a name="ln5003">    if (stp-&gt;st_score == SCORE_MAXMAX)</a>
<a name="ln5004">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5005">    else</a>
<a name="ln5006">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5007">    stp-&gt;st_salscore = true;</a>
<a name="ln5008">  }</a>
<a name="ln5009"> </a>
<a name="ln5010">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln5011">  // for both lists.</a>
<a name="ln5012">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln5013">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5014">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln5015">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5016"> </a>
<a name="ln5017">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln5018">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln5019"> </a>
<a name="ln5020">  stp = &amp;SUG(ga, 0);</a>
<a name="ln5021">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5022">    // round 1: get a suggestion from su_ga</a>
<a name="ln5023">    // round 2: get a suggestion from su_sga</a>
<a name="ln5024">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln5025">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln5026">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln5027">        // Don't add a word if it's already there.</a>
<a name="ln5028">        p = SUG(*gap, i).st_word;</a>
<a name="ln5029">        int j;</a>
<a name="ln5030">        for (j = 0; j &lt; ga.ga_len; ++j)</a>
<a name="ln5031">          if (STRCMP(stp[j].st_word, p) == 0)</a>
<a name="ln5032">            break;</a>
<a name="ln5033">        if (j == ga.ga_len)</a>
<a name="ln5034">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln5035">        else</a>
<a name="ln5036">          xfree(p);</a>
<a name="ln5037">      }</a>
<a name="ln5038">    }</a>
<a name="ln5039">  }</a>
<a name="ln5040"> </a>
<a name="ln5041">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln5042">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln5043"> </a>
<a name="ln5044">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5045">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln5046">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; ++i) {</a>
<a name="ln5047">      xfree(stp[i].st_word);</a>
<a name="ln5048">    }</a>
<a name="ln5049">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln5050">  }</a>
<a name="ln5051"> </a>
<a name="ln5052">  su-&gt;su_ga = ga;</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln5056">// badword.</a>
<a name="ln5057">static int</a>
<a name="ln5058">stp_sal_score (</a>
<a name="ln5059">    suggest_T *stp,</a>
<a name="ln5060">    suginfo_T *su,</a>
<a name="ln5061">    slang_T *slang,</a>
<a name="ln5062">    char_u *badsound          // sound-folded badword</a>
<a name="ln5063">)</a>
<a name="ln5064">{</a>
<a name="ln5065">  char_u      *p;</a>
<a name="ln5066">  char_u      *pbad;</a>
<a name="ln5067">  char_u      *pgood;</a>
<a name="ln5068">  char_u badsound2[MAXWLEN];</a>
<a name="ln5069">  char_u fword[MAXWLEN];</a>
<a name="ln5070">  char_u goodsound[MAXWLEN];</a>
<a name="ln5071">  char_u goodword[MAXWLEN];</a>
<a name="ln5072">  int lendiff;</a>
<a name="ln5073"> </a>
<a name="ln5074">  lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln5075">  if (lendiff &gt;= 0)</a>
<a name="ln5076">    pbad = badsound;</a>
<a name="ln5077">  else {</a>
<a name="ln5078">    // soundfold the bad word with more characters following</a>
<a name="ln5079">    (void)spell_casefold(su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln5080"> </a>
<a name="ln5081">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln5082">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln5083">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln5084">    // space.</a>
<a name="ln5085">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln5086">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL)</a>
<a name="ln5087">      for (p = fword; *(p = skiptowhite(p)) != NUL; )</a>
<a name="ln5088">        STRMOVE(p, p + 1);</a>
<a name="ln5089"> </a>
<a name="ln5090">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln5091">    pbad = badsound2;</a>
<a name="ln5092">  }</a>
<a name="ln5093"> </a>
<a name="ln5094">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln5095">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln5096">    // what replaces the bad word.</a>
<a name="ln5097">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln5098">    STRLCPY(goodword + stp-&gt;st_wordlen,</a>
<a name="ln5099">        su-&gt;su_badptr + su-&gt;su_badlen - lendiff, lendiff + 1);</a>
<a name="ln5100">    pgood = goodword;</a>
<a name="ln5101">  } else</a>
<a name="ln5102">    pgood = stp-&gt;st_word;</a>
<a name="ln5103"> </a>
<a name="ln5104">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln5105">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln5106"> </a>
<a name="ln5107">  return soundalike_score(goodsound, pbad);</a>
<a name="ln5108">}</a>
<a name="ln5109"> </a>
<a name="ln5110">static sftword_T dumsft;</a>
<a name="ln5111">#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&amp;dumsft)))</a>
<a name="ln5112">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln5113"> </a>
<a name="ln5114">// Prepare for calling suggest_try_soundalike().</a>
<a name="ln5115">static void suggest_try_soundalike_prep(void)</a>
<a name="ln5116">{</a>
<a name="ln5117">  langp_T     *lp;</a>
<a name="ln5118">  slang_T     *slang;</a>
<a name="ln5119"> </a>
<a name="ln5120">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5121">  // .sug file has been loaded.</a>
<a name="ln5122">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5123">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5124">    slang = lp-&gt;lp_slang;</a>
<a name="ln5125">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL)</a>
<a name="ln5126">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln5127">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5128">  }</a>
<a name="ln5129">}</a>
<a name="ln5130"> </a>
<a name="ln5131">// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln5132">// Note: This doesn't support postponed prefixes.</a>
<a name="ln5133">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln5134">{</a>
<a name="ln5135">  char_u salword[MAXWLEN];</a>
<a name="ln5136">  langp_T     *lp;</a>
<a name="ln5137">  slang_T     *slang;</a>
<a name="ln5138"> </a>
<a name="ln5139">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5140">  // .sug file has been loaded.</a>
<a name="ln5141">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5142">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5143">    slang = lp-&gt;lp_slang;</a>
<a name="ln5144">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5145">      // soundfold the bad word</a>
<a name="ln5146">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln5147"> </a>
<a name="ln5148">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln5149">      // TODO: also soundfold the next words, so that we can try joining</a>
<a name="ln5150">      // and splitting</a>
<a name="ln5151">#ifdef SUGGEST_PROFILE</a>
<a name="ln5152">      prof_init();</a>
<a name="ln5153">#endif</a>
<a name="ln5154">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln5155">#ifdef SUGGEST_PROFILE</a>
<a name="ln5156">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln5157">#endif</a>
<a name="ln5158">    }</a>
<a name="ln5159">  }</a>
<a name="ln5160">}</a>
<a name="ln5161"> </a>
<a name="ln5162">// Finish up after calling suggest_try_soundalike().</a>
<a name="ln5163">static void suggest_try_soundalike_finish(void)</a>
<a name="ln5164">{</a>
<a name="ln5165">  langp_T     *lp;</a>
<a name="ln5166">  slang_T     *slang;</a>
<a name="ln5167">  int todo;</a>
<a name="ln5168">  hashitem_T  *hi;</a>
<a name="ln5169"> </a>
<a name="ln5170">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5171">  // .sug file has been loaded.</a>
<a name="ln5172">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5173">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5174">    slang = lp-&gt;lp_slang;</a>
<a name="ln5175">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5176">      // Free the info about handled words.</a>
<a name="ln5177">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln5178">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; ++hi)</a>
<a name="ln5179">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln5180">          xfree(HI2SFT(hi));</a>
<a name="ln5181">          --todo;</a>
<a name="ln5182">        }</a>
<a name="ln5183"> </a>
<a name="ln5184">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln5185">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5186">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5187">    }</a>
<a name="ln5188">  }</a>
<a name="ln5189">}</a>
<a name="ln5190"> </a>
<a name="ln5191">// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln5192">// produce this soundfolded word.</a>
<a name="ln5193">static void</a>
<a name="ln5194">add_sound_suggest (</a>
<a name="ln5195">    suginfo_T *su,</a>
<a name="ln5196">    char_u *goodword,</a>
<a name="ln5197">    int score,                      // soundfold score</a>
<a name="ln5198">    langp_T *lp</a>
<a name="ln5199">)</a>
<a name="ln5200">{</a>
<a name="ln5201">  slang_T     *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln5202">  int sfwordnr;</a>
<a name="ln5203">  char_u      *nrline;</a>
<a name="ln5204">  int orgnr;</a>
<a name="ln5205">  char_u theword[MAXWLEN];</a>
<a name="ln5206">  int i;</a>
<a name="ln5207">  int wlen;</a>
<a name="ln5208">  char_u      *byts;</a>
<a name="ln5209">  idx_T       *idxs;</a>
<a name="ln5210">  int n;</a>
<a name="ln5211">  int wordcount;</a>
<a name="ln5212">  int wc;</a>
<a name="ln5213">  int goodscore;</a>
<a name="ln5214">  hash_T hash;</a>
<a name="ln5215">  hashitem_T  *hi;</a>
<a name="ln5216">  sftword_T   *sft;</a>
<a name="ln5217">  int bc, gc;</a>
<a name="ln5218">  int limit;</a>
<a name="ln5219"> </a>
<a name="ln5220">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln5221">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln5222">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln5223">  // remember the words that have been done.</a>
<a name="ln5224">  hash = hash_hash(goodword);</a>
<a name="ln5225">  const size_t goodword_len = STRLEN(goodword);</a>
<a name="ln5226">  hi = hash_lookup(&amp;slang-&gt;sl_sounddone, (const char *)goodword, goodword_len,</a>
<a name="ln5227">                   hash);</a>
<a name="ln5228">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5229">    sft = xmalloc(sizeof(sftword_T) + goodword_len);</a>
<a name="ln5230">    sft-&gt;sft_score = score;</a>
<a name="ln5231">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln5232">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, sft-&gt;sft_word, hash);</a>
<a name="ln5233">  } else {</a>
<a name="ln5234">    sft = HI2SFT(hi);</a>
<a name="ln5235">    if (score &gt;= sft-&gt;sft_score)</a>
<a name="ln5236">      return;</a>
<a name="ln5237">    sft-&gt;sft_score = score;</a>
<a name="ln5238">  }</a>
<a name="ln5239"> </a>
<a name="ln5240">  // Find the word nr in the soundfold tree.</a>
<a name="ln5241">  sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln5242">  if (sfwordnr &lt; 0) {</a>
<a name="ln5243">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln5244">    return;</a>
<a name="ln5245">  }</a>
<a name="ln5246"> </a>
<a name="ln5247">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln5248">  nrline = ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln5249">  orgnr = 0;</a>
<a name="ln5250">  while (*nrline != NUL) {</a>
<a name="ln5251">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln5252">    // previous wordnr.</a>
<a name="ln5253">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln5254"> </a>
<a name="ln5255">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln5256">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln5257"> </a>
<a name="ln5258">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln5259">    n = 0;</a>
<a name="ln5260">    wordcount = 0;</a>
<a name="ln5261">    for (wlen = 0; wlen &lt; MAXWLEN - 3; ++wlen) {</a>
<a name="ln5262">      i = 1;</a>
<a name="ln5263">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL)</a>
<a name="ln5264">        break;          // found end of word</a>
<a name="ln5265"> </a>
<a name="ln5266">      if (byts[n + 1] == NUL)</a>
<a name="ln5267">        ++wordcount;</a>
<a name="ln5268"> </a>
<a name="ln5269">      // skip over the NUL bytes</a>
<a name="ln5270">      for (; byts[n + i] == NUL; ++i)</a>
<a name="ln5271">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln5272">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln5273">          wlen += 3;</a>
<a name="ln5274">          goto badword;</a>
<a name="ln5275">        }</a>
<a name="ln5276"> </a>
<a name="ln5277">      // One of the siblings must have the word.</a>
<a name="ln5278">      for (; i &lt; byts[n]; ++i) {</a>
<a name="ln5279">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln5280">        if (wordcount + wc &gt; orgnr)</a>
<a name="ln5281">          break;</a>
<a name="ln5282">        wordcount += wc;</a>
<a name="ln5283">      }</a>
<a name="ln5284"> </a>
<a name="ln5285">      theword[wlen] = byts[n + i];</a>
<a name="ln5286">      n = idxs[n + i];</a>
<a name="ln5287">    }</a>
<a name="ln5288">badword:</a>
<a name="ln5289">    theword[wlen] = NUL;</a>
<a name="ln5290"> </a>
<a name="ln5291">    // Go over the possible flags and regions.</a>
<a name="ln5292">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; ++i) {</a>
<a name="ln5293">      char_u cword[MAXWLEN];</a>
<a name="ln5294">      char_u      *p;</a>
<a name="ln5295">      int flags = (int)idxs[n + i];</a>
<a name="ln5296"> </a>
<a name="ln5297">      // Skip words with the NOSUGGEST flag</a>
<a name="ln5298">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln5299">        continue;</a>
<a name="ln5300"> </a>
<a name="ln5301">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln5302">        // Must find the word in the keep-case tree.</a>
<a name="ln5303">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln5304">        p = cword;</a>
<a name="ln5305">      } else {</a>
<a name="ln5306">        flags |= su-&gt;su_badflags;</a>
<a name="ln5307">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln5308">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln5309">          make_case_word(theword, cword, flags);</a>
<a name="ln5310">          p = cword;</a>
<a name="ln5311">        } else</a>
<a name="ln5312">          p = theword;</a>
<a name="ln5313">      }</a>
<a name="ln5314"> </a>
<a name="ln5315">      // Add the suggestion.</a>
<a name="ln5316">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln5317">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln5318">        if (score &lt;= su-&gt;su_maxscore)</a>
<a name="ln5319">          add_suggestion(su, &amp;su-&gt;su_sga, p, su-&gt;su_badlen,</a>
<a name="ln5320">              score, 0, false, slang, false);</a>
<a name="ln5321">      } else {</a>
<a name="ln5322">        // Add a penalty for words in another region.</a>
<a name="ln5323">        if ((flags &amp; WF_REGION)</a>
<a name="ln5324">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln5325">          goodscore = SCORE_REGION;</a>
<a name="ln5326">        else</a>
<a name="ln5327">          goodscore = 0;</a>
<a name="ln5328"> </a>
<a name="ln5329">        // Add a small penalty for changing the first letter from</a>
<a name="ln5330">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln5331">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln5332">        // letter is the same, that has already been counted.</a>
<a name="ln5333">        gc = PTR2CHAR(p);</a>
<a name="ln5334">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln5335">          bc = PTR2CHAR(su-&gt;su_badword);</a>
<a name="ln5336">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln5337">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))</a>
<a name="ln5338">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln5339">        }</a>
<a name="ln5340"> </a>
<a name="ln5341">        // Compute the score for the good word.  This only does letter</a>
<a name="ln5342">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln5343">        // which may make the score a bit higher.</a>
<a name="ln5344">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln5345">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln5346">        // If the limit is very high then the iterative method is</a>
<a name="ln5347">        // inefficient, using an array is quicker.</a>
<a name="ln5348">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln5349">        if (limit &gt; SCORE_LIMITMAX)</a>
<a name="ln5350">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln5351">        else</a>
<a name="ln5352">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword,</a>
<a name="ln5353">              p, limit);</a>
<a name="ln5354"> </a>
<a name="ln5355">        // When going over the limit don't bother to do the rest.</a>
<a name="ln5356">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln5357">          // Give a bonus to words seen before.</a>
<a name="ln5358">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln5359"> </a>
<a name="ln5360">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln5361">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln5362">          if (goodscore &lt;= su-&gt;su_sfmaxscore)</a>
<a name="ln5363">            add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln5364">                goodscore, score, true, slang, true);</a>
<a name="ln5365">        }</a>
<a name="ln5366">      }</a>
<a name="ln5367">    }</a>
<a name="ln5368">  }</a>
<a name="ln5369">}</a>
<a name="ln5370"> </a>
<a name="ln5371">// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln5372">static int soundfold_find(slang_T *slang, char_u *word)</a>
<a name="ln5373">{</a>
<a name="ln5374">  idx_T arridx = 0;</a>
<a name="ln5375">  int len;</a>
<a name="ln5376">  int wlen = 0;</a>
<a name="ln5377">  int c;</a>
<a name="ln5378">  char_u      *ptr = word;</a>
<a name="ln5379">  char_u      *byts;</a>
<a name="ln5380">  idx_T       *idxs;</a>
<a name="ln5381">  int wordnr = 0;</a>
<a name="ln5382"> </a>
<a name="ln5383">  byts = slang-&gt;sl_sbyts;</a>
<a name="ln5384">  idxs = slang-&gt;sl_sidxs;</a>
<a name="ln5385"> </a>
<a name="ln5386">  for (;; ) {</a>
<a name="ln5387">    // First byte is the number of possible bytes.</a>
<a name="ln5388">    len = byts[arridx++];</a>
<a name="ln5389"> </a>
<a name="ln5390">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln5391">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln5392">    c = ptr[wlen];</a>
<a name="ln5393">    if (byts[arridx] == NUL) {</a>
<a name="ln5394">      if (c == NUL)</a>
<a name="ln5395">        break;</a>
<a name="ln5396"> </a>
<a name="ln5397">      // Skip over the zeros, there can be several.</a>
<a name="ln5398">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln5399">        ++arridx;</a>
<a name="ln5400">        --len;</a>
<a name="ln5401">      }</a>
<a name="ln5402">      if (len == 0)</a>
<a name="ln5403">        return -1;            // no children, word should have ended here</a>
<a name="ln5404">      ++wordnr;</a>
<a name="ln5405">    }</a>
<a name="ln5406"> </a>
<a name="ln5407">    // If the word ends we didn't find it.</a>
<a name="ln5408">    if (c == NUL)</a>
<a name="ln5409">      return -1;</a>
<a name="ln5410"> </a>
<a name="ln5411">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln5412">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln5413">      c = ' ';</a>
<a name="ln5414">    while (byts[arridx] &lt; c) {</a>
<a name="ln5415">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln5416">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln5417">      ++arridx;</a>
<a name="ln5418">      if (--len == 0)           // end of the bytes, didn't find it</a>
<a name="ln5419">        return -1;</a>
<a name="ln5420">    }</a>
<a name="ln5421">    if (byts[arridx] != c)      // didn't find the byte</a>
<a name="ln5422">      return -1;</a>
<a name="ln5423"> </a>
<a name="ln5424">    // Continue at the child (if there is one).</a>
<a name="ln5425">    arridx = idxs[arridx];</a>
<a name="ln5426">    ++wlen;</a>
<a name="ln5427"> </a>
<a name="ln5428">    // One space in the good word may stand for several spaces in the</a>
<a name="ln5429">    // checked word.</a>
<a name="ln5430">    if (c == ' ')</a>
<a name="ln5431">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)</a>
<a name="ln5432">        ++wlen;</a>
<a name="ln5433">  }</a>
<a name="ln5434"> </a>
<a name="ln5435">  return wordnr;</a>
<a name="ln5436">}</a>
<a name="ln5437"> </a>
<a name="ln5438">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln5439">static void make_case_word(char_u *fword, char_u *cword, int flags)</a>
<a name="ln5440">{</a>
<a name="ln5441">  if (flags &amp; WF_ALLCAP)</a>
<a name="ln5442">    // Make it all upper-case</a>
<a name="ln5443">    allcap_copy(fword, cword);</a>
<a name="ln5444">  else if (flags &amp; WF_ONECAP)</a>
<a name="ln5445">    // Make the first letter upper-case</a>
<a name="ln5446">    onecap_copy(fword, cword, true);</a>
<a name="ln5447">  else</a>
<a name="ln5448">    // Use goodword as-is.</a>
<a name="ln5449">    STRCPY(cword, fword);</a>
<a name="ln5450">}</a>
<a name="ln5451"> </a>
<a name="ln5452">// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln5453">// lines in the .aff file.</a>
<a name="ln5454">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln5455">{</a>
<a name="ln5456">  int m1, m2;</a>
<a name="ln5457">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5458">  hashitem_T  *hi;</a>
<a name="ln5459"> </a>
<a name="ln5460">  if (c1 &gt;= 256) {</a>
<a name="ln5461">    buf[utf_char2bytes(c1, buf)] = 0;</a>
<a name="ln5462">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5463">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5464">      m1 = 0;</a>
<a name="ln5465">    } else {</a>
<a name="ln5466">      m1 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5467">    }</a>
<a name="ln5468">  } else {</a>
<a name="ln5469">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln5470">  }</a>
<a name="ln5471">  if (m1 == 0) {</a>
<a name="ln5472">    return false;</a>
<a name="ln5473">  }</a>
<a name="ln5474"> </a>
<a name="ln5475">  if (c2 &gt;= 256) {</a>
<a name="ln5476">    buf[utf_char2bytes(c2, buf)] = 0;</a>
<a name="ln5477">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5478">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5479">      m2 = 0;</a>
<a name="ln5480">    } else {</a>
<a name="ln5481">      m2 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5482">    }</a>
<a name="ln5483">  } else {</a>
<a name="ln5484">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln5485">  }</a>
<a name="ln5486"> </a>
<a name="ln5487">  return m1 == m2;</a>
<a name="ln5488">}</a>
<a name="ln5489"> </a>
<a name="ln5490">// Adds a suggestion to the list of suggestions.</a>
<a name="ln5491">// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln5492">static void</a>
<a name="ln5493">add_suggestion (</a>
<a name="ln5494">    suginfo_T *su,</a>
<a name="ln5495">    garray_T *gap,              // either su_ga or su_sga</a>
<a name="ln5496">    const char_u *goodword,</a>
<a name="ln5497">    int badlenarg,              // len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln5498">    int score,</a>
<a name="ln5499">    int altscore,</a>
<a name="ln5500">    bool had_bonus,             // value for st_had_bonus</a>
<a name="ln5501">    slang_T *slang,             // language for sound folding</a>
<a name="ln5502">    bool maxsf                  // su_maxscore applies to soundfold score,</a>
<a name="ln5503">                                // su_sfmaxscore to the total score.</a>
<a name="ln5504">)</a>
<a name="ln5505">{</a>
<a name="ln5506">  int goodlen;                  // len of goodword changed</a>
<a name="ln5507">  int badlen;                   // len of bad word changed</a>
<a name="ln5508">  suggest_T   *stp;</a>
<a name="ln5509">  suggest_T new_sug;</a>
<a name="ln5510"> </a>
<a name="ln5511">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln5512">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln5513">  const char_u *pgood = goodword + STRLEN(goodword);</a>
<a name="ln5514">  char_u *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln5515">  for (;; ) {</a>
<a name="ln5516">    goodlen = (int)(pgood - goodword);</a>
<a name="ln5517">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln5518">    if (goodlen &lt;= 0 || badlen &lt;= 0)</a>
<a name="ln5519">      break;</a>
<a name="ln5520">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln5521">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln5522">    if (utf_ptr2char(pgood) != utf_ptr2char(pbad)) {</a>
<a name="ln5523">      break;</a>
<a name="ln5524">    }</a>
<a name="ln5525">  }</a>
<a name="ln5526"> </a>
<a name="ln5527">  if (badlen == 0 &amp;&amp; goodlen == 0)</a>
<a name="ln5528">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln5529">    // the first &quot;the&quot; to itself.</a>
<a name="ln5530">    return;</a>
<a name="ln5531"> </a>
<a name="ln5532">  int i;</a>
<a name="ln5533">  if (GA_EMPTY(gap)) {</a>
<a name="ln5534">    i = -1;</a>
<a name="ln5535">  } else {</a>
<a name="ln5536">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln5537">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln5538">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln5539">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln5540">    for (i = gap-&gt;ga_len; --i &gt;= 0; ++stp) {</a>
<a name="ln5541">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln5542">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln5543">          &amp;&amp; STRNCMP(stp-&gt;st_word, goodword, goodlen) == 0) {</a>
<a name="ln5544">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln5545">        if (stp-&gt;st_slang == NULL)</a>
<a name="ln5546">          stp-&gt;st_slang = slang;</a>
<a name="ln5547"> </a>
<a name="ln5548">        new_sug.st_score = score;</a>
<a name="ln5549">        new_sug.st_altscore = altscore;</a>
<a name="ln5550">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln5551"> </a>
<a name="ln5552">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln5553">          // Only one of the two had the soundalike score computed.</a>
<a name="ln5554">          // Need to do that for the other one now, otherwise the</a>
<a name="ln5555">          // scores can't be compared.  This happens because</a>
<a name="ln5556">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln5557">          // word to keep it fast, while some special methods set</a>
<a name="ln5558">          // the soundalike score to zero.</a>
<a name="ln5559">          if (had_bonus)</a>
<a name="ln5560">            rescore_one(su, stp);</a>
<a name="ln5561">          else {</a>
<a name="ln5562">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln5563">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln5564">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln5565">            new_sug.st_orglen = badlen;</a>
<a name="ln5566">            rescore_one(su, &amp;new_sug);</a>
<a name="ln5567">          }</a>
<a name="ln5568">        }</a>
<a name="ln5569"> </a>
<a name="ln5570">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln5571">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln5572">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln5573">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln5574">        }</a>
<a name="ln5575">        break;</a>
<a name="ln5576">      }</a>
<a name="ln5577">    }</a>
<a name="ln5578">  }</a>
<a name="ln5579"> </a>
<a name="ln5580">  if (i &lt; 0) {</a>
<a name="ln5581">    // Add a suggestion.</a>
<a name="ln5582">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln5583">    stp-&gt;st_word = vim_strnsave(goodword, goodlen);</a>
<a name="ln5584">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln5585">    stp-&gt;st_score = score;</a>
<a name="ln5586">    stp-&gt;st_altscore = altscore;</a>
<a name="ln5587">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln5588">    stp-&gt;st_orglen = badlen;</a>
<a name="ln5589">    stp-&gt;st_slang = slang;</a>
<a name="ln5590"> </a>
<a name="ln5591">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln5592">    // the best suggestions.</a>
<a name="ln5593">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln5594">      if (maxsf)</a>
<a name="ln5595">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln5596">            su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5597">      else</a>
<a name="ln5598">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln5599">            su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5600">    }</a>
<a name="ln5601">  }</a>
<a name="ln5602">}</a>
<a name="ln5603"> </a>
<a name="ln5604">// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln5605">// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln5606">static void</a>
<a name="ln5607">check_suggestions (</a>
<a name="ln5608">    suginfo_T *su,</a>
<a name="ln5609">    garray_T *gap                   // either su_ga or su_sga</a>
<a name="ln5610">)</a>
<a name="ln5611">{</a>
<a name="ln5612">  suggest_T   *stp;</a>
<a name="ln5613">  char_u longword[MAXWLEN + 1];</a>
<a name="ln5614">  int len;</a>
<a name="ln5615">  hlf_T attr;</a>
<a name="ln5616"> </a>
<a name="ln5617">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln5618">    return;</a>
<a name="ln5619">  }</a>
<a name="ln5620">  stp = &amp;SUG(*gap, 0);</a>
<a name="ln5621">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln5622">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln5623">    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln5624">    len = stp[i].st_wordlen;</a>
<a name="ln5625">    STRLCPY(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln5626">        MAXWLEN - len + 1);</a>
<a name="ln5627">    attr = HLF_COUNT;</a>
<a name="ln5628">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln5629">    if (attr != HLF_COUNT) {</a>
<a name="ln5630">      // Remove this entry.</a>
<a name="ln5631">      xfree(stp[i].st_word);</a>
<a name="ln5632">      --gap-&gt;ga_len;</a>
<a name="ln5633">      if (i &lt; gap-&gt;ga_len)</a>
<a name="ln5634">        memmove(stp + i, stp + i + 1,</a>
<a name="ln5635">            sizeof(suggest_T) * (gap-&gt;ga_len - i));</a>
<a name="ln5636">    }</a>
<a name="ln5637">  }</a>
<a name="ln5638">}</a>
<a name="ln5639"> </a>
<a name="ln5640"> </a>
<a name="ln5641">// Add a word to be banned.</a>
<a name="ln5642">static void add_banned(suginfo_T *su, char_u *word)</a>
<a name="ln5643">{</a>
<a name="ln5644">  char_u      *s;</a>
<a name="ln5645">  hash_T hash;</a>
<a name="ln5646">  hashitem_T  *hi;</a>
<a name="ln5647"> </a>
<a name="ln5648">  hash = hash_hash(word);</a>
<a name="ln5649">  const size_t word_len = STRLEN(word);</a>
<a name="ln5650">  hi = hash_lookup(&amp;su-&gt;su_banned, (const char *)word, word_len, hash);</a>
<a name="ln5651">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5652">    s = xmemdupz(word, word_len);</a>
<a name="ln5653">    hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln5654">  }</a>
<a name="ln5655">}</a>
<a name="ln5656"> </a>
<a name="ln5657">// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln5658">// is slow, thus only done for the final results.</a>
<a name="ln5659">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln5660">{</a>
<a name="ln5661">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln5662">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5663">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln5664">    }</a>
<a name="ln5665">  }</a>
<a name="ln5666">}</a>
<a name="ln5667"> </a>
<a name="ln5668">// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln5669">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln5670">{</a>
<a name="ln5671">  slang_T     *slang = stp-&gt;st_slang;</a>
<a name="ln5672">  char_u sal_badword[MAXWLEN];</a>
<a name="ln5673">  char_u      *p;</a>
<a name="ln5674"> </a>
<a name="ln5675">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln5676">  // language.</a>
<a name="ln5677">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln5678">    if (slang == su-&gt;su_sallang)</a>
<a name="ln5679">      p = su-&gt;su_sal_badword;</a>
<a name="ln5680">    else {</a>
<a name="ln5681">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln5682">      p = sal_badword;</a>
<a name="ln5683">    }</a>
<a name="ln5684"> </a>
<a name="ln5685">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln5686">    if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln5687">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln5688">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln5689">    stp-&gt;st_had_bonus = true;</a>
<a name="ln5690">  }</a>
<a name="ln5691">}</a>
<a name="ln5692"> </a>
<a name="ln5693"> </a>
<a name="ln5694">// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln5695">// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln5696">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln5697">{</a>
<a name="ln5698">  suggest_T   *p1 = (suggest_T *)s1;</a>
<a name="ln5699">  suggest_T   *p2 = (suggest_T *)s2;</a>
<a name="ln5700">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln5701"> </a>
<a name="ln5702">  if (n == 0) {</a>
<a name="ln5703">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln5704">    if (n == 0)</a>
<a name="ln5705">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln5706">  }</a>
<a name="ln5707">  return n;</a>
<a name="ln5708">}</a>
<a name="ln5709"> </a>
<a name="ln5710">// Cleanup the suggestions:</a>
<a name="ln5711">// - Sort on score.</a>
<a name="ln5712">// - Remove words that won't be displayed.</a>
<a name="ln5713">// Returns the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln5714">static int</a>
<a name="ln5715">cleanup_suggestions (</a>
<a name="ln5716">    garray_T *gap,</a>
<a name="ln5717">    int maxscore,</a>
<a name="ln5718">    int keep                       // nr of suggestions to keep</a>
<a name="ln5719">)</a>
<a name="ln5720">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5721">{</a>
<a name="ln5722">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5723">    // Sort the list.</a>
<a name="ln5724">    qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln5725"> </a>
<a name="ln5726">    // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5727">    if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln5728">      suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln5729"> </a>
<a name="ln5730">      for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln5731">        xfree(stp[i].st_word);</a>
<a name="ln5732">      }</a>
<a name="ln5733">      gap-&gt;ga_len = keep;</a>
<a name="ln5734">      return stp[keep - 1].st_score;</a>
<a name="ln5735">    }</a>
<a name="ln5736">  }</a>
<a name="ln5737">  return maxscore;</a>
<a name="ln5738">}</a>
<a name="ln5739"> </a>
<a name="ln5740">/// Soundfold a string, for soundfold()</a>
<a name="ln5741">///</a>
<a name="ln5742">/// @param[in]  word  Word to soundfold.</a>
<a name="ln5743">///</a>
<a name="ln5744">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln5745">///                     copy of the input string if soundfolding is not</a>
<a name="ln5746">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln5747">char *eval_soundfold(const char *const word)</a>
<a name="ln5748">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5749">{</a>
<a name="ln5750">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln5751">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln5752">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln5753">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5754">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5755">        // soundfold the word</a>
<a name="ln5756">        char_u sound[MAXWLEN];</a>
<a name="ln5757">        spell_soundfold(lp-&gt;lp_slang, (char_u *)word, false, sound);</a>
<a name="ln5758">        return xstrdup((const char *)sound);</a>
<a name="ln5759">      }</a>
<a name="ln5760">    }</a>
<a name="ln5761">  }</a>
<a name="ln5762"> </a>
<a name="ln5763">  // No language with sound folding, return word as-is.</a>
<a name="ln5764">  return xstrdup(word);</a>
<a name="ln5765">}</a>
<a name="ln5766"> </a>
<a name="ln5767">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5768">///</a>
<a name="ln5769">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln5770">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln5771">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln5772">/// Erikson.</a>
<a name="ln5773">///</a>
<a name="ln5774">/// We support two methods:</a>
<a name="ln5775">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln5776">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln5777">///</a>
<a name="ln5778">/// @param[in]  slang</a>
<a name="ln5779">/// @param[in]  inword  word to soundfold</a>
<a name="ln5780">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln5781">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln5782">void spell_soundfold(slang_T *slang, char_u *inword, bool folded, char_u *res)</a>
<a name="ln5783">{</a>
<a name="ln5784">  char_u fword[MAXWLEN];</a>
<a name="ln5785">  char_u      *word;</a>
<a name="ln5786"> </a>
<a name="ln5787">  if (slang-&gt;sl_sofo)</a>
<a name="ln5788">    // SOFOFROM and SOFOTO used</a>
<a name="ln5789">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln5790">  else {</a>
<a name="ln5791">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln5792">    if (folded)</a>
<a name="ln5793">      word = inword;</a>
<a name="ln5794">    else {</a>
<a name="ln5795">      (void)spell_casefold(inword, (int)STRLEN(inword), fword, MAXWLEN);</a>
<a name="ln5796">      word = fword;</a>
<a name="ln5797">    }</a>
<a name="ln5798"> </a>
<a name="ln5799">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln5800">  }</a>
<a name="ln5801">}</a>
<a name="ln5802"> </a>
<a name="ln5803">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln5804">// SOFOTO lines.</a>
<a name="ln5805">static void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5806">{</a>
<a name="ln5807">  int ri = 0;</a>
<a name="ln5808"> </a>
<a name="ln5809">  int prevc = 0;</a>
<a name="ln5810"> </a>
<a name="ln5811">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln5812">  // 255, sl_sal the rest.</a>
<a name="ln5813">  for (char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5814">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5815">    if (utf_class(c) == 0) {</a>
<a name="ln5816">      c = ' ';</a>
<a name="ln5817">    } else if (c &lt; 256) {</a>
<a name="ln5818">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln5819">    } else {</a>
<a name="ln5820">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln5821">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln5822">        c = NUL;</a>
<a name="ln5823">      } else {</a>
<a name="ln5824">        for (;; ) {                   // find &quot;c&quot; in the list</a>
<a name="ln5825">          if (*ip == 0) {             // not found</a>
<a name="ln5826">            c = NUL;</a>
<a name="ln5827">            break;</a>
<a name="ln5828">          }</a>
<a name="ln5829">          if (*ip == c) {             // match!</a>
<a name="ln5830">            c = ip[1];</a>
<a name="ln5831">            break;</a>
<a name="ln5832">          }</a>
<a name="ln5833">          ip += 2;</a>
<a name="ln5834">        }</a>
<a name="ln5835">      }</a>
<a name="ln5836">    }</a>
<a name="ln5837"> </a>
<a name="ln5838">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln5839">      ri += utf_char2bytes(c, res + ri);</a>
<a name="ln5840">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln5841">        break;</a>
<a name="ln5842">      }</a>
<a name="ln5843">      prevc = c;</a>
<a name="ln5844">    }</a>
<a name="ln5845">  }</a>
<a name="ln5846"> </a>
<a name="ln5847">  res[ri] = NUL;</a>
<a name="ln5848">}</a>
<a name="ln5849"> </a>
<a name="ln5850">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5851">// Multi-byte version of spell_soundfold().</a>
<a name="ln5852">static void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5853">{</a>
<a name="ln5854">  salitem_T   *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln5855">  int word[MAXWLEN] = { 0 };</a>
<a name="ln5856">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln5857">  int l;</a>
<a name="ln5858">  int         *ws;</a>
<a name="ln5859">  int         *pf;</a>
<a name="ln5860">  int i, j, z;</a>
<a name="ln5861">  int reslen;</a>
<a name="ln5862">  int n, k = 0;</a>
<a name="ln5863">  int z0;</a>
<a name="ln5864">  int k0;</a>
<a name="ln5865">  int n0;</a>
<a name="ln5866">  int c;</a>
<a name="ln5867">  int pri;</a>
<a name="ln5868">  int p0 = -333;</a>
<a name="ln5869">  int c0;</a>
<a name="ln5870">  bool did_white = false;</a>
<a name="ln5871">  int wordlen;</a>
<a name="ln5872"> </a>
<a name="ln5873"> </a>
<a name="ln5874">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln5875">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln5876">  // But keep white space.</a>
<a name="ln5877">  wordlen = 0;</a>
<a name="ln5878">  for (const char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5879">    const char_u *t = s;</a>
<a name="ln5880">    c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5881">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln5882">      if (utf_class(c) == 0) {</a>
<a name="ln5883">        if (did_white) {</a>
<a name="ln5884">          continue;</a>
<a name="ln5885">        }</a>
<a name="ln5886">        c = ' ';</a>
<a name="ln5887">        did_white = true;</a>
<a name="ln5888">      } else {</a>
<a name="ln5889">        did_white = false;</a>
<a name="ln5890">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln5891">          continue;</a>
<a name="ln5892">        }</a>
<a name="ln5893">      }</a>
<a name="ln5894">    }</a>
<a name="ln5895">    word[wordlen++] = c;</a>
<a name="ln5896">  }</a>
<a name="ln5897">  word[wordlen] = NUL;</a>
<a name="ln5898"> </a>
<a name="ln5899">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln5900">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln5901">  // Changed to keep spaces.</a>
<a name="ln5902">  i = reslen = z = 0;</a>
<a name="ln5903">  while ((c = word[i]) != NUL) {</a>
<a name="ln5904">    // Start with the first rule that has the character in the word.</a>
<a name="ln5905">    n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln5906">    z0 = 0;</a>
<a name="ln5907"> </a>
<a name="ln5908">    if (n &gt;= 0) {</a>
<a name="ln5909">      // Check all rules for the same index byte.</a>
<a name="ln5910">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln5911">      // (c &amp; 0xff) is NUL.</a>
<a name="ln5912">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln5913">           &amp;&amp; ws[0] != NUL; ++n) {</a>
<a name="ln5914">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln5915">        // entries are less then three chars, optimize for that.</a>
<a name="ln5916">        if (c != ws[0])</a>
<a name="ln5917">          continue;</a>
<a name="ln5918">        k = smp[n].sm_leadlen;</a>
<a name="ln5919">        if (k &gt; 1) {</a>
<a name="ln5920">          if (word[i + 1] != ws[1])</a>
<a name="ln5921">            continue;</a>
<a name="ln5922">          if (k &gt; 2) {</a>
<a name="ln5923">            for (j = 2; j &lt; k; ++j)</a>
<a name="ln5924">              if (word[i + j] != ws[j])</a>
<a name="ln5925">                break;</a>
<a name="ln5926">            if (j &lt; k)</a>
<a name="ln5927">              continue;</a>
<a name="ln5928">          }</a>
<a name="ln5929">        }</a>
<a name="ln5930"> </a>
<a name="ln5931">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln5932">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln5933">          while (*pf != NUL &amp;&amp; *pf != word[i + k])</a>
<a name="ln5934">            ++pf;</a>
<a name="ln5935">          if (*pf == NUL)</a>
<a name="ln5936">            continue;</a>
<a name="ln5937">          ++k;</a>
<a name="ln5938">        }</a>
<a name="ln5939">        char_u *s = smp[n].sm_rules;</a>
<a name="ln5940">        pri = 5;            // default priority</a>
<a name="ln5941"> </a>
<a name="ln5942">        p0 = *s;</a>
<a name="ln5943">        k0 = k;</a>
<a name="ln5944">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln5945">          k--;</a>
<a name="ln5946">          s++;</a>
<a name="ln5947">        }</a>
<a name="ln5948">        if (*s == '&lt;')</a>
<a name="ln5949">          s++;</a>
<a name="ln5950">        if (ascii_isdigit(*s)) {</a>
<a name="ln5951">          // determine priority</a>
<a name="ln5952">          pri = *s - '0';</a>
<a name="ln5953">          s++;</a>
<a name="ln5954">        }</a>
<a name="ln5955">        if (*s == '^' &amp;&amp; *(s + 1) == '^')</a>
<a name="ln5956">          s++;</a>
<a name="ln5957"> </a>
<a name="ln5958">        if (*s == NUL</a>
<a name="ln5959">            || (*s == '^'</a>
<a name="ln5960">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln5961">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln5962">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln5963">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln5964">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln5965">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln5966">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln5967">          // search for followup rules, if:</a>
<a name="ln5968">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln5969">          c0 = word[i + k - 1];</a>
<a name="ln5970">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln5971"> </a>
<a name="ln5972">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln5973">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln5974">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln5975">            // all entries with the same index byte.</a>
<a name="ln5976">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln5977">                 == (c0 &amp; 0xff); ++n0) {</a>
<a name="ln5978">              // Quickly skip entries that don't match the word.</a>
<a name="ln5979">              if (c0 != ws[0])</a>
<a name="ln5980">                continue;</a>
<a name="ln5981">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln5982">              if (k0 &gt; 1) {</a>
<a name="ln5983">                if (word[i + k] != ws[1])</a>
<a name="ln5984">                  continue;</a>
<a name="ln5985">                if (k0 &gt; 2) {</a>
<a name="ln5986">                  pf = word + i + k + 1;</a>
<a name="ln5987">                  for (j = 2; j &lt; k0; ++j)</a>
<a name="ln5988">                    if (*pf++ != ws[j])</a>
<a name="ln5989">                      break;</a>
<a name="ln5990">                  if (j &lt; k0)</a>
<a name="ln5991">                    continue;</a>
<a name="ln5992">                }</a>
<a name="ln5993">              }</a>
<a name="ln5994">              k0 += k - 1;</a>
<a name="ln5995"> </a>
<a name="ln5996">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln5997">                // Check for match with one of the chars in</a>
<a name="ln5998">                // &quot;sm_oneof&quot;.</a>
<a name="ln5999">                while (*pf != NUL &amp;&amp; *pf != word[i + k0])</a>
<a name="ln6000">                  ++pf;</a>
<a name="ln6001">                if (*pf == NUL)</a>
<a name="ln6002">                  continue;</a>
<a name="ln6003">                ++k0;</a>
<a name="ln6004">              }</a>
<a name="ln6005"> </a>
<a name="ln6006">              p0 = 5;</a>
<a name="ln6007">              s = smp[n0].sm_rules;</a>
<a name="ln6008">              while (*s == '-') {</a>
<a name="ln6009">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln6010">                // &quot;if (k0 == k)&quot;</a>
<a name="ln6011">                s++;</a>
<a name="ln6012">              }</a>
<a name="ln6013">              if (*s == '&lt;')</a>
<a name="ln6014">                s++;</a>
<a name="ln6015">              if (ascii_isdigit(*s)) {</a>
<a name="ln6016">                p0 = *s - '0';</a>
<a name="ln6017">                s++;</a>
<a name="ln6018">              }</a>
<a name="ln6019"> </a>
<a name="ln6020">              if (*s == NUL</a>
<a name="ln6021">                  // *s == '^' cuts</a>
<a name="ln6022">                  || (*s == '$'</a>
<a name="ln6023">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln6024">                          curwin))) {</a>
<a name="ln6025">                if (k0 == k)</a>
<a name="ln6026">                  // this is just a piece of the string</a>
<a name="ln6027">                  continue;</a>
<a name="ln6028"> </a>
<a name="ln6029">                if (p0 &lt; pri)</a>
<a name="ln6030">                  // priority too low</a>
<a name="ln6031">                  continue;</a>
<a name="ln6032">                // rule fits; stop search</a>
<a name="ln6033">                break;</a>
<a name="ln6034">              }</a>
<a name="ln6035">            }</a>
<a name="ln6036"> </a>
<a name="ln6037">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln6038">                == (c0 &amp; 0xff))</a>
<a name="ln6039">              continue;</a>
<a name="ln6040">          }</a>
<a name="ln6041"> </a>
<a name="ln6042">          // replace string</a>
<a name="ln6043">          ws = smp[n].sm_to_w;</a>
<a name="ln6044">          s = smp[n].sm_rules;</a>
<a name="ln6045">          p0 = (vim_strchr(s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln6046">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln6047">            // rule with '&lt;' is used</a>
<a name="ln6048">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln6049">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln6050">                    || wres[reslen - 1] == *ws))</a>
<a name="ln6051">              reslen--;</a>
<a name="ln6052">            z0 = 1;</a>
<a name="ln6053">            z = 1;</a>
<a name="ln6054">            k0 = 0;</a>
<a name="ln6055">            if (ws != NULL)</a>
<a name="ln6056">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln6057">                word[i + k0] = *ws;</a>
<a name="ln6058">                k0++;</a>
<a name="ln6059">                ws++;</a>
<a name="ln6060">              }</a>
<a name="ln6061">            if (k &gt; k0)</a>
<a name="ln6062">              memmove(word + i + k0, word + i + k,</a>
<a name="ln6063">                  sizeof(int) * (wordlen - (i + k) + 1));</a>
<a name="ln6064"> </a>
<a name="ln6065">            // new &quot;actual letter&quot;</a>
<a name="ln6066">            c = word[i];</a>
<a name="ln6067">          } else {</a>
<a name="ln6068">            // no '&lt;' rule used</a>
<a name="ln6069">            i += k - 1;</a>
<a name="ln6070">            z = 0;</a>
<a name="ln6071">            if (ws != NULL)</a>
<a name="ln6072">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln6073">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln6074">                if (reslen == 0 || wres[reslen - 1] != *ws)</a>
<a name="ln6075">                  wres[reslen++] = *ws;</a>
<a name="ln6076">                ws++;</a>
<a name="ln6077">              }</a>
<a name="ln6078">            // new &quot;actual letter&quot;</a>
<a name="ln6079">            if (ws == NULL)</a>
<a name="ln6080">              c = NUL;</a>
<a name="ln6081">            else</a>
<a name="ln6082">              c = *ws;</a>
<a name="ln6083">            if (strstr((char *)s, &quot;^^&quot;) != NULL) {</a>
<a name="ln6084">              if (c != NUL)</a>
<a name="ln6085">                wres[reslen++] = c;</a>
<a name="ln6086">              memmove(word, word + i + 1,</a>
<a name="ln6087">                  sizeof(int) * (wordlen - (i + 1) + 1));</a>
<a name="ln6088">              i = 0;</a>
<a name="ln6089">              z0 = 1;</a>
<a name="ln6090">            }</a>
<a name="ln6091">          }</a>
<a name="ln6092">          break;</a>
<a name="ln6093">        }</a>
<a name="ln6094">      }</a>
<a name="ln6095">    } else if (ascii_iswhite(c))   {</a>
<a name="ln6096">      c = ' ';</a>
<a name="ln6097">      k = 1;</a>
<a name="ln6098">    }</a>
<a name="ln6099"> </a>
<a name="ln6100">    if (z0 == 0) {</a>
<a name="ln6101">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln6102">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln6103">              || wres[reslen - 1] != c))</a>
<a name="ln6104">        // condense only double letters</a>
<a name="ln6105">        wres[reslen++] = c;</a>
<a name="ln6106"> </a>
<a name="ln6107">      i++;</a>
<a name="ln6108">      z = 0;</a>
<a name="ln6109">      k = 0;</a>
<a name="ln6110">    }</a>
<a name="ln6111">  }</a>
<a name="ln6112"> </a>
<a name="ln6113">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln6114">  l = 0;</a>
<a name="ln6115">  for (n = 0; n &lt; reslen; n++) {</a>
<a name="ln6116">    l += utf_char2bytes(wres[n], res + l);</a>
<a name="ln6117">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln6118">      break;</a>
<a name="ln6119">    }</a>
<a name="ln6120">  }</a>
<a name="ln6121">  res[l] = NUL;</a>
<a name="ln6122">}</a>
<a name="ln6123"> </a>
<a name="ln6124">// Compute a score for two sound-a-like words.</a>
<a name="ln6125">// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln6126">// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln6127">// avoiding checks that will not be possible.</a>
<a name="ln6128">static int</a>
<a name="ln6129">soundalike_score (</a>
<a name="ln6130">    char_u *goodstart,         // sound-folded good word</a>
<a name="ln6131">    char_u *badstart          // sound-folded bad word</a>
<a name="ln6132">)</a>
<a name="ln6133">{</a>
<a name="ln6134">  char_u      *goodsound = goodstart;</a>
<a name="ln6135">  char_u      *badsound = badstart;</a>
<a name="ln6136">  int goodlen;</a>
<a name="ln6137">  int badlen;</a>
<a name="ln6138">  int n;</a>
<a name="ln6139">  char_u      *pl, *ps;</a>
<a name="ln6140">  char_u      *pl2, *ps2;</a>
<a name="ln6141">  int score = 0;</a>
<a name="ln6142"> </a>
<a name="ln6143">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln6144">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln6145">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln6146">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln6147">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL))</a>
<a name="ln6148">      // changing word with vowel to word without a sound</a>
<a name="ln6149">      return SCORE_DEL;</a>
<a name="ln6150">    if (badsound[0] == NUL || goodsound[0] == NUL)</a>
<a name="ln6151">      // more than two changes</a>
<a name="ln6152">      return SCORE_MAXMAX;</a>
<a name="ln6153"> </a>
<a name="ln6154">    if (badsound[1] == goodsound[1]</a>
<a name="ln6155">        || (badsound[1] != NUL</a>
<a name="ln6156">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln6157">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln6158">      // handle like a substitute</a>
<a name="ln6159">    } else {</a>
<a name="ln6160">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln6161">      if (*badsound == '*')</a>
<a name="ln6162">        ++badsound;</a>
<a name="ln6163">      else</a>
<a name="ln6164">        ++goodsound;</a>
<a name="ln6165">    }</a>
<a name="ln6166">  }</a>
<a name="ln6167"> </a>
<a name="ln6168">  goodlen = (int)STRLEN(goodsound);</a>
<a name="ln6169">  badlen = (int)STRLEN(badsound);</a>
<a name="ln6170"> </a>
<a name="ln6171">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln6172">  // changes.</a>
<a name="ln6173">  n = goodlen - badlen;</a>
<a name="ln6174">  if (n &lt; -2 || n &gt; 2)</a>
<a name="ln6175">    return SCORE_MAXMAX;</a>
<a name="ln6176"> </a>
<a name="ln6177">  if (n &gt; 0) {</a>
<a name="ln6178">    pl = goodsound;         // goodsound is longest</a>
<a name="ln6179">    ps = badsound;</a>
<a name="ln6180">  } else {</a>
<a name="ln6181">    pl = badsound;          // badsound is longest</a>
<a name="ln6182">    ps = goodsound;</a>
<a name="ln6183">  }</a>
<a name="ln6184"> </a>
<a name="ln6185">  // Skip over the identical part.</a>
<a name="ln6186">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln6187">    ++pl;</a>
<a name="ln6188">    ++ps;</a>
<a name="ln6189">  }</a>
<a name="ln6190"> </a>
<a name="ln6191">  switch (n) {</a>
<a name="ln6192">  case -2:</a>
<a name="ln6193">  case 2:</a>
<a name="ln6194">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln6195">    ++pl;               // first delete</a>
<a name="ln6196">    while (*pl == *ps) {</a>
<a name="ln6197">      ++pl;</a>
<a name="ln6198">      ++ps;</a>
<a name="ln6199">    }</a>
<a name="ln6200">    // strings must be equal after second delete</a>
<a name="ln6201">    if (STRCMP(pl + 1, ps) == 0)</a>
<a name="ln6202">      return score + SCORE_DEL * 2;</a>
<a name="ln6203"> </a>
<a name="ln6204">    // Failed to compare.</a>
<a name="ln6205">    break;</a>
<a name="ln6206"> </a>
<a name="ln6207">  case -1:</a>
<a name="ln6208">  case 1:</a>
<a name="ln6209">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln6210"> </a>
<a name="ln6211">    // 1: delete</a>
<a name="ln6212">    pl2 = pl + 1;</a>
<a name="ln6213">    ps2 = ps;</a>
<a name="ln6214">    while (*pl2 == *ps2) {</a>
<a name="ln6215">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6216">        return score + SCORE_DEL;</a>
<a name="ln6217">      ++pl2;</a>
<a name="ln6218">      ++ps2;</a>
<a name="ln6219">    }</a>
<a name="ln6220"> </a>
<a name="ln6221">    // 2: delete then swap, then rest must be equal</a>
<a name="ln6222">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6223">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6224">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln6225"> </a>
<a name="ln6226">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln6227">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6228">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln6229"> </a>
<a name="ln6230">    // 4: first swap then delete</a>
<a name="ln6231">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6232">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6233">      ps2 = ps + 2;</a>
<a name="ln6234">      while (*pl2 == *ps2) {</a>
<a name="ln6235">        ++pl2;</a>
<a name="ln6236">        ++ps2;</a>
<a name="ln6237">      }</a>
<a name="ln6238">      // delete a char and then strings must be equal</a>
<a name="ln6239">      if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6240">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln6241">    }</a>
<a name="ln6242"> </a>
<a name="ln6243">    // 5: first substitute then delete</a>
<a name="ln6244">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln6245">    ps2 = ps + 1;</a>
<a name="ln6246">    while (*pl2 == *ps2) {</a>
<a name="ln6247">      ++pl2;</a>
<a name="ln6248">      ++ps2;</a>
<a name="ln6249">    }</a>
<a name="ln6250">    // delete a char and then strings must be equal</a>
<a name="ln6251">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6252">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln6253"> </a>
<a name="ln6254">    // Failed to compare.</a>
<a name="ln6255">    break;</a>
<a name="ln6256"> </a>
<a name="ln6257">  case 0:</a>
<a name="ln6258">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln6259">    // insert is only possible in combination with a delete.</a>
<a name="ln6260">    // 1: check if for identical strings</a>
<a name="ln6261">    if (*pl == NUL)</a>
<a name="ln6262">      return score;</a>
<a name="ln6263"> </a>
<a name="ln6264">    // 2: swap</a>
<a name="ln6265">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6266">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6267">      ps2 = ps + 2;</a>
<a name="ln6268">      while (*pl2 == *ps2) {</a>
<a name="ln6269">        if (*pl2 == NUL)                // reached the end</a>
<a name="ln6270">          return score + SCORE_SWAP;</a>
<a name="ln6271">        ++pl2;</a>
<a name="ln6272">        ++ps2;</a>
<a name="ln6273">      }</a>
<a name="ln6274">      // 3: swap and swap again</a>
<a name="ln6275">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6276">          &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6277">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln6278"> </a>
<a name="ln6279">      // 4: swap and substitute</a>
<a name="ln6280">      if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6281">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln6282">    }</a>
<a name="ln6283"> </a>
<a name="ln6284">    // 5: substitute</a>
<a name="ln6285">    pl2 = pl + 1;</a>
<a name="ln6286">    ps2 = ps + 1;</a>
<a name="ln6287">    while (*pl2 == *ps2) {</a>
<a name="ln6288">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6289">        return score + SCORE_SUBST;</a>
<a name="ln6290">      ++pl2;</a>
<a name="ln6291">      ++ps2;</a>
<a name="ln6292">    }</a>
<a name="ln6293"> </a>
<a name="ln6294">    // 6: substitute and swap</a>
<a name="ln6295">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6296">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6297">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln6298"> </a>
<a name="ln6299">    // 7: substitute and substitute</a>
<a name="ln6300">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6301">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln6302"> </a>
<a name="ln6303">    // 8: insert then delete</a>
<a name="ln6304">    pl2 = pl;</a>
<a name="ln6305">    ps2 = ps + 1;</a>
<a name="ln6306">    while (*pl2 == *ps2) {</a>
<a name="ln6307">      ++pl2;</a>
<a name="ln6308">      ++ps2;</a>
<a name="ln6309">    }</a>
<a name="ln6310">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6311">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6312"> </a>
<a name="ln6313">    // 9: delete then insert</a>
<a name="ln6314">    pl2 = pl + 1;</a>
<a name="ln6315">    ps2 = ps;</a>
<a name="ln6316">    while (*pl2 == *ps2) {</a>
<a name="ln6317">      ++pl2;</a>
<a name="ln6318">      ++ps2;</a>
<a name="ln6319">    }</a>
<a name="ln6320">    if (STRCMP(pl2, ps2 + 1) == 0)</a>
<a name="ln6321">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6322"> </a>
<a name="ln6323">    // Failed to compare.</a>
<a name="ln6324">    break;</a>
<a name="ln6325">  }</a>
<a name="ln6326"> </a>
<a name="ln6327">  return SCORE_MAXMAX;</a>
<a name="ln6328">}</a>
<a name="ln6329"> </a>
<a name="ln6330">// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln6331">// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln6332">//</a>
<a name="ln6333">// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln6334">// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln6335">// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln6336">// support multi-byte characters.</a>
<a name="ln6337">static int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword)</a>
<a name="ln6338">{</a>
<a name="ln6339">  int *cnt;</a>
<a name="ln6340">  int j, i;</a>
<a name="ln6341">  int t;</a>
<a name="ln6342">  int bc, gc;</a>
<a name="ln6343">  int pbc, pgc;</a>
<a name="ln6344">  int wbadword[MAXWLEN];</a>
<a name="ln6345">  int wgoodword[MAXWLEN];</a>
<a name="ln6346"> </a>
<a name="ln6347">  // Lengths with NUL.</a>
<a name="ln6348">  int badlen;</a>
<a name="ln6349">  int goodlen;</a>
<a name="ln6350">  {</a>
<a name="ln6351">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6352">    // int array for easy access.</a>
<a name="ln6353">    badlen = 0;</a>
<a name="ln6354">    for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6355">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6356">    }</a>
<a name="ln6357">    wbadword[badlen++] = 0;</a>
<a name="ln6358">    goodlen = 0;</a>
<a name="ln6359">    for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6360">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6361">    }</a>
<a name="ln6362">    wgoodword[goodlen++] = 0;</a>
<a name="ln6363">  }</a>
<a name="ln6364"> </a>
<a name="ln6365">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln6366">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln6367">  cnt = xmalloc(sizeof(int) * (badlen + 1) * (goodlen + 1));</a>
<a name="ln6368"> </a>
<a name="ln6369">  CNT(0, 0) = 0;</a>
<a name="ln6370">  for (j = 1; j &lt;= goodlen; ++j)</a>
<a name="ln6371">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln6372"> </a>
<a name="ln6373">  for (i = 1; i &lt;= badlen; ++i) {</a>
<a name="ln6374">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln6375">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln6376">      bc = wbadword[i - 1];</a>
<a name="ln6377">      gc = wgoodword[j - 1];</a>
<a name="ln6378">      if (bc == gc) {</a>
<a name="ln6379">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln6380">      } else {</a>
<a name="ln6381">        // Use a better score when there is only a case difference.</a>
<a name="ln6382">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6383">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln6384">        else {</a>
<a name="ln6385">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6386">          if (slang != NULL</a>
<a name="ln6387">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6388">              &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6389">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln6390">          else</a>
<a name="ln6391">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln6392">        }</a>
<a name="ln6393"> </a>
<a name="ln6394">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln6395">          pbc = wbadword[i - 2];</a>
<a name="ln6396">          pgc = wgoodword[j - 2];</a>
<a name="ln6397">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln6398">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln6399">            if (t &lt; CNT(i, j))</a>
<a name="ln6400">              CNT(i, j) = t;</a>
<a name="ln6401">          }</a>
<a name="ln6402">        }</a>
<a name="ln6403">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln6404">        if (t &lt; CNT(i, j))</a>
<a name="ln6405">          CNT(i, j) = t;</a>
<a name="ln6406">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln6407">        if (t &lt; CNT(i, j))</a>
<a name="ln6408">          CNT(i, j) = t;</a>
<a name="ln6409">      }</a>
<a name="ln6410">    }</a>
<a name="ln6411">  }</a>
<a name="ln6412"> </a>
<a name="ln6413">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln6414">  xfree(cnt);</a>
<a name="ln6415">  return i;</a>
<a name="ln6416">}</a>
<a name="ln6417"> </a>
<a name="ln6418">// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln6419">// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln6420">//</a>
<a name="ln6421">// This uses a stack for the edits still to be tried.</a>
<a name="ln6422">// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln6423">// for multi-byte characters.</a>
<a name="ln6424">static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6425">{</a>
<a name="ln6426">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln6427">}</a>
<a name="ln6428"> </a>
<a name="ln6429">// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln6430">// Keep it in sync with the above!</a>
<a name="ln6431">static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6432">{</a>
<a name="ln6433">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln6434">  int stackidx;</a>
<a name="ln6435">  int bi, gi;</a>
<a name="ln6436">  int bi2, gi2;</a>
<a name="ln6437">  int bc, gc;</a>
<a name="ln6438">  int score;</a>
<a name="ln6439">  int score_off;</a>
<a name="ln6440">  int minscore;</a>
<a name="ln6441">  int round;</a>
<a name="ln6442">  int wbadword[MAXWLEN];</a>
<a name="ln6443">  int wgoodword[MAXWLEN];</a>
<a name="ln6444"> </a>
<a name="ln6445">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6446">  // int array for easy access.</a>
<a name="ln6447">  bi = 0;</a>
<a name="ln6448">  for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6449">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6450">  }</a>
<a name="ln6451">  wbadword[bi++] = 0;</a>
<a name="ln6452">  gi = 0;</a>
<a name="ln6453">  for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6454">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6455">  }</a>
<a name="ln6456">  wgoodword[gi++] = 0;</a>
<a name="ln6457"> </a>
<a name="ln6458">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln6459">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln6460">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln6461">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln6462">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln6463">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln6464">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln6465">  stackidx = 0;</a>
<a name="ln6466">  bi = 0;</a>
<a name="ln6467">  gi = 0;</a>
<a name="ln6468">  score = 0;</a>
<a name="ln6469">  minscore = limit + 1;</a>
<a name="ln6470"> </a>
<a name="ln6471">  for (;; ) {</a>
<a name="ln6472">    // Skip over an equal part, score remains the same.</a>
<a name="ln6473">    for (;; ) {</a>
<a name="ln6474">      bc = wbadword[bi];</a>
<a name="ln6475">      gc = wgoodword[gi];</a>
<a name="ln6476"> </a>
<a name="ln6477">      if (bc != gc)             // stop at a char that's different</a>
<a name="ln6478">        break;</a>
<a name="ln6479">      if (bc == NUL) {          // both words end</a>
<a name="ln6480">        if (score &lt; minscore)</a>
<a name="ln6481">          minscore = score;</a>
<a name="ln6482">        goto pop;               // do next alternative</a>
<a name="ln6483">      }</a>
<a name="ln6484">      ++bi;</a>
<a name="ln6485">      ++gi;</a>
<a name="ln6486">    }</a>
<a name="ln6487"> </a>
<a name="ln6488">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln6489">      do {</a>
<a name="ln6490">        if ((score += SCORE_DEL) &gt;= minscore)</a>
<a name="ln6491">          goto pop;                 // do next alternative</a>
<a name="ln6492">      } while (wbadword[++bi] != NUL);</a>
<a name="ln6493">      minscore = score;</a>
<a name="ln6494">    } else if (bc == NUL)   { // badword ends, insert badword chars</a>
<a name="ln6495">      do {</a>
<a name="ln6496">        if ((score += SCORE_INS) &gt;= minscore)</a>
<a name="ln6497">          goto pop;                 // do next alternative</a>
<a name="ln6498">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln6499">      minscore = score;</a>
<a name="ln6500">    } else {                  // both words continue</a>
<a name="ln6501">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln6502">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln6503">      // round 0: try deleting a char from badword</a>
<a name="ln6504">      // round 1: try inserting a char in badword</a>
<a name="ln6505">      for (round = 0; round &lt;= 1; ++round) {</a>
<a name="ln6506">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln6507">        if (score_off &lt; minscore) {</a>
<a name="ln6508">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln6509">            // Near the limit, rest of the words must match.  We</a>
<a name="ln6510">            // can check that right now, no need to push an item</a>
<a name="ln6511">            // onto the stack.</a>
<a name="ln6512">            bi2 = bi + 1 - round;</a>
<a name="ln6513">            gi2 = gi + round;</a>
<a name="ln6514">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln6515">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln6516">                minscore = score_off;</a>
<a name="ln6517">                break;</a>
<a name="ln6518">              }</a>
<a name="ln6519">              ++bi2;</a>
<a name="ln6520">              ++gi2;</a>
<a name="ln6521">            }</a>
<a name="ln6522">          } else {</a>
<a name="ln6523">            // try deleting a character from badword later</a>
<a name="ln6524">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln6525">            stack[stackidx].goodi = gi + round;</a>
<a name="ln6526">            stack[stackidx].score = score_off;</a>
<a name="ln6527">            ++stackidx;</a>
<a name="ln6528">          }</a>
<a name="ln6529">        }</a>
<a name="ln6530">      }</a>
<a name="ln6531"> </a>
<a name="ln6532">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln6533">        // If swapping two characters makes a match then the</a>
<a name="ln6534">        // substitution is more expensive, thus there is no need to</a>
<a name="ln6535">        // try both.</a>
<a name="ln6536">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln6537">          // Swap two characters, that is: skip them.</a>
<a name="ln6538">          gi += 2;</a>
<a name="ln6539">          bi += 2;</a>
<a name="ln6540">          score += SCORE_SWAP;</a>
<a name="ln6541">          continue;</a>
<a name="ln6542">        }</a>
<a name="ln6543">      }</a>
<a name="ln6544"> </a>
<a name="ln6545">      // Substitute one character for another which is the same</a>
<a name="ln6546">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln6547">      // Use a better score when there is only a case difference.</a>
<a name="ln6548">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6549">        score += SCORE_ICASE;</a>
<a name="ln6550">      else {</a>
<a name="ln6551">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6552">        if (slang != NULL</a>
<a name="ln6553">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6554">            &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6555">          score += SCORE_SIMILAR;</a>
<a name="ln6556">        else</a>
<a name="ln6557">          score += SCORE_SUBST;</a>
<a name="ln6558">      }</a>
<a name="ln6559"> </a>
<a name="ln6560">      if (score &lt; minscore) {</a>
<a name="ln6561">        // Do the substitution.</a>
<a name="ln6562">        ++gi;</a>
<a name="ln6563">        ++bi;</a>
<a name="ln6564">        continue;</a>
<a name="ln6565">      }</a>
<a name="ln6566">    }</a>
<a name="ln6567">pop:</a>
<a name="ln6568">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln6569">    if (stackidx == 0)                  // stack is empty, finished</a>
<a name="ln6570">      break;</a>
<a name="ln6571"> </a>
<a name="ln6572">    // pop an item from the stack</a>
<a name="ln6573">    --stackidx;</a>
<a name="ln6574">    gi = stack[stackidx].goodi;</a>
<a name="ln6575">    bi = stack[stackidx].badi;</a>
<a name="ln6576">    score = stack[stackidx].score;</a>
<a name="ln6577">  }</a>
<a name="ln6578"> </a>
<a name="ln6579">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln6580">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln6581">  // bonus.</a>
<a name="ln6582">  if (minscore &gt; limit)</a>
<a name="ln6583">    return SCORE_MAXMAX;</a>
<a name="ln6584">  return minscore;</a>
<a name="ln6585">}</a>
<a name="ln6586"> </a>
<a name="ln6587">// &quot;:spellinfo&quot;</a>
<a name="ln6588">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln6589">{</a>
<a name="ln6590">  if (no_spell_checking(curwin)) {</a>
<a name="ln6591">    return;</a>
<a name="ln6592">  }</a>
<a name="ln6593"> </a>
<a name="ln6594">  msg_start();</a>
<a name="ln6595">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln6596">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6597">    msg_puts(&quot;file: &quot;);</a>
<a name="ln6598">    msg_puts((const char *)lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln6599">    msg_putchar('\n');</a>
<a name="ln6600">    const char *const p = (const char *)lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln6601">    if (p != NULL) {</a>
<a name="ln6602">      msg_puts(p);</a>
<a name="ln6603">      msg_putchar('\n');</a>
<a name="ln6604">    }</a>
<a name="ln6605">  }</a>
<a name="ln6606">  msg_end();</a>
<a name="ln6607">}</a>
<a name="ln6608"> </a>
<a name="ln6609">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln6610">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln6611">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln6612">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln6613">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln6614"> </a>
<a name="ln6615">// &quot;:spelldump&quot;</a>
<a name="ln6616">void ex_spelldump(exarg_T *eap)</a>
<a name="ln6617">{</a>
<a name="ln6618">  char_u  *spl;</a>
<a name="ln6619">  long dummy;</a>
<a name="ln6620"> </a>
<a name="ln6621">  if (no_spell_checking(curwin)) {</a>
<a name="ln6622">    return;</a>
<a name="ln6623">  }</a>
<a name="ln6624">  get_option_value((char_u *)&quot;spl&quot;, &amp;dummy, &amp;spl, OPT_LOCAL);</a>
<a name="ln6625"> </a>
<a name="ln6626">  // Create a new empty buffer in a new window.</a>
<a name="ln6627">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln6628"> </a>
<a name="ln6629">  // enable spelling locally in the new window</a>
<a name="ln6630">  set_option_value(&quot;spell&quot;, true, &quot;&quot;, OPT_LOCAL);</a>
<a name="ln6631">  set_option_value(&quot;spl&quot;,  dummy, (char *)spl, OPT_LOCAL);</a>
<a name="ln6632">  xfree(spl);</a>
<a name="ln6633"> </a>
<a name="ln6634">  if (!BUFEMPTY()) {</a>
<a name="ln6635">    return;</a>
<a name="ln6636">  }</a>
<a name="ln6637"> </a>
<a name="ln6638">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln6639"> </a>
<a name="ln6640">  // Delete the empty line that we started with.</a>
<a name="ln6641">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln6642">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln6643">  }</a>
<a name="ln6644">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln6645">}</a>
<a name="ln6646"> </a>
<a name="ln6647">// Go through all possible words and:</a>
<a name="ln6648">// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln6649">//      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln6650">// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln6651">void</a>
<a name="ln6652">spell_dump_compl (</a>
<a name="ln6653">    char_u *pat,           // leading part of the word</a>
<a name="ln6654">    int ic,                     // ignore case</a>
<a name="ln6655">    Direction *dir,        // direction for adding matches</a>
<a name="ln6656">    int dumpflags_arg              // DUMPFLAG_*</a>
<a name="ln6657">)</a>
<a name="ln6658">{</a>
<a name="ln6659">  langp_T     *lp;</a>
<a name="ln6660">  slang_T     *slang;</a>
<a name="ln6661">  idx_T arridx[MAXWLEN];</a>
<a name="ln6662">  int curi[MAXWLEN];</a>
<a name="ln6663">  char_u word[MAXWLEN];</a>
<a name="ln6664">  int c;</a>
<a name="ln6665">  char_u      *byts;</a>
<a name="ln6666">  idx_T       *idxs;</a>
<a name="ln6667">  linenr_T lnum = 0;</a>
<a name="ln6668">  int round;</a>
<a name="ln6669">  int depth;</a>
<a name="ln6670">  int n;</a>
<a name="ln6671">  int flags;</a>
<a name="ln6672">  char_u      *region_names = NULL;         // region names being used</a>
<a name="ln6673">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln6674">  char_u      *p;</a>
<a name="ln6675">  int dumpflags = dumpflags_arg;</a>
<a name="ln6676">  int patlen;</a>
<a name="ln6677"> </a>
<a name="ln6678">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln6679">  // to dump_word().</a>
<a name="ln6680">  if (pat != NULL) {</a>
<a name="ln6681">    if (ic)</a>
<a name="ln6682">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln6683">    else {</a>
<a name="ln6684">      n = captype(pat, NULL);</a>
<a name="ln6685">      if (n == WF_ONECAP)</a>
<a name="ln6686">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln6687">      else if (n == WF_ALLCAP</a>
<a name="ln6688">               &amp;&amp; (int)STRLEN(pat) &gt; mb_ptr2len(pat)</a>
<a name="ln6689">               )</a>
<a name="ln6690">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln6691">    }</a>
<a name="ln6692">  }</a>
<a name="ln6693"> </a>
<a name="ln6694">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln6695">  // regions or none at all.</a>
<a name="ln6696">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6697">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6698">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln6699">    if (p[0] != 0) {</a>
<a name="ln6700">      if (region_names == NULL)             // first language with regions</a>
<a name="ln6701">        region_names = p;</a>
<a name="ln6702">      else if (STRCMP(region_names, p) != 0) {</a>
<a name="ln6703">        do_region = false;                  // region names are different</a>
<a name="ln6704">        break;</a>
<a name="ln6705">      }</a>
<a name="ln6706">    }</a>
<a name="ln6707">  }</a>
<a name="ln6708"> </a>
<a name="ln6709">  if (do_region &amp;&amp; region_names != NULL) {</a>
<a name="ln6710">    if (pat == NULL) {</a>
<a name="ln6711">      vim_snprintf((char *)IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln6712">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6713">    }</a>
<a name="ln6714">  } else</a>
<a name="ln6715">    do_region = false;</a>
<a name="ln6716"> </a>
<a name="ln6717">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln6718">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6719">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6720">    slang = lp-&gt;lp_slang;</a>
<a name="ln6721">    if (slang-&gt;sl_fbyts == NULL)            // reloading failed</a>
<a name="ln6722">      continue;</a>
<a name="ln6723"> </a>
<a name="ln6724">    if (pat == NULL) {</a>
<a name="ln6725">      vim_snprintf((char *)IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln6726">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6727">    }</a>
<a name="ln6728"> </a>
<a name="ln6729">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln6730">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln6731">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL)</a>
<a name="ln6732">      patlen = (int)STRLEN(pat);</a>
<a name="ln6733">    else</a>
<a name="ln6734">      patlen = -1;</a>
<a name="ln6735"> </a>
<a name="ln6736">    // round 1: case-folded tree</a>
<a name="ln6737">    // round 2: keep-case tree</a>
<a name="ln6738">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln6739">      if (round == 1) {</a>
<a name="ln6740">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln6741">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln6742">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln6743">      } else {</a>
<a name="ln6744">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln6745">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln6746">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln6747">      }</a>
<a name="ln6748">      if (byts == NULL)</a>
<a name="ln6749">        continue;                       // array is empty</a>
<a name="ln6750"> </a>
<a name="ln6751">      depth = 0;</a>
<a name="ln6752">      arridx[0] = 0;</a>
<a name="ln6753">      curi[0] = 1;</a>
<a name="ln6754">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln6755">             &amp;&amp; (pat == NULL || !compl_interrupted)) {</a>
<a name="ln6756">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln6757">          // Done all bytes at this node, go up one level.</a>
<a name="ln6758">          --depth;</a>
<a name="ln6759">          line_breakcheck();</a>
<a name="ln6760">          ins_compl_check_keys(50, false);</a>
<a name="ln6761">        } else {</a>
<a name="ln6762">          // Do one more byte at this node.</a>
<a name="ln6763">          n = arridx[depth] + curi[depth];</a>
<a name="ln6764">          ++curi[depth];</a>
<a name="ln6765">          c = byts[n];</a>
<a name="ln6766">          if (c == 0) {</a>
<a name="ln6767">            // End of word, deal with the word.</a>
<a name="ln6768">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln6769">            // they will appear in the keep-case tree.</a>
<a name="ln6770">            // Only use the word when the region matches.</a>
<a name="ln6771">            flags = (int)idxs[n];</a>
<a name="ln6772">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln6773">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln6774">                &amp;&amp; (do_region</a>
<a name="ln6775">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln6776">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln6777">                        &amp; lp-&gt;lp_region) != 0)) {</a>
<a name="ln6778">              word[depth] = NUL;</a>
<a name="ln6779">              if (!do_region)</a>
<a name="ln6780">                flags &amp;= ~WF_REGION;</a>
<a name="ln6781"> </a>
<a name="ln6782">              // Dump the basic word if there is no prefix or</a>
<a name="ln6783">              // when it's the first one.</a>
<a name="ln6784">              c = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln6785">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln6786">                dump_word(slang, word, pat, dir,</a>
<a name="ln6787">                    dumpflags, flags, lnum);</a>
<a name="ln6788">                if (pat == NULL)</a>
<a name="ln6789">                  ++lnum;</a>
<a name="ln6790">              }</a>
<a name="ln6791"> </a>
<a name="ln6792">              // Apply the prefix, if there is one.</a>
<a name="ln6793">              if (c != 0)</a>
<a name="ln6794">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln6795">                    dumpflags, flags, lnum);</a>
<a name="ln6796">            }</a>
<a name="ln6797">          } else {</a>
<a name="ln6798">            // Normal char, go one level deeper.</a>
<a name="ln6799">            word[depth++] = c;</a>
<a name="ln6800">            arridx[depth] = idxs[n];</a>
<a name="ln6801">            curi[depth] = 1;</a>
<a name="ln6802"> </a>
<a name="ln6803">            // Check if this characters matches with the pattern.</a>
<a name="ln6804">            // If not skip the whole tree below it.</a>
<a name="ln6805">            // Always ignore case here, dump_word() will check</a>
<a name="ln6806">            // proper case later.  This isn't exactly right when</a>
<a name="ln6807">            // length changes for multi-byte characters with</a>
<a name="ln6808">            // ignore case...</a>
<a name="ln6809">            assert(depth &gt;= 0);</a>
<a name="ln6810">            if (depth &lt;= patlen</a>
<a name="ln6811">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0)</a>
<a name="ln6812">              --depth;</a>
<a name="ln6813">          }</a>
<a name="ln6814">        }</a>
<a name="ln6815">      }</a>
<a name="ln6816">    }</a>
<a name="ln6817">  }</a>
<a name="ln6818">}</a>
<a name="ln6819"> </a>
<a name="ln6820">// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln6821">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6822">static void dump_word(slang_T *slang, char_u *word, char_u *pat,</a>
<a name="ln6823">                      Direction *dir, int dumpflags, int wordflags,</a>
<a name="ln6824">                      linenr_T lnum)</a>
<a name="ln6825">{</a>
<a name="ln6826">  bool keepcap = false;</a>
<a name="ln6827">  char_u      *p;</a>
<a name="ln6828">  char_u      *tw;</a>
<a name="ln6829">  char_u cword[MAXWLEN];</a>
<a name="ln6830">  char_u badword[MAXWLEN + 10];</a>
<a name="ln6831">  int i;</a>
<a name="ln6832">  int flags = wordflags;</a>
<a name="ln6833"> </a>
<a name="ln6834">  if (dumpflags &amp; DUMPFLAG_ONECAP)</a>
<a name="ln6835">    flags |= WF_ONECAP;</a>
<a name="ln6836">  if (dumpflags &amp; DUMPFLAG_ALLCAP)</a>
<a name="ln6837">    flags |= WF_ALLCAP;</a>
<a name="ln6838"> </a>
<a name="ln6839">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln6840">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln6841">    make_case_word(word, cword, flags);</a>
<a name="ln6842">    p = cword;</a>
<a name="ln6843">  } else {</a>
<a name="ln6844">    p = word;</a>
<a name="ln6845">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln6846">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln6847">            || (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln6848">      keepcap = true;</a>
<a name="ln6849">  }</a>
<a name="ln6850">  tw = p;</a>
<a name="ln6851"> </a>
<a name="ln6852">  if (pat == NULL) {</a>
<a name="ln6853">    // Add flags and regions after a slash.</a>
<a name="ln6854">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln6855">      STRCPY(badword, p);</a>
<a name="ln6856">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln6857">      if (keepcap) {</a>
<a name="ln6858">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln6859">      }</a>
<a name="ln6860">      if (flags &amp; WF_BANNED) {</a>
<a name="ln6861">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln6862">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln6863">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln6864">      }</a>
<a name="ln6865">      if (flags &amp; WF_REGION) {</a>
<a name="ln6866">        for (i = 0; i &lt; 7; i++) {</a>
<a name="ln6867">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln6868">            const size_t badword_len = STRLEN(badword);</a>
<a name="ln6869">            snprintf((char *)badword + badword_len,</a>
<a name="ln6870">                     sizeof(badword) - badword_len,</a>
<a name="ln6871">                     &quot;%d&quot;, i + 1);</a>
<a name="ln6872">          }</a>
<a name="ln6873">        }</a>
<a name="ln6874">      }</a>
<a name="ln6875">      p = badword;</a>
<a name="ln6876">    }</a>
<a name="ln6877"> </a>
<a name="ln6878">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln6879">      hashitem_T  *hi;</a>
<a name="ln6880"> </a>
<a name="ln6881">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln6882">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln6883">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln6884">        vim_snprintf((char *)IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln6885">            tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln6886">        p = IObuff;</a>
<a name="ln6887">      }</a>
<a name="ln6888">    }</a>
<a name="ln6889"> </a>
<a name="ln6890">    ml_append(lnum, p, (colnr_T)0, false);</a>
<a name="ln6891">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln6892">              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0</a>
<a name="ln6893">              : STRNCMP(p, pat, STRLEN(pat)) == 0)</a>
<a name="ln6894">             &amp;&amp; ins_compl_add_infercase(p, (int)STRLEN(p),</a>
<a name="ln6895">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln6896">    // if dir was BACKWARD then honor it just once</a>
<a name="ln6897">    *dir = FORWARD;</a>
<a name="ln6898">  }</a>
<a name="ln6899">}</a>
<a name="ln6900"> </a>
<a name="ln6901">// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln6902">// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln6903">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6904">// Return the updated line number.</a>
<a name="ln6905">static linenr_T</a>
<a name="ln6906">dump_prefixes (</a>
<a name="ln6907">    slang_T *slang,</a>
<a name="ln6908">    char_u *word,          // case-folded word</a>
<a name="ln6909">    char_u *pat,</a>
<a name="ln6910">    Direction *dir,</a>
<a name="ln6911">    int dumpflags,</a>
<a name="ln6912">    int flags,                  // flags with prefix ID</a>
<a name="ln6913">    linenr_T startlnum</a>
<a name="ln6914">)</a>
<a name="ln6915">{</a>
<a name="ln6916">  idx_T arridx[MAXWLEN];</a>
<a name="ln6917">  int curi[MAXWLEN];</a>
<a name="ln6918">  char_u prefix[MAXWLEN];</a>
<a name="ln6919">  char_u word_up[MAXWLEN];</a>
<a name="ln6920">  bool has_word_up = false;</a>
<a name="ln6921">  int c;</a>
<a name="ln6922">  char_u      *byts;</a>
<a name="ln6923">  idx_T       *idxs;</a>
<a name="ln6924">  linenr_T lnum = startlnum;</a>
<a name="ln6925">  int depth;</a>
<a name="ln6926">  int n;</a>
<a name="ln6927">  int len;</a>
<a name="ln6928">  int i;</a>
<a name="ln6929"> </a>
<a name="ln6930">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln6931">  // upper-case letter in word_up[].</a>
<a name="ln6932">  c = PTR2CHAR(word);</a>
<a name="ln6933">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln6934">    onecap_copy(word, word_up, true);</a>
<a name="ln6935">    has_word_up = true;</a>
<a name="ln6936">  }</a>
<a name="ln6937"> </a>
<a name="ln6938">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln6939">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln6940">  if (byts != NULL) {           // array not is empty</a>
<a name="ln6941">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln6942">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln6943">    depth = 0;</a>
<a name="ln6944">    arridx[0] = 0;</a>
<a name="ln6945">    curi[0] = 1;</a>
<a name="ln6946">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln6947">      n = arridx[depth];</a>
<a name="ln6948">      len = byts[n];</a>
<a name="ln6949">      if (curi[depth] &gt; len) {</a>
<a name="ln6950">        // Done all bytes at this node, go up one level.</a>
<a name="ln6951">        --depth;</a>
<a name="ln6952">        line_breakcheck();</a>
<a name="ln6953">      } else {</a>
<a name="ln6954">        // Do one more byte at this node.</a>
<a name="ln6955">        n += curi[depth];</a>
<a name="ln6956">        ++curi[depth];</a>
<a name="ln6957">        c = byts[n];</a>
<a name="ln6958">        if (c == 0) {</a>
<a name="ln6959">          // End of prefix, find out how many IDs there are.</a>
<a name="ln6960">          for (i = 1; i &lt; len; ++i)</a>
<a name="ln6961">            if (byts[n + i] != 0)</a>
<a name="ln6962">              break;</a>
<a name="ln6963">          curi[depth] += i - 1;</a>
<a name="ln6964"> </a>
<a name="ln6965">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln6966">          if (c != 0) {</a>
<a name="ln6967">            STRLCPY(prefix + depth, word, MAXWLEN - depth);</a>
<a name="ln6968">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln6969">                (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln6970">                : flags, lnum);</a>
<a name="ln6971">            if (lnum != 0)</a>
<a name="ln6972">              ++lnum;</a>
<a name="ln6973">          }</a>
<a name="ln6974"> </a>
<a name="ln6975">          // Check for prefix that matches the word when the</a>
<a name="ln6976">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln6977">          // a condition.</a>
<a name="ln6978">          if (has_word_up) {</a>
<a name="ln6979">            c = valid_word_prefix(i, n, flags, word_up, slang,</a>
<a name="ln6980">                true);</a>
<a name="ln6981">            if (c != 0) {</a>
<a name="ln6982">              STRLCPY(prefix + depth, word_up, MAXWLEN - depth);</a>
<a name="ln6983">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln6984">                  (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln6985">                  : flags, lnum);</a>
<a name="ln6986">              if (lnum != 0)</a>
<a name="ln6987">                ++lnum;</a>
<a name="ln6988">            }</a>
<a name="ln6989">          }</a>
<a name="ln6990">        } else {</a>
<a name="ln6991">          // Normal char, go one level deeper.</a>
<a name="ln6992">          prefix[depth++] = c;</a>
<a name="ln6993">          arridx[depth] = idxs[n];</a>
<a name="ln6994">          curi[depth] = 1;</a>
<a name="ln6995">        }</a>
<a name="ln6996">      }</a>
<a name="ln6997">    }</a>
<a name="ln6998">  }</a>
<a name="ln6999"> </a>
<a name="ln7000">  return lnum;</a>
<a name="ln7001">}</a>
<a name="ln7002"> </a>
<a name="ln7003">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln7004">// Uses the spell-checking word characters.</a>
<a name="ln7005">char_u *spell_to_word_end(char_u *start, win_T *win)</a>
<a name="ln7006">{</a>
<a name="ln7007">  char_u  *p = start;</a>
<a name="ln7008"> </a>
<a name="ln7009">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln7010">    MB_PTR_ADV(p);</a>
<a name="ln7011">  }</a>
<a name="ln7012">  return p;</a>
<a name="ln7013">}</a>
<a name="ln7014"> </a>
<a name="ln7015">// For Insert mode completion CTRL-X s:</a>
<a name="ln7016">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln7017">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln7018">// the word in front of the cursor.</a>
<a name="ln7019">// Returns the column number of the word.</a>
<a name="ln7020">int spell_word_start(int startcol)</a>
<a name="ln7021">{</a>
<a name="ln7022">  char_u      *line;</a>
<a name="ln7023">  char_u      *p;</a>
<a name="ln7024">  int col = 0;</a>
<a name="ln7025"> </a>
<a name="ln7026">  if (no_spell_checking(curwin)) {</a>
<a name="ln7027">    return startcol;</a>
<a name="ln7028">  }</a>
<a name="ln7029"> </a>
<a name="ln7030">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln7031">  line = get_cursor_line_ptr();</a>
<a name="ln7032">  for (p = line + startcol; p &gt; line; ) {</a>
<a name="ln7033">    MB_PTR_BACK(line, p);</a>
<a name="ln7034">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln7035">      break;</a>
<a name="ln7036">    }</a>
<a name="ln7037">  }</a>
<a name="ln7038"> </a>
<a name="ln7039">  // Go back to start of the word.</a>
<a name="ln7040">  while (p &gt; line) {</a>
<a name="ln7041">    col = (int)(p - line);</a>
<a name="ln7042">    MB_PTR_BACK(line, p);</a>
<a name="ln7043">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln7044">      break;</a>
<a name="ln7045">    }</a>
<a name="ln7046">    col = 0;</a>
<a name="ln7047">  }</a>
<a name="ln7048"> </a>
<a name="ln7049">  return col;</a>
<a name="ln7050">}</a>
<a name="ln7051"> </a>
<a name="ln7052">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln7053">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln7054">static bool spell_expand_need_cap;</a>
<a name="ln7055"> </a>
<a name="ln7056">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln7057">{</a>
<a name="ln7058">  spell_expand_need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln7059">}</a>
<a name="ln7060"> </a>
<a name="ln7061">// Get list of spelling suggestions.</a>
<a name="ln7062">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln7063">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln7064">// allocated strings.</a>
<a name="ln7065">int expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp)</a>
<a name="ln7066">{</a>
<a name="ln7067">  garray_T ga;</a>
<a name="ln7068"> </a>
<a name="ln7069">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln7070">  *matchp = ga.ga_data;</a>
<a name="ln7071">  return ga.ga_len;</a>
<a name="ln7072">}</a>

</code></pre>
<div class="balloon" rel="448"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'mi.mi_fwordlen - 1' index could reach -1.</p></div>
<div class="balloon" rel="5958"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>syntax.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * syntax.c: code for syntax highlighting</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;ctype.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln18">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln24">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln25">#include &quot;nvim/fold.h&quot;</a>
<a name="ln26">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln27">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln28">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln29">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln30">#include &quot;nvim/memline.h&quot;</a>
<a name="ln31">#include &quot;nvim/memory.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln34">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln38">#include &quot;nvim/path.h&quot;</a>
<a name="ln39">#include &quot;nvim/macros.h&quot;</a>
<a name="ln40">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln41">#include &quot;nvim/screen.h&quot;</a>
<a name="ln42">#include &quot;nvim/sign.h&quot;</a>
<a name="ln43">#include &quot;nvim/strings.h&quot;</a>
<a name="ln44">#include &quot;nvim/syntax_defs.h&quot;</a>
<a name="ln45">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln46">#include &quot;nvim/ui.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln49">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">static bool did_syntax_onoff = false;</a>
<a name="ln52"> </a>
<a name="ln53">/// Structure that stores information about a highlight group.</a>
<a name="ln54">/// The ID of a highlight group is also called group ID.  It is the index in</a>
<a name="ln55">/// the highlight_ga array PLUS ONE.</a>
<a name="ln56">struct hl_group {</a>
<a name="ln57">  char_u      *sg_name;         ///&lt; highlight group name</a>
<a name="ln58">  char_u      *sg_name_u;       ///&lt; uppercase of sg_name</a>
<a name="ln59">  bool sg_cleared;              ///&lt; &quot;hi clear&quot; was used</a>
<a name="ln60">  int sg_attr;                  ///&lt; Screen attr @see ATTR_ENTRY</a>
<a name="ln61">  int sg_link;                  ///&lt; link to this highlight group ID</a>
<a name="ln62">  int sg_set;                   ///&lt; combination of flags in \ref SG_SET</a>
<a name="ln63">  sctx_T sg_script_ctx;         ///&lt; script in which the group was last set</a>
<a name="ln64">  // for terminal UIs</a>
<a name="ln65">  int sg_cterm;                 ///&lt; &quot;cterm=&quot; highlighting attr</a>
<a name="ln66">                                ///&lt; (combination of \ref HlAttrFlags)</a>
<a name="ln67">  int sg_cterm_fg;              ///&lt; terminal fg color number + 1</a>
<a name="ln68">  int sg_cterm_bg;              ///&lt; terminal bg color number + 1</a>
<a name="ln69">  bool sg_cterm_bold;           ///&lt; bold attr was set for light color</a>
<a name="ln70">  // for RGB UIs</a>
<a name="ln71">  int sg_gui;                   ///&lt; &quot;gui=&quot; highlighting attributes</a>
<a name="ln72">                                ///&lt; (combination of \ref HlAttrFlags)</a>
<a name="ln73">  RgbValue sg_rgb_fg;           ///&lt; RGB foreground color</a>
<a name="ln74">  RgbValue sg_rgb_bg;           ///&lt; RGB background color</a>
<a name="ln75">  RgbValue sg_rgb_sp;           ///&lt; RGB special color</a>
<a name="ln76">  char *sg_rgb_fg_name;         ///&lt; RGB foreground color name</a>
<a name="ln77">  char *sg_rgb_bg_name;         ///&lt; RGB background color name</a>
<a name="ln78">  char *sg_rgb_sp_name;         ///&lt; RGB special color name</a>
<a name="ln79"> </a>
<a name="ln80">  int sg_blend;                 ///&lt; blend level (0-100 inclusive), -1 if unset</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">/// \addtogroup SG_SET</a>
<a name="ln84">/// @{</a>
<a name="ln85">#define SG_CTERM        2       // cterm has been set</a>
<a name="ln86">#define SG_GUI          4       // gui has been set</a>
<a name="ln87">#define SG_LINK         8       // link has been set</a>
<a name="ln88">/// @}</a>
<a name="ln89"> </a>
<a name="ln90">// builtin |highlight-groups|</a>
<a name="ln91">static garray_T highlight_ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln92"> </a>
<a name="ln93">static inline struct hl_group * HL_TABLE(void)</a>
<a name="ln94">{</a>
<a name="ln95">  return ((struct hl_group *)((highlight_ga.ga_data)));</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">#define MAX_HL_ID       20000   /* maximum value for a highlight ID. */</a>
<a name="ln99"> </a>
<a name="ln100">/* different types of offsets that are possible */</a>
<a name="ln101">#define SPO_MS_OFF      0       /* match  start offset */</a>
<a name="ln102">#define SPO_ME_OFF      1       /* match  end	offset */</a>
<a name="ln103">#define SPO_HS_OFF      2       /* highl. start offset */</a>
<a name="ln104">#define SPO_HE_OFF      3       /* highl. end	offset */</a>
<a name="ln105">#define SPO_RS_OFF      4       /* region start offset */</a>
<a name="ln106">#define SPO_RE_OFF      5       /* region end	offset */</a>
<a name="ln107">#define SPO_LC_OFF      6       /* leading context offset */</a>
<a name="ln108">#define SPO_COUNT       7</a>
<a name="ln109"> </a>
<a name="ln110">/* Flags to indicate an additional string for highlight name completion. */</a>
<a name="ln111">static int include_none = 0;    /* when 1 include &quot;nvim/None&quot; */</a>
<a name="ln112">static int include_default = 0; /* when 1 include &quot;nvim/default&quot; */</a>
<a name="ln113">static int include_link = 0;    /* when 2 include &quot;nvim/link&quot; and &quot;clear&quot; */</a>
<a name="ln114"> </a>
<a name="ln115">/// The &quot;term&quot;, &quot;cterm&quot; and &quot;gui&quot; arguments can be any combination of the</a>
<a name="ln116">/// following names, separated by commas (but no spaces!).</a>
<a name="ln117">static char *(hl_name_table[]) =</a>
<a name="ln118">{ &quot;bold&quot;, &quot;standout&quot;, &quot;underline&quot;, &quot;undercurl&quot;,</a>
<a name="ln119">  &quot;italic&quot;, &quot;reverse&quot;, &quot;inverse&quot;, &quot;strikethrough&quot;, &quot;nocombine&quot;, &quot;NONE&quot; };</a>
<a name="ln120">static int hl_attr_table[] =</a>
<a name="ln121">{ HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE,</a>
<a name="ln122">  HL_INVERSE, HL_STRIKETHROUGH, HL_NOCOMBINE, 0 };</a>
<a name="ln123"> </a>
<a name="ln124">static char e_illegal_arg[] = N_(&quot;E390: Illegal argument: %s&quot;);</a>
<a name="ln125"> </a>
<a name="ln126">// The patterns that are being searched for are stored in a syn_pattern.</a>
<a name="ln127">// A match item consists of one pattern.</a>
<a name="ln128">// A start/end item consists of n start patterns and m end patterns.</a>
<a name="ln129">// A start/skip/end item consists of n start patterns, one skip pattern and m</a>
<a name="ln130">// end patterns.</a>
<a name="ln131">// For the latter two, the patterns are always consecutive: start-skip-end.</a>
<a name="ln132">//</a>
<a name="ln133">// A character offset can be given for the matched text (_m_start and _m_end)</a>
<a name="ln134">// and for the actually highlighted text (_h_start and _h_end).</a>
<a name="ln135">//</a>
<a name="ln136">// Note that ordering of members is optimized to reduce padding.</a>
<a name="ln137">typedef struct syn_pattern {</a>
<a name="ln138">  char sp_type;                         // see SPTYPE_ defines below</a>
<a name="ln139">  bool sp_syncing;                      // this item used for syncing</a>
<a name="ln140">  int16_t sp_syn_match_id;              // highlight group ID of pattern</a>
<a name="ln141">  int16_t sp_off_flags;                 // see below</a>
<a name="ln142">  int sp_offsets[SPO_COUNT];            // offsets</a>
<a name="ln143">  int sp_flags;                         // see HL_ defines below</a>
<a name="ln144">  int sp_cchar;                         // conceal substitute character</a>
<a name="ln145">  int sp_ic;                            // ignore-case flag for sp_prog</a>
<a name="ln146">  int sp_sync_idx;                      // sync item index (syncing only)</a>
<a name="ln147">  int sp_line_id;                       // ID of last line where tried</a>
<a name="ln148">  int sp_startcol;                      // next match in sp_line_id line</a>
<a name="ln149">  int16_t *sp_cont_list;                // cont. group IDs, if non-zero</a>
<a name="ln150">  int16_t *sp_next_list;                // next group IDs, if non-zero</a>
<a name="ln151">  struct sp_syn sp_syn;                 // struct passed to in_id_list()</a>
<a name="ln152">  char_u *sp_pattern;                   // regexp to match, pattern</a>
<a name="ln153">  regprog_T *sp_prog;                   // regexp to match, program</a>
<a name="ln154">  syn_time_T sp_time;</a>
<a name="ln155">} synpat_T;</a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">typedef struct syn_cluster_S {</a>
<a name="ln159">  char_u *scl_name;         // syntax cluster name</a>
<a name="ln160">  char_u *scl_name_u;       // uppercase of scl_name</a>
<a name="ln161">  int16_t *scl_list;        // IDs in this syntax cluster</a>
<a name="ln162">} syn_cluster_T;</a>
<a name="ln163"> </a>
<a name="ln164">/*</a>
<a name="ln165"> * For the current state we need to remember more than just the idx.</a>
<a name="ln166"> * When si_m_endpos.lnum is 0, the items other than si_idx are unknown.</a>
<a name="ln167"> * (The end positions have the column number of the next char)</a>
<a name="ln168"> */</a>
<a name="ln169">typedef struct state_item {</a>
<a name="ln170">  int si_idx;                           // index of syntax pattern or</a>
<a name="ln171">                                        // KEYWORD_IDX</a>
<a name="ln172">  int si_id;                            // highlight group ID for keywords</a>
<a name="ln173">  int si_trans_id;                      // idem, transparency removed</a>
<a name="ln174">  int si_m_lnum;                        // lnum of the match</a>
<a name="ln175">  int si_m_startcol;                    // starting column of the match</a>
<a name="ln176">  lpos_T si_m_endpos;                   // just after end posn of the match</a>
<a name="ln177">  lpos_T si_h_startpos;                 // start position of the highlighting</a>
<a name="ln178">  lpos_T si_h_endpos;                   // end position of the highlighting</a>
<a name="ln179">  lpos_T si_eoe_pos;                    // end position of end pattern</a>
<a name="ln180">  int si_end_idx;                       // group ID for end pattern or zero</a>
<a name="ln181">  int si_ends;                          // if match ends before si_m_endpos</a>
<a name="ln182">  int si_attr;                          // attributes in this state</a>
<a name="ln183">  long si_flags;                        // HL_HAS_EOL flag in this state, and</a>
<a name="ln184">                                        // HL_SKIP* for si_next_list</a>
<a name="ln185">  int si_seqnr;                         // sequence number</a>
<a name="ln186">  int si_cchar;                         // substitution character for conceal</a>
<a name="ln187">  int16_t *si_cont_list;                // list of contained groups</a>
<a name="ln188">  int16_t *si_next_list;                // nextgroup IDs after this item ends</a>
<a name="ln189">  reg_extmatch_T *si_extmatch;          // \z(...\) matches from start</a>
<a name="ln190">                                        // pattern</a>
<a name="ln191">} stateitem_T;</a>
<a name="ln192"> </a>
<a name="ln193">/*</a>
<a name="ln194"> * Struct to reduce the number of arguments to get_syn_options(), it's used</a>
<a name="ln195"> * very often.</a>
<a name="ln196"> */</a>
<a name="ln197">typedef struct {</a>
<a name="ln198">  int flags;                   // flags for contained and transparent</a>
<a name="ln199">  bool keyword;                // true for &quot;:syn keyword&quot;</a>
<a name="ln200">  int *sync_idx;               // syntax item for &quot;grouphere&quot; argument, NULL</a>
<a name="ln201">                               // if not allowed</a>
<a name="ln202">  bool has_cont_list;          // true if &quot;cont_list&quot; can be used</a>
<a name="ln203">  int16_t *cont_list;          // group IDs for &quot;contains&quot; argument</a>
<a name="ln204">  int16_t *cont_in_list;       // group IDs for &quot;containedin&quot; argument</a>
<a name="ln205">  int16_t *next_list;          // group IDs for &quot;nextgroup&quot; argument</a>
<a name="ln206">} syn_opt_arg_T;</a>
<a name="ln207"> </a>
<a name="ln208">typedef struct {</a>
<a name="ln209">  proftime_T total;</a>
<a name="ln210">  int count;</a>
<a name="ln211">  int match;</a>
<a name="ln212">  proftime_T slowest;</a>
<a name="ln213">  proftime_T average;</a>
<a name="ln214">  int id;</a>
<a name="ln215">  char_u      *pattern;</a>
<a name="ln216">} time_entry_T;</a>
<a name="ln217"> </a>
<a name="ln218">struct name_list {</a>
<a name="ln219">  int flag;</a>
<a name="ln220">  char        *name;</a>
<a name="ln221">};</a>
<a name="ln222"> </a>
<a name="ln223">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln224"># include &quot;syntax.c.generated.h&quot;</a>
<a name="ln225">#endif</a>
<a name="ln226"> </a>
<a name="ln227">static char *(spo_name_tab[SPO_COUNT]) =</a>
<a name="ln228">{&quot;ms=&quot;, &quot;me=&quot;, &quot;hs=&quot;, &quot;he=&quot;, &quot;rs=&quot;, &quot;re=&quot;, &quot;lc=&quot;};</a>
<a name="ln229"> </a>
<a name="ln230">/* The sp_off_flags are computed like this:</a>
<a name="ln231"> * offset from the start of the matched text: (1 &lt;&lt; SPO_XX_OFF)</a>
<a name="ln232"> * offset from the end	 of the matched text: (1 &lt;&lt; (SPO_XX_OFF + SPO_COUNT))</a>
<a name="ln233"> * When both are present, only one is used.</a>
<a name="ln234"> */</a>
<a name="ln235"> </a>
<a name="ln236">#define SPTYPE_MATCH    1       /* match keyword with this group ID */</a>
<a name="ln237">#define SPTYPE_START    2       /* match a regexp, start of item */</a>
<a name="ln238">#define SPTYPE_END      3       /* match a regexp, end of item */</a>
<a name="ln239">#define SPTYPE_SKIP     4       /* match a regexp, skip within item */</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">#define SYN_ITEMS(buf)  ((synpat_T *)((buf)-&gt;b_syn_patterns.ga_data))</a>
<a name="ln243"> </a>
<a name="ln244">#define NONE_IDX        -2      /* value of sp_sync_idx for &quot;NONE&quot; */</a>
<a name="ln245"> </a>
<a name="ln246">/*</a>
<a name="ln247"> * Flags for b_syn_sync_flags:</a>
<a name="ln248"> */</a>
<a name="ln249">#define SF_CCOMMENT     0x01    /* sync on a C-style comment */</a>
<a name="ln250">#define SF_MATCH        0x02    /* sync by matching a pattern */</a>
<a name="ln251"> </a>
<a name="ln252">#define SYN_STATE_P(ssp)    ((bufstate_T *)((ssp)-&gt;ga_data))</a>
<a name="ln253"> </a>
<a name="ln254">#define MAXKEYWLEN      80          /* maximum length of a keyword */</a>
<a name="ln255"> </a>
<a name="ln256">/*</a>
<a name="ln257"> * The attributes of the syntax item that has been recognized.</a>
<a name="ln258"> */</a>
<a name="ln259">static int current_attr = 0;        /* attr of current syntax word */</a>
<a name="ln260">static int current_id = 0;          /* ID of current char for syn_get_id() */</a>
<a name="ln261">static int current_trans_id = 0;    /* idem, transparency removed */</a>
<a name="ln262">static int current_flags = 0;</a>
<a name="ln263">static int current_seqnr = 0;</a>
<a name="ln264">static int current_sub_char = 0;</a>
<a name="ln265"> </a>
<a name="ln266">/*</a>
<a name="ln267"> * Methods of combining two clusters</a>
<a name="ln268"> */</a>
<a name="ln269">#define CLUSTER_REPLACE     1   /* replace first list with second */</a>
<a name="ln270">#define CLUSTER_ADD         2   /* add second list to first */</a>
<a name="ln271">#define CLUSTER_SUBTRACT    3   /* subtract second list from first */</a>
<a name="ln272"> </a>
<a name="ln273">#define SYN_CLSTR(buf)  ((syn_cluster_T *)((buf)-&gt;b_syn_clusters.ga_data))</a>
<a name="ln274"> </a>
<a name="ln275">/*</a>
<a name="ln276"> * Syntax group IDs have different types:</a>
<a name="ln277"> *     0 - 19999  normal syntax groups</a>
<a name="ln278"> * 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)</a>
<a name="ln279"> * 21000 - 21999  TOP indicator (current_syn_inc_tag added)</a>
<a name="ln280"> * 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)</a>
<a name="ln281"> * 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)</a>
<a name="ln282"> */</a>
<a name="ln283">#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */</a>
<a name="ln284">#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */</a>
<a name="ln285">#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */</a>
<a name="ln286">#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */</a>
<a name="ln287"> </a>
<a name="ln288">#define MAX_SYN_INC_TAG 999         /* maximum before the above overflow */</a>
<a name="ln289">#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)</a>
<a name="ln290"> </a>
<a name="ln291">/*</a>
<a name="ln292"> * Annoying Hack(TM):  &quot;:syn include&quot; needs this pointer to pass to</a>
<a name="ln293"> * expand_filename().  Most of the other syntax commands don't need it, so</a>
<a name="ln294"> * instead of passing it to them, we stow it here.</a>
<a name="ln295"> */</a>
<a name="ln296">static char_u **syn_cmdlinep;</a>
<a name="ln297"> </a>
<a name="ln298">/*</a>
<a name="ln299"> * Another Annoying Hack(TM):  To prevent rules from other &quot;:syn include&quot;'d</a>
<a name="ln300"> * files from leaking into ALLBUT lists, we assign a unique ID to the</a>
<a name="ln301"> * rules in each &quot;:syn include&quot;'d file.</a>
<a name="ln302"> */</a>
<a name="ln303">static int current_syn_inc_tag = 0;</a>
<a name="ln304">static int running_syn_inc_tag = 0;</a>
<a name="ln305"> </a>
<a name="ln306">/*</a>
<a name="ln307"> * In a hashtable item &quot;hi_key&quot; points to &quot;keyword&quot; in a keyentry.</a>
<a name="ln308"> * This avoids adding a pointer to the hashtable item.</a>
<a name="ln309"> * KE2HIKEY() converts a var pointer to a hashitem key pointer.</a>
<a name="ln310"> * HIKEY2KE() converts a hashitem key pointer to a var pointer.</a>
<a name="ln311"> * HI2KE() converts a hashitem pointer to a var pointer.</a>
<a name="ln312"> */</a>
<a name="ln313">static keyentry_T dumkey;</a>
<a name="ln314">#define KE2HIKEY(kp)  ((kp)-&gt;keyword)</a>
<a name="ln315">#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&amp;dumkey)))</a>
<a name="ln316">#define HI2KE(hi)      HIKEY2KE((hi)-&gt;hi_key)</a>
<a name="ln317"> </a>
<a name="ln318">// -V:HI2KE:782</a>
<a name="ln319"> </a>
<a name="ln320">/*</a>
<a name="ln321"> * To reduce the time spent in keepend(), remember at which level in the state</a>
<a name="ln322"> * stack the first item with &quot;keepend&quot; is present.  When &quot;-1&quot;, there is no</a>
<a name="ln323"> * &quot;keepend&quot; on the stack.</a>
<a name="ln324"> */</a>
<a name="ln325">static int keepend_level = -1;</a>
<a name="ln326"> </a>
<a name="ln327">static char msg_no_items[] = N_(&quot;No Syntax items defined for this buffer&quot;);</a>
<a name="ln328"> </a>
<a name="ln329">// value of si_idx for keywords</a>
<a name="ln330">#define KEYWORD_IDX     -1</a>
<a name="ln331">// valid of si_cont_list for containing all but contained groups</a>
<a name="ln332">#define ID_LIST_ALL     (int16_t *)-1</a>
<a name="ln333"> </a>
<a name="ln334">static int next_seqnr = 1;              /* value to use for si_seqnr */</a>
<a name="ln335"> </a>
<a name="ln336">/*</a>
<a name="ln337"> * The next possible match in the current line for any pattern is remembered,</a>
<a name="ln338"> * to avoid having to try for a match in each column.</a>
<a name="ln339"> * If next_match_idx == -1, not tried (in this line) yet.</a>
<a name="ln340"> * If next_match_col == MAXCOL, no match found in this line.</a>
<a name="ln341"> * (All end positions have the column of the char after the end)</a>
<a name="ln342"> */</a>
<a name="ln343">static int next_match_col;              /* column for start of next match */</a>
<a name="ln344">static lpos_T next_match_m_endpos;      /* position for end of next match */</a>
<a name="ln345">static lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */</a>
<a name="ln346">static lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */</a>
<a name="ln347">static int next_match_idx;              /* index of matched item */</a>
<a name="ln348">static long next_match_flags;           /* flags for next match */</a>
<a name="ln349">static lpos_T next_match_eos_pos;       /* end of start pattn (start region) */</a>
<a name="ln350">static lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */</a>
<a name="ln351">static int next_match_end_idx;          /* ID of group for end pattn or zero */</a>
<a name="ln352">static reg_extmatch_T *next_match_extmatch = NULL;</a>
<a name="ln353"> </a>
<a name="ln354">/*</a>
<a name="ln355"> * A state stack is an array of integers or stateitem_T, stored in a</a>
<a name="ln356"> * garray_T.  A state stack is invalid if its itemsize entry is zero.</a>
<a name="ln357"> */</a>
<a name="ln358">#define INVALID_STATE(ssp)  ((ssp)-&gt;ga_itemsize == 0)</a>
<a name="ln359">#define VALID_STATE(ssp)    ((ssp)-&gt;ga_itemsize != 0)</a>
<a name="ln360"> </a>
<a name="ln361">/*</a>
<a name="ln362"> * The current state (within the line) of the recognition engine.</a>
<a name="ln363"> * When current_state.ga_itemsize is 0 the current state is invalid.</a>
<a name="ln364"> */</a>
<a name="ln365">static win_T    *syn_win;               // current window for highlighting</a>
<a name="ln366">static buf_T    *syn_buf;               // current buffer for highlighting</a>
<a name="ln367">static synblock_T *syn_block;           // current buffer for highlighting</a>
<a name="ln368">static proftime_T *syn_tm;              // timeout limit</a>
<a name="ln369">static linenr_T current_lnum = 0;       // lnum of current state</a>
<a name="ln370">static colnr_T current_col = 0;         // column of current state</a>
<a name="ln371">static int current_state_stored = 0;    // TRUE if stored current state</a>
<a name="ln372">                                        // after setting current_finished</a>
<a name="ln373">static int current_finished = 0;        // current line has been finished</a>
<a name="ln374">static garray_T current_state           // current stack of state_items</a>
<a name="ln375">  = GA_EMPTY_INIT_VALUE;</a>
<a name="ln376">static int16_t *current_next_list = NULL;   // when non-zero, nextgroup list</a>
<a name="ln377">static int current_next_flags = 0;          // flags for current_next_list</a>
<a name="ln378">static int current_line_id = 0;             // unique number for current line</a>
<a name="ln379"> </a>
<a name="ln380">#define CUR_STATE(idx)  ((stateitem_T *)(current_state.ga_data))[idx]</a>
<a name="ln381"> </a>
<a name="ln382">static int syn_time_on = FALSE;</a>
<a name="ln383"># define IF_SYN_TIME(p) (p)</a>
<a name="ln384"> </a>
<a name="ln385">// Set the timeout used for syntax highlighting.</a>
<a name="ln386">// Use NULL to reset, no timeout.</a>
<a name="ln387">void syn_set_timeout(proftime_T *tm)</a>
<a name="ln388">{</a>
<a name="ln389">  syn_tm = tm;</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/*</a>
<a name="ln393"> * Start the syntax recognition for a line.  This function is normally called</a>
<a name="ln394"> * from the screen updating, once for each displayed line.</a>
<a name="ln395"> * The buffer is remembered in syn_buf, because get_syntax_attr() doesn't get</a>
<a name="ln396"> * it.	Careful: curbuf and curwin are likely to point to another buffer and</a>
<a name="ln397"> * window.</a>
<a name="ln398"> */</a>
<a name="ln399">void syntax_start(win_T *wp, linenr_T lnum)</a>
<a name="ln400">{</a>
<a name="ln401">  synstate_T  *p;</a>
<a name="ln402">  synstate_T  *last_valid = NULL;</a>
<a name="ln403">  synstate_T  *last_min_valid = NULL;</a>
<a name="ln404">  synstate_T  *sp, *prev = NULL;</a>
<a name="ln405">  linenr_T parsed_lnum;</a>
<a name="ln406">  linenr_T first_stored;</a>
<a name="ln407">  int dist;</a>
<a name="ln408">  static int changedtick = 0;           /* remember the last change ID */</a>
<a name="ln409"> </a>
<a name="ln410">  current_sub_char = NUL;</a>
<a name="ln411"> </a>
<a name="ln412">  /*</a>
<a name="ln413">   * After switching buffers, invalidate current_state.</a>
<a name="ln414">   * Also do this when a change was made, the current state may be invalid</a>
<a name="ln415">   * then.</a>
<a name="ln416">   */</a>
<a name="ln417">  if (syn_block != wp-&gt;w_s</a>
<a name="ln418">      || syn_buf != wp-&gt;w_buffer</a>
<a name="ln419">      || changedtick != buf_get_changedtick(syn_buf)) {</a>
<a name="ln420">    invalidate_current_state();</a>
<a name="ln421">    syn_buf = wp-&gt;w_buffer;</a>
<a name="ln422">    syn_block = wp-&gt;w_s;</a>
<a name="ln423">  }</a>
<a name="ln424">  changedtick = buf_get_changedtick(syn_buf);</a>
<a name="ln425">  syn_win = wp;</a>
<a name="ln426"> </a>
<a name="ln427">  /*</a>
<a name="ln428">   * Allocate syntax stack when needed.</a>
<a name="ln429">   */</a>
<a name="ln430">  syn_stack_alloc();</a>
<a name="ln431">  if (syn_block-&gt;b_sst_array == NULL)</a>
<a name="ln432">    return;             /* out of memory */</a>
<a name="ln433">  syn_block-&gt;b_sst_lasttick = display_tick;</a>
<a name="ln434"> </a>
<a name="ln435">  /*</a>
<a name="ln436">   * If the state of the end of the previous line is useful, store it.</a>
<a name="ln437">   */</a>
<a name="ln438">  if (VALID_STATE(&amp;current_state)</a>
<a name="ln439">      &amp;&amp; current_lnum &lt; lnum</a>
<a name="ln440">      &amp;&amp; current_lnum &lt; syn_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln441">    (void)syn_finish_line(false);</a>
<a name="ln442">    if (!current_state_stored) {</a>
<a name="ln443">      ++current_lnum;</a>
<a name="ln444">      (void)store_current_state();</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">    /*</a>
<a name="ln448">     * If the current_lnum is now the same as &quot;lnum&quot;, keep the current</a>
<a name="ln449">     * state (this happens very often!).  Otherwise invalidate</a>
<a name="ln450">     * current_state and figure it out below.</a>
<a name="ln451">     */</a>
<a name="ln452">    if (current_lnum != lnum)</a>
<a name="ln453">      invalidate_current_state();</a>
<a name="ln454">  } else</a>
<a name="ln455">    invalidate_current_state();</a>
<a name="ln456"> </a>
<a name="ln457">  /*</a>
<a name="ln458">   * Try to synchronize from a saved state in b_sst_array[].</a>
<a name="ln459">   * Only do this if lnum is not before and not to far beyond a saved state.</a>
<a name="ln460">   */</a>
<a name="ln461">  if (INVALID_STATE(&amp;current_state) &amp;&amp; syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln462">    /* Find last valid saved state before start_lnum. */</a>
<a name="ln463">    for (p = syn_block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next) {</a>
<a name="ln464">      if (p-&gt;sst_lnum &gt; lnum) {</a>
<a name="ln465">        break;</a>
<a name="ln466">      }</a>
<a name="ln467">      if (p-&gt;sst_change_lnum == 0) {</a>
<a name="ln468">        last_valid = p;</a>
<a name="ln469">        if (p-&gt;sst_lnum &gt;= lnum - syn_block-&gt;b_syn_sync_minlines)</a>
<a name="ln470">          last_min_valid = p;</a>
<a name="ln471">      }</a>
<a name="ln472">    }</a>
<a name="ln473">    if (last_min_valid != NULL)</a>
<a name="ln474">      load_current_state(last_min_valid);</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  /*</a>
<a name="ln478">   * If &quot;lnum&quot; is before or far beyond a line with a saved state, need to</a>
<a name="ln479">   * re-synchronize.</a>
<a name="ln480">   */</a>
<a name="ln481">  if (INVALID_STATE(&amp;current_state)) {</a>
<a name="ln482">    syn_sync(wp, lnum, last_valid);</a>
<a name="ln483">    if (current_lnum == 1)</a>
<a name="ln484">      /* First line is always valid, no matter &quot;minlines&quot;. */</a>
<a name="ln485">      first_stored = 1;</a>
<a name="ln486">    else</a>
<a name="ln487">      /* Need to parse &quot;minlines&quot; lines before state can be considered</a>
<a name="ln488">       * valid to store. */</a>
<a name="ln489">      first_stored = current_lnum + syn_block-&gt;b_syn_sync_minlines;</a>
<a name="ln490">  } else</a>
<a name="ln491">    first_stored = current_lnum;</a>
<a name="ln492"> </a>
<a name="ln493">  /*</a>
<a name="ln494">   * Advance from the sync point or saved state until the current line.</a>
<a name="ln495">   * Save some entries for syncing with later on.</a>
<a name="ln496">   */</a>
<a name="ln497">  if (syn_block-&gt;b_sst_len &lt;= Rows)</a>
<a name="ln498">    dist = 999999;</a>
<a name="ln499">  else</a>
<a name="ln500">    dist = syn_buf-&gt;b_ml.ml_line_count / (syn_block-&gt;b_sst_len - Rows) + 1;</a>
<a name="ln501">  while (current_lnum &lt; lnum) {</a>
<a name="ln502">    syn_start_line();</a>
<a name="ln503">    (void)syn_finish_line(false);</a>
<a name="ln504">    current_lnum++;</a>
<a name="ln505"> </a>
<a name="ln506">    /* If we parsed at least &quot;minlines&quot; lines or started at a valid</a>
<a name="ln507">     * state, the current state is considered valid. */</a>
<a name="ln508">    if (current_lnum &gt;= first_stored) {</a>
<a name="ln509">      /* Check if the saved state entry is for the current line and is</a>
<a name="ln510">       * equal to the current state.  If so, then validate all saved</a>
<a name="ln511">       * states that depended on a change before the parsed line. */</a>
<a name="ln512">      if (prev == NULL)</a>
<a name="ln513">        prev = syn_stack_find_entry(current_lnum - 1);</a>
<a name="ln514">      if (prev == NULL)</a>
<a name="ln515">        sp = syn_block-&gt;b_sst_first;</a>
<a name="ln516">      else</a>
<a name="ln517">        sp = prev;</a>
<a name="ln518">      while (sp != NULL &amp;&amp; sp-&gt;sst_lnum &lt; current_lnum)</a>
<a name="ln519">        sp = sp-&gt;sst_next;</a>
<a name="ln520">      if (sp != NULL</a>
<a name="ln521">          &amp;&amp; sp-&gt;sst_lnum == current_lnum</a>
<a name="ln522">          &amp;&amp; syn_stack_equal(sp)) {</a>
<a name="ln523">        parsed_lnum = current_lnum;</a>
<a name="ln524">        prev = sp;</a>
<a name="ln525">        while (sp != NULL &amp;&amp; sp-&gt;sst_change_lnum &lt;= parsed_lnum) {</a>
<a name="ln526">          if (sp-&gt;sst_lnum &lt;= lnum)</a>
<a name="ln527">            /* valid state before desired line, use this one */</a>
<a name="ln528">            prev = sp;</a>
<a name="ln529">          else if (sp-&gt;sst_change_lnum == 0)</a>
<a name="ln530">            /* past saved states depending on change, break here. */</a>
<a name="ln531">            break;</a>
<a name="ln532">          sp-&gt;sst_change_lnum = 0;</a>
<a name="ln533">          sp = sp-&gt;sst_next;</a>
<a name="ln534">        }</a>
<a name="ln535">        load_current_state(prev);</a>
<a name="ln536">      }</a>
<a name="ln537">      /* Store the state at this line when it's the first one, the line</a>
<a name="ln538">       * where we start parsing, or some distance from the previously</a>
<a name="ln539">       * saved state.  But only when parsed at least 'minlines'. */</a>
<a name="ln540">      else if (prev == NULL</a>
<a name="ln541">               || current_lnum == lnum</a>
<a name="ln542">               || current_lnum &gt;= prev-&gt;sst_lnum + dist)</a>
<a name="ln543">        prev = store_current_state();</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">    /* This can take a long time: break when CTRL-C pressed.  The current</a>
<a name="ln547">     * state will be wrong then. */</a>
<a name="ln548">    line_breakcheck();</a>
<a name="ln549">    if (got_int) {</a>
<a name="ln550">      current_lnum = lnum;</a>
<a name="ln551">      break;</a>
<a name="ln552">    }</a>
<a name="ln553">  }</a>
<a name="ln554"> </a>
<a name="ln555">  syn_start_line();</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/*</a>
<a name="ln559"> * We cannot simply discard growarrays full of state_items or buf_states; we</a>
<a name="ln560"> * have to manually release their extmatch pointers first.</a>
<a name="ln561"> */</a>
<a name="ln562">static void clear_syn_state(synstate_T *p)</a>
<a name="ln563">{</a>
<a name="ln564">  if (p-&gt;sst_stacksize &gt; SST_FIX_STATES) {</a>
<a name="ln565">#   define UNREF_BUFSTATE_EXTMATCH(bs) unref_extmatch((bs)-&gt;bs_extmatch)</a>
<a name="ln566">    GA_DEEP_CLEAR(&amp;(p-&gt;sst_union.sst_ga), bufstate_T, UNREF_BUFSTATE_EXTMATCH);</a>
<a name="ln567">  } else {</a>
<a name="ln568">    for (int i = 0; i &lt; p-&gt;sst_stacksize; i++) {</a>
<a name="ln569">      unref_extmatch(p-&gt;sst_union.sst_stack[i].bs_extmatch);</a>
<a name="ln570">    }</a>
<a name="ln571">  }</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">/*</a>
<a name="ln575"> * Cleanup the current_state stack.</a>
<a name="ln576"> */</a>
<a name="ln577">static void clear_current_state(void)</a>
<a name="ln578">{</a>
<a name="ln579"># define UNREF_STATEITEM_EXTMATCH(si) unref_extmatch((si)-&gt;si_extmatch)</a>
<a name="ln580">  GA_DEEP_CLEAR(&amp;current_state, stateitem_T, UNREF_STATEITEM_EXTMATCH);</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">/*</a>
<a name="ln584"> * Try to find a synchronisation point for line &quot;lnum&quot;.</a>
<a name="ln585"> *</a>
<a name="ln586"> * This sets current_lnum and the current state.  One of three methods is</a>
<a name="ln587"> * used:</a>
<a name="ln588"> * 1. Search backwards for the end of a C-comment.</a>
<a name="ln589"> * 2. Search backwards for given sync patterns.</a>
<a name="ln590"> * 3. Simply start on a given number of lines above &quot;lnum&quot;.</a>
<a name="ln591"> */</a>
<a name="ln592">static void syn_sync(win_T *wp, linenr_T start_lnum, synstate_T *last_valid)</a>
<a name="ln593">{</a>
<a name="ln594">  buf_T       *curbuf_save;</a>
<a name="ln595">  win_T       *curwin_save;</a>
<a name="ln596">  pos_T cursor_save;</a>
<a name="ln597">  int idx;</a>
<a name="ln598">  linenr_T lnum;</a>
<a name="ln599">  linenr_T end_lnum;</a>
<a name="ln600">  linenr_T break_lnum;</a>
<a name="ln601">  bool had_sync_point;</a>
<a name="ln602">  stateitem_T *cur_si;</a>
<a name="ln603">  synpat_T    *spp;</a>
<a name="ln604">  char_u      *line;</a>
<a name="ln605">  int found_flags = 0;</a>
<a name="ln606">  int found_match_idx = 0;</a>
<a name="ln607">  linenr_T found_current_lnum = 0;</a>
<a name="ln608">  int found_current_col= 0;</a>
<a name="ln609">  lpos_T found_m_endpos;</a>
<a name="ln610">  colnr_T prev_current_col;</a>
<a name="ln611"> </a>
<a name="ln612">  /*</a>
<a name="ln613">   * Clear any current state that might be hanging around.</a>
<a name="ln614">   */</a>
<a name="ln615">  invalidate_current_state();</a>
<a name="ln616"> </a>
<a name="ln617">  /*</a>
<a name="ln618">   * Start at least &quot;minlines&quot; back.  Default starting point for parsing is</a>
<a name="ln619">   * there.</a>
<a name="ln620">   * Start further back, to avoid that scrolling backwards will result in</a>
<a name="ln621">   * resyncing for every line.  Now it resyncs only one out of N lines,</a>
<a name="ln622">   * where N is minlines * 1.5, or minlines * 2 if minlines is small.</a>
<a name="ln623">   * Watch out for overflow when minlines is MAXLNUM.</a>
<a name="ln624">   */</a>
<a name="ln625">  if (syn_block-&gt;b_syn_sync_minlines &gt; start_lnum)</a>
<a name="ln626">    start_lnum = 1;</a>
<a name="ln627">  else {</a>
<a name="ln628">    if (syn_block-&gt;b_syn_sync_minlines == 1)</a>
<a name="ln629">      lnum = 1;</a>
<a name="ln630">    else if (syn_block-&gt;b_syn_sync_minlines &lt; 10)</a>
<a name="ln631">      lnum = syn_block-&gt;b_syn_sync_minlines * 2;</a>
<a name="ln632">    else</a>
<a name="ln633">      lnum = syn_block-&gt;b_syn_sync_minlines * 3 / 2;</a>
<a name="ln634">    if (syn_block-&gt;b_syn_sync_maxlines != 0</a>
<a name="ln635">        &amp;&amp; lnum &gt; syn_block-&gt;b_syn_sync_maxlines)</a>
<a name="ln636">      lnum = syn_block-&gt;b_syn_sync_maxlines;</a>
<a name="ln637">    if (lnum &gt;= start_lnum)</a>
<a name="ln638">      start_lnum = 1;</a>
<a name="ln639">    else</a>
<a name="ln640">      start_lnum -= lnum;</a>
<a name="ln641">  }</a>
<a name="ln642">  current_lnum = start_lnum;</a>
<a name="ln643"> </a>
<a name="ln644">  /*</a>
<a name="ln645">   * 1. Search backwards for the end of a C-style comment.</a>
<a name="ln646">   */</a>
<a name="ln647">  if (syn_block-&gt;b_syn_sync_flags &amp; SF_CCOMMENT) {</a>
<a name="ln648">    /* Need to make syn_buf the current buffer for a moment, to be able to</a>
<a name="ln649">     * use find_start_comment(). */</a>
<a name="ln650">    curwin_save = curwin;</a>
<a name="ln651">    curwin = wp;</a>
<a name="ln652">    curbuf_save = curbuf;</a>
<a name="ln653">    curbuf = syn_buf;</a>
<a name="ln654"> </a>
<a name="ln655">    /*</a>
<a name="ln656">     * Skip lines that end in a backslash.</a>
<a name="ln657">     */</a>
<a name="ln658">    for (; start_lnum &gt; 1; --start_lnum) {</a>
<a name="ln659">      line = ml_get(start_lnum - 1);</a>
<a name="ln660">      if (*line == NUL || *(line + STRLEN(line) - 1) != '\\')</a>
<a name="ln661">        break;</a>
<a name="ln662">    }</a>
<a name="ln663">    current_lnum = start_lnum;</a>
<a name="ln664"> </a>
<a name="ln665">    /* set cursor to start of search */</a>
<a name="ln666">    cursor_save = wp-&gt;w_cursor;</a>
<a name="ln667">    wp-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln668">    wp-&gt;w_cursor.col = 0;</a>
<a name="ln669"> </a>
<a name="ln670">    /*</a>
<a name="ln671">     * If the line is inside a comment, need to find the syntax item that</a>
<a name="ln672">     * defines the comment.</a>
<a name="ln673">     * Restrict the search for the end of a comment to b_syn_sync_maxlines.</a>
<a name="ln674">     */</a>
<a name="ln675">    if (find_start_comment((int)syn_block-&gt;b_syn_sync_maxlines) != NULL) {</a>
<a name="ln676">      for (idx = syn_block-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; )</a>
<a name="ln677">        if (SYN_ITEMS(syn_block)[idx].sp_syn.id</a>
<a name="ln678">            == syn_block-&gt;b_syn_sync_id</a>
<a name="ln679">            &amp;&amp; SYN_ITEMS(syn_block)[idx].sp_type == SPTYPE_START) {</a>
<a name="ln680">          validate_current_state();</a>
<a name="ln681">          push_current_state(idx);</a>
<a name="ln682">          update_si_attr(current_state.ga_len - 1);</a>
<a name="ln683">          break;</a>
<a name="ln684">        }</a>
<a name="ln685">    }</a>
<a name="ln686"> </a>
<a name="ln687">    /* restore cursor and buffer */</a>
<a name="ln688">    wp-&gt;w_cursor = cursor_save;</a>
<a name="ln689">    curwin = curwin_save;</a>
<a name="ln690">    curbuf = curbuf_save;</a>
<a name="ln691">  }</a>
<a name="ln692">  /*</a>
<a name="ln693">   * 2. Search backwards for given sync patterns.</a>
<a name="ln694">   */</a>
<a name="ln695">  else if (syn_block-&gt;b_syn_sync_flags &amp; SF_MATCH) {</a>
<a name="ln696">    if (syn_block-&gt;b_syn_sync_maxlines != 0</a>
<a name="ln697">        &amp;&amp; start_lnum &gt; syn_block-&gt;b_syn_sync_maxlines)</a>
<a name="ln698">      break_lnum = start_lnum - syn_block-&gt;b_syn_sync_maxlines;</a>
<a name="ln699">    else</a>
<a name="ln700">      break_lnum = 0;</a>
<a name="ln701"> </a>
<a name="ln702">    found_m_endpos.lnum = 0;</a>
<a name="ln703">    found_m_endpos.col = 0;</a>
<a name="ln704">    end_lnum = start_lnum;</a>
<a name="ln705">    lnum = start_lnum;</a>
<a name="ln706">    while (--lnum &gt; break_lnum) {</a>
<a name="ln707">      /* This can take a long time: break when CTRL-C pressed. */</a>
<a name="ln708">      line_breakcheck();</a>
<a name="ln709">      if (got_int) {</a>
<a name="ln710">        invalidate_current_state();</a>
<a name="ln711">        current_lnum = start_lnum;</a>
<a name="ln712">        break;</a>
<a name="ln713">      }</a>
<a name="ln714"> </a>
<a name="ln715">      /* Check if we have run into a valid saved state stack now. */</a>
<a name="ln716">      if (last_valid != NULL &amp;&amp; lnum == last_valid-&gt;sst_lnum) {</a>
<a name="ln717">        load_current_state(last_valid);</a>
<a name="ln718">        break;</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">      /*</a>
<a name="ln722">       * Check if the previous line has the line-continuation pattern.</a>
<a name="ln723">       */</a>
<a name="ln724">      if (lnum &gt; 1 &amp;&amp; syn_match_linecont(lnum - 1))</a>
<a name="ln725">        continue;</a>
<a name="ln726"> </a>
<a name="ln727">      /*</a>
<a name="ln728">       * Start with nothing on the state stack</a>
<a name="ln729">       */</a>
<a name="ln730">      validate_current_state();</a>
<a name="ln731"> </a>
<a name="ln732">      for (current_lnum = lnum; current_lnum &lt; end_lnum; ++current_lnum) {</a>
<a name="ln733">        syn_start_line();</a>
<a name="ln734">        for (;; ) {</a>
<a name="ln735">          had_sync_point = syn_finish_line(true);</a>
<a name="ln736">          // When a sync point has been found, remember where, and</a>
<a name="ln737">          // continue to look for another one, further on in the line.</a>
<a name="ln738">          if (had_sync_point &amp;&amp; current_state.ga_len) {</a>
<a name="ln739">            cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln740">            if (cur_si-&gt;si_m_endpos.lnum &gt; start_lnum) {</a>
<a name="ln741">              /* ignore match that goes to after where started */</a>
<a name="ln742">              current_lnum = end_lnum;</a>
<a name="ln743">              break;</a>
<a name="ln744">            }</a>
<a name="ln745">            if (cur_si-&gt;si_idx &lt; 0) {</a>
<a name="ln746">              /* Cannot happen? */</a>
<a name="ln747">              found_flags = 0;</a>
<a name="ln748">              found_match_idx = KEYWORD_IDX;</a>
<a name="ln749">            } else {</a>
<a name="ln750">              spp = &amp;(SYN_ITEMS(syn_block)[cur_si-&gt;si_idx]);</a>
<a name="ln751">              found_flags = spp-&gt;sp_flags;</a>
<a name="ln752">              found_match_idx = spp-&gt;sp_sync_idx;</a>
<a name="ln753">            }</a>
<a name="ln754">            found_current_lnum = current_lnum;</a>
<a name="ln755">            found_current_col = current_col;</a>
<a name="ln756">            found_m_endpos = cur_si-&gt;si_m_endpos;</a>
<a name="ln757">            /*</a>
<a name="ln758">             * Continue after the match (be aware of a zero-length</a>
<a name="ln759">             * match).</a>
<a name="ln760">             */</a>
<a name="ln761">            if (found_m_endpos.lnum &gt; current_lnum) {</a>
<a name="ln762">              current_lnum = found_m_endpos.lnum;</a>
<a name="ln763">              current_col = found_m_endpos.col;</a>
<a name="ln764">              if (current_lnum &gt;= end_lnum)</a>
<a name="ln765">                break;</a>
<a name="ln766">            } else if (found_m_endpos.col &gt; current_col)</a>
<a name="ln767">              current_col = found_m_endpos.col;</a>
<a name="ln768">            else</a>
<a name="ln769">              ++current_col;</a>
<a name="ln770"> </a>
<a name="ln771">            /* syn_current_attr() will have skipped the check for</a>
<a name="ln772">             * an item that ends here, need to do that now.  Be</a>
<a name="ln773">             * careful not to go past the NUL. */</a>
<a name="ln774">            prev_current_col = current_col;</a>
<a name="ln775">            if (syn_getcurline()[current_col] != NUL)</a>
<a name="ln776">              ++current_col;</a>
<a name="ln777">            check_state_ends();</a>
<a name="ln778">            current_col = prev_current_col;</a>
<a name="ln779">          } else</a>
<a name="ln780">            break;</a>
<a name="ln781">        }</a>
<a name="ln782">      }</a>
<a name="ln783"> </a>
<a name="ln784">      /*</a>
<a name="ln785">       * If a sync point was encountered, break here.</a>
<a name="ln786">       */</a>
<a name="ln787">      if (found_flags) {</a>
<a name="ln788">        /*</a>
<a name="ln789">         * Put the item that was specified by the sync point on the</a>
<a name="ln790">         * state stack.  If there was no item specified, make the</a>
<a name="ln791">         * state stack empty.</a>
<a name="ln792">         */</a>
<a name="ln793">        clear_current_state();</a>
<a name="ln794">        if (found_match_idx &gt;= 0) {</a>
<a name="ln795">          push_current_state(found_match_idx);</a>
<a name="ln796">          update_si_attr(current_state.ga_len - 1);</a>
<a name="ln797">        }</a>
<a name="ln798"> </a>
<a name="ln799">        /*</a>
<a name="ln800">         * When using &quot;grouphere&quot;, continue from the sync point</a>
<a name="ln801">         * match, until the end of the line.  Parsing starts at</a>
<a name="ln802">         * the next line.</a>
<a name="ln803">         * For &quot;groupthere&quot; the parsing starts at start_lnum.</a>
<a name="ln804">         */</a>
<a name="ln805">        if (found_flags &amp; HL_SYNC_HERE) {</a>
<a name="ln806">          if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln807">            cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln808">            cur_si-&gt;si_h_startpos.lnum = found_current_lnum;</a>
<a name="ln809">            cur_si-&gt;si_h_startpos.col = found_current_col;</a>
<a name="ln810">            update_si_end(cur_si, (int)current_col, TRUE);</a>
<a name="ln811">            check_keepend();</a>
<a name="ln812">          }</a>
<a name="ln813">          current_col = found_m_endpos.col;</a>
<a name="ln814">          current_lnum = found_m_endpos.lnum;</a>
<a name="ln815">          (void)syn_finish_line(false);</a>
<a name="ln816">          current_lnum++;</a>
<a name="ln817">        } else {</a>
<a name="ln818">          current_lnum = start_lnum;</a>
<a name="ln819">        }</a>
<a name="ln820"> </a>
<a name="ln821">        break;</a>
<a name="ln822">      }</a>
<a name="ln823"> </a>
<a name="ln824">      end_lnum = lnum;</a>
<a name="ln825">      invalidate_current_state();</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">    /* Ran into start of the file or exceeded maximum number of lines */</a>
<a name="ln829">    if (lnum &lt;= break_lnum) {</a>
<a name="ln830">      invalidate_current_state();</a>
<a name="ln831">      current_lnum = break_lnum + 1;</a>
<a name="ln832">    }</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  validate_current_state();</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">static void save_chartab(char_u *chartab)</a>
<a name="ln839">{</a>
<a name="ln840">  if (syn_block-&gt;b_syn_isk != empty_option) {</a>
<a name="ln841">    memmove(chartab, syn_buf-&gt;b_chartab, (size_t)32);</a>
<a name="ln842">    memmove(syn_buf-&gt;b_chartab, syn_win-&gt;w_s-&gt;b_syn_chartab, (size_t)32);</a>
<a name="ln843">  }</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">static void restore_chartab(char_u *chartab)</a>
<a name="ln847">{</a>
<a name="ln848">  if (syn_win-&gt;w_s-&gt;b_syn_isk != empty_option) {</a>
<a name="ln849">    memmove(syn_buf-&gt;b_chartab, chartab, (size_t)32);</a>
<a name="ln850">  }</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">/*</a>
<a name="ln854"> * Return TRUE if the line-continuation pattern matches in line &quot;lnum&quot;.</a>
<a name="ln855"> */</a>
<a name="ln856">static int syn_match_linecont(linenr_T lnum)</a>
<a name="ln857">{</a>
<a name="ln858">  if (syn_block-&gt;b_syn_linecont_prog != NULL) {</a>
<a name="ln859">    regmmatch_T regmatch;</a>
<a name="ln860">    // chartab array for syn iskeyword</a>
<a name="ln861">    char_u buf_chartab[32];</a>
<a name="ln862">    save_chartab(buf_chartab);</a>
<a name="ln863"> </a>
<a name="ln864">    regmatch.rmm_ic = syn_block-&gt;b_syn_linecont_ic;</a>
<a name="ln865">    regmatch.regprog = syn_block-&gt;b_syn_linecont_prog;</a>
<a name="ln866">    int r = syn_regexec(&amp;regmatch, lnum, (colnr_T)0,</a>
<a name="ln867">                        IF_SYN_TIME(&amp;syn_block-&gt;b_syn_linecont_time));</a>
<a name="ln868">    syn_block-&gt;b_syn_linecont_prog = regmatch.regprog;</a>
<a name="ln869"> </a>
<a name="ln870">    restore_chartab(buf_chartab);</a>
<a name="ln871">    return r;</a>
<a name="ln872">  }</a>
<a name="ln873">  return FALSE;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">/*</a>
<a name="ln877"> * Prepare the current state for the start of a line.</a>
<a name="ln878"> */</a>
<a name="ln879">static void syn_start_line(void)</a>
<a name="ln880">{</a>
<a name="ln881">  current_finished = FALSE;</a>
<a name="ln882">  current_col = 0;</a>
<a name="ln883"> </a>
<a name="ln884">  /*</a>
<a name="ln885">   * Need to update the end of a start/skip/end that continues from the</a>
<a name="ln886">   * previous line and regions that have &quot;keepend&quot;.</a>
<a name="ln887">   */</a>
<a name="ln888">  if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln889">    syn_update_ends(TRUE);</a>
<a name="ln890">    check_state_ends();</a>
<a name="ln891">  }</a>
<a name="ln892"> </a>
<a name="ln893">  next_match_idx = -1;</a>
<a name="ln894">  current_line_id++;</a>
<a name="ln895">  next_seqnr = 1;</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">/*</a>
<a name="ln899"> * Check for items in the stack that need their end updated.</a>
<a name="ln900"> * When &quot;startofline&quot; is TRUE the last item is always updated.</a>
<a name="ln901"> * When &quot;startofline&quot; is FALSE the item with &quot;keepend&quot; is forcefully updated.</a>
<a name="ln902"> */</a>
<a name="ln903">static void syn_update_ends(int startofline)</a>
<a name="ln904">{</a>
<a name="ln905">  stateitem_T *cur_si;</a>
<a name="ln906">  int seen_keepend;</a>
<a name="ln907"> </a>
<a name="ln908">  if (startofline) {</a>
<a name="ln909">    /* Check for a match carried over from a previous line with a</a>
<a name="ln910">     * contained region.  The match ends as soon as the region ends. */</a>
<a name="ln911">    for (int i = 0; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln912">      cur_si = &amp;CUR_STATE(i);</a>
<a name="ln913">      if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln914">          &amp;&amp; (SYN_ITEMS(syn_block)[cur_si-&gt;si_idx]).sp_type</a>
<a name="ln915">          == SPTYPE_MATCH</a>
<a name="ln916">          &amp;&amp; cur_si-&gt;si_m_endpos.lnum &lt; current_lnum) {</a>
<a name="ln917">        cur_si-&gt;si_flags |= HL_MATCHCONT;</a>
<a name="ln918">        cur_si-&gt;si_m_endpos.lnum = 0;</a>
<a name="ln919">        cur_si-&gt;si_m_endpos.col = 0;</a>
<a name="ln920">        cur_si-&gt;si_h_endpos = cur_si-&gt;si_m_endpos;</a>
<a name="ln921">        cur_si-&gt;si_ends = TRUE;</a>
<a name="ln922">      }</a>
<a name="ln923">    }</a>
<a name="ln924">  }</a>
<a name="ln925"> </a>
<a name="ln926">  /*</a>
<a name="ln927">   * Need to update the end of a start/skip/end that continues from the</a>
<a name="ln928">   * previous line.  And regions that have &quot;keepend&quot;, because they may</a>
<a name="ln929">   * influence contained items.  If we've just removed &quot;extend&quot;</a>
<a name="ln930">   * (startofline == 0) then we should update ends of normal regions</a>
<a name="ln931">   * contained inside &quot;keepend&quot; because &quot;extend&quot; could have extended</a>
<a name="ln932">   * these &quot;keepend&quot; regions as well as contained normal regions.</a>
<a name="ln933">   * Then check for items ending in column 0.</a>
<a name="ln934">   */</a>
<a name="ln935">  int i = current_state.ga_len - 1;</a>
<a name="ln936">  if (keepend_level &gt;= 0)</a>
<a name="ln937">    for (; i &gt; keepend_level; --i)</a>
<a name="ln938">      if (CUR_STATE(i).si_flags &amp; HL_EXTEND)</a>
<a name="ln939">        break;</a>
<a name="ln940"> </a>
<a name="ln941">  seen_keepend = FALSE;</a>
<a name="ln942">  for (; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln943">    cur_si = &amp;CUR_STATE(i);</a>
<a name="ln944">    if ((cur_si-&gt;si_flags &amp; HL_KEEPEND)</a>
<a name="ln945">        || (seen_keepend &amp;&amp; !startofline)</a>
<a name="ln946">        || (i == current_state.ga_len - 1 &amp;&amp; startofline)) {</a>
<a name="ln947">      cur_si-&gt;si_h_startpos.col = 0;            /* start highl. in col 0 */</a>
<a name="ln948">      cur_si-&gt;si_h_startpos.lnum = current_lnum;</a>
<a name="ln949"> </a>
<a name="ln950">      if (!(cur_si-&gt;si_flags &amp; HL_MATCHCONT))</a>
<a name="ln951">        update_si_end(cur_si, (int)current_col, !startofline);</a>
<a name="ln952"> </a>
<a name="ln953">      if (!startofline &amp;&amp; (cur_si-&gt;si_flags &amp; HL_KEEPEND))</a>
<a name="ln954">        seen_keepend = TRUE;</a>
<a name="ln955">    }</a>
<a name="ln956">  }</a>
<a name="ln957">  check_keepend();</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">/****************************************</a>
<a name="ln961"> * Handling of the state stack cache.</a>
<a name="ln962"> */</a>
<a name="ln963"> </a>
<a name="ln964">/*</a>
<a name="ln965"> * EXPLANATION OF THE SYNTAX STATE STACK CACHE</a>
<a name="ln966"> *</a>
<a name="ln967"> * To speed up syntax highlighting, the state stack for the start of some</a>
<a name="ln968"> * lines is cached.  These entries can be used to start parsing at that point.</a>
<a name="ln969"> *</a>
<a name="ln970"> * The stack is kept in b_sst_array[] for each buffer.  There is a list of</a>
<a name="ln971"> * valid entries.  b_sst_first points to the first one, then follow sst_next.</a>
<a name="ln972"> * The entries are sorted on line number.  The first entry is often for line 2</a>
<a name="ln973"> * (line 1 always starts with an empty stack).</a>
<a name="ln974"> * There is also a list for free entries.  This construction is used to avoid</a>
<a name="ln975"> * having to allocate and free memory blocks too often.</a>
<a name="ln976"> *</a>
<a name="ln977"> * When making changes to the buffer, this is logged in b_mod_*.  When calling</a>
<a name="ln978"> * update_screen() to update the display, it will call</a>
<a name="ln979"> * syn_stack_apply_changes() for each displayed buffer to adjust the cached</a>
<a name="ln980"> * entries.  The entries which are inside the changed area are removed,</a>
<a name="ln981"> * because they must be recomputed.  Entries below the changed have their line</a>
<a name="ln982"> * number adjusted for deleted/inserted lines, and have their sst_change_lnum</a>
<a name="ln983"> * set to indicate that a check must be made if the changed lines would change</a>
<a name="ln984"> * the cached entry.</a>
<a name="ln985"> *</a>
<a name="ln986"> * When later displaying lines, an entry is stored for each line.  Displayed</a>
<a name="ln987"> * lines are likely to be displayed again, in which case the state at the</a>
<a name="ln988"> * start of the line is needed.</a>
<a name="ln989"> * For not displayed lines, an entry is stored for every so many lines.  These</a>
<a name="ln990"> * entries will be used e.g., when scrolling backwards.  The distance between</a>
<a name="ln991"> * entries depends on the number of lines in the buffer.  For small buffers</a>
<a name="ln992"> * the distance is fixed at SST_DIST, for large buffers there is a fixed</a>
<a name="ln993"> * number of entries SST_MAX_ENTRIES, and the distance is computed.</a>
<a name="ln994"> */</a>
<a name="ln995"> </a>
<a name="ln996">static void syn_stack_free_block(synblock_T *block)</a>
<a name="ln997">{</a>
<a name="ln998">  synstate_T  *p;</a>
<a name="ln999"> </a>
<a name="ln1000">  if (block-&gt;b_sst_array != NULL) {</a>
<a name="ln1001">    for (p = block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next) {</a>
<a name="ln1002">      clear_syn_state(p);</a>
<a name="ln1003">    }</a>
<a name="ln1004">    XFREE_CLEAR(block-&gt;b_sst_array);</a>
<a name="ln1005">    block-&gt;b_sst_first = NULL;</a>
<a name="ln1006">    block-&gt;b_sst_len = 0;</a>
<a name="ln1007">  }</a>
<a name="ln1008">}</a>
<a name="ln1009">/*</a>
<a name="ln1010"> * Free b_sst_array[] for buffer &quot;buf&quot;.</a>
<a name="ln1011"> * Used when syntax items changed to force resyncing everywhere.</a>
<a name="ln1012"> */</a>
<a name="ln1013">void syn_stack_free_all(synblock_T *block)</a>
<a name="ln1014">{</a>
<a name="ln1015">  syn_stack_free_block(block);</a>
<a name="ln1016"> </a>
<a name="ln1017">  /* When using &quot;syntax&quot; fold method, must update all folds. */</a>
<a name="ln1018">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1019">    if (wp-&gt;w_s == block &amp;&amp; foldmethodIsSyntax(wp)) {</a>
<a name="ln1020">      foldUpdateAll(wp);</a>
<a name="ln1021">    }</a>
<a name="ln1022">  }</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">/*</a>
<a name="ln1026"> * Allocate the syntax state stack for syn_buf when needed.</a>
<a name="ln1027"> * If the number of entries in b_sst_array[] is much too big or a bit too</a>
<a name="ln1028"> * small, reallocate it.</a>
<a name="ln1029"> * Also used to allocate b_sst_array[] for the first time.</a>
<a name="ln1030"> */</a>
<a name="ln1031">static void syn_stack_alloc(void)</a>
<a name="ln1032">{</a>
<a name="ln1033">  long len;</a>
<a name="ln1034">  synstate_T  *to, *from;</a>
<a name="ln1035">  synstate_T  *sstp;</a>
<a name="ln1036"> </a>
<a name="ln1037">  len = syn_buf-&gt;b_ml.ml_line_count / SST_DIST + Rows * 2;</a>
<a name="ln1038">  if (len &lt; SST_MIN_ENTRIES)</a>
<a name="ln1039">    len = SST_MIN_ENTRIES;</a>
<a name="ln1040">  else if (len &gt; SST_MAX_ENTRIES)</a>
<a name="ln1041">    len = SST_MAX_ENTRIES;</a>
<a name="ln1042">  if (syn_block-&gt;b_sst_len &gt; len * 2 || syn_block-&gt;b_sst_len &lt; len) {</a>
<a name="ln1043">    /* Allocate 50% too much, to avoid reallocating too often. */</a>
<a name="ln1044">    len = syn_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1045">    len = (len + len / 2) / SST_DIST + Rows * 2;</a>
<a name="ln1046">    if (len &lt; SST_MIN_ENTRIES)</a>
<a name="ln1047">      len = SST_MIN_ENTRIES;</a>
<a name="ln1048">    else if (len &gt; SST_MAX_ENTRIES)</a>
<a name="ln1049">      len = SST_MAX_ENTRIES;</a>
<a name="ln1050"> </a>
<a name="ln1051">    if (syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln1052">      /* When shrinking the array, cleanup the existing stack.</a>
<a name="ln1053">       * Make sure that all valid entries fit in the new array. */</a>
<a name="ln1054">      while (syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2 &gt; len</a>
<a name="ln1055">             &amp;&amp; syn_stack_cleanup())</a>
<a name="ln1056">        ;</a>
<a name="ln1057">      if (len &lt; syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2)</a>
<a name="ln1058">        len = syn_block-&gt;b_sst_len - syn_block-&gt;b_sst_freecount + 2;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">    assert(len &gt;= 0);</a>
<a name="ln1062">    sstp = xcalloc(len, sizeof(synstate_T));</a>
<a name="ln1063"> </a>
<a name="ln1064">    to = sstp - 1;</a>
<a name="ln1065">    if (syn_block-&gt;b_sst_array != NULL) {</a>
<a name="ln1066">      /* Move the states from the old array to the new one. */</a>
<a name="ln1067">      for (from = syn_block-&gt;b_sst_first; from != NULL;</a>
<a name="ln1068">           from = from-&gt;sst_next) {</a>
<a name="ln1069">        ++to;</a>
<a name="ln1070">        *to = *from;</a>
<a name="ln1071">        to-&gt;sst_next = to + 1;</a>
<a name="ln1072">      }</a>
<a name="ln1073">    }</a>
<a name="ln1074">    if (to != sstp - 1) {</a>
<a name="ln1075">      to-&gt;sst_next = NULL;</a>
<a name="ln1076">      syn_block-&gt;b_sst_first = sstp;</a>
<a name="ln1077">      syn_block-&gt;b_sst_freecount = len - (int)(to - sstp) - 1;</a>
<a name="ln1078">    } else {</a>
<a name="ln1079">      syn_block-&gt;b_sst_first = NULL;</a>
<a name="ln1080">      syn_block-&gt;b_sst_freecount = len;</a>
<a name="ln1081">    }</a>
<a name="ln1082"> </a>
<a name="ln1083">    /* Create the list of free entries. */</a>
<a name="ln1084">    syn_block-&gt;b_sst_firstfree = to + 1;</a>
<a name="ln1085">    while (++to &lt; sstp + len)</a>
<a name="ln1086">      to-&gt;sst_next = to + 1;</a>
<a name="ln1087">    (sstp + len - 1)-&gt;sst_next = NULL;</a>
<a name="ln1088"> </a>
<a name="ln1089">    xfree(syn_block-&gt;b_sst_array);</a>
<a name="ln1090">    syn_block-&gt;b_sst_array = sstp;</a>
<a name="ln1091">    syn_block-&gt;b_sst_len = len;</a>
<a name="ln1092">  }</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">/*</a>
<a name="ln1096"> * Check for changes in a buffer to affect stored syntax states.  Uses the</a>
<a name="ln1097"> * b_mod_* fields.</a>
<a name="ln1098"> * Called from update_screen(), before screen is being updated, once for each</a>
<a name="ln1099"> * displayed buffer.</a>
<a name="ln1100"> */</a>
<a name="ln1101">void syn_stack_apply_changes(buf_T *buf)</a>
<a name="ln1102">{</a>
<a name="ln1103">  syn_stack_apply_changes_block(&amp;buf-&gt;b_s, buf);</a>
<a name="ln1104"> </a>
<a name="ln1105">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1106">    if ((wp-&gt;w_buffer == buf) &amp;&amp; (wp-&gt;w_s != &amp;buf-&gt;b_s)) {</a>
<a name="ln1107">      syn_stack_apply_changes_block(wp-&gt;w_s, buf);</a>
<a name="ln1108">    }</a>
<a name="ln1109">  }</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">static void syn_stack_apply_changes_block(synblock_T *block, buf_T *buf)</a>
<a name="ln1113">{</a>
<a name="ln1114">  synstate_T  *p, *prev, *np;</a>
<a name="ln1115">  linenr_T n;</a>
<a name="ln1116"> </a>
<a name="ln1117">  prev = NULL;</a>
<a name="ln1118">  for (p = block-&gt;b_sst_first; p != NULL; ) {</a>
<a name="ln1119">    if (p-&gt;sst_lnum + block-&gt;b_syn_sync_linebreaks &gt; buf-&gt;b_mod_top) {</a>
<a name="ln1120">      n = p-&gt;sst_lnum + buf-&gt;b_mod_xlines;</a>
<a name="ln1121">      if (n &lt;= buf-&gt;b_mod_bot) {</a>
<a name="ln1122">        /* this state is inside the changed area, remove it */</a>
<a name="ln1123">        np = p-&gt;sst_next;</a>
<a name="ln1124">        if (prev == NULL)</a>
<a name="ln1125">          block-&gt;b_sst_first = np;</a>
<a name="ln1126">        else</a>
<a name="ln1127">          prev-&gt;sst_next = np;</a>
<a name="ln1128">        syn_stack_free_entry(block, p);</a>
<a name="ln1129">        p = np;</a>
<a name="ln1130">        continue;</a>
<a name="ln1131">      }</a>
<a name="ln1132">      /* This state is below the changed area.  Remember the line</a>
<a name="ln1133">       * that needs to be parsed before this entry can be made valid</a>
<a name="ln1134">       * again. */</a>
<a name="ln1135">      if (p-&gt;sst_change_lnum != 0 &amp;&amp; p-&gt;sst_change_lnum &gt; buf-&gt;b_mod_top) {</a>
<a name="ln1136">        if (p-&gt;sst_change_lnum + buf-&gt;b_mod_xlines &gt; buf-&gt;b_mod_top)</a>
<a name="ln1137">          p-&gt;sst_change_lnum += buf-&gt;b_mod_xlines;</a>
<a name="ln1138">        else</a>
<a name="ln1139">          p-&gt;sst_change_lnum = buf-&gt;b_mod_top;</a>
<a name="ln1140">      }</a>
<a name="ln1141">      if (p-&gt;sst_change_lnum == 0</a>
<a name="ln1142">          || p-&gt;sst_change_lnum &lt; buf-&gt;b_mod_bot)</a>
<a name="ln1143">        p-&gt;sst_change_lnum = buf-&gt;b_mod_bot;</a>
<a name="ln1144"> </a>
<a name="ln1145">      p-&gt;sst_lnum = n;</a>
<a name="ln1146">    }</a>
<a name="ln1147">    prev = p;</a>
<a name="ln1148">    p = p-&gt;sst_next;</a>
<a name="ln1149">  }</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">/*</a>
<a name="ln1153"> * Reduce the number of entries in the state stack for syn_buf.</a>
<a name="ln1154"> * Returns TRUE if at least one entry was freed.</a>
<a name="ln1155"> */</a>
<a name="ln1156">static int syn_stack_cleanup(void)</a>
<a name="ln1157">{</a>
<a name="ln1158">  synstate_T  *p, *prev;</a>
<a name="ln1159">  disptick_T tick;</a>
<a name="ln1160">  int above;</a>
<a name="ln1161">  int dist;</a>
<a name="ln1162">  int retval = FALSE;</a>
<a name="ln1163"> </a>
<a name="ln1164">  if (syn_block-&gt;b_sst_first == NULL) {</a>
<a name="ln1165">    return retval;</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  /* Compute normal distance between non-displayed entries. */</a>
<a name="ln1169">  if (syn_block-&gt;b_sst_len &lt;= Rows)</a>
<a name="ln1170">    dist = 999999;</a>
<a name="ln1171">  else</a>
<a name="ln1172">    dist = syn_buf-&gt;b_ml.ml_line_count / (syn_block-&gt;b_sst_len - Rows) + 1;</a>
<a name="ln1173"> </a>
<a name="ln1174">  /*</a>
<a name="ln1175">   * Go through the list to find the &quot;tick&quot; for the oldest entry that can</a>
<a name="ln1176">   * be removed.  Set &quot;above&quot; when the &quot;tick&quot; for the oldest entry is above</a>
<a name="ln1177">   * &quot;b_sst_lasttick&quot; (the display tick wraps around).</a>
<a name="ln1178">   */</a>
<a name="ln1179">  tick = syn_block-&gt;b_sst_lasttick;</a>
<a name="ln1180">  above = FALSE;</a>
<a name="ln1181">  prev = syn_block-&gt;b_sst_first;</a>
<a name="ln1182">  for (p = prev-&gt;sst_next; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1183">    if (prev-&gt;sst_lnum + dist &gt; p-&gt;sst_lnum) {</a>
<a name="ln1184">      if (p-&gt;sst_tick &gt; syn_block-&gt;b_sst_lasttick) {</a>
<a name="ln1185">        if (!above || p-&gt;sst_tick &lt; tick)</a>
<a name="ln1186">          tick = p-&gt;sst_tick;</a>
<a name="ln1187">        above = TRUE;</a>
<a name="ln1188">      } else if (!above &amp;&amp; p-&gt;sst_tick &lt; tick)</a>
<a name="ln1189">        tick = p-&gt;sst_tick;</a>
<a name="ln1190">    }</a>
<a name="ln1191">  }</a>
<a name="ln1192"> </a>
<a name="ln1193">  /*</a>
<a name="ln1194">   * Go through the list to make the entries for the oldest tick at an</a>
<a name="ln1195">   * interval of several lines.</a>
<a name="ln1196">   */</a>
<a name="ln1197">  prev = syn_block-&gt;b_sst_first;</a>
<a name="ln1198">  for (p = prev-&gt;sst_next; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1199">    if (p-&gt;sst_tick == tick &amp;&amp; prev-&gt;sst_lnum + dist &gt; p-&gt;sst_lnum) {</a>
<a name="ln1200">      /* Move this entry from used list to free list */</a>
<a name="ln1201">      prev-&gt;sst_next = p-&gt;sst_next;</a>
<a name="ln1202">      syn_stack_free_entry(syn_block, p);</a>
<a name="ln1203">      p = prev;</a>
<a name="ln1204">      retval = TRUE;</a>
<a name="ln1205">    }</a>
<a name="ln1206">  }</a>
<a name="ln1207">  return retval;</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">/*</a>
<a name="ln1211"> * Free the allocated memory for a syn_state item.</a>
<a name="ln1212"> * Move the entry into the free list.</a>
<a name="ln1213"> */</a>
<a name="ln1214">static void syn_stack_free_entry(synblock_T *block, synstate_T *p)</a>
<a name="ln1215">{</a>
<a name="ln1216">  clear_syn_state(p);</a>
<a name="ln1217">  p-&gt;sst_next = block-&gt;b_sst_firstfree;</a>
<a name="ln1218">  block-&gt;b_sst_firstfree = p;</a>
<a name="ln1219">  ++block-&gt;b_sst_freecount;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">/*</a>
<a name="ln1223"> * Find an entry in the list of state stacks at or before &quot;lnum&quot;.</a>
<a name="ln1224"> * Returns NULL when there is no entry or the first entry is after &quot;lnum&quot;.</a>
<a name="ln1225"> */</a>
<a name="ln1226">static synstate_T *syn_stack_find_entry(linenr_T lnum)</a>
<a name="ln1227">{</a>
<a name="ln1228">  synstate_T  *p, *prev;</a>
<a name="ln1229"> </a>
<a name="ln1230">  prev = NULL;</a>
<a name="ln1231">  for (p = syn_block-&gt;b_sst_first; p != NULL; prev = p, p = p-&gt;sst_next) {</a>
<a name="ln1232">    if (p-&gt;sst_lnum == lnum)</a>
<a name="ln1233">      return p;</a>
<a name="ln1234">    if (p-&gt;sst_lnum &gt; lnum)</a>
<a name="ln1235">      break;</a>
<a name="ln1236">  }</a>
<a name="ln1237">  return prev;</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">/*</a>
<a name="ln1241"> * Try saving the current state in b_sst_array[].</a>
<a name="ln1242"> * The current state must be valid for the start of the current_lnum line!</a>
<a name="ln1243"> */</a>
<a name="ln1244">static synstate_T *store_current_state(void)</a>
<a name="ln1245">{</a>
<a name="ln1246">  int i;</a>
<a name="ln1247">  synstate_T  *p;</a>
<a name="ln1248">  bufstate_T  *bp;</a>
<a name="ln1249">  stateitem_T *cur_si;</a>
<a name="ln1250">  synstate_T  *sp = syn_stack_find_entry(current_lnum);</a>
<a name="ln1251"> </a>
<a name="ln1252">  /*</a>
<a name="ln1253">   * If the current state contains a start or end pattern that continues</a>
<a name="ln1254">   * from the previous line, we can't use it.  Don't store it then.</a>
<a name="ln1255">   */</a>
<a name="ln1256">  for (i = current_state.ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln1257">    cur_si = &amp;CUR_STATE(i);</a>
<a name="ln1258">    if (cur_si-&gt;si_h_startpos.lnum &gt;= current_lnum</a>
<a name="ln1259">        || cur_si-&gt;si_m_endpos.lnum &gt;= current_lnum</a>
<a name="ln1260">        || cur_si-&gt;si_h_endpos.lnum &gt;= current_lnum</a>
<a name="ln1261">        || (cur_si-&gt;si_end_idx</a>
<a name="ln1262">            &amp;&amp; cur_si-&gt;si_eoe_pos.lnum &gt;= current_lnum))</a>
<a name="ln1263">      break;</a>
<a name="ln1264">  }</a>
<a name="ln1265">  if (i &gt;= 0) {</a>
<a name="ln1266">    if (sp != NULL) {</a>
<a name="ln1267">      /* find &quot;sp&quot; in the list and remove it */</a>
<a name="ln1268">      if (syn_block-&gt;b_sst_first == sp)</a>
<a name="ln1269">        /* it's the first entry */</a>
<a name="ln1270">        syn_block-&gt;b_sst_first = sp-&gt;sst_next;</a>
<a name="ln1271">      else {</a>
<a name="ln1272">        /* find the entry just before this one to adjust sst_next */</a>
<a name="ln1273">        for (p = syn_block-&gt;b_sst_first; p != NULL; p = p-&gt;sst_next)</a>
<a name="ln1274">          if (p-&gt;sst_next == sp)</a>
<a name="ln1275">            break;</a>
<a name="ln1276">        if (p != NULL)          /* just in case */</a>
<a name="ln1277">          p-&gt;sst_next = sp-&gt;sst_next;</a>
<a name="ln1278">      }</a>
<a name="ln1279">      syn_stack_free_entry(syn_block, sp);</a>
<a name="ln1280">      sp = NULL;</a>
<a name="ln1281">    }</a>
<a name="ln1282">  } else if (sp == NULL || sp-&gt;sst_lnum != current_lnum)   {</a>
<a name="ln1283">    /*</a>
<a name="ln1284">     * Add a new entry</a>
<a name="ln1285">     */</a>
<a name="ln1286">    /* If no free items, cleanup the array first. */</a>
<a name="ln1287">    if (syn_block-&gt;b_sst_freecount == 0) {</a>
<a name="ln1288">      (void)syn_stack_cleanup();</a>
<a name="ln1289">      /* &quot;sp&quot; may have been moved to the freelist now */</a>
<a name="ln1290">      sp = syn_stack_find_entry(current_lnum);</a>
<a name="ln1291">    }</a>
<a name="ln1292">    /* Still no free items?  Must be a strange problem... */</a>
<a name="ln1293">    if (syn_block-&gt;b_sst_freecount == 0)</a>
<a name="ln1294">      sp = NULL;</a>
<a name="ln1295">    else {</a>
<a name="ln1296">      /* Take the first item from the free list and put it in the used</a>
<a name="ln1297">       * list, after *sp */</a>
<a name="ln1298">      p = syn_block-&gt;b_sst_firstfree;</a>
<a name="ln1299">      syn_block-&gt;b_sst_firstfree = p-&gt;sst_next;</a>
<a name="ln1300">      --syn_block-&gt;b_sst_freecount;</a>
<a name="ln1301">      if (sp == NULL) {</a>
<a name="ln1302">        /* Insert in front of the list */</a>
<a name="ln1303">        p-&gt;sst_next = syn_block-&gt;b_sst_first;</a>
<a name="ln1304">        syn_block-&gt;b_sst_first = p;</a>
<a name="ln1305">      } else {</a>
<a name="ln1306">        /* insert in list after *sp */</a>
<a name="ln1307">        p-&gt;sst_next = sp-&gt;sst_next;</a>
<a name="ln1308">        sp-&gt;sst_next = p;</a>
<a name="ln1309">      }</a>
<a name="ln1310">      sp = p;</a>
<a name="ln1311">      sp-&gt;sst_stacksize = 0;</a>
<a name="ln1312">      sp-&gt;sst_lnum = current_lnum;</a>
<a name="ln1313">    }</a>
<a name="ln1314">  }</a>
<a name="ln1315">  if (sp != NULL) {</a>
<a name="ln1316">    /* When overwriting an existing state stack, clear it first */</a>
<a name="ln1317">    clear_syn_state(sp);</a>
<a name="ln1318">    sp-&gt;sst_stacksize = current_state.ga_len;</a>
<a name="ln1319">    if (current_state.ga_len &gt; SST_FIX_STATES) {</a>
<a name="ln1320">      /* Need to clear it, might be something remaining from when the</a>
<a name="ln1321">       * length was less than SST_FIX_STATES. */</a>
<a name="ln1322">      ga_init(&amp;sp-&gt;sst_union.sst_ga, (int)sizeof(bufstate_T), 1);</a>
<a name="ln1323">      ga_grow(&amp;sp-&gt;sst_union.sst_ga, current_state.ga_len);</a>
<a name="ln1324">      sp-&gt;sst_union.sst_ga.ga_len = current_state.ga_len;</a>
<a name="ln1325">      bp = SYN_STATE_P(&amp;(sp-&gt;sst_union.sst_ga));</a>
<a name="ln1326">    } else</a>
<a name="ln1327">      bp = sp-&gt;sst_union.sst_stack;</a>
<a name="ln1328">    for (i = 0; i &lt; sp-&gt;sst_stacksize; ++i) {</a>
<a name="ln1329">      bp[i].bs_idx = CUR_STATE(i).si_idx;</a>
<a name="ln1330">      bp[i].bs_flags = CUR_STATE(i).si_flags;</a>
<a name="ln1331">      bp[i].bs_seqnr = CUR_STATE(i).si_seqnr;</a>
<a name="ln1332">      bp[i].bs_cchar = CUR_STATE(i).si_cchar;</a>
<a name="ln1333">      bp[i].bs_extmatch = ref_extmatch(CUR_STATE(i).si_extmatch);</a>
<a name="ln1334">    }</a>
<a name="ln1335">    sp-&gt;sst_next_flags = current_next_flags;</a>
<a name="ln1336">    sp-&gt;sst_next_list = current_next_list;</a>
<a name="ln1337">    sp-&gt;sst_tick = display_tick;</a>
<a name="ln1338">    sp-&gt;sst_change_lnum = 0;</a>
<a name="ln1339">  }</a>
<a name="ln1340">  current_state_stored = TRUE;</a>
<a name="ln1341">  return sp;</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344">/*</a>
<a name="ln1345"> * Copy a state stack from &quot;from&quot; in b_sst_array[] to current_state;</a>
<a name="ln1346"> */</a>
<a name="ln1347">static void load_current_state(synstate_T *from)</a>
<a name="ln1348">{</a>
<a name="ln1349">  int i;</a>
<a name="ln1350">  bufstate_T  *bp;</a>
<a name="ln1351"> </a>
<a name="ln1352">  clear_current_state();</a>
<a name="ln1353">  validate_current_state();</a>
<a name="ln1354">  keepend_level = -1;</a>
<a name="ln1355">  if (from-&gt;sst_stacksize) {</a>
<a name="ln1356">    ga_grow(&amp;current_state, from-&gt;sst_stacksize);</a>
<a name="ln1357">    if (from-&gt;sst_stacksize &gt; SST_FIX_STATES)</a>
<a name="ln1358">      bp = SYN_STATE_P(&amp;(from-&gt;sst_union.sst_ga));</a>
<a name="ln1359">    else</a>
<a name="ln1360">      bp = from-&gt;sst_union.sst_stack;</a>
<a name="ln1361">    for (i = 0; i &lt; from-&gt;sst_stacksize; ++i) {</a>
<a name="ln1362">      CUR_STATE(i).si_idx = bp[i].bs_idx;</a>
<a name="ln1363">      CUR_STATE(i).si_flags = bp[i].bs_flags;</a>
<a name="ln1364">      CUR_STATE(i).si_seqnr = bp[i].bs_seqnr;</a>
<a name="ln1365">      CUR_STATE(i).si_cchar = bp[i].bs_cchar;</a>
<a name="ln1366">      CUR_STATE(i).si_extmatch = ref_extmatch(bp[i].bs_extmatch);</a>
<a name="ln1367">      if (keepend_level &lt; 0 &amp;&amp; (CUR_STATE(i).si_flags &amp; HL_KEEPEND))</a>
<a name="ln1368">        keepend_level = i;</a>
<a name="ln1369">      CUR_STATE(i).si_ends = FALSE;</a>
<a name="ln1370">      CUR_STATE(i).si_m_lnum = 0;</a>
<a name="ln1371">      if (CUR_STATE(i).si_idx &gt;= 0)</a>
<a name="ln1372">        CUR_STATE(i).si_next_list =</a>
<a name="ln1373">          (SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_next_list;</a>
<a name="ln1374">      else</a>
<a name="ln1375">        CUR_STATE(i).si_next_list = NULL;</a>
<a name="ln1376">      update_si_attr(i);</a>
<a name="ln1377">    }</a>
<a name="ln1378">    current_state.ga_len = from-&gt;sst_stacksize;</a>
<a name="ln1379">  }</a>
<a name="ln1380">  current_next_list = from-&gt;sst_next_list;</a>
<a name="ln1381">  current_next_flags = from-&gt;sst_next_flags;</a>
<a name="ln1382">  current_lnum = from-&gt;sst_lnum;</a>
<a name="ln1383">}</a>
<a name="ln1384"> </a>
<a name="ln1385">/*</a>
<a name="ln1386"> * Compare saved state stack &quot;*sp&quot; with the current state.</a>
<a name="ln1387"> * Return TRUE when they are equal.</a>
<a name="ln1388"> */</a>
<a name="ln1389">static int syn_stack_equal(synstate_T *sp)</a>
<a name="ln1390">{</a>
<a name="ln1391">  bufstate_T  *bp;</a>
<a name="ln1392">  reg_extmatch_T      *six, *bsx;</a>
<a name="ln1393"> </a>
<a name="ln1394">  /* First a quick check if the stacks have the same size end nextlist. */</a>
<a name="ln1395">  if (sp-&gt;sst_stacksize != current_state.ga_len</a>
<a name="ln1396">      || sp-&gt;sst_next_list != current_next_list) {</a>
<a name="ln1397">    return FALSE;</a>
<a name="ln1398">  }</a>
<a name="ln1399"> </a>
<a name="ln1400">  /* Need to compare all states on both stacks. */</a>
<a name="ln1401">  if (sp-&gt;sst_stacksize &gt; SST_FIX_STATES)</a>
<a name="ln1402">    bp = SYN_STATE_P(&amp;(sp-&gt;sst_union.sst_ga));</a>
<a name="ln1403">  else</a>
<a name="ln1404">    bp = sp-&gt;sst_union.sst_stack;</a>
<a name="ln1405"> </a>
<a name="ln1406">  int i;</a>
<a name="ln1407">  for (i = current_state.ga_len; --i &gt;= 0; ) {</a>
<a name="ln1408">    /* If the item has another index the state is different. */</a>
<a name="ln1409">    if (bp[i].bs_idx != CUR_STATE(i).si_idx)</a>
<a name="ln1410">      break;</a>
<a name="ln1411">    if (bp[i].bs_extmatch == CUR_STATE(i).si_extmatch) {</a>
<a name="ln1412">      continue;</a>
<a name="ln1413">    }</a>
<a name="ln1414">    /* When the extmatch pointers are different, the strings in</a>
<a name="ln1415">     * them can still be the same.  Check if the extmatch</a>
<a name="ln1416">     * references are equal. */</a>
<a name="ln1417">    bsx = bp[i].bs_extmatch;</a>
<a name="ln1418">    six = CUR_STATE(i).si_extmatch;</a>
<a name="ln1419">    /* If one of the extmatch pointers is NULL the states are</a>
<a name="ln1420">     * different. */</a>
<a name="ln1421">    if (bsx == NULL || six == NULL)</a>
<a name="ln1422">      break;</a>
<a name="ln1423">    int j;</a>
<a name="ln1424">    for (j = 0; j &lt; NSUBEXP; ++j) {</a>
<a name="ln1425">      /* Check each referenced match string. They must all be</a>
<a name="ln1426">       * equal. */</a>
<a name="ln1427">      if (bsx-&gt;matches[j] != six-&gt;matches[j]) {</a>
<a name="ln1428">        /* If the pointer is different it can still be the</a>
<a name="ln1429">         * same text.  Compare the strings, ignore case when</a>
<a name="ln1430">         * the start item has the sp_ic flag set. */</a>
<a name="ln1431">        if (bsx-&gt;matches[j] == NULL || six-&gt;matches[j] == NULL) {</a>
<a name="ln1432">          break;</a>
<a name="ln1433">        }</a>
<a name="ln1434">        if (mb_strcmp_ic((SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_ic,</a>
<a name="ln1435">                         (const char *)bsx-&gt;matches[j],</a>
<a name="ln1436">                         (const char *)six-&gt;matches[j]) != 0) {</a>
<a name="ln1437">          break;</a>
<a name="ln1438">        }</a>
<a name="ln1439">      }</a>
<a name="ln1440">    }</a>
<a name="ln1441">    if (j != NSUBEXP)</a>
<a name="ln1442">      break;</a>
<a name="ln1443">  }</a>
<a name="ln1444">  if (i &lt; 0)</a>
<a name="ln1445">    return TRUE;</a>
<a name="ln1446"> </a>
<a name="ln1447">  return FALSE;</a>
<a name="ln1448">}</a>
<a name="ln1449"> </a>
<a name="ln1450">/*</a>
<a name="ln1451"> * We stop parsing syntax above line &quot;lnum&quot;.  If the stored state at or below</a>
<a name="ln1452"> * this line depended on a change before it, it now depends on the line below</a>
<a name="ln1453"> * the last parsed line.</a>
<a name="ln1454"> * The window looks like this:</a>
<a name="ln1455"> *	    line which changed</a>
<a name="ln1456"> *	    displayed line</a>
<a name="ln1457"> *	    displayed line</a>
<a name="ln1458"> * lnum -&gt;  line below window</a>
<a name="ln1459"> */</a>
<a name="ln1460">void syntax_end_parsing(linenr_T lnum)</a>
<a name="ln1461">{</a>
<a name="ln1462">  synstate_T  *sp;</a>
<a name="ln1463"> </a>
<a name="ln1464">  sp = syn_stack_find_entry(lnum);</a>
<a name="ln1465">  if (sp != NULL &amp;&amp; sp-&gt;sst_lnum &lt; lnum)</a>
<a name="ln1466">    sp = sp-&gt;sst_next;</a>
<a name="ln1467"> </a>
<a name="ln1468">  if (sp != NULL &amp;&amp; sp-&gt;sst_change_lnum != 0)</a>
<a name="ln1469">    sp-&gt;sst_change_lnum = lnum;</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">/*</a>
<a name="ln1473"> * End of handling of the state stack.</a>
<a name="ln1474"> ****************************************/</a>
<a name="ln1475"> </a>
<a name="ln1476">static void invalidate_current_state(void)</a>
<a name="ln1477">{</a>
<a name="ln1478">  clear_current_state();</a>
<a name="ln1479">  current_state.ga_itemsize = 0;        /* mark current_state invalid */</a>
<a name="ln1480">  current_next_list = NULL;</a>
<a name="ln1481">  keepend_level = -1;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">static void validate_current_state(void)</a>
<a name="ln1485">{</a>
<a name="ln1486">  current_state.ga_itemsize = sizeof(stateitem_T);</a>
<a name="ln1487">  ga_set_growsize(&amp;current_state, 3);</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">/*</a>
<a name="ln1491"> * Return TRUE if the syntax at start of lnum changed since last time.</a>
<a name="ln1492"> * This will only be called just after get_syntax_attr() for the previous</a>
<a name="ln1493"> * line, to check if the next line needs to be redrawn too.</a>
<a name="ln1494"> */</a>
<a name="ln1495">int syntax_check_changed(linenr_T lnum)</a>
<a name="ln1496">{</a>
<a name="ln1497">  int retval = TRUE;</a>
<a name="ln1498">  synstate_T  *sp;</a>
<a name="ln1499"> </a>
<a name="ln1500">  /*</a>
<a name="ln1501">   * Check the state stack when:</a>
<a name="ln1502">   * - lnum is just below the previously syntaxed line.</a>
<a name="ln1503">   * - lnum is not before the lines with saved states.</a>
<a name="ln1504">   * - lnum is not past the lines with saved states.</a>
<a name="ln1505">   * - lnum is at or before the last changed line.</a>
<a name="ln1506">   */</a>
<a name="ln1507">  if (VALID_STATE(&amp;current_state) &amp;&amp; lnum == current_lnum + 1) {</a>
<a name="ln1508">    sp = syn_stack_find_entry(lnum);</a>
<a name="ln1509">    if (sp != NULL &amp;&amp; sp-&gt;sst_lnum == lnum) {</a>
<a name="ln1510">      /*</a>
<a name="ln1511">       * finish the previous line (needed when not all of the line was</a>
<a name="ln1512">       * drawn)</a>
<a name="ln1513">       */</a>
<a name="ln1514">      (void)syn_finish_line(false);</a>
<a name="ln1515"> </a>
<a name="ln1516">      /*</a>
<a name="ln1517">       * Compare the current state with the previously saved state of</a>
<a name="ln1518">       * the line.</a>
<a name="ln1519">       */</a>
<a name="ln1520">      if (syn_stack_equal(sp))</a>
<a name="ln1521">        retval = FALSE;</a>
<a name="ln1522"> </a>
<a name="ln1523">      /*</a>
<a name="ln1524">       * Store the current state in b_sst_array[] for later use.</a>
<a name="ln1525">       */</a>
<a name="ln1526">      ++current_lnum;</a>
<a name="ln1527">      (void)store_current_state();</a>
<a name="ln1528">    }</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  return retval;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">/*</a>
<a name="ln1535"> * Finish the current line.</a>
<a name="ln1536"> * This doesn't return any attributes, it only gets the state at the end of</a>
<a name="ln1537"> * the line.  It can start anywhere in the line, as long as the current state</a>
<a name="ln1538"> * is valid.</a>
<a name="ln1539"> */</a>
<a name="ln1540">static bool</a>
<a name="ln1541">syn_finish_line(</a>
<a name="ln1542">    const bool syncing            // called for syncing</a>
<a name="ln1543">)</a>
<a name="ln1544">{</a>
<a name="ln1545">  while (!current_finished) {</a>
<a name="ln1546">    (void)syn_current_attr(syncing, false, NULL, false);</a>
<a name="ln1547"> </a>
<a name="ln1548">    // When syncing, and found some item, need to check the item.</a>
<a name="ln1549">    if (syncing &amp;&amp; current_state.ga_len) {</a>
<a name="ln1550">      // Check for match with sync item.</a>
<a name="ln1551">      const stateitem_T *const cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1552">      if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln1553">          &amp;&amp; (SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_flags</a>
<a name="ln1554">              &amp; (HL_SYNC_HERE|HL_SYNC_THERE))) {</a>
<a name="ln1555">        return true;</a>
<a name="ln1556">      }</a>
<a name="ln1557"> </a>
<a name="ln1558">      // syn_current_attr() will have skipped the check for an item</a>
<a name="ln1559">      // that ends here, need to do that now.  Be careful not to go</a>
<a name="ln1560">      // past the NUL.</a>
<a name="ln1561">      const colnr_T prev_current_col = current_col;</a>
<a name="ln1562">      if (syn_getcurline()[current_col] != NUL) {</a>
<a name="ln1563">        current_col++;</a>
<a name="ln1564">      }</a>
<a name="ln1565">      check_state_ends();</a>
<a name="ln1566">      current_col = prev_current_col;</a>
<a name="ln1567">    }</a>
<a name="ln1568">    current_col++;</a>
<a name="ln1569">  }</a>
<a name="ln1570">  return false;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573">/*</a>
<a name="ln1574"> * Return highlight attributes for next character.</a>
<a name="ln1575"> * Must first call syntax_start() once for the line.</a>
<a name="ln1576"> * &quot;col&quot; is normally 0 for the first use in a line, and increments by one each</a>
<a name="ln1577"> * time.  It's allowed to skip characters and to stop before the end of the</a>
<a name="ln1578"> * line.  But only a &quot;col&quot; after a previously used column is allowed.</a>
<a name="ln1579"> * When &quot;can_spell&quot; is not NULL set it to TRUE when spell-checking should be</a>
<a name="ln1580"> * done.</a>
<a name="ln1581"> */</a>
<a name="ln1582">int</a>
<a name="ln1583">get_syntax_attr(</a>
<a name="ln1584">    const colnr_T col,</a>
<a name="ln1585">    bool *const can_spell,</a>
<a name="ln1586">    const bool keep_state           // keep state of char at &quot;col&quot;</a>
<a name="ln1587">)</a>
<a name="ln1588">{</a>
<a name="ln1589">  int attr = 0;</a>
<a name="ln1590"> </a>
<a name="ln1591">  if (can_spell != NULL)</a>
<a name="ln1592">    /* Default: Only do spelling when there is no @Spell cluster or when</a>
<a name="ln1593">     * &quot;:syn spell toplevel&quot; was used. */</a>
<a name="ln1594">    *can_spell = syn_block-&gt;b_syn_spell == SYNSPL_DEFAULT</a>
<a name="ln1595">                 ? (syn_block-&gt;b_spell_cluster_id == 0)</a>
<a name="ln1596">                 : (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln1597"> </a>
<a name="ln1598">  /* check for out of memory situation */</a>
<a name="ln1599">  if (syn_block-&gt;b_sst_array == NULL)</a>
<a name="ln1600">    return 0;</a>
<a name="ln1601"> </a>
<a name="ln1602">  /* After 'synmaxcol' the attribute is always zero. */</a>
<a name="ln1603">  if (syn_buf-&gt;b_p_smc &gt; 0 &amp;&amp; col &gt;= (colnr_T)syn_buf-&gt;b_p_smc) {</a>
<a name="ln1604">    clear_current_state();</a>
<a name="ln1605">    current_id = 0;</a>
<a name="ln1606">    current_trans_id = 0;</a>
<a name="ln1607">    current_flags = 0;</a>
<a name="ln1608">    current_seqnr = 0;</a>
<a name="ln1609">    return 0;</a>
<a name="ln1610">  }</a>
<a name="ln1611"> </a>
<a name="ln1612">  /* Make sure current_state is valid */</a>
<a name="ln1613">  if (INVALID_STATE(&amp;current_state))</a>
<a name="ln1614">    validate_current_state();</a>
<a name="ln1615"> </a>
<a name="ln1616">  /*</a>
<a name="ln1617">   * Skip from the current column to &quot;col&quot;, get the attributes for &quot;col&quot;.</a>
<a name="ln1618">   */</a>
<a name="ln1619">  while (current_col &lt;= col) {</a>
<a name="ln1620">    attr = syn_current_attr(false, true, can_spell,</a>
<a name="ln1621">                            current_col == col ? keep_state : false);</a>
<a name="ln1622">    current_col++;</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  return attr;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">/*</a>
<a name="ln1629"> * Get syntax attributes for current_lnum, current_col.</a>
<a name="ln1630"> */</a>
<a name="ln1631">static int syn_current_attr(</a>
<a name="ln1632">    const bool syncing,                   // When true: called for syncing</a>
<a name="ln1633">    const bool displaying,                // result will be displayed</a>
<a name="ln1634">    bool *const can_spell,                // return: do spell checking</a>
<a name="ln1635">    const bool keep_state                 // keep syntax stack afterwards</a>
<a name="ln1636">)</a>
<a name="ln1637">{</a>
<a name="ln1638">  lpos_T endpos;                // was: char_u *endp;</a>
<a name="ln1639">  lpos_T hl_startpos;           // was: int hl_startcol;</a>
<a name="ln1640">  lpos_T hl_endpos;</a>
<a name="ln1641">  lpos_T eos_pos;               // end-of-start match (start region)</a>
<a name="ln1642">  lpos_T eoe_pos;               // end-of-end pattern</a>
<a name="ln1643">  int end_idx;                  // group ID for end pattern</a>
<a name="ln1644">  stateitem_T *cur_si, *sip = NULL;</a>
<a name="ln1645">  int startcol;</a>
<a name="ln1646">  int endcol;</a>
<a name="ln1647">  long flags;</a>
<a name="ln1648">  int cchar;</a>
<a name="ln1649">  int16_t *next_list;</a>
<a name="ln1650">  bool found_match;                         // found usable match</a>
<a name="ln1651">  static bool try_next_column = false;      // must try in next col</a>
<a name="ln1652">  regmmatch_T regmatch;</a>
<a name="ln1653">  lpos_T pos;</a>
<a name="ln1654">  reg_extmatch_T *cur_extmatch = NULL;</a>
<a name="ln1655">  char_u      buf_chartab[32];  // chartab array for syn iskeyword</a>
<a name="ln1656">  char_u      *line;            // current line.  NOTE: becomes invalid after</a>
<a name="ln1657">                                // looking for a pattern match!</a>
<a name="ln1658"> </a>
<a name="ln1659">  // variables for zero-width matches that have a &quot;nextgroup&quot; argument</a>
<a name="ln1660">  bool keep_next_list;</a>
<a name="ln1661">  bool zero_width_next_list = false;</a>
<a name="ln1662">  garray_T zero_width_next_ga;</a>
<a name="ln1663"> </a>
<a name="ln1664">  /*</a>
<a name="ln1665">   * No character, no attributes!  Past end of line?</a>
<a name="ln1666">   * Do try matching with an empty line (could be the start of a region).</a>
<a name="ln1667">   */</a>
<a name="ln1668">  line = syn_getcurline();</a>
<a name="ln1669">  if (line[current_col] == NUL &amp;&amp; current_col != 0) {</a>
<a name="ln1670">    /*</a>
<a name="ln1671">     * If we found a match after the last column, use it.</a>
<a name="ln1672">     */</a>
<a name="ln1673">    if (next_match_idx &gt;= 0 &amp;&amp; next_match_col &gt;= (int)current_col</a>
<a name="ln1674">        &amp;&amp; next_match_col != MAXCOL) {</a>
<a name="ln1675">      (void)push_next_match();</a>
<a name="ln1676">    }</a>
<a name="ln1677"> </a>
<a name="ln1678">    current_finished = TRUE;</a>
<a name="ln1679">    current_state_stored = FALSE;</a>
<a name="ln1680">    return 0;</a>
<a name="ln1681">  }</a>
<a name="ln1682"> </a>
<a name="ln1683">  /* if the current or next character is NUL, we will finish the line now */</a>
<a name="ln1684">  if (line[current_col] == NUL || line[current_col + 1] == NUL) {</a>
<a name="ln1685">    current_finished = TRUE;</a>
<a name="ln1686">    current_state_stored = FALSE;</a>
<a name="ln1687">  }</a>
<a name="ln1688"> </a>
<a name="ln1689">  /*</a>
<a name="ln1690">   * When in the previous column there was a match but it could not be used</a>
<a name="ln1691">   * (empty match or already matched in this column) need to try again in</a>
<a name="ln1692">   * the next column.</a>
<a name="ln1693">   */</a>
<a name="ln1694">  if (try_next_column) {</a>
<a name="ln1695">    next_match_idx = -1;</a>
<a name="ln1696">    try_next_column = false;</a>
<a name="ln1697">  }</a>
<a name="ln1698"> </a>
<a name="ln1699">  // Only check for keywords when not syncing and there are some.</a>
<a name="ln1700">  const bool do_keywords = !syncing</a>
<a name="ln1701">      &amp;&amp; (syn_block-&gt;b_keywtab.ht_used &gt; 0</a>
<a name="ln1702">          || syn_block-&gt;b_keywtab_ic.ht_used &gt; 0);</a>
<a name="ln1703"> </a>
<a name="ln1704">  /* Init the list of zero-width matches with a nextlist.  This is used to</a>
<a name="ln1705">   * avoid matching the same item in the same position twice. */</a>
<a name="ln1706">  ga_init(&amp;zero_width_next_ga, (int)sizeof(int), 10);</a>
<a name="ln1707"> </a>
<a name="ln1708">  // use syntax iskeyword option</a>
<a name="ln1709">  save_chartab(buf_chartab);</a>
<a name="ln1710"> </a>
<a name="ln1711">  /*</a>
<a name="ln1712">   * Repeat matching keywords and patterns, to find contained items at the</a>
<a name="ln1713">   * same column.  This stops when there are no extra matches at the current</a>
<a name="ln1714">   * column.</a>
<a name="ln1715">   */</a>
<a name="ln1716">  do {</a>
<a name="ln1717">    found_match = false;</a>
<a name="ln1718">    keep_next_list = false;</a>
<a name="ln1719">    int syn_id = 0;</a>
<a name="ln1720"> </a>
<a name="ln1721">    /*</a>
<a name="ln1722">     * 1. Check for a current state.</a>
<a name="ln1723">     *    Only when there is no current state, or if the current state may</a>
<a name="ln1724">     *    contain other things, we need to check for keywords and patterns.</a>
<a name="ln1725">     *    Always need to check for contained items if some item has the</a>
<a name="ln1726">     *    &quot;containedin&quot; argument (takes extra time!).</a>
<a name="ln1727">     */</a>
<a name="ln1728">    if (current_state.ga_len)</a>
<a name="ln1729">      cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1730">    else</a>
<a name="ln1731">      cur_si = NULL;</a>
<a name="ln1732"> </a>
<a name="ln1733">    if (syn_block-&gt;b_syn_containedin || cur_si == NULL</a>
<a name="ln1734">        || cur_si-&gt;si_cont_list != NULL) {</a>
<a name="ln1735">      /*</a>
<a name="ln1736">       * 2. Check for keywords, if on a keyword char after a non-keyword</a>
<a name="ln1737">       *	  char.  Don't do this when syncing.</a>
<a name="ln1738">       */</a>
<a name="ln1739">      if (do_keywords) {</a>
<a name="ln1740">        line = syn_getcurline();</a>
<a name="ln1741">        const char_u *cur_pos = line + current_col;</a>
<a name="ln1742">        if (vim_iswordp_buf(cur_pos, syn_buf)</a>
<a name="ln1743">            &amp;&amp; (current_col == 0 || !vim_iswordp_buf(</a>
<a name="ln1744">                cur_pos - 1 - utf_head_off(line, cur_pos - 1), syn_buf))) {</a>
<a name="ln1745">          syn_id = check_keyword_id(line, (int)current_col, &amp;endcol, &amp;flags,</a>
<a name="ln1746">                                    &amp;next_list, cur_si, &amp;cchar);</a>
<a name="ln1747">          if (syn_id != 0) {</a>
<a name="ln1748">            push_current_state(KEYWORD_IDX);</a>
<a name="ln1749">            {</a>
<a name="ln1750">              cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln1751">              cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln1752">              cur_si-&gt;si_h_startpos.lnum = current_lnum;</a>
<a name="ln1753">              cur_si-&gt;si_h_startpos.col = 0;            /* starts right away */</a>
<a name="ln1754">              cur_si-&gt;si_m_endpos.lnum = current_lnum;</a>
<a name="ln1755">              cur_si-&gt;si_m_endpos.col = endcol;</a>
<a name="ln1756">              cur_si-&gt;si_h_endpos.lnum = current_lnum;</a>
<a name="ln1757">              cur_si-&gt;si_h_endpos.col = endcol;</a>
<a name="ln1758">              cur_si-&gt;si_ends = TRUE;</a>
<a name="ln1759">              cur_si-&gt;si_end_idx = 0;</a>
<a name="ln1760">              cur_si-&gt;si_flags = flags;</a>
<a name="ln1761">              cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln1762">              cur_si-&gt;si_cchar = cchar;</a>
<a name="ln1763">              if (current_state.ga_len &gt; 1)</a>
<a name="ln1764">                cur_si-&gt;si_flags |=</a>
<a name="ln1765">                  CUR_STATE(current_state.ga_len - 2).si_flags</a>
<a name="ln1766">                  &amp; HL_CONCEAL;</a>
<a name="ln1767">              cur_si-&gt;si_id = syn_id;</a>
<a name="ln1768">              cur_si-&gt;si_trans_id = syn_id;</a>
<a name="ln1769">              if (flags &amp; HL_TRANSP) {</a>
<a name="ln1770">                if (current_state.ga_len &lt; 2) {</a>
<a name="ln1771">                  cur_si-&gt;si_attr = 0;</a>
<a name="ln1772">                  cur_si-&gt;si_trans_id = 0;</a>
<a name="ln1773">                } else {</a>
<a name="ln1774">                  cur_si-&gt;si_attr = CUR_STATE(</a>
<a name="ln1775">                      current_state.ga_len - 2).si_attr;</a>
<a name="ln1776">                  cur_si-&gt;si_trans_id = CUR_STATE(</a>
<a name="ln1777">                      current_state.ga_len - 2).si_trans_id;</a>
<a name="ln1778">                }</a>
<a name="ln1779">              } else {</a>
<a name="ln1780">                cur_si-&gt;si_attr = syn_id2attr(syn_id);</a>
<a name="ln1781">              }</a>
<a name="ln1782">              cur_si-&gt;si_cont_list = NULL;</a>
<a name="ln1783">              cur_si-&gt;si_next_list = next_list;</a>
<a name="ln1784">              check_keepend();</a>
<a name="ln1785">            }</a>
<a name="ln1786">          }</a>
<a name="ln1787">        }</a>
<a name="ln1788">      }</a>
<a name="ln1789"> </a>
<a name="ln1790">      /*</a>
<a name="ln1791">       * 3. Check for patterns (only if no keyword found).</a>
<a name="ln1792">       */</a>
<a name="ln1793">      if (syn_id == 0 &amp;&amp; syn_block-&gt;b_syn_patterns.ga_len) {</a>
<a name="ln1794">        /*</a>
<a name="ln1795">         * If we didn't check for a match yet, or we are past it, check</a>
<a name="ln1796">         * for any match with a pattern.</a>
<a name="ln1797">         */</a>
<a name="ln1798">        if (next_match_idx &lt; 0 || next_match_col &lt; (int)current_col) {</a>
<a name="ln1799">          /*</a>
<a name="ln1800">           * Check all relevant patterns for a match at this</a>
<a name="ln1801">           * position.  This is complicated, because matching with a</a>
<a name="ln1802">           * pattern takes quite a bit of time, thus we want to</a>
<a name="ln1803">           * avoid doing it when it's not needed.</a>
<a name="ln1804">           */</a>
<a name="ln1805">          next_match_idx = 0;                   /* no match in this line yet */</a>
<a name="ln1806">          next_match_col = MAXCOL;</a>
<a name="ln1807">          for (int idx = syn_block-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; ) {</a>
<a name="ln1808">            synpat_T *const spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln1809">            if (       spp-&gt;sp_syncing == syncing</a>
<a name="ln1810">                       &amp;&amp; (displaying || !(spp-&gt;sp_flags &amp; HL_DISPLAY))</a>
<a name="ln1811">                       &amp;&amp; (spp-&gt;sp_type == SPTYPE_MATCH</a>
<a name="ln1812">                           || spp-&gt;sp_type == SPTYPE_START)</a>
<a name="ln1813">                       &amp;&amp; (current_next_list != NULL</a>
<a name="ln1814">                           ? in_id_list(NULL, current_next_list,</a>
<a name="ln1815">                               &amp;spp-&gt;sp_syn, 0)</a>
<a name="ln1816">                           : (cur_si == NULL</a>
<a name="ln1817">                              ? !(spp-&gt;sp_flags &amp; HL_CONTAINED)</a>
<a name="ln1818">                              : in_id_list(cur_si,</a>
<a name="ln1819">                                  cur_si-&gt;si_cont_list, &amp;spp-&gt;sp_syn,</a>
<a name="ln1820">                                  spp-&gt;sp_flags &amp; HL_CONTAINED)))) {</a>
<a name="ln1821">              /* If we already tried matching in this line, and</a>
<a name="ln1822">               * there isn't a match before next_match_col, skip</a>
<a name="ln1823">               * this item. */</a>
<a name="ln1824">              if (spp-&gt;sp_line_id == current_line_id</a>
<a name="ln1825">                  &amp;&amp; spp-&gt;sp_startcol &gt;= next_match_col)</a>
<a name="ln1826">                continue;</a>
<a name="ln1827">              spp-&gt;sp_line_id = current_line_id;</a>
<a name="ln1828"> </a>
<a name="ln1829">              colnr_T lc_col = current_col - spp-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln1830">              if (lc_col &lt; 0) {</a>
<a name="ln1831">                lc_col = 0;</a>
<a name="ln1832">              }</a>
<a name="ln1833"> </a>
<a name="ln1834">              regmatch.rmm_ic = spp-&gt;sp_ic;</a>
<a name="ln1835">              regmatch.regprog = spp-&gt;sp_prog;</a>
<a name="ln1836">              int r = syn_regexec(&amp;regmatch, current_lnum, lc_col,</a>
<a name="ln1837">                                  IF_SYN_TIME(&amp;spp-&gt;sp_time));</a>
<a name="ln1838">              spp-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln1839">              if (!r) {</a>
<a name="ln1840">                /* no match in this line, try another one */</a>
<a name="ln1841">                spp-&gt;sp_startcol = MAXCOL;</a>
<a name="ln1842">                continue;</a>
<a name="ln1843">              }</a>
<a name="ln1844"> </a>
<a name="ln1845">              /*</a>
<a name="ln1846">               * Compute the first column of the match.</a>
<a name="ln1847">               */</a>
<a name="ln1848">              syn_add_start_off(&amp;pos, &amp;regmatch,</a>
<a name="ln1849">                  spp, SPO_MS_OFF, -1);</a>
<a name="ln1850">              if (pos.lnum &gt; current_lnum) {</a>
<a name="ln1851">                /* must have used end of match in a next line,</a>
<a name="ln1852">                 * we can't handle that */</a>
<a name="ln1853">                spp-&gt;sp_startcol = MAXCOL;</a>
<a name="ln1854">                continue;</a>
<a name="ln1855">              }</a>
<a name="ln1856">              startcol = pos.col;</a>
<a name="ln1857"> </a>
<a name="ln1858">              /* remember the next column where this pattern</a>
<a name="ln1859">               * matches in the current line */</a>
<a name="ln1860">              spp-&gt;sp_startcol = startcol;</a>
<a name="ln1861"> </a>
<a name="ln1862">              /*</a>
<a name="ln1863">               * If a previously found match starts at a lower</a>
<a name="ln1864">               * column number, don't use this one.</a>
<a name="ln1865">               */</a>
<a name="ln1866">              if (startcol &gt;= next_match_col)</a>
<a name="ln1867">                continue;</a>
<a name="ln1868"> </a>
<a name="ln1869">              /*</a>
<a name="ln1870">               * If we matched this pattern at this position</a>
<a name="ln1871">               * before, skip it.  Must retry in the next</a>
<a name="ln1872">               * column, because it may match from there.</a>
<a name="ln1873">               */</a>
<a name="ln1874">              if (did_match_already(idx, &amp;zero_width_next_ga)) {</a>
<a name="ln1875">                try_next_column = true;</a>
<a name="ln1876">                continue;</a>
<a name="ln1877">              }</a>
<a name="ln1878"> </a>
<a name="ln1879">              endpos.lnum = regmatch.endpos[0].lnum;</a>
<a name="ln1880">              endpos.col = regmatch.endpos[0].col;</a>
<a name="ln1881"> </a>
<a name="ln1882">              /* Compute the highlight start. */</a>
<a name="ln1883">              syn_add_start_off(&amp;hl_startpos, &amp;regmatch,</a>
<a name="ln1884">                  spp, SPO_HS_OFF, -1);</a>
<a name="ln1885"> </a>
<a name="ln1886">              /* Compute the region start. */</a>
<a name="ln1887">              /* Default is to use the end of the match. */</a>
<a name="ln1888">              syn_add_end_off(&amp;eos_pos, &amp;regmatch,</a>
<a name="ln1889">                  spp, SPO_RS_OFF, 0);</a>
<a name="ln1890"> </a>
<a name="ln1891">              /*</a>
<a name="ln1892">               * Grab the external submatches before they get</a>
<a name="ln1893">               * overwritten.  Reference count doesn't change.</a>
<a name="ln1894">               */</a>
<a name="ln1895">              unref_extmatch(cur_extmatch);</a>
<a name="ln1896">              cur_extmatch = re_extmatch_out;</a>
<a name="ln1897">              re_extmatch_out = NULL;</a>
<a name="ln1898"> </a>
<a name="ln1899">              flags = 0;</a>
<a name="ln1900">              eoe_pos.lnum = 0;                 /* avoid warning */</a>
<a name="ln1901">              eoe_pos.col = 0;</a>
<a name="ln1902">              end_idx = 0;</a>
<a name="ln1903">              hl_endpos.lnum = 0;</a>
<a name="ln1904"> </a>
<a name="ln1905">              /*</a>
<a name="ln1906">               * For a &quot;oneline&quot; the end must be found in the</a>
<a name="ln1907">               * same line too.  Search for it after the end of</a>
<a name="ln1908">               * the match with the start pattern.  Set the</a>
<a name="ln1909">               * resulting end positions at the same time.</a>
<a name="ln1910">               */</a>
<a name="ln1911">              if (spp-&gt;sp_type == SPTYPE_START</a>
<a name="ln1912">                  &amp;&amp; (spp-&gt;sp_flags &amp; HL_ONELINE)) {</a>
<a name="ln1913">                lpos_T startpos;</a>
<a name="ln1914"> </a>
<a name="ln1915">                startpos = endpos;</a>
<a name="ln1916">                find_endpos(idx, &amp;startpos, &amp;endpos, &amp;hl_endpos,</a>
<a name="ln1917">                    &amp;flags, &amp;eoe_pos, &amp;end_idx, cur_extmatch);</a>
<a name="ln1918">                if (endpos.lnum == 0)</a>
<a name="ln1919">                  continue;                         /* not found */</a>
<a name="ln1920">              }</a>
<a name="ln1921">              /*</a>
<a name="ln1922">               * For a &quot;match&quot; the size must be &gt; 0 after the</a>
<a name="ln1923">               * end offset needs has been added.  Except when</a>
<a name="ln1924">               * syncing.</a>
<a name="ln1925">               */</a>
<a name="ln1926">              else if (spp-&gt;sp_type == SPTYPE_MATCH) {</a>
<a name="ln1927">                syn_add_end_off(&amp;hl_endpos, &amp;regmatch, spp,</a>
<a name="ln1928">                    SPO_HE_OFF, 0);</a>
<a name="ln1929">                syn_add_end_off(&amp;endpos, &amp;regmatch, spp,</a>
<a name="ln1930">                    SPO_ME_OFF, 0);</a>
<a name="ln1931">                if (endpos.lnum == current_lnum</a>
<a name="ln1932">                    &amp;&amp; (int)endpos.col + syncing &lt; startcol) {</a>
<a name="ln1933">                  /*</a>
<a name="ln1934">                   * If an empty string is matched, may need</a>
<a name="ln1935">                   * to try matching again at next column.</a>
<a name="ln1936">                   */</a>
<a name="ln1937">                  if (regmatch.startpos[0].col == regmatch.endpos[0].col) {</a>
<a name="ln1938">                    try_next_column = true;</a>
<a name="ln1939">                  }</a>
<a name="ln1940">                  continue;</a>
<a name="ln1941">                }</a>
<a name="ln1942">              }</a>
<a name="ln1943"> </a>
<a name="ln1944">              /*</a>
<a name="ln1945">               * keep the best match so far in next_match_*</a>
<a name="ln1946">               */</a>
<a name="ln1947">              /* Highlighting must start after startpos and end</a>
<a name="ln1948">               * before endpos. */</a>
<a name="ln1949">              if (hl_startpos.lnum == current_lnum</a>
<a name="ln1950">                  &amp;&amp; (int)hl_startpos.col &lt; startcol)</a>
<a name="ln1951">                hl_startpos.col = startcol;</a>
<a name="ln1952">              limit_pos_zero(&amp;hl_endpos, &amp;endpos);</a>
<a name="ln1953"> </a>
<a name="ln1954">              next_match_idx = idx;</a>
<a name="ln1955">              next_match_col = startcol;</a>
<a name="ln1956">              next_match_m_endpos = endpos;</a>
<a name="ln1957">              next_match_h_endpos = hl_endpos;</a>
<a name="ln1958">              next_match_h_startpos = hl_startpos;</a>
<a name="ln1959">              next_match_flags = flags;</a>
<a name="ln1960">              next_match_eos_pos = eos_pos;</a>
<a name="ln1961">              next_match_eoe_pos = eoe_pos;</a>
<a name="ln1962">              next_match_end_idx = end_idx;</a>
<a name="ln1963">              unref_extmatch(next_match_extmatch);</a>
<a name="ln1964">              next_match_extmatch = cur_extmatch;</a>
<a name="ln1965">              cur_extmatch = NULL;</a>
<a name="ln1966">            }</a>
<a name="ln1967">          }</a>
<a name="ln1968">        }</a>
<a name="ln1969"> </a>
<a name="ln1970">        /*</a>
<a name="ln1971">         * If we found a match at the current column, use it.</a>
<a name="ln1972">         */</a>
<a name="ln1973">        if (next_match_idx &gt;= 0 &amp;&amp; next_match_col == (int)current_col) {</a>
<a name="ln1974">          synpat_T    *lspp;</a>
<a name="ln1975"> </a>
<a name="ln1976">          /* When a zero-width item matched which has a nextgroup,</a>
<a name="ln1977">           * don't push the item but set nextgroup. */</a>
<a name="ln1978">          lspp = &amp;(SYN_ITEMS(syn_block)[next_match_idx]);</a>
<a name="ln1979">          if (next_match_m_endpos.lnum == current_lnum</a>
<a name="ln1980">              &amp;&amp; next_match_m_endpos.col == current_col</a>
<a name="ln1981">              &amp;&amp; lspp-&gt;sp_next_list != NULL) {</a>
<a name="ln1982">            current_next_list = lspp-&gt;sp_next_list;</a>
<a name="ln1983">            current_next_flags = lspp-&gt;sp_flags;</a>
<a name="ln1984">            keep_next_list = true;</a>
<a name="ln1985">            zero_width_next_list = true;</a>
<a name="ln1986"> </a>
<a name="ln1987">            /* Add the index to a list, so that we can check</a>
<a name="ln1988">             * later that we don't match it again (and cause an</a>
<a name="ln1989">             * endless loop). */</a>
<a name="ln1990">            GA_APPEND(int, &amp;zero_width_next_ga, next_match_idx);</a>
<a name="ln1991">            next_match_idx = -1;</a>
<a name="ln1992">          } else {</a>
<a name="ln1993">            cur_si = push_next_match();</a>
<a name="ln1994">          }</a>
<a name="ln1995">          found_match = true;</a>
<a name="ln1996">        }</a>
<a name="ln1997">      }</a>
<a name="ln1998">    }</a>
<a name="ln1999"> </a>
<a name="ln2000">    /*</a>
<a name="ln2001">     * Handle searching for nextgroup match.</a>
<a name="ln2002">     */</a>
<a name="ln2003">    if (current_next_list != NULL &amp;&amp; !keep_next_list) {</a>
<a name="ln2004">      /*</a>
<a name="ln2005">       * If a nextgroup was not found, continue looking for one if:</a>
<a name="ln2006">       * - this is an empty line and the &quot;skipempty&quot; option was given</a>
<a name="ln2007">       * - we are on white space and the &quot;skipwhite&quot; option was given</a>
<a name="ln2008">       */</a>
<a name="ln2009">      if (!found_match) {</a>
<a name="ln2010">        line = syn_getcurline();</a>
<a name="ln2011">        if (((current_next_flags &amp; HL_SKIPWHITE)</a>
<a name="ln2012">             &amp;&amp; ascii_iswhite(line[current_col]))</a>
<a name="ln2013">            || ((current_next_flags &amp; HL_SKIPEMPTY)</a>
<a name="ln2014">                &amp;&amp; *line == NUL))</a>
<a name="ln2015">          break;</a>
<a name="ln2016">      }</a>
<a name="ln2017"> </a>
<a name="ln2018">      /*</a>
<a name="ln2019">       * If a nextgroup was found: Use it, and continue looking for</a>
<a name="ln2020">       * contained matches.</a>
<a name="ln2021">       * If a nextgroup was not found: Continue looking for a normal</a>
<a name="ln2022">       * match.</a>
<a name="ln2023">       * When did set current_next_list for a zero-width item and no</a>
<a name="ln2024">       * match was found don't loop (would get stuck).</a>
<a name="ln2025">       */</a>
<a name="ln2026">      current_next_list = NULL;</a>
<a name="ln2027">      next_match_idx = -1;</a>
<a name="ln2028">      if (!zero_width_next_list) {</a>
<a name="ln2029">        found_match = true;</a>
<a name="ln2030">      }</a>
<a name="ln2031">    }</a>
<a name="ln2032"> </a>
<a name="ln2033">  } while (found_match);</a>
<a name="ln2034"> </a>
<a name="ln2035">  restore_chartab(buf_chartab);</a>
<a name="ln2036"> </a>
<a name="ln2037">  /*</a>
<a name="ln2038">   * Use attributes from the current state, if within its highlighting.</a>
<a name="ln2039">   * If not, use attributes from the current-but-one state, etc.</a>
<a name="ln2040">   */</a>
<a name="ln2041">  current_attr = 0;</a>
<a name="ln2042">  current_id = 0;</a>
<a name="ln2043">  current_trans_id = 0;</a>
<a name="ln2044">  current_flags = 0;</a>
<a name="ln2045">  current_seqnr = 0;</a>
<a name="ln2046">  if (cur_si != NULL) {</a>
<a name="ln2047">    for (int idx = current_state.ga_len - 1; idx &gt;= 0; --idx) {</a>
<a name="ln2048">      sip = &amp;CUR_STATE(idx);</a>
<a name="ln2049">      if ((current_lnum &gt; sip-&gt;si_h_startpos.lnum</a>
<a name="ln2050">           || (current_lnum == sip-&gt;si_h_startpos.lnum</a>
<a name="ln2051">               &amp;&amp; current_col &gt;= sip-&gt;si_h_startpos.col))</a>
<a name="ln2052">          &amp;&amp; (sip-&gt;si_h_endpos.lnum == 0</a>
<a name="ln2053">              || current_lnum &lt; sip-&gt;si_h_endpos.lnum</a>
<a name="ln2054">              || (current_lnum == sip-&gt;si_h_endpos.lnum</a>
<a name="ln2055">                  &amp;&amp; current_col &lt; sip-&gt;si_h_endpos.col))) {</a>
<a name="ln2056">        current_attr = sip-&gt;si_attr;</a>
<a name="ln2057">        current_id = sip-&gt;si_id;</a>
<a name="ln2058">        current_trans_id = sip-&gt;si_trans_id;</a>
<a name="ln2059">        current_flags = sip-&gt;si_flags;</a>
<a name="ln2060">        current_seqnr = sip-&gt;si_seqnr;</a>
<a name="ln2061">        current_sub_char = sip-&gt;si_cchar;</a>
<a name="ln2062">        break;</a>
<a name="ln2063">      }</a>
<a name="ln2064">    }</a>
<a name="ln2065"> </a>
<a name="ln2066">    if (can_spell != NULL) {</a>
<a name="ln2067">      struct sp_syn sps;</a>
<a name="ln2068"> </a>
<a name="ln2069">      /*</a>
<a name="ln2070">       * set &quot;can_spell&quot; to TRUE if spell checking is supposed to be</a>
<a name="ln2071">       * done in the current item.</a>
<a name="ln2072">       */</a>
<a name="ln2073">      if (syn_block-&gt;b_spell_cluster_id == 0) {</a>
<a name="ln2074">        /* There is no @Spell cluster: Do spelling for items without</a>
<a name="ln2075">         * @NoSpell cluster. */</a>
<a name="ln2076">        if (syn_block-&gt;b_nospell_cluster_id == 0</a>
<a name="ln2077">            || current_trans_id == 0)</a>
<a name="ln2078">          *can_spell = (syn_block-&gt;b_syn_spell != SYNSPL_NOTOP);</a>
<a name="ln2079">        else {</a>
<a name="ln2080">          sps.inc_tag = 0;</a>
<a name="ln2081">          sps.id = syn_block-&gt;b_nospell_cluster_id;</a>
<a name="ln2082">          sps.cont_in_list = NULL;</a>
<a name="ln2083">          *can_spell = !in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0);</a>
<a name="ln2084">        }</a>
<a name="ln2085">      } else {</a>
<a name="ln2086">        /* The @Spell cluster is defined: Do spelling in items with</a>
<a name="ln2087">         * the @Spell cluster.  But not when @NoSpell is also there.</a>
<a name="ln2088">         * At the toplevel only spell check when &quot;:syn spell toplevel&quot;</a>
<a name="ln2089">         * was used. */</a>
<a name="ln2090">        if (current_trans_id == 0)</a>
<a name="ln2091">          *can_spell = (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln2092">        else {</a>
<a name="ln2093">          sps.inc_tag = 0;</a>
<a name="ln2094">          sps.id = syn_block-&gt;b_spell_cluster_id;</a>
<a name="ln2095">          sps.cont_in_list = NULL;</a>
<a name="ln2096">          *can_spell = in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0);</a>
<a name="ln2097"> </a>
<a name="ln2098">          if (syn_block-&gt;b_nospell_cluster_id != 0) {</a>
<a name="ln2099">            sps.id = syn_block-&gt;b_nospell_cluster_id;</a>
<a name="ln2100">            if (in_id_list(sip, sip-&gt;si_cont_list, &amp;sps, 0))</a>
<a name="ln2101">              *can_spell = false;</a>
<a name="ln2102">          }</a>
<a name="ln2103">        }</a>
<a name="ln2104">      }</a>
<a name="ln2105">    }</a>
<a name="ln2106"> </a>
<a name="ln2107"> </a>
<a name="ln2108">    /*</a>
<a name="ln2109">     * Check for end of current state (and the states before it) at the</a>
<a name="ln2110">     * next column.  Don't do this for syncing, because we would miss a</a>
<a name="ln2111">     * single character match.</a>
<a name="ln2112">     * First check if the current state ends at the current column.  It</a>
<a name="ln2113">     * may be for an empty match and a containing item might end in the</a>
<a name="ln2114">     * current column.</a>
<a name="ln2115">     */</a>
<a name="ln2116">    if (!syncing &amp;&amp; !keep_state) {</a>
<a name="ln2117">      check_state_ends();</a>
<a name="ln2118">      if (!GA_EMPTY(&amp;current_state)</a>
<a name="ln2119">          &amp;&amp; syn_getcurline()[current_col] != NUL) {</a>
<a name="ln2120">        ++current_col;</a>
<a name="ln2121">        check_state_ends();</a>
<a name="ln2122">        --current_col;</a>
<a name="ln2123">      }</a>
<a name="ln2124">    }</a>
<a name="ln2125">  } else if (can_spell != NULL)</a>
<a name="ln2126">    /* Default: Only do spelling when there is no @Spell cluster or when</a>
<a name="ln2127">     * &quot;:syn spell toplevel&quot; was used. */</a>
<a name="ln2128">    *can_spell = syn_block-&gt;b_syn_spell == SYNSPL_DEFAULT</a>
<a name="ln2129">                 ? (syn_block-&gt;b_spell_cluster_id == 0)</a>
<a name="ln2130">                 : (syn_block-&gt;b_syn_spell == SYNSPL_TOP);</a>
<a name="ln2131"> </a>
<a name="ln2132">  /* nextgroup ends at end of line, unless &quot;skipnl&quot; or &quot;skipempty&quot; present */</a>
<a name="ln2133">  if (current_next_list != NULL</a>
<a name="ln2134">      &amp;&amp; (line = syn_getcurline())[current_col] != NUL</a>
<a name="ln2135">      &amp;&amp; line[current_col + 1] == NUL</a>
<a name="ln2136">      &amp;&amp; !(current_next_flags &amp; (HL_SKIPNL | HL_SKIPEMPTY))) {</a>
<a name="ln2137">    current_next_list = NULL;</a>
<a name="ln2138">  }</a>
<a name="ln2139"> </a>
<a name="ln2140">  if (!GA_EMPTY(&amp;zero_width_next_ga))</a>
<a name="ln2141">    ga_clear(&amp;zero_width_next_ga);</a>
<a name="ln2142"> </a>
<a name="ln2143">  /* No longer need external matches.  But keep next_match_extmatch. */</a>
<a name="ln2144">  unref_extmatch(re_extmatch_out);</a>
<a name="ln2145">  re_extmatch_out = NULL;</a>
<a name="ln2146">  unref_extmatch(cur_extmatch);</a>
<a name="ln2147"> </a>
<a name="ln2148">  return current_attr;</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151"> </a>
<a name="ln2152">/*</a>
<a name="ln2153"> * Check if we already matched pattern &quot;idx&quot; at the current column.</a>
<a name="ln2154"> */</a>
<a name="ln2155">static int did_match_already(int idx, garray_T *gap)</a>
<a name="ln2156">{</a>
<a name="ln2157">  for (int i = current_state.ga_len; --i &gt;= 0; ) {</a>
<a name="ln2158">    if (CUR_STATE(i).si_m_startcol == (int)current_col</a>
<a name="ln2159">        &amp;&amp; CUR_STATE(i).si_m_lnum == (int)current_lnum</a>
<a name="ln2160">        &amp;&amp; CUR_STATE(i).si_idx == idx) {</a>
<a name="ln2161">      return TRUE;</a>
<a name="ln2162">    }</a>
<a name="ln2163">  }</a>
<a name="ln2164"> </a>
<a name="ln2165">  /* Zero-width matches with a nextgroup argument are not put on the syntax</a>
<a name="ln2166">   * stack, and can only be matched once anyway. */</a>
<a name="ln2167">  for (int i = gap-&gt;ga_len; --i &gt;= 0; ) {</a>
<a name="ln2168">    if (((int *)(gap-&gt;ga_data))[i] == idx) {</a>
<a name="ln2169">      return TRUE;</a>
<a name="ln2170">    }</a>
<a name="ln2171">  }</a>
<a name="ln2172"> </a>
<a name="ln2173">  return FALSE;</a>
<a name="ln2174">}</a>
<a name="ln2175"> </a>
<a name="ln2176">/*</a>
<a name="ln2177"> * Push the next match onto the stack.</a>
<a name="ln2178"> */</a>
<a name="ln2179">static stateitem_T *push_next_match(void)</a>
<a name="ln2180">{</a>
<a name="ln2181">  stateitem_T *cur_si;</a>
<a name="ln2182">  synpat_T *spp;</a>
<a name="ln2183">  int save_flags;</a>
<a name="ln2184"> </a>
<a name="ln2185">  spp = &amp;(SYN_ITEMS(syn_block)[next_match_idx]);</a>
<a name="ln2186"> </a>
<a name="ln2187">  /*</a>
<a name="ln2188">   * Push the item in current_state stack;</a>
<a name="ln2189">   */</a>
<a name="ln2190">  push_current_state(next_match_idx);</a>
<a name="ln2191">  {</a>
<a name="ln2192">    /*</a>
<a name="ln2193">     * If it's a start-skip-end type that crosses lines, figure out how</a>
<a name="ln2194">     * much it continues in this line.  Otherwise just fill in the length.</a>
<a name="ln2195">     */</a>
<a name="ln2196">    cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2197">    cur_si-&gt;si_h_startpos = next_match_h_startpos;</a>
<a name="ln2198">    cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln2199">    cur_si-&gt;si_m_lnum = current_lnum;</a>
<a name="ln2200">    cur_si-&gt;si_flags = spp-&gt;sp_flags;</a>
<a name="ln2201">    cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2202">    cur_si-&gt;si_cchar = spp-&gt;sp_cchar;</a>
<a name="ln2203">    if (current_state.ga_len &gt; 1)</a>
<a name="ln2204">      cur_si-&gt;si_flags |=</a>
<a name="ln2205">        CUR_STATE(current_state.ga_len - 2).si_flags &amp; HL_CONCEAL;</a>
<a name="ln2206">    cur_si-&gt;si_next_list = spp-&gt;sp_next_list;</a>
<a name="ln2207">    cur_si-&gt;si_extmatch = ref_extmatch(next_match_extmatch);</a>
<a name="ln2208">    if (spp-&gt;sp_type == SPTYPE_START &amp;&amp; !(spp-&gt;sp_flags &amp; HL_ONELINE)) {</a>
<a name="ln2209">      /* Try to find the end pattern in the current line */</a>
<a name="ln2210">      update_si_end(cur_si, (int)(next_match_m_endpos.col), TRUE);</a>
<a name="ln2211">      check_keepend();</a>
<a name="ln2212">    } else {</a>
<a name="ln2213">      cur_si-&gt;si_m_endpos = next_match_m_endpos;</a>
<a name="ln2214">      cur_si-&gt;si_h_endpos = next_match_h_endpos;</a>
<a name="ln2215">      cur_si-&gt;si_ends = TRUE;</a>
<a name="ln2216">      cur_si-&gt;si_flags |= next_match_flags;</a>
<a name="ln2217">      cur_si-&gt;si_eoe_pos = next_match_eoe_pos;</a>
<a name="ln2218">      cur_si-&gt;si_end_idx = next_match_end_idx;</a>
<a name="ln2219">    }</a>
<a name="ln2220">    if (keepend_level &lt; 0 &amp;&amp; (cur_si-&gt;si_flags &amp; HL_KEEPEND))</a>
<a name="ln2221">      keepend_level = current_state.ga_len - 1;</a>
<a name="ln2222">    check_keepend();</a>
<a name="ln2223">    update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2224"> </a>
<a name="ln2225">    save_flags = cur_si-&gt;si_flags &amp; (HL_CONCEAL | HL_CONCEALENDS);</a>
<a name="ln2226">    /*</a>
<a name="ln2227">     * If the start pattern has another highlight group, push another item</a>
<a name="ln2228">     * on the stack for the start pattern.</a>
<a name="ln2229">     */</a>
<a name="ln2230">    if (spp-&gt;sp_type == SPTYPE_START &amp;&amp; spp-&gt;sp_syn_match_id != 0) {</a>
<a name="ln2231">      push_current_state(next_match_idx);</a>
<a name="ln2232">      cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2233">      cur_si-&gt;si_h_startpos = next_match_h_startpos;</a>
<a name="ln2234">      cur_si-&gt;si_m_startcol = current_col;</a>
<a name="ln2235">      cur_si-&gt;si_m_lnum = current_lnum;</a>
<a name="ln2236">      cur_si-&gt;si_m_endpos = next_match_eos_pos;</a>
<a name="ln2237">      cur_si-&gt;si_h_endpos = next_match_eos_pos;</a>
<a name="ln2238">      cur_si-&gt;si_ends = TRUE;</a>
<a name="ln2239">      cur_si-&gt;si_end_idx = 0;</a>
<a name="ln2240">      cur_si-&gt;si_flags = HL_MATCH;</a>
<a name="ln2241">      cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2242">      cur_si-&gt;si_flags |= save_flags;</a>
<a name="ln2243">      if (cur_si-&gt;si_flags &amp; HL_CONCEALENDS)</a>
<a name="ln2244">        cur_si-&gt;si_flags |= HL_CONCEAL;</a>
<a name="ln2245">      cur_si-&gt;si_next_list = NULL;</a>
<a name="ln2246">      check_keepend();</a>
<a name="ln2247">      update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2248">    }</a>
<a name="ln2249">  }</a>
<a name="ln2250"> </a>
<a name="ln2251">  next_match_idx = -1;          /* try other match next time */</a>
<a name="ln2252"> </a>
<a name="ln2253">  return cur_si;</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256">/*</a>
<a name="ln2257"> * Check for end of current state (and the states before it).</a>
<a name="ln2258"> */</a>
<a name="ln2259">static void check_state_ends(void)</a>
<a name="ln2260">{</a>
<a name="ln2261">  stateitem_T *cur_si;</a>
<a name="ln2262">  int had_extend;</a>
<a name="ln2263"> </a>
<a name="ln2264">  cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2265">  for (;; ) {</a>
<a name="ln2266">    if (cur_si-&gt;si_ends</a>
<a name="ln2267">        &amp;&amp; (cur_si-&gt;si_m_endpos.lnum &lt; current_lnum</a>
<a name="ln2268">            || (cur_si-&gt;si_m_endpos.lnum == current_lnum</a>
<a name="ln2269">                &amp;&amp; cur_si-&gt;si_m_endpos.col &lt;= current_col))) {</a>
<a name="ln2270">      /*</a>
<a name="ln2271">       * If there is an end pattern group ID, highlight the end pattern</a>
<a name="ln2272">       * now.  No need to pop the current item from the stack.</a>
<a name="ln2273">       * Only do this if the end pattern continues beyond the current</a>
<a name="ln2274">       * position.</a>
<a name="ln2275">       */</a>
<a name="ln2276">      if (cur_si-&gt;si_end_idx</a>
<a name="ln2277">          &amp;&amp; (cur_si-&gt;si_eoe_pos.lnum &gt; current_lnum</a>
<a name="ln2278">              || (cur_si-&gt;si_eoe_pos.lnum == current_lnum</a>
<a name="ln2279">                  &amp;&amp; cur_si-&gt;si_eoe_pos.col &gt; current_col))) {</a>
<a name="ln2280">        cur_si-&gt;si_idx = cur_si-&gt;si_end_idx;</a>
<a name="ln2281">        cur_si-&gt;si_end_idx = 0;</a>
<a name="ln2282">        cur_si-&gt;si_m_endpos = cur_si-&gt;si_eoe_pos;</a>
<a name="ln2283">        cur_si-&gt;si_h_endpos = cur_si-&gt;si_eoe_pos;</a>
<a name="ln2284">        cur_si-&gt;si_flags |= HL_MATCH;</a>
<a name="ln2285">        cur_si-&gt;si_seqnr = next_seqnr++;</a>
<a name="ln2286">        if (cur_si-&gt;si_flags &amp; HL_CONCEALENDS)</a>
<a name="ln2287">          cur_si-&gt;si_flags |= HL_CONCEAL;</a>
<a name="ln2288">        update_si_attr(current_state.ga_len - 1);</a>
<a name="ln2289"> </a>
<a name="ln2290">        /* nextgroup= should not match in the end pattern */</a>
<a name="ln2291">        current_next_list = NULL;</a>
<a name="ln2292"> </a>
<a name="ln2293">        /* what matches next may be different now, clear it */</a>
<a name="ln2294">        next_match_idx = 0;</a>
<a name="ln2295">        next_match_col = MAXCOL;</a>
<a name="ln2296">        break;</a>
<a name="ln2297">      } else {</a>
<a name="ln2298">        /* handle next_list, unless at end of line and no &quot;skipnl&quot; or</a>
<a name="ln2299">         * &quot;skipempty&quot; */</a>
<a name="ln2300">        current_next_list = cur_si-&gt;si_next_list;</a>
<a name="ln2301">        current_next_flags = cur_si-&gt;si_flags;</a>
<a name="ln2302">        if (!(current_next_flags &amp; (HL_SKIPNL | HL_SKIPEMPTY))</a>
<a name="ln2303">            &amp;&amp; syn_getcurline()[current_col] == NUL)</a>
<a name="ln2304">          current_next_list = NULL;</a>
<a name="ln2305"> </a>
<a name="ln2306">        /* When the ended item has &quot;extend&quot;, another item with</a>
<a name="ln2307">         * &quot;keepend&quot; now needs to check for its end. */</a>
<a name="ln2308">        had_extend = (cur_si-&gt;si_flags &amp; HL_EXTEND);</a>
<a name="ln2309"> </a>
<a name="ln2310">        pop_current_state();</a>
<a name="ln2311"> </a>
<a name="ln2312">        if (GA_EMPTY(&amp;current_state))</a>
<a name="ln2313">          break;</a>
<a name="ln2314"> </a>
<a name="ln2315">        if (had_extend &amp;&amp; keepend_level &gt;= 0) {</a>
<a name="ln2316">          syn_update_ends(FALSE);</a>
<a name="ln2317">          if (GA_EMPTY(&amp;current_state))</a>
<a name="ln2318">            break;</a>
<a name="ln2319">        }</a>
<a name="ln2320"> </a>
<a name="ln2321">        cur_si = &amp;CUR_STATE(current_state.ga_len - 1);</a>
<a name="ln2322"> </a>
<a name="ln2323">        /*</a>
<a name="ln2324">         * Only for a region the search for the end continues after</a>
<a name="ln2325">         * the end of the contained item.  If the contained match</a>
<a name="ln2326">         * included the end-of-line, break here, the region continues.</a>
<a name="ln2327">         * Don't do this when:</a>
<a name="ln2328">         * - &quot;keepend&quot; is used for the contained item</a>
<a name="ln2329">         * - not at the end of the line (could be end=&quot;x$&quot;me=e-1).</a>
<a name="ln2330">         * - &quot;excludenl&quot; is used (HL_HAS_EOL won't be set)</a>
<a name="ln2331">         */</a>
<a name="ln2332">        if (cur_si-&gt;si_idx &gt;= 0</a>
<a name="ln2333">            &amp;&amp; SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_type</a>
<a name="ln2334">            == SPTYPE_START</a>
<a name="ln2335">            &amp;&amp; !(cur_si-&gt;si_flags &amp; (HL_MATCH | HL_KEEPEND))) {</a>
<a name="ln2336">          update_si_end(cur_si, (int)current_col, TRUE);</a>
<a name="ln2337">          check_keepend();</a>
<a name="ln2338">          if ((current_next_flags &amp; HL_HAS_EOL)</a>
<a name="ln2339">              &amp;&amp; keepend_level &lt; 0</a>
<a name="ln2340">              &amp;&amp; syn_getcurline()[current_col] == NUL)</a>
<a name="ln2341">            break;</a>
<a name="ln2342">        }</a>
<a name="ln2343">      }</a>
<a name="ln2344">    } else</a>
<a name="ln2345">      break;</a>
<a name="ln2346">  }</a>
<a name="ln2347">}</a>
<a name="ln2348"> </a>
<a name="ln2349">/*</a>
<a name="ln2350"> * Update an entry in the current_state stack for a match or region.  This</a>
<a name="ln2351"> * fills in si_attr, si_next_list and si_cont_list.</a>
<a name="ln2352"> */</a>
<a name="ln2353">static void update_si_attr(int idx)</a>
<a name="ln2354">{</a>
<a name="ln2355">  stateitem_T *sip = &amp;CUR_STATE(idx);</a>
<a name="ln2356">  synpat_T    *spp;</a>
<a name="ln2357"> </a>
<a name="ln2358">  /* This should not happen... */</a>
<a name="ln2359">  if (sip-&gt;si_idx &lt; 0)</a>
<a name="ln2360">    return;</a>
<a name="ln2361"> </a>
<a name="ln2362">  spp = &amp;(SYN_ITEMS(syn_block)[sip-&gt;si_idx]);</a>
<a name="ln2363">  if (sip-&gt;si_flags &amp; HL_MATCH)</a>
<a name="ln2364">    sip-&gt;si_id = spp-&gt;sp_syn_match_id;</a>
<a name="ln2365">  else</a>
<a name="ln2366">    sip-&gt;si_id = spp-&gt;sp_syn.id;</a>
<a name="ln2367">  sip-&gt;si_attr = syn_id2attr(sip-&gt;si_id);</a>
<a name="ln2368">  sip-&gt;si_trans_id = sip-&gt;si_id;</a>
<a name="ln2369">  if (sip-&gt;si_flags &amp; HL_MATCH)</a>
<a name="ln2370">    sip-&gt;si_cont_list = NULL;</a>
<a name="ln2371">  else</a>
<a name="ln2372">    sip-&gt;si_cont_list = spp-&gt;sp_cont_list;</a>
<a name="ln2373"> </a>
<a name="ln2374">  /*</a>
<a name="ln2375">   * For transparent items, take attr from outer item.</a>
<a name="ln2376">   * Also take cont_list, if there is none.</a>
<a name="ln2377">   * Don't do this for the matchgroup of a start or end pattern.</a>
<a name="ln2378">   */</a>
<a name="ln2379">  if ((spp-&gt;sp_flags &amp; HL_TRANSP) &amp;&amp; !(sip-&gt;si_flags &amp; HL_MATCH)) {</a>
<a name="ln2380">    if (idx == 0) {</a>
<a name="ln2381">      sip-&gt;si_attr = 0;</a>
<a name="ln2382">      sip-&gt;si_trans_id = 0;</a>
<a name="ln2383">      if (sip-&gt;si_cont_list == NULL)</a>
<a name="ln2384">        sip-&gt;si_cont_list = ID_LIST_ALL;</a>
<a name="ln2385">    } else {</a>
<a name="ln2386">      sip-&gt;si_attr = CUR_STATE(idx - 1).si_attr;</a>
<a name="ln2387">      sip-&gt;si_trans_id = CUR_STATE(idx - 1).si_trans_id;</a>
<a name="ln2388">      sip-&gt;si_h_startpos = CUR_STATE(idx - 1).si_h_startpos;</a>
<a name="ln2389">      sip-&gt;si_h_endpos = CUR_STATE(idx - 1).si_h_endpos;</a>
<a name="ln2390">      if (sip-&gt;si_cont_list == NULL) {</a>
<a name="ln2391">        sip-&gt;si_flags |= HL_TRANS_CONT;</a>
<a name="ln2392">        sip-&gt;si_cont_list = CUR_STATE(idx - 1).si_cont_list;</a>
<a name="ln2393">      }</a>
<a name="ln2394">    }</a>
<a name="ln2395">  }</a>
<a name="ln2396">}</a>
<a name="ln2397"> </a>
<a name="ln2398">/*</a>
<a name="ln2399"> * Check the current stack for patterns with &quot;keepend&quot; flag.</a>
<a name="ln2400"> * Propagate the match-end to contained items, until a &quot;skipend&quot; item is found.</a>
<a name="ln2401"> */</a>
<a name="ln2402">static void check_keepend(void)</a>
<a name="ln2403">{</a>
<a name="ln2404">  int i;</a>
<a name="ln2405">  lpos_T maxpos;</a>
<a name="ln2406">  lpos_T maxpos_h;</a>
<a name="ln2407">  stateitem_T *sip;</a>
<a name="ln2408"> </a>
<a name="ln2409">  /*</a>
<a name="ln2410">   * This check can consume a lot of time; only do it from the level where</a>
<a name="ln2411">   * there really is a keepend.</a>
<a name="ln2412">   */</a>
<a name="ln2413">  if (keepend_level &lt; 0)</a>
<a name="ln2414">    return;</a>
<a name="ln2415"> </a>
<a name="ln2416">  /*</a>
<a name="ln2417">   * Find the last index of an &quot;extend&quot; item.  &quot;keepend&quot; items before that</a>
<a name="ln2418">   * won't do anything.  If there is no &quot;extend&quot; item &quot;i&quot; will be</a>
<a name="ln2419">   * &quot;keepend_level&quot; and all &quot;keepend&quot; items will work normally.</a>
<a name="ln2420">   */</a>
<a name="ln2421">  for (i = current_state.ga_len - 1; i &gt; keepend_level; --i)</a>
<a name="ln2422">    if (CUR_STATE(i).si_flags &amp; HL_EXTEND)</a>
<a name="ln2423">      break;</a>
<a name="ln2424"> </a>
<a name="ln2425">  maxpos.lnum = 0;</a>
<a name="ln2426">  maxpos.col = 0;</a>
<a name="ln2427">  maxpos_h.lnum = 0;</a>
<a name="ln2428">  maxpos_h.col = 0;</a>
<a name="ln2429">  for (; i &lt; current_state.ga_len; ++i) {</a>
<a name="ln2430">    sip = &amp;CUR_STATE(i);</a>
<a name="ln2431">    if (maxpos.lnum != 0) {</a>
<a name="ln2432">      limit_pos_zero(&amp;sip-&gt;si_m_endpos, &amp;maxpos);</a>
<a name="ln2433">      limit_pos_zero(&amp;sip-&gt;si_h_endpos, &amp;maxpos_h);</a>
<a name="ln2434">      limit_pos_zero(&amp;sip-&gt;si_eoe_pos, &amp;maxpos);</a>
<a name="ln2435">      sip-&gt;si_ends = TRUE;</a>
<a name="ln2436">    }</a>
<a name="ln2437">    if (sip-&gt;si_ends &amp;&amp; (sip-&gt;si_flags &amp; HL_KEEPEND)) {</a>
<a name="ln2438">      if (maxpos.lnum == 0</a>
<a name="ln2439">          || maxpos.lnum &gt; sip-&gt;si_m_endpos.lnum</a>
<a name="ln2440">          || (maxpos.lnum == sip-&gt;si_m_endpos.lnum</a>
<a name="ln2441">              &amp;&amp; maxpos.col &gt; sip-&gt;si_m_endpos.col))</a>
<a name="ln2442">        maxpos = sip-&gt;si_m_endpos;</a>
<a name="ln2443">      if (maxpos_h.lnum == 0</a>
<a name="ln2444">          || maxpos_h.lnum &gt; sip-&gt;si_h_endpos.lnum</a>
<a name="ln2445">          || (maxpos_h.lnum == sip-&gt;si_h_endpos.lnum</a>
<a name="ln2446">              &amp;&amp; maxpos_h.col &gt; sip-&gt;si_h_endpos.col))</a>
<a name="ln2447">        maxpos_h = sip-&gt;si_h_endpos;</a>
<a name="ln2448">    }</a>
<a name="ln2449">  }</a>
<a name="ln2450">}</a>
<a name="ln2451"> </a>
<a name="ln2452">/*</a>
<a name="ln2453"> * Update an entry in the current_state stack for a start-skip-end pattern.</a>
<a name="ln2454"> * This finds the end of the current item, if it's in the current line.</a>
<a name="ln2455"> *</a>
<a name="ln2456"> * Return the flags for the matched END.</a>
<a name="ln2457"> */</a>
<a name="ln2458">static void</a>
<a name="ln2459">update_si_end(</a>
<a name="ln2460">    stateitem_T *sip,</a>
<a name="ln2461">    int startcol,               /* where to start searching for the end */</a>
<a name="ln2462">    int force                  /* when TRUE overrule a previous end */</a>
<a name="ln2463">)</a>
<a name="ln2464">{</a>
<a name="ln2465">  lpos_T hl_endpos;</a>
<a name="ln2466">  lpos_T end_endpos;</a>
<a name="ln2467"> </a>
<a name="ln2468">  /* return quickly for a keyword */</a>
<a name="ln2469">  if (sip-&gt;si_idx &lt; 0)</a>
<a name="ln2470">    return;</a>
<a name="ln2471"> </a>
<a name="ln2472">  /* Don't update when it's already done.  Can be a match of an end pattern</a>
<a name="ln2473">   * that started in a previous line.  Watch out: can also be a &quot;keepend&quot;</a>
<a name="ln2474">   * from a containing item. */</a>
<a name="ln2475">  if (!force &amp;&amp; sip-&gt;si_m_endpos.lnum &gt;= current_lnum)</a>
<a name="ln2476">    return;</a>
<a name="ln2477"> </a>
<a name="ln2478">  /*</a>
<a name="ln2479">   * We need to find the end of the region.  It may continue in the next</a>
<a name="ln2480">   * line.</a>
<a name="ln2481">   */</a>
<a name="ln2482">  int end_idx = 0;</a>
<a name="ln2483">  lpos_T startpos = {</a>
<a name="ln2484">    .lnum = current_lnum,</a>
<a name="ln2485">    .col = startcol,</a>
<a name="ln2486">  };</a>
<a name="ln2487">  lpos_T endpos = { 0 };</a>
<a name="ln2488">  find_endpos(sip-&gt;si_idx, &amp;startpos, &amp;endpos, &amp;hl_endpos,</a>
<a name="ln2489">      &amp;(sip-&gt;si_flags), &amp;end_endpos, &amp;end_idx, sip-&gt;si_extmatch);</a>
<a name="ln2490"> </a>
<a name="ln2491">  if (endpos.lnum == 0) {</a>
<a name="ln2492">    /* No end pattern matched. */</a>
<a name="ln2493">    if (SYN_ITEMS(syn_block)[sip-&gt;si_idx].sp_flags &amp; HL_ONELINE) {</a>
<a name="ln2494">      /* a &quot;oneline&quot; never continues in the next line */</a>
<a name="ln2495">      sip-&gt;si_ends = TRUE;</a>
<a name="ln2496">      sip-&gt;si_m_endpos.lnum = current_lnum;</a>
<a name="ln2497">      sip-&gt;si_m_endpos.col = (colnr_T)STRLEN(syn_getcurline());</a>
<a name="ln2498">    } else {</a>
<a name="ln2499">      /* continues in the next line */</a>
<a name="ln2500">      sip-&gt;si_ends = FALSE;</a>
<a name="ln2501">      sip-&gt;si_m_endpos.lnum = 0;</a>
<a name="ln2502">    }</a>
<a name="ln2503">    sip-&gt;si_h_endpos = sip-&gt;si_m_endpos;</a>
<a name="ln2504">  } else {</a>
<a name="ln2505">    /* match within this line */</a>
<a name="ln2506">    sip-&gt;si_m_endpos = endpos;</a>
<a name="ln2507">    sip-&gt;si_h_endpos = hl_endpos;</a>
<a name="ln2508">    sip-&gt;si_eoe_pos = end_endpos;</a>
<a name="ln2509">    sip-&gt;si_ends = TRUE;</a>
<a name="ln2510">    sip-&gt;si_end_idx = end_idx;</a>
<a name="ln2511">  }</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514">/*</a>
<a name="ln2515"> * Add a new state to the current state stack.</a>
<a name="ln2516"> * It is cleared and the index set to &quot;idx&quot;.</a>
<a name="ln2517"> */</a>
<a name="ln2518">static void push_current_state(int idx)</a>
<a name="ln2519">{</a>
<a name="ln2520">  stateitem_T *p = GA_APPEND_VIA_PTR(stateitem_T, &amp;current_state);</a>
<a name="ln2521">  memset(p, 0, sizeof(*p));</a>
<a name="ln2522">  p-&gt;si_idx = idx;</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525">/*</a>
<a name="ln2526"> * Remove a state from the current_state stack.</a>
<a name="ln2527"> */</a>
<a name="ln2528">static void pop_current_state(void)</a>
<a name="ln2529">{</a>
<a name="ln2530">  if (!GA_EMPTY(&amp;current_state)) {</a>
<a name="ln2531">    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);</a>
<a name="ln2532">    --current_state.ga_len;</a>
<a name="ln2533">  }</a>
<a name="ln2534">  /* after the end of a pattern, try matching a keyword or pattern */</a>
<a name="ln2535">  next_match_idx = -1;</a>
<a name="ln2536"> </a>
<a name="ln2537">  /* if first state with &quot;keepend&quot; is popped, reset keepend_level */</a>
<a name="ln2538">  if (keepend_level &gt;= current_state.ga_len)</a>
<a name="ln2539">    keepend_level = -1;</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542">/*</a>
<a name="ln2543"> * Find the end of a start/skip/end syntax region after &quot;startpos&quot;.</a>
<a name="ln2544"> * Only checks one line.</a>
<a name="ln2545"> * Also handles a match item that continued from a previous line.</a>
<a name="ln2546"> * If not found, the syntax item continues in the next line.  m_endpos-&gt;lnum</a>
<a name="ln2547"> * will be 0.</a>
<a name="ln2548"> * If found, the end of the region and the end of the highlighting is</a>
<a name="ln2549"> * computed.</a>
<a name="ln2550"> */</a>
<a name="ln2551">static void</a>
<a name="ln2552">find_endpos(</a>
<a name="ln2553">    int idx,                    // index of the pattern</a>
<a name="ln2554">    lpos_T *startpos,           // where to start looking for an END match</a>
<a name="ln2555">    lpos_T *m_endpos,           // return: end of match</a>
<a name="ln2556">    lpos_T *hl_endpos,          // return: end of highlighting</a>
<a name="ln2557">    long *flagsp,               // return: flags of matching END</a>
<a name="ln2558">    lpos_T *end_endpos,         // return: end of end pattern match</a>
<a name="ln2559">    int *end_idx,               // return: group ID for end pat. match, or 0</a>
<a name="ln2560">    reg_extmatch_T *start_ext   // submatches from the start pattern</a>
<a name="ln2561">)</a>
<a name="ln2562">{</a>
<a name="ln2563">  colnr_T matchcol;</a>
<a name="ln2564">  synpat_T    *spp, *spp_skip;</a>
<a name="ln2565">  int start_idx;</a>
<a name="ln2566">  int best_idx;</a>
<a name="ln2567">  regmmatch_T regmatch;</a>
<a name="ln2568">  regmmatch_T best_regmatch;        /* startpos/endpos of best match */</a>
<a name="ln2569">  lpos_T pos;</a>
<a name="ln2570">  char_u      *line;</a>
<a name="ln2571">  int had_match = false;</a>
<a name="ln2572">  char_u buf_chartab[32];  // chartab array for syn option iskeyword</a>
<a name="ln2573"> </a>
<a name="ln2574">  /* just in case we are invoked for a keyword */</a>
<a name="ln2575">  if (idx &lt; 0)</a>
<a name="ln2576">    return;</a>
<a name="ln2577"> </a>
<a name="ln2578">  /*</a>
<a name="ln2579">   * Check for being called with a START pattern.</a>
<a name="ln2580">   * Can happen with a match that continues to the next line, because it</a>
<a name="ln2581">   * contained a region.</a>
<a name="ln2582">   */</a>
<a name="ln2583">  spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2584">  if (spp-&gt;sp_type != SPTYPE_START) {</a>
<a name="ln2585">    *hl_endpos = *startpos;</a>
<a name="ln2586">    return;</a>
<a name="ln2587">  }</a>
<a name="ln2588"> </a>
<a name="ln2589">  /*</a>
<a name="ln2590">   * Find the SKIP or first END pattern after the last START pattern.</a>
<a name="ln2591">   */</a>
<a name="ln2592">  for (;; ) {</a>
<a name="ln2593">    spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2594">    if (spp-&gt;sp_type != SPTYPE_START)</a>
<a name="ln2595">      break;</a>
<a name="ln2596">    ++idx;</a>
<a name="ln2597">  }</a>
<a name="ln2598"> </a>
<a name="ln2599">  /*</a>
<a name="ln2600">   *	Lookup the SKIP pattern (if present)</a>
<a name="ln2601">   */</a>
<a name="ln2602">  if (spp-&gt;sp_type == SPTYPE_SKIP) {</a>
<a name="ln2603">    spp_skip = spp;</a>
<a name="ln2604">    ++idx;</a>
<a name="ln2605">  } else</a>
<a name="ln2606">    spp_skip = NULL;</a>
<a name="ln2607"> </a>
<a name="ln2608">  /* Setup external matches for syn_regexec(). */</a>
<a name="ln2609">  unref_extmatch(re_extmatch_in);</a>
<a name="ln2610">  re_extmatch_in = ref_extmatch(start_ext);</a>
<a name="ln2611"> </a>
<a name="ln2612">  matchcol = startpos-&gt;col;     // start looking for a match at sstart</a>
<a name="ln2613">  start_idx = idx;              // remember the first END pattern.</a>
<a name="ln2614">  best_regmatch.startpos[0].col = 0;            // avoid compiler warning</a>
<a name="ln2615"> </a>
<a name="ln2616">  // use syntax iskeyword option</a>
<a name="ln2617">  save_chartab(buf_chartab);</a>
<a name="ln2618"> </a>
<a name="ln2619">  for (;; ) {</a>
<a name="ln2620">    /*</a>
<a name="ln2621">     * Find end pattern that matches first after &quot;matchcol&quot;.</a>
<a name="ln2622">     */</a>
<a name="ln2623">    best_idx = -1;</a>
<a name="ln2624">    for (idx = start_idx; idx &lt; syn_block-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln2625">      int lc_col = matchcol;</a>
<a name="ln2626"> </a>
<a name="ln2627">      spp = &amp;(SYN_ITEMS(syn_block)[idx]);</a>
<a name="ln2628">      if (spp-&gt;sp_type != SPTYPE_END)           /* past last END pattern */</a>
<a name="ln2629">        break;</a>
<a name="ln2630">      lc_col -= spp-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln2631">      if (lc_col &lt; 0)</a>
<a name="ln2632">        lc_col = 0;</a>
<a name="ln2633"> </a>
<a name="ln2634">      regmatch.rmm_ic = spp-&gt;sp_ic;</a>
<a name="ln2635">      regmatch.regprog = spp-&gt;sp_prog;</a>
<a name="ln2636">      int r = syn_regexec(&amp;regmatch, startpos-&gt;lnum, lc_col,</a>
<a name="ln2637">                          IF_SYN_TIME(&amp;spp-&gt;sp_time));</a>
<a name="ln2638">      spp-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln2639">      if (r) {</a>
<a name="ln2640">        if (best_idx == -1 || regmatch.startpos[0].col</a>
<a name="ln2641">            &lt; best_regmatch.startpos[0].col) {</a>
<a name="ln2642">          best_idx = idx;</a>
<a name="ln2643">          best_regmatch.startpos[0] = regmatch.startpos[0];</a>
<a name="ln2644">          best_regmatch.endpos[0] = regmatch.endpos[0];</a>
<a name="ln2645">        }</a>
<a name="ln2646">      }</a>
<a name="ln2647">    }</a>
<a name="ln2648"> </a>
<a name="ln2649">    /*</a>
<a name="ln2650">     * If all end patterns have been tried, and there is no match, the</a>
<a name="ln2651">     * item continues until end-of-line.</a>
<a name="ln2652">     */</a>
<a name="ln2653">    if (best_idx == -1)</a>
<a name="ln2654">      break;</a>
<a name="ln2655"> </a>
<a name="ln2656">    /*</a>
<a name="ln2657">     * If the skip pattern matches before the end pattern,</a>
<a name="ln2658">     * continue searching after the skip pattern.</a>
<a name="ln2659">     */</a>
<a name="ln2660">    if (spp_skip != NULL) {</a>
<a name="ln2661">      int lc_col = matchcol - spp_skip-&gt;sp_offsets[SPO_LC_OFF];</a>
<a name="ln2662"> </a>
<a name="ln2663">      if (lc_col &lt; 0)</a>
<a name="ln2664">        lc_col = 0;</a>
<a name="ln2665">      regmatch.rmm_ic = spp_skip-&gt;sp_ic;</a>
<a name="ln2666">      regmatch.regprog = spp_skip-&gt;sp_prog;</a>
<a name="ln2667">      int r = syn_regexec(&amp;regmatch, startpos-&gt;lnum, lc_col,</a>
<a name="ln2668">                          IF_SYN_TIME(&amp;spp_skip-&gt;sp_time));</a>
<a name="ln2669">      spp_skip-&gt;sp_prog = regmatch.regprog;</a>
<a name="ln2670">      if (r &amp;&amp; regmatch.startpos[0].col &lt;= best_regmatch.startpos[0].col) {</a>
<a name="ln2671">        // Add offset to skip pattern match</a>
<a name="ln2672">        syn_add_end_off(&amp;pos, &amp;regmatch, spp_skip, SPO_ME_OFF, 1);</a>
<a name="ln2673"> </a>
<a name="ln2674">        // If the skip pattern goes on to the next line, there is no</a>
<a name="ln2675">        // match with an end pattern in this line.</a>
<a name="ln2676">        if (pos.lnum &gt; startpos-&gt;lnum) {</a>
<a name="ln2677">          break;</a>
<a name="ln2678">        }</a>
<a name="ln2679"> </a>
<a name="ln2680">        line = ml_get_buf(syn_buf, startpos-&gt;lnum, false);</a>
<a name="ln2681">        int line_len = (int)STRLEN(line);</a>
<a name="ln2682"> </a>
<a name="ln2683">        // take care of an empty match or negative offset</a>
<a name="ln2684">        if (pos.col &lt;= matchcol) {</a>
<a name="ln2685">          matchcol++;</a>
<a name="ln2686">        } else if (pos.col &lt;= regmatch.endpos[0].col) {</a>
<a name="ln2687">          matchcol = pos.col;</a>
<a name="ln2688">        } else {</a>
<a name="ln2689">          // Be careful not to jump over the NUL at the end-of-line</a>
<a name="ln2690">          for (matchcol = regmatch.endpos[0].col;</a>
<a name="ln2691">               matchcol &lt; line_len &amp;&amp; matchcol &lt; pos.col;</a>
<a name="ln2692">               matchcol++) {</a>
<a name="ln2693">          }</a>
<a name="ln2694">        }</a>
<a name="ln2695"> </a>
<a name="ln2696">        // if the skip pattern includes end-of-line, break here</a>
<a name="ln2697">        if (matchcol &gt;= line_len) {</a>
<a name="ln2698">          break;</a>
<a name="ln2699">        }</a>
<a name="ln2700"> </a>
<a name="ln2701">        continue;  // start with first end pattern again</a>
<a name="ln2702">      }</a>
<a name="ln2703">    }</a>
<a name="ln2704"> </a>
<a name="ln2705">    /*</a>
<a name="ln2706">     * Match from start pattern to end pattern.</a>
<a name="ln2707">     * Correct for match and highlight offset of end pattern.</a>
<a name="ln2708">     */</a>
<a name="ln2709">    spp = &amp;(SYN_ITEMS(syn_block)[best_idx]);</a>
<a name="ln2710">    syn_add_end_off(m_endpos, &amp;best_regmatch, spp, SPO_ME_OFF, 1);</a>
<a name="ln2711">    /* can't end before the start */</a>
<a name="ln2712">    if (m_endpos-&gt;lnum == startpos-&gt;lnum &amp;&amp; m_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2713">      m_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2714"> </a>
<a name="ln2715">    syn_add_end_off(end_endpos, &amp;best_regmatch, spp, SPO_HE_OFF, 1);</a>
<a name="ln2716">    /* can't end before the start */</a>
<a name="ln2717">    if (end_endpos-&gt;lnum == startpos-&gt;lnum</a>
<a name="ln2718">        &amp;&amp; end_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2719">      end_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2720">    /* can't end after the match */</a>
<a name="ln2721">    limit_pos(end_endpos, m_endpos);</a>
<a name="ln2722"> </a>
<a name="ln2723">    /*</a>
<a name="ln2724">     * If the end group is highlighted differently, adjust the pointers.</a>
<a name="ln2725">     */</a>
<a name="ln2726">    if (spp-&gt;sp_syn_match_id != spp-&gt;sp_syn.id &amp;&amp; spp-&gt;sp_syn_match_id != 0) {</a>
<a name="ln2727">      *end_idx = best_idx;</a>
<a name="ln2728">      if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; (SPO_RE_OFF + SPO_COUNT))) {</a>
<a name="ln2729">        hl_endpos-&gt;lnum = best_regmatch.endpos[0].lnum;</a>
<a name="ln2730">        hl_endpos-&gt;col = best_regmatch.endpos[0].col;</a>
<a name="ln2731">      } else {</a>
<a name="ln2732">        hl_endpos-&gt;lnum = best_regmatch.startpos[0].lnum;</a>
<a name="ln2733">        hl_endpos-&gt;col = best_regmatch.startpos[0].col;</a>
<a name="ln2734">      }</a>
<a name="ln2735">      hl_endpos-&gt;col += spp-&gt;sp_offsets[SPO_RE_OFF];</a>
<a name="ln2736"> </a>
<a name="ln2737">      /* can't end before the start */</a>
<a name="ln2738">      if (hl_endpos-&gt;lnum == startpos-&gt;lnum</a>
<a name="ln2739">          &amp;&amp; hl_endpos-&gt;col &lt; startpos-&gt;col)</a>
<a name="ln2740">        hl_endpos-&gt;col = startpos-&gt;col;</a>
<a name="ln2741">      limit_pos(hl_endpos, m_endpos);</a>
<a name="ln2742"> </a>
<a name="ln2743">      /* now the match ends where the highlighting ends, it is turned</a>
<a name="ln2744">       * into the matchgroup for the end */</a>
<a name="ln2745">      *m_endpos = *hl_endpos;</a>
<a name="ln2746">    } else {</a>
<a name="ln2747">      *end_idx = 0;</a>
<a name="ln2748">      *hl_endpos = *end_endpos;</a>
<a name="ln2749">    }</a>
<a name="ln2750"> </a>
<a name="ln2751">    *flagsp = spp-&gt;sp_flags;</a>
<a name="ln2752"> </a>
<a name="ln2753">    had_match = TRUE;</a>
<a name="ln2754">    break;</a>
<a name="ln2755">  }</a>
<a name="ln2756"> </a>
<a name="ln2757">  /* no match for an END pattern in this line */</a>
<a name="ln2758">  if (!had_match)</a>
<a name="ln2759">    m_endpos-&gt;lnum = 0;</a>
<a name="ln2760"> </a>
<a name="ln2761">  restore_chartab(buf_chartab);</a>
<a name="ln2762"> </a>
<a name="ln2763">  /* Remove external matches. */</a>
<a name="ln2764">  unref_extmatch(re_extmatch_in);</a>
<a name="ln2765">  re_extmatch_in = NULL;</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768">/*</a>
<a name="ln2769"> * Limit &quot;pos&quot; not to be after &quot;limit&quot;.</a>
<a name="ln2770"> */</a>
<a name="ln2771">static void limit_pos(lpos_T *pos, lpos_T *limit)</a>
<a name="ln2772">{</a>
<a name="ln2773">  if (pos-&gt;lnum &gt; limit-&gt;lnum)</a>
<a name="ln2774">    *pos = *limit;</a>
<a name="ln2775">  else if (pos-&gt;lnum == limit-&gt;lnum &amp;&amp; pos-&gt;col &gt; limit-&gt;col)</a>
<a name="ln2776">    pos-&gt;col = limit-&gt;col;</a>
<a name="ln2777">}</a>
<a name="ln2778"> </a>
<a name="ln2779">/*</a>
<a name="ln2780"> * Limit &quot;pos&quot; not to be after &quot;limit&quot;, unless pos-&gt;lnum is zero.</a>
<a name="ln2781"> */</a>
<a name="ln2782">static void limit_pos_zero(lpos_T *pos, lpos_T *limit)</a>
<a name="ln2783">{</a>
<a name="ln2784">  if (pos-&gt;lnum == 0)</a>
<a name="ln2785">    *pos = *limit;</a>
<a name="ln2786">  else</a>
<a name="ln2787">    limit_pos(pos, limit);</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790">/*</a>
<a name="ln2791"> * Add offset to matched text for end of match or highlight.</a>
<a name="ln2792"> */</a>
<a name="ln2793">static void</a>
<a name="ln2794">syn_add_end_off(</a>
<a name="ln2795">    lpos_T *result,           // returned position</a>
<a name="ln2796">    regmmatch_T *regmatch,    // start/end of match</a>
<a name="ln2797">    synpat_T *spp,            // matched pattern</a>
<a name="ln2798">    int idx,                  // index of offset</a>
<a name="ln2799">    int extra                 // extra chars for offset to start</a>
<a name="ln2800">)</a>
<a name="ln2801">{</a>
<a name="ln2802">  int col;</a>
<a name="ln2803">  int off;</a>
<a name="ln2804">  char_u      *base;</a>
<a name="ln2805">  char_u      *p;</a>
<a name="ln2806"> </a>
<a name="ln2807">  if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; idx)) {</a>
<a name="ln2808">    result-&gt;lnum = regmatch-&gt;startpos[0].lnum;</a>
<a name="ln2809">    col = regmatch-&gt;startpos[0].col;</a>
<a name="ln2810">    off = spp-&gt;sp_offsets[idx] + extra;</a>
<a name="ln2811">  } else {</a>
<a name="ln2812">    result-&gt;lnum = regmatch-&gt;endpos[0].lnum;</a>
<a name="ln2813">    col = regmatch-&gt;endpos[0].col;</a>
<a name="ln2814">    off = spp-&gt;sp_offsets[idx];</a>
<a name="ln2815">  }</a>
<a name="ln2816">  /* Don't go past the end of the line.  Matters for &quot;rs=e+2&quot; when there</a>
<a name="ln2817">   * is a matchgroup. Watch out for match with last NL in the buffer. */</a>
<a name="ln2818">  if (result-&gt;lnum &gt; syn_buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2819">    col = 0;</a>
<a name="ln2820">  else if (off != 0) {</a>
<a name="ln2821">    base = ml_get_buf(syn_buf, result-&gt;lnum, FALSE);</a>
<a name="ln2822">    p = base + col;</a>
<a name="ln2823">    if (off &gt; 0) {</a>
<a name="ln2824">      while (off-- &gt; 0 &amp;&amp; *p != NUL) {</a>
<a name="ln2825">        MB_PTR_ADV(p);</a>
<a name="ln2826">      }</a>
<a name="ln2827">    } else {</a>
<a name="ln2828">      while (off++ &lt; 0 &amp;&amp; base &lt; p) {</a>
<a name="ln2829">        MB_PTR_BACK(base, p);</a>
<a name="ln2830">      }</a>
<a name="ln2831">    }</a>
<a name="ln2832">    col = (int)(p - base);</a>
<a name="ln2833">  }</a>
<a name="ln2834">  result-&gt;col = col;</a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">/*</a>
<a name="ln2838"> * Add offset to matched text for start of match or highlight.</a>
<a name="ln2839"> * Avoid resulting column to become negative.</a>
<a name="ln2840"> */</a>
<a name="ln2841">static void</a>
<a name="ln2842">syn_add_start_off(</a>
<a name="ln2843">    lpos_T *result,           // returned position</a>
<a name="ln2844">    regmmatch_T *regmatch,    // start/end of match</a>
<a name="ln2845">    synpat_T *spp,</a>
<a name="ln2846">    int idx,</a>
<a name="ln2847">    int extra                 // extra chars for offset to end</a>
<a name="ln2848">)</a>
<a name="ln2849">{</a>
<a name="ln2850">  int col;</a>
<a name="ln2851">  int off;</a>
<a name="ln2852">  char_u      *base;</a>
<a name="ln2853">  char_u      *p;</a>
<a name="ln2854"> </a>
<a name="ln2855">  if (spp-&gt;sp_off_flags &amp; (1 &lt;&lt; (idx + SPO_COUNT))) {</a>
<a name="ln2856">    result-&gt;lnum = regmatch-&gt;endpos[0].lnum;</a>
<a name="ln2857">    col = regmatch-&gt;endpos[0].col;</a>
<a name="ln2858">    off = spp-&gt;sp_offsets[idx] + extra;</a>
<a name="ln2859">  } else {</a>
<a name="ln2860">    result-&gt;lnum = regmatch-&gt;startpos[0].lnum;</a>
<a name="ln2861">    col = regmatch-&gt;startpos[0].col;</a>
<a name="ln2862">    off = spp-&gt;sp_offsets[idx];</a>
<a name="ln2863">  }</a>
<a name="ln2864">  if (result-&gt;lnum &gt; syn_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2865">    /* a &quot;\n&quot; at the end of the pattern may take us below the last line */</a>
<a name="ln2866">    result-&gt;lnum = syn_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2867">    col = (int)STRLEN(ml_get_buf(syn_buf, result-&gt;lnum, FALSE));</a>
<a name="ln2868">  }</a>
<a name="ln2869">  if (off != 0) {</a>
<a name="ln2870">    base = ml_get_buf(syn_buf, result-&gt;lnum, FALSE);</a>
<a name="ln2871">    p = base + col;</a>
<a name="ln2872">    if (off &gt; 0) {</a>
<a name="ln2873">      while (off-- &amp;&amp; *p != NUL) {</a>
<a name="ln2874">        MB_PTR_ADV(p);</a>
<a name="ln2875">      }</a>
<a name="ln2876">    } else {</a>
<a name="ln2877">      while (off++ &amp;&amp; base &lt; p) {</a>
<a name="ln2878">        MB_PTR_BACK(base, p);</a>
<a name="ln2879">      }</a>
<a name="ln2880">    }</a>
<a name="ln2881">    col = (int)(p - base);</a>
<a name="ln2882">  }</a>
<a name="ln2883">  result-&gt;col = col;</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/*</a>
<a name="ln2887"> * Get current line in syntax buffer.</a>
<a name="ln2888"> */</a>
<a name="ln2889">static char_u *syn_getcurline(void)</a>
<a name="ln2890">{</a>
<a name="ln2891">  return ml_get_buf(syn_buf, current_lnum, FALSE);</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">/*</a>
<a name="ln2895"> * Call vim_regexec() to find a match with &quot;rmp&quot; in &quot;syn_buf&quot;.</a>
<a name="ln2896"> * Returns TRUE when there is a match.</a>
<a name="ln2897"> */</a>
<a name="ln2898">static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)</a>
<a name="ln2899">{</a>
<a name="ln2900">  int r;</a>
<a name="ln2901">  int timed_out = 0;</a>
<a name="ln2902">  proftime_T pt;</a>
<a name="ln2903">  const int l_syn_time_on = syn_time_on;</a>
<a name="ln2904"> </a>
<a name="ln2905">  if (l_syn_time_on) {</a>
<a name="ln2906">    pt = profile_start();</a>
<a name="ln2907">  }</a>
<a name="ln2908"> </a>
<a name="ln2909">  if (rmp-&gt;regprog == NULL) {</a>
<a name="ln2910">    // This can happen if a previous call to vim_regexec_multi() tried to</a>
<a name="ln2911">    // use the NFA engine, which resulted in NFA_TOO_EXPENSIVE, and</a>
<a name="ln2912">    // compiling the pattern with the other engine fails.</a>
<a name="ln2913">    return false;</a>
<a name="ln2914">  }</a>
<a name="ln2915"> </a>
<a name="ln2916">  rmp-&gt;rmm_maxcol = syn_buf-&gt;b_p_smc;</a>
<a name="ln2917">  r = vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col,</a>
<a name="ln2918">                        syn_tm, &amp;timed_out);</a>
<a name="ln2919"> </a>
<a name="ln2920">  if (l_syn_time_on) {</a>
<a name="ln2921">    pt = profile_end(pt);</a>
<a name="ln2922">    st-&gt;total = profile_add(st-&gt;total, pt);</a>
<a name="ln2923">    if (profile_cmp(pt, st-&gt;slowest) &lt; 0) {</a>
<a name="ln2924">      st-&gt;slowest = pt;</a>
<a name="ln2925">    }</a>
<a name="ln2926">    ++st-&gt;count;</a>
<a name="ln2927">    if (r &gt; 0)</a>
<a name="ln2928">      ++st-&gt;match;</a>
<a name="ln2929">  }</a>
<a name="ln2930">  if (timed_out &amp;&amp; !syn_win-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln2931">    syn_win-&gt;w_s-&gt;b_syn_slow = true;</a>
<a name="ln2932">    MSG(_(&quot;'redrawtime' exceeded, syntax highlighting disabled&quot;));</a>
<a name="ln2933">  }</a>
<a name="ln2934"> </a>
<a name="ln2935">  if (r &gt; 0) {</a>
<a name="ln2936">    rmp-&gt;startpos[0].lnum += lnum;</a>
<a name="ln2937">    rmp-&gt;endpos[0].lnum += lnum;</a>
<a name="ln2938">    return TRUE;</a>
<a name="ln2939">  }</a>
<a name="ln2940">  return FALSE;</a>
<a name="ln2941">}</a>
<a name="ln2942"> </a>
<a name="ln2943">/*</a>
<a name="ln2944"> * Check one position in a line for a matching keyword.</a>
<a name="ln2945"> * The caller must check if a keyword can start at startcol.</a>
<a name="ln2946"> * Return its ID if found, 0 otherwise.</a>
<a name="ln2947"> */</a>
<a name="ln2948">static int check_keyword_id(</a>
<a name="ln2949">    char_u *const line,</a>
<a name="ln2950">    const int startcol,           // position in line to check for keyword</a>
<a name="ln2951">    int *const endcolp,           // return: character after found keyword</a>
<a name="ln2952">    long *const flagsp,           // return: flags of matching keyword</a>
<a name="ln2953">    int16_t **const next_listp,   // return: next_list of matching keyword</a>
<a name="ln2954">    stateitem_T *const cur_si,    // item at the top of the stack</a>
<a name="ln2955">    int *const ccharp             // conceal substitution char</a>
<a name="ln2956">)</a>
<a name="ln2957">{</a>
<a name="ln2958">  // Find first character after the keyword.  First character was already</a>
<a name="ln2959">  // checked.</a>
<a name="ln2960">  char_u *const kwp = line + startcol;</a>
<a name="ln2961">  int kwlen = 0;</a>
<a name="ln2962">  do {</a>
<a name="ln2963">    if (has_mbyte) {</a>
<a name="ln2964">      kwlen += (*mb_ptr2len)(kwp + kwlen);</a>
<a name="ln2965">    } else {</a>
<a name="ln2966">      kwlen++;</a>
<a name="ln2967">    }</a>
<a name="ln2968">  } while (vim_iswordp_buf(kwp + kwlen, syn_buf));</a>
<a name="ln2969"> </a>
<a name="ln2970">  if (kwlen &gt; MAXKEYWLEN) {</a>
<a name="ln2971">    return 0;</a>
<a name="ln2972">  }</a>
<a name="ln2973"> </a>
<a name="ln2974">  // Must make a copy of the keyword, so we can add a NUL and make it</a>
<a name="ln2975">  // lowercase.</a>
<a name="ln2976">  char_u keyword[MAXKEYWLEN + 1];         // assume max. keyword len is 80</a>
<a name="ln2977">  STRLCPY(keyword, kwp, kwlen + 1);</a>
<a name="ln2978"> </a>
<a name="ln2979">  keyentry_T *kp = NULL;</a>
<a name="ln2980"> </a>
<a name="ln2981">  // matching case</a>
<a name="ln2982">  if (syn_block-&gt;b_keywtab.ht_used != 0) {</a>
<a name="ln2983">    kp = match_keyword(keyword, &amp;syn_block-&gt;b_keywtab, cur_si);</a>
<a name="ln2984">  }</a>
<a name="ln2985"> </a>
<a name="ln2986">  // ignoring case</a>
<a name="ln2987">  if (kp == NULL &amp;&amp; syn_block-&gt;b_keywtab_ic.ht_used != 0) {</a>
<a name="ln2988">    str_foldcase(kwp, kwlen, keyword, MAXKEYWLEN + 1);</a>
<a name="ln2989">    kp = match_keyword(keyword, &amp;syn_block-&gt;b_keywtab_ic, cur_si);</a>
<a name="ln2990">  }</a>
<a name="ln2991"> </a>
<a name="ln2992">  if (kp != NULL) {</a>
<a name="ln2993">    *endcolp = startcol + kwlen;</a>
<a name="ln2994">    *flagsp = kp-&gt;flags;</a>
<a name="ln2995">    *next_listp = kp-&gt;next_list;</a>
<a name="ln2996">    *ccharp = kp-&gt;k_char;</a>
<a name="ln2997">    return kp-&gt;k_syn.id;</a>
<a name="ln2998">  }</a>
<a name="ln2999"> </a>
<a name="ln3000">  return 0;</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">/// Find keywords that match.  There can be several with different</a>
<a name="ln3004">/// attributes.</a>
<a name="ln3005">/// When current_next_list is non-zero accept only that group, otherwise:</a>
<a name="ln3006">///  Accept a not-contained keyword at toplevel.</a>
<a name="ln3007">///  Accept a keyword at other levels only if it is in the contains list.</a>
<a name="ln3008">static keyentry_T *match_keyword(char_u *keyword, hashtab_T *ht,</a>
<a name="ln3009">                                 stateitem_T *cur_si)</a>
<a name="ln3010">{</a>
<a name="ln3011">  hashitem_T *hi = hash_find(ht, keyword);</a>
<a name="ln3012">  if (!HASHITEM_EMPTY(hi))</a>
<a name="ln3013">    for (keyentry_T *kp = HI2KE(hi); kp != NULL; kp = kp-&gt;ke_next) {</a>
<a name="ln3014">      if (current_next_list != 0</a>
<a name="ln3015">          ? in_id_list(NULL, current_next_list, &amp;kp-&gt;k_syn, 0)</a>
<a name="ln3016">          : (cur_si == NULL</a>
<a name="ln3017">            ? !(kp-&gt;flags &amp; HL_CONTAINED)</a>
<a name="ln3018">            : in_id_list(cur_si, cur_si-&gt;si_cont_list,</a>
<a name="ln3019">                         &amp;kp-&gt;k_syn, kp-&gt;flags &amp; HL_CONTAINED))) {</a>
<a name="ln3020">        return kp;</a>
<a name="ln3021">      }</a>
<a name="ln3022">    }</a>
<a name="ln3023">  return NULL;</a>
<a name="ln3024">}</a>
<a name="ln3025"> </a>
<a name="ln3026">/*</a>
<a name="ln3027"> * Handle &quot;:syntax conceal&quot; command.</a>
<a name="ln3028"> */</a>
<a name="ln3029">static void syn_cmd_conceal(exarg_T *eap, int syncing)</a>
<a name="ln3030">{</a>
<a name="ln3031">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3032">  char_u      *next;</a>
<a name="ln3033"> </a>
<a name="ln3034">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3035">  if (eap-&gt;skip)</a>
<a name="ln3036">    return;</a>
<a name="ln3037"> </a>
<a name="ln3038">  next = skiptowhite(arg);</a>
<a name="ln3039">  if (*arg == NUL) {</a>
<a name="ln3040">    if (curwin-&gt;w_s-&gt;b_syn_conceal) {</a>
<a name="ln3041">      MSG(_(&quot;syntax conceal on&quot;));</a>
<a name="ln3042">    } else {</a>
<a name="ln3043">      MSG(_(&quot;syntax conceal off&quot;));</a>
<a name="ln3044">    }</a>
<a name="ln3045">  } else if (STRNICMP(arg, &quot;on&quot;, 2) == 0 &amp;&amp; next - arg == 2) {</a>
<a name="ln3046">    curwin-&gt;w_s-&gt;b_syn_conceal = true;</a>
<a name="ln3047">  } else if (STRNICMP(arg, &quot;off&quot;, 3) == 0 &amp;&amp; next - arg == 3) {</a>
<a name="ln3048">    curwin-&gt;w_s-&gt;b_syn_conceal = false;</a>
<a name="ln3049">  } else {</a>
<a name="ln3050">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3051">  }</a>
<a name="ln3052">}</a>
<a name="ln3053"> </a>
<a name="ln3054">/*</a>
<a name="ln3055"> * Handle &quot;:syntax case&quot; command.</a>
<a name="ln3056"> */</a>
<a name="ln3057">static void syn_cmd_case(exarg_T *eap, int syncing)</a>
<a name="ln3058">{</a>
<a name="ln3059">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3060">  char_u      *next;</a>
<a name="ln3061"> </a>
<a name="ln3062">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3063">  if (eap-&gt;skip)</a>
<a name="ln3064">    return;</a>
<a name="ln3065"> </a>
<a name="ln3066">  next = skiptowhite(arg);</a>
<a name="ln3067">  if (*arg == NUL) {</a>
<a name="ln3068">    if (curwin-&gt;w_s-&gt;b_syn_ic) {</a>
<a name="ln3069">      MSG(_(&quot;syntax case ignore&quot;));</a>
<a name="ln3070">    } else {</a>
<a name="ln3071">      MSG(_(&quot;syntax case match&quot;));</a>
<a name="ln3072">    }</a>
<a name="ln3073">  } else if (STRNICMP(arg, &quot;match&quot;, 5) == 0 &amp;&amp; next - arg == 5) {</a>
<a name="ln3074">    curwin-&gt;w_s-&gt;b_syn_ic = false;</a>
<a name="ln3075">  } else if (STRNICMP(arg, &quot;ignore&quot;, 6) == 0 &amp;&amp; next - arg == 6) {</a>
<a name="ln3076">    curwin-&gt;w_s-&gt;b_syn_ic = true;</a>
<a name="ln3077">  } else {</a>
<a name="ln3078">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3079">  }</a>
<a name="ln3080">}</a>
<a name="ln3081"> </a>
<a name="ln3082">/// Handle &quot;:syntax foldlevel&quot; command.</a>
<a name="ln3083">static void syn_cmd_foldlevel(exarg_T *eap, int syncing)</a>
<a name="ln3084">{</a>
<a name="ln3085">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3086">  char_u *arg_end;</a>
<a name="ln3087"> </a>
<a name="ln3088">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3089">  if (eap-&gt;skip)</a>
<a name="ln3090">    return;</a>
<a name="ln3091"> </a>
<a name="ln3092">  if (*arg == NUL) {</a>
<a name="ln3093">    switch (curwin-&gt;w_s-&gt;b_syn_foldlevel) {</a>
<a name="ln3094">    case SYNFLD_START:   MSG(_(&quot;syntax foldlevel start&quot;));   break;</a>
<a name="ln3095">    case SYNFLD_MINIMUM: MSG(_(&quot;syntax foldlevel minimum&quot;)); break;</a>
<a name="ln3096">    default: break;</a>
<a name="ln3097">    }</a>
<a name="ln3098">    return;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">  arg_end = skiptowhite(arg);</a>
<a name="ln3102">  if (STRNICMP(arg, &quot;start&quot;, 5) == 0 &amp;&amp; arg_end - arg == 5) {</a>
<a name="ln3103">    curwin-&gt;w_s-&gt;b_syn_foldlevel = SYNFLD_START;</a>
<a name="ln3104">  } else if (STRNICMP(arg, &quot;minimum&quot;, 7) == 0 &amp;&amp; arg_end - arg == 7) {</a>
<a name="ln3105">    curwin-&gt;w_s-&gt;b_syn_foldlevel = SYNFLD_MINIMUM;</a>
<a name="ln3106">  } else {</a>
<a name="ln3107">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3108">    return;</a>
<a name="ln3109">  }</a>
<a name="ln3110"> </a>
<a name="ln3111">  arg = skipwhite(arg_end);</a>
<a name="ln3112">  if (*arg != NUL) {</a>
<a name="ln3113">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3114">  }</a>
<a name="ln3115">}</a>
<a name="ln3116"> </a>
<a name="ln3117">/*</a>
<a name="ln3118"> * Handle &quot;:syntax spell&quot; command.</a>
<a name="ln3119"> */</a>
<a name="ln3120">static void syn_cmd_spell(exarg_T *eap, int syncing)</a>
<a name="ln3121">{</a>
<a name="ln3122">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3123">  char_u      *next;</a>
<a name="ln3124"> </a>
<a name="ln3125">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3126">  if (eap-&gt;skip)</a>
<a name="ln3127">    return;</a>
<a name="ln3128"> </a>
<a name="ln3129">  next = skiptowhite(arg);</a>
<a name="ln3130">  if (*arg == NUL) {</a>
<a name="ln3131">    if (curwin-&gt;w_s-&gt;b_syn_spell == SYNSPL_TOP) {</a>
<a name="ln3132">      MSG(_(&quot;syntax spell toplevel&quot;));</a>
<a name="ln3133">    } else if (curwin-&gt;w_s-&gt;b_syn_spell == SYNSPL_NOTOP) {</a>
<a name="ln3134">      MSG(_(&quot;syntax spell notoplevel&quot;));</a>
<a name="ln3135">    } else {</a>
<a name="ln3136">      MSG(_(&quot;syntax spell default&quot;));</a>
<a name="ln3137">    }</a>
<a name="ln3138">  } else if (STRNICMP(arg, &quot;toplevel&quot;, 8) == 0 &amp;&amp; next - arg == 8) {</a>
<a name="ln3139">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_TOP;</a>
<a name="ln3140">  } else if (STRNICMP(arg, &quot;notoplevel&quot;, 10) == 0 &amp;&amp; next - arg == 10) {</a>
<a name="ln3141">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_NOTOP;</a>
<a name="ln3142">  } else if (STRNICMP(arg, &quot;default&quot;, 7) == 0 &amp;&amp; next - arg == 7) {</a>
<a name="ln3143">    curwin-&gt;w_s-&gt;b_syn_spell = SYNSPL_DEFAULT;</a>
<a name="ln3144">  } else {</a>
<a name="ln3145">    EMSG2(_(e_illegal_arg), arg);</a>
<a name="ln3146">    return;</a>
<a name="ln3147">  }</a>
<a name="ln3148"> </a>
<a name="ln3149">  // assume spell checking changed, force a redraw</a>
<a name="ln3150">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln3151">}</a>
<a name="ln3152"> </a>
<a name="ln3153">/// Handle &quot;:syntax iskeyword&quot; command.</a>
<a name="ln3154">static void syn_cmd_iskeyword(exarg_T *eap, int syncing)</a>
<a name="ln3155">{</a>
<a name="ln3156">  char_u *arg = eap-&gt;arg;</a>
<a name="ln3157">  char_u save_chartab[32];</a>
<a name="ln3158">  char_u *save_isk;</a>
<a name="ln3159"> </a>
<a name="ln3160">  if (eap-&gt;skip) {</a>
<a name="ln3161">    return;</a>
<a name="ln3162">  }</a>
<a name="ln3163"> </a>
<a name="ln3164">  arg = skipwhite(arg);</a>
<a name="ln3165">  if (*arg == NUL) {</a>
<a name="ln3166">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln3167">    if (curwin-&gt;w_s-&gt;b_syn_isk != empty_option) {</a>
<a name="ln3168">      MSG_PUTS(_(&quot;syntax iskeyword &quot;));</a>
<a name="ln3169">      msg_outtrans(curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3170">    } else {</a>
<a name="ln3171">      msg_outtrans((char_u *)_(&quot;syntax iskeyword not set&quot;));</a>
<a name="ln3172">    }</a>
<a name="ln3173">  } else {</a>
<a name="ln3174">    if (STRNICMP(arg, &quot;clear&quot;, 5) == 0) {</a>
<a name="ln3175">      memmove(curwin-&gt;w_s-&gt;b_syn_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3176">      clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3177">    } else {</a>
<a name="ln3178">      memmove(save_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3179">      save_isk = curbuf-&gt;b_p_isk;</a>
<a name="ln3180">      curbuf-&gt;b_p_isk = vim_strsave(arg);</a>
<a name="ln3181"> </a>
<a name="ln3182">      buf_init_chartab(curbuf, false);</a>
<a name="ln3183">      memmove(curwin-&gt;w_s-&gt;b_syn_chartab, curbuf-&gt;b_chartab, (size_t)32);</a>
<a name="ln3184">      memmove(curbuf-&gt;b_chartab, save_chartab, (size_t)32);</a>
<a name="ln3185">      clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3186">      curwin-&gt;w_s-&gt;b_syn_isk = curbuf-&gt;b_p_isk;</a>
<a name="ln3187">      curbuf-&gt;b_p_isk = save_isk;</a>
<a name="ln3188">    }</a>
<a name="ln3189">  }</a>
<a name="ln3190">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln3191">}</a>
<a name="ln3192"> </a>
<a name="ln3193">/*</a>
<a name="ln3194"> * Clear all syntax info for one buffer.</a>
<a name="ln3195"> */</a>
<a name="ln3196">void syntax_clear(synblock_T *block)</a>
<a name="ln3197">{</a>
<a name="ln3198">  block-&gt;b_syn_error = false;           // clear previous error</a>
<a name="ln3199">  block-&gt;b_syn_slow = false;            // clear previous timeout</a>
<a name="ln3200">  block-&gt;b_syn_ic = false;              // Use case, by default</a>
<a name="ln3201">  block-&gt;b_syn_foldlevel = SYNFLD_START;</a>
<a name="ln3202">  block-&gt;b_syn_spell = SYNSPL_DEFAULT;  // default spell checking</a>
<a name="ln3203">  block-&gt;b_syn_containedin = false;</a>
<a name="ln3204">  block-&gt;b_syn_conceal = false;</a>
<a name="ln3205"> </a>
<a name="ln3206">  /* free the keywords */</a>
<a name="ln3207">  clear_keywtab(&amp;block-&gt;b_keywtab);</a>
<a name="ln3208">  clear_keywtab(&amp;block-&gt;b_keywtab_ic);</a>
<a name="ln3209"> </a>
<a name="ln3210">  /* free the syntax patterns */</a>
<a name="ln3211">  for (int i = block-&gt;b_syn_patterns.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3212">    syn_clear_pattern(block, i);</a>
<a name="ln3213">  }</a>
<a name="ln3214">  ga_clear(&amp;block-&gt;b_syn_patterns);</a>
<a name="ln3215"> </a>
<a name="ln3216">  /* free the syntax clusters */</a>
<a name="ln3217">  for (int i = block-&gt;b_syn_clusters.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3218">    syn_clear_cluster(block, i);</a>
<a name="ln3219">  }</a>
<a name="ln3220">  ga_clear(&amp;block-&gt;b_syn_clusters);</a>
<a name="ln3221">  block-&gt;b_spell_cluster_id = 0;</a>
<a name="ln3222">  block-&gt;b_nospell_cluster_id = 0;</a>
<a name="ln3223"> </a>
<a name="ln3224">  block-&gt;b_syn_sync_flags = 0;</a>
<a name="ln3225">  block-&gt;b_syn_sync_minlines = 0;</a>
<a name="ln3226">  block-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln3227">  block-&gt;b_syn_sync_linebreaks = 0;</a>
<a name="ln3228"> </a>
<a name="ln3229">  vim_regfree(block-&gt;b_syn_linecont_prog);</a>
<a name="ln3230">  block-&gt;b_syn_linecont_prog = NULL;</a>
<a name="ln3231">  XFREE_CLEAR(block-&gt;b_syn_linecont_pat);</a>
<a name="ln3232">  block-&gt;b_syn_folditems = 0;</a>
<a name="ln3233">  clear_string_option(&amp;block-&gt;b_syn_isk);</a>
<a name="ln3234"> </a>
<a name="ln3235">  /* free the stored states */</a>
<a name="ln3236">  syn_stack_free_all(block);</a>
<a name="ln3237">  invalidate_current_state();</a>
<a name="ln3238"> </a>
<a name="ln3239">  /* Reset the counter for &quot;:syn include&quot; */</a>
<a name="ln3240">  running_syn_inc_tag = 0;</a>
<a name="ln3241">}</a>
<a name="ln3242"> </a>
<a name="ln3243">/*</a>
<a name="ln3244"> * Get rid of ownsyntax for window &quot;wp&quot;.</a>
<a name="ln3245"> */</a>
<a name="ln3246">void reset_synblock(win_T *wp)</a>
<a name="ln3247">{</a>
<a name="ln3248">  if (wp-&gt;w_s != &amp;wp-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln3249">    syntax_clear(wp-&gt;w_s);</a>
<a name="ln3250">    xfree(wp-&gt;w_s);</a>
<a name="ln3251">    wp-&gt;w_s = &amp;wp-&gt;w_buffer-&gt;b_s;</a>
<a name="ln3252">  }</a>
<a name="ln3253">}</a>
<a name="ln3254"> </a>
<a name="ln3255">/*</a>
<a name="ln3256"> * Clear syncing info for one buffer.</a>
<a name="ln3257"> */</a>
<a name="ln3258">static void syntax_sync_clear(void)</a>
<a name="ln3259">{</a>
<a name="ln3260">  /* free the syntax patterns */</a>
<a name="ln3261">  for (int i = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --i &gt;= 0; ) {</a>
<a name="ln3262">    if (SYN_ITEMS(curwin-&gt;w_s)[i].sp_syncing) {</a>
<a name="ln3263">      syn_remove_pattern(curwin-&gt;w_s, i);</a>
<a name="ln3264">    }</a>
<a name="ln3265">  }</a>
<a name="ln3266"> </a>
<a name="ln3267">  curwin-&gt;w_s-&gt;b_syn_sync_flags = 0;</a>
<a name="ln3268">  curwin-&gt;w_s-&gt;b_syn_sync_minlines = 0;</a>
<a name="ln3269">  curwin-&gt;w_s-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln3270">  curwin-&gt;w_s-&gt;b_syn_sync_linebreaks = 0;</a>
<a name="ln3271"> </a>
<a name="ln3272">  vim_regfree(curwin-&gt;w_s-&gt;b_syn_linecont_prog);</a>
<a name="ln3273">  curwin-&gt;w_s-&gt;b_syn_linecont_prog = NULL;</a>
<a name="ln3274">  XFREE_CLEAR(curwin-&gt;w_s-&gt;b_syn_linecont_pat);</a>
<a name="ln3275">  clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln3276"> </a>
<a name="ln3277">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln3278">}</a>
<a name="ln3279"> </a>
<a name="ln3280">/*</a>
<a name="ln3281"> * Remove one pattern from the buffer's pattern list.</a>
<a name="ln3282"> */</a>
<a name="ln3283">static void syn_remove_pattern(synblock_T *block, int idx)</a>
<a name="ln3284">{</a>
<a name="ln3285">  synpat_T    *spp;</a>
<a name="ln3286"> </a>
<a name="ln3287">  spp = &amp;(SYN_ITEMS(block)[idx]);</a>
<a name="ln3288">  if (spp-&gt;sp_flags &amp; HL_FOLD)</a>
<a name="ln3289">    --block-&gt;b_syn_folditems;</a>
<a name="ln3290">  syn_clear_pattern(block, idx);</a>
<a name="ln3291">  memmove(spp, spp + 1,</a>
<a name="ln3292">      sizeof(synpat_T) * (block-&gt;b_syn_patterns.ga_len - idx - 1));</a>
<a name="ln3293">  --block-&gt;b_syn_patterns.ga_len;</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296">/*</a>
<a name="ln3297"> * Clear and free one syntax pattern.  When clearing all, must be called from</a>
<a name="ln3298"> * last to first!</a>
<a name="ln3299"> */</a>
<a name="ln3300">static void syn_clear_pattern(synblock_T *block, int i)</a>
<a name="ln3301">{</a>
<a name="ln3302">  xfree(SYN_ITEMS(block)[i].sp_pattern);</a>
<a name="ln3303">  vim_regfree(SYN_ITEMS(block)[i].sp_prog);</a>
<a name="ln3304">  /* Only free sp_cont_list and sp_next_list of first start pattern */</a>
<a name="ln3305">  if (i == 0 || SYN_ITEMS(block)[i - 1].sp_type != SPTYPE_START) {</a>
<a name="ln3306">    xfree(SYN_ITEMS(block)[i].sp_cont_list);</a>
<a name="ln3307">    xfree(SYN_ITEMS(block)[i].sp_next_list);</a>
<a name="ln3308">    xfree(SYN_ITEMS(block)[i].sp_syn.cont_in_list);</a>
<a name="ln3309">  }</a>
<a name="ln3310">}</a>
<a name="ln3311"> </a>
<a name="ln3312">/*</a>
<a name="ln3313"> * Clear and free one syntax cluster.</a>
<a name="ln3314"> */</a>
<a name="ln3315">static void syn_clear_cluster(synblock_T *block, int i)</a>
<a name="ln3316">{</a>
<a name="ln3317">  xfree(SYN_CLSTR(block)[i].scl_name);</a>
<a name="ln3318">  xfree(SYN_CLSTR(block)[i].scl_name_u);</a>
<a name="ln3319">  xfree(SYN_CLSTR(block)[i].scl_list);</a>
<a name="ln3320">}</a>
<a name="ln3321"> </a>
<a name="ln3322">/*</a>
<a name="ln3323"> * Handle &quot;:syntax clear&quot; command.</a>
<a name="ln3324"> */</a>
<a name="ln3325">static void syn_cmd_clear(exarg_T *eap, int syncing)</a>
<a name="ln3326">{</a>
<a name="ln3327">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3328">  char_u      *arg_end;</a>
<a name="ln3329">  int id;</a>
<a name="ln3330"> </a>
<a name="ln3331">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3332">  if (eap-&gt;skip)</a>
<a name="ln3333">    return;</a>
<a name="ln3334"> </a>
<a name="ln3335">  /*</a>
<a name="ln3336">   * We have to disable this within &quot;:syn include @group filename&quot;,</a>
<a name="ln3337">   * because otherwise @group would get deleted.</a>
<a name="ln3338">   * Only required for Vim 5.x syntax files, 6.0 ones don't contain &quot;:syn</a>
<a name="ln3339">   * clear&quot;.</a>
<a name="ln3340">   */</a>
<a name="ln3341">  if (curwin-&gt;w_s-&gt;b_syn_topgrp != 0)</a>
<a name="ln3342">    return;</a>
<a name="ln3343"> </a>
<a name="ln3344">  if (ends_excmd(*arg)) {</a>
<a name="ln3345">    /*</a>
<a name="ln3346">     * No argument: Clear all syntax items.</a>
<a name="ln3347">     */</a>
<a name="ln3348">    if (syncing)</a>
<a name="ln3349">      syntax_sync_clear();</a>
<a name="ln3350">    else {</a>
<a name="ln3351">      syntax_clear(curwin-&gt;w_s);</a>
<a name="ln3352">      if (curwin-&gt;w_s == &amp;curwin-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln3353">        do_unlet(S_LEN(&quot;b:current_syntax&quot;), true);</a>
<a name="ln3354">      }</a>
<a name="ln3355">      do_unlet(S_LEN(&quot;w:current_syntax&quot;), true);</a>
<a name="ln3356">    }</a>
<a name="ln3357">  } else {</a>
<a name="ln3358">    /*</a>
<a name="ln3359">     * Clear the group IDs that are in the argument.</a>
<a name="ln3360">     */</a>
<a name="ln3361">    while (!ends_excmd(*arg)) {</a>
<a name="ln3362">      arg_end = skiptowhite(arg);</a>
<a name="ln3363">      if (*arg == '@') {</a>
<a name="ln3364">        id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));</a>
<a name="ln3365">        if (id == 0) {</a>
<a name="ln3366">          EMSG2(_(&quot;E391: No such syntax cluster: %s&quot;), arg);</a>
<a name="ln3367">          break;</a>
<a name="ln3368">        } else {</a>
<a name="ln3369">          // We can't physically delete a cluster without changing</a>
<a name="ln3370">          // the IDs of other clusters, so we do the next best thing</a>
<a name="ln3371">          // and make it empty.</a>
<a name="ln3372">          int scl_id = id - SYNID_CLUSTER;</a>
<a name="ln3373"> </a>
<a name="ln3374">          XFREE_CLEAR(SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_list);</a>
<a name="ln3375">        }</a>
<a name="ln3376">      } else {</a>
<a name="ln3377">        id = syn_namen2id(arg, (int)(arg_end - arg));</a>
<a name="ln3378">        if (id == 0) {</a>
<a name="ln3379">          EMSG2(_(e_nogroup), arg);</a>
<a name="ln3380">          break;</a>
<a name="ln3381">        } else</a>
<a name="ln3382">          syn_clear_one(id, syncing);</a>
<a name="ln3383">      }</a>
<a name="ln3384">      arg = skipwhite(arg_end);</a>
<a name="ln3385">    }</a>
<a name="ln3386">  }</a>
<a name="ln3387">  redraw_curbuf_later(SOME_VALID);</a>
<a name="ln3388">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln3389">}</a>
<a name="ln3390"> </a>
<a name="ln3391">/*</a>
<a name="ln3392"> * Clear one syntax group for the current buffer.</a>
<a name="ln3393"> */</a>
<a name="ln3394">static void syn_clear_one(const int id, const bool syncing)</a>
<a name="ln3395">{</a>
<a name="ln3396">  synpat_T    *spp;</a>
<a name="ln3397"> </a>
<a name="ln3398">  /* Clear keywords only when not &quot;:syn sync clear group-name&quot; */</a>
<a name="ln3399">  if (!syncing) {</a>
<a name="ln3400">    syn_clear_keyword(id, &amp;curwin-&gt;w_s-&gt;b_keywtab);</a>
<a name="ln3401">    syn_clear_keyword(id, &amp;curwin-&gt;w_s-&gt;b_keywtab_ic);</a>
<a name="ln3402">  }</a>
<a name="ln3403"> </a>
<a name="ln3404">  /* clear the patterns for &quot;id&quot; */</a>
<a name="ln3405">  for (int idx = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --idx &gt;= 0; ) {</a>
<a name="ln3406">    spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln3407">    if (spp-&gt;sp_syn.id != id || spp-&gt;sp_syncing != syncing)</a>
<a name="ln3408">      continue;</a>
<a name="ln3409">    syn_remove_pattern(curwin-&gt;w_s, idx);</a>
<a name="ln3410">  }</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413">/*</a>
<a name="ln3414"> * Handle &quot;:syntax on&quot; command.</a>
<a name="ln3415"> */</a>
<a name="ln3416">static void syn_cmd_on(exarg_T *eap, int syncing)</a>
<a name="ln3417">{</a>
<a name="ln3418">  syn_cmd_onoff(eap, &quot;syntax&quot;);</a>
<a name="ln3419">}</a>
<a name="ln3420"> </a>
<a name="ln3421">/*</a>
<a name="ln3422"> * Handle &quot;:syntax enable&quot; command.</a>
<a name="ln3423"> */</a>
<a name="ln3424">static void syn_cmd_enable(exarg_T *eap, int syncing)</a>
<a name="ln3425">{</a>
<a name="ln3426">  set_internal_string_var((char_u *)&quot;syntax_cmd&quot;, (char_u *)&quot;enable&quot;);</a>
<a name="ln3427">  syn_cmd_onoff(eap, &quot;syntax&quot;);</a>
<a name="ln3428">  do_unlet(S_LEN(&quot;g:syntax_cmd&quot;), true);</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431">/*</a>
<a name="ln3432"> * Handle &quot;:syntax reset&quot; command.</a>
<a name="ln3433"> * It actually resets highlighting, not syntax.</a>
<a name="ln3434"> */</a>
<a name="ln3435">static void syn_cmd_reset(exarg_T *eap, int syncing)</a>
<a name="ln3436">{</a>
<a name="ln3437">  eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln3438">  if (!eap-&gt;skip) {</a>
<a name="ln3439">    set_internal_string_var((char_u *)&quot;syntax_cmd&quot;, (char_u *)&quot;reset&quot;);</a>
<a name="ln3440">    do_cmdline_cmd(&quot;runtime! syntax/syncolor.vim&quot;);</a>
<a name="ln3441">    do_unlet(S_LEN(&quot;g:syntax_cmd&quot;), true);</a>
<a name="ln3442">  }</a>
<a name="ln3443">}</a>
<a name="ln3444"> </a>
<a name="ln3445">/*</a>
<a name="ln3446"> * Handle &quot;:syntax manual&quot; command.</a>
<a name="ln3447"> */</a>
<a name="ln3448">static void syn_cmd_manual(exarg_T *eap, int syncing)</a>
<a name="ln3449">{</a>
<a name="ln3450">  syn_cmd_onoff(eap, &quot;manual&quot;);</a>
<a name="ln3451">}</a>
<a name="ln3452"> </a>
<a name="ln3453">/*</a>
<a name="ln3454"> * Handle &quot;:syntax off&quot; command.</a>
<a name="ln3455"> */</a>
<a name="ln3456">static void syn_cmd_off(exarg_T *eap, int syncing)</a>
<a name="ln3457">{</a>
<a name="ln3458">  syn_cmd_onoff(eap, &quot;nosyntax&quot;);</a>
<a name="ln3459">}</a>
<a name="ln3460"> </a>
<a name="ln3461">static void syn_cmd_onoff(exarg_T *eap, char *name)</a>
<a name="ln3462">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3463">{</a>
<a name="ln3464">  eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln3465">  if (!eap-&gt;skip) {</a>
<a name="ln3466">    did_syntax_onoff = true;</a>
<a name="ln3467">    char buf[100];</a>
<a name="ln3468">    memcpy(buf, &quot;so &quot;, 4);</a>
<a name="ln3469">    vim_snprintf(buf + 3, sizeof(buf) - 3, SYNTAX_FNAME, name);</a>
<a name="ln3470">    do_cmdline_cmd(buf);</a>
<a name="ln3471">  }</a>
<a name="ln3472">}</a>
<a name="ln3473"> </a>
<a name="ln3474">void syn_maybe_on(void)</a>
<a name="ln3475">{</a>
<a name="ln3476">  if (!did_syntax_onoff) {</a>
<a name="ln3477">    exarg_T ea;</a>
<a name="ln3478">    ea.arg = (char_u *)&quot;&quot;;</a>
<a name="ln3479">    ea.skip = false;</a>
<a name="ln3480">    syn_cmd_onoff(&amp;ea, &quot;syntax&quot;);</a>
<a name="ln3481">  }</a>
<a name="ln3482">}</a>
<a name="ln3483"> </a>
<a name="ln3484">/*</a>
<a name="ln3485"> * Handle &quot;:syntax [list]&quot; command: list current syntax words.</a>
<a name="ln3486"> */</a>
<a name="ln3487">static void</a>
<a name="ln3488">syn_cmd_list(</a>
<a name="ln3489">    exarg_T *eap,</a>
<a name="ln3490">    int syncing                        /* when TRUE: list syncing items */</a>
<a name="ln3491">)</a>
<a name="ln3492">{</a>
<a name="ln3493">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln3494">  char_u      *arg_end;</a>
<a name="ln3495"> </a>
<a name="ln3496">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln3497">  if (eap-&gt;skip)</a>
<a name="ln3498">    return;</a>
<a name="ln3499"> </a>
<a name="ln3500">  if (!syntax_present(curwin)) {</a>
<a name="ln3501">    MSG(_(msg_no_items));</a>
<a name="ln3502">    return;</a>
<a name="ln3503">  }</a>
<a name="ln3504"> </a>
<a name="ln3505">  if (syncing) {</a>
<a name="ln3506">    if (curwin-&gt;w_s-&gt;b_syn_sync_flags &amp; SF_CCOMMENT) {</a>
<a name="ln3507">      MSG_PUTS(_(&quot;syncing on C-style comments&quot;));</a>
<a name="ln3508">      syn_lines_msg();</a>
<a name="ln3509">      syn_match_msg();</a>
<a name="ln3510">      return;</a>
<a name="ln3511">    } else if (!(curwin-&gt;w_s-&gt;b_syn_sync_flags &amp; SF_MATCH))   {</a>
<a name="ln3512">      if (curwin-&gt;w_s-&gt;b_syn_sync_minlines == 0)</a>
<a name="ln3513">        MSG_PUTS(_(&quot;no syncing&quot;));</a>
<a name="ln3514">      else {</a>
<a name="ln3515">        MSG_PUTS(_(&quot;syncing starts &quot;));</a>
<a name="ln3516">        msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_minlines);</a>
<a name="ln3517">        MSG_PUTS(_(&quot; lines before top line&quot;));</a>
<a name="ln3518">        syn_match_msg();</a>
<a name="ln3519">      }</a>
<a name="ln3520">      return;</a>
<a name="ln3521">    }</a>
<a name="ln3522">    MSG_PUTS_TITLE(_(&quot;\n--- Syntax sync items ---&quot;));</a>
<a name="ln3523">    if (curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0</a>
<a name="ln3524">        || curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0</a>
<a name="ln3525">        || curwin-&gt;w_s-&gt;b_syn_sync_linebreaks &gt; 0) {</a>
<a name="ln3526">      MSG_PUTS(_(&quot;\nsyncing on items&quot;));</a>
<a name="ln3527">      syn_lines_msg();</a>
<a name="ln3528">      syn_match_msg();</a>
<a name="ln3529">    }</a>
<a name="ln3530">  } else</a>
<a name="ln3531">    MSG_PUTS_TITLE(_(&quot;\n--- Syntax items ---&quot;));</a>
<a name="ln3532">  if (ends_excmd(*arg)) {</a>
<a name="ln3533">    /*</a>
<a name="ln3534">     * No argument: List all group IDs and all syntax clusters.</a>
<a name="ln3535">     */</a>
<a name="ln3536">    for (int id = 1; id &lt;= highlight_ga.ga_len &amp;&amp; !got_int; id++) {</a>
<a name="ln3537">      syn_list_one(id, syncing, false);</a>
<a name="ln3538">    }</a>
<a name="ln3539">    for (int id = 0; id &lt; curwin-&gt;w_s-&gt;b_syn_clusters.ga_len &amp;&amp; !got_int; ++id) {</a>
<a name="ln3540">      syn_list_cluster(id);</a>
<a name="ln3541">    }</a>
<a name="ln3542">  } else {</a>
<a name="ln3543">    /*</a>
<a name="ln3544">     * List the group IDs and syntax clusters that are in the argument.</a>
<a name="ln3545">     */</a>
<a name="ln3546">    while (!ends_excmd(*arg) &amp;&amp; !got_int) {</a>
<a name="ln3547">      arg_end = skiptowhite(arg);</a>
<a name="ln3548">      if (*arg == '@') {</a>
<a name="ln3549">        int id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));</a>
<a name="ln3550">        if (id == 0)</a>
<a name="ln3551">          EMSG2(_(&quot;E392: No such syntax cluster: %s&quot;), arg);</a>
<a name="ln3552">        else</a>
<a name="ln3553">          syn_list_cluster(id - SYNID_CLUSTER);</a>
<a name="ln3554">      } else {</a>
<a name="ln3555">        int id = syn_namen2id(arg, (int)(arg_end - arg));</a>
<a name="ln3556">        if (id == 0) {</a>
<a name="ln3557">          EMSG2(_(e_nogroup), arg);</a>
<a name="ln3558">        } else {</a>
<a name="ln3559">          syn_list_one(id, syncing, true);</a>
<a name="ln3560">        }</a>
<a name="ln3561">      }</a>
<a name="ln3562">      arg = skipwhite(arg_end);</a>
<a name="ln3563">    }</a>
<a name="ln3564">  }</a>
<a name="ln3565">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln3566">}</a>
<a name="ln3567"> </a>
<a name="ln3568">static void syn_lines_msg(void)</a>
<a name="ln3569">{</a>
<a name="ln3570">  if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0</a>
<a name="ln3571">      || curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0) {</a>
<a name="ln3572">    MSG_PUTS(&quot;; &quot;);</a>
<a name="ln3573">    if (curwin-&gt;w_s-&gt;b_syn_sync_minlines &gt; 0) {</a>
<a name="ln3574">      MSG_PUTS(_(&quot;minimal &quot;));</a>
<a name="ln3575">      msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_minlines);</a>
<a name="ln3576">      if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines)</a>
<a name="ln3577">        MSG_PUTS(&quot;, &quot;);</a>
<a name="ln3578">    }</a>
<a name="ln3579">    if (curwin-&gt;w_s-&gt;b_syn_sync_maxlines &gt; 0) {</a>
<a name="ln3580">      MSG_PUTS(_(&quot;maximal &quot;));</a>
<a name="ln3581">      msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_maxlines);</a>
<a name="ln3582">    }</a>
<a name="ln3583">    MSG_PUTS(_(&quot; lines before top line&quot;));</a>
<a name="ln3584">  }</a>
<a name="ln3585">}</a>
<a name="ln3586"> </a>
<a name="ln3587">static void syn_match_msg(void)</a>
<a name="ln3588">{</a>
<a name="ln3589">  if (curwin-&gt;w_s-&gt;b_syn_sync_linebreaks &gt; 0) {</a>
<a name="ln3590">    MSG_PUTS(_(&quot;; match &quot;));</a>
<a name="ln3591">    msg_outnum(curwin-&gt;w_s-&gt;b_syn_sync_linebreaks);</a>
<a name="ln3592">    MSG_PUTS(_(&quot; line breaks&quot;));</a>
<a name="ln3593">  }</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596">static int last_matchgroup;</a>
<a name="ln3597"> </a>
<a name="ln3598"> </a>
<a name="ln3599">/*</a>
<a name="ln3600"> * List one syntax item, for &quot;:syntax&quot; or &quot;syntax list syntax_name&quot;.</a>
<a name="ln3601"> */</a>
<a name="ln3602">static void</a>
<a name="ln3603">syn_list_one(</a>
<a name="ln3604">    const int id,</a>
<a name="ln3605">    const bool syncing,                 // when true: list syncing items</a>
<a name="ln3606">    const bool link_only                // when true; list link-only too</a>
<a name="ln3607">)</a>
<a name="ln3608">{</a>
<a name="ln3609">  bool did_header = false;</a>
<a name="ln3610">  static struct name_list namelist1[] =</a>
<a name="ln3611">  {</a>
<a name="ln3612">    {HL_DISPLAY, &quot;display&quot;},</a>
<a name="ln3613">    {HL_CONTAINED, &quot;contained&quot;},</a>
<a name="ln3614">    {HL_ONELINE, &quot;oneline&quot;},</a>
<a name="ln3615">    {HL_KEEPEND, &quot;keepend&quot;},</a>
<a name="ln3616">    {HL_EXTEND, &quot;extend&quot;},</a>
<a name="ln3617">    {HL_EXCLUDENL, &quot;excludenl&quot;},</a>
<a name="ln3618">    {HL_TRANSP, &quot;transparent&quot;},</a>
<a name="ln3619">    {HL_FOLD, &quot;fold&quot;},</a>
<a name="ln3620">    {HL_CONCEAL, &quot;conceal&quot;},</a>
<a name="ln3621">    {HL_CONCEALENDS, &quot;concealends&quot;},</a>
<a name="ln3622">    {0, NULL}</a>
<a name="ln3623">  };</a>
<a name="ln3624">  static struct name_list namelist2[] =</a>
<a name="ln3625">  {</a>
<a name="ln3626">    {HL_SKIPWHITE, &quot;skipwhite&quot;},</a>
<a name="ln3627">    {HL_SKIPNL, &quot;skipnl&quot;},</a>
<a name="ln3628">    {HL_SKIPEMPTY, &quot;skipempty&quot;},</a>
<a name="ln3629">    {0, NULL}</a>
<a name="ln3630">  };</a>
<a name="ln3631"> </a>
<a name="ln3632">  const int attr = HL_ATTR(HLF_D);      // highlight like directories</a>
<a name="ln3633"> </a>
<a name="ln3634">  // list the keywords for &quot;id&quot;</a>
<a name="ln3635">  if (!syncing) {</a>
<a name="ln3636">    did_header = syn_list_keywords(id, &amp;curwin-&gt;w_s-&gt;b_keywtab, false, attr);</a>
<a name="ln3637">    did_header = syn_list_keywords(id, &amp;curwin-&gt;w_s-&gt;b_keywtab_ic,</a>
<a name="ln3638">                                   did_header, attr);</a>
<a name="ln3639">  }</a>
<a name="ln3640"> </a>
<a name="ln3641">  // list the patterns for &quot;id&quot;</a>
<a name="ln3642">  for (int idx = 0;</a>
<a name="ln3643">       idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len &amp;&amp; !got_int;</a>
<a name="ln3644">       idx++) {</a>
<a name="ln3645">    const synpat_T *const spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln3646">    if (spp-&gt;sp_syn.id != id || spp-&gt;sp_syncing != syncing) {</a>
<a name="ln3647">      continue;</a>
<a name="ln3648">    }</a>
<a name="ln3649"> </a>
<a name="ln3650">    (void)syn_list_header(did_header, 0, id, true);</a>
<a name="ln3651">    did_header = true;</a>
<a name="ln3652">    last_matchgroup = 0;</a>
<a name="ln3653">    if (spp-&gt;sp_type == SPTYPE_MATCH) {</a>
<a name="ln3654">      put_pattern(&quot;match&quot;, ' ', spp, attr);</a>
<a name="ln3655">      msg_putchar(' ');</a>
<a name="ln3656">    } else if (spp-&gt;sp_type == SPTYPE_START)   {</a>
<a name="ln3657">      while (SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_START)</a>
<a name="ln3658">        put_pattern(&quot;start&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3659">      if (SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_SKIP)</a>
<a name="ln3660">        put_pattern(&quot;skip&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3661">      while (idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len</a>
<a name="ln3662">             &amp;&amp; SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type == SPTYPE_END)</a>
<a name="ln3663">        put_pattern(&quot;end&quot;, '=', &amp;SYN_ITEMS(curwin-&gt;w_s)[idx++], attr);</a>
<a name="ln3664">      --idx;</a>
<a name="ln3665">      msg_putchar(' ');</a>
<a name="ln3666">    }</a>
<a name="ln3667">    syn_list_flags(namelist1, spp-&gt;sp_flags, attr);</a>
<a name="ln3668"> </a>
<a name="ln3669">    if (spp-&gt;sp_cont_list != NULL) {</a>
<a name="ln3670">      put_id_list(&quot;contains&quot;, spp-&gt;sp_cont_list, attr);</a>
<a name="ln3671">    }</a>
<a name="ln3672"> </a>
<a name="ln3673">    if (spp-&gt;sp_syn.cont_in_list != NULL) {</a>
<a name="ln3674">      put_id_list(&quot;containedin&quot;, spp-&gt;sp_syn.cont_in_list, attr);</a>
<a name="ln3675">    }</a>
<a name="ln3676"> </a>
<a name="ln3677">    if (spp-&gt;sp_next_list != NULL) {</a>
<a name="ln3678">      put_id_list(&quot;nextgroup&quot;, spp-&gt;sp_next_list, attr);</a>
<a name="ln3679">      syn_list_flags(namelist2, spp-&gt;sp_flags, attr);</a>
<a name="ln3680">    }</a>
<a name="ln3681">    if (spp-&gt;sp_flags &amp; (HL_SYNC_HERE|HL_SYNC_THERE)) {</a>
<a name="ln3682">      if (spp-&gt;sp_flags &amp; HL_SYNC_HERE) {</a>
<a name="ln3683">        msg_puts_attr(&quot;grouphere&quot;, attr);</a>
<a name="ln3684">      } else {</a>
<a name="ln3685">        msg_puts_attr(&quot;groupthere&quot;, attr);</a>
<a name="ln3686">      }</a>
<a name="ln3687">      msg_putchar(' ');</a>
<a name="ln3688">      if (spp-&gt;sp_sync_idx &gt;= 0)</a>
<a name="ln3689">        msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin-&gt;w_s)</a>
<a name="ln3690">                                [spp-&gt;sp_sync_idx].sp_syn.id - 1].sg_name);</a>
<a name="ln3691">      else</a>
<a name="ln3692">        MSG_PUTS(&quot;NONE&quot;);</a>
<a name="ln3693">      msg_putchar(' ');</a>
<a name="ln3694">    }</a>
<a name="ln3695">  }</a>
<a name="ln3696"> </a>
<a name="ln3697">  /* list the link, if there is one */</a>
<a name="ln3698">  if (HL_TABLE()[id - 1].sg_link &amp;&amp; (did_header || link_only) &amp;&amp; !got_int) {</a>
<a name="ln3699">    (void)syn_list_header(did_header, 0, id, true);</a>
<a name="ln3700">    msg_puts_attr(&quot;links to&quot;, attr);</a>
<a name="ln3701">    msg_putchar(' ');</a>
<a name="ln3702">    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);</a>
<a name="ln3703">  }</a>
<a name="ln3704">}</a>
<a name="ln3705"> </a>
<a name="ln3706">static void syn_list_flags(struct name_list *nlist, int flags, int attr)</a>
<a name="ln3707">{</a>
<a name="ln3708">  int i;</a>
<a name="ln3709"> </a>
<a name="ln3710">  for (i = 0; nlist[i].flag != 0; ++i)</a>
<a name="ln3711">    if (flags &amp; nlist[i].flag) {</a>
<a name="ln3712">      msg_puts_attr(nlist[i].name, attr);</a>
<a name="ln3713">      msg_putchar(' ');</a>
<a name="ln3714">    }</a>
<a name="ln3715">}</a>
<a name="ln3716"> </a>
<a name="ln3717">/*</a>
<a name="ln3718"> * List one syntax cluster, for &quot;:syntax&quot; or &quot;syntax list syntax_name&quot;.</a>
<a name="ln3719"> */</a>
<a name="ln3720">static void syn_list_cluster(int id)</a>
<a name="ln3721">{</a>
<a name="ln3722">  int endcol = 15;</a>
<a name="ln3723"> </a>
<a name="ln3724">  /* slight hack:  roughly duplicate the guts of syn_list_header() */</a>
<a name="ln3725">  msg_putchar('\n');</a>
<a name="ln3726">  msg_outtrans(SYN_CLSTR(curwin-&gt;w_s)[id].scl_name);</a>
<a name="ln3727"> </a>
<a name="ln3728">  if (msg_col &gt;= endcol)        /* output at least one space */</a>
<a name="ln3729">    endcol = msg_col + 1;</a>
<a name="ln3730">  if (Columns &lt;= endcol)        /* avoid hang for tiny window */</a>
<a name="ln3731">    endcol = Columns - 1;</a>
<a name="ln3732"> </a>
<a name="ln3733">  msg_advance(endcol);</a>
<a name="ln3734">  if (SYN_CLSTR(curwin-&gt;w_s)[id].scl_list != NULL) {</a>
<a name="ln3735">    put_id_list(&quot;cluster&quot;, SYN_CLSTR(curwin-&gt;w_s)[id].scl_list, HL_ATTR(HLF_D));</a>
<a name="ln3736">  } else {</a>
<a name="ln3737">    msg_puts_attr(&quot;cluster&quot;, HL_ATTR(HLF_D));</a>
<a name="ln3738">    msg_puts(&quot;=NONE&quot;);</a>
<a name="ln3739">  }</a>
<a name="ln3740">}</a>
<a name="ln3741"> </a>
<a name="ln3742">static void put_id_list(const char *const name,</a>
<a name="ln3743">                        const int16_t *const list,</a>
<a name="ln3744">                        const int attr)</a>
<a name="ln3745">{</a>
<a name="ln3746">  msg_puts_attr(name, attr);</a>
<a name="ln3747">  msg_putchar('=');</a>
<a name="ln3748">  for (const int16_t *p = list; *p; p++) {</a>
<a name="ln3749">    if (*p &gt;= SYNID_ALLBUT &amp;&amp; *p &lt; SYNID_TOP) {</a>
<a name="ln3750">      if (p[1]) {</a>
<a name="ln3751">        msg_puts(&quot;ALLBUT&quot;);</a>
<a name="ln3752">      } else {</a>
<a name="ln3753">        msg_puts(&quot;ALL&quot;);</a>
<a name="ln3754">      }</a>
<a name="ln3755">    } else if (*p &gt;= SYNID_TOP &amp;&amp; *p &lt; SYNID_CONTAINED)   {</a>
<a name="ln3756">      msg_puts(&quot;TOP&quot;);</a>
<a name="ln3757">    } else if (*p &gt;= SYNID_CONTAINED &amp;&amp; *p &lt; SYNID_CLUSTER)   {</a>
<a name="ln3758">      msg_puts(&quot;CONTAINED&quot;);</a>
<a name="ln3759">    } else if (*p &gt;= SYNID_CLUSTER)   {</a>
<a name="ln3760">      int scl_id = *p - SYNID_CLUSTER;</a>
<a name="ln3761"> </a>
<a name="ln3762">      msg_putchar('@');</a>
<a name="ln3763">      msg_outtrans(SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_name);</a>
<a name="ln3764">    } else</a>
<a name="ln3765">      msg_outtrans(HL_TABLE()[*p - 1].sg_name);</a>
<a name="ln3766">    if (p[1])</a>
<a name="ln3767">      msg_putchar(',');</a>
<a name="ln3768">  }</a>
<a name="ln3769">  msg_putchar(' ');</a>
<a name="ln3770">}</a>
<a name="ln3771"> </a>
<a name="ln3772">static void put_pattern(const char *const s, const int c,</a>
<a name="ln3773">                        const synpat_T *const spp, const int attr)</a>
<a name="ln3774">{</a>
<a name="ln3775">  static const char *const sepchars = &quot;/+=-#@\&quot;|'^&amp;&quot;;</a>
<a name="ln3776">  int i;</a>
<a name="ln3777"> </a>
<a name="ln3778">  /* May have to write &quot;matchgroup=group&quot; */</a>
<a name="ln3779">  if (last_matchgroup != spp-&gt;sp_syn_match_id) {</a>
<a name="ln3780">    last_matchgroup = spp-&gt;sp_syn_match_id;</a>
<a name="ln3781">    msg_puts_attr(&quot;matchgroup&quot;, attr);</a>
<a name="ln3782">    msg_putchar('=');</a>
<a name="ln3783">    if (last_matchgroup == 0)</a>
<a name="ln3784">      msg_outtrans((char_u *)&quot;NONE&quot;);</a>
<a name="ln3785">    else</a>
<a name="ln3786">      msg_outtrans(HL_TABLE()[last_matchgroup - 1].sg_name);</a>
<a name="ln3787">    msg_putchar(' ');</a>
<a name="ln3788">  }</a>
<a name="ln3789"> </a>
<a name="ln3790">  // Output the name of the pattern and an '=' or ' '.</a>
<a name="ln3791">  msg_puts_attr(s, attr);</a>
<a name="ln3792">  msg_putchar(c);</a>
<a name="ln3793"> </a>
<a name="ln3794">  /* output the pattern, in between a char that is not in the pattern */</a>
<a name="ln3795">  for (i = 0; vim_strchr(spp-&gt;sp_pattern, sepchars[i]) != NULL; )</a>
<a name="ln3796">    if (sepchars[++i] == NUL) {</a>
<a name="ln3797">      i = 0;            /* no good char found, just use the first one */</a>
<a name="ln3798">      break;</a>
<a name="ln3799">    }</a>
<a name="ln3800">  msg_putchar(sepchars[i]);</a>
<a name="ln3801">  msg_outtrans(spp-&gt;sp_pattern);</a>
<a name="ln3802">  msg_putchar(sepchars[i]);</a>
<a name="ln3803"> </a>
<a name="ln3804">  // output any pattern options</a>
<a name="ln3805">  bool first = true;</a>
<a name="ln3806">  for (i = 0; i &lt; SPO_COUNT; i++) {</a>
<a name="ln3807">    const int mask = (1 &lt;&lt; i);</a>
<a name="ln3808">    if (!(spp-&gt;sp_off_flags &amp; (mask + (mask &lt;&lt; SPO_COUNT)))) {</a>
<a name="ln3809">      continue;</a>
<a name="ln3810">    }</a>
<a name="ln3811">    if (!first) {</a>
<a name="ln3812">      msg_putchar(',');  // Separate with commas.</a>
<a name="ln3813">    }</a>
<a name="ln3814">    msg_puts(spo_name_tab[i]);</a>
<a name="ln3815">    const long n = spp-&gt;sp_offsets[i];</a>
<a name="ln3816">    if (i != SPO_LC_OFF) {</a>
<a name="ln3817">      if (spp-&gt;sp_off_flags &amp; mask)</a>
<a name="ln3818">        msg_putchar('s');</a>
<a name="ln3819">      else</a>
<a name="ln3820">        msg_putchar('e');</a>
<a name="ln3821">      if (n &gt; 0)</a>
<a name="ln3822">        msg_putchar('+');</a>
<a name="ln3823">    }</a>
<a name="ln3824">    if (n || i == SPO_LC_OFF) {</a>
<a name="ln3825">      msg_outnum(n);</a>
<a name="ln3826">    }</a>
<a name="ln3827">    first = false;</a>
<a name="ln3828">  }</a>
<a name="ln3829">  msg_putchar(' ');</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">// List or clear the keywords for one syntax group.</a>
<a name="ln3833">// Return true if the header has been printed.</a>
<a name="ln3834">static bool syn_list_keywords(</a>
<a name="ln3835">    const int id,</a>
<a name="ln3836">    const hashtab_T *const ht,</a>
<a name="ln3837">    bool did_header,                        // header has already been printed</a>
<a name="ln3838">    const int attr</a>
<a name="ln3839">)</a>
<a name="ln3840">{</a>
<a name="ln3841">  int prev_contained = 0;</a>
<a name="ln3842">  const int16_t *prev_next_list = NULL;</a>
<a name="ln3843">  const int16_t *prev_cont_in_list = NULL;</a>
<a name="ln3844">  int prev_skipnl = 0;</a>
<a name="ln3845">  int prev_skipwhite = 0;</a>
<a name="ln3846">  int prev_skipempty = 0;</a>
<a name="ln3847"> </a>
<a name="ln3848">  // Unfortunately, this list of keywords is not sorted on alphabet but on</a>
<a name="ln3849">  // hash value...</a>
<a name="ln3850">  size_t todo = ht-&gt;ht_used;</a>
<a name="ln3851">  for (const hashitem_T *hi = ht-&gt;ht_array; todo &gt; 0 &amp;&amp; !got_int; hi++) {</a>
<a name="ln3852">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3853">      continue;</a>
<a name="ln3854">    }</a>
<a name="ln3855">    todo--;</a>
<a name="ln3856">    for (keyentry_T *kp = HI2KE(hi); kp != NULL &amp;&amp; !got_int; kp = kp-&gt;ke_next) {</a>
<a name="ln3857">      if (kp-&gt;k_syn.id == id) {</a>
<a name="ln3858">        int outlen = 0;</a>
<a name="ln3859">        bool force_newline = false;</a>
<a name="ln3860">        if (prev_contained != (kp-&gt;flags &amp; HL_CONTAINED)</a>
<a name="ln3861">            || prev_skipnl != (kp-&gt;flags &amp; HL_SKIPNL)</a>
<a name="ln3862">            || prev_skipwhite != (kp-&gt;flags &amp; HL_SKIPWHITE)</a>
<a name="ln3863">            || prev_skipempty != (kp-&gt;flags &amp; HL_SKIPEMPTY)</a>
<a name="ln3864">            || prev_cont_in_list != kp-&gt;k_syn.cont_in_list</a>
<a name="ln3865">            || prev_next_list != kp-&gt;next_list) {</a>
<a name="ln3866">            force_newline = true;</a>
<a name="ln3867">        } else {</a>
<a name="ln3868">          outlen = (int)STRLEN(kp-&gt;keyword);</a>
<a name="ln3869">        }</a>
<a name="ln3870">        // output &quot;contained&quot; and &quot;nextgroup&quot; on each line</a>
<a name="ln3871">        if (syn_list_header(did_header, outlen, id, force_newline)) {</a>
<a name="ln3872">          prev_contained = 0;</a>
<a name="ln3873">          prev_next_list = NULL;</a>
<a name="ln3874">          prev_cont_in_list = NULL;</a>
<a name="ln3875">          prev_skipnl = 0;</a>
<a name="ln3876">          prev_skipwhite = 0;</a>
<a name="ln3877">          prev_skipempty = 0;</a>
<a name="ln3878">        }</a>
<a name="ln3879">        did_header = true;</a>
<a name="ln3880">        if (prev_contained != (kp-&gt;flags &amp; HL_CONTAINED)) {</a>
<a name="ln3881">          msg_puts_attr(&quot;contained&quot;, attr);</a>
<a name="ln3882">          msg_putchar(' ');</a>
<a name="ln3883">          prev_contained = (kp-&gt;flags &amp; HL_CONTAINED);</a>
<a name="ln3884">        }</a>
<a name="ln3885">        if (kp-&gt;k_syn.cont_in_list != prev_cont_in_list) {</a>
<a name="ln3886">          put_id_list(&quot;containedin&quot;, kp-&gt;k_syn.cont_in_list, attr);</a>
<a name="ln3887">          msg_putchar(' ');</a>
<a name="ln3888">          prev_cont_in_list = kp-&gt;k_syn.cont_in_list;</a>
<a name="ln3889">        }</a>
<a name="ln3890">        if (kp-&gt;next_list != prev_next_list) {</a>
<a name="ln3891">          put_id_list(&quot;nextgroup&quot;, kp-&gt;next_list, attr);</a>
<a name="ln3892">          msg_putchar(' ');</a>
<a name="ln3893">          prev_next_list = kp-&gt;next_list;</a>
<a name="ln3894">          if (kp-&gt;flags &amp; HL_SKIPNL) {</a>
<a name="ln3895">            msg_puts_attr(&quot;skipnl&quot;, attr);</a>
<a name="ln3896">            msg_putchar(' ');</a>
<a name="ln3897">            prev_skipnl = (kp-&gt;flags &amp; HL_SKIPNL);</a>
<a name="ln3898">          }</a>
<a name="ln3899">          if (kp-&gt;flags &amp; HL_SKIPWHITE) {</a>
<a name="ln3900">            msg_puts_attr(&quot;skipwhite&quot;, attr);</a>
<a name="ln3901">            msg_putchar(' ');</a>
<a name="ln3902">            prev_skipwhite = (kp-&gt;flags &amp; HL_SKIPWHITE);</a>
<a name="ln3903">          }</a>
<a name="ln3904">          if (kp-&gt;flags &amp; HL_SKIPEMPTY) {</a>
<a name="ln3905">            msg_puts_attr(&quot;skipempty&quot;, attr);</a>
<a name="ln3906">            msg_putchar(' ');</a>
<a name="ln3907">            prev_skipempty = (kp-&gt;flags &amp; HL_SKIPEMPTY);</a>
<a name="ln3908">          }</a>
<a name="ln3909">        }</a>
<a name="ln3910">        msg_outtrans(kp-&gt;keyword);</a>
<a name="ln3911">      }</a>
<a name="ln3912">    }</a>
<a name="ln3913">  }</a>
<a name="ln3914"> </a>
<a name="ln3915">  return did_header;</a>
<a name="ln3916">}</a>
<a name="ln3917"> </a>
<a name="ln3918">static void syn_clear_keyword(int id, hashtab_T *ht)</a>
<a name="ln3919">{</a>
<a name="ln3920">  hashitem_T  *hi;</a>
<a name="ln3921">  keyentry_T  *kp;</a>
<a name="ln3922">  keyentry_T  *kp_prev;</a>
<a name="ln3923">  keyentry_T  *kp_next;</a>
<a name="ln3924">  int todo;</a>
<a name="ln3925"> </a>
<a name="ln3926">  hash_lock(ht);</a>
<a name="ln3927">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln3928">  for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln3929">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3930">      continue;</a>
<a name="ln3931">    }</a>
<a name="ln3932">    --todo;</a>
<a name="ln3933">    kp_prev = NULL;</a>
<a name="ln3934">    for (kp = HI2KE(hi); kp != NULL; ) {</a>
<a name="ln3935">      if (kp-&gt;k_syn.id == id) {</a>
<a name="ln3936">        kp_next = kp-&gt;ke_next;</a>
<a name="ln3937">        if (kp_prev == NULL) {</a>
<a name="ln3938">          if (kp_next == NULL)</a>
<a name="ln3939">            hash_remove(ht, hi);</a>
<a name="ln3940">          else</a>
<a name="ln3941">            hi-&gt;hi_key = KE2HIKEY(kp_next);</a>
<a name="ln3942">        } else</a>
<a name="ln3943">          kp_prev-&gt;ke_next = kp_next;</a>
<a name="ln3944">        xfree(kp-&gt;next_list);</a>
<a name="ln3945">        xfree(kp-&gt;k_syn.cont_in_list);</a>
<a name="ln3946">        xfree(kp);</a>
<a name="ln3947">        kp = kp_next;</a>
<a name="ln3948">      } else {</a>
<a name="ln3949">        kp_prev = kp;</a>
<a name="ln3950">        kp = kp-&gt;ke_next;</a>
<a name="ln3951">      }</a>
<a name="ln3952">    }</a>
<a name="ln3953">  }</a>
<a name="ln3954">  hash_unlock(ht);</a>
<a name="ln3955">}</a>
<a name="ln3956"> </a>
<a name="ln3957">/*</a>
<a name="ln3958"> * Clear a whole keyword table.</a>
<a name="ln3959"> */</a>
<a name="ln3960">static void clear_keywtab(hashtab_T *ht)</a>
<a name="ln3961">{</a>
<a name="ln3962">  hashitem_T  *hi;</a>
<a name="ln3963">  int todo;</a>
<a name="ln3964">  keyentry_T  *kp;</a>
<a name="ln3965">  keyentry_T  *kp_next;</a>
<a name="ln3966"> </a>
<a name="ln3967">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln3968">  for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln3969">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3970">      --todo;</a>
<a name="ln3971">      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {</a>
<a name="ln3972">        kp_next = kp-&gt;ke_next;</a>
<a name="ln3973">        xfree(kp-&gt;next_list);</a>
<a name="ln3974">        xfree(kp-&gt;k_syn.cont_in_list);</a>
<a name="ln3975">        xfree(kp);</a>
<a name="ln3976">      }</a>
<a name="ln3977">    }</a>
<a name="ln3978">  }</a>
<a name="ln3979">  hash_clear(ht);</a>
<a name="ln3980">  hash_init(ht);</a>
<a name="ln3981">}</a>
<a name="ln3982"> </a>
<a name="ln3983">/// Add a keyword to the list of keywords.</a>
<a name="ln3984">///</a>
<a name="ln3985">/// @param name name of keyword</a>
<a name="ln3986">/// @param id group ID for this keyword</a>
<a name="ln3987">/// @param flags flags for this keyword</a>
<a name="ln3988">/// @param cont_in_list containedin for this keyword</a>
<a name="ln3989">/// @param next_list nextgroup for this keyword</a>
<a name="ln3990">static void add_keyword(char_u *const name,</a>
<a name="ln3991">                        const int id,</a>
<a name="ln3992">                        const int flags,</a>
<a name="ln3993">                        int16_t *const cont_in_list,</a>
<a name="ln3994">                        int16_t *const next_list,</a>
<a name="ln3995">                        const int conceal_char)</a>
<a name="ln3996">{</a>
<a name="ln3997">  char_u name_folded[MAXKEYWLEN + 1];</a>
<a name="ln3998">  const char_u *const name_ic = (curwin-&gt;w_s-&gt;b_syn_ic)</a>
<a name="ln3999">      ? str_foldcase(name, (int)STRLEN(name), name_folded, sizeof(name_folded))</a>
<a name="ln4000">      : name;</a>
<a name="ln4001"> </a>
<a name="ln4002">  keyentry_T *const kp = xmalloc(sizeof(keyentry_T) + STRLEN(name_ic));</a>
<a name="ln4003">  STRCPY(kp-&gt;keyword, name_ic);</a>
<a name="ln4004">  kp-&gt;k_syn.id = id;</a>
<a name="ln4005">  kp-&gt;k_syn.inc_tag = current_syn_inc_tag;</a>
<a name="ln4006">  kp-&gt;flags = flags;</a>
<a name="ln4007">  kp-&gt;k_char = conceal_char;</a>
<a name="ln4008">  kp-&gt;k_syn.cont_in_list = copy_id_list(cont_in_list);</a>
<a name="ln4009">  if (cont_in_list != NULL) {</a>
<a name="ln4010">    curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4011">  }</a>
<a name="ln4012">  kp-&gt;next_list = copy_id_list(next_list);</a>
<a name="ln4013"> </a>
<a name="ln4014">  const hash_T hash = hash_hash(kp-&gt;keyword);</a>
<a name="ln4015">  hashtab_T *const ht = (curwin-&gt;w_s-&gt;b_syn_ic)</a>
<a name="ln4016">      ? &amp;curwin-&gt;w_s-&gt;b_keywtab_ic</a>
<a name="ln4017">      : &amp;curwin-&gt;w_s-&gt;b_keywtab;</a>
<a name="ln4018">  hashitem_T *const hi = hash_lookup(ht, (const char *)kp-&gt;keyword,</a>
<a name="ln4019">                                     STRLEN(kp-&gt;keyword), hash);</a>
<a name="ln4020"> </a>
<a name="ln4021">  // even though it looks like only the kp-&gt;keyword member is</a>
<a name="ln4022">  // being used here, vim uses some pointer trickery to get the original</a>
<a name="ln4023">  // struct again later by using knowledge of the offset of the keyword</a>
<a name="ln4024">  // field in the struct. See the definition of the HI2KE macro.</a>
<a name="ln4025">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln4026">    // new keyword, add to hashtable</a>
<a name="ln4027">    kp-&gt;ke_next = NULL;</a>
<a name="ln4028">    hash_add_item(ht, hi, kp-&gt;keyword, hash);</a>
<a name="ln4029">  } else {</a>
<a name="ln4030">    // keyword already exists, prepend to list</a>
<a name="ln4031">    kp-&gt;ke_next = HI2KE(hi);</a>
<a name="ln4032">    hi-&gt;hi_key = KE2HIKEY(kp);</a>
<a name="ln4033">  }</a>
<a name="ln4034">}</a>
<a name="ln4035"> </a>
<a name="ln4036">/*</a>
<a name="ln4037"> * Get the start and end of the group name argument.</a>
<a name="ln4038"> * Return a pointer to the first argument.</a>
<a name="ln4039"> * Return NULL if the end of the command was found instead of further args.</a>
<a name="ln4040"> */</a>
<a name="ln4041">static char_u *</a>
<a name="ln4042">get_group_name (</a>
<a name="ln4043">    char_u *arg,               /* start of the argument */</a>
<a name="ln4044">    char_u **name_end         /* pointer to end of the name */</a>
<a name="ln4045">)</a>
<a name="ln4046">{</a>
<a name="ln4047">  char_u      *rest;</a>
<a name="ln4048"> </a>
<a name="ln4049">  *name_end = skiptowhite(arg);</a>
<a name="ln4050">  rest = skipwhite(*name_end);</a>
<a name="ln4051"> </a>
<a name="ln4052">  /*</a>
<a name="ln4053">   * Check if there are enough arguments.  The first argument may be a</a>
<a name="ln4054">   * pattern, where '|' is allowed, so only check for NUL.</a>
<a name="ln4055">   */</a>
<a name="ln4056">  if (ends_excmd(*arg) || *rest == NUL)</a>
<a name="ln4057">    return NULL;</a>
<a name="ln4058">  return rest;</a>
<a name="ln4059">}</a>
<a name="ln4060"> </a>
<a name="ln4061">/*</a>
<a name="ln4062"> * Check for syntax command option arguments.</a>
<a name="ln4063"> * This can be called at any place in the list of arguments, and just picks</a>
<a name="ln4064"> * out the arguments that are known.  Can be called several times in a row to</a>
<a name="ln4065"> * collect all options in between other arguments.</a>
<a name="ln4066"> * Return a pointer to the next argument (which isn't an option).</a>
<a name="ln4067"> * Return NULL for any error;</a>
<a name="ln4068"> */</a>
<a name="ln4069">static char_u *</a>
<a name="ln4070">get_syn_options(</a>
<a name="ln4071">    char_u *arg,            // next argument to be checked</a>
<a name="ln4072">    syn_opt_arg_T *opt,     // various things</a>
<a name="ln4073">    int *conceal_char,</a>
<a name="ln4074">    int skip                // TRUE if skipping over command</a>
<a name="ln4075">)</a>
<a name="ln4076">{</a>
<a name="ln4077">  char_u      *gname_start, *gname;</a>
<a name="ln4078">  int syn_id;</a>
<a name="ln4079">  int len = 0;</a>
<a name="ln4080">  char        *p;</a>
<a name="ln4081">  int fidx;</a>
<a name="ln4082">  static const struct flag {</a>
<a name="ln4083">    char    *name;</a>
<a name="ln4084">    int argtype;</a>
<a name="ln4085">    int flags;</a>
<a name="ln4086">  } flagtab[] = { {&quot;cCoOnNtTaAiInNeEdD&quot;,      0,      HL_CONTAINED},</a>
<a name="ln4087">                  {&quot;oOnNeElLiInNeE&quot;,          0,      HL_ONELINE},</a>
<a name="ln4088">                  {&quot;kKeEeEpPeEnNdD&quot;,          0,      HL_KEEPEND},</a>
<a name="ln4089">                  {&quot;eExXtTeEnNdD&quot;,            0,      HL_EXTEND},</a>
<a name="ln4090">                  {&quot;eExXcClLuUdDeEnNlL&quot;,      0,      HL_EXCLUDENL},</a>
<a name="ln4091">                  {&quot;tTrRaAnNsSpPaArReEnNtT&quot;,  0,      HL_TRANSP},</a>
<a name="ln4092">                  {&quot;sSkKiIpPnNlL&quot;,            0,      HL_SKIPNL},</a>
<a name="ln4093">                  {&quot;sSkKiIpPwWhHiItTeE&quot;,      0,      HL_SKIPWHITE},</a>
<a name="ln4094">                  {&quot;sSkKiIpPeEmMpPtTyY&quot;,      0,      HL_SKIPEMPTY},</a>
<a name="ln4095">                  {&quot;gGrRoOuUpPhHeErReE&quot;,      0,      HL_SYNC_HERE},</a>
<a name="ln4096">                  {&quot;gGrRoOuUpPtThHeErReE&quot;,    0,      HL_SYNC_THERE},</a>
<a name="ln4097">                  {&quot;dDiIsSpPlLaAyY&quot;,          0,      HL_DISPLAY},</a>
<a name="ln4098">                  {&quot;fFoOlLdD&quot;,                0,      HL_FOLD},</a>
<a name="ln4099">                  {&quot;cCoOnNcCeEaAlL&quot;,          0,      HL_CONCEAL},</a>
<a name="ln4100">                  {&quot;cCoOnNcCeEaAlLeEnNdDsS&quot;,  0,      HL_CONCEALENDS},</a>
<a name="ln4101">                  {&quot;cCcChHaArR&quot;,              11,     0},</a>
<a name="ln4102">                  {&quot;cCoOnNtTaAiInNsS&quot;,        1,      0},</a>
<a name="ln4103">                  {&quot;cCoOnNtTaAiInNeEdDiInN&quot;,  2,      0},</a>
<a name="ln4104">                  {&quot;nNeExXtTgGrRoOuUpP&quot;,      3,      0},};</a>
<a name="ln4105">  static const char *const first_letters = &quot;cCoOkKeEtTsSgGdDfFnN&quot;;</a>
<a name="ln4106"> </a>
<a name="ln4107">  if (arg == NULL)              /* already detected error */</a>
<a name="ln4108">    return NULL;</a>
<a name="ln4109"> </a>
<a name="ln4110">  if (curwin-&gt;w_s-&gt;b_syn_conceal)</a>
<a name="ln4111">    opt-&gt;flags |= HL_CONCEAL;</a>
<a name="ln4112"> </a>
<a name="ln4113">  for (;; ) {</a>
<a name="ln4114">    /*</a>
<a name="ln4115">     * This is used very often when a large number of keywords is defined.</a>
<a name="ln4116">     * Need to skip quickly when no option name is found.</a>
<a name="ln4117">     * Also avoid tolower(), it's slow.</a>
<a name="ln4118">     */</a>
<a name="ln4119">    if (strchr(first_letters, *arg) == NULL)</a>
<a name="ln4120">      break;</a>
<a name="ln4121"> </a>
<a name="ln4122">    for (fidx = ARRAY_SIZE(flagtab); --fidx &gt;= 0; ) {</a>
<a name="ln4123">      p = flagtab[fidx].name;</a>
<a name="ln4124">      int i;</a>
<a name="ln4125">      for (i = 0, len = 0; p[i] != NUL; i += 2, ++len) {</a>
<a name="ln4126">        if (arg[len] != p[i] &amp;&amp; arg[len] != p[i + 1])</a>
<a name="ln4127">          break;</a>
<a name="ln4128">      }</a>
<a name="ln4129">      if (p[i] == NUL &amp;&amp; (ascii_iswhite(arg[len])</a>
<a name="ln4130">                          || (flagtab[fidx].argtype &gt; 0</a>
<a name="ln4131">                              ? arg[len] == '='</a>
<a name="ln4132">                              : ends_excmd(arg[len])))) {</a>
<a name="ln4133">        if (opt-&gt;keyword</a>
<a name="ln4134">            &amp;&amp; (flagtab[fidx].flags == HL_DISPLAY</a>
<a name="ln4135">                || flagtab[fidx].flags == HL_FOLD</a>
<a name="ln4136">                || flagtab[fidx].flags == HL_EXTEND))</a>
<a name="ln4137">          /* treat &quot;display&quot;, &quot;fold&quot; and &quot;extend&quot; as a keyword */</a>
<a name="ln4138">          fidx = -1;</a>
<a name="ln4139">        break;</a>
<a name="ln4140">      }</a>
<a name="ln4141">    }</a>
<a name="ln4142">    if (fidx &lt; 0)           /* no match found */</a>
<a name="ln4143">      break;</a>
<a name="ln4144"> </a>
<a name="ln4145">    if (flagtab[fidx].argtype == 1) {</a>
<a name="ln4146">      if (!opt-&gt;has_cont_list) {</a>
<a name="ln4147">        EMSG(_(&quot;E395: contains argument not accepted here&quot;));</a>
<a name="ln4148">        return NULL;</a>
<a name="ln4149">      }</a>
<a name="ln4150">      if (get_id_list(&amp;arg, 8, &amp;opt-&gt;cont_list, skip) == FAIL) {</a>
<a name="ln4151">        return NULL;</a>
<a name="ln4152">      }</a>
<a name="ln4153">    } else if (flagtab[fidx].argtype == 2)   {</a>
<a name="ln4154">      if (get_id_list(&amp;arg, 11, &amp;opt-&gt;cont_in_list, skip) == FAIL) {</a>
<a name="ln4155">        return NULL;</a>
<a name="ln4156">      }</a>
<a name="ln4157">    } else if (flagtab[fidx].argtype == 3)   {</a>
<a name="ln4158">      if (get_id_list(&amp;arg, 9, &amp;opt-&gt;next_list, skip) == FAIL) {</a>
<a name="ln4159">        return NULL;</a>
<a name="ln4160">      }</a>
<a name="ln4161">    } else if (flagtab[fidx].argtype == 11 &amp;&amp; arg[5] == '=')   {</a>
<a name="ln4162">      // cchar=?</a>
<a name="ln4163">      *conceal_char = utf_ptr2char(arg + 6);</a>
<a name="ln4164">      arg += mb_ptr2len(arg + 6) - 1;</a>
<a name="ln4165">      if (!vim_isprintc_strict(*conceal_char)) {</a>
<a name="ln4166">        EMSG(_(&quot;E844: invalid cchar value&quot;));</a>
<a name="ln4167">        return NULL;</a>
<a name="ln4168">      }</a>
<a name="ln4169">      arg = skipwhite(arg + 7);</a>
<a name="ln4170">    } else {</a>
<a name="ln4171">      opt-&gt;flags |= flagtab[fidx].flags;</a>
<a name="ln4172">      arg = skipwhite(arg + len);</a>
<a name="ln4173"> </a>
<a name="ln4174">      if (flagtab[fidx].flags == HL_SYNC_HERE</a>
<a name="ln4175">          || flagtab[fidx].flags == HL_SYNC_THERE) {</a>
<a name="ln4176">        if (opt-&gt;sync_idx == NULL) {</a>
<a name="ln4177">          EMSG(_(&quot;E393: group[t]here not accepted here&quot;));</a>
<a name="ln4178">          return NULL;</a>
<a name="ln4179">        }</a>
<a name="ln4180">        gname_start = arg;</a>
<a name="ln4181">        arg = skiptowhite(arg);</a>
<a name="ln4182">        if (gname_start == arg)</a>
<a name="ln4183">          return NULL;</a>
<a name="ln4184">        gname = vim_strnsave(gname_start, (int)(arg - gname_start));</a>
<a name="ln4185">        if (STRCMP(gname, &quot;NONE&quot;) == 0)</a>
<a name="ln4186">          *opt-&gt;sync_idx = NONE_IDX;</a>
<a name="ln4187">        else {</a>
<a name="ln4188">          syn_id = syn_name2id(gname);</a>
<a name="ln4189">          int i;</a>
<a name="ln4190">          for (i = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; --i &gt;= 0; )</a>
<a name="ln4191">            if (SYN_ITEMS(curwin-&gt;w_s)[i].sp_syn.id == syn_id</a>
<a name="ln4192">                &amp;&amp; SYN_ITEMS(curwin-&gt;w_s)[i].sp_type == SPTYPE_START) {</a>
<a name="ln4193">              *opt-&gt;sync_idx = i;</a>
<a name="ln4194">              break;</a>
<a name="ln4195">            }</a>
<a name="ln4196">          if (i &lt; 0) {</a>
<a name="ln4197">            EMSG2(_(&quot;E394: Didn't find region item for %s&quot;), gname);</a>
<a name="ln4198">            xfree(gname);</a>
<a name="ln4199">            return NULL;</a>
<a name="ln4200">          }</a>
<a name="ln4201">        }</a>
<a name="ln4202"> </a>
<a name="ln4203">        xfree(gname);</a>
<a name="ln4204">        arg = skipwhite(arg);</a>
<a name="ln4205">      } else if (flagtab[fidx].flags == HL_FOLD</a>
<a name="ln4206">                 &amp;&amp; foldmethodIsSyntax(curwin))</a>
<a name="ln4207">        /* Need to update folds later. */</a>
<a name="ln4208">        foldUpdateAll(curwin);</a>
<a name="ln4209">    }</a>
<a name="ln4210">  }</a>
<a name="ln4211"> </a>
<a name="ln4212">  return arg;</a>
<a name="ln4213">}</a>
<a name="ln4214"> </a>
<a name="ln4215">/*</a>
<a name="ln4216"> * Adjustments to syntax item when declared in a &quot;:syn include&quot;'d file.</a>
<a name="ln4217"> * Set the contained flag, and if the item is not already contained, add it</a>
<a name="ln4218"> * to the specified top-level group, if any.</a>
<a name="ln4219"> */</a>
<a name="ln4220">static void syn_incl_toplevel(int id, int *flagsp)</a>
<a name="ln4221">{</a>
<a name="ln4222">  if ((*flagsp &amp; HL_CONTAINED) || curwin-&gt;w_s-&gt;b_syn_topgrp == 0)</a>
<a name="ln4223">    return;</a>
<a name="ln4224">  *flagsp |= HL_CONTAINED;</a>
<a name="ln4225">  if (curwin-&gt;w_s-&gt;b_syn_topgrp &gt;= SYNID_CLUSTER) {</a>
<a name="ln4226">    // We have to alloc this, because syn_combine_list() will free it.</a>
<a name="ln4227">    int16_t *grp_list = xmalloc(2 * sizeof(*grp_list));</a>
<a name="ln4228">    int tlg_id = curwin-&gt;w_s-&gt;b_syn_topgrp - SYNID_CLUSTER;</a>
<a name="ln4229"> </a>
<a name="ln4230">    grp_list[0] = id;</a>
<a name="ln4231">    grp_list[1] = 0;</a>
<a name="ln4232">    syn_combine_list(&amp;SYN_CLSTR(curwin-&gt;w_s)[tlg_id].scl_list, &amp;grp_list,</a>
<a name="ln4233">        CLUSTER_ADD);</a>
<a name="ln4234">  }</a>
<a name="ln4235">}</a>
<a name="ln4236"> </a>
<a name="ln4237">/*</a>
<a name="ln4238"> * Handle &quot;:syntax include [@{group-name}] filename&quot; command.</a>
<a name="ln4239"> */</a>
<a name="ln4240">static void syn_cmd_include(exarg_T *eap, int syncing)</a>
<a name="ln4241">{</a>
<a name="ln4242">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4243">  int sgl_id = 1;</a>
<a name="ln4244">  char_u      *group_name_end;</a>
<a name="ln4245">  char_u      *rest;</a>
<a name="ln4246">  char_u      *errormsg = NULL;</a>
<a name="ln4247">  int prev_toplvl_grp;</a>
<a name="ln4248">  int prev_syn_inc_tag;</a>
<a name="ln4249">  int source = FALSE;</a>
<a name="ln4250"> </a>
<a name="ln4251">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln4252">  if (eap-&gt;skip)</a>
<a name="ln4253">    return;</a>
<a name="ln4254"> </a>
<a name="ln4255">  if (arg[0] == '@') {</a>
<a name="ln4256">    ++arg;</a>
<a name="ln4257">    rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4258">    if (rest == NULL) {</a>
<a name="ln4259">      EMSG((char_u *)_(&quot;E397: Filename required&quot;));</a>
<a name="ln4260">      return;</a>
<a name="ln4261">    }</a>
<a name="ln4262">    sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));</a>
<a name="ln4263">    if (sgl_id == 0)</a>
<a name="ln4264">      return;</a>
<a name="ln4265">    /* separate_nextcmd() and expand_filename() depend on this */</a>
<a name="ln4266">    eap-&gt;arg = rest;</a>
<a name="ln4267">  }</a>
<a name="ln4268"> </a>
<a name="ln4269">  /*</a>
<a name="ln4270">   * Everything that's left, up to the next command, should be the</a>
<a name="ln4271">   * filename to include.</a>
<a name="ln4272">   */</a>
<a name="ln4273">  eap-&gt;argt |= (XFILE | NOSPC);</a>
<a name="ln4274">  separate_nextcmd(eap);</a>
<a name="ln4275">  if (*eap-&gt;arg == '&lt;' || *eap-&gt;arg == '$' || path_is_absolute(eap-&gt;arg)) {</a>
<a name="ln4276">    // For an absolute path, &quot;$VIM/...&quot; or &quot;&lt;sfile&gt;..&quot; we &quot;:source&quot; the</a>
<a name="ln4277">    // file.  Need to expand the file name first.  In other cases</a>
<a name="ln4278">    // &quot;:runtime!&quot; is used.</a>
<a name="ln4279">    source = true;</a>
<a name="ln4280">    if (expand_filename(eap, syn_cmdlinep, &amp;errormsg) == FAIL) {</a>
<a name="ln4281">      if (errormsg != NULL)</a>
<a name="ln4282">        EMSG(errormsg);</a>
<a name="ln4283">      return;</a>
<a name="ln4284">    }</a>
<a name="ln4285">  }</a>
<a name="ln4286"> </a>
<a name="ln4287">  /*</a>
<a name="ln4288">   * Save and restore the existing top-level grouplist id and &quot;:syn</a>
<a name="ln4289">   * include&quot; tag around the actual inclusion.</a>
<a name="ln4290">   */</a>
<a name="ln4291">  if (running_syn_inc_tag &gt;= MAX_SYN_INC_TAG) {</a>
<a name="ln4292">    EMSG((char_u *)_(&quot;E847: Too many syntax includes&quot;));</a>
<a name="ln4293">    return;</a>
<a name="ln4294">  }</a>
<a name="ln4295">  prev_syn_inc_tag = current_syn_inc_tag;</a>
<a name="ln4296">  current_syn_inc_tag = ++running_syn_inc_tag;</a>
<a name="ln4297">  prev_toplvl_grp = curwin-&gt;w_s-&gt;b_syn_topgrp;</a>
<a name="ln4298">  curwin-&gt;w_s-&gt;b_syn_topgrp = sgl_id;</a>
<a name="ln4299">  if (source ? do_source(eap-&gt;arg, false, DOSO_NONE) == FAIL</a>
<a name="ln4300">             : source_in_path(p_rtp, eap-&gt;arg, DIP_ALL) == FAIL) {</a>
<a name="ln4301">    EMSG2(_(e_notopen), eap-&gt;arg);</a>
<a name="ln4302">  }</a>
<a name="ln4303">  curwin-&gt;w_s-&gt;b_syn_topgrp = prev_toplvl_grp;</a>
<a name="ln4304">  current_syn_inc_tag = prev_syn_inc_tag;</a>
<a name="ln4305">}</a>
<a name="ln4306"> </a>
<a name="ln4307">/*</a>
<a name="ln4308"> * Handle &quot;:syntax keyword {group-name} [{option}] keyword ..&quot; command.</a>
<a name="ln4309"> */</a>
<a name="ln4310">static void syn_cmd_keyword(exarg_T *eap, int syncing)</a>
<a name="ln4311">{</a>
<a name="ln4312">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4313">  char_u      *group_name_end;</a>
<a name="ln4314">  int syn_id;</a>
<a name="ln4315">  char_u      *rest;</a>
<a name="ln4316">  char_u      *keyword_copy = NULL;</a>
<a name="ln4317">  char_u      *p;</a>
<a name="ln4318">  char_u      *kw;</a>
<a name="ln4319">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4320">  int cnt;</a>
<a name="ln4321">  int conceal_char = NUL;</a>
<a name="ln4322"> </a>
<a name="ln4323">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4324"> </a>
<a name="ln4325">  if (rest != NULL) {</a>
<a name="ln4326">    if (eap-&gt;skip) {</a>
<a name="ln4327">      syn_id = -1;</a>
<a name="ln4328">    } else {</a>
<a name="ln4329">      syn_id = syn_check_group(arg, (int)(group_name_end - arg));</a>
<a name="ln4330">    }</a>
<a name="ln4331">    if (syn_id != 0) {</a>
<a name="ln4332">      // Allocate a buffer, for removing backslashes in the keyword.</a>
<a name="ln4333">      keyword_copy = xmalloc(STRLEN(rest) + 1);</a>
<a name="ln4334">    }</a>
<a name="ln4335">    if (keyword_copy != NULL) {</a>
<a name="ln4336">      syn_opt_arg.flags = 0;</a>
<a name="ln4337">      syn_opt_arg.keyword = true;</a>
<a name="ln4338">      syn_opt_arg.sync_idx = NULL;</a>
<a name="ln4339">      syn_opt_arg.has_cont_list = false;</a>
<a name="ln4340">      syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4341">      syn_opt_arg.next_list = NULL;</a>
<a name="ln4342"> </a>
<a name="ln4343">      // The options given apply to ALL keywords, so all options must be</a>
<a name="ln4344">      // found before keywords can be created.</a>
<a name="ln4345">      // 1: collect the options and copy the keywords to keyword_copy.</a>
<a name="ln4346">      cnt = 0;</a>
<a name="ln4347">      p = keyword_copy;</a>
<a name="ln4348">      for (; rest != NULL &amp;&amp; !ends_excmd(*rest); rest = skipwhite(rest)) {</a>
<a name="ln4349">        rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4350">        if (rest == NULL || ends_excmd(*rest)) {</a>
<a name="ln4351">          break;</a>
<a name="ln4352">        }</a>
<a name="ln4353">        // Copy the keyword, removing backslashes, and add a NUL.</a>
<a name="ln4354">        while (*rest != NUL &amp;&amp; !ascii_iswhite(*rest)) {</a>
<a name="ln4355">          if (*rest == '\\' &amp;&amp; rest[1] != NUL) {</a>
<a name="ln4356">            rest++;</a>
<a name="ln4357">          }</a>
<a name="ln4358">          *p++ = *rest++;</a>
<a name="ln4359">        }</a>
<a name="ln4360">        *p++ = NUL;</a>
<a name="ln4361">        cnt++;</a>
<a name="ln4362">      }</a>
<a name="ln4363"> </a>
<a name="ln4364">      if (!eap-&gt;skip) {</a>
<a name="ln4365">        // Adjust flags for use of &quot;:syn include&quot;.</a>
<a name="ln4366">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4367"> </a>
<a name="ln4368">        // 2: Add an entry for each keyword.</a>
<a name="ln4369">        for (kw = keyword_copy; --cnt &gt;= 0; kw += STRLEN(kw) + 1) {</a>
<a name="ln4370">          for (p = vim_strchr(kw, '[');; ) {</a>
<a name="ln4371">            if (p != NULL) {</a>
<a name="ln4372">              *p = NUL;</a>
<a name="ln4373">            }</a>
<a name="ln4374">            add_keyword(kw, syn_id, syn_opt_arg.flags,</a>
<a name="ln4375">                        syn_opt_arg.cont_in_list,</a>
<a name="ln4376">                        syn_opt_arg.next_list, conceal_char);</a>
<a name="ln4377">            if (p == NULL) {</a>
<a name="ln4378">              break;</a>
<a name="ln4379">            }</a>
<a name="ln4380">            if (p[1] == NUL) {</a>
<a name="ln4381">              emsgf(_(&quot;E789: Missing ']': %s&quot;), kw);</a>
<a name="ln4382">              goto error;</a>
<a name="ln4383">            }</a>
<a name="ln4384">            if (p[1] == ']') {</a>
<a name="ln4385">              if (p[2] != NUL) {</a>
<a name="ln4386">                emsgf(_(&quot;E890: trailing char after ']': %s]%s&quot;),</a>
<a name="ln4387">                      kw, &amp;p[2]);</a>
<a name="ln4388">                goto error;</a>
<a name="ln4389">              }</a>
<a name="ln4390">              kw = p + 1;</a>
<a name="ln4391">              break;   // skip over the &quot;]&quot;</a>
<a name="ln4392">            }</a>
<a name="ln4393">            const int l = (*mb_ptr2len)(p + 1);</a>
<a name="ln4394"> </a>
<a name="ln4395">            memmove(p, p + 1, l);</a>
<a name="ln4396">            p += l;</a>
<a name="ln4397">          }</a>
<a name="ln4398">        }</a>
<a name="ln4399">      }</a>
<a name="ln4400"> </a>
<a name="ln4401">error:</a>
<a name="ln4402">      xfree(keyword_copy);</a>
<a name="ln4403">      xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4404">      xfree(syn_opt_arg.next_list);</a>
<a name="ln4405">    }</a>
<a name="ln4406">  }</a>
<a name="ln4407"> </a>
<a name="ln4408">  if (rest != NULL)</a>
<a name="ln4409">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4410">  else</a>
<a name="ln4411">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln4412"> </a>
<a name="ln4413">  redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4414">  syn_stack_free_all(curwin-&gt;w_s);              /* Need to recompute all syntax. */</a>
<a name="ln4415">}</a>
<a name="ln4416"> </a>
<a name="ln4417">/*</a>
<a name="ln4418"> * Handle &quot;:syntax match {name} [{options}] {pattern} [{options}]&quot;.</a>
<a name="ln4419"> *</a>
<a name="ln4420"> * Also &quot;:syntax sync match {name} [[grouphere | groupthere] {group-name}] ..&quot;</a>
<a name="ln4421"> */</a>
<a name="ln4422">static void</a>
<a name="ln4423">syn_cmd_match(</a>
<a name="ln4424">    exarg_T *eap,</a>
<a name="ln4425">    int syncing                        /* TRUE for &quot;:syntax sync match .. &quot; */</a>
<a name="ln4426">)</a>
<a name="ln4427">{</a>
<a name="ln4428">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4429">  char_u      *group_name_end;</a>
<a name="ln4430">  char_u      *rest;</a>
<a name="ln4431">  synpat_T item;                /* the item found in the line */</a>
<a name="ln4432">  int syn_id;</a>
<a name="ln4433">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4434">  int sync_idx = 0;</a>
<a name="ln4435">  int conceal_char = NUL;</a>
<a name="ln4436"> </a>
<a name="ln4437">  /* Isolate the group name, check for validity */</a>
<a name="ln4438">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4439"> </a>
<a name="ln4440">  /* Get options before the pattern */</a>
<a name="ln4441">  syn_opt_arg.flags = 0;</a>
<a name="ln4442">  syn_opt_arg.keyword = false;</a>
<a name="ln4443">  syn_opt_arg.sync_idx = syncing ? &amp;sync_idx : NULL;</a>
<a name="ln4444">  syn_opt_arg.has_cont_list = true;</a>
<a name="ln4445">  syn_opt_arg.cont_list = NULL;</a>
<a name="ln4446">  syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4447">  syn_opt_arg.next_list = NULL;</a>
<a name="ln4448">  rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4449"> </a>
<a name="ln4450">  /* get the pattern. */</a>
<a name="ln4451">  init_syn_patterns();</a>
<a name="ln4452">  memset(&amp;item, 0, sizeof(item));</a>
<a name="ln4453">  rest = get_syn_pattern(rest, &amp;item);</a>
<a name="ln4454">  if (vim_regcomp_had_eol() &amp;&amp; !(syn_opt_arg.flags &amp; HL_EXCLUDENL)) {</a>
<a name="ln4455">    syn_opt_arg.flags |= HL_HAS_EOL;</a>
<a name="ln4456">  }</a>
<a name="ln4457"> </a>
<a name="ln4458">  // Get options after the pattern</a>
<a name="ln4459">  rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4460"> </a>
<a name="ln4461">  if (rest != NULL) {           /* all arguments are valid */</a>
<a name="ln4462">    /*</a>
<a name="ln4463">     * Check for trailing command and illegal trailing arguments.</a>
<a name="ln4464">     */</a>
<a name="ln4465">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4466">    if (!ends_excmd(*rest) || eap-&gt;skip)</a>
<a name="ln4467">      rest = NULL;</a>
<a name="ln4468">    else {</a>
<a name="ln4469">      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {</a>
<a name="ln4470">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4471">        /*</a>
<a name="ln4472">         * Store the pattern in the syn_items list</a>
<a name="ln4473">         */</a>
<a name="ln4474">        synpat_T *spp = GA_APPEND_VIA_PTR(synpat_T,</a>
<a name="ln4475">                                          &amp;curwin-&gt;w_s-&gt;b_syn_patterns);</a>
<a name="ln4476">        *spp = item;</a>
<a name="ln4477">        spp-&gt;sp_syncing = syncing;</a>
<a name="ln4478">        spp-&gt;sp_type = SPTYPE_MATCH;</a>
<a name="ln4479">        spp-&gt;sp_syn.id = syn_id;</a>
<a name="ln4480">        spp-&gt;sp_syn.inc_tag = current_syn_inc_tag;</a>
<a name="ln4481">        spp-&gt;sp_flags = syn_opt_arg.flags;</a>
<a name="ln4482">        spp-&gt;sp_sync_idx = sync_idx;</a>
<a name="ln4483">        spp-&gt;sp_cont_list = syn_opt_arg.cont_list;</a>
<a name="ln4484">        spp-&gt;sp_syn.cont_in_list = syn_opt_arg.cont_in_list;</a>
<a name="ln4485">        spp-&gt;sp_cchar = conceal_char;</a>
<a name="ln4486">        if (syn_opt_arg.cont_in_list != NULL)</a>
<a name="ln4487">          curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4488">        spp-&gt;sp_next_list = syn_opt_arg.next_list;</a>
<a name="ln4489"> </a>
<a name="ln4490">        /* remember that we found a match for syncing on */</a>
<a name="ln4491">        if (syn_opt_arg.flags &amp; (HL_SYNC_HERE|HL_SYNC_THERE))</a>
<a name="ln4492">          curwin-&gt;w_s-&gt;b_syn_sync_flags |= SF_MATCH;</a>
<a name="ln4493">        if (syn_opt_arg.flags &amp; HL_FOLD)</a>
<a name="ln4494">          ++curwin-&gt;w_s-&gt;b_syn_folditems;</a>
<a name="ln4495"> </a>
<a name="ln4496">        redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4497">        syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all syntax. */</a>
<a name="ln4498">        return;           /* don't free the progs and patterns now */</a>
<a name="ln4499">      }</a>
<a name="ln4500">    }</a>
<a name="ln4501">  }</a>
<a name="ln4502"> </a>
<a name="ln4503">  /*</a>
<a name="ln4504">   * Something failed, free the allocated memory.</a>
<a name="ln4505">   */</a>
<a name="ln4506">  vim_regfree(item.sp_prog);</a>
<a name="ln4507">  xfree(item.sp_pattern);</a>
<a name="ln4508">  xfree(syn_opt_arg.cont_list);</a>
<a name="ln4509">  xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4510">  xfree(syn_opt_arg.next_list);</a>
<a name="ln4511"> </a>
<a name="ln4512">  if (rest == NULL)</a>
<a name="ln4513">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln4514">}</a>
<a name="ln4515"> </a>
<a name="ln4516">/*</a>
<a name="ln4517"> * Handle &quot;:syntax region {group-name} [matchgroup={group-name}]</a>
<a name="ln4518"> *		start {start} .. [skip {skip}] end {end} .. [{options}]&quot;.</a>
<a name="ln4519"> */</a>
<a name="ln4520">static void</a>
<a name="ln4521">syn_cmd_region(</a>
<a name="ln4522">    exarg_T *eap,</a>
<a name="ln4523">    int syncing                        /* TRUE for &quot;:syntax sync region ..&quot; */</a>
<a name="ln4524">)</a>
<a name="ln4525">{</a>
<a name="ln4526">  char_u              *arg = eap-&gt;arg;</a>
<a name="ln4527">  char_u              *group_name_end;</a>
<a name="ln4528">  char_u              *rest;                    /* next arg, NULL on error */</a>
<a name="ln4529">  char_u              *key_end;</a>
<a name="ln4530">  char_u              *key = NULL;</a>
<a name="ln4531">  char_u              *p;</a>
<a name="ln4532">  int item;</a>
<a name="ln4533">#define ITEM_START          0</a>
<a name="ln4534">#define ITEM_SKIP           1</a>
<a name="ln4535">#define ITEM_END            2</a>
<a name="ln4536">#define ITEM_MATCHGROUP     3</a>
<a name="ln4537">  struct pat_ptr {</a>
<a name="ln4538">    synpat_T        *pp_synp;                   /* pointer to syn_pattern */</a>
<a name="ln4539">    int pp_matchgroup_id;                       /* matchgroup ID */</a>
<a name="ln4540">    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */</a>
<a name="ln4541">  }                   *(pat_ptrs[3]);</a>
<a name="ln4542">  /* patterns found in the line */</a>
<a name="ln4543">  struct pat_ptr      *ppp;</a>
<a name="ln4544">  struct pat_ptr      *ppp_next;</a>
<a name="ln4545">  int pat_count = 0;                            /* nr of syn_patterns found */</a>
<a name="ln4546">  int syn_id;</a>
<a name="ln4547">  int matchgroup_id = 0;</a>
<a name="ln4548">  int not_enough = FALSE;                       /* not enough arguments */</a>
<a name="ln4549">  int illegal = FALSE;                          /* illegal arguments */</a>
<a name="ln4550">  int success = FALSE;</a>
<a name="ln4551">  syn_opt_arg_T syn_opt_arg;</a>
<a name="ln4552">  int conceal_char = NUL;</a>
<a name="ln4553"> </a>
<a name="ln4554">  /* Isolate the group name, check for validity */</a>
<a name="ln4555">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4556"> </a>
<a name="ln4557">  pat_ptrs[0] = NULL;</a>
<a name="ln4558">  pat_ptrs[1] = NULL;</a>
<a name="ln4559">  pat_ptrs[2] = NULL;</a>
<a name="ln4560"> </a>
<a name="ln4561">  init_syn_patterns();</a>
<a name="ln4562"> </a>
<a name="ln4563">  syn_opt_arg.flags = 0;</a>
<a name="ln4564">  syn_opt_arg.keyword = false;</a>
<a name="ln4565">  syn_opt_arg.sync_idx = NULL;</a>
<a name="ln4566">  syn_opt_arg.has_cont_list = true;</a>
<a name="ln4567">  syn_opt_arg.cont_list = NULL;</a>
<a name="ln4568">  syn_opt_arg.cont_in_list = NULL;</a>
<a name="ln4569">  syn_opt_arg.next_list = NULL;</a>
<a name="ln4570"> </a>
<a name="ln4571">  // get the options, patterns and matchgroup.</a>
<a name="ln4572">  while (rest != NULL &amp;&amp; !ends_excmd(*rest)) {</a>
<a name="ln4573">    // Check for option arguments</a>
<a name="ln4574">    rest = get_syn_options(rest, &amp;syn_opt_arg, &amp;conceal_char, eap-&gt;skip);</a>
<a name="ln4575">    if (rest == NULL || ends_excmd(*rest)) {</a>
<a name="ln4576">      break;</a>
<a name="ln4577">    }</a>
<a name="ln4578"> </a>
<a name="ln4579">    /* must be a pattern or matchgroup then */</a>
<a name="ln4580">    key_end = rest;</a>
<a name="ln4581">    while (*key_end &amp;&amp; !ascii_iswhite(*key_end) &amp;&amp; *key_end != '=')</a>
<a name="ln4582">      ++key_end;</a>
<a name="ln4583">    xfree(key);</a>
<a name="ln4584">    key = vim_strnsave_up(rest, (int)(key_end - rest));</a>
<a name="ln4585">    if (STRCMP(key, &quot;MATCHGROUP&quot;) == 0) {</a>
<a name="ln4586">      item = ITEM_MATCHGROUP;</a>
<a name="ln4587">    } else if (STRCMP(key, &quot;START&quot;) == 0) {</a>
<a name="ln4588">      item = ITEM_START;</a>
<a name="ln4589">    } else if (STRCMP(key, &quot;END&quot;) == 0) {</a>
<a name="ln4590">      item = ITEM_END;</a>
<a name="ln4591">    } else if (STRCMP(key, &quot;SKIP&quot;) == 0) {</a>
<a name="ln4592">      if (pat_ptrs[ITEM_SKIP] != NULL) {  // One skip pattern allowed.</a>
<a name="ln4593">        illegal = true;</a>
<a name="ln4594">        break;</a>
<a name="ln4595">      }</a>
<a name="ln4596">      item = ITEM_SKIP;</a>
<a name="ln4597">    } else {</a>
<a name="ln4598">      break;</a>
<a name="ln4599">    }</a>
<a name="ln4600">    rest = skipwhite(key_end);</a>
<a name="ln4601">    if (*rest != '=') {</a>
<a name="ln4602">      rest = NULL;</a>
<a name="ln4603">      EMSG2(_(&quot;E398: Missing '=': %s&quot;), arg);</a>
<a name="ln4604">      break;</a>
<a name="ln4605">    }</a>
<a name="ln4606">    rest = skipwhite(rest + 1);</a>
<a name="ln4607">    if (*rest == NUL) {</a>
<a name="ln4608">      not_enough = TRUE;</a>
<a name="ln4609">      break;</a>
<a name="ln4610">    }</a>
<a name="ln4611"> </a>
<a name="ln4612">    if (item == ITEM_MATCHGROUP) {</a>
<a name="ln4613">      p = skiptowhite(rest);</a>
<a name="ln4614">      if ((p - rest == 4 &amp;&amp; STRNCMP(rest, &quot;NONE&quot;, 4) == 0) || eap-&gt;skip)</a>
<a name="ln4615">        matchgroup_id = 0;</a>
<a name="ln4616">      else {</a>
<a name="ln4617">        matchgroup_id = syn_check_group(rest, (int)(p - rest));</a>
<a name="ln4618">        if (matchgroup_id == 0) {</a>
<a name="ln4619">          illegal = TRUE;</a>
<a name="ln4620">          break;</a>
<a name="ln4621">        }</a>
<a name="ln4622">      }</a>
<a name="ln4623">      rest = skipwhite(p);</a>
<a name="ln4624">    } else {</a>
<a name="ln4625">      /*</a>
<a name="ln4626">       * Allocate room for a syn_pattern, and link it in the list of</a>
<a name="ln4627">       * syn_patterns for this item, at the start (because the list is</a>
<a name="ln4628">       * used from end to start).</a>
<a name="ln4629">       */</a>
<a name="ln4630">      ppp = xmalloc(sizeof(struct pat_ptr));</a>
<a name="ln4631">      ppp-&gt;pp_next = pat_ptrs[item];</a>
<a name="ln4632">      pat_ptrs[item] = ppp;</a>
<a name="ln4633">      ppp-&gt;pp_synp = xcalloc(1, sizeof(synpat_T));</a>
<a name="ln4634"> </a>
<a name="ln4635">      // Get the syntax pattern and the following offset(s).</a>
<a name="ln4636"> </a>
<a name="ln4637">      // Enable the appropriate \z specials.</a>
<a name="ln4638">      if (item == ITEM_START) {</a>
<a name="ln4639">        reg_do_extmatch = REX_SET;</a>
<a name="ln4640">      } else {</a>
<a name="ln4641">        assert(item == ITEM_SKIP || item == ITEM_END);</a>
<a name="ln4642">        reg_do_extmatch = REX_USE;</a>
<a name="ln4643">      }</a>
<a name="ln4644">      rest = get_syn_pattern(rest, ppp-&gt;pp_synp);</a>
<a name="ln4645">      reg_do_extmatch = 0;</a>
<a name="ln4646">      if (item == ITEM_END &amp;&amp; vim_regcomp_had_eol()</a>
<a name="ln4647">          &amp;&amp; !(syn_opt_arg.flags &amp; HL_EXCLUDENL)) {</a>
<a name="ln4648">        ppp-&gt;pp_synp-&gt;sp_flags |= HL_HAS_EOL;</a>
<a name="ln4649">      }</a>
<a name="ln4650">      ppp-&gt;pp_matchgroup_id = matchgroup_id;</a>
<a name="ln4651">      pat_count++;</a>
<a name="ln4652">    }</a>
<a name="ln4653">  }</a>
<a name="ln4654">  xfree(key);</a>
<a name="ln4655">  if (illegal || not_enough)</a>
<a name="ln4656">    rest = NULL;</a>
<a name="ln4657"> </a>
<a name="ln4658">  // Must have a &quot;start&quot; and &quot;end&quot; pattern.</a>
<a name="ln4659">  if (rest != NULL &amp;&amp; (pat_ptrs[ITEM_START] == NULL</a>
<a name="ln4660">                       || pat_ptrs[ITEM_END] == NULL)) {</a>
<a name="ln4661">    not_enough = true;</a>
<a name="ln4662">    rest = NULL;</a>
<a name="ln4663">  }</a>
<a name="ln4664"> </a>
<a name="ln4665">  if (rest != NULL) {</a>
<a name="ln4666">    /*</a>
<a name="ln4667">     * Check for trailing garbage or command.</a>
<a name="ln4668">     * If OK, add the item.</a>
<a name="ln4669">     */</a>
<a name="ln4670">    eap-&gt;nextcmd = check_nextcmd(rest);</a>
<a name="ln4671">    if (!ends_excmd(*rest) || eap-&gt;skip)</a>
<a name="ln4672">      rest = NULL;</a>
<a name="ln4673">    else {</a>
<a name="ln4674">      ga_grow(&amp;(curwin-&gt;w_s-&gt;b_syn_patterns), pat_count);</a>
<a name="ln4675">      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {</a>
<a name="ln4676">        syn_incl_toplevel(syn_id, &amp;syn_opt_arg.flags);</a>
<a name="ln4677">        /*</a>
<a name="ln4678">         * Store the start/skip/end in the syn_items list</a>
<a name="ln4679">         */</a>
<a name="ln4680">        int idx = curwin-&gt;w_s-&gt;b_syn_patterns.ga_len;</a>
<a name="ln4681">        for (item = ITEM_START; item &lt;= ITEM_END; ++item) {</a>
<a name="ln4682">          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp-&gt;pp_next) {</a>
<a name="ln4683">            SYN_ITEMS(curwin-&gt;w_s)[idx] = *(ppp-&gt;pp_synp);</a>
<a name="ln4684">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syncing = syncing;</a>
<a name="ln4685">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_type =</a>
<a name="ln4686">              (item == ITEM_START) ? SPTYPE_START :</a>
<a name="ln4687">              (item == ITEM_SKIP) ? SPTYPE_SKIP : SPTYPE_END;</a>
<a name="ln4688">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_flags |= syn_opt_arg.flags;</a>
<a name="ln4689">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.id = syn_id;</a>
<a name="ln4690">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.inc_tag =</a>
<a name="ln4691">              current_syn_inc_tag;</a>
<a name="ln4692">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn_match_id =</a>
<a name="ln4693">              ppp-&gt;pp_matchgroup_id;</a>
<a name="ln4694">            SYN_ITEMS(curwin-&gt;w_s)[idx].sp_cchar = conceal_char;</a>
<a name="ln4695">            if (item == ITEM_START) {</a>
<a name="ln4696">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_cont_list =</a>
<a name="ln4697">                syn_opt_arg.cont_list;</a>
<a name="ln4698">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_syn.cont_in_list =</a>
<a name="ln4699">                syn_opt_arg.cont_in_list;</a>
<a name="ln4700">              if (syn_opt_arg.cont_in_list != NULL)</a>
<a name="ln4701">                curwin-&gt;w_s-&gt;b_syn_containedin = TRUE;</a>
<a name="ln4702">              SYN_ITEMS(curwin-&gt;w_s)[idx].sp_next_list =</a>
<a name="ln4703">                syn_opt_arg.next_list;</a>
<a name="ln4704">            }</a>
<a name="ln4705">            ++curwin-&gt;w_s-&gt;b_syn_patterns.ga_len;</a>
<a name="ln4706">            ++idx;</a>
<a name="ln4707">            if (syn_opt_arg.flags &amp; HL_FOLD)</a>
<a name="ln4708">              ++curwin-&gt;w_s-&gt;b_syn_folditems;</a>
<a name="ln4709">          }</a>
<a name="ln4710">        }</a>
<a name="ln4711"> </a>
<a name="ln4712">        redraw_curbuf_later(SOME_VALID);</a>
<a name="ln4713">        syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all syntax. */</a>
<a name="ln4714">        success = TRUE;               /* don't free the progs and patterns now */</a>
<a name="ln4715">      }</a>
<a name="ln4716">    }</a>
<a name="ln4717">  }</a>
<a name="ln4718"> </a>
<a name="ln4719">  /*</a>
<a name="ln4720">   * Free the allocated memory.</a>
<a name="ln4721">   */</a>
<a name="ln4722">  for (item = ITEM_START; item &lt;= ITEM_END; ++item)</a>
<a name="ln4723">    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {</a>
<a name="ln4724">      if (!success &amp;&amp; ppp-&gt;pp_synp != NULL) {</a>
<a name="ln4725">        vim_regfree(ppp-&gt;pp_synp-&gt;sp_prog);</a>
<a name="ln4726">        xfree(ppp-&gt;pp_synp-&gt;sp_pattern);</a>
<a name="ln4727">      }</a>
<a name="ln4728">      xfree(ppp-&gt;pp_synp);</a>
<a name="ln4729">      ppp_next = ppp-&gt;pp_next;</a>
<a name="ln4730">      xfree(ppp);</a>
<a name="ln4731">    }</a>
<a name="ln4732"> </a>
<a name="ln4733">  if (!success) {</a>
<a name="ln4734">    xfree(syn_opt_arg.cont_list);</a>
<a name="ln4735">    xfree(syn_opt_arg.cont_in_list);</a>
<a name="ln4736">    xfree(syn_opt_arg.next_list);</a>
<a name="ln4737">    if (not_enough)</a>
<a name="ln4738">      EMSG2(_(&quot;E399: Not enough arguments: syntax region %s&quot;), arg);</a>
<a name="ln4739">    else if (illegal || rest == NULL)</a>
<a name="ln4740">      EMSG2(_(e_invarg2), arg);</a>
<a name="ln4741">  }</a>
<a name="ln4742">}</a>
<a name="ln4743"> </a>
<a name="ln4744">// A simple syntax group ID comparison function suitable for use in qsort()</a>
<a name="ln4745">static int syn_compare_stub(const void *const v1, const void *const v2)</a>
<a name="ln4746">{</a>
<a name="ln4747">  const int16_t *const s1 = v1;</a>
<a name="ln4748">  const int16_t *const s2 = v2;</a>
<a name="ln4749"> </a>
<a name="ln4750">  return *s1 &gt; *s2 ? 1 : *s1 &lt; *s2 ? -1 : 0;</a>
<a name="ln4751">}</a>
<a name="ln4752"> </a>
<a name="ln4753">// Combines lists of syntax clusters.</a>
<a name="ln4754">// *clstr1 and *clstr2 must both be allocated memory; they will be consumed.</a>
<a name="ln4755">static void syn_combine_list(int16_t **const clstr1, int16_t **const clstr2,</a>
<a name="ln4756">                             const int list_op)</a>
<a name="ln4757">{</a>
<a name="ln4758">  size_t count1 = 0;</a>
<a name="ln4759">  size_t count2 = 0;</a>
<a name="ln4760">  const int16_t *g1;</a>
<a name="ln4761">  const int16_t *g2;</a>
<a name="ln4762">  int16_t *clstr = NULL;</a>
<a name="ln4763"> </a>
<a name="ln4764">  /*</a>
<a name="ln4765">   * Handle degenerate cases.</a>
<a name="ln4766">   */</a>
<a name="ln4767">  if (*clstr2 == NULL)</a>
<a name="ln4768">    return;</a>
<a name="ln4769">  if (*clstr1 == NULL || list_op == CLUSTER_REPLACE) {</a>
<a name="ln4770">    if (list_op == CLUSTER_REPLACE)</a>
<a name="ln4771">      xfree(*clstr1);</a>
<a name="ln4772">    if (list_op == CLUSTER_REPLACE || list_op == CLUSTER_ADD)</a>
<a name="ln4773">      *clstr1 = *clstr2;</a>
<a name="ln4774">    else</a>
<a name="ln4775">      xfree(*clstr2);</a>
<a name="ln4776">    return;</a>
<a name="ln4777">  }</a>
<a name="ln4778"> </a>
<a name="ln4779">  for (g1 = *clstr1; *g1; g1++) {</a>
<a name="ln4780">    count1++;</a>
<a name="ln4781">  }</a>
<a name="ln4782">  for (g2 = *clstr2; *g2; g2++) {</a>
<a name="ln4783">    count2++;</a>
<a name="ln4784">  }</a>
<a name="ln4785"> </a>
<a name="ln4786">  // For speed purposes, sort both lists.</a>
<a name="ln4787">  qsort(*clstr1, count1, sizeof(**clstr1), syn_compare_stub);</a>
<a name="ln4788">  qsort(*clstr2, count2, sizeof(**clstr2), syn_compare_stub);</a>
<a name="ln4789"> </a>
<a name="ln4790">  // We proceed in two passes; in round 1, we count the elements to place</a>
<a name="ln4791">  // in the new list, and in round 2, we allocate and populate the new</a>
<a name="ln4792">  // list.  For speed, we use a mergesort-like method, adding the smaller</a>
<a name="ln4793">  // of the current elements in each list to the new list.</a>
<a name="ln4794">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln4795">    g1 = *clstr1;</a>
<a name="ln4796">    g2 = *clstr2;</a>
<a name="ln4797">    int count = 0;</a>
<a name="ln4798"> </a>
<a name="ln4799">    /*</a>
<a name="ln4800">     * First, loop through the lists until one of them is empty.</a>
<a name="ln4801">     */</a>
<a name="ln4802">    while (*g1 &amp;&amp; *g2) {</a>
<a name="ln4803">      /*</a>
<a name="ln4804">       * We always want to add from the first list.</a>
<a name="ln4805">       */</a>
<a name="ln4806">      if (*g1 &lt; *g2) {</a>
<a name="ln4807">        if (round == 2)</a>
<a name="ln4808">          clstr[count] = *g1;</a>
<a name="ln4809">        count++;</a>
<a name="ln4810">        g1++;</a>
<a name="ln4811">        continue;</a>
<a name="ln4812">      }</a>
<a name="ln4813">      /*</a>
<a name="ln4814">       * We only want to add from the second list if we're adding the</a>
<a name="ln4815">       * lists.</a>
<a name="ln4816">       */</a>
<a name="ln4817">      if (list_op == CLUSTER_ADD) {</a>
<a name="ln4818">        if (round == 2)</a>
<a name="ln4819">          clstr[count] = *g2;</a>
<a name="ln4820">        count++;</a>
<a name="ln4821">      }</a>
<a name="ln4822">      if (*g1 == *g2)</a>
<a name="ln4823">        g1++;</a>
<a name="ln4824">      g2++;</a>
<a name="ln4825">    }</a>
<a name="ln4826"> </a>
<a name="ln4827">    /*</a>
<a name="ln4828">     * Now add the leftovers from whichever list didn't get finished</a>
<a name="ln4829">     * first.  As before, we only want to add from the second list if</a>
<a name="ln4830">     * we're adding the lists.</a>
<a name="ln4831">     */</a>
<a name="ln4832">    for (; *g1; g1++, count++)</a>
<a name="ln4833">      if (round == 2)</a>
<a name="ln4834">        clstr[count] = *g1;</a>
<a name="ln4835">    if (list_op == CLUSTER_ADD)</a>
<a name="ln4836">      for (; *g2; g2++, count++)</a>
<a name="ln4837">        if (round == 2)</a>
<a name="ln4838">          clstr[count] = *g2;</a>
<a name="ln4839"> </a>
<a name="ln4840">    if (round == 1) {</a>
<a name="ln4841">      /*</a>
<a name="ln4842">       * If the group ended up empty, we don't need to allocate any</a>
<a name="ln4843">       * space for it.</a>
<a name="ln4844">       */</a>
<a name="ln4845">      if (count == 0) {</a>
<a name="ln4846">        clstr = NULL;</a>
<a name="ln4847">        break;</a>
<a name="ln4848">      }</a>
<a name="ln4849">      clstr = xmalloc((count + 1) * sizeof(*clstr));</a>
<a name="ln4850">      clstr[count] = 0;</a>
<a name="ln4851">    }</a>
<a name="ln4852">  }</a>
<a name="ln4853"> </a>
<a name="ln4854">  /*</a>
<a name="ln4855">   * Finally, put the new list in place.</a>
<a name="ln4856">   */</a>
<a name="ln4857">  xfree(*clstr1);</a>
<a name="ln4858">  xfree(*clstr2);</a>
<a name="ln4859">  *clstr1 = clstr;</a>
<a name="ln4860">}</a>
<a name="ln4861"> </a>
<a name="ln4862">// Lookup a syntax cluster name and return its ID.</a>
<a name="ln4863">// If it is not found, 0 is returned.</a>
<a name="ln4864">static int syn_scl_name2id(char_u *name)</a>
<a name="ln4865">{</a>
<a name="ln4866">  // Avoid using stricmp() too much, it's slow on some systems</a>
<a name="ln4867">  char_u *name_u = vim_strsave_up(name);</a>
<a name="ln4868">  int i;</a>
<a name="ln4869">  for (i = curwin-&gt;w_s-&gt;b_syn_clusters.ga_len; --i &gt;= 0; ) {</a>
<a name="ln4870">    if (SYN_CLSTR(curwin-&gt;w_s)[i].scl_name_u != NULL</a>
<a name="ln4871">        &amp;&amp; STRCMP(name_u, SYN_CLSTR(curwin-&gt;w_s)[i].scl_name_u) == 0) {</a>
<a name="ln4872">      break;</a>
<a name="ln4873">    }</a>
<a name="ln4874">  }</a>
<a name="ln4875">  xfree(name_u);</a>
<a name="ln4876">  return i &lt; 0 ? 0 : i + SYNID_CLUSTER;</a>
<a name="ln4877">}</a>
<a name="ln4878"> </a>
<a name="ln4879">/*</a>
<a name="ln4880"> * Like syn_scl_name2id(), but take a pointer + length argument.</a>
<a name="ln4881"> */</a>
<a name="ln4882">static int syn_scl_namen2id(char_u *linep, int len)</a>
<a name="ln4883">{</a>
<a name="ln4884">  char_u *name = vim_strnsave(linep, len);</a>
<a name="ln4885">  int id = syn_scl_name2id(name);</a>
<a name="ln4886">  xfree(name);</a>
<a name="ln4887"> </a>
<a name="ln4888">  return id;</a>
<a name="ln4889">}</a>
<a name="ln4890"> </a>
<a name="ln4891">// Find syntax cluster name in the table and return its ID.</a>
<a name="ln4892">// The argument is a pointer to the name and the length of the name.</a>
<a name="ln4893">// If it doesn't exist yet, a new entry is created.</a>
<a name="ln4894">// Return 0 for failure.</a>
<a name="ln4895">static int syn_check_cluster(char_u *pp, int len)</a>
<a name="ln4896">{</a>
<a name="ln4897">  int id;</a>
<a name="ln4898">  char_u      *name;</a>
<a name="ln4899"> </a>
<a name="ln4900">  name = vim_strnsave(pp, len);</a>
<a name="ln4901"> </a>
<a name="ln4902">  id = syn_scl_name2id(name);</a>
<a name="ln4903">  if (id == 0)                          /* doesn't exist yet */</a>
<a name="ln4904">    id = syn_add_cluster(name);</a>
<a name="ln4905">  else</a>
<a name="ln4906">    xfree(name);</a>
<a name="ln4907">  return id;</a>
<a name="ln4908">}</a>
<a name="ln4909"> </a>
<a name="ln4910">// Add new syntax cluster and return its ID.</a>
<a name="ln4911">// &quot;name&quot; must be an allocated string, it will be consumed.</a>
<a name="ln4912">// Return 0 for failure.</a>
<a name="ln4913">static int syn_add_cluster(char_u *name)</a>
<a name="ln4914">{</a>
<a name="ln4915">  /*</a>
<a name="ln4916">   * First call for this growarray: init growing array.</a>
<a name="ln4917">   */</a>
<a name="ln4918">  if (curwin-&gt;w_s-&gt;b_syn_clusters.ga_data == NULL) {</a>
<a name="ln4919">    curwin-&gt;w_s-&gt;b_syn_clusters.ga_itemsize = sizeof(syn_cluster_T);</a>
<a name="ln4920">    ga_set_growsize(&amp;curwin-&gt;w_s-&gt;b_syn_clusters, 10);</a>
<a name="ln4921">  }</a>
<a name="ln4922"> </a>
<a name="ln4923">  int len = curwin-&gt;w_s-&gt;b_syn_clusters.ga_len;</a>
<a name="ln4924">  if (len &gt;= MAX_CLUSTER_ID) {</a>
<a name="ln4925">    EMSG((char_u *)_(&quot;E848: Too many syntax clusters&quot;));</a>
<a name="ln4926">    xfree(name);</a>
<a name="ln4927">    return 0;</a>
<a name="ln4928">  }</a>
<a name="ln4929"> </a>
<a name="ln4930">  syn_cluster_T *scp = GA_APPEND_VIA_PTR(syn_cluster_T,</a>
<a name="ln4931">                                         &amp;curwin-&gt;w_s-&gt;b_syn_clusters);</a>
<a name="ln4932">  memset(scp, 0, sizeof(*scp));</a>
<a name="ln4933">  scp-&gt;scl_name = name;</a>
<a name="ln4934">  scp-&gt;scl_name_u = vim_strsave_up(name);</a>
<a name="ln4935">  scp-&gt;scl_list = NULL;</a>
<a name="ln4936"> </a>
<a name="ln4937">  if (STRICMP(name, &quot;Spell&quot;) == 0)</a>
<a name="ln4938">    curwin-&gt;w_s-&gt;b_spell_cluster_id = len + SYNID_CLUSTER;</a>
<a name="ln4939">  if (STRICMP(name, &quot;NoSpell&quot;) == 0)</a>
<a name="ln4940">    curwin-&gt;w_s-&gt;b_nospell_cluster_id = len + SYNID_CLUSTER;</a>
<a name="ln4941"> </a>
<a name="ln4942">  return len + SYNID_CLUSTER;</a>
<a name="ln4943">}</a>
<a name="ln4944"> </a>
<a name="ln4945">/*</a>
<a name="ln4946"> * Handle &quot;:syntax cluster {cluster-name} [contains={groupname},..]</a>
<a name="ln4947"> *		[add={groupname},..] [remove={groupname},..]&quot;.</a>
<a name="ln4948"> */</a>
<a name="ln4949">static void syn_cmd_cluster(exarg_T *eap, int syncing)</a>
<a name="ln4950">{</a>
<a name="ln4951">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln4952">  char_u      *group_name_end;</a>
<a name="ln4953">  char_u      *rest;</a>
<a name="ln4954">  bool got_clstr = false;</a>
<a name="ln4955">  int opt_len;</a>
<a name="ln4956">  int list_op;</a>
<a name="ln4957"> </a>
<a name="ln4958">  eap-&gt;nextcmd = find_nextcmd(arg);</a>
<a name="ln4959">  if (eap-&gt;skip)</a>
<a name="ln4960">    return;</a>
<a name="ln4961"> </a>
<a name="ln4962">  rest = get_group_name(arg, &amp;group_name_end);</a>
<a name="ln4963"> </a>
<a name="ln4964">  if (rest != NULL) {</a>
<a name="ln4965">    int scl_id = syn_check_cluster(arg, (int)(group_name_end - arg));</a>
<a name="ln4966">    if (scl_id == 0) {</a>
<a name="ln4967">      return;</a>
<a name="ln4968">    }</a>
<a name="ln4969">    scl_id -= SYNID_CLUSTER;</a>
<a name="ln4970"> </a>
<a name="ln4971">    for (;; ) {</a>
<a name="ln4972">      if (STRNICMP(rest, &quot;add&quot;, 3) == 0</a>
<a name="ln4973">          &amp;&amp; (ascii_iswhite(rest[3]) || rest[3] == '=')) {</a>
<a name="ln4974">        opt_len = 3;</a>
<a name="ln4975">        list_op = CLUSTER_ADD;</a>
<a name="ln4976">      } else if (STRNICMP(rest, &quot;remove&quot;, 6) == 0</a>
<a name="ln4977">                 &amp;&amp; (ascii_iswhite(rest[6]) || rest[6] == '=')) {</a>
<a name="ln4978">        opt_len = 6;</a>
<a name="ln4979">        list_op = CLUSTER_SUBTRACT;</a>
<a name="ln4980">      } else if (STRNICMP(rest, &quot;contains&quot;, 8) == 0</a>
<a name="ln4981">                 &amp;&amp; (ascii_iswhite(rest[8]) || rest[8] == '=')) {</a>
<a name="ln4982">        opt_len = 8;</a>
<a name="ln4983">        list_op = CLUSTER_REPLACE;</a>
<a name="ln4984">      } else</a>
<a name="ln4985">        break;</a>
<a name="ln4986"> </a>
<a name="ln4987">      int16_t *clstr_list = NULL;</a>
<a name="ln4988">      if (get_id_list(&amp;rest, opt_len, &amp;clstr_list, eap-&gt;skip) == FAIL) {</a>
<a name="ln4989">        EMSG2(_(e_invarg2), rest);</a>
<a name="ln4990">        break;</a>
<a name="ln4991">      }</a>
<a name="ln4992">      if (scl_id &gt;= 0) {</a>
<a name="ln4993">        syn_combine_list(&amp;SYN_CLSTR(curwin-&gt;w_s)[scl_id].scl_list,</a>
<a name="ln4994">                         &amp;clstr_list, list_op);</a>
<a name="ln4995">      } else {</a>
<a name="ln4996">        xfree(clstr_list);</a>
<a name="ln4997">      }</a>
<a name="ln4998">      got_clstr = true;</a>
<a name="ln4999">    }</a>
<a name="ln5000"> </a>
<a name="ln5001">    if (got_clstr) {</a>
<a name="ln5002">      redraw_curbuf_later(SOME_VALID);</a>
<a name="ln5003">      syn_stack_free_all(curwin-&gt;w_s);          /* Need to recompute all. */</a>
<a name="ln5004">    }</a>
<a name="ln5005">  }</a>
<a name="ln5006"> </a>
<a name="ln5007">  if (!got_clstr)</a>
<a name="ln5008">    EMSG(_(&quot;E400: No cluster specified&quot;));</a>
<a name="ln5009">  if (rest == NULL || !ends_excmd(*rest))</a>
<a name="ln5010">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln5011">}</a>
<a name="ln5012"> </a>
<a name="ln5013">/*</a>
<a name="ln5014"> * On first call for current buffer: Init growing array.</a>
<a name="ln5015"> */</a>
<a name="ln5016">static void init_syn_patterns(void)</a>
<a name="ln5017">{</a>
<a name="ln5018">  curwin-&gt;w_s-&gt;b_syn_patterns.ga_itemsize = sizeof(synpat_T);</a>
<a name="ln5019">  ga_set_growsize(&amp;curwin-&gt;w_s-&gt;b_syn_patterns, 10);</a>
<a name="ln5020">}</a>
<a name="ln5021"> </a>
<a name="ln5022">/*</a>
<a name="ln5023"> * Get one pattern for a &quot;:syntax match&quot; or &quot;:syntax region&quot; command.</a>
<a name="ln5024"> * Stores the pattern and program in a synpat_T.</a>
<a name="ln5025"> * Returns a pointer to the next argument, or NULL in case of an error.</a>
<a name="ln5026"> */</a>
<a name="ln5027">static char_u *get_syn_pattern(char_u *arg, synpat_T *ci)</a>
<a name="ln5028">{</a>
<a name="ln5029">  char_u      *end;</a>
<a name="ln5030">  int         *p;</a>
<a name="ln5031">  int idx;</a>
<a name="ln5032">  char_u      *cpo_save;</a>
<a name="ln5033"> </a>
<a name="ln5034">  // need at least three chars</a>
<a name="ln5035">  if (arg == NULL || arg[0] == NUL || arg[1] == NUL || arg[2] == NUL) {</a>
<a name="ln5036">    return NULL;</a>
<a name="ln5037">  }</a>
<a name="ln5038"> </a>
<a name="ln5039">  end = skip_regexp(arg + 1, *arg, TRUE, NULL);</a>
<a name="ln5040">  if (*end != *arg) {                       /* end delimiter not found */</a>
<a name="ln5041">    EMSG2(_(&quot;E401: Pattern delimiter not found: %s&quot;), arg);</a>
<a name="ln5042">    return NULL;</a>
<a name="ln5043">  }</a>
<a name="ln5044">  /* store the pattern and compiled regexp program */</a>
<a name="ln5045">  ci-&gt;sp_pattern = vim_strnsave(arg + 1, (int)(end - arg - 1));</a>
<a name="ln5046"> </a>
<a name="ln5047">  /* Make 'cpoptions' empty, to avoid the 'l' flag */</a>
<a name="ln5048">  cpo_save = p_cpo;</a>
<a name="ln5049">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5050">  ci-&gt;sp_prog = vim_regcomp(ci-&gt;sp_pattern, RE_MAGIC);</a>
<a name="ln5051">  p_cpo = cpo_save;</a>
<a name="ln5052"> </a>
<a name="ln5053">  if (ci-&gt;sp_prog == NULL)</a>
<a name="ln5054">    return NULL;</a>
<a name="ln5055">  ci-&gt;sp_ic = curwin-&gt;w_s-&gt;b_syn_ic;</a>
<a name="ln5056">  syn_clear_time(&amp;ci-&gt;sp_time);</a>
<a name="ln5057"> </a>
<a name="ln5058">  /*</a>
<a name="ln5059">   * Check for a match, highlight or region offset.</a>
<a name="ln5060">   */</a>
<a name="ln5061">  ++end;</a>
<a name="ln5062">  do {</a>
<a name="ln5063">    for (idx = SPO_COUNT; --idx &gt;= 0; )</a>
<a name="ln5064">      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)</a>
<a name="ln5065">        break;</a>
<a name="ln5066">    if (idx &gt;= 0) {</a>
<a name="ln5067">      p = &amp;(ci-&gt;sp_offsets[idx]);</a>
<a name="ln5068">      if (idx != SPO_LC_OFF)</a>
<a name="ln5069">        switch (end[3]) {</a>
<a name="ln5070">        case 's':   break;</a>
<a name="ln5071">        case 'b':   break;</a>
<a name="ln5072">        case 'e':   idx += SPO_COUNT; break;</a>
<a name="ln5073">        default:    idx = -1; break;</a>
<a name="ln5074">        }</a>
<a name="ln5075">      if (idx &gt;= 0) {</a>
<a name="ln5076">        ci-&gt;sp_off_flags |= (1 &lt;&lt; idx);</a>
<a name="ln5077">        if (idx == SPO_LC_OFF) {            /* lc=99 */</a>
<a name="ln5078">          end += 3;</a>
<a name="ln5079">          *p = getdigits_int(&amp;end, true, 0);</a>
<a name="ln5080"> </a>
<a name="ln5081">          /* &quot;lc=&quot; offset automatically sets &quot;ms=&quot; offset */</a>
<a name="ln5082">          if (!(ci-&gt;sp_off_flags &amp; (1 &lt;&lt; SPO_MS_OFF))) {</a>
<a name="ln5083">            ci-&gt;sp_off_flags |= (1 &lt;&lt; SPO_MS_OFF);</a>
<a name="ln5084">            ci-&gt;sp_offsets[SPO_MS_OFF] = *p;</a>
<a name="ln5085">          }</a>
<a name="ln5086">        } else {                          /* yy=x+99 */</a>
<a name="ln5087">          end += 4;</a>
<a name="ln5088">          if (*end == '+') {</a>
<a name="ln5089">            end++;</a>
<a name="ln5090">            *p = getdigits_int(&amp;end, true, 0);    // positive offset</a>
<a name="ln5091">          } else if (*end == '-')   {</a>
<a name="ln5092">            end++;</a>
<a name="ln5093">            *p = -getdigits_int(&amp;end, true, 0);   // negative offset</a>
<a name="ln5094">          }</a>
<a name="ln5095">        }</a>
<a name="ln5096">        if (*end != ',')</a>
<a name="ln5097">          break;</a>
<a name="ln5098">        ++end;</a>
<a name="ln5099">      }</a>
<a name="ln5100">    }</a>
<a name="ln5101">  } while (idx &gt;= 0);</a>
<a name="ln5102"> </a>
<a name="ln5103">  if (!ends_excmd(*end) &amp;&amp; !ascii_iswhite(*end)) {</a>
<a name="ln5104">    EMSG2(_(&quot;E402: Garbage after pattern: %s&quot;), arg);</a>
<a name="ln5105">    return NULL;</a>
<a name="ln5106">  }</a>
<a name="ln5107">  return skipwhite(end);</a>
<a name="ln5108">}</a>
<a name="ln5109"> </a>
<a name="ln5110">/*</a>
<a name="ln5111"> * Handle &quot;:syntax sync ..&quot; command.</a>
<a name="ln5112"> */</a>
<a name="ln5113">static void syn_cmd_sync(exarg_T *eap, int syncing)</a>
<a name="ln5114">{</a>
<a name="ln5115">  char_u      *arg_start = eap-&gt;arg;</a>
<a name="ln5116">  char_u      *arg_end;</a>
<a name="ln5117">  char_u      *key = NULL;</a>
<a name="ln5118">  char_u      *next_arg;</a>
<a name="ln5119">  int illegal = FALSE;</a>
<a name="ln5120">  int finished = FALSE;</a>
<a name="ln5121">  long n;</a>
<a name="ln5122">  char_u      *cpo_save;</a>
<a name="ln5123"> </a>
<a name="ln5124">  if (ends_excmd(*arg_start)) {</a>
<a name="ln5125">    syn_cmd_list(eap, TRUE);</a>
<a name="ln5126">    return;</a>
<a name="ln5127">  }</a>
<a name="ln5128"> </a>
<a name="ln5129">  while (!ends_excmd(*arg_start)) {</a>
<a name="ln5130">    arg_end = skiptowhite(arg_start);</a>
<a name="ln5131">    next_arg = skipwhite(arg_end);</a>
<a name="ln5132">    xfree(key);</a>
<a name="ln5133">    key = vim_strnsave_up(arg_start, (int)(arg_end - arg_start));</a>
<a name="ln5134">    if (STRCMP(key, &quot;CCOMMENT&quot;) == 0) {</a>
<a name="ln5135">      if (!eap-&gt;skip)</a>
<a name="ln5136">        curwin-&gt;w_s-&gt;b_syn_sync_flags |= SF_CCOMMENT;</a>
<a name="ln5137">      if (!ends_excmd(*next_arg)) {</a>
<a name="ln5138">        arg_end = skiptowhite(next_arg);</a>
<a name="ln5139">        if (!eap-&gt;skip)</a>
<a name="ln5140">          curwin-&gt;w_s-&gt;b_syn_sync_id = syn_check_group(next_arg,</a>
<a name="ln5141">              (int)(arg_end - next_arg));</a>
<a name="ln5142">        next_arg = skipwhite(arg_end);</a>
<a name="ln5143">      } else if (!eap-&gt;skip)</a>
<a name="ln5144">        curwin-&gt;w_s-&gt;b_syn_sync_id = syn_name2id((char_u *)&quot;Comment&quot;);</a>
<a name="ln5145">    } else if (  STRNCMP(key, &quot;LINES&quot;, 5) == 0</a>
<a name="ln5146">                 || STRNCMP(key, &quot;MINLINES&quot;, 8) == 0</a>
<a name="ln5147">                 || STRNCMP(key, &quot;MAXLINES&quot;, 8) == 0</a>
<a name="ln5148">                 || STRNCMP(key, &quot;LINEBREAKS&quot;, 10) == 0) {</a>
<a name="ln5149">      if (key[4] == 'S')</a>
<a name="ln5150">        arg_end = key + 6;</a>
<a name="ln5151">      else if (key[0] == 'L')</a>
<a name="ln5152">        arg_end = key + 11;</a>
<a name="ln5153">      else</a>
<a name="ln5154">        arg_end = key + 9;</a>
<a name="ln5155">      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {</a>
<a name="ln5156">        illegal = TRUE;</a>
<a name="ln5157">        break;</a>
<a name="ln5158">      }</a>
<a name="ln5159">      n = getdigits_long(&amp;arg_end, false, 0);</a>
<a name="ln5160">      if (!eap-&gt;skip) {</a>
<a name="ln5161">        if (key[4] == 'B')</a>
<a name="ln5162">          curwin-&gt;w_s-&gt;b_syn_sync_linebreaks = n;</a>
<a name="ln5163">        else if (key[1] == 'A')</a>
<a name="ln5164">          curwin-&gt;w_s-&gt;b_syn_sync_maxlines = n;</a>
<a name="ln5165">        else</a>
<a name="ln5166">          curwin-&gt;w_s-&gt;b_syn_sync_minlines = n;</a>
<a name="ln5167">      }</a>
<a name="ln5168">    } else if (STRCMP(key, &quot;FROMSTART&quot;) == 0)   {</a>
<a name="ln5169">      if (!eap-&gt;skip) {</a>
<a name="ln5170">        curwin-&gt;w_s-&gt;b_syn_sync_minlines = MAXLNUM;</a>
<a name="ln5171">        curwin-&gt;w_s-&gt;b_syn_sync_maxlines = 0;</a>
<a name="ln5172">      }</a>
<a name="ln5173">    } else if (STRCMP(key, &quot;LINECONT&quot;) == 0)   {</a>
<a name="ln5174">      if (*next_arg == NUL) {  // missing pattern</a>
<a name="ln5175">        illegal = true;</a>
<a name="ln5176">        break;</a>
<a name="ln5177">      }</a>
<a name="ln5178">      if (curwin-&gt;w_s-&gt;b_syn_linecont_pat != NULL) {</a>
<a name="ln5179">        EMSG(_(&quot;E403: syntax sync: line continuations pattern specified twice&quot;));</a>
<a name="ln5180">        finished = TRUE;</a>
<a name="ln5181">        break;</a>
<a name="ln5182">      }</a>
<a name="ln5183">      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);</a>
<a name="ln5184">      if (*arg_end != *next_arg) {          /* end delimiter not found */</a>
<a name="ln5185">        illegal = TRUE;</a>
<a name="ln5186">        break;</a>
<a name="ln5187">      }</a>
<a name="ln5188"> </a>
<a name="ln5189">      if (!eap-&gt;skip) {</a>
<a name="ln5190">        /* store the pattern and compiled regexp program */</a>
<a name="ln5191">        curwin-&gt;w_s-&gt;b_syn_linecont_pat =</a>
<a name="ln5192">          vim_strnsave(next_arg + 1, (int)(arg_end - next_arg - 1));</a>
<a name="ln5193">        curwin-&gt;w_s-&gt;b_syn_linecont_ic = curwin-&gt;w_s-&gt;b_syn_ic;</a>
<a name="ln5194"> </a>
<a name="ln5195">        /* Make 'cpoptions' empty, to avoid the 'l' flag */</a>
<a name="ln5196">        cpo_save = p_cpo;</a>
<a name="ln5197">        p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5198">        curwin-&gt;w_s-&gt;b_syn_linecont_prog =</a>
<a name="ln5199">          vim_regcomp(curwin-&gt;w_s-&gt;b_syn_linecont_pat, RE_MAGIC);</a>
<a name="ln5200">        p_cpo = cpo_save;</a>
<a name="ln5201">        syn_clear_time(&amp;curwin-&gt;w_s-&gt;b_syn_linecont_time);</a>
<a name="ln5202"> </a>
<a name="ln5203">        if (curwin-&gt;w_s-&gt;b_syn_linecont_prog == NULL) {</a>
<a name="ln5204">          XFREE_CLEAR(curwin-&gt;w_s-&gt;b_syn_linecont_pat);</a>
<a name="ln5205">          finished = true;</a>
<a name="ln5206">          break;</a>
<a name="ln5207">        }</a>
<a name="ln5208">      }</a>
<a name="ln5209">      next_arg = skipwhite(arg_end + 1);</a>
<a name="ln5210">    } else {</a>
<a name="ln5211">      eap-&gt;arg = next_arg;</a>
<a name="ln5212">      if (STRCMP(key, &quot;MATCH&quot;) == 0)</a>
<a name="ln5213">        syn_cmd_match(eap, TRUE);</a>
<a name="ln5214">      else if (STRCMP(key, &quot;REGION&quot;) == 0)</a>
<a name="ln5215">        syn_cmd_region(eap, TRUE);</a>
<a name="ln5216">      else if (STRCMP(key, &quot;CLEAR&quot;) == 0)</a>
<a name="ln5217">        syn_cmd_clear(eap, TRUE);</a>
<a name="ln5218">      else</a>
<a name="ln5219">        illegal = TRUE;</a>
<a name="ln5220">      finished = TRUE;</a>
<a name="ln5221">      break;</a>
<a name="ln5222">    }</a>
<a name="ln5223">    arg_start = next_arg;</a>
<a name="ln5224">  }</a>
<a name="ln5225">  xfree(key);</a>
<a name="ln5226">  if (illegal)</a>
<a name="ln5227">    EMSG2(_(&quot;E404: Illegal arguments: %s&quot;), arg_start);</a>
<a name="ln5228">  else if (!finished) {</a>
<a name="ln5229">    eap-&gt;nextcmd = check_nextcmd(arg_start);</a>
<a name="ln5230">    redraw_curbuf_later(SOME_VALID);</a>
<a name="ln5231">    syn_stack_free_all(curwin-&gt;w_s);            /* Need to recompute all syntax. */</a>
<a name="ln5232">  }</a>
<a name="ln5233">}</a>
<a name="ln5234"> </a>
<a name="ln5235">/*</a>
<a name="ln5236"> * Convert a line of highlight group names into a list of group ID numbers.</a>
<a name="ln5237"> * &quot;arg&quot; should point to the &quot;contains&quot; or &quot;nextgroup&quot; keyword.</a>
<a name="ln5238"> * &quot;arg&quot; is advanced to after the last group name.</a>
<a name="ln5239"> * Careful: the argument is modified (NULs added).</a>
<a name="ln5240"> * returns FAIL for some error, OK for success.</a>
<a name="ln5241"> */</a>
<a name="ln5242">static int</a>
<a name="ln5243">get_id_list(</a>
<a name="ln5244">    char_u **const arg,</a>
<a name="ln5245">    const int keylen,       // length of keyword</a>
<a name="ln5246">    int16_t **const list,   // where to store the resulting list, if not</a>
<a name="ln5247">                            // NULL, the list is silently skipped!</a>
<a name="ln5248">    const bool skip</a>
<a name="ln5249">)</a>
<a name="ln5250">{</a>
<a name="ln5251">  char_u      *p = NULL;</a>
<a name="ln5252">  char_u      *end;</a>
<a name="ln5253">  int total_count = 0;</a>
<a name="ln5254">  int16_t *retval = NULL;</a>
<a name="ln5255">  regmatch_T regmatch;</a>
<a name="ln5256">  int id;</a>
<a name="ln5257">  bool failed = false;</a>
<a name="ln5258"> </a>
<a name="ln5259">  // We parse the list twice:</a>
<a name="ln5260">  // round == 1: count the number of items, allocate the array.</a>
<a name="ln5261">  // round == 2: fill the array with the items.</a>
<a name="ln5262">  // In round 1 new groups may be added, causing the number of items to</a>
<a name="ln5263">  // grow when a regexp is used.  In that case round 1 is done once again.</a>
<a name="ln5264">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln5265">    // skip &quot;contains&quot;</a>
<a name="ln5266">    p = skipwhite(*arg + keylen);</a>
<a name="ln5267">    if (*p != '=') {</a>
<a name="ln5268">      EMSG2(_(&quot;E405: Missing equal sign: %s&quot;), *arg);</a>
<a name="ln5269">      break;</a>
<a name="ln5270">    }</a>
<a name="ln5271">    p = skipwhite(p + 1);</a>
<a name="ln5272">    if (ends_excmd(*p)) {</a>
<a name="ln5273">      EMSG2(_(&quot;E406: Empty argument: %s&quot;), *arg);</a>
<a name="ln5274">      break;</a>
<a name="ln5275">    }</a>
<a name="ln5276"> </a>
<a name="ln5277">    // parse the arguments after &quot;contains&quot;</a>
<a name="ln5278">    int count = 0;</a>
<a name="ln5279">    do {</a>
<a name="ln5280">      for (end = p; *end &amp;&amp; !ascii_iswhite(*end) &amp;&amp; *end != ','; end++) {</a>
<a name="ln5281">      }</a>
<a name="ln5282">      char_u *const name = xmalloc((int)(end - p + 3));   // leave room for &quot;^$&quot;</a>
<a name="ln5283">      STRLCPY(name + 1, p, end - p + 1);</a>
<a name="ln5284">      if (       STRCMP(name + 1, &quot;ALLBUT&quot;) == 0</a>
<a name="ln5285">                 || STRCMP(name + 1, &quot;ALL&quot;) == 0</a>
<a name="ln5286">                 || STRCMP(name + 1, &quot;TOP&quot;) == 0</a>
<a name="ln5287">                 || STRCMP(name + 1, &quot;CONTAINED&quot;) == 0) {</a>
<a name="ln5288">        if (TOUPPER_ASC(**arg) != 'C') {</a>
<a name="ln5289">          EMSG2(_(&quot;E407: %s not allowed here&quot;), name + 1);</a>
<a name="ln5290">          failed = true;</a>
<a name="ln5291">          xfree(name);</a>
<a name="ln5292">          break;</a>
<a name="ln5293">        }</a>
<a name="ln5294">        if (count != 0) {</a>
<a name="ln5295">          EMSG2(_(&quot;E408: %s must be first in contains list&quot;),</a>
<a name="ln5296">                name + 1);</a>
<a name="ln5297">          failed = true;</a>
<a name="ln5298">          xfree(name);</a>
<a name="ln5299">          break;</a>
<a name="ln5300">        }</a>
<a name="ln5301">        if (name[1] == 'A')</a>
<a name="ln5302">          id = SYNID_ALLBUT;</a>
<a name="ln5303">        else if (name[1] == 'T')</a>
<a name="ln5304">          id = SYNID_TOP;</a>
<a name="ln5305">        else</a>
<a name="ln5306">          id = SYNID_CONTAINED;</a>
<a name="ln5307">        id += current_syn_inc_tag;</a>
<a name="ln5308">      } else if (name[1] == '@')   {</a>
<a name="ln5309">        if (skip) {</a>
<a name="ln5310">          id = -1;</a>
<a name="ln5311">        } else {</a>
<a name="ln5312">          id = syn_check_cluster(name + 2, (int)(end - p - 1));</a>
<a name="ln5313">        }</a>
<a name="ln5314">      } else {</a>
<a name="ln5315">        /*</a>
<a name="ln5316">         * Handle full group name.</a>
<a name="ln5317">         */</a>
<a name="ln5318">        if (vim_strpbrk(name + 1, (char_u *)&quot;\\.*^$~[&quot;) == NULL) {</a>
<a name="ln5319">          id = syn_check_group(name + 1, (int)(end - p));</a>
<a name="ln5320">        } else {</a>
<a name="ln5321">          // Handle match of regexp with group names.</a>
<a name="ln5322">          *name = '^';</a>
<a name="ln5323">          STRCAT(name, &quot;$&quot;);</a>
<a name="ln5324">          regmatch.regprog = vim_regcomp(name, RE_MAGIC);</a>
<a name="ln5325">          if (regmatch.regprog == NULL) {</a>
<a name="ln5326">            failed = true;</a>
<a name="ln5327">            xfree(name);</a>
<a name="ln5328">            break;</a>
<a name="ln5329">          }</a>
<a name="ln5330"> </a>
<a name="ln5331">          regmatch.rm_ic = TRUE;</a>
<a name="ln5332">          id = 0;</a>
<a name="ln5333">          for (int i = highlight_ga.ga_len; --i &gt;= 0; ) {</a>
<a name="ln5334">            if (vim_regexec(&amp;regmatch, HL_TABLE()[i].sg_name, (colnr_T)0)) {</a>
<a name="ln5335">              if (round == 2) {</a>
<a name="ln5336">                // Got more items than expected; can happen</a>
<a name="ln5337">                // when adding items that match:</a>
<a name="ln5338">                // &quot;contains=a.*b,axb&quot;.</a>
<a name="ln5339">                // Go back to first round.</a>
<a name="ln5340">                if (count &gt;= total_count) {</a>
<a name="ln5341">                  xfree(retval);</a>
<a name="ln5342">                  round = 1;</a>
<a name="ln5343">                } else {</a>
<a name="ln5344">                  retval[count] = i + 1;  // -V522</a>
<a name="ln5345">                }</a>
<a name="ln5346">              }</a>
<a name="ln5347">              count++;</a>
<a name="ln5348">              id = -1;  // Remember that we found one.</a>
<a name="ln5349">            }</a>
<a name="ln5350">          }</a>
<a name="ln5351">          vim_regfree(regmatch.regprog);</a>
<a name="ln5352">        }</a>
<a name="ln5353">      }</a>
<a name="ln5354">      xfree(name);</a>
<a name="ln5355">      if (id == 0) {</a>
<a name="ln5356">        EMSG2(_(&quot;E409: Unknown group name: %s&quot;), p);</a>
<a name="ln5357">        failed = true;</a>
<a name="ln5358">        break;</a>
<a name="ln5359">      }</a>
<a name="ln5360">      if (id &gt; 0) {</a>
<a name="ln5361">        if (round == 2) {</a>
<a name="ln5362">          // Got more items than expected, go back to first round.</a>
<a name="ln5363">          if (count &gt;= total_count) {</a>
<a name="ln5364">            xfree(retval);</a>
<a name="ln5365">            round = 1;</a>
<a name="ln5366">          } else {</a>
<a name="ln5367">            retval[count] = id;</a>
<a name="ln5368">          }</a>
<a name="ln5369">        }</a>
<a name="ln5370">        ++count;</a>
<a name="ln5371">      }</a>
<a name="ln5372">      p = skipwhite(end);</a>
<a name="ln5373">      if (*p != ',')</a>
<a name="ln5374">        break;</a>
<a name="ln5375">      p = skipwhite(p + 1);             /* skip comma in between arguments */</a>
<a name="ln5376">    } while (!ends_excmd(*p));</a>
<a name="ln5377">    if (failed)</a>
<a name="ln5378">      break;</a>
<a name="ln5379">    if (round == 1) {</a>
<a name="ln5380">      retval = xmalloc((count + 1) * sizeof(*retval));</a>
<a name="ln5381">      retval[count] = 0;            // zero means end of the list</a>
<a name="ln5382">      total_count = count;</a>
<a name="ln5383">    }</a>
<a name="ln5384">  }</a>
<a name="ln5385"> </a>
<a name="ln5386">  *arg = p;</a>
<a name="ln5387">  if (failed || retval == NULL) {</a>
<a name="ln5388">    xfree(retval);</a>
<a name="ln5389">    return FAIL;</a>
<a name="ln5390">  }</a>
<a name="ln5391"> </a>
<a name="ln5392">  if (*list == NULL)</a>
<a name="ln5393">    *list = retval;</a>
<a name="ln5394">  else</a>
<a name="ln5395">    xfree(retval);           /* list already found, don't overwrite it */</a>
<a name="ln5396"> </a>
<a name="ln5397">  return OK;</a>
<a name="ln5398">}</a>
<a name="ln5399"> </a>
<a name="ln5400">/*</a>
<a name="ln5401"> * Make a copy of an ID list.</a>
<a name="ln5402"> */</a>
<a name="ln5403">static int16_t *copy_id_list(const int16_t *const list)</a>
<a name="ln5404">{</a>
<a name="ln5405">  if (list == NULL) {</a>
<a name="ln5406">    return NULL;</a>
<a name="ln5407">  }</a>
<a name="ln5408"> </a>
<a name="ln5409">  int count;</a>
<a name="ln5410">  for (count = 0; list[count]; count++) {</a>
<a name="ln5411">  }</a>
<a name="ln5412">  const size_t len = (count + 1) * sizeof(int16_t);</a>
<a name="ln5413">  int16_t *const retval = xmalloc(len);</a>
<a name="ln5414">  memmove(retval, list, len);</a>
<a name="ln5415"> </a>
<a name="ln5416">  return retval;</a>
<a name="ln5417">}</a>
<a name="ln5418"> </a>
<a name="ln5419">/*</a>
<a name="ln5420"> * Check if syntax group &quot;ssp&quot; is in the ID list &quot;list&quot; of &quot;cur_si&quot;.</a>
<a name="ln5421"> * &quot;cur_si&quot; can be NULL if not checking the &quot;containedin&quot; list.</a>
<a name="ln5422"> * Used to check if a syntax item is in the &quot;contains&quot; or &quot;nextgroup&quot; list of</a>
<a name="ln5423"> * the current item.</a>
<a name="ln5424"> * This function is called very often, keep it fast!!</a>
<a name="ln5425"> */</a>
<a name="ln5426">static int</a>
<a name="ln5427">in_id_list(</a>
<a name="ln5428">    stateitem_T *cur_si,    // current item or NULL</a>
<a name="ln5429">    int16_t *list,          // id list</a>
<a name="ln5430">    struct sp_syn *ssp,     // group id and &quot;:syn include&quot; tag of group</a>
<a name="ln5431">    int contained           // group id is contained</a>
<a name="ln5432">)</a>
<a name="ln5433">{</a>
<a name="ln5434">  int retval;</a>
<a name="ln5435">  int16_t *scl_list;</a>
<a name="ln5436">  int16_t item;</a>
<a name="ln5437">  int16_t id = ssp-&gt;id;</a>
<a name="ln5438">  static int depth = 0;</a>
<a name="ln5439">  int r;</a>
<a name="ln5440"> </a>
<a name="ln5441">  /* If ssp has a &quot;containedin&quot; list and &quot;cur_si&quot; is in it, return TRUE. */</a>
<a name="ln5442">  if (cur_si != NULL &amp;&amp; ssp-&gt;cont_in_list != NULL</a>
<a name="ln5443">      &amp;&amp; !(cur_si-&gt;si_flags &amp; HL_MATCH)) {</a>
<a name="ln5444">    /* Ignore transparent items without a contains argument.  Double check</a>
<a name="ln5445">     * that we don't go back past the first one. */</a>
<a name="ln5446">    while ((cur_si-&gt;si_flags &amp; HL_TRANS_CONT)</a>
<a name="ln5447">           &amp;&amp; cur_si &gt; (stateitem_T *)(current_state.ga_data))</a>
<a name="ln5448">      --cur_si;</a>
<a name="ln5449">    /* cur_si-&gt;si_idx is -1 for keywords, these never contain anything. */</a>
<a name="ln5450">    if (cur_si-&gt;si_idx &gt;= 0 &amp;&amp; in_id_list(NULL, ssp-&gt;cont_in_list,</a>
<a name="ln5451">            &amp;(SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_syn),</a>
<a name="ln5452">            SYN_ITEMS(syn_block)[cur_si-&gt;si_idx].sp_flags &amp; HL_CONTAINED))</a>
<a name="ln5453">      return TRUE;</a>
<a name="ln5454">  }</a>
<a name="ln5455"> </a>
<a name="ln5456">  if (list == NULL)</a>
<a name="ln5457">    return FALSE;</a>
<a name="ln5458"> </a>
<a name="ln5459">  /*</a>
<a name="ln5460">   * If list is ID_LIST_ALL, we are in a transparent item that isn't</a>
<a name="ln5461">   * inside anything.  Only allow not-contained groups.</a>
<a name="ln5462">   */</a>
<a name="ln5463">  if (list == ID_LIST_ALL)</a>
<a name="ln5464">    return !contained;</a>
<a name="ln5465"> </a>
<a name="ln5466">  /*</a>
<a name="ln5467">   * If the first item is &quot;ALLBUT&quot;, return TRUE if &quot;id&quot; is NOT in the</a>
<a name="ln5468">   * contains list.  We also require that &quot;id&quot; is at the same &quot;:syn include&quot;</a>
<a name="ln5469">   * level as the list.</a>
<a name="ln5470">   */</a>
<a name="ln5471">  item = *list;</a>
<a name="ln5472">  if (item &gt;= SYNID_ALLBUT &amp;&amp; item &lt; SYNID_CLUSTER) {</a>
<a name="ln5473">    if (item &lt; SYNID_TOP) {</a>
<a name="ln5474">      /* ALL or ALLBUT: accept all groups in the same file */</a>
<a name="ln5475">      if (item - SYNID_ALLBUT != ssp-&gt;inc_tag)</a>
<a name="ln5476">        return FALSE;</a>
<a name="ln5477">    } else if (item &lt; SYNID_CONTAINED)   {</a>
<a name="ln5478">      /* TOP: accept all not-contained groups in the same file */</a>
<a name="ln5479">      if (item - SYNID_TOP != ssp-&gt;inc_tag || contained)</a>
<a name="ln5480">        return FALSE;</a>
<a name="ln5481">    } else {</a>
<a name="ln5482">      /* CONTAINED: accept all contained groups in the same file */</a>
<a name="ln5483">      if (item - SYNID_CONTAINED != ssp-&gt;inc_tag || !contained)</a>
<a name="ln5484">        return FALSE;</a>
<a name="ln5485">    }</a>
<a name="ln5486">    item = *++list;</a>
<a name="ln5487">    retval = FALSE;</a>
<a name="ln5488">  } else</a>
<a name="ln5489">    retval = TRUE;</a>
<a name="ln5490"> </a>
<a name="ln5491">  /*</a>
<a name="ln5492">   * Return &quot;retval&quot; if id is in the contains list.</a>
<a name="ln5493">   */</a>
<a name="ln5494">  while (item != 0) {</a>
<a name="ln5495">    if (item == id)</a>
<a name="ln5496">      return retval;</a>
<a name="ln5497">    if (item &gt;= SYNID_CLUSTER) {</a>
<a name="ln5498">      scl_list = SYN_CLSTR(syn_block)[item - SYNID_CLUSTER].scl_list;</a>
<a name="ln5499">      /* restrict recursiveness to 30 to avoid an endless loop for a</a>
<a name="ln5500">       * cluster that includes itself (indirectly) */</a>
<a name="ln5501">      if (scl_list != NULL &amp;&amp; depth &lt; 30) {</a>
<a name="ln5502">        ++depth;</a>
<a name="ln5503">        r = in_id_list(NULL, scl_list, ssp, contained);</a>
<a name="ln5504">        --depth;</a>
<a name="ln5505">        if (r)</a>
<a name="ln5506">          return retval;</a>
<a name="ln5507">      }</a>
<a name="ln5508">    }</a>
<a name="ln5509">    item = *++list;</a>
<a name="ln5510">  }</a>
<a name="ln5511">  return !retval;</a>
<a name="ln5512">}</a>
<a name="ln5513"> </a>
<a name="ln5514">struct subcommand {</a>
<a name="ln5515">  char    *name;                                /* subcommand name */</a>
<a name="ln5516">  void    (*func)(exarg_T *, int);              /* function to call */</a>
<a name="ln5517">};</a>
<a name="ln5518"> </a>
<a name="ln5519">static struct subcommand subcommands[] =</a>
<a name="ln5520">{</a>
<a name="ln5521">  { &quot;case&quot;,      syn_cmd_case },</a>
<a name="ln5522">  { &quot;clear&quot;,     syn_cmd_clear },</a>
<a name="ln5523">  { &quot;cluster&quot;,   syn_cmd_cluster },</a>
<a name="ln5524">  { &quot;conceal&quot;,   syn_cmd_conceal },</a>
<a name="ln5525">  { &quot;enable&quot;,    syn_cmd_enable },</a>
<a name="ln5526">  { &quot;foldlevel&quot;, syn_cmd_foldlevel },</a>
<a name="ln5527">  { &quot;include&quot;,   syn_cmd_include },</a>
<a name="ln5528">  { &quot;iskeyword&quot;, syn_cmd_iskeyword },</a>
<a name="ln5529">  { &quot;keyword&quot;,   syn_cmd_keyword },</a>
<a name="ln5530">  { &quot;list&quot;,      syn_cmd_list },</a>
<a name="ln5531">  { &quot;manual&quot;,    syn_cmd_manual },</a>
<a name="ln5532">  { &quot;match&quot;,     syn_cmd_match },</a>
<a name="ln5533">  { &quot;on&quot;,        syn_cmd_on },</a>
<a name="ln5534">  { &quot;off&quot;,       syn_cmd_off },</a>
<a name="ln5535">  { &quot;region&quot;,    syn_cmd_region },</a>
<a name="ln5536">  { &quot;reset&quot;,     syn_cmd_reset },</a>
<a name="ln5537">  { &quot;spell&quot;,     syn_cmd_spell },</a>
<a name="ln5538">  { &quot;sync&quot;,      syn_cmd_sync },</a>
<a name="ln5539">  { &quot;&quot;,          syn_cmd_list },</a>
<a name="ln5540">  { NULL, NULL }</a>
<a name="ln5541">};</a>
<a name="ln5542"> </a>
<a name="ln5543">/*</a>
<a name="ln5544"> * &quot;:syntax&quot;.</a>
<a name="ln5545"> * This searches the subcommands[] table for the subcommand name, and calls a</a>
<a name="ln5546"> * syntax_subcommand() function to do the rest.</a>
<a name="ln5547"> */</a>
<a name="ln5548">void ex_syntax(exarg_T *eap)</a>
<a name="ln5549">{</a>
<a name="ln5550">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln5551">  char_u      *subcmd_end;</a>
<a name="ln5552">  char_u      *subcmd_name;</a>
<a name="ln5553">  int i;</a>
<a name="ln5554"> </a>
<a name="ln5555">  syn_cmdlinep = eap-&gt;cmdlinep;</a>
<a name="ln5556"> </a>
<a name="ln5557">  /* isolate subcommand name */</a>
<a name="ln5558">  for (subcmd_end = arg; ASCII_ISALPHA(*subcmd_end); ++subcmd_end)</a>
<a name="ln5559">    ;</a>
<a name="ln5560">  subcmd_name = vim_strnsave(arg, (int)(subcmd_end - arg));</a>
<a name="ln5561">  if (eap-&gt;skip)              /* skip error messages for all subcommands */</a>
<a name="ln5562">    ++emsg_skip;</a>
<a name="ln5563">  for (i = 0;; ++i) {</a>
<a name="ln5564">    if (subcommands[i].name == NULL) {</a>
<a name="ln5565">      EMSG2(_(&quot;E410: Invalid :syntax subcommand: %s&quot;), subcmd_name);</a>
<a name="ln5566">      break;</a>
<a name="ln5567">    }</a>
<a name="ln5568">    if (STRCMP(subcmd_name, (char_u *)subcommands[i].name) == 0) {</a>
<a name="ln5569">      eap-&gt;arg = skipwhite(subcmd_end);</a>
<a name="ln5570">      (subcommands[i].func)(eap, FALSE);</a>
<a name="ln5571">      break;</a>
<a name="ln5572">    }</a>
<a name="ln5573">  }</a>
<a name="ln5574">  xfree(subcmd_name);</a>
<a name="ln5575">  if (eap-&gt;skip)</a>
<a name="ln5576">    --emsg_skip;</a>
<a name="ln5577">}</a>
<a name="ln5578"> </a>
<a name="ln5579">void ex_ownsyntax(exarg_T *eap)</a>
<a name="ln5580">{</a>
<a name="ln5581">  char_u      *old_value;</a>
<a name="ln5582">  char_u      *new_value;</a>
<a name="ln5583"> </a>
<a name="ln5584">  if (curwin-&gt;w_s == &amp;curwin-&gt;w_buffer-&gt;b_s) {</a>
<a name="ln5585">    curwin-&gt;w_s = xmalloc(sizeof(synblock_T));</a>
<a name="ln5586">    memset(curwin-&gt;w_s, 0, sizeof(synblock_T));</a>
<a name="ln5587">    hash_init(&amp;curwin-&gt;w_s-&gt;b_keywtab);</a>
<a name="ln5588">    hash_init(&amp;curwin-&gt;w_s-&gt;b_keywtab_ic);</a>
<a name="ln5589">    // TODO: Keep the spell checking as it was. NOLINT(readability/todo)</a>
<a name="ln5590">    curwin-&gt;w_p_spell = false;  // No spell checking</a>
<a name="ln5591">    // make sure option values are &quot;empty_option&quot; instead of NULL</a>
<a name="ln5592">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln5593">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln5594">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln5595">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln5596">    clear_string_option(&amp;curwin-&gt;w_s-&gt;b_syn_isk);</a>
<a name="ln5597">  }</a>
<a name="ln5598"> </a>
<a name="ln5599">  // Save value of b:current_syntax.</a>
<a name="ln5600">  old_value = get_var_value(&quot;b:current_syntax&quot;);</a>
<a name="ln5601">  if (old_value != NULL) {</a>
<a name="ln5602">    old_value = vim_strsave(old_value);</a>
<a name="ln5603">  }</a>
<a name="ln5604"> </a>
<a name="ln5605">  /* Apply the &quot;syntax&quot; autocommand event, this finds and loads the syntax</a>
<a name="ln5606">   * file. */</a>
<a name="ln5607">  apply_autocmds(EVENT_SYNTAX, eap-&gt;arg, curbuf-&gt;b_fname, TRUE, curbuf);</a>
<a name="ln5608"> </a>
<a name="ln5609">  // Move value of b:current_syntax to w:current_syntax.</a>
<a name="ln5610">  new_value = get_var_value(&quot;b:current_syntax&quot;);</a>
<a name="ln5611">  if (new_value != NULL) {</a>
<a name="ln5612">    set_internal_string_var((char_u *)&quot;w:current_syntax&quot;, new_value);</a>
<a name="ln5613">  }</a>
<a name="ln5614"> </a>
<a name="ln5615">  // Restore value of b:current_syntax.</a>
<a name="ln5616">  if (old_value == NULL) {</a>
<a name="ln5617">    do_unlet(S_LEN(&quot;b:current_syntax&quot;), true);</a>
<a name="ln5618">  } else {</a>
<a name="ln5619">    set_internal_string_var((char_u *)&quot;b:current_syntax&quot;, old_value);</a>
<a name="ln5620">    xfree(old_value);</a>
<a name="ln5621">  }</a>
<a name="ln5622">}</a>
<a name="ln5623"> </a>
<a name="ln5624">bool syntax_present(win_T *win)</a>
<a name="ln5625">{</a>
<a name="ln5626">  return win-&gt;w_s-&gt;b_syn_patterns.ga_len != 0</a>
<a name="ln5627">         || win-&gt;w_s-&gt;b_syn_clusters.ga_len != 0</a>
<a name="ln5628">         || win-&gt;w_s-&gt;b_keywtab.ht_used &gt; 0</a>
<a name="ln5629">         || win-&gt;w_s-&gt;b_keywtab_ic.ht_used &gt; 0;</a>
<a name="ln5630">}</a>
<a name="ln5631"> </a>
<a name="ln5632"> </a>
<a name="ln5633">static enum {</a>
<a name="ln5634">  EXP_SUBCMD,       // expand &quot;:syn&quot; sub-commands</a>
<a name="ln5635">  EXP_CASE,         // expand &quot;:syn case&quot; arguments</a>
<a name="ln5636">  EXP_SPELL,        // expand &quot;:syn spell&quot; arguments</a>
<a name="ln5637">  EXP_SYNC          // expand &quot;:syn sync&quot; arguments</a>
<a name="ln5638">} expand_what;</a>
<a name="ln5639"> </a>
<a name="ln5640">/*</a>
<a name="ln5641"> * Reset include_link, include_default, include_none to 0.</a>
<a name="ln5642"> * Called when we are done expanding.</a>
<a name="ln5643"> */</a>
<a name="ln5644">void reset_expand_highlight(void)</a>
<a name="ln5645">{</a>
<a name="ln5646">  include_link = include_default = include_none = 0;</a>
<a name="ln5647">}</a>
<a name="ln5648"> </a>
<a name="ln5649">/*</a>
<a name="ln5650"> * Handle command line completion for :match and :echohl command: Add &quot;None&quot;</a>
<a name="ln5651"> * as highlight group.</a>
<a name="ln5652"> */</a>
<a name="ln5653">void set_context_in_echohl_cmd(expand_T *xp, const char *arg)</a>
<a name="ln5654">{</a>
<a name="ln5655">  xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln5656">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln5657">  include_none = 1;</a>
<a name="ln5658">}</a>
<a name="ln5659"> </a>
<a name="ln5660">/*</a>
<a name="ln5661"> * Handle command line completion for :syntax command.</a>
<a name="ln5662"> */</a>
<a name="ln5663">void set_context_in_syntax_cmd(expand_T *xp, const char *arg)</a>
<a name="ln5664">{</a>
<a name="ln5665">  // Default: expand subcommands.</a>
<a name="ln5666">  xp-&gt;xp_context = EXPAND_SYNTAX;</a>
<a name="ln5667">  expand_what = EXP_SUBCMD;</a>
<a name="ln5668">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln5669">  include_link = 0;</a>
<a name="ln5670">  include_default = 0;</a>
<a name="ln5671"> </a>
<a name="ln5672">  /* (part of) subcommand already typed */</a>
<a name="ln5673">  if (*arg != NUL) {</a>
<a name="ln5674">    const char *p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln5675">    if (*p != NUL) {  // Past first word.</a>
<a name="ln5676">      xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln5677">      if (*skiptowhite(xp-&gt;xp_pattern) != NUL) {</a>
<a name="ln5678">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5679">      } else if (STRNICMP(arg, &quot;case&quot;, p - arg) == 0) {</a>
<a name="ln5680">        expand_what = EXP_CASE;</a>
<a name="ln5681">      } else if (STRNICMP(arg, &quot;spell&quot;, p - arg) == 0) {</a>
<a name="ln5682">        expand_what = EXP_SPELL;</a>
<a name="ln5683">      } else if (STRNICMP(arg, &quot;sync&quot;, p - arg) == 0) {</a>
<a name="ln5684">        expand_what = EXP_SYNC;</a>
<a name="ln5685">      } else if (STRNICMP(arg, &quot;keyword&quot;, p - arg) == 0</a>
<a name="ln5686">                 || STRNICMP(arg, &quot;region&quot;, p - arg) == 0</a>
<a name="ln5687">                 || STRNICMP(arg, &quot;match&quot;, p - arg) == 0</a>
<a name="ln5688">                 || STRNICMP(arg, &quot;list&quot;, p - arg) == 0) {</a>
<a name="ln5689">        xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln5690">      } else {</a>
<a name="ln5691">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5692">      }</a>
<a name="ln5693">    }</a>
<a name="ln5694">  }</a>
<a name="ln5695">}</a>
<a name="ln5696"> </a>
<a name="ln5697">/*</a>
<a name="ln5698"> * Function given to ExpandGeneric() to obtain the list syntax names for</a>
<a name="ln5699"> * expansion.</a>
<a name="ln5700"> */</a>
<a name="ln5701">char_u *get_syntax_name(expand_T *xp, int idx)</a>
<a name="ln5702">{</a>
<a name="ln5703">  switch (expand_what) {</a>
<a name="ln5704">    case EXP_SUBCMD:</a>
<a name="ln5705">        return (char_u *)subcommands[idx].name;</a>
<a name="ln5706">    case EXP_CASE: {</a>
<a name="ln5707">        static char *case_args[] = { &quot;match&quot;, &quot;ignore&quot;, NULL };</a>
<a name="ln5708">        return (char_u *)case_args[idx];</a>
<a name="ln5709">    }</a>
<a name="ln5710">    case EXP_SPELL: {</a>
<a name="ln5711">        static char *spell_args[] =</a>
<a name="ln5712">        { &quot;toplevel&quot;, &quot;notoplevel&quot;, &quot;default&quot;, NULL };</a>
<a name="ln5713">        return (char_u *)spell_args[idx];</a>
<a name="ln5714">    }</a>
<a name="ln5715">    case EXP_SYNC: {</a>
<a name="ln5716">        static char *sync_args[] =</a>
<a name="ln5717">        { &quot;ccomment&quot;, &quot;clear&quot;, &quot;fromstart&quot;,</a>
<a name="ln5718">         &quot;linebreaks=&quot;, &quot;linecont&quot;, &quot;lines=&quot;, &quot;match&quot;,</a>
<a name="ln5719">         &quot;maxlines=&quot;, &quot;minlines=&quot;, &quot;region&quot;, NULL };</a>
<a name="ln5720">        return (char_u *)sync_args[idx];</a>
<a name="ln5721">    }</a>
<a name="ln5722">  }</a>
<a name="ln5723">  return NULL;</a>
<a name="ln5724">}</a>
<a name="ln5725"> </a>
<a name="ln5726"> </a>
<a name="ln5727">// Function called for expression evaluation: get syntax ID at file position.</a>
<a name="ln5728">int syn_get_id(</a>
<a name="ln5729">    win_T *wp,</a>
<a name="ln5730">    long lnum,</a>
<a name="ln5731">    colnr_T col,</a>
<a name="ln5732">    int trans,      // remove transparency</a>
<a name="ln5733">    bool *spellp,   // return: can do spell checking</a>
<a name="ln5734">    int keep_state  // keep state of char at &quot;col&quot;</a>
<a name="ln5735">)</a>
<a name="ln5736">{</a>
<a name="ln5737">  // When the position is not after the current position and in the same</a>
<a name="ln5738">  // line of the same buffer, need to restart parsing.</a>
<a name="ln5739">  if (wp-&gt;w_buffer != syn_buf || lnum != current_lnum || col &lt; current_col) {</a>
<a name="ln5740">    syntax_start(wp, lnum);</a>
<a name="ln5741">  } else if (col &gt; current_col) {</a>
<a name="ln5742">      // next_match may not be correct when moving around, e.g. with the</a>
<a name="ln5743">      // &quot;skip&quot; expression in searchpair()</a>
<a name="ln5744">      next_match_idx = -1;</a>
<a name="ln5745">  }</a>
<a name="ln5746"> </a>
<a name="ln5747">  (void)get_syntax_attr(col, spellp, keep_state);</a>
<a name="ln5748"> </a>
<a name="ln5749">  return trans ? current_trans_id : current_id;</a>
<a name="ln5750">}</a>
<a name="ln5751"> </a>
<a name="ln5752">/*</a>
<a name="ln5753"> * Get extra information about the syntax item.  Must be called right after</a>
<a name="ln5754"> * get_syntax_attr().</a>
<a name="ln5755"> * Stores the current item sequence nr in &quot;*seqnrp&quot;.</a>
<a name="ln5756"> * Returns the current flags.</a>
<a name="ln5757"> */</a>
<a name="ln5758">int get_syntax_info(int *seqnrp)</a>
<a name="ln5759">{</a>
<a name="ln5760">  *seqnrp = current_seqnr;</a>
<a name="ln5761">  return current_flags;</a>
<a name="ln5762">}</a>
<a name="ln5763"> </a>
<a name="ln5764"> </a>
<a name="ln5765">/// Get the sequence number of the concealed file position.</a>
<a name="ln5766">///</a>
<a name="ln5767">/// @return seqnr if the file position is concealed, 0 otherwise.</a>
<a name="ln5768">int syn_get_concealed_id(win_T *wp, linenr_T lnum, colnr_T col)</a>
<a name="ln5769">{</a>
<a name="ln5770">  int seqnr;</a>
<a name="ln5771">  int syntax_flags;</a>
<a name="ln5772"> </a>
<a name="ln5773">  (void)syn_get_id(wp, lnum, col, false, NULL, false);</a>
<a name="ln5774">  syntax_flags = get_syntax_info(&amp;seqnr);</a>
<a name="ln5775"> </a>
<a name="ln5776">  if (syntax_flags &amp; HL_CONCEAL) {</a>
<a name="ln5777">    return seqnr;</a>
<a name="ln5778">  }</a>
<a name="ln5779">  return 0;</a>
<a name="ln5780">}</a>
<a name="ln5781"> </a>
<a name="ln5782">/*</a>
<a name="ln5783"> * Return conceal substitution character</a>
<a name="ln5784"> */</a>
<a name="ln5785">int syn_get_sub_char(void)</a>
<a name="ln5786">{</a>
<a name="ln5787">  return current_sub_char;</a>
<a name="ln5788">}</a>
<a name="ln5789"> </a>
<a name="ln5790">/*</a>
<a name="ln5791"> * Return the syntax ID at position &quot;i&quot; in the current stack.</a>
<a name="ln5792"> * The caller must have called syn_get_id() before to fill the stack.</a>
<a name="ln5793"> * Returns -1 when &quot;i&quot; is out of range.</a>
<a name="ln5794"> */</a>
<a name="ln5795">int syn_get_stack_item(int i)</a>
<a name="ln5796">{</a>
<a name="ln5797">  if (i &gt;= current_state.ga_len) {</a>
<a name="ln5798">    /* Need to invalidate the state, because we didn't properly finish it</a>
<a name="ln5799">     * for the last character, &quot;keep_state&quot; was TRUE. */</a>
<a name="ln5800">    invalidate_current_state();</a>
<a name="ln5801">    current_col = MAXCOL;</a>
<a name="ln5802">    return -1;</a>
<a name="ln5803">  }</a>
<a name="ln5804">  return CUR_STATE(i).si_id;</a>
<a name="ln5805">}</a>
<a name="ln5806"> </a>
<a name="ln5807">static int syn_cur_foldlevel(void)</a>
<a name="ln5808">{</a>
<a name="ln5809">  int level = 0;</a>
<a name="ln5810">  for (int i = 0; i &lt; current_state.ga_len; i++) {</a>
<a name="ln5811">    if (CUR_STATE(i).si_flags &amp; HL_FOLD) {</a>
<a name="ln5812">      level++;</a>
<a name="ln5813">    }</a>
<a name="ln5814">  }</a>
<a name="ln5815">  return level;</a>
<a name="ln5816">}</a>
<a name="ln5817"> </a>
<a name="ln5818">/*</a>
<a name="ln5819"> * Function called to get folding level for line &quot;lnum&quot; in window &quot;wp&quot;.</a>
<a name="ln5820"> */</a>
<a name="ln5821">int syn_get_foldlevel(win_T *wp, long lnum)</a>
<a name="ln5822">{</a>
<a name="ln5823">  int level = 0;</a>
<a name="ln5824"> </a>
<a name="ln5825">  // Return quickly when there are no fold items at all.</a>
<a name="ln5826">  if (wp-&gt;w_s-&gt;b_syn_folditems != 0</a>
<a name="ln5827">      &amp;&amp; !wp-&gt;w_s-&gt;b_syn_error</a>
<a name="ln5828">      &amp;&amp; !wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln5829">    syntax_start(wp, lnum);</a>
<a name="ln5830"> </a>
<a name="ln5831">    // Start with the fold level at the start of the line.</a>
<a name="ln5832">    level = syn_cur_foldlevel();</a>
<a name="ln5833"> </a>
<a name="ln5834">    if (wp-&gt;w_s-&gt;b_syn_foldlevel == SYNFLD_MINIMUM) {</a>
<a name="ln5835">      // Find the lowest fold level that is followed by a higher one.</a>
<a name="ln5836">      int cur_level = level;</a>
<a name="ln5837">      int low_level = cur_level;</a>
<a name="ln5838">      while (!current_finished) {</a>
<a name="ln5839">        (void)syn_current_attr(false, false, NULL, false);</a>
<a name="ln5840">        cur_level = syn_cur_foldlevel();</a>
<a name="ln5841">        if (cur_level &lt; low_level) {</a>
<a name="ln5842">          low_level = cur_level;</a>
<a name="ln5843">        } else if (cur_level &gt; low_level) {</a>
<a name="ln5844">          level = low_level;</a>
<a name="ln5845">        }</a>
<a name="ln5846">        current_col++;</a>
<a name="ln5847">      }</a>
<a name="ln5848">    }</a>
<a name="ln5849">  }</a>
<a name="ln5850">  if (level &gt; wp-&gt;w_p_fdn) {</a>
<a name="ln5851">    level = wp-&gt;w_p_fdn;</a>
<a name="ln5852">    if (level &lt; 0)</a>
<a name="ln5853">      level = 0;</a>
<a name="ln5854">  }</a>
<a name="ln5855">  return level;</a>
<a name="ln5856">}</a>
<a name="ln5857"> </a>
<a name="ln5858">/*</a>
<a name="ln5859"> * &quot;:syntime&quot;.</a>
<a name="ln5860"> */</a>
<a name="ln5861">void ex_syntime(exarg_T *eap)</a>
<a name="ln5862">{</a>
<a name="ln5863">  if (STRCMP(eap-&gt;arg, &quot;on&quot;) == 0)</a>
<a name="ln5864">    syn_time_on = TRUE;</a>
<a name="ln5865">  else if (STRCMP(eap-&gt;arg, &quot;off&quot;) == 0)</a>
<a name="ln5866">    syn_time_on = FALSE;</a>
<a name="ln5867">  else if (STRCMP(eap-&gt;arg, &quot;clear&quot;) == 0)</a>
<a name="ln5868">    syntime_clear();</a>
<a name="ln5869">  else if (STRCMP(eap-&gt;arg, &quot;report&quot;) == 0)</a>
<a name="ln5870">    syntime_report();</a>
<a name="ln5871">  else</a>
<a name="ln5872">    EMSG2(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln5873">}</a>
<a name="ln5874"> </a>
<a name="ln5875">static void syn_clear_time(syn_time_T *st)</a>
<a name="ln5876">{</a>
<a name="ln5877">  st-&gt;total = profile_zero();</a>
<a name="ln5878">  st-&gt;slowest = profile_zero();</a>
<a name="ln5879">  st-&gt;count = 0;</a>
<a name="ln5880">  st-&gt;match = 0;</a>
<a name="ln5881">}</a>
<a name="ln5882"> </a>
<a name="ln5883">/*</a>
<a name="ln5884"> * Clear the syntax timing for the current buffer.</a>
<a name="ln5885"> */</a>
<a name="ln5886">static void syntime_clear(void)</a>
<a name="ln5887">{</a>
<a name="ln5888">  synpat_T    *spp;</a>
<a name="ln5889"> </a>
<a name="ln5890">  if (!syntax_present(curwin)) {</a>
<a name="ln5891">    MSG(_(msg_no_items));</a>
<a name="ln5892">    return;</a>
<a name="ln5893">  }</a>
<a name="ln5894">  for (int idx = 0; idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln5895">    spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln5896">    syn_clear_time(&amp;spp-&gt;sp_time);</a>
<a name="ln5897">  }</a>
<a name="ln5898">}</a>
<a name="ln5899"> </a>
<a name="ln5900">/*</a>
<a name="ln5901"> * Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln5902"> * &quot;:syntime {on,off,clear,report}&quot; command.</a>
<a name="ln5903"> */</a>
<a name="ln5904">char_u *get_syntime_arg(expand_T *xp, int idx)</a>
<a name="ln5905">{</a>
<a name="ln5906">  switch (idx) {</a>
<a name="ln5907">  case 0: return (char_u *)&quot;on&quot;;</a>
<a name="ln5908">  case 1: return (char_u *)&quot;off&quot;;</a>
<a name="ln5909">  case 2: return (char_u *)&quot;clear&quot;;</a>
<a name="ln5910">  case 3: return (char_u *)&quot;report&quot;;</a>
<a name="ln5911">  }</a>
<a name="ln5912">  return NULL;</a>
<a name="ln5913">}</a>
<a name="ln5914"> </a>
<a name="ln5915">static int syn_compare_syntime(const void *v1, const void *v2)</a>
<a name="ln5916">{</a>
<a name="ln5917">  const time_entry_T  *s1 = v1;</a>
<a name="ln5918">  const time_entry_T  *s2 = v2;</a>
<a name="ln5919"> </a>
<a name="ln5920">  return profile_cmp(s1-&gt;total, s2-&gt;total);</a>
<a name="ln5921">}</a>
<a name="ln5922"> </a>
<a name="ln5923">/*</a>
<a name="ln5924"> * Clear the syntax timing for the current buffer.</a>
<a name="ln5925"> */</a>
<a name="ln5926">static void syntime_report(void)</a>
<a name="ln5927">{</a>
<a name="ln5928">  if (!syntax_present(curwin)) {</a>
<a name="ln5929">    MSG(_(msg_no_items));</a>
<a name="ln5930">    return;</a>
<a name="ln5931">  }</a>
<a name="ln5932"> </a>
<a name="ln5933">  garray_T ga;</a>
<a name="ln5934">  ga_init(&amp;ga, sizeof(time_entry_T), 50);</a>
<a name="ln5935"> </a>
<a name="ln5936">  proftime_T total_total = profile_zero();</a>
<a name="ln5937">  int total_count = 0;</a>
<a name="ln5938">  time_entry_T *p;</a>
<a name="ln5939">  for (int idx = 0; idx &lt; curwin-&gt;w_s-&gt;b_syn_patterns.ga_len; ++idx) {</a>
<a name="ln5940">    synpat_T *spp = &amp;(SYN_ITEMS(curwin-&gt;w_s)[idx]);</a>
<a name="ln5941">    if (spp-&gt;sp_time.count &gt; 0) {</a>
<a name="ln5942">      p = GA_APPEND_VIA_PTR(time_entry_T, &amp;ga);</a>
<a name="ln5943">      p-&gt;total = spp-&gt;sp_time.total;</a>
<a name="ln5944">      total_total = profile_add(total_total, spp-&gt;sp_time.total);</a>
<a name="ln5945">      p-&gt;count = spp-&gt;sp_time.count;</a>
<a name="ln5946">      p-&gt;match = spp-&gt;sp_time.match;</a>
<a name="ln5947">      total_count += spp-&gt;sp_time.count;</a>
<a name="ln5948">      p-&gt;slowest = spp-&gt;sp_time.slowest;</a>
<a name="ln5949">      proftime_T tm = profile_divide(spp-&gt;sp_time.total, spp-&gt;sp_time.count);</a>
<a name="ln5950">      p-&gt;average = tm;</a>
<a name="ln5951">      p-&gt;id = spp-&gt;sp_syn.id;</a>
<a name="ln5952">      p-&gt;pattern = spp-&gt;sp_pattern;</a>
<a name="ln5953">    }</a>
<a name="ln5954">  }</a>
<a name="ln5955"> </a>
<a name="ln5956">  // Sort on total time. Skip if there are no items to avoid passing NULL</a>
<a name="ln5957">  // pointer to qsort().</a>
<a name="ln5958">  if (ga.ga_len &gt; 1) {</a>
<a name="ln5959">    qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),</a>
<a name="ln5960">          syn_compare_syntime);</a>
<a name="ln5961">  }</a>
<a name="ln5962"> </a>
<a name="ln5963">  MSG_PUTS_TITLE(_(</a>
<a name="ln5964">          &quot;  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN&quot;));</a>
<a name="ln5965">  MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln5966">  for (int idx = 0; idx &lt; ga.ga_len &amp;&amp; !got_int; ++idx) {</a>
<a name="ln5967">    p = ((time_entry_T *)ga.ga_data) + idx;</a>
<a name="ln5968"> </a>
<a name="ln5969">    MSG_PUTS(profile_msg(p-&gt;total));</a>
<a name="ln5970">    MSG_PUTS(&quot; &quot;);     /* make sure there is always a separating space */</a>
<a name="ln5971">    msg_advance(13);</a>
<a name="ln5972">    msg_outnum(p-&gt;count);</a>
<a name="ln5973">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5974">    msg_advance(20);</a>
<a name="ln5975">    msg_outnum(p-&gt;match);</a>
<a name="ln5976">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5977">    msg_advance(26);</a>
<a name="ln5978">    MSG_PUTS(profile_msg(p-&gt;slowest));</a>
<a name="ln5979">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5980">    msg_advance(38);</a>
<a name="ln5981">    MSG_PUTS(profile_msg(p-&gt;average));</a>
<a name="ln5982">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5983">    msg_advance(50);</a>
<a name="ln5984">    msg_outtrans(HL_TABLE()[p-&gt;id - 1].sg_name);</a>
<a name="ln5985">    MSG_PUTS(&quot; &quot;);</a>
<a name="ln5986"> </a>
<a name="ln5987">    msg_advance(69);</a>
<a name="ln5988">    int len;</a>
<a name="ln5989">    if (Columns &lt; 80)</a>
<a name="ln5990">      len = 20;       /* will wrap anyway */</a>
<a name="ln5991">    else</a>
<a name="ln5992">      len = Columns - 70;</a>
<a name="ln5993">    if (len &gt; (int)STRLEN(p-&gt;pattern))</a>
<a name="ln5994">      len = (int)STRLEN(p-&gt;pattern);</a>
<a name="ln5995">    msg_outtrans_len(p-&gt;pattern, len);</a>
<a name="ln5996">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln5997">  }</a>
<a name="ln5998">  ga_clear(&amp;ga);</a>
<a name="ln5999">  if (!got_int) {</a>
<a name="ln6000">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln6001">    MSG_PUTS(profile_msg(total_total));</a>
<a name="ln6002">    msg_advance(13);</a>
<a name="ln6003">    msg_outnum(total_count);</a>
<a name="ln6004">    MSG_PUTS(&quot;\n&quot;);</a>
<a name="ln6005">  }</a>
<a name="ln6006">}</a>
<a name="ln6007"> </a>
<a name="ln6008">/**************************************</a>
<a name="ln6009">*  Highlighting stuff		      *</a>
<a name="ln6010">**************************************/</a>
<a name="ln6011"> </a>
<a name="ln6012">// The default highlight groups.  These are compiled-in for fast startup and</a>
<a name="ln6013">// they still work when the runtime files can't be found.</a>
<a name="ln6014">//</a>
<a name="ln6015">// When making changes here, also change runtime/colors/default.vim!</a>
<a name="ln6016"> </a>
<a name="ln6017">static const char *highlight_init_both[] = {</a>
<a name="ln6018">  &quot;Conceal &quot;</a>
<a name="ln6019">      &quot;ctermbg=DarkGrey ctermfg=LightGrey guibg=DarkGrey guifg=LightGrey&quot;,</a>
<a name="ln6020">  &quot;Cursor       guibg=fg guifg=bg&quot;,</a>
<a name="ln6021">  &quot;lCursor      guibg=fg guifg=bg&quot;,</a>
<a name="ln6022">  &quot;DiffText     cterm=bold ctermbg=Red gui=bold guibg=Red&quot;,</a>
<a name="ln6023">  &quot;ErrorMsg     ctermbg=DarkRed ctermfg=White guibg=Red guifg=White&quot;,</a>
<a name="ln6024">  &quot;IncSearch    cterm=reverse gui=reverse&quot;,</a>
<a name="ln6025">  &quot;ModeMsg      cterm=bold gui=bold&quot;,</a>
<a name="ln6026">  &quot;NonText      ctermfg=Blue gui=bold guifg=Blue&quot;,</a>
<a name="ln6027">  &quot;Normal       cterm=NONE gui=NONE&quot;,</a>
<a name="ln6028">  &quot;PmenuSbar    ctermbg=Grey guibg=Grey&quot;,</a>
<a name="ln6029">  &quot;StatusLine   cterm=reverse,bold gui=reverse,bold&quot;,</a>
<a name="ln6030">  &quot;StatusLineNC cterm=reverse gui=reverse&quot;,</a>
<a name="ln6031">  &quot;TabLineFill  cterm=reverse gui=reverse&quot;,</a>
<a name="ln6032">  &quot;TabLineSel   cterm=bold gui=bold&quot;,</a>
<a name="ln6033">  &quot;TermCursor   cterm=reverse gui=reverse&quot;,</a>
<a name="ln6034">  &quot;VertSplit    cterm=reverse gui=reverse&quot;,</a>
<a name="ln6035">  &quot;WildMenu     ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black&quot;,</a>
<a name="ln6036">  &quot;default link EndOfBuffer NonText&quot;,</a>
<a name="ln6037">  &quot;default link QuickFixLine Search&quot;,</a>
<a name="ln6038">  &quot;default link Substitute Search&quot;,</a>
<a name="ln6039">  &quot;default link Whitespace NonText&quot;,</a>
<a name="ln6040">  &quot;default link MsgSeparator StatusLine&quot;,</a>
<a name="ln6041">  &quot;default link NormalFloat Pmenu&quot;,</a>
<a name="ln6042">  &quot;RedrawDebugNormal cterm=reverse gui=reverse&quot;,</a>
<a name="ln6043">  &quot;RedrawDebugClear ctermbg=Yellow guibg=Yellow&quot;,</a>
<a name="ln6044">  &quot;RedrawDebugComposed ctermbg=Green guibg=Green&quot;,</a>
<a name="ln6045">  &quot;RedrawDebugRecompose ctermbg=Red guibg=Red&quot;,</a>
<a name="ln6046">  NULL</a>
<a name="ln6047">};</a>
<a name="ln6048"> </a>
<a name="ln6049">// Default colors only used with a light background.</a>
<a name="ln6050">static const char *highlight_init_light[] = {</a>
<a name="ln6051">  &quot;ColorColumn  ctermbg=LightRed guibg=LightRed&quot;,</a>
<a name="ln6052">  &quot;CursorColumn ctermbg=LightGrey guibg=Grey90&quot;,</a>
<a name="ln6053">  &quot;CursorLine   cterm=underline guibg=Grey90&quot;,</a>
<a name="ln6054">  &quot;CursorLineNr ctermfg=Brown gui=bold guifg=Brown&quot;,</a>
<a name="ln6055">  &quot;DiffAdd      ctermbg=LightBlue guibg=LightBlue&quot;,</a>
<a name="ln6056">  &quot;DiffChange   ctermbg=LightMagenta guibg=LightMagenta&quot;,</a>
<a name="ln6057">  &quot;DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan&quot;,</a>
<a name="ln6058">  &quot;Directory    ctermfg=DarkBlue guifg=Blue&quot;,</a>
<a name="ln6059">  &quot;FoldColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue&quot;,</a>
<a name="ln6060">  &quot;Folded       ctermbg=Grey ctermfg=DarkBlue guibg=LightGrey guifg=DarkBlue&quot;,</a>
<a name="ln6061">  &quot;LineNr       ctermfg=Brown guifg=Brown&quot;,</a>
<a name="ln6062">  &quot;MatchParen   ctermbg=Cyan guibg=Cyan&quot;,</a>
<a name="ln6063">  &quot;MoreMsg      ctermfg=DarkGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6064">  &quot;Pmenu        ctermbg=LightMagenta ctermfg=Black guibg=LightMagenta&quot;,</a>
<a name="ln6065">  &quot;PmenuSel     ctermbg=LightGrey ctermfg=Black guibg=Grey&quot;,</a>
<a name="ln6066">  &quot;PmenuThumb   ctermbg=Black guibg=Black&quot;,</a>
<a name="ln6067">  &quot;Question     ctermfg=DarkGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6068">  &quot;Search       ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE&quot;,</a>
<a name="ln6069">  &quot;SignColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue&quot;,</a>
<a name="ln6070">  &quot;SpecialKey   ctermfg=DarkBlue guifg=Blue&quot;,</a>
<a name="ln6071">  &quot;SpellBad     ctermbg=LightRed guisp=Red gui=undercurl&quot;,</a>
<a name="ln6072">  &quot;SpellCap     ctermbg=LightBlue guisp=Blue gui=undercurl&quot;,</a>
<a name="ln6073">  &quot;SpellLocal   ctermbg=Cyan guisp=DarkCyan gui=undercurl&quot;,</a>
<a name="ln6074">  &quot;SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl&quot;,</a>
<a name="ln6075">  &quot;TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey&quot;,</a>
<a name="ln6076">  &quot;Title        ctermfg=DarkMagenta gui=bold guifg=Magenta&quot;,</a>
<a name="ln6077">  &quot;Visual       guibg=LightGrey&quot;,</a>
<a name="ln6078">  &quot;WarningMsg   ctermfg=DarkRed guifg=Red&quot;,</a>
<a name="ln6079">  NULL</a>
<a name="ln6080">};</a>
<a name="ln6081"> </a>
<a name="ln6082">// Default colors only used with a dark background.</a>
<a name="ln6083">static const char *highlight_init_dark[] = {</a>
<a name="ln6084">  &quot;ColorColumn  ctermbg=DarkRed guibg=DarkRed&quot;,</a>
<a name="ln6085">  &quot;CursorColumn ctermbg=DarkGrey guibg=Grey40&quot;,</a>
<a name="ln6086">  &quot;CursorLine   cterm=underline guibg=Grey40&quot;,</a>
<a name="ln6087">  &quot;CursorLineNr ctermfg=Yellow gui=bold guifg=Yellow&quot;,</a>
<a name="ln6088">  &quot;DiffAdd      ctermbg=DarkBlue guibg=DarkBlue&quot;,</a>
<a name="ln6089">  &quot;DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta&quot;,</a>
<a name="ln6090">  &quot;DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan&quot;,</a>
<a name="ln6091">  &quot;Directory    ctermfg=LightCyan guifg=Cyan&quot;,</a>
<a name="ln6092">  &quot;FoldColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan&quot;,</a>
<a name="ln6093">  &quot;Folded       ctermbg=DarkGrey ctermfg=Cyan guibg=DarkGrey guifg=Cyan&quot;,</a>
<a name="ln6094">  &quot;LineNr       ctermfg=Yellow guifg=Yellow&quot;,</a>
<a name="ln6095">  &quot;MatchParen   ctermbg=DarkCyan guibg=DarkCyan&quot;,</a>
<a name="ln6096">  &quot;MoreMsg      ctermfg=LightGreen gui=bold guifg=SeaGreen&quot;,</a>
<a name="ln6097">  &quot;Pmenu        ctermbg=Magenta ctermfg=Black guibg=Magenta&quot;,</a>
<a name="ln6098">  &quot;PmenuSel     ctermbg=Black ctermfg=DarkGrey guibg=DarkGrey&quot;,</a>
<a name="ln6099">  &quot;PmenuThumb   ctermbg=White guibg=White&quot;,</a>
<a name="ln6100">  &quot;Question     ctermfg=LightGreen gui=bold guifg=Green&quot;,</a>
<a name="ln6101">  &quot;Search       ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black&quot;,</a>
<a name="ln6102">  &quot;SignColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan&quot;,</a>
<a name="ln6103">  &quot;SpecialKey   ctermfg=LightBlue guifg=Cyan&quot;,</a>
<a name="ln6104">  &quot;SpellBad     ctermbg=Red guisp=Red gui=undercurl&quot;,</a>
<a name="ln6105">  &quot;SpellCap     ctermbg=Blue guisp=Blue gui=undercurl&quot;,</a>
<a name="ln6106">  &quot;SpellLocal   ctermbg=Cyan guisp=Cyan gui=undercurl&quot;,</a>
<a name="ln6107">  &quot;SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl&quot;,</a>
<a name="ln6108">  &quot;TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey&quot;,</a>
<a name="ln6109">  &quot;Title        ctermfg=LightMagenta gui=bold guifg=Magenta&quot;,</a>
<a name="ln6110">  &quot;Visual       guibg=DarkGrey&quot;,</a>
<a name="ln6111">  &quot;WarningMsg   ctermfg=LightRed guifg=Red&quot;,</a>
<a name="ln6112">  NULL</a>
<a name="ln6113">};</a>
<a name="ln6114"> </a>
<a name="ln6115">const char *const highlight_init_cmdline[] = {</a>
<a name="ln6116">  // XXX When modifying a list modify it in both valid and invalid halfs.</a>
<a name="ln6117">  // TODO(ZyX-I): merge valid and invalid groups via a macros.</a>
<a name="ln6118"> </a>
<a name="ln6119">  // NvimInternalError should appear only when highlighter has a bug.</a>
<a name="ln6120">  &quot;NvimInternalError ctermfg=Red ctermbg=Red guifg=Red guibg=Red&quot;,</a>
<a name="ln6121"> </a>
<a name="ln6122">  // Highlight groups (links) used by parser:</a>
<a name="ln6123"> </a>
<a name="ln6124">  &quot;default link NvimAssignment Operator&quot;,</a>
<a name="ln6125">  &quot;default link NvimPlainAssignment NvimAssignment&quot;,</a>
<a name="ln6126">  &quot;default link NvimAugmentedAssignment NvimAssignment&quot;,</a>
<a name="ln6127">  &quot;default link NvimAssignmentWithAddition NvimAugmentedAssignment&quot;,</a>
<a name="ln6128">  &quot;default link NvimAssignmentWithSubtraction NvimAugmentedAssignment&quot;,</a>
<a name="ln6129">  &quot;default link NvimAssignmentWithConcatenation NvimAugmentedAssignment&quot;,</a>
<a name="ln6130"> </a>
<a name="ln6131">  &quot;default link NvimOperator Operator&quot;,</a>
<a name="ln6132"> </a>
<a name="ln6133">  &quot;default link NvimUnaryOperator NvimOperator&quot;,</a>
<a name="ln6134">  &quot;default link NvimUnaryPlus NvimUnaryOperator&quot;,</a>
<a name="ln6135">  &quot;default link NvimUnaryMinus NvimUnaryOperator&quot;,</a>
<a name="ln6136">  &quot;default link NvimNot NvimUnaryOperator&quot;,</a>
<a name="ln6137"> </a>
<a name="ln6138">  &quot;default link NvimBinaryOperator NvimOperator&quot;,</a>
<a name="ln6139">  &quot;default link NvimComparison NvimBinaryOperator&quot;,</a>
<a name="ln6140">  &quot;default link NvimComparisonModifier NvimComparison&quot;,</a>
<a name="ln6141">  &quot;default link NvimBinaryPlus NvimBinaryOperator&quot;,</a>
<a name="ln6142">  &quot;default link NvimBinaryMinus NvimBinaryOperator&quot;,</a>
<a name="ln6143">  &quot;default link NvimConcat NvimBinaryOperator&quot;,</a>
<a name="ln6144">  &quot;default link NvimConcatOrSubscript NvimConcat&quot;,</a>
<a name="ln6145">  &quot;default link NvimOr NvimBinaryOperator&quot;,</a>
<a name="ln6146">  &quot;default link NvimAnd NvimBinaryOperator&quot;,</a>
<a name="ln6147">  &quot;default link NvimMultiplication NvimBinaryOperator&quot;,</a>
<a name="ln6148">  &quot;default link NvimDivision NvimBinaryOperator&quot;,</a>
<a name="ln6149">  &quot;default link NvimMod NvimBinaryOperator&quot;,</a>
<a name="ln6150"> </a>
<a name="ln6151">  &quot;default link NvimTernary NvimOperator&quot;,</a>
<a name="ln6152">  &quot;default link NvimTernaryColon NvimTernary&quot;,</a>
<a name="ln6153"> </a>
<a name="ln6154">  &quot;default link NvimParenthesis Delimiter&quot;,</a>
<a name="ln6155">  &quot;default link NvimLambda NvimParenthesis&quot;,</a>
<a name="ln6156">  &quot;default link NvimNestingParenthesis NvimParenthesis&quot;,</a>
<a name="ln6157">  &quot;default link NvimCallingParenthesis NvimParenthesis&quot;,</a>
<a name="ln6158"> </a>
<a name="ln6159">  &quot;default link NvimSubscript NvimParenthesis&quot;,</a>
<a name="ln6160">  &quot;default link NvimSubscriptBracket NvimSubscript&quot;,</a>
<a name="ln6161">  &quot;default link NvimSubscriptColon NvimSubscript&quot;,</a>
<a name="ln6162">  &quot;default link NvimCurly NvimSubscript&quot;,</a>
<a name="ln6163"> </a>
<a name="ln6164">  &quot;default link NvimContainer NvimParenthesis&quot;,</a>
<a name="ln6165">  &quot;default link NvimDict NvimContainer&quot;,</a>
<a name="ln6166">  &quot;default link NvimList NvimContainer&quot;,</a>
<a name="ln6167"> </a>
<a name="ln6168">  &quot;default link NvimIdentifier Identifier&quot;,</a>
<a name="ln6169">  &quot;default link NvimIdentifierScope NvimIdentifier&quot;,</a>
<a name="ln6170">  &quot;default link NvimIdentifierScopeDelimiter NvimIdentifier&quot;,</a>
<a name="ln6171">  &quot;default link NvimIdentifierName NvimIdentifier&quot;,</a>
<a name="ln6172">  &quot;default link NvimIdentifierKey NvimIdentifier&quot;,</a>
<a name="ln6173"> </a>
<a name="ln6174">  &quot;default link NvimColon Delimiter&quot;,</a>
<a name="ln6175">  &quot;default link NvimComma Delimiter&quot;,</a>
<a name="ln6176">  &quot;default link NvimArrow Delimiter&quot;,</a>
<a name="ln6177"> </a>
<a name="ln6178">  &quot;default link NvimRegister SpecialChar&quot;,</a>
<a name="ln6179">  &quot;default link NvimNumber Number&quot;,</a>
<a name="ln6180">  &quot;default link NvimFloat NvimNumber&quot;,</a>
<a name="ln6181">  &quot;default link NvimNumberPrefix Type&quot;,</a>
<a name="ln6182"> </a>
<a name="ln6183">  &quot;default link NvimOptionSigil Type&quot;,</a>
<a name="ln6184">  &quot;default link NvimOptionName NvimIdentifier&quot;,</a>
<a name="ln6185">  &quot;default link NvimOptionScope NvimIdentifierScope&quot;,</a>
<a name="ln6186">  &quot;default link NvimOptionScopeDelimiter NvimIdentifierScopeDelimiter&quot;,</a>
<a name="ln6187"> </a>
<a name="ln6188">  &quot;default link NvimEnvironmentSigil NvimOptionSigil&quot;,</a>
<a name="ln6189">  &quot;default link NvimEnvironmentName NvimIdentifier&quot;,</a>
<a name="ln6190"> </a>
<a name="ln6191">  &quot;default link NvimString String&quot;,</a>
<a name="ln6192">  &quot;default link NvimStringBody NvimString&quot;,</a>
<a name="ln6193">  &quot;default link NvimStringQuote NvimString&quot;,</a>
<a name="ln6194">  &quot;default link NvimStringSpecial SpecialChar&quot;,</a>
<a name="ln6195"> </a>
<a name="ln6196">  &quot;default link NvimSingleQuote NvimStringQuote&quot;,</a>
<a name="ln6197">  &quot;default link NvimSingleQuotedBody NvimStringBody&quot;,</a>
<a name="ln6198">  &quot;default link NvimSingleQuotedQuote NvimStringSpecial&quot;,</a>
<a name="ln6199"> </a>
<a name="ln6200">  &quot;default link NvimDoubleQuote NvimStringQuote&quot;,</a>
<a name="ln6201">  &quot;default link NvimDoubleQuotedBody NvimStringBody&quot;,</a>
<a name="ln6202">  &quot;default link NvimDoubleQuotedEscape NvimStringSpecial&quot;,</a>
<a name="ln6203"> </a>
<a name="ln6204">  &quot;default link NvimFigureBrace NvimInternalError&quot;,</a>
<a name="ln6205">  &quot;default link NvimSingleQuotedUnknownEscape NvimInternalError&quot;,</a>
<a name="ln6206"> </a>
<a name="ln6207">  &quot;default link NvimSpacing Normal&quot;,</a>
<a name="ln6208"> </a>
<a name="ln6209">  // NvimInvalid groups:</a>
<a name="ln6210"> </a>
<a name="ln6211">  &quot;default link NvimInvalidSingleQuotedUnknownEscape NvimInternalError&quot;,</a>
<a name="ln6212"> </a>
<a name="ln6213">  &quot;default link NvimInvalid Error&quot;,</a>
<a name="ln6214"> </a>
<a name="ln6215">  &quot;default link NvimInvalidAssignment NvimInvalid&quot;,</a>
<a name="ln6216">  &quot;default link NvimInvalidPlainAssignment NvimInvalidAssignment&quot;,</a>
<a name="ln6217">  &quot;default link NvimInvalidAugmentedAssignment NvimInvalidAssignment&quot;,</a>
<a name="ln6218">  &quot;default link NvimInvalidAssignmentWithAddition &quot;</a>
<a name="ln6219">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6220">  &quot;default link NvimInvalidAssignmentWithSubtraction &quot;</a>
<a name="ln6221">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6222">  &quot;default link NvimInvalidAssignmentWithConcatenation &quot;</a>
<a name="ln6223">      &quot;NvimInvalidAugmentedAssignment&quot;,</a>
<a name="ln6224"> </a>
<a name="ln6225">  &quot;default link NvimInvalidOperator NvimInvalid&quot;,</a>
<a name="ln6226"> </a>
<a name="ln6227">  &quot;default link NvimInvalidUnaryOperator NvimInvalidOperator&quot;,</a>
<a name="ln6228">  &quot;default link NvimInvalidUnaryPlus NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6229">  &quot;default link NvimInvalidUnaryMinus NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6230">  &quot;default link NvimInvalidNot NvimInvalidUnaryOperator&quot;,</a>
<a name="ln6231"> </a>
<a name="ln6232">  &quot;default link NvimInvalidBinaryOperator NvimInvalidOperator&quot;,</a>
<a name="ln6233">  &quot;default link NvimInvalidComparison NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6234">  &quot;default link NvimInvalidComparisonModifier NvimInvalidComparison&quot;,</a>
<a name="ln6235">  &quot;default link NvimInvalidBinaryPlus NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6236">  &quot;default link NvimInvalidBinaryMinus NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6237">  &quot;default link NvimInvalidConcat NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6238">  &quot;default link NvimInvalidConcatOrSubscript NvimInvalidConcat&quot;,</a>
<a name="ln6239">  &quot;default link NvimInvalidOr NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6240">  &quot;default link NvimInvalidAnd NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6241">  &quot;default link NvimInvalidMultiplication NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6242">  &quot;default link NvimInvalidDivision NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6243">  &quot;default link NvimInvalidMod NvimInvalidBinaryOperator&quot;,</a>
<a name="ln6244"> </a>
<a name="ln6245">  &quot;default link NvimInvalidTernary NvimInvalidOperator&quot;,</a>
<a name="ln6246">  &quot;default link NvimInvalidTernaryColon NvimInvalidTernary&quot;,</a>
<a name="ln6247"> </a>
<a name="ln6248">  &quot;default link NvimInvalidDelimiter NvimInvalid&quot;,</a>
<a name="ln6249"> </a>
<a name="ln6250">  &quot;default link NvimInvalidParenthesis NvimInvalidDelimiter&quot;,</a>
<a name="ln6251">  &quot;default link NvimInvalidLambda NvimInvalidParenthesis&quot;,</a>
<a name="ln6252">  &quot;default link NvimInvalidNestingParenthesis NvimInvalidParenthesis&quot;,</a>
<a name="ln6253">  &quot;default link NvimInvalidCallingParenthesis NvimInvalidParenthesis&quot;,</a>
<a name="ln6254"> </a>
<a name="ln6255">  &quot;default link NvimInvalidSubscript NvimInvalidParenthesis&quot;,</a>
<a name="ln6256">  &quot;default link NvimInvalidSubscriptBracket NvimInvalidSubscript&quot;,</a>
<a name="ln6257">  &quot;default link NvimInvalidSubscriptColon NvimInvalidSubscript&quot;,</a>
<a name="ln6258">  &quot;default link NvimInvalidCurly NvimInvalidSubscript&quot;,</a>
<a name="ln6259"> </a>
<a name="ln6260">  &quot;default link NvimInvalidContainer NvimInvalidParenthesis&quot;,</a>
<a name="ln6261">  &quot;default link NvimInvalidDict NvimInvalidContainer&quot;,</a>
<a name="ln6262">  &quot;default link NvimInvalidList NvimInvalidContainer&quot;,</a>
<a name="ln6263"> </a>
<a name="ln6264">  &quot;default link NvimInvalidValue NvimInvalid&quot;,</a>
<a name="ln6265"> </a>
<a name="ln6266">  &quot;default link NvimInvalidIdentifier NvimInvalidValue&quot;,</a>
<a name="ln6267">  &quot;default link NvimInvalidIdentifierScope NvimInvalidIdentifier&quot;,</a>
<a name="ln6268">  &quot;default link NvimInvalidIdentifierScopeDelimiter NvimInvalidIdentifier&quot;,</a>
<a name="ln6269">  &quot;default link NvimInvalidIdentifierName NvimInvalidIdentifier&quot;,</a>
<a name="ln6270">  &quot;default link NvimInvalidIdentifierKey NvimInvalidIdentifier&quot;,</a>
<a name="ln6271"> </a>
<a name="ln6272">  &quot;default link NvimInvalidColon NvimInvalidDelimiter&quot;,</a>
<a name="ln6273">  &quot;default link NvimInvalidComma NvimInvalidDelimiter&quot;,</a>
<a name="ln6274">  &quot;default link NvimInvalidArrow NvimInvalidDelimiter&quot;,</a>
<a name="ln6275"> </a>
<a name="ln6276">  &quot;default link NvimInvalidRegister NvimInvalidValue&quot;,</a>
<a name="ln6277">  &quot;default link NvimInvalidNumber NvimInvalidValue&quot;,</a>
<a name="ln6278">  &quot;default link NvimInvalidFloat NvimInvalidNumber&quot;,</a>
<a name="ln6279">  &quot;default link NvimInvalidNumberPrefix NvimInvalidNumber&quot;,</a>
<a name="ln6280"> </a>
<a name="ln6281">  &quot;default link NvimInvalidOptionSigil NvimInvalidIdentifier&quot;,</a>
<a name="ln6282">  &quot;default link NvimInvalidOptionName NvimInvalidIdentifier&quot;,</a>
<a name="ln6283">  &quot;default link NvimInvalidOptionScope NvimInvalidIdentifierScope&quot;,</a>
<a name="ln6284">  &quot;default link NvimInvalidOptionScopeDelimiter &quot;</a>
<a name="ln6285">      &quot;NvimInvalidIdentifierScopeDelimiter&quot;,</a>
<a name="ln6286"> </a>
<a name="ln6287">  &quot;default link NvimInvalidEnvironmentSigil NvimInvalidOptionSigil&quot;,</a>
<a name="ln6288">  &quot;default link NvimInvalidEnvironmentName NvimInvalidIdentifier&quot;,</a>
<a name="ln6289"> </a>
<a name="ln6290">  // Invalid string bodies and specials are still highlighted as valid ones to</a>
<a name="ln6291">  // minimize the red area.</a>
<a name="ln6292">  &quot;default link NvimInvalidString NvimInvalidValue&quot;,</a>
<a name="ln6293">  &quot;default link NvimInvalidStringBody NvimStringBody&quot;,</a>
<a name="ln6294">  &quot;default link NvimInvalidStringQuote NvimInvalidString&quot;,</a>
<a name="ln6295">  &quot;default link NvimInvalidStringSpecial NvimStringSpecial&quot;,</a>
<a name="ln6296"> </a>
<a name="ln6297">  &quot;default link NvimInvalidSingleQuote NvimInvalidStringQuote&quot;,</a>
<a name="ln6298">  &quot;default link NvimInvalidSingleQuotedBody NvimInvalidStringBody&quot;,</a>
<a name="ln6299">  &quot;default link NvimInvalidSingleQuotedQuote NvimInvalidStringSpecial&quot;,</a>
<a name="ln6300"> </a>
<a name="ln6301">  &quot;default link NvimInvalidDoubleQuote NvimInvalidStringQuote&quot;,</a>
<a name="ln6302">  &quot;default link NvimInvalidDoubleQuotedBody NvimInvalidStringBody&quot;,</a>
<a name="ln6303">  &quot;default link NvimInvalidDoubleQuotedEscape NvimInvalidStringSpecial&quot;,</a>
<a name="ln6304">  &quot;default link NvimInvalidDoubleQuotedUnknownEscape NvimInvalidValue&quot;,</a>
<a name="ln6305"> </a>
<a name="ln6306">  &quot;default link NvimInvalidFigureBrace NvimInvalidDelimiter&quot;,</a>
<a name="ln6307"> </a>
<a name="ln6308">  &quot;default link NvimInvalidSpacing ErrorMsg&quot;,</a>
<a name="ln6309"> </a>
<a name="ln6310">  // Not actually invalid, but we highlight user that he is doing something</a>
<a name="ln6311">  // wrong.</a>
<a name="ln6312">  &quot;default link NvimDoubleQuotedUnknownEscape NvimInvalidValue&quot;,</a>
<a name="ln6313">  NULL,</a>
<a name="ln6314">};</a>
<a name="ln6315"> </a>
<a name="ln6316">/// Create default links for Nvim* highlight groups used for cmdline coloring</a>
<a name="ln6317">void syn_init_cmdline_highlight(bool reset, bool init)</a>
<a name="ln6318">{</a>
<a name="ln6319">  for (size_t i = 0 ; highlight_init_cmdline[i] != NULL ; i++) {</a>
<a name="ln6320">    do_highlight(highlight_init_cmdline[i], reset, init);</a>
<a name="ln6321">  }</a>
<a name="ln6322">}</a>
<a name="ln6323"> </a>
<a name="ln6324">/// Load colors from a file if &quot;g:colors_name&quot; is set, otherwise load builtin</a>
<a name="ln6325">/// colors</a>
<a name="ln6326">///</a>
<a name="ln6327">/// @param both include groups where 'bg' doesn't matter</a>
<a name="ln6328">/// @param reset clear groups first</a>
<a name="ln6329">void init_highlight(bool both, bool reset)</a>
<a name="ln6330">{</a>
<a name="ln6331">  static int had_both = false;</a>
<a name="ln6332"> </a>
<a name="ln6333">  // Try finding the color scheme file.  Used when a color file was loaded</a>
<a name="ln6334">  // and 'background' or 't_Co' is changed.</a>
<a name="ln6335">  char_u *p = get_var_value(&quot;g:colors_name&quot;);</a>
<a name="ln6336">  if (p != NULL) {</a>
<a name="ln6337">    // Value of g:colors_name could be freed in load_colors() and make</a>
<a name="ln6338">    // p invalid, so copy it.</a>
<a name="ln6339">    char_u *copy_p = vim_strsave(p);</a>
<a name="ln6340">    bool okay = load_colors(copy_p);</a>
<a name="ln6341">    xfree(copy_p);</a>
<a name="ln6342">    if (okay) {</a>
<a name="ln6343">        return;</a>
<a name="ln6344">    }</a>
<a name="ln6345">  }</a>
<a name="ln6346"> </a>
<a name="ln6347">  /*</a>
<a name="ln6348">   * Didn't use a color file, use the compiled-in colors.</a>
<a name="ln6349">   */</a>
<a name="ln6350">  if (both) {</a>
<a name="ln6351">    had_both = true;</a>
<a name="ln6352">    const char *const *const pp = highlight_init_both;</a>
<a name="ln6353">    for (size_t i = 0; pp[i] != NULL; i++) {</a>
<a name="ln6354">      do_highlight(pp[i], reset, true);</a>
<a name="ln6355">    }</a>
<a name="ln6356">  } else if (!had_both) {</a>
<a name="ln6357">    // Don't do anything before the call with both == TRUE from main().</a>
<a name="ln6358">    // Not everything has been setup then, and that call will overrule</a>
<a name="ln6359">    // everything anyway.</a>
<a name="ln6360">    return;</a>
<a name="ln6361">  }</a>
<a name="ln6362"> </a>
<a name="ln6363">  const char *const *const pp = ((*p_bg == 'l')</a>
<a name="ln6364">                                 ? highlight_init_light</a>
<a name="ln6365">                                 : highlight_init_dark);</a>
<a name="ln6366">  for (size_t i = 0; pp[i] != NULL; i++) {</a>
<a name="ln6367">    do_highlight(pp[i], reset, true);</a>
<a name="ln6368">  }</a>
<a name="ln6369"> </a>
<a name="ln6370">  /* Reverse looks ugly, but grey may not work for 8 colors.  Thus let it</a>
<a name="ln6371">   * depend on the number of colors available.</a>
<a name="ln6372">   * With 8 colors brown is equal to yellow, need to use black for Search fg</a>
<a name="ln6373">   * to avoid Statement highlighted text disappears.</a>
<a name="ln6374">   * Clear the attributes, needed when changing the t_Co value. */</a>
<a name="ln6375">  if (t_colors &gt; 8) {</a>
<a name="ln6376">    do_highlight(</a>
<a name="ln6377">        (*p_bg == 'l'</a>
<a name="ln6378">         ? &quot;Visual cterm=NONE ctermbg=LightGrey&quot;</a>
<a name="ln6379">         : &quot;Visual cterm=NONE ctermbg=DarkGrey&quot;), false, true);</a>
<a name="ln6380">  } else {</a>
<a name="ln6381">    do_highlight(&quot;Visual cterm=reverse ctermbg=NONE&quot;, false, true);</a>
<a name="ln6382">    if (*p_bg == 'l') {</a>
<a name="ln6383">      do_highlight(&quot;Search ctermfg=black&quot;, false, true);</a>
<a name="ln6384">    }</a>
<a name="ln6385">  }</a>
<a name="ln6386"> </a>
<a name="ln6387">  /*</a>
<a name="ln6388">   * If syntax highlighting is enabled load the highlighting for it.</a>
<a name="ln6389">   */</a>
<a name="ln6390">  if (get_var_value(&quot;g:syntax_on&quot;) != NULL) {</a>
<a name="ln6391">    static int recursive = 0;</a>
<a name="ln6392"> </a>
<a name="ln6393">    if (recursive &gt;= 5) {</a>
<a name="ln6394">      EMSG(_(&quot;E679: recursive loop loading syncolor.vim&quot;));</a>
<a name="ln6395">    } else {</a>
<a name="ln6396">      recursive++;</a>
<a name="ln6397">      (void)source_runtime((char_u *)&quot;syntax/syncolor.vim&quot;, DIP_ALL);</a>
<a name="ln6398">      recursive--;</a>
<a name="ln6399">    }</a>
<a name="ln6400">  }</a>
<a name="ln6401">  syn_init_cmdline_highlight(false, false);</a>
<a name="ln6402">}</a>
<a name="ln6403"> </a>
<a name="ln6404">/*</a>
<a name="ln6405"> * Load color file &quot;name&quot;.</a>
<a name="ln6406"> * Return OK for success, FAIL for failure.</a>
<a name="ln6407"> */</a>
<a name="ln6408">int load_colors(char_u *name)</a>
<a name="ln6409">{</a>
<a name="ln6410">  char_u      *buf;</a>
<a name="ln6411">  int retval = FAIL;</a>
<a name="ln6412">  static int recursive = false;</a>
<a name="ln6413"> </a>
<a name="ln6414">  // When being called recursively, this is probably because setting</a>
<a name="ln6415">  // 'background' caused the highlighting to be reloaded.  This means it is</a>
<a name="ln6416">  // working, thus we should return OK.</a>
<a name="ln6417">  if (recursive) {</a>
<a name="ln6418">    return OK;</a>
<a name="ln6419">  }</a>
<a name="ln6420"> </a>
<a name="ln6421">  recursive = true;</a>
<a name="ln6422">  size_t buflen = STRLEN(name) + 12;</a>
<a name="ln6423">  buf = xmalloc(buflen);</a>
<a name="ln6424">  apply_autocmds(EVENT_COLORSCHEMEPRE, name, curbuf-&gt;b_fname, false, curbuf);</a>
<a name="ln6425">  snprintf((char *)buf, buflen, &quot;colors/%s.vim&quot;, name);</a>
<a name="ln6426">  retval = source_runtime(buf, DIP_START + DIP_OPT);</a>
<a name="ln6427">  xfree(buf);</a>
<a name="ln6428">  apply_autocmds(EVENT_COLORSCHEME, name, curbuf-&gt;b_fname, FALSE, curbuf);</a>
<a name="ln6429"> </a>
<a name="ln6430">  recursive = false;</a>
<a name="ln6431"> </a>
<a name="ln6432">  return retval;</a>
<a name="ln6433">}</a>
<a name="ln6434"> </a>
<a name="ln6435">static char *(color_names[28]) = {</a>
<a name="ln6436">  &quot;Black&quot;, &quot;DarkBlue&quot;, &quot;DarkGreen&quot;, &quot;DarkCyan&quot;,</a>
<a name="ln6437">  &quot;DarkRed&quot;, &quot;DarkMagenta&quot;, &quot;Brown&quot;, &quot;DarkYellow&quot;,</a>
<a name="ln6438">  &quot;Gray&quot;, &quot;Grey&quot;, &quot;LightGray&quot;, &quot;LightGrey&quot;,</a>
<a name="ln6439">  &quot;DarkGray&quot;, &quot;DarkGrey&quot;,</a>
<a name="ln6440">  &quot;Blue&quot;, &quot;LightBlue&quot;, &quot;Green&quot;, &quot;LightGreen&quot;,</a>
<a name="ln6441">  &quot;Cyan&quot;, &quot;LightCyan&quot;, &quot;Red&quot;, &quot;LightRed&quot;, &quot;Magenta&quot;,</a>
<a name="ln6442">  &quot;LightMagenta&quot;, &quot;Yellow&quot;, &quot;LightYellow&quot;, &quot;White&quot;, &quot;NONE&quot; };</a>
<a name="ln6443">  // indices:</a>
<a name="ln6444">  // 0, 1, 2, 3,</a>
<a name="ln6445">  // 4, 5, 6, 7,</a>
<a name="ln6446">  // 8, 9, 10, 11,</a>
<a name="ln6447">  // 12, 13,</a>
<a name="ln6448">  // 14, 15, 16, 17,</a>
<a name="ln6449">  // 18, 19, 20, 21, 22,</a>
<a name="ln6450">  // 23, 24, 25, 26, 27</a>
<a name="ln6451">static int color_numbers_16[28] = { 0, 1, 2, 3,</a>
<a name="ln6452">  4, 5, 6, 6,</a>
<a name="ln6453">  7, 7, 7, 7,</a>
<a name="ln6454">  8, 8,</a>
<a name="ln6455">  9, 9, 10, 10,</a>
<a name="ln6456">  11, 11, 12, 12, 13,</a>
<a name="ln6457">  13, 14, 14, 15, -1 };</a>
<a name="ln6458">// for xterm with 88 colors...</a>
<a name="ln6459">static int color_numbers_88[28] = { 0, 4, 2, 6,</a>
<a name="ln6460">  1, 5, 32, 72,</a>
<a name="ln6461">  84, 84, 7, 7,</a>
<a name="ln6462">  82, 82,</a>
<a name="ln6463">  12, 43, 10, 61,</a>
<a name="ln6464">  14, 63, 9, 74, 13,</a>
<a name="ln6465">  75, 11, 78, 15, -1 };</a>
<a name="ln6466">// for xterm with 256 colors...</a>
<a name="ln6467">static int color_numbers_256[28] = { 0, 4, 2, 6,</a>
<a name="ln6468">  1, 5, 130, 3,</a>
<a name="ln6469">  248, 248, 7, 7,</a>
<a name="ln6470">  242, 242,</a>
<a name="ln6471">  12, 81, 10, 121,</a>
<a name="ln6472">  14, 159, 9, 224, 13,</a>
<a name="ln6473">  225, 11, 229, 15, -1 };</a>
<a name="ln6474">// for terminals with less than 16 colors...</a>
<a name="ln6475">static int color_numbers_8[28] = { 0, 4, 2, 6,</a>
<a name="ln6476">  1, 5, 3, 3,</a>
<a name="ln6477">  7, 7, 7, 7,</a>
<a name="ln6478">  0+8, 0+8,</a>
<a name="ln6479">  4+8, 4+8, 2+8, 2+8,</a>
<a name="ln6480">  6+8, 6+8, 1+8, 1+8, 5+8,</a>
<a name="ln6481">  5+8, 3+8, 3+8, 7+8, -1 };</a>
<a name="ln6482"> </a>
<a name="ln6483">// Lookup the &quot;cterm&quot; value to be used for color with index &quot;idx&quot; in</a>
<a name="ln6484">// color_names[].</a>
<a name="ln6485">// &quot;boldp&quot; will be set to TRUE or FALSE for a foreground color when using 8</a>
<a name="ln6486">// colors, otherwise it will be unchanged.</a>
<a name="ln6487">int lookup_color(const int idx, const bool foreground, TriState *const boldp)</a>
<a name="ln6488">{</a>
<a name="ln6489">  int color = color_numbers_16[idx];</a>
<a name="ln6490"> </a>
<a name="ln6491">  // Use the _16 table to check if it's a valid color name.</a>
<a name="ln6492">  if (color &lt; 0) {</a>
<a name="ln6493">    return -1;</a>
<a name="ln6494">  }</a>
<a name="ln6495"> </a>
<a name="ln6496">  if (t_colors == 8) {</a>
<a name="ln6497">    // t_Co is 8: use the 8 colors table</a>
<a name="ln6498">    color = color_numbers_8[idx];</a>
<a name="ln6499">    if (foreground) {</a>
<a name="ln6500">      // set/reset bold attribute to get light foreground</a>
<a name="ln6501">      // colors (on some terminals, e.g. &quot;linux&quot;)</a>
<a name="ln6502">      if (color &amp; 8) {</a>
<a name="ln6503">        *boldp = kTrue;</a>
<a name="ln6504">      } else {</a>
<a name="ln6505">        *boldp = kFalse;</a>
<a name="ln6506">      }</a>
<a name="ln6507">    }</a>
<a name="ln6508">    color &amp;= 7;   // truncate to 8 colors</a>
<a name="ln6509">  } else if (t_colors == 16) {</a>
<a name="ln6510">    color = color_numbers_8[idx];</a>
<a name="ln6511">  } else if (t_colors == 88) {</a>
<a name="ln6512">    color = color_numbers_88[idx];</a>
<a name="ln6513">  } else if (t_colors &gt;= 256) {</a>
<a name="ln6514">    color = color_numbers_256[idx];</a>
<a name="ln6515">  }</a>
<a name="ln6516">  return color;</a>
<a name="ln6517">}</a>
<a name="ln6518"> </a>
<a name="ln6519"> </a>
<a name="ln6520">/// Handle &quot;:highlight&quot; command</a>
<a name="ln6521">///</a>
<a name="ln6522">/// When using &quot;:highlight clear&quot; this is called recursively for each group with</a>
<a name="ln6523">/// forceit and init being both true.</a>
<a name="ln6524">///</a>
<a name="ln6525">/// @param[in]  line  Command arguments.</a>
<a name="ln6526">/// @param[in]  forceit  True when bang is given, allows to link group even if</a>
<a name="ln6527">///                      it has its own settings.</a>
<a name="ln6528">/// @param[in]  init  True when initializing.</a>
<a name="ln6529">void do_highlight(const char *line, const bool forceit, const bool init)</a>
<a name="ln6530">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6531">{</a>
<a name="ln6532">  const char *name_end;</a>
<a name="ln6533">  const char *linep;</a>
<a name="ln6534">  const char *key_start;</a>
<a name="ln6535">  const char *arg_start;</a>
<a name="ln6536">  long i;</a>
<a name="ln6537">  int off;</a>
<a name="ln6538">  int len;</a>
<a name="ln6539">  int attr;</a>
<a name="ln6540">  int id;</a>
<a name="ln6541">  int idx;</a>
<a name="ln6542">  struct hl_group item_before;</a>
<a name="ln6543">  bool did_change = false;</a>
<a name="ln6544">  bool dodefault = false;</a>
<a name="ln6545">  bool doclear = false;</a>
<a name="ln6546">  bool dolink = false;</a>
<a name="ln6547">  bool error = false;</a>
<a name="ln6548">  int color;</a>
<a name="ln6549">  bool is_normal_group = false;   // &quot;Normal&quot; group</a>
<a name="ln6550">  bool did_highlight_changed = false;</a>
<a name="ln6551"> </a>
<a name="ln6552">  // If no argument, list current highlighting.</a>
<a name="ln6553">  if (ends_excmd((uint8_t)(*line))) {</a>
<a name="ln6554">    for (i = 1; i &lt;= highlight_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln6555">      // TODO(brammool): only call when the group has attributes set</a>
<a name="ln6556">      highlight_list_one(i);</a>
<a name="ln6557">    }</a>
<a name="ln6558">    return;</a>
<a name="ln6559">  }</a>
<a name="ln6560"> </a>
<a name="ln6561">  // Isolate the name.</a>
<a name="ln6562">  name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6563">  linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6564"> </a>
<a name="ln6565">  // Check for &quot;default&quot; argument.</a>
<a name="ln6566">  if (strncmp(line, &quot;default&quot;, name_end - line) == 0) {</a>
<a name="ln6567">    dodefault = true;</a>
<a name="ln6568">    line = linep;</a>
<a name="ln6569">    name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6570">    linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6571">  }</a>
<a name="ln6572"> </a>
<a name="ln6573">  // Check for &quot;clear&quot; or &quot;link&quot; argument.</a>
<a name="ln6574">  if (strncmp(line, &quot;clear&quot;, name_end - line) == 0) {</a>
<a name="ln6575">    doclear = true;</a>
<a name="ln6576">  } else if (strncmp(line, &quot;link&quot;, name_end - line) == 0) {</a>
<a name="ln6577">    dolink = true;</a>
<a name="ln6578">  }</a>
<a name="ln6579"> </a>
<a name="ln6580">  // &quot;:highlight {group-name}&quot;: list highlighting for one group.</a>
<a name="ln6581">  if (!doclear &amp;&amp; !dolink &amp;&amp; ends_excmd((uint8_t)(*linep))) {</a>
<a name="ln6582">    id = syn_namen2id((const char_u *)line, (int)(name_end - line));</a>
<a name="ln6583">    if (id == 0) {</a>
<a name="ln6584">      emsgf(_(&quot;E411: highlight group not found: %s&quot;), line);</a>
<a name="ln6585">    } else {</a>
<a name="ln6586">      highlight_list_one(id);</a>
<a name="ln6587">    }</a>
<a name="ln6588">    return;</a>
<a name="ln6589">  }</a>
<a name="ln6590"> </a>
<a name="ln6591">  // Handle &quot;:highlight link {from} {to}&quot; command.</a>
<a name="ln6592">  if (dolink) {</a>
<a name="ln6593">    const char *from_start = linep;</a>
<a name="ln6594">    const char *from_end;</a>
<a name="ln6595">    const char *to_start;</a>
<a name="ln6596">    const char *to_end;</a>
<a name="ln6597">    int from_id;</a>
<a name="ln6598">    int to_id;</a>
<a name="ln6599"> </a>
<a name="ln6600">    from_end = (const char *)skiptowhite((const char_u *)from_start);</a>
<a name="ln6601">    to_start = (const char *)skipwhite((const char_u *)from_end);</a>
<a name="ln6602">    to_end   = (const char *)skiptowhite((const char_u *)to_start);</a>
<a name="ln6603"> </a>
<a name="ln6604">    if (ends_excmd((uint8_t)(*from_start))</a>
<a name="ln6605">        || ends_excmd((uint8_t)(*to_start))) {</a>
<a name="ln6606">      emsgf(_(&quot;E412: Not enough arguments: \&quot;:highlight link %s\&quot;&quot;),</a>
<a name="ln6607">            from_start);</a>
<a name="ln6608">      return;</a>
<a name="ln6609">    }</a>
<a name="ln6610"> </a>
<a name="ln6611">    if (!ends_excmd(*skipwhite((const char_u *)to_end))) {</a>
<a name="ln6612">      emsgf(_(&quot;E413: Too many arguments: \&quot;:highlight link %s\&quot;&quot;), from_start);</a>
<a name="ln6613">      return;</a>
<a name="ln6614">    }</a>
<a name="ln6615"> </a>
<a name="ln6616">    from_id = syn_check_group((const char_u *)from_start,</a>
<a name="ln6617">                              (int)(from_end - from_start));</a>
<a name="ln6618">    if (strncmp(to_start, &quot;NONE&quot;, 4) == 0) {</a>
<a name="ln6619">      to_id = 0;</a>
<a name="ln6620">    } else {</a>
<a name="ln6621">      to_id = syn_check_group((const char_u *)to_start,</a>
<a name="ln6622">                              (int)(to_end - to_start));</a>
<a name="ln6623">    }</a>
<a name="ln6624"> </a>
<a name="ln6625">    if (from_id &gt; 0 &amp;&amp; (!init || HL_TABLE()[from_id - 1].sg_set == 0)) {</a>
<a name="ln6626">      // Don't allow a link when there already is some highlighting</a>
<a name="ln6627">      // for the group, unless '!' is used</a>
<a name="ln6628">      if (to_id &gt; 0 &amp;&amp; !forceit &amp;&amp; !init</a>
<a name="ln6629">          &amp;&amp; hl_has_settings(from_id - 1, dodefault)) {</a>
<a name="ln6630">        if (sourcing_name == NULL &amp;&amp; !dodefault) {</a>
<a name="ln6631">          EMSG(_(&quot;E414: group has settings, highlight link ignored&quot;));</a>
<a name="ln6632">        }</a>
<a name="ln6633">      } else if (HL_TABLE()[from_id - 1].sg_link != to_id</a>
<a name="ln6634">                 || HL_TABLE()[from_id - 1].sg_script_ctx.sc_sid</a>
<a name="ln6635">                 != current_sctx.sc_sid</a>
<a name="ln6636">                 || HL_TABLE()[from_id - 1].sg_cleared) {</a>
<a name="ln6637">        if (!init) {</a>
<a name="ln6638">          HL_TABLE()[from_id - 1].sg_set |= SG_LINK;</a>
<a name="ln6639">        }</a>
<a name="ln6640">        HL_TABLE()[from_id - 1].sg_link = to_id;</a>
<a name="ln6641">        HL_TABLE()[from_id - 1].sg_script_ctx = current_sctx;</a>
<a name="ln6642">        HL_TABLE()[from_id - 1].sg_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln6643">        HL_TABLE()[from_id - 1].sg_cleared = false;</a>
<a name="ln6644">        redraw_all_later(SOME_VALID);</a>
<a name="ln6645"> </a>
<a name="ln6646">        // Only call highlight changed() once after multiple changes</a>
<a name="ln6647">        need_highlight_changed = true;</a>
<a name="ln6648">      }</a>
<a name="ln6649">    }</a>
<a name="ln6650"> </a>
<a name="ln6651">    return;</a>
<a name="ln6652">  }</a>
<a name="ln6653"> </a>
<a name="ln6654">  if (doclear) {</a>
<a name="ln6655">    // &quot;:highlight clear [group]&quot; command.</a>
<a name="ln6656">    line = linep;</a>
<a name="ln6657">    if (ends_excmd((uint8_t)(*line))) {</a>
<a name="ln6658">      do_unlet(S_LEN(&quot;colors_name&quot;), true);</a>
<a name="ln6659">      restore_cterm_colors();</a>
<a name="ln6660"> </a>
<a name="ln6661">      // Clear all default highlight groups and load the defaults.</a>
<a name="ln6662">      for (int j = 0; j &lt; highlight_ga.ga_len; j++) {</a>
<a name="ln6663">        highlight_clear(j);</a>
<a name="ln6664">      }</a>
<a name="ln6665">      init_highlight(true, true);</a>
<a name="ln6666">      highlight_changed();</a>
<a name="ln6667">      redraw_all_later(NOT_VALID);</a>
<a name="ln6668">      return;</a>
<a name="ln6669">    }</a>
<a name="ln6670">    name_end = (const char *)skiptowhite((const char_u *)line);</a>
<a name="ln6671">    linep = (const char *)skipwhite((const char_u *)name_end);</a>
<a name="ln6672">  }</a>
<a name="ln6673"> </a>
<a name="ln6674">  // Find the group name in the table.  If it does not exist yet, add it.</a>
<a name="ln6675">  id = syn_check_group((const char_u *)line, (int)(name_end - line));</a>
<a name="ln6676">  if (id == 0) {  // Failed (out of memory).</a>
<a name="ln6677">    return;</a>
<a name="ln6678">  }</a>
<a name="ln6679">  idx = id - 1;  // Index is ID minus one.</a>
<a name="ln6680"> </a>
<a name="ln6681">  // Return if &quot;default&quot; was used and the group already has settings</a>
<a name="ln6682">  if (dodefault &amp;&amp; hl_has_settings(idx, true)) {</a>
<a name="ln6683">    return;</a>
<a name="ln6684">  }</a>
<a name="ln6685"> </a>
<a name="ln6686">  // Make a copy so we can check if any attribute actually changed</a>
<a name="ln6687">  item_before = HL_TABLE()[idx];</a>
<a name="ln6688">  is_normal_group = (STRCMP(HL_TABLE()[idx].sg_name_u, &quot;NORMAL&quot;) == 0);</a>
<a name="ln6689"> </a>
<a name="ln6690">  // Clear the highlighting for &quot;:hi clear {group}&quot; and &quot;:hi clear&quot;.</a>
<a name="ln6691">  if (doclear || (forceit &amp;&amp; init)) {</a>
<a name="ln6692">    highlight_clear(idx);</a>
<a name="ln6693">    if (!doclear) {</a>
<a name="ln6694">      HL_TABLE()[idx].sg_set = 0;</a>
<a name="ln6695">    }</a>
<a name="ln6696">  }</a>
<a name="ln6697"> </a>
<a name="ln6698">  char *key = NULL;</a>
<a name="ln6699">  char *arg = NULL;</a>
<a name="ln6700">  if (!doclear) {</a>
<a name="ln6701">    while (!ends_excmd((uint8_t)(*linep))) {</a>
<a name="ln6702">      key_start = linep;</a>
<a name="ln6703">      if (*linep == '=') {</a>
<a name="ln6704">        emsgf(_(&quot;E415: unexpected equal sign: %s&quot;), key_start);</a>
<a name="ln6705">        error = true;</a>
<a name="ln6706">        break;</a>
<a name="ln6707">      }</a>
<a name="ln6708"> </a>
<a name="ln6709">      // Isolate the key (&quot;term&quot;, &quot;ctermfg&quot;, &quot;ctermbg&quot;, &quot;font&quot;, &quot;guifg&quot;,</a>
<a name="ln6710">      // &quot;guibg&quot; or &quot;guisp&quot;).</a>
<a name="ln6711">      while (*linep &amp;&amp; !ascii_iswhite(*linep) &amp;&amp; *linep != '=') {</a>
<a name="ln6712">        linep++;</a>
<a name="ln6713">      }</a>
<a name="ln6714">      xfree(key);</a>
<a name="ln6715">      key = (char *)vim_strnsave_up((const char_u *)key_start,</a>
<a name="ln6716">                                    (int)(linep - key_start));</a>
<a name="ln6717">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln6718"> </a>
<a name="ln6719">      if (strcmp(key, &quot;NONE&quot;) == 0) {</a>
<a name="ln6720">        if (!init || HL_TABLE()[idx].sg_set == 0) {</a>
<a name="ln6721">          if (!init) {</a>
<a name="ln6722">            HL_TABLE()[idx].sg_set |= SG_CTERM+SG_GUI;</a>
<a name="ln6723">          }</a>
<a name="ln6724">          highlight_clear(idx);</a>
<a name="ln6725">        }</a>
<a name="ln6726">        continue;</a>
<a name="ln6727">      }</a>
<a name="ln6728"> </a>
<a name="ln6729">      // Check for the equal sign.</a>
<a name="ln6730">      if (*linep != '=') {</a>
<a name="ln6731">        emsgf(_(&quot;E416: missing equal sign: %s&quot;), key_start);</a>
<a name="ln6732">        error = true;</a>
<a name="ln6733">        break;</a>
<a name="ln6734">      }</a>
<a name="ln6735">      linep++;</a>
<a name="ln6736"> </a>
<a name="ln6737">      // Isolate the argument.</a>
<a name="ln6738">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln6739">      if (*linep == '\'') {  // guifg='color name'</a>
<a name="ln6740">        arg_start = ++linep;</a>
<a name="ln6741">        linep = strchr(linep, '\'');</a>
<a name="ln6742">        if (linep == NULL) {</a>
<a name="ln6743">          emsgf(_(e_invarg2), key_start);</a>
<a name="ln6744">          error = true;</a>
<a name="ln6745">          break;</a>
<a name="ln6746">        }</a>
<a name="ln6747">      } else {</a>
<a name="ln6748">        arg_start = linep;</a>
<a name="ln6749">        linep = (const char *)skiptowhite((const char_u *)linep);</a>
<a name="ln6750">      }</a>
<a name="ln6751">      if (linep == arg_start) {</a>
<a name="ln6752">        emsgf(_(&quot;E417: missing argument: %s&quot;), key_start);</a>
<a name="ln6753">        error = true;</a>
<a name="ln6754">        break;</a>
<a name="ln6755">      }</a>
<a name="ln6756">      xfree(arg);</a>
<a name="ln6757">      arg = xstrndup(arg_start, (size_t)(linep - arg_start));</a>
<a name="ln6758"> </a>
<a name="ln6759">      if (*linep == '\'') {</a>
<a name="ln6760">        linep++;</a>
<a name="ln6761">      }</a>
<a name="ln6762"> </a>
<a name="ln6763">      // Store the argument.</a>
<a name="ln6764">      if (strcmp(key, &quot;TERM&quot;) == 0</a>
<a name="ln6765">          || strcmp(key, &quot;CTERM&quot;) == 0</a>
<a name="ln6766">          || strcmp(key, &quot;GUI&quot;) == 0) {</a>
<a name="ln6767">        attr = 0;</a>
<a name="ln6768">        off = 0;</a>
<a name="ln6769">        while (arg[off] != NUL) {</a>
<a name="ln6770">          for (i = ARRAY_SIZE(hl_attr_table); --i &gt;= 0; ) {</a>
<a name="ln6771">            len = (int)STRLEN(hl_name_table[i]);</a>
<a name="ln6772">            if (STRNICMP(arg + off, hl_name_table[i], len) == 0) {</a>
<a name="ln6773">              attr |= hl_attr_table[i];</a>
<a name="ln6774">              off += len;</a>
<a name="ln6775">              break;</a>
<a name="ln6776">            }</a>
<a name="ln6777">          }</a>
<a name="ln6778">          if (i &lt; 0) {</a>
<a name="ln6779">            emsgf(_(&quot;E418: Illegal value: %s&quot;), arg);</a>
<a name="ln6780">            error = true;</a>
<a name="ln6781">            break;</a>
<a name="ln6782">          }</a>
<a name="ln6783">          if (arg[off] == ',') {  // Another one follows.</a>
<a name="ln6784">            off++;</a>
<a name="ln6785">          }</a>
<a name="ln6786">        }</a>
<a name="ln6787">        if (error) {</a>
<a name="ln6788">          break;</a>
<a name="ln6789">        }</a>
<a name="ln6790">        if (*key == 'C')   {</a>
<a name="ln6791">          if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_CTERM)) {</a>
<a name="ln6792">            if (!init) {</a>
<a name="ln6793">              HL_TABLE()[idx].sg_set |= SG_CTERM;</a>
<a name="ln6794">            }</a>
<a name="ln6795">            HL_TABLE()[idx].sg_cterm = attr;</a>
<a name="ln6796">            HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln6797">          }</a>
<a name="ln6798">        } else if (*key == 'G') {</a>
<a name="ln6799">          if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6800">            if (!init) {</a>
<a name="ln6801">              HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6802">            }</a>
<a name="ln6803">            HL_TABLE()[idx].sg_gui = attr;</a>
<a name="ln6804">          }</a>
<a name="ln6805">        }</a>
<a name="ln6806">      } else if (STRCMP(key, &quot;FONT&quot;) == 0)   {</a>
<a name="ln6807">        // in non-GUI fonts are simply ignored</a>
<a name="ln6808">      } else if (STRCMP(key, &quot;CTERMFG&quot;) == 0 || STRCMP(key, &quot;CTERMBG&quot;) == 0) {</a>
<a name="ln6809">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_CTERM)) {</a>
<a name="ln6810">          if (!init) {</a>
<a name="ln6811">            HL_TABLE()[idx].sg_set |= SG_CTERM;</a>
<a name="ln6812">          }</a>
<a name="ln6813"> </a>
<a name="ln6814">          /* When setting the foreground color, and previously the &quot;bold&quot;</a>
<a name="ln6815">           * flag was set for a light color, reset it now */</a>
<a name="ln6816">          if (key[5] == 'F' &amp;&amp; HL_TABLE()[idx].sg_cterm_bold) {</a>
<a name="ln6817">            HL_TABLE()[idx].sg_cterm &amp;= ~HL_BOLD;</a>
<a name="ln6818">            HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln6819">          }</a>
<a name="ln6820"> </a>
<a name="ln6821">          if (ascii_isdigit(*arg)) {</a>
<a name="ln6822">            color = atoi((char *)arg);</a>
<a name="ln6823">          } else if (STRICMP(arg, &quot;fg&quot;) == 0) {</a>
<a name="ln6824">            if (cterm_normal_fg_color) {</a>
<a name="ln6825">              color = cterm_normal_fg_color - 1;</a>
<a name="ln6826">            } else {</a>
<a name="ln6827">              EMSG(_(&quot;E419: FG color unknown&quot;));</a>
<a name="ln6828">              error = true;</a>
<a name="ln6829">              break;</a>
<a name="ln6830">            }</a>
<a name="ln6831">          } else if (STRICMP(arg, &quot;bg&quot;) == 0)   {</a>
<a name="ln6832">            if (cterm_normal_bg_color &gt; 0)</a>
<a name="ln6833">              color = cterm_normal_bg_color - 1;</a>
<a name="ln6834">            else {</a>
<a name="ln6835">              EMSG(_(&quot;E420: BG color unknown&quot;));</a>
<a name="ln6836">              error = true;</a>
<a name="ln6837">              break;</a>
<a name="ln6838">            }</a>
<a name="ln6839">          } else {</a>
<a name="ln6840">            // Reduce calls to STRICMP a bit, it can be slow.</a>
<a name="ln6841">            off = TOUPPER_ASC(*arg);</a>
<a name="ln6842">            for (i = ARRAY_SIZE(color_names); --i &gt;= 0; ) {</a>
<a name="ln6843">              if (off == color_names[i][0]</a>
<a name="ln6844">                  &amp;&amp; STRICMP(arg + 1, color_names[i] + 1) == 0) {</a>
<a name="ln6845">                break;</a>
<a name="ln6846">              }</a>
<a name="ln6847">            }</a>
<a name="ln6848">            if (i &lt; 0) {</a>
<a name="ln6849">              emsgf(_(&quot;E421: Color name or number not recognized: %s&quot;),</a>
<a name="ln6850">                    key_start);</a>
<a name="ln6851">              error = true;</a>
<a name="ln6852">              break;</a>
<a name="ln6853">            }</a>
<a name="ln6854"> </a>
<a name="ln6855">            TriState bold = kNone;</a>
<a name="ln6856">            color = lookup_color(i, key[5] == 'F', &amp;bold);</a>
<a name="ln6857"> </a>
<a name="ln6858">            // set/reset bold attribute to get light foreground</a>
<a name="ln6859">            // colors (on some terminals, e.g. &quot;linux&quot;)</a>
<a name="ln6860">            if (bold == kTrue) {</a>
<a name="ln6861">              HL_TABLE()[idx].sg_cterm |= HL_BOLD;</a>
<a name="ln6862">              HL_TABLE()[idx].sg_cterm_bold = true;</a>
<a name="ln6863">            } else if (bold == kFalse) {</a>
<a name="ln6864">              HL_TABLE()[idx].sg_cterm &amp;= ~HL_BOLD;</a>
<a name="ln6865">            }</a>
<a name="ln6866">          }</a>
<a name="ln6867">          // Add one to the argument, to avoid zero.  Zero is used for</a>
<a name="ln6868">          // &quot;NONE&quot;, then &quot;color&quot; is -1.</a>
<a name="ln6869">          if (key[5] == 'F') {</a>
<a name="ln6870">            HL_TABLE()[idx].sg_cterm_fg = color + 1;</a>
<a name="ln6871">            if (is_normal_group) {</a>
<a name="ln6872">              cterm_normal_fg_color = color + 1;</a>
<a name="ln6873">            }</a>
<a name="ln6874">          } else {</a>
<a name="ln6875">            HL_TABLE()[idx].sg_cterm_bg = color + 1;</a>
<a name="ln6876">            if (is_normal_group) {</a>
<a name="ln6877">              cterm_normal_bg_color = color + 1;</a>
<a name="ln6878">              if (!ui_rgb_attached()) {</a>
<a name="ln6879">                if (color &gt;= 0) {</a>
<a name="ln6880">                  int dark = -1;</a>
<a name="ln6881"> </a>
<a name="ln6882">                  if (t_colors &lt; 16) {</a>
<a name="ln6883">                    dark = (color == 0 || color == 4);</a>
<a name="ln6884">                  } else if (color &lt; 16) {</a>
<a name="ln6885">                    // Limit the heuristic to the standard 16 colors</a>
<a name="ln6886">                    dark = (color &lt; 7 || color == 8);</a>
<a name="ln6887">                  }</a>
<a name="ln6888">                  // Set the 'background' option if the value is</a>
<a name="ln6889">                  // wrong.</a>
<a name="ln6890">                  if (dark != -1</a>
<a name="ln6891">                      &amp;&amp; dark != (*p_bg == 'd')</a>
<a name="ln6892">                      &amp;&amp; !option_was_set(&quot;bg&quot;)) {</a>
<a name="ln6893">                    set_option_value(&quot;bg&quot;, 0L, (dark ? &quot;dark&quot; : &quot;light&quot;), 0);</a>
<a name="ln6894">                    reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln6895">                  }</a>
<a name="ln6896">                }</a>
<a name="ln6897">              }</a>
<a name="ln6898">            }</a>
<a name="ln6899">          }</a>
<a name="ln6900">        }</a>
<a name="ln6901">      } else if (strcmp(key, &quot;GUIFG&quot;) == 0)   {</a>
<a name="ln6902">        char **namep = &amp;HL_TABLE()[idx].sg_rgb_fg_name;</a>
<a name="ln6903"> </a>
<a name="ln6904">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6905">          if (!init) {</a>
<a name="ln6906">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6907">          }</a>
<a name="ln6908"> </a>
<a name="ln6909">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6910">            xfree(*namep);</a>
<a name="ln6911">            if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6912">              *namep = xstrdup(arg);</a>
<a name="ln6913">              HL_TABLE()[idx].sg_rgb_fg = name_to_color(arg);</a>
<a name="ln6914">            } else {</a>
<a name="ln6915">              *namep = NULL;</a>
<a name="ln6916">              HL_TABLE()[idx].sg_rgb_fg = -1;</a>
<a name="ln6917">            }</a>
<a name="ln6918">            did_change = true;</a>
<a name="ln6919">          }</a>
<a name="ln6920">        }</a>
<a name="ln6921"> </a>
<a name="ln6922">        if (is_normal_group) {</a>
<a name="ln6923">          normal_fg = HL_TABLE()[idx].sg_rgb_fg;</a>
<a name="ln6924">        }</a>
<a name="ln6925">      } else if (STRCMP(key, &quot;GUIBG&quot;) == 0)   {</a>
<a name="ln6926">        char **const namep = &amp;HL_TABLE()[idx].sg_rgb_bg_name;</a>
<a name="ln6927"> </a>
<a name="ln6928">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6929">          if (!init) {</a>
<a name="ln6930">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6931">          }</a>
<a name="ln6932"> </a>
<a name="ln6933">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6934">            xfree(*namep);</a>
<a name="ln6935">            if (STRCMP(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6936">              *namep = xstrdup(arg);</a>
<a name="ln6937">              HL_TABLE()[idx].sg_rgb_bg = name_to_color(arg);</a>
<a name="ln6938">            } else {</a>
<a name="ln6939">              *namep = NULL;</a>
<a name="ln6940">              HL_TABLE()[idx].sg_rgb_bg = -1;</a>
<a name="ln6941">            }</a>
<a name="ln6942">            did_change = true;</a>
<a name="ln6943">          }</a>
<a name="ln6944">        }</a>
<a name="ln6945"> </a>
<a name="ln6946">        if (is_normal_group) {</a>
<a name="ln6947">          normal_bg = HL_TABLE()[idx].sg_rgb_bg;</a>
<a name="ln6948">        }</a>
<a name="ln6949">      } else if (strcmp(key, &quot;GUISP&quot;) == 0)   {</a>
<a name="ln6950">        char **const namep = &amp;HL_TABLE()[idx].sg_rgb_sp_name;</a>
<a name="ln6951"> </a>
<a name="ln6952">        if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_GUI)) {</a>
<a name="ln6953">          if (!init) {</a>
<a name="ln6954">            HL_TABLE()[idx].sg_set |= SG_GUI;</a>
<a name="ln6955">          }</a>
<a name="ln6956"> </a>
<a name="ln6957">          if (*namep == NULL || STRCMP(*namep, arg) != 0) {</a>
<a name="ln6958">            xfree(*namep);</a>
<a name="ln6959">            if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6960">              *namep = xstrdup(arg);</a>
<a name="ln6961">              HL_TABLE()[idx].sg_rgb_sp = name_to_color(arg);</a>
<a name="ln6962">            } else {</a>
<a name="ln6963">              *namep = NULL;</a>
<a name="ln6964">              HL_TABLE()[idx].sg_rgb_sp = -1;</a>
<a name="ln6965">            }</a>
<a name="ln6966">            did_change = true;</a>
<a name="ln6967">          }</a>
<a name="ln6968">        }</a>
<a name="ln6969"> </a>
<a name="ln6970">        if (is_normal_group) {</a>
<a name="ln6971">          normal_sp = HL_TABLE()[idx].sg_rgb_sp;</a>
<a name="ln6972">        }</a>
<a name="ln6973">      } else if (strcmp(key, &quot;START&quot;) == 0 || strcmp(key, &quot;STOP&quot;) == 0)   {</a>
<a name="ln6974">        // Ignored for now</a>
<a name="ln6975">      } else if (strcmp(key, &quot;BLEND&quot;) == 0)   {</a>
<a name="ln6976">        if (strcmp(arg, &quot;NONE&quot;) != 0) {</a>
<a name="ln6977">          HL_TABLE()[idx].sg_blend = strtol(arg, NULL, 10);</a>
<a name="ln6978">        } else {</a>
<a name="ln6979">          HL_TABLE()[idx].sg_blend = -1;</a>
<a name="ln6980">        }</a>
<a name="ln6981">      } else {</a>
<a name="ln6982">        emsgf(_(&quot;E423: Illegal argument: %s&quot;), key_start);</a>
<a name="ln6983">        error = true;</a>
<a name="ln6984">        break;</a>
<a name="ln6985">      }</a>
<a name="ln6986">      HL_TABLE()[idx].sg_cleared = false;</a>
<a name="ln6987"> </a>
<a name="ln6988">      // When highlighting has been given for a group, don't link it.</a>
<a name="ln6989">      if (!init || !(HL_TABLE()[idx].sg_set &amp; SG_LINK)) {</a>
<a name="ln6990">        HL_TABLE()[idx].sg_link = 0;</a>
<a name="ln6991">      }</a>
<a name="ln6992"> </a>
<a name="ln6993">      // Continue with next argument.</a>
<a name="ln6994">      linep = (const char *)skipwhite((const char_u *)linep);</a>
<a name="ln6995">    }</a>
<a name="ln6996">  }</a>
<a name="ln6997"> </a>
<a name="ln6998">  // If there is an error, and it's a new entry, remove it from the table.</a>
<a name="ln6999">  if (error &amp;&amp; idx == highlight_ga.ga_len) {</a>
<a name="ln7000">    syn_unadd_group();</a>
<a name="ln7001">  } else {</a>
<a name="ln7002">    if (!error &amp;&amp; is_normal_group) {</a>
<a name="ln7003">      // Need to update all groups, because they might be using &quot;bg&quot; and/or</a>
<a name="ln7004">      // &quot;fg&quot;, which have been changed now.</a>
<a name="ln7005">      highlight_attr_set_all();</a>
<a name="ln7006"> </a>
<a name="ln7007">      if (!ui_has(kUILinegrid) &amp;&amp; starting == 0) {</a>
<a name="ln7008">        // Older UIs assume that we clear the screen after normal group is</a>
<a name="ln7009">        // changed</a>
<a name="ln7010">        ui_refresh();</a>
<a name="ln7011">      } else {</a>
<a name="ln7012">        // TUI and newer UIs will repaint the screen themselves. NOT_VALID</a>
<a name="ln7013">        // redraw below will still handle usages of guibg=fg etc.</a>
<a name="ln7014">        ui_default_colors_set();</a>
<a name="ln7015">      }</a>
<a name="ln7016">      did_highlight_changed = true;</a>
<a name="ln7017">      redraw_all_later(NOT_VALID);</a>
<a name="ln7018">    } else {</a>
<a name="ln7019">      set_hl_attr(idx);</a>
<a name="ln7020">    }</a>
<a name="ln7021">    HL_TABLE()[idx].sg_script_ctx = current_sctx;</a>
<a name="ln7022">    HL_TABLE()[idx].sg_script_ctx.sc_lnum += sourcing_lnum;</a>
<a name="ln7023">  }</a>
<a name="ln7024">  xfree(key);</a>
<a name="ln7025">  xfree(arg);</a>
<a name="ln7026"> </a>
<a name="ln7027">  // Only call highlight_changed() once, after a sequence of highlight</a>
<a name="ln7028">  // commands, and only if an attribute actually changed</a>
<a name="ln7029">  if ((did_change</a>
<a name="ln7030">       || memcmp(&amp;HL_TABLE()[idx], &amp;item_before, sizeof(item_before)) != 0)</a>
<a name="ln7031">      &amp;&amp; !did_highlight_changed) {</a>
<a name="ln7032">    // Do not trigger a redraw when highlighting is changed while</a>
<a name="ln7033">    // redrawing.  This may happen when evaluating 'statusline' changes the</a>
<a name="ln7034">    // StatusLine group.</a>
<a name="ln7035">    if (!updating_screen) {</a>
<a name="ln7036">      redraw_all_later(NOT_VALID);</a>
<a name="ln7037">    }</a>
<a name="ln7038">    need_highlight_changed = true;</a>
<a name="ln7039">  }</a>
<a name="ln7040">}</a>
<a name="ln7041"> </a>
<a name="ln7042">#if defined(EXITFREE)</a>
<a name="ln7043">void free_highlight(void)</a>
<a name="ln7044">{</a>
<a name="ln7045">  for (int i = 0; i &lt; highlight_ga.ga_len; ++i) {</a>
<a name="ln7046">    highlight_clear(i);</a>
<a name="ln7047">    xfree(HL_TABLE()[i].sg_name);</a>
<a name="ln7048">    xfree(HL_TABLE()[i].sg_name_u);</a>
<a name="ln7049">  }</a>
<a name="ln7050">  ga_clear(&amp;highlight_ga);</a>
<a name="ln7051">}</a>
<a name="ln7052"> </a>
<a name="ln7053">#endif</a>
<a name="ln7054"> </a>
<a name="ln7055">/*</a>
<a name="ln7056"> * Reset the cterm colors to what they were before Vim was started, if</a>
<a name="ln7057"> * possible.  Otherwise reset them to zero.</a>
<a name="ln7058"> */</a>
<a name="ln7059">void restore_cterm_colors(void)</a>
<a name="ln7060">{</a>
<a name="ln7061">  normal_fg = -1;</a>
<a name="ln7062">  normal_bg = -1;</a>
<a name="ln7063">  normal_sp = -1;</a>
<a name="ln7064">  cterm_normal_fg_color = 0;</a>
<a name="ln7065">  cterm_normal_bg_color = 0;</a>
<a name="ln7066">}</a>
<a name="ln7067"> </a>
<a name="ln7068">/*</a>
<a name="ln7069"> * Return TRUE if highlight group &quot;idx&quot; has any settings.</a>
<a name="ln7070"> * When &quot;check_link&quot; is TRUE also check for an existing link.</a>
<a name="ln7071"> */</a>
<a name="ln7072">static int hl_has_settings(int idx, int check_link)</a>
<a name="ln7073">{</a>
<a name="ln7074">  return HL_TABLE()[idx].sg_attr != 0</a>
<a name="ln7075">         || HL_TABLE()[idx].sg_cterm_fg != 0</a>
<a name="ln7076">         || HL_TABLE()[idx].sg_cterm_bg != 0</a>
<a name="ln7077">         || HL_TABLE()[idx].sg_rgb_fg_name != NULL</a>
<a name="ln7078">         || HL_TABLE()[idx].sg_rgb_bg_name != NULL</a>
<a name="ln7079">         || HL_TABLE()[idx].sg_rgb_sp_name != NULL</a>
<a name="ln7080">         || (check_link &amp;&amp; (HL_TABLE()[idx].sg_set &amp; SG_LINK));</a>
<a name="ln7081">}</a>
<a name="ln7082"> </a>
<a name="ln7083">/*</a>
<a name="ln7084"> * Clear highlighting for one group.</a>
<a name="ln7085"> */</a>
<a name="ln7086">static void highlight_clear(int idx)</a>
<a name="ln7087">{</a>
<a name="ln7088">  HL_TABLE()[idx].sg_cleared = true;</a>
<a name="ln7089"> </a>
<a name="ln7090">  HL_TABLE()[idx].sg_attr = 0;</a>
<a name="ln7091">  HL_TABLE()[idx].sg_cterm = 0;</a>
<a name="ln7092">  HL_TABLE()[idx].sg_cterm_bold = false;</a>
<a name="ln7093">  HL_TABLE()[idx].sg_cterm_fg = 0;</a>
<a name="ln7094">  HL_TABLE()[idx].sg_cterm_bg = 0;</a>
<a name="ln7095">  HL_TABLE()[idx].sg_gui = 0;</a>
<a name="ln7096">  HL_TABLE()[idx].sg_rgb_fg = -1;</a>
<a name="ln7097">  HL_TABLE()[idx].sg_rgb_bg = -1;</a>
<a name="ln7098">  HL_TABLE()[idx].sg_rgb_sp = -1;</a>
<a name="ln7099">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_fg_name);</a>
<a name="ln7100">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_bg_name);</a>
<a name="ln7101">  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_sp_name);</a>
<a name="ln7102">  HL_TABLE()[idx].sg_blend = -1;</a>
<a name="ln7103">  // Clear the script ID only when there is no link, since that is not</a>
<a name="ln7104">  // cleared.</a>
<a name="ln7105">  if (HL_TABLE()[idx].sg_link == 0) {</a>
<a name="ln7106">    HL_TABLE()[idx].sg_script_ctx.sc_sid = 0;</a>
<a name="ln7107">    HL_TABLE()[idx].sg_script_ctx.sc_lnum = 0;</a>
<a name="ln7108">  }</a>
<a name="ln7109">}</a>
<a name="ln7110"> </a>
<a name="ln7111"> </a>
<a name="ln7112">/// \addtogroup LIST_XXX</a>
<a name="ln7113">/// @{</a>
<a name="ln7114">#define LIST_ATTR   1</a>
<a name="ln7115">#define LIST_STRING 2</a>
<a name="ln7116">#define LIST_INT    3</a>
<a name="ln7117">/// @}</a>
<a name="ln7118"> </a>
<a name="ln7119">static void highlight_list_one(const int id)</a>
<a name="ln7120">{</a>
<a name="ln7121">  struct hl_group *const sgp = &amp;HL_TABLE()[id - 1];  // index is ID minus one</a>
<a name="ln7122">  bool didh = false;</a>
<a name="ln7123"> </a>
<a name="ln7124">  if (message_filtered(sgp-&gt;sg_name)) {</a>
<a name="ln7125">    return;</a>
<a name="ln7126">  }</a>
<a name="ln7127"> </a>
<a name="ln7128">  didh = highlight_list_arg(id, didh, LIST_ATTR,</a>
<a name="ln7129">      sgp-&gt;sg_cterm, NULL, &quot;cterm&quot;);</a>
<a name="ln7130">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7131">      sgp-&gt;sg_cterm_fg, NULL, &quot;ctermfg&quot;);</a>
<a name="ln7132">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7133">      sgp-&gt;sg_cterm_bg, NULL, &quot;ctermbg&quot;);</a>
<a name="ln7134"> </a>
<a name="ln7135">  didh = highlight_list_arg(id, didh, LIST_ATTR,</a>
<a name="ln7136">      sgp-&gt;sg_gui, NULL, &quot;gui&quot;);</a>
<a name="ln7137">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7138">      0, sgp-&gt;sg_rgb_fg_name, &quot;guifg&quot;);</a>
<a name="ln7139">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7140">      0, sgp-&gt;sg_rgb_bg_name, &quot;guibg&quot;);</a>
<a name="ln7141">  didh = highlight_list_arg(id, didh, LIST_STRING,</a>
<a name="ln7142">                            0, sgp-&gt;sg_rgb_sp_name, &quot;guisp&quot;);</a>
<a name="ln7143"> </a>
<a name="ln7144">  didh = highlight_list_arg(id, didh, LIST_INT,</a>
<a name="ln7145">                            sgp-&gt;sg_blend+1, NULL, &quot;blend&quot;);</a>
<a name="ln7146"> </a>
<a name="ln7147">  if (sgp-&gt;sg_link &amp;&amp; !got_int) {</a>
<a name="ln7148">    (void)syn_list_header(didh, 0, id, true);</a>
<a name="ln7149">    didh = true;</a>
<a name="ln7150">    msg_puts_attr(&quot;links to&quot;, HL_ATTR(HLF_D));</a>
<a name="ln7151">    msg_putchar(' ');</a>
<a name="ln7152">    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);</a>
<a name="ln7153">  }</a>
<a name="ln7154"> </a>
<a name="ln7155">  if (!didh) {</a>
<a name="ln7156">    highlight_list_arg(id, didh, LIST_STRING, 0, &quot;cleared&quot;, &quot;&quot;);</a>
<a name="ln7157">  }</a>
<a name="ln7158">  if (p_verbose &gt; 0) {</a>
<a name="ln7159">    last_set_msg(sgp-&gt;sg_script_ctx);</a>
<a name="ln7160">  }</a>
<a name="ln7161">}</a>
<a name="ln7162"> </a>
<a name="ln7163">Dictionary get_global_hl_defs(void)</a>
<a name="ln7164">{</a>
<a name="ln7165">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln7166">  for (int i = 1; i &lt;= highlight_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln7167">    Dictionary attrs = ARRAY_DICT_INIT;</a>
<a name="ln7168">    struct hl_group *h = &amp;HL_TABLE()[i - 1];</a>
<a name="ln7169">    if (h-&gt;sg_attr &gt; 0) {</a>
<a name="ln7170">      attrs = hlattrs2dict(syn_attr2entry(h-&gt;sg_attr), true);</a>
<a name="ln7171">    } else if (h-&gt;sg_link &gt; 0) {</a>
<a name="ln7172">      const char *link = (const char *)HL_TABLE()[h-&gt;sg_link - 1].sg_name;</a>
<a name="ln7173">      PUT(attrs, &quot;link&quot;, STRING_OBJ(cstr_to_string(link)));</a>
<a name="ln7174">    }</a>
<a name="ln7175">    PUT(rv, (const char *)h-&gt;sg_name, DICTIONARY_OBJ(attrs));</a>
<a name="ln7176">  }</a>
<a name="ln7177"> </a>
<a name="ln7178">  return rv;</a>
<a name="ln7179">}</a>
<a name="ln7180"> </a>
<a name="ln7181">/// Outputs a highlight when doing &quot;:hi MyHighlight&quot;</a>
<a name="ln7182">///</a>
<a name="ln7183">/// @param type one of \ref LIST_XXX</a>
<a name="ln7184">/// @param iarg integer argument used if \p type == LIST_INT</a>
<a name="ln7185">/// @param sarg string used if \p type == LIST_STRING</a>
<a name="ln7186">static bool highlight_list_arg(</a>
<a name="ln7187">    const int id, bool didh, const int type, int iarg,</a>
<a name="ln7188">    char *const sarg, const char *const name)</a>
<a name="ln7189">{</a>
<a name="ln7190">  char buf[100];</a>
<a name="ln7191"> </a>
<a name="ln7192">  if (got_int) {</a>
<a name="ln7193">    return false;</a>
<a name="ln7194">  }</a>
<a name="ln7195">  if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0)) {</a>
<a name="ln7196">    char *ts = buf;</a>
<a name="ln7197">    if (type == LIST_INT) {</a>
<a name="ln7198">      snprintf((char *)buf, sizeof(buf), &quot;%d&quot;, iarg - 1);</a>
<a name="ln7199">    } else if (type == LIST_STRING) {</a>
<a name="ln7200">      ts = sarg;</a>
<a name="ln7201">    } else {    // type == LIST_ATTR</a>
<a name="ln7202">      buf[0] = NUL;</a>
<a name="ln7203">      for (int i = 0; hl_attr_table[i] != 0; i++) {</a>
<a name="ln7204">        if (iarg &amp; hl_attr_table[i]) {</a>
<a name="ln7205">          if (buf[0] != NUL)</a>
<a name="ln7206">            xstrlcat((char *)buf, &quot;,&quot;, 100);</a>
<a name="ln7207">          xstrlcat((char *)buf, hl_name_table[i], 100);</a>
<a name="ln7208">          iarg &amp;= ~hl_attr_table[i];                /* don't want &quot;inverse&quot; */</a>
<a name="ln7209">        }</a>
<a name="ln7210">      }</a>
<a name="ln7211">    }</a>
<a name="ln7212"> </a>
<a name="ln7213">    (void)syn_list_header(didh, (int)(vim_strsize((char_u *)ts) + STRLEN(name)</a>
<a name="ln7214">                                      + 1), id, false);</a>
<a name="ln7215">    didh = true;</a>
<a name="ln7216">    if (!got_int) {</a>
<a name="ln7217">      if (*name != NUL) {</a>
<a name="ln7218">        MSG_PUTS_ATTR(name, HL_ATTR(HLF_D));</a>
<a name="ln7219">        MSG_PUTS_ATTR(&quot;=&quot;, HL_ATTR(HLF_D));</a>
<a name="ln7220">      }</a>
<a name="ln7221">      msg_outtrans((char_u *)ts);</a>
<a name="ln7222">    }</a>
<a name="ln7223">  }</a>
<a name="ln7224">  return didh;</a>
<a name="ln7225">}</a>
<a name="ln7226"> </a>
<a name="ln7227">/// Check whether highlight group has attribute</a>
<a name="ln7228">///</a>
<a name="ln7229">/// @param[in]  id  Highlight group to check.</a>
<a name="ln7230">/// @param[in]  flag  Attribute to check.</a>
<a name="ln7231">/// @param[in]  modec  'g' for GUI, 'c' for term.</a>
<a name="ln7232">///</a>
<a name="ln7233">/// @return &quot;1&quot; if highlight group has attribute, NULL otherwise.</a>
<a name="ln7234">const char *highlight_has_attr(const int id, const int flag, const int modec)</a>
<a name="ln7235">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln7236">{</a>
<a name="ln7237">  int attr;</a>
<a name="ln7238"> </a>
<a name="ln7239">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len) {</a>
<a name="ln7240">    return NULL;</a>
<a name="ln7241">  }</a>
<a name="ln7242"> </a>
<a name="ln7243">  if (modec == 'g') {</a>
<a name="ln7244">    attr = HL_TABLE()[id - 1].sg_gui;</a>
<a name="ln7245">  } else {</a>
<a name="ln7246">    attr = HL_TABLE()[id - 1].sg_cterm;</a>
<a name="ln7247">  }</a>
<a name="ln7248"> </a>
<a name="ln7249">  return (attr &amp; flag) ? &quot;1&quot; : NULL;</a>
<a name="ln7250">}</a>
<a name="ln7251"> </a>
<a name="ln7252">/// Return color name of the given highlight group</a>
<a name="ln7253">///</a>
<a name="ln7254">/// @param[in]  id  Highlight group to work with.</a>
<a name="ln7255">/// @param[in]  what  What to return: one of &quot;font&quot;, &quot;fg&quot;, &quot;bg&quot;, &quot;sp&quot;, &quot;fg#&quot;,</a>
<a name="ln7256">///                   &quot;bg#&quot; or &quot;sp#&quot;.</a>
<a name="ln7257">/// @param[in]  modec  'g' for GUI, 'c' for cterm and 't' for term.</a>
<a name="ln7258">///</a>
<a name="ln7259">/// @return color name, possibly in a static buffer. Buffer will be overwritten</a>
<a name="ln7260">///         on next highlight_color() call. May return NULL.</a>
<a name="ln7261">const char *highlight_color(const int id, const char *const what,</a>
<a name="ln7262">                            const int modec)</a>
<a name="ln7263">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7264">{</a>
<a name="ln7265">  static char name[20];</a>
<a name="ln7266">  int n;</a>
<a name="ln7267">  bool fg = false;</a>
<a name="ln7268">  bool sp = false;</a>
<a name="ln7269">  bool font = false;</a>
<a name="ln7270"> </a>
<a name="ln7271">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len) {</a>
<a name="ln7272">    return NULL;</a>
<a name="ln7273">  }</a>
<a name="ln7274"> </a>
<a name="ln7275">  if (TOLOWER_ASC(what[0]) == 'f' &amp;&amp; TOLOWER_ASC(what[1]) == 'g') {</a>
<a name="ln7276">    fg = true;</a>
<a name="ln7277">  } else if (TOLOWER_ASC(what[0]) == 'f' &amp;&amp; TOLOWER_ASC(what[1]) == 'o'</a>
<a name="ln7278">             &amp;&amp; TOLOWER_ASC(what[2]) == 'n' &amp;&amp; TOLOWER_ASC(what[3]) == 't') {</a>
<a name="ln7279">    font = true;</a>
<a name="ln7280">  } else if (TOLOWER_ASC(what[0]) == 's' &amp;&amp; TOLOWER_ASC(what[1]) == 'p') {</a>
<a name="ln7281">    sp = true;</a>
<a name="ln7282">  } else if (!(TOLOWER_ASC(what[0]) == 'b' &amp;&amp; TOLOWER_ASC(what[1]) == 'g')) {</a>
<a name="ln7283">    return NULL;</a>
<a name="ln7284">  }</a>
<a name="ln7285">  if (modec == 'g') {</a>
<a name="ln7286">    if (what[2] == '#' &amp;&amp; ui_rgb_attached()) {</a>
<a name="ln7287">      if (fg) {</a>
<a name="ln7288">          n = HL_TABLE()[id - 1].sg_rgb_fg;</a>
<a name="ln7289">      } else if (sp) {</a>
<a name="ln7290">          n = HL_TABLE()[id - 1].sg_rgb_sp;</a>
<a name="ln7291">      } else {</a>
<a name="ln7292">          n = HL_TABLE()[id - 1].sg_rgb_bg;</a>
<a name="ln7293">      }</a>
<a name="ln7294">      if (n &lt; 0 || n &gt; 0xffffff) {</a>
<a name="ln7295">        return NULL;</a>
<a name="ln7296">      }</a>
<a name="ln7297">      snprintf(name, sizeof(name), &quot;#%06x&quot;, n);</a>
<a name="ln7298">      return name;</a>
<a name="ln7299">    }</a>
<a name="ln7300">    if (fg) {</a>
<a name="ln7301">      return (const char *)HL_TABLE()[id - 1].sg_rgb_fg_name;</a>
<a name="ln7302">    }</a>
<a name="ln7303">    if (sp) {</a>
<a name="ln7304">      return (const char *)HL_TABLE()[id - 1].sg_rgb_sp_name;</a>
<a name="ln7305">    }</a>
<a name="ln7306">    return (const char *)HL_TABLE()[id - 1].sg_rgb_bg_name;</a>
<a name="ln7307">  }</a>
<a name="ln7308">  if (font || sp) {</a>
<a name="ln7309">    return NULL;</a>
<a name="ln7310">  }</a>
<a name="ln7311">  if (modec == 'c') {</a>
<a name="ln7312">    if (fg) {</a>
<a name="ln7313">      n = HL_TABLE()[id - 1].sg_cterm_fg - 1;</a>
<a name="ln7314">    } else {</a>
<a name="ln7315">      n = HL_TABLE()[id - 1].sg_cterm_bg - 1;</a>
<a name="ln7316">    }</a>
<a name="ln7317">    if (n &lt; 0) {</a>
<a name="ln7318">      return NULL;</a>
<a name="ln7319">    }</a>
<a name="ln7320">    snprintf(name, sizeof(name), &quot;%d&quot;, n);</a>
<a name="ln7321">    return name;</a>
<a name="ln7322">  }</a>
<a name="ln7323">  // term doesn't have color.</a>
<a name="ln7324">  return NULL;</a>
<a name="ln7325">}</a>
<a name="ln7326"> </a>
<a name="ln7327">/// Output the syntax list header.</a>
<a name="ln7328">///</a>
<a name="ln7329">/// @param did_header did header already</a>
<a name="ln7330">/// @param outlen length of string that comes</a>
<a name="ln7331">/// @param id highlight group id</a>
<a name="ln7332">/// @param force_newline always start a new line</a>
<a name="ln7333">/// @return true when started a new line.</a>
<a name="ln7334">static bool syn_list_header(const bool did_header, const int outlen,</a>
<a name="ln7335">                            const int id, bool force_newline)</a>
<a name="ln7336">{</a>
<a name="ln7337">  int endcol = 19;</a>
<a name="ln7338">  bool newline = true;</a>
<a name="ln7339">  bool adjust = true;</a>
<a name="ln7340"> </a>
<a name="ln7341">  if (!did_header) {</a>
<a name="ln7342">    msg_putchar('\n');</a>
<a name="ln7343">    if (got_int) {</a>
<a name="ln7344">      return true;</a>
<a name="ln7345">    }</a>
<a name="ln7346">    msg_outtrans(HL_TABLE()[id - 1].sg_name);</a>
<a name="ln7347">    endcol = 15;</a>
<a name="ln7348">  } else if ((ui_has(kUIMessages) || msg_silent) &amp;&amp; !force_newline) {</a>
<a name="ln7349">    msg_putchar(' ');</a>
<a name="ln7350">    adjust = false;</a>
<a name="ln7351">  } else if (msg_col + outlen + 1 &gt;= Columns || force_newline)   {</a>
<a name="ln7352">    msg_putchar('\n');</a>
<a name="ln7353">    if (got_int) {</a>
<a name="ln7354">      return true;</a>
<a name="ln7355">    }</a>
<a name="ln7356">  } else {</a>
<a name="ln7357">    if (msg_col &gt;= endcol) {    // wrap around is like starting a new line</a>
<a name="ln7358">      newline = false;</a>
<a name="ln7359">    }</a>
<a name="ln7360">  }</a>
<a name="ln7361"> </a>
<a name="ln7362">  if (adjust) {</a>
<a name="ln7363">    if (msg_col &gt;= endcol) {</a>
<a name="ln7364">      // output at least one space</a>
<a name="ln7365">      endcol = msg_col + 1;</a>
<a name="ln7366">    }</a>
<a name="ln7367"> </a>
<a name="ln7368">    msg_advance(endcol);</a>
<a name="ln7369">  }</a>
<a name="ln7370"> </a>
<a name="ln7371">  /* Show &quot;xxx&quot; with the attributes. */</a>
<a name="ln7372">  if (!did_header) {</a>
<a name="ln7373">    msg_puts_attr(&quot;xxx&quot;, syn_id2attr(id));</a>
<a name="ln7374">    msg_putchar(' ');</a>
<a name="ln7375">  }</a>
<a name="ln7376"> </a>
<a name="ln7377">  return newline;</a>
<a name="ln7378">}</a>
<a name="ln7379"> </a>
<a name="ln7380">/// Set the attribute numbers for a highlight group.</a>
<a name="ln7381">/// Called after one of the attributes has changed.</a>
<a name="ln7382">/// @param idx corrected highlight index</a>
<a name="ln7383">static void set_hl_attr(int idx)</a>
<a name="ln7384">{</a>
<a name="ln7385">  HlAttrs at_en = HLATTRS_INIT;</a>
<a name="ln7386">  struct hl_group     *sgp = HL_TABLE() + idx;</a>
<a name="ln7387"> </a>
<a name="ln7388">  at_en.cterm_ae_attr = sgp-&gt;sg_cterm;</a>
<a name="ln7389">  at_en.cterm_fg_color = sgp-&gt;sg_cterm_fg;</a>
<a name="ln7390">  at_en.cterm_bg_color = sgp-&gt;sg_cterm_bg;</a>
<a name="ln7391">  at_en.rgb_ae_attr = sgp-&gt;sg_gui;</a>
<a name="ln7392">  // FIXME(tarruda): The &quot;unset value&quot; for rgb is -1, but since hlgroup is</a>
<a name="ln7393">  // initialized with 0(by garray functions), check for sg_rgb_{f,b}g_name</a>
<a name="ln7394">  // before setting attr_entry-&gt;{f,g}g_color to a other than -1</a>
<a name="ln7395">  at_en.rgb_fg_color = sgp-&gt;sg_rgb_fg_name ? sgp-&gt;sg_rgb_fg : -1;</a>
<a name="ln7396">  at_en.rgb_bg_color = sgp-&gt;sg_rgb_bg_name ? sgp-&gt;sg_rgb_bg : -1;</a>
<a name="ln7397">  at_en.rgb_sp_color = sgp-&gt;sg_rgb_sp_name ? sgp-&gt;sg_rgb_sp : -1;</a>
<a name="ln7398">  at_en.hl_blend = sgp-&gt;sg_blend;</a>
<a name="ln7399"> </a>
<a name="ln7400">  sgp-&gt;sg_attr = hl_get_syn_attr(0, idx+1, at_en);</a>
<a name="ln7401"> </a>
<a name="ln7402">  // a cursor style uses this syn_id, make sure its attribute is updated.</a>
<a name="ln7403">  if (cursor_mode_uses_syn_id(idx+1)) {</a>
<a name="ln7404">    ui_mode_info_set();</a>
<a name="ln7405">  }</a>
<a name="ln7406">}</a>
<a name="ln7407"> </a>
<a name="ln7408">/// Lookup a highlight group name and return its ID.</a>
<a name="ln7409">///</a>
<a name="ln7410">/// @param highlight name e.g. 'Cursor', 'Normal'</a>
<a name="ln7411">/// @return the highlight id, else 0 if \p name does not exist</a>
<a name="ln7412">int syn_name2id(const char_u *name)</a>
<a name="ln7413">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7414">{</a>
<a name="ln7415">  int i;</a>
<a name="ln7416">  char_u name_u[200];</a>
<a name="ln7417"> </a>
<a name="ln7418">  /* Avoid using stricmp() too much, it's slow on some systems */</a>
<a name="ln7419">  /* Avoid alloc()/free(), these are slow too.  ID names over 200 chars</a>
<a name="ln7420">   * don't deserve to be found! */</a>
<a name="ln7421">  STRLCPY(name_u, name, 200);</a>
<a name="ln7422">  vim_strup(name_u);</a>
<a name="ln7423">  for (i = highlight_ga.ga_len; --i &gt;= 0; )</a>
<a name="ln7424">    if (HL_TABLE()[i].sg_name_u != NULL</a>
<a name="ln7425">        &amp;&amp; STRCMP(name_u, HL_TABLE()[i].sg_name_u) == 0)</a>
<a name="ln7426">      break;</a>
<a name="ln7427">  return i + 1;</a>
<a name="ln7428">}</a>
<a name="ln7429"> </a>
<a name="ln7430">/// Lookup a highlight group name and return its attributes.</a>
<a name="ln7431">/// Return zero if not found.</a>
<a name="ln7432">int syn_name2attr(const char_u *name)</a>
<a name="ln7433">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7434">{</a>
<a name="ln7435">  int id = syn_name2id(name);</a>
<a name="ln7436"> </a>
<a name="ln7437">  if (id != 0) {</a>
<a name="ln7438">    return syn_id2attr(id);</a>
<a name="ln7439">  }</a>
<a name="ln7440">  return 0;</a>
<a name="ln7441">}</a>
<a name="ln7442"> </a>
<a name="ln7443">/*</a>
<a name="ln7444"> * Return TRUE if highlight group &quot;name&quot; exists.</a>
<a name="ln7445"> */</a>
<a name="ln7446">int highlight_exists(const char_u *name)</a>
<a name="ln7447">{</a>
<a name="ln7448">  return syn_name2id(name) &gt; 0;</a>
<a name="ln7449">}</a>
<a name="ln7450"> </a>
<a name="ln7451">/*</a>
<a name="ln7452"> * Return the name of highlight group &quot;id&quot;.</a>
<a name="ln7453"> * When not a valid ID return an empty string.</a>
<a name="ln7454"> */</a>
<a name="ln7455">char_u *syn_id2name(int id)</a>
<a name="ln7456">{</a>
<a name="ln7457">  if (id &lt;= 0 || id &gt; highlight_ga.ga_len)</a>
<a name="ln7458">    return (char_u *)&quot;&quot;;</a>
<a name="ln7459">  return HL_TABLE()[id - 1].sg_name;</a>
<a name="ln7460">}</a>
<a name="ln7461"> </a>
<a name="ln7462">/*</a>
<a name="ln7463"> * Like syn_name2id(), but take a pointer + length argument.</a>
<a name="ln7464"> */</a>
<a name="ln7465">int syn_namen2id(const char_u *linep, int len)</a>
<a name="ln7466">{</a>
<a name="ln7467">  char_u *name = vim_strnsave(linep, len);</a>
<a name="ln7468">  int id = syn_name2id(name);</a>
<a name="ln7469">  xfree(name);</a>
<a name="ln7470"> </a>
<a name="ln7471">  return id;</a>
<a name="ln7472">}</a>
<a name="ln7473"> </a>
<a name="ln7474">/// Find highlight group name in the table and return its ID.</a>
<a name="ln7475">/// If it doesn't exist yet, a new entry is created.</a>
<a name="ln7476">///</a>
<a name="ln7477">/// @param pp Highlight group name</a>
<a name="ln7478">/// @param len length of \p pp</a>
<a name="ln7479">///</a>
<a name="ln7480">/// @return 0 for failure else the id of the group</a>
<a name="ln7481">int syn_check_group(const char_u *pp, int len)</a>
<a name="ln7482">{</a>
<a name="ln7483">  char_u  *name = vim_strnsave(pp, len);</a>
<a name="ln7484">  int id = syn_name2id(name);</a>
<a name="ln7485">  if (id == 0) {  // doesn't exist yet</a>
<a name="ln7486">    id = syn_add_group(name);</a>
<a name="ln7487">  } else {</a>
<a name="ln7488">    xfree(name);</a>
<a name="ln7489">  }</a>
<a name="ln7490">  return id;</a>
<a name="ln7491">}</a>
<a name="ln7492"> </a>
<a name="ln7493">/// Add new highlight group and return its ID.</a>
<a name="ln7494">///</a>
<a name="ln7495">/// @param name must be an allocated string, it will be consumed.</a>
<a name="ln7496">/// @return 0 for failure, else the allocated group id</a>
<a name="ln7497">/// @see syn_check_group syn_unadd_group</a>
<a name="ln7498">static int syn_add_group(char_u *name)</a>
<a name="ln7499">{</a>
<a name="ln7500">  char_u      *p;</a>
<a name="ln7501"> </a>
<a name="ln7502">  /* Check that the name is ASCII letters, digits and underscore. */</a>
<a name="ln7503">  for (p = name; *p != NUL; ++p) {</a>
<a name="ln7504">    if (!vim_isprintc(*p)) {</a>
<a name="ln7505">      EMSG(_(&quot;E669: Unprintable character in group name&quot;));</a>
<a name="ln7506">      xfree(name);</a>
<a name="ln7507">      return 0;</a>
<a name="ln7508">    } else if (!ASCII_ISALNUM(*p) &amp;&amp; *p != '_')   {</a>
<a name="ln7509">      /* This is an error, but since there previously was no check only</a>
<a name="ln7510">       * give a warning. */</a>
<a name="ln7511">      msg_source(HL_ATTR(HLF_W));</a>
<a name="ln7512">      MSG(_(&quot;W18: Invalid character in group name&quot;));</a>
<a name="ln7513">      break;</a>
<a name="ln7514">    }</a>
<a name="ln7515">  }</a>
<a name="ln7516"> </a>
<a name="ln7517">  /*</a>
<a name="ln7518">   * First call for this growarray: init growing array.</a>
<a name="ln7519">   */</a>
<a name="ln7520">  if (highlight_ga.ga_data == NULL) {</a>
<a name="ln7521">    highlight_ga.ga_itemsize = sizeof(struct hl_group);</a>
<a name="ln7522">    ga_set_growsize(&amp;highlight_ga, 10);</a>
<a name="ln7523">  }</a>
<a name="ln7524"> </a>
<a name="ln7525">  if (highlight_ga.ga_len &gt;= MAX_HL_ID) {</a>
<a name="ln7526">    EMSG(_(&quot;E849: Too many highlight and syntax groups&quot;));</a>
<a name="ln7527">    xfree(name);</a>
<a name="ln7528">    return 0;</a>
<a name="ln7529">  }</a>
<a name="ln7530"> </a>
<a name="ln7531">  char_u *const name_up = vim_strsave_up(name);</a>
<a name="ln7532"> </a>
<a name="ln7533">  // Append another syntax_highlight entry.</a>
<a name="ln7534">  struct hl_group* hlgp = GA_APPEND_VIA_PTR(struct hl_group, &amp;highlight_ga);</a>
<a name="ln7535">  memset(hlgp, 0, sizeof(*hlgp));</a>
<a name="ln7536">  hlgp-&gt;sg_name = name;</a>
<a name="ln7537">  hlgp-&gt;sg_rgb_bg = -1;</a>
<a name="ln7538">  hlgp-&gt;sg_rgb_fg = -1;</a>
<a name="ln7539">  hlgp-&gt;sg_rgb_sp = -1;</a>
<a name="ln7540">  hlgp-&gt;sg_blend = -1;</a>
<a name="ln7541">  hlgp-&gt;sg_name_u = name_up;</a>
<a name="ln7542"> </a>
<a name="ln7543">  return highlight_ga.ga_len;               /* ID is index plus one */</a>
<a name="ln7544">}</a>
<a name="ln7545"> </a>
<a name="ln7546">/// When, just after calling syn_add_group(), an error is discovered, this</a>
<a name="ln7547">/// function deletes the new name.</a>
<a name="ln7548">static void syn_unadd_group(void)</a>
<a name="ln7549">{</a>
<a name="ln7550">  highlight_ga.ga_len--;</a>
<a name="ln7551">  xfree(HL_TABLE()[highlight_ga.ga_len].sg_name);</a>
<a name="ln7552">  xfree(HL_TABLE()[highlight_ga.ga_len].sg_name_u);</a>
<a name="ln7553">}</a>
<a name="ln7554"> </a>
<a name="ln7555"> </a>
<a name="ln7556">/// Translate a group ID to highlight attributes.</a>
<a name="ln7557">/// @see syn_attr2entry</a>
<a name="ln7558">int syn_id2attr(int hl_id)</a>
<a name="ln7559">{</a>
<a name="ln7560">  struct hl_group     *sgp;</a>
<a name="ln7561"> </a>
<a name="ln7562">  hl_id = syn_get_final_id(hl_id);</a>
<a name="ln7563">  int attr = ns_get_hl(-1, hl_id, false);</a>
<a name="ln7564">  if (attr &gt;= 0) {</a>
<a name="ln7565">    return attr;</a>
<a name="ln7566">  }</a>
<a name="ln7567">  sgp = &amp;HL_TABLE()[hl_id - 1];  // index is ID minus one</a>
<a name="ln7568">  return sgp-&gt;sg_attr;</a>
<a name="ln7569">}</a>
<a name="ln7570"> </a>
<a name="ln7571"> </a>
<a name="ln7572"> </a>
<a name="ln7573"> </a>
<a name="ln7574">/*</a>
<a name="ln7575"> * Translate a group ID to the final group ID (following links).</a>
<a name="ln7576"> */</a>
<a name="ln7577">int syn_get_final_id(int hl_id)</a>
<a name="ln7578">{</a>
<a name="ln7579">  int count;</a>
<a name="ln7580">  struct hl_group     *sgp;</a>
<a name="ln7581"> </a>
<a name="ln7582">  if (hl_id &gt; highlight_ga.ga_len || hl_id &lt; 1)</a>
<a name="ln7583">    return 0;                           /* Can be called from eval!! */</a>
<a name="ln7584"> </a>
<a name="ln7585">  /*</a>
<a name="ln7586">   * Follow links until there is no more.</a>
<a name="ln7587">   * Look out for loops!  Break after 100 links.</a>
<a name="ln7588">   */</a>
<a name="ln7589">  for (count = 100; --count &gt;= 0; ) {</a>
<a name="ln7590">    // ACHTUNG: when using &quot;tmp&quot; attribute (no link) the function might be</a>
<a name="ln7591">    // called twice. it needs be smart enough to remember attr only to</a>
<a name="ln7592">    // syn_id2attr time</a>
<a name="ln7593">    int check = ns_get_hl(-1, hl_id, true);</a>
<a name="ln7594">    if (check == 0) {</a>
<a name="ln7595">      return 0;  // how dare! it broke the link!</a>
<a name="ln7596">    } else if (check &gt; 0) {</a>
<a name="ln7597">      hl_id = check;</a>
<a name="ln7598">      continue;</a>
<a name="ln7599">    }</a>
<a name="ln7600"> </a>
<a name="ln7601"> </a>
<a name="ln7602">    sgp = &amp;HL_TABLE()[hl_id - 1];  // index is ID minus one</a>
<a name="ln7603">    if (sgp-&gt;sg_link == 0 || sgp-&gt;sg_link &gt; highlight_ga.ga_len) {</a>
<a name="ln7604">      break;</a>
<a name="ln7605">    }</a>
<a name="ln7606">    hl_id = sgp-&gt;sg_link;</a>
<a name="ln7607">  }</a>
<a name="ln7608"> </a>
<a name="ln7609">  return hl_id;</a>
<a name="ln7610">}</a>
<a name="ln7611"> </a>
<a name="ln7612">/// Refresh the color attributes of all highlight groups.</a>
<a name="ln7613">void highlight_attr_set_all(void)</a>
<a name="ln7614">{</a>
<a name="ln7615">  for (int idx = 0; idx &lt; highlight_ga.ga_len; idx++) {</a>
<a name="ln7616">    struct hl_group *sgp = &amp;HL_TABLE()[idx];</a>
<a name="ln7617">    if (sgp-&gt;sg_rgb_bg_name != NULL) {</a>
<a name="ln7618">      sgp-&gt;sg_rgb_bg = name_to_color(sgp-&gt;sg_rgb_bg_name);</a>
<a name="ln7619">    }</a>
<a name="ln7620">    if (sgp-&gt;sg_rgb_fg_name != NULL) {</a>
<a name="ln7621">      sgp-&gt;sg_rgb_fg = name_to_color(sgp-&gt;sg_rgb_fg_name);</a>
<a name="ln7622">    }</a>
<a name="ln7623">    if (sgp-&gt;sg_rgb_sp_name != NULL) {</a>
<a name="ln7624">      sgp-&gt;sg_rgb_sp = name_to_color(sgp-&gt;sg_rgb_sp_name);</a>
<a name="ln7625">    }</a>
<a name="ln7626">    set_hl_attr(idx);</a>
<a name="ln7627">  }</a>
<a name="ln7628">}</a>
<a name="ln7629"> </a>
<a name="ln7630">// Apply difference between User[1-9] and HLF_S to HLF_SNC.</a>
<a name="ln7631">static void combine_stl_hlt(int id, int id_S, int id_alt, int hlcnt, int i,</a>
<a name="ln7632">                            int hlf, int *table)</a>
<a name="ln7633">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7634">{</a>
<a name="ln7635">  struct hl_group *const hlt = HL_TABLE();</a>
<a name="ln7636"> </a>
<a name="ln7637">  if (id_alt == 0) {</a>
<a name="ln7638">    memset(&amp;hlt[hlcnt + i], 0, sizeof(struct hl_group));</a>
<a name="ln7639">    hlt[hlcnt + i].sg_cterm = highlight_attr[hlf];</a>
<a name="ln7640">    hlt[hlcnt + i].sg_gui = highlight_attr[hlf];</a>
<a name="ln7641">  } else {</a>
<a name="ln7642">    memmove(&amp;hlt[hlcnt + i], &amp;hlt[id_alt - 1], sizeof(struct hl_group));</a>
<a name="ln7643">  }</a>
<a name="ln7644">  hlt[hlcnt + i].sg_link = 0;</a>
<a name="ln7645"> </a>
<a name="ln7646">  hlt[hlcnt + i].sg_cterm ^= hlt[id - 1].sg_cterm ^ hlt[id_S - 1].sg_cterm;</a>
<a name="ln7647">  if (hlt[id - 1].sg_cterm_fg != hlt[id_S - 1].sg_cterm_fg) {</a>
<a name="ln7648">    hlt[hlcnt + i].sg_cterm_fg = hlt[id - 1].sg_cterm_fg;</a>
<a name="ln7649">  }</a>
<a name="ln7650">  if (hlt[id - 1].sg_cterm_bg != hlt[id_S - 1].sg_cterm_bg) {</a>
<a name="ln7651">    hlt[hlcnt + i].sg_cterm_bg = hlt[id - 1].sg_cterm_bg;</a>
<a name="ln7652">  }</a>
<a name="ln7653">  hlt[hlcnt + i].sg_gui ^= hlt[id - 1].sg_gui ^ hlt[id_S - 1].sg_gui;</a>
<a name="ln7654">  if (hlt[id - 1].sg_rgb_fg != hlt[id_S - 1].sg_rgb_fg) {</a>
<a name="ln7655">    hlt[hlcnt + i].sg_rgb_fg = hlt[id - 1].sg_rgb_fg;</a>
<a name="ln7656">  }</a>
<a name="ln7657">  if (hlt[id - 1].sg_rgb_bg != hlt[id_S - 1].sg_rgb_bg) {</a>
<a name="ln7658">    hlt[hlcnt + i].sg_rgb_bg = hlt[id - 1].sg_rgb_bg;</a>
<a name="ln7659">  }</a>
<a name="ln7660">  if (hlt[id - 1].sg_rgb_sp != hlt[id_S - 1].sg_rgb_sp) {</a>
<a name="ln7661">    hlt[hlcnt + i].sg_rgb_sp = hlt[id - 1].sg_rgb_sp;</a>
<a name="ln7662">  }</a>
<a name="ln7663">  highlight_ga.ga_len = hlcnt + i + 1;</a>
<a name="ln7664">  set_hl_attr(hlcnt + i);  // At long last we can apply</a>
<a name="ln7665">  table[i] = syn_id2attr(hlcnt + i + 1);</a>
<a name="ln7666">}</a>
<a name="ln7667"> </a>
<a name="ln7668">/// Translate highlight groups into attributes in highlight_attr[] and set up</a>
<a name="ln7669">/// the user highlights User1..9. A set of corresponding highlights to use on</a>
<a name="ln7670">/// top of HLF_SNC is computed.  Called only when nvim starts and upon first</a>
<a name="ln7671">/// screen redraw after any :highlight command.</a>
<a name="ln7672">void highlight_changed(void)</a>
<a name="ln7673">{</a>
<a name="ln7674">  int id;</a>
<a name="ln7675">  char_u userhl[30];  // use 30 to avoid compiler warning</a>
<a name="ln7676">  int id_S = -1;</a>
<a name="ln7677">  int id_SNC = 0;</a>
<a name="ln7678">  int hlcnt;</a>
<a name="ln7679"> </a>
<a name="ln7680">  need_highlight_changed = FALSE;</a>
<a name="ln7681"> </a>
<a name="ln7682">  /// Translate builtin highlight groups into attributes for quick lookup.</a>
<a name="ln7683">  for (int hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln7684">    id = syn_check_group((char_u *)hlf_names[hlf], STRLEN(hlf_names[hlf]));</a>
<a name="ln7685">    if (id == 0) {</a>
<a name="ln7686">      abort();</a>
<a name="ln7687">    }</a>
<a name="ln7688">    int final_id = syn_get_final_id(id);</a>
<a name="ln7689">    if (hlf == (int)HLF_SNC) {</a>
<a name="ln7690">      id_SNC = final_id;</a>
<a name="ln7691">    } else if (hlf == (int)HLF_S) {</a>
<a name="ln7692">      id_S = final_id;</a>
<a name="ln7693">    }</a>
<a name="ln7694"> </a>
<a name="ln7695">    highlight_attr[hlf] = hl_get_ui_attr(hlf, final_id,</a>
<a name="ln7696">                                         hlf == (int)HLF_INACTIVE);</a>
<a name="ln7697"> </a>
<a name="ln7698">    if (highlight_attr[hlf] != highlight_attr_last[hlf]) {</a>
<a name="ln7699">      if (hlf == HLF_MSG) {</a>
<a name="ln7700">        clear_cmdline = true;</a>
<a name="ln7701">      }</a>
<a name="ln7702">      ui_call_hl_group_set(cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln7703">                           highlight_attr[hlf]);</a>
<a name="ln7704">      highlight_attr_last[hlf] = highlight_attr[hlf];</a>
<a name="ln7705">    }</a>
<a name="ln7706">  }</a>
<a name="ln7707"> </a>
<a name="ln7708">  //</a>
<a name="ln7709">  // Setup the user highlights</a>
<a name="ln7710">  //</a>
<a name="ln7711">  // Temporarily utilize 10 more hl entries:</a>
<a name="ln7712">  // 9 for User1-User9 combined with StatusLineNC</a>
<a name="ln7713">  // 1 for StatusLine default</a>
<a name="ln7714">  // Must to be in there simultaneously in case of table overflows in</a>
<a name="ln7715">  // get_attr_entry()</a>
<a name="ln7716">  ga_grow(&amp;highlight_ga, 10);</a>
<a name="ln7717">  hlcnt = highlight_ga.ga_len;</a>
<a name="ln7718">  if (id_S == -1) {</a>
<a name="ln7719">    // Make sure id_S is always valid to simplify code below. Use the last entry</a>
<a name="ln7720">    memset(&amp;HL_TABLE()[hlcnt + 9], 0, sizeof(struct hl_group));</a>
<a name="ln7721">    id_S = hlcnt + 10;</a>
<a name="ln7722">  }</a>
<a name="ln7723">  for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln7724">    sprintf((char *)userhl, &quot;User%d&quot;, i + 1);</a>
<a name="ln7725">    id = syn_name2id(userhl);</a>
<a name="ln7726">    if (id == 0) {</a>
<a name="ln7727">      highlight_user[i] = 0;</a>
<a name="ln7728">      highlight_stlnc[i] = 0;</a>
<a name="ln7729">    } else {</a>
<a name="ln7730">      highlight_user[i] = syn_id2attr(id);</a>
<a name="ln7731">      combine_stl_hlt(id, id_S, id_SNC, hlcnt, i, HLF_SNC, highlight_stlnc);</a>
<a name="ln7732">    }</a>
<a name="ln7733">  }</a>
<a name="ln7734">  highlight_ga.ga_len = hlcnt;</a>
<a name="ln7735">}</a>
<a name="ln7736"> </a>
<a name="ln7737"> </a>
<a name="ln7738">/*</a>
<a name="ln7739"> * Handle command line completion for :highlight command.</a>
<a name="ln7740"> */</a>
<a name="ln7741">void set_context_in_highlight_cmd(expand_T *xp, const char *arg)</a>
<a name="ln7742">{</a>
<a name="ln7743">  // Default: expand group names.</a>
<a name="ln7744">  xp-&gt;xp_context = EXPAND_HIGHLIGHT;</a>
<a name="ln7745">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln7746">  include_link = 2;</a>
<a name="ln7747">  include_default = 1;</a>
<a name="ln7748"> </a>
<a name="ln7749">  /* (part of) subcommand already typed */</a>
<a name="ln7750">  if (*arg != NUL) {</a>
<a name="ln7751">    const char *p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln7752">    if (*p != NUL) {  // Past &quot;default&quot; or group name.</a>
<a name="ln7753">      include_default = 0;</a>
<a name="ln7754">      if (strncmp(&quot;default&quot;, arg, p - arg) == 0) {</a>
<a name="ln7755">        arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln7756">        xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln7757">        p = (const char *)skiptowhite((const char_u *)arg);</a>
<a name="ln7758">      }</a>
<a name="ln7759">      if (*p != NUL) {                          /* past group name */</a>
<a name="ln7760">        include_link = 0;</a>
<a name="ln7761">        if (arg[1] == 'i' &amp;&amp; arg[0] == 'N') {</a>
<a name="ln7762">          highlight_list();</a>
<a name="ln7763">        }</a>
<a name="ln7764">        if (strncmp(&quot;link&quot;, arg, p - arg) == 0</a>
<a name="ln7765">            || strncmp(&quot;clear&quot;, arg, p - arg) == 0) {</a>
<a name="ln7766">          xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln7767">          p = (const char *)skiptowhite(xp-&gt;xp_pattern);</a>
<a name="ln7768">          if (*p != NUL) {  // Past first group name.</a>
<a name="ln7769">            xp-&gt;xp_pattern = skipwhite((const char_u *)p);</a>
<a name="ln7770">            p = (const char *)skiptowhite(xp-&gt;xp_pattern);</a>
<a name="ln7771">          }</a>
<a name="ln7772">        }</a>
<a name="ln7773">        if (*p != NUL) {  // Past group name(s).</a>
<a name="ln7774">          xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln7775">        }</a>
<a name="ln7776">      }</a>
<a name="ln7777">    }</a>
<a name="ln7778">  }</a>
<a name="ln7779">}</a>
<a name="ln7780"> </a>
<a name="ln7781">/*</a>
<a name="ln7782"> * List highlighting matches in a nice way.</a>
<a name="ln7783"> */</a>
<a name="ln7784">static void highlight_list(void)</a>
<a name="ln7785">{</a>
<a name="ln7786">  int i;</a>
<a name="ln7787"> </a>
<a name="ln7788">  for (i = 10; --i &gt;= 0; ) {</a>
<a name="ln7789">    highlight_list_two(i, HL_ATTR(HLF_D));</a>
<a name="ln7790">  }</a>
<a name="ln7791">  for (i = 40; --i &gt;= 0; ) {</a>
<a name="ln7792">    highlight_list_two(99, 0);</a>
<a name="ln7793">  }</a>
<a name="ln7794">}</a>
<a name="ln7795"> </a>
<a name="ln7796">static void highlight_list_two(int cnt, int attr)</a>
<a name="ln7797">{</a>
<a name="ln7798">  msg_puts_attr(&amp;(&quot;N \bI \b!  \b&quot;[cnt / 11]), attr);</a>
<a name="ln7799">  msg_clr_eos();</a>
<a name="ln7800">  ui_flush();</a>
<a name="ln7801">  os_delay(cnt == 99 ? 40L : (long)cnt * 50L, false);</a>
<a name="ln7802">}</a>
<a name="ln7803"> </a>
<a name="ln7804"> </a>
<a name="ln7805">/// Function given to ExpandGeneric() to obtain the list of group names.</a>
<a name="ln7806">const char *get_highlight_name(expand_T *const xp, int idx)</a>
<a name="ln7807">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7808">{</a>
<a name="ln7809">  return get_highlight_name_ext(xp, idx, true);</a>
<a name="ln7810">}</a>
<a name="ln7811"> </a>
<a name="ln7812"> </a>
<a name="ln7813">/// Obtain a highlight group name.</a>
<a name="ln7814">/// When &quot;skip_cleared&quot; is TRUE don't return a cleared entry.</a>
<a name="ln7815">const char *get_highlight_name_ext(expand_T *xp, int idx, int skip_cleared)</a>
<a name="ln7816">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7817">{</a>
<a name="ln7818">  if (idx &lt; 0) {</a>
<a name="ln7819">    return NULL;</a>
<a name="ln7820">  }</a>
<a name="ln7821"> </a>
<a name="ln7822">  // Items are never removed from the table, skip the ones that were cleared.</a>
<a name="ln7823">  if (skip_cleared &amp;&amp; idx &lt; highlight_ga.ga_len &amp;&amp; HL_TABLE()[idx].sg_cleared) {</a>
<a name="ln7824">    return &quot;&quot;;</a>
<a name="ln7825">  }</a>
<a name="ln7826"> </a>
<a name="ln7827">  if (idx == highlight_ga.ga_len &amp;&amp; include_none != 0) {</a>
<a name="ln7828">    return &quot;none&quot;;</a>
<a name="ln7829">  } else if (idx == highlight_ga.ga_len + include_none</a>
<a name="ln7830">             &amp;&amp; include_default != 0) {</a>
<a name="ln7831">    return &quot;default&quot;;</a>
<a name="ln7832">  } else if (idx == highlight_ga.ga_len + include_none + include_default</a>
<a name="ln7833">             &amp;&amp; include_link != 0) {</a>
<a name="ln7834">    return &quot;link&quot;;</a>
<a name="ln7835">  } else if (idx == highlight_ga.ga_len + include_none + include_default + 1</a>
<a name="ln7836">             &amp;&amp; include_link != 0) {</a>
<a name="ln7837">    return &quot;clear&quot;;</a>
<a name="ln7838">  } else if (idx &gt;= highlight_ga.ga_len) {</a>
<a name="ln7839">    return NULL;</a>
<a name="ln7840">  }</a>
<a name="ln7841">  return (const char *)HL_TABLE()[idx].sg_name;</a>
<a name="ln7842">}</a>
<a name="ln7843"> </a>
<a name="ln7844">color_name_table_T color_name_table[] = {</a>
<a name="ln7845">  // Colors from rgb.txt</a>
<a name="ln7846">  { &quot;AliceBlue&quot;, RGB_(0xf0, 0xf8, 0xff) },</a>
<a name="ln7847">  { &quot;AntiqueWhite&quot;, RGB_(0xfa, 0xeb, 0xd7) },</a>
<a name="ln7848">  { &quot;AntiqueWhite1&quot;, RGB_(0xff, 0xef, 0xdb) },</a>
<a name="ln7849">  { &quot;AntiqueWhite2&quot;, RGB_(0xee, 0xdf, 0xcc) },</a>
<a name="ln7850">  { &quot;AntiqueWhite3&quot;, RGB_(0xcd, 0xc0, 0xb0) },</a>
<a name="ln7851">  { &quot;AntiqueWhite4&quot;, RGB_(0x8b, 0x83, 0x78) },</a>
<a name="ln7852">  { &quot;Aqua&quot;, RGB_(0x00, 0xff, 0xff) },</a>
<a name="ln7853">  { &quot;Aquamarine&quot;, RGB_(0x7f, 0xff, 0xd4) },</a>
<a name="ln7854">  { &quot;Aquamarine1&quot;, RGB_(0x7f, 0xff, 0xd4) },</a>
<a name="ln7855">  { &quot;Aquamarine2&quot;, RGB_(0x76, 0xee, 0xc6) },</a>
<a name="ln7856">  { &quot;Aquamarine3&quot;, RGB_(0x66, 0xcd, 0xaa) },</a>
<a name="ln7857">  { &quot;Aquamarine4&quot;, RGB_(0x45, 0x8b, 0x74) },</a>
<a name="ln7858">  { &quot;Azure&quot;, RGB_(0xf0, 0xff, 0xff) },</a>
<a name="ln7859">  { &quot;Azure1&quot;, RGB_(0xf0, 0xff, 0xff) },</a>
<a name="ln7860">  { &quot;Azure2&quot;, RGB_(0xe0, 0xee, 0xee) },</a>
<a name="ln7861">  { &quot;Azure3&quot;, RGB_(0xc1, 0xcd, 0xcd) },</a>
<a name="ln7862">  { &quot;Azure4&quot;, RGB_(0x83, 0x8b, 0x8b) },</a>
<a name="ln7863">  { &quot;Beige&quot;, RGB_(0xf5, 0xf5, 0xdc) },</a>
<a name="ln7864">  { &quot;Bisque&quot;, RGB_(0xff, 0xe4, 0xc4) },</a>
<a name="ln7865">  { &quot;Bisque1&quot;, RGB_(0xff, 0xe4, 0xc4) },</a>
<a name="ln7866">  { &quot;Bisque2&quot;, RGB_(0xee, 0xd5, 0xb7) },</a>
<a name="ln7867">  { &quot;Bisque3&quot;, RGB_(0xcd, 0xb7, 0x9e) },</a>
<a name="ln7868">  { &quot;Bisque4&quot;, RGB_(0x8b, 0x7d, 0x6b) },</a>
<a name="ln7869">  { &quot;Black&quot;, RGB_(0x00, 0x00, 0x00) },</a>
<a name="ln7870">  { &quot;BlanchedAlmond&quot;, RGB_(0xff, 0xeb, 0xcd) },</a>
<a name="ln7871">  { &quot;Blue&quot;, RGB_(0x00, 0x00, 0xff) },</a>
<a name="ln7872">  { &quot;Blue1&quot;, RGB_(0x0, 0x0, 0xff) },</a>
<a name="ln7873">  { &quot;Blue2&quot;, RGB_(0x0, 0x0, 0xee) },</a>
<a name="ln7874">  { &quot;Blue3&quot;, RGB_(0x0, 0x0, 0xcd) },</a>
<a name="ln7875">  { &quot;Blue4&quot;, RGB_(0x0, 0x0, 0x8b) },</a>
<a name="ln7876">  { &quot;BlueViolet&quot;, RGB_(0x8a, 0x2b, 0xe2) },</a>
<a name="ln7877">  { &quot;Brown&quot;, RGB_(0xa5, 0x2a, 0x2a) },</a>
<a name="ln7878">  { &quot;Brown1&quot;, RGB_(0xff, 0x40, 0x40) },</a>
<a name="ln7879">  { &quot;Brown2&quot;, RGB_(0xee, 0x3b, 0x3b) },</a>
<a name="ln7880">  { &quot;Brown3&quot;, RGB_(0xcd, 0x33, 0x33) },</a>
<a name="ln7881">  { &quot;Brown4&quot;, RGB_(0x8b, 0x23, 0x23) },</a>
<a name="ln7882">  { &quot;BurlyWood&quot;, RGB_(0xde, 0xb8, 0x87) },</a>
<a name="ln7883">  { &quot;Burlywood1&quot;, RGB_(0xff, 0xd3, 0x9b) },</a>
<a name="ln7884">  { &quot;Burlywood2&quot;, RGB_(0xee, 0xc5, 0x91) },</a>
<a name="ln7885">  { &quot;Burlywood3&quot;, RGB_(0xcd, 0xaa, 0x7d) },</a>
<a name="ln7886">  { &quot;Burlywood4&quot;, RGB_(0x8b, 0x73, 0x55) },</a>
<a name="ln7887">  { &quot;CadetBlue&quot;, RGB_(0x5f, 0x9e, 0xa0) },</a>
<a name="ln7888">  { &quot;CadetBlue1&quot;, RGB_(0x98, 0xf5, 0xff) },</a>
<a name="ln7889">  { &quot;CadetBlue2&quot;, RGB_(0x8e, 0xe5, 0xee) },</a>
<a name="ln7890">  { &quot;CadetBlue3&quot;, RGB_(0x7a, 0xc5, 0xcd) },</a>
<a name="ln7891">  { &quot;CadetBlue4&quot;, RGB_(0x53, 0x86, 0x8b) },</a>
<a name="ln7892">  { &quot;ChartReuse&quot;, RGB_(0x7f, 0xff, 0x00) },</a>
<a name="ln7893">  { &quot;Chartreuse1&quot;, RGB_(0x7f, 0xff, 0x0) },</a>
<a name="ln7894">  { &quot;Chartreuse2&quot;, RGB_(0x76, 0xee, 0x0) },</a>
<a name="ln7895">  { &quot;Chartreuse3&quot;, RGB_(0x66, 0xcd, 0x0) },</a>
<a name="ln7896">  { &quot;Chartreuse4&quot;, RGB_(0x45, 0x8b, 0x0) },</a>
<a name="ln7897">  { &quot;Chocolate&quot;, RGB_(0xd2, 0x69, 0x1e) },</a>
<a name="ln7898">  { &quot;Chocolate1&quot;, RGB_(0xff, 0x7f, 0x24) },</a>
<a name="ln7899">  { &quot;Chocolate2&quot;, RGB_(0xee, 0x76, 0x21) },</a>
<a name="ln7900">  { &quot;Chocolate3&quot;, RGB_(0xcd, 0x66, 0x1d) },</a>
<a name="ln7901">  { &quot;Chocolate4&quot;, RGB_(0x8b, 0x45, 0x13) },</a>
<a name="ln7902">  { &quot;Coral&quot;, RGB_(0xff, 0x7f, 0x50) },</a>
<a name="ln7903">  { &quot;Coral1&quot;, RGB_(0xff, 0x72, 0x56) },</a>
<a name="ln7904">  { &quot;Coral2&quot;, RGB_(0xee, 0x6a, 0x50) },</a>
<a name="ln7905">  { &quot;Coral3&quot;, RGB_(0xcd, 0x5b, 0x45) },</a>
<a name="ln7906">  { &quot;Coral4&quot;, RGB_(0x8b, 0x3e, 0x2f) },</a>
<a name="ln7907">  { &quot;CornFlowerBlue&quot;, RGB_(0x64, 0x95, 0xed) },</a>
<a name="ln7908">  { &quot;Cornsilk&quot;, RGB_(0xff, 0xf8, 0xdc) },</a>
<a name="ln7909">  { &quot;Cornsilk1&quot;, RGB_(0xff, 0xf8, 0xdc) },</a>
<a name="ln7910">  { &quot;Cornsilk2&quot;, RGB_(0xee, 0xe8, 0xcd) },</a>
<a name="ln7911">  { &quot;Cornsilk3&quot;, RGB_(0xcd, 0xc8, 0xb1) },</a>
<a name="ln7912">  { &quot;Cornsilk4&quot;, RGB_(0x8b, 0x88, 0x78) },</a>
<a name="ln7913">  { &quot;Crimson&quot;, RGB_(0xdc, 0x14, 0x3c) },</a>
<a name="ln7914">  { &quot;Cyan&quot;, RGB_(0x00, 0xff, 0xff) },</a>
<a name="ln7915">  { &quot;Cyan1&quot;, RGB_(0x0, 0xff, 0xff) },</a>
<a name="ln7916">  { &quot;Cyan2&quot;, RGB_(0x0, 0xee, 0xee) },</a>
<a name="ln7917">  { &quot;Cyan3&quot;, RGB_(0x0, 0xcd, 0xcd) },</a>
<a name="ln7918">  { &quot;Cyan4&quot;, RGB_(0x0, 0x8b, 0x8b) },</a>
<a name="ln7919">  { &quot;DarkBlue&quot;, RGB_(0x00, 0x00, 0x8b) },</a>
<a name="ln7920">  { &quot;DarkCyan&quot;, RGB_(0x00, 0x8b, 0x8b) },</a>
<a name="ln7921">  { &quot;DarkGoldenRod&quot;, RGB_(0xb8, 0x86, 0x0b) },</a>
<a name="ln7922">  { &quot;DarkGoldenrod1&quot;, RGB_(0xff, 0xb9, 0xf) },</a>
<a name="ln7923">  { &quot;DarkGoldenrod2&quot;, RGB_(0xee, 0xad, 0xe) },</a>
<a name="ln7924">  { &quot;DarkGoldenrod3&quot;, RGB_(0xcd, 0x95, 0xc) },</a>
<a name="ln7925">  { &quot;DarkGoldenrod4&quot;, RGB_(0x8b, 0x65, 0x8) },</a>
<a name="ln7926">  { &quot;DarkGray&quot;, RGB_(0xa9, 0xa9, 0xa9) },</a>
<a name="ln7927">  { &quot;DarkGreen&quot;, RGB_(0x00, 0x64, 0x00) },</a>
<a name="ln7928">  { &quot;DarkGrey&quot;, RGB_(0xa9, 0xa9, 0xa9) },</a>
<a name="ln7929">  { &quot;DarkKhaki&quot;, RGB_(0xbd, 0xb7, 0x6b) },</a>
<a name="ln7930">  { &quot;DarkMagenta&quot;, RGB_(0x8b, 0x00, 0x8b) },</a>
<a name="ln7931">  { &quot;DarkOliveGreen&quot;, RGB_(0x55, 0x6b, 0x2f) },</a>
<a name="ln7932">  { &quot;DarkOliveGreen1&quot;, RGB_(0xca, 0xff, 0x70) },</a>
<a name="ln7933">  { &quot;DarkOliveGreen2&quot;, RGB_(0xbc, 0xee, 0x68) },</a>
<a name="ln7934">  { &quot;DarkOliveGreen3&quot;, RGB_(0xa2, 0xcd, 0x5a) },</a>
<a name="ln7935">  { &quot;DarkOliveGreen4&quot;, RGB_(0x6e, 0x8b, 0x3d) },</a>
<a name="ln7936">  { &quot;DarkOrange&quot;, RGB_(0xff, 0x8c, 0x00) },</a>
<a name="ln7937">  { &quot;DarkOrange1&quot;, RGB_(0xff, 0x7f, 0x0) },</a>
<a name="ln7938">  { &quot;DarkOrange2&quot;, RGB_(0xee, 0x76, 0x0) },</a>
<a name="ln7939">  { &quot;DarkOrange3&quot;, RGB_(0xcd, 0x66, 0x0) },</a>
<a name="ln7940">  { &quot;DarkOrange4&quot;, RGB_(0x8b, 0x45, 0x0) },</a>
<a name="ln7941">  { &quot;DarkOrchid&quot;, RGB_(0x99, 0x32, 0xcc) },</a>
<a name="ln7942">  { &quot;DarkOrchid1&quot;, RGB_(0xbf, 0x3e, 0xff) },</a>
<a name="ln7943">  { &quot;DarkOrchid2&quot;, RGB_(0xb2, 0x3a, 0xee) },</a>
<a name="ln7944">  { &quot;DarkOrchid3&quot;, RGB_(0x9a, 0x32, 0xcd) },</a>
<a name="ln7945">  { &quot;DarkOrchid4&quot;, RGB_(0x68, 0x22, 0x8b) },</a>
<a name="ln7946">  { &quot;DarkRed&quot;, RGB_(0x8b, 0x00, 0x00) },</a>
<a name="ln7947">  { &quot;DarkSalmon&quot;, RGB_(0xe9, 0x96, 0x7a) },</a>
<a name="ln7948">  { &quot;DarkSeaGreen&quot;, RGB_(0x8f, 0xbc, 0x8f) },</a>
<a name="ln7949">  { &quot;DarkSeaGreen1&quot;, RGB_(0xc1, 0xff, 0xc1) },</a>
<a name="ln7950">  { &quot;DarkSeaGreen2&quot;, RGB_(0xb4, 0xee, 0xb4) },</a>
<a name="ln7951">  { &quot;DarkSeaGreen3&quot;, RGB_(0x9b, 0xcd, 0x9b) },</a>
<a name="ln7952">  { &quot;DarkSeaGreen4&quot;, RGB_(0x69, 0x8b, 0x69) },</a>
<a name="ln7953">  { &quot;DarkSlateBlue&quot;, RGB_(0x48, 0x3d, 0x8b) },</a>
<a name="ln7954">  { &quot;DarkSlateGray&quot;, RGB_(0x2f, 0x4f, 0x4f) },</a>
<a name="ln7955">  { &quot;DarkSlateGray1&quot;, RGB_(0x97, 0xff, 0xff) },</a>
<a name="ln7956">  { &quot;DarkSlateGray2&quot;, RGB_(0x8d, 0xee, 0xee) },</a>
<a name="ln7957">  { &quot;DarkSlateGray3&quot;, RGB_(0x79, 0xcd, 0xcd) },</a>
<a name="ln7958">  { &quot;DarkSlateGray4&quot;, RGB_(0x52, 0x8b, 0x8b) },</a>
<a name="ln7959">  { &quot;DarkSlateGrey&quot;, RGB_(0x2f, 0x4f, 0x4f) },</a>
<a name="ln7960">  { &quot;DarkTurquoise&quot;, RGB_(0x00, 0xce, 0xd1) },</a>
<a name="ln7961">  { &quot;DarkViolet&quot;, RGB_(0x94, 0x00, 0xd3) },</a>
<a name="ln7962">  { &quot;DarkYellow&quot;, RGB_(0xbb, 0xbb, 0x00) },</a>
<a name="ln7963">  { &quot;DeepPink&quot;, RGB_(0xff, 0x14, 0x93) },</a>
<a name="ln7964">  { &quot;DeepPink1&quot;, RGB_(0xff, 0x14, 0x93) },</a>
<a name="ln7965">  { &quot;DeepPink2&quot;, RGB_(0xee, 0x12, 0x89) },</a>
<a name="ln7966">  { &quot;DeepPink3&quot;, RGB_(0xcd, 0x10, 0x76) },</a>
<a name="ln7967">  { &quot;DeepPink4&quot;, RGB_(0x8b, 0xa, 0x50) },</a>
<a name="ln7968">  { &quot;DeepSkyBlue&quot;, RGB_(0x00, 0xbf, 0xff) },</a>
<a name="ln7969">  { &quot;DeepSkyBlue1&quot;, RGB_(0x0, 0xbf, 0xff) },</a>
<a name="ln7970">  { &quot;DeepSkyBlue2&quot;, RGB_(0x0, 0xb2, 0xee) },</a>
<a name="ln7971">  { &quot;DeepSkyBlue3&quot;, RGB_(0x0, 0x9a, 0xcd) },</a>
<a name="ln7972">  { &quot;DeepSkyBlue4&quot;, RGB_(0x0, 0x68, 0x8b) },</a>
<a name="ln7973">  { &quot;DimGray&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln7974">  { &quot;DimGrey&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln7975">  { &quot;DodgerBlue&quot;, RGB_(0x1e, 0x90, 0xff) },</a>
<a name="ln7976">  { &quot;DodgerBlue1&quot;, RGB_(0x1e, 0x90, 0xff) },</a>
<a name="ln7977">  { &quot;DodgerBlue2&quot;, RGB_(0x1c, 0x86, 0xee) },</a>
<a name="ln7978">  { &quot;DodgerBlue3&quot;, RGB_(0x18, 0x74, 0xcd) },</a>
<a name="ln7979">  { &quot;DodgerBlue4&quot;, RGB_(0x10, 0x4e, 0x8b) },</a>
<a name="ln7980">  { &quot;Firebrick&quot;, RGB_(0xb2, 0x22, 0x22) },</a>
<a name="ln7981">  { &quot;Firebrick1&quot;, RGB_(0xff, 0x30, 0x30) },</a>
<a name="ln7982">  { &quot;Firebrick2&quot;, RGB_(0xee, 0x2c, 0x2c) },</a>
<a name="ln7983">  { &quot;Firebrick3&quot;, RGB_(0xcd, 0x26, 0x26) },</a>
<a name="ln7984">  { &quot;Firebrick4&quot;, RGB_(0x8b, 0x1a, 0x1a) },</a>
<a name="ln7985">  { &quot;FloralWhite&quot;, RGB_(0xff, 0xfa, 0xf0) },</a>
<a name="ln7986">  { &quot;ForestGreen&quot;, RGB_(0x22, 0x8b, 0x22) },</a>
<a name="ln7987">  { &quot;Fuchsia&quot;, RGB_(0xff, 0x00, 0xff) },</a>
<a name="ln7988">  { &quot;Gainsboro&quot;, RGB_(0xdc, 0xdc, 0xdc) },</a>
<a name="ln7989">  { &quot;GhostWhite&quot;, RGB_(0xf8, 0xf8, 0xff) },</a>
<a name="ln7990">  { &quot;Gold&quot;, RGB_(0xff, 0xd7, 0x00) },</a>
<a name="ln7991">  { &quot;Gold1&quot;, RGB_(0xff, 0xd7, 0x0) },</a>
<a name="ln7992">  { &quot;Gold2&quot;, RGB_(0xee, 0xc9, 0x0) },</a>
<a name="ln7993">  { &quot;Gold3&quot;, RGB_(0xcd, 0xad, 0x0) },</a>
<a name="ln7994">  { &quot;Gold4&quot;, RGB_(0x8b, 0x75, 0x0) },</a>
<a name="ln7995">  { &quot;GoldenRod&quot;, RGB_(0xda, 0xa5, 0x20) },</a>
<a name="ln7996">  { &quot;Goldenrod1&quot;, RGB_(0xff, 0xc1, 0x25) },</a>
<a name="ln7997">  { &quot;Goldenrod2&quot;, RGB_(0xee, 0xb4, 0x22) },</a>
<a name="ln7998">  { &quot;Goldenrod3&quot;, RGB_(0xcd, 0x9b, 0x1d) },</a>
<a name="ln7999">  { &quot;Goldenrod4&quot;, RGB_(0x8b, 0x69, 0x14) },</a>
<a name="ln8000">  { &quot;Gray&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8001">  { &quot;Gray0&quot;, RGB_(0x0, 0x0, 0x0) },</a>
<a name="ln8002">  { &quot;Gray1&quot;, RGB_(0x3, 0x3, 0x3) },</a>
<a name="ln8003">  { &quot;Gray10&quot;, RGB_(0x1a, 0x1a, 0x1a) },</a>
<a name="ln8004">  { &quot;Gray100&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8005">  { &quot;Gray11&quot;, RGB_(0x1c, 0x1c, 0x1c) },</a>
<a name="ln8006">  { &quot;Gray12&quot;, RGB_(0x1f, 0x1f, 0x1f) },</a>
<a name="ln8007">  { &quot;Gray13&quot;, RGB_(0x21, 0x21, 0x21) },</a>
<a name="ln8008">  { &quot;Gray14&quot;, RGB_(0x24, 0x24, 0x24) },</a>
<a name="ln8009">  { &quot;Gray15&quot;, RGB_(0x26, 0x26, 0x26) },</a>
<a name="ln8010">  { &quot;Gray16&quot;, RGB_(0x29, 0x29, 0x29) },</a>
<a name="ln8011">  { &quot;Gray17&quot;, RGB_(0x2b, 0x2b, 0x2b) },</a>
<a name="ln8012">  { &quot;Gray18&quot;, RGB_(0x2e, 0x2e, 0x2e) },</a>
<a name="ln8013">  { &quot;Gray19&quot;, RGB_(0x30, 0x30, 0x30) },</a>
<a name="ln8014">  { &quot;Gray2&quot;, RGB_(0x5, 0x5, 0x5) },</a>
<a name="ln8015">  { &quot;Gray20&quot;, RGB_(0x33, 0x33, 0x33) },</a>
<a name="ln8016">  { &quot;Gray21&quot;, RGB_(0x36, 0x36, 0x36) },</a>
<a name="ln8017">  { &quot;Gray22&quot;, RGB_(0x38, 0x38, 0x38) },</a>
<a name="ln8018">  { &quot;Gray23&quot;, RGB_(0x3b, 0x3b, 0x3b) },</a>
<a name="ln8019">  { &quot;Gray24&quot;, RGB_(0x3d, 0x3d, 0x3d) },</a>
<a name="ln8020">  { &quot;Gray25&quot;, RGB_(0x40, 0x40, 0x40) },</a>
<a name="ln8021">  { &quot;Gray26&quot;, RGB_(0x42, 0x42, 0x42) },</a>
<a name="ln8022">  { &quot;Gray27&quot;, RGB_(0x45, 0x45, 0x45) },</a>
<a name="ln8023">  { &quot;Gray28&quot;, RGB_(0x47, 0x47, 0x47) },</a>
<a name="ln8024">  { &quot;Gray29&quot;, RGB_(0x4a, 0x4a, 0x4a) },</a>
<a name="ln8025">  { &quot;Gray3&quot;, RGB_(0x8, 0x8, 0x8) },</a>
<a name="ln8026">  { &quot;Gray30&quot;, RGB_(0x4d, 0x4d, 0x4d) },</a>
<a name="ln8027">  { &quot;Gray31&quot;, RGB_(0x4f, 0x4f, 0x4f) },</a>
<a name="ln8028">  { &quot;Gray32&quot;, RGB_(0x52, 0x52, 0x52) },</a>
<a name="ln8029">  { &quot;Gray33&quot;, RGB_(0x54, 0x54, 0x54) },</a>
<a name="ln8030">  { &quot;Gray34&quot;, RGB_(0x57, 0x57, 0x57) },</a>
<a name="ln8031">  { &quot;Gray35&quot;, RGB_(0x59, 0x59, 0x59) },</a>
<a name="ln8032">  { &quot;Gray36&quot;, RGB_(0x5c, 0x5c, 0x5c) },</a>
<a name="ln8033">  { &quot;Gray37&quot;, RGB_(0x5e, 0x5e, 0x5e) },</a>
<a name="ln8034">  { &quot;Gray38&quot;, RGB_(0x61, 0x61, 0x61) },</a>
<a name="ln8035">  { &quot;Gray39&quot;, RGB_(0x63, 0x63, 0x63) },</a>
<a name="ln8036">  { &quot;Gray4&quot;, RGB_(0xa, 0xa, 0xa) },</a>
<a name="ln8037">  { &quot;Gray40&quot;, RGB_(0x66, 0x66, 0x66) },</a>
<a name="ln8038">  { &quot;Gray41&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln8039">  { &quot;Gray42&quot;, RGB_(0x6b, 0x6b, 0x6b) },</a>
<a name="ln8040">  { &quot;Gray43&quot;, RGB_(0x6e, 0x6e, 0x6e) },</a>
<a name="ln8041">  { &quot;Gray44&quot;, RGB_(0x70, 0x70, 0x70) },</a>
<a name="ln8042">  { &quot;Gray45&quot;, RGB_(0x73, 0x73, 0x73) },</a>
<a name="ln8043">  { &quot;Gray46&quot;, RGB_(0x75, 0x75, 0x75) },</a>
<a name="ln8044">  { &quot;Gray47&quot;, RGB_(0x78, 0x78, 0x78) },</a>
<a name="ln8045">  { &quot;Gray48&quot;, RGB_(0x7a, 0x7a, 0x7a) },</a>
<a name="ln8046">  { &quot;Gray49&quot;, RGB_(0x7d, 0x7d, 0x7d) },</a>
<a name="ln8047">  { &quot;Gray5&quot;, RGB_(0xd, 0xd, 0xd) },</a>
<a name="ln8048">  { &quot;Gray50&quot;, RGB_(0x7f, 0x7f, 0x7f) },</a>
<a name="ln8049">  { &quot;Gray51&quot;, RGB_(0x82, 0x82, 0x82) },</a>
<a name="ln8050">  { &quot;Gray52&quot;, RGB_(0x85, 0x85, 0x85) },</a>
<a name="ln8051">  { &quot;Gray53&quot;, RGB_(0x87, 0x87, 0x87) },</a>
<a name="ln8052">  { &quot;Gray54&quot;, RGB_(0x8a, 0x8a, 0x8a) },</a>
<a name="ln8053">  { &quot;Gray55&quot;, RGB_(0x8c, 0x8c, 0x8c) },</a>
<a name="ln8054">  { &quot;Gray56&quot;, RGB_(0x8f, 0x8f, 0x8f) },</a>
<a name="ln8055">  { &quot;Gray57&quot;, RGB_(0x91, 0x91, 0x91) },</a>
<a name="ln8056">  { &quot;Gray58&quot;, RGB_(0x94, 0x94, 0x94) },</a>
<a name="ln8057">  { &quot;Gray59&quot;, RGB_(0x96, 0x96, 0x96) },</a>
<a name="ln8058">  { &quot;Gray6&quot;, RGB_(0xf, 0xf, 0xf) },</a>
<a name="ln8059">  { &quot;Gray60&quot;, RGB_(0x99, 0x99, 0x99) },</a>
<a name="ln8060">  { &quot;Gray61&quot;, RGB_(0x9c, 0x9c, 0x9c) },</a>
<a name="ln8061">  { &quot;Gray62&quot;, RGB_(0x9e, 0x9e, 0x9e) },</a>
<a name="ln8062">  { &quot;Gray63&quot;, RGB_(0xa1, 0xa1, 0xa1) },</a>
<a name="ln8063">  { &quot;Gray64&quot;, RGB_(0xa3, 0xa3, 0xa3) },</a>
<a name="ln8064">  { &quot;Gray65&quot;, RGB_(0xa6, 0xa6, 0xa6) },</a>
<a name="ln8065">  { &quot;Gray66&quot;, RGB_(0xa8, 0xa8, 0xa8) },</a>
<a name="ln8066">  { &quot;Gray67&quot;, RGB_(0xab, 0xab, 0xab) },</a>
<a name="ln8067">  { &quot;Gray68&quot;, RGB_(0xad, 0xad, 0xad) },</a>
<a name="ln8068">  { &quot;Gray69&quot;, RGB_(0xb0, 0xb0, 0xb0) },</a>
<a name="ln8069">  { &quot;Gray7&quot;, RGB_(0x12, 0x12, 0x12) },</a>
<a name="ln8070">  { &quot;Gray70&quot;, RGB_(0xb3, 0xb3, 0xb3) },</a>
<a name="ln8071">  { &quot;Gray71&quot;, RGB_(0xb5, 0xb5, 0xb5) },</a>
<a name="ln8072">  { &quot;Gray72&quot;, RGB_(0xb8, 0xb8, 0xb8) },</a>
<a name="ln8073">  { &quot;Gray73&quot;, RGB_(0xba, 0xba, 0xba) },</a>
<a name="ln8074">  { &quot;Gray74&quot;, RGB_(0xbd, 0xbd, 0xbd) },</a>
<a name="ln8075">  { &quot;Gray75&quot;, RGB_(0xbf, 0xbf, 0xbf) },</a>
<a name="ln8076">  { &quot;Gray76&quot;, RGB_(0xc2, 0xc2, 0xc2) },</a>
<a name="ln8077">  { &quot;Gray77&quot;, RGB_(0xc4, 0xc4, 0xc4) },</a>
<a name="ln8078">  { &quot;Gray78&quot;, RGB_(0xc7, 0xc7, 0xc7) },</a>
<a name="ln8079">  { &quot;Gray79&quot;, RGB_(0xc9, 0xc9, 0xc9) },</a>
<a name="ln8080">  { &quot;Gray8&quot;, RGB_(0x14, 0x14, 0x14) },</a>
<a name="ln8081">  { &quot;Gray80&quot;, RGB_(0xcc, 0xcc, 0xcc) },</a>
<a name="ln8082">  { &quot;Gray81&quot;, RGB_(0xcf, 0xcf, 0xcf) },</a>
<a name="ln8083">  { &quot;Gray82&quot;, RGB_(0xd1, 0xd1, 0xd1) },</a>
<a name="ln8084">  { &quot;Gray83&quot;, RGB_(0xd4, 0xd4, 0xd4) },</a>
<a name="ln8085">  { &quot;Gray84&quot;, RGB_(0xd6, 0xd6, 0xd6) },</a>
<a name="ln8086">  { &quot;Gray85&quot;, RGB_(0xd9, 0xd9, 0xd9) },</a>
<a name="ln8087">  { &quot;Gray86&quot;, RGB_(0xdb, 0xdb, 0xdb) },</a>
<a name="ln8088">  { &quot;Gray87&quot;, RGB_(0xde, 0xde, 0xde) },</a>
<a name="ln8089">  { &quot;Gray88&quot;, RGB_(0xe0, 0xe0, 0xe0) },</a>
<a name="ln8090">  { &quot;Gray89&quot;, RGB_(0xe3, 0xe3, 0xe3) },</a>
<a name="ln8091">  { &quot;Gray9&quot;, RGB_(0x17, 0x17, 0x17) },</a>
<a name="ln8092">  { &quot;Gray90&quot;, RGB_(0xe5, 0xe5, 0xe5) },</a>
<a name="ln8093">  { &quot;Gray91&quot;, RGB_(0xe8, 0xe8, 0xe8) },</a>
<a name="ln8094">  { &quot;Gray92&quot;, RGB_(0xeb, 0xeb, 0xeb) },</a>
<a name="ln8095">  { &quot;Gray93&quot;, RGB_(0xed, 0xed, 0xed) },</a>
<a name="ln8096">  { &quot;Gray94&quot;, RGB_(0xf0, 0xf0, 0xf0) },</a>
<a name="ln8097">  { &quot;Gray95&quot;, RGB_(0xf2, 0xf2, 0xf2) },</a>
<a name="ln8098">  { &quot;Gray96&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8099">  { &quot;Gray97&quot;, RGB_(0xf7, 0xf7, 0xf7) },</a>
<a name="ln8100">  { &quot;Gray98&quot;, RGB_(0xfa, 0xfa, 0xfa) },</a>
<a name="ln8101">  { &quot;Gray99&quot;, RGB_(0xfc, 0xfc, 0xfc) },</a>
<a name="ln8102">  { &quot;Green&quot;, RGB_(0x00, 0x80, 0x00) },</a>
<a name="ln8103">  { &quot;Green1&quot;, RGB_(0x0, 0xff, 0x0) },</a>
<a name="ln8104">  { &quot;Green2&quot;, RGB_(0x0, 0xee, 0x0) },</a>
<a name="ln8105">  { &quot;Green3&quot;, RGB_(0x0, 0xcd, 0x0) },</a>
<a name="ln8106">  { &quot;Green4&quot;, RGB_(0x0, 0x8b, 0x0) },</a>
<a name="ln8107">  { &quot;GreenYellow&quot;, RGB_(0xad, 0xff, 0x2f) },</a>
<a name="ln8108">  { &quot;Grey&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8109">  { &quot;Grey0&quot;, RGB_(0x0, 0x0, 0x0) },</a>
<a name="ln8110">  { &quot;Grey1&quot;, RGB_(0x3, 0x3, 0x3) },</a>
<a name="ln8111">  { &quot;Grey10&quot;, RGB_(0x1a, 0x1a, 0x1a) },</a>
<a name="ln8112">  { &quot;Grey100&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8113">  { &quot;Grey11&quot;, RGB_(0x1c, 0x1c, 0x1c) },</a>
<a name="ln8114">  { &quot;Grey12&quot;, RGB_(0x1f, 0x1f, 0x1f) },</a>
<a name="ln8115">  { &quot;Grey13&quot;, RGB_(0x21, 0x21, 0x21) },</a>
<a name="ln8116">  { &quot;Grey14&quot;, RGB_(0x24, 0x24, 0x24) },</a>
<a name="ln8117">  { &quot;Grey15&quot;, RGB_(0x26, 0x26, 0x26) },</a>
<a name="ln8118">  { &quot;Grey16&quot;, RGB_(0x29, 0x29, 0x29) },</a>
<a name="ln8119">  { &quot;Grey17&quot;, RGB_(0x2b, 0x2b, 0x2b) },</a>
<a name="ln8120">  { &quot;Grey18&quot;, RGB_(0x2e, 0x2e, 0x2e) },</a>
<a name="ln8121">  { &quot;Grey19&quot;, RGB_(0x30, 0x30, 0x30) },</a>
<a name="ln8122">  { &quot;Grey2&quot;, RGB_(0x5, 0x5, 0x5) },</a>
<a name="ln8123">  { &quot;Grey20&quot;, RGB_(0x33, 0x33, 0x33) },</a>
<a name="ln8124">  { &quot;Grey21&quot;, RGB_(0x36, 0x36, 0x36) },</a>
<a name="ln8125">  { &quot;Grey22&quot;, RGB_(0x38, 0x38, 0x38) },</a>
<a name="ln8126">  { &quot;Grey23&quot;, RGB_(0x3b, 0x3b, 0x3b) },</a>
<a name="ln8127">  { &quot;Grey24&quot;, RGB_(0x3d, 0x3d, 0x3d) },</a>
<a name="ln8128">  { &quot;Grey25&quot;, RGB_(0x40, 0x40, 0x40) },</a>
<a name="ln8129">  { &quot;Grey26&quot;, RGB_(0x42, 0x42, 0x42) },</a>
<a name="ln8130">  { &quot;Grey27&quot;, RGB_(0x45, 0x45, 0x45) },</a>
<a name="ln8131">  { &quot;Grey28&quot;, RGB_(0x47, 0x47, 0x47) },</a>
<a name="ln8132">  { &quot;Grey29&quot;, RGB_(0x4a, 0x4a, 0x4a) },</a>
<a name="ln8133">  { &quot;Grey3&quot;, RGB_(0x8, 0x8, 0x8) },</a>
<a name="ln8134">  { &quot;Grey30&quot;, RGB_(0x4d, 0x4d, 0x4d) },</a>
<a name="ln8135">  { &quot;Grey31&quot;, RGB_(0x4f, 0x4f, 0x4f) },</a>
<a name="ln8136">  { &quot;Grey32&quot;, RGB_(0x52, 0x52, 0x52) },</a>
<a name="ln8137">  { &quot;Grey33&quot;, RGB_(0x54, 0x54, 0x54) },</a>
<a name="ln8138">  { &quot;Grey34&quot;, RGB_(0x57, 0x57, 0x57) },</a>
<a name="ln8139">  { &quot;Grey35&quot;, RGB_(0x59, 0x59, 0x59) },</a>
<a name="ln8140">  { &quot;Grey36&quot;, RGB_(0x5c, 0x5c, 0x5c) },</a>
<a name="ln8141">  { &quot;Grey37&quot;, RGB_(0x5e, 0x5e, 0x5e) },</a>
<a name="ln8142">  { &quot;Grey38&quot;, RGB_(0x61, 0x61, 0x61) },</a>
<a name="ln8143">  { &quot;Grey39&quot;, RGB_(0x63, 0x63, 0x63) },</a>
<a name="ln8144">  { &quot;Grey4&quot;, RGB_(0xa, 0xa, 0xa) },</a>
<a name="ln8145">  { &quot;Grey40&quot;, RGB_(0x66, 0x66, 0x66) },</a>
<a name="ln8146">  { &quot;Grey41&quot;, RGB_(0x69, 0x69, 0x69) },</a>
<a name="ln8147">  { &quot;Grey42&quot;, RGB_(0x6b, 0x6b, 0x6b) },</a>
<a name="ln8148">  { &quot;Grey43&quot;, RGB_(0x6e, 0x6e, 0x6e) },</a>
<a name="ln8149">  { &quot;Grey44&quot;, RGB_(0x70, 0x70, 0x70) },</a>
<a name="ln8150">  { &quot;Grey45&quot;, RGB_(0x73, 0x73, 0x73) },</a>
<a name="ln8151">  { &quot;Grey46&quot;, RGB_(0x75, 0x75, 0x75) },</a>
<a name="ln8152">  { &quot;Grey47&quot;, RGB_(0x78, 0x78, 0x78) },</a>
<a name="ln8153">  { &quot;Grey48&quot;, RGB_(0x7a, 0x7a, 0x7a) },</a>
<a name="ln8154">  { &quot;Grey49&quot;, RGB_(0x7d, 0x7d, 0x7d) },</a>
<a name="ln8155">  { &quot;Grey5&quot;, RGB_(0xd, 0xd, 0xd) },</a>
<a name="ln8156">  { &quot;Grey50&quot;, RGB_(0x7f, 0x7f, 0x7f) },</a>
<a name="ln8157">  { &quot;Grey51&quot;, RGB_(0x82, 0x82, 0x82) },</a>
<a name="ln8158">  { &quot;Grey52&quot;, RGB_(0x85, 0x85, 0x85) },</a>
<a name="ln8159">  { &quot;Grey53&quot;, RGB_(0x87, 0x87, 0x87) },</a>
<a name="ln8160">  { &quot;Grey54&quot;, RGB_(0x8a, 0x8a, 0x8a) },</a>
<a name="ln8161">  { &quot;Grey55&quot;, RGB_(0x8c, 0x8c, 0x8c) },</a>
<a name="ln8162">  { &quot;Grey56&quot;, RGB_(0x8f, 0x8f, 0x8f) },</a>
<a name="ln8163">  { &quot;Grey57&quot;, RGB_(0x91, 0x91, 0x91) },</a>
<a name="ln8164">  { &quot;Grey58&quot;, RGB_(0x94, 0x94, 0x94) },</a>
<a name="ln8165">  { &quot;Grey59&quot;, RGB_(0x96, 0x96, 0x96) },</a>
<a name="ln8166">  { &quot;Grey6&quot;, RGB_(0xf, 0xf, 0xf) },</a>
<a name="ln8167">  { &quot;Grey60&quot;, RGB_(0x99, 0x99, 0x99) },</a>
<a name="ln8168">  { &quot;Grey61&quot;, RGB_(0x9c, 0x9c, 0x9c) },</a>
<a name="ln8169">  { &quot;Grey62&quot;, RGB_(0x9e, 0x9e, 0x9e) },</a>
<a name="ln8170">  { &quot;Grey63&quot;, RGB_(0xa1, 0xa1, 0xa1) },</a>
<a name="ln8171">  { &quot;Grey64&quot;, RGB_(0xa3, 0xa3, 0xa3) },</a>
<a name="ln8172">  { &quot;Grey65&quot;, RGB_(0xa6, 0xa6, 0xa6) },</a>
<a name="ln8173">  { &quot;Grey66&quot;, RGB_(0xa8, 0xa8, 0xa8) },</a>
<a name="ln8174">  { &quot;Grey67&quot;, RGB_(0xab, 0xab, 0xab) },</a>
<a name="ln8175">  { &quot;Grey68&quot;, RGB_(0xad, 0xad, 0xad) },</a>
<a name="ln8176">  { &quot;Grey69&quot;, RGB_(0xb0, 0xb0, 0xb0) },</a>
<a name="ln8177">  { &quot;Grey7&quot;, RGB_(0x12, 0x12, 0x12) },</a>
<a name="ln8178">  { &quot;Grey70&quot;, RGB_(0xb3, 0xb3, 0xb3) },</a>
<a name="ln8179">  { &quot;Grey71&quot;, RGB_(0xb5, 0xb5, 0xb5) },</a>
<a name="ln8180">  { &quot;Grey72&quot;, RGB_(0xb8, 0xb8, 0xb8) },</a>
<a name="ln8181">  { &quot;Grey73&quot;, RGB_(0xba, 0xba, 0xba) },</a>
<a name="ln8182">  { &quot;Grey74&quot;, RGB_(0xbd, 0xbd, 0xbd) },</a>
<a name="ln8183">  { &quot;Grey75&quot;, RGB_(0xbf, 0xbf, 0xbf) },</a>
<a name="ln8184">  { &quot;Grey76&quot;, RGB_(0xc2, 0xc2, 0xc2) },</a>
<a name="ln8185">  { &quot;Grey77&quot;, RGB_(0xc4, 0xc4, 0xc4) },</a>
<a name="ln8186">  { &quot;Grey78&quot;, RGB_(0xc7, 0xc7, 0xc7) },</a>
<a name="ln8187">  { &quot;Grey79&quot;, RGB_(0xc9, 0xc9, 0xc9) },</a>
<a name="ln8188">  { &quot;Grey8&quot;, RGB_(0x14, 0x14, 0x14) },</a>
<a name="ln8189">  { &quot;Grey80&quot;, RGB_(0xcc, 0xcc, 0xcc) },</a>
<a name="ln8190">  { &quot;Grey81&quot;, RGB_(0xcf, 0xcf, 0xcf) },</a>
<a name="ln8191">  { &quot;Grey82&quot;, RGB_(0xd1, 0xd1, 0xd1) },</a>
<a name="ln8192">  { &quot;Grey83&quot;, RGB_(0xd4, 0xd4, 0xd4) },</a>
<a name="ln8193">  { &quot;Grey84&quot;, RGB_(0xd6, 0xd6, 0xd6) },</a>
<a name="ln8194">  { &quot;Grey85&quot;, RGB_(0xd9, 0xd9, 0xd9) },</a>
<a name="ln8195">  { &quot;Grey86&quot;, RGB_(0xdb, 0xdb, 0xdb) },</a>
<a name="ln8196">  { &quot;Grey87&quot;, RGB_(0xde, 0xde, 0xde) },</a>
<a name="ln8197">  { &quot;Grey88&quot;, RGB_(0xe0, 0xe0, 0xe0) },</a>
<a name="ln8198">  { &quot;Grey89&quot;, RGB_(0xe3, 0xe3, 0xe3) },</a>
<a name="ln8199">  { &quot;Grey9&quot;, RGB_(0x17, 0x17, 0x17) },</a>
<a name="ln8200">  { &quot;Grey90&quot;, RGB_(0xe5, 0xe5, 0xe5) },</a>
<a name="ln8201">  { &quot;Grey91&quot;, RGB_(0xe8, 0xe8, 0xe8) },</a>
<a name="ln8202">  { &quot;Grey92&quot;, RGB_(0xeb, 0xeb, 0xeb) },</a>
<a name="ln8203">  { &quot;Grey93&quot;, RGB_(0xed, 0xed, 0xed) },</a>
<a name="ln8204">  { &quot;Grey94&quot;, RGB_(0xf0, 0xf0, 0xf0) },</a>
<a name="ln8205">  { &quot;Grey95&quot;, RGB_(0xf2, 0xf2, 0xf2) },</a>
<a name="ln8206">  { &quot;Grey96&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8207">  { &quot;Grey97&quot;, RGB_(0xf7, 0xf7, 0xf7) },</a>
<a name="ln8208">  { &quot;Grey98&quot;, RGB_(0xfa, 0xfa, 0xfa) },</a>
<a name="ln8209">  { &quot;Grey99&quot;, RGB_(0xfc, 0xfc, 0xfc) },</a>
<a name="ln8210">  { &quot;Honeydew&quot;, RGB_(0xf0, 0xff, 0xf0) },</a>
<a name="ln8211">  { &quot;Honeydew1&quot;, RGB_(0xf0, 0xff, 0xf0) },</a>
<a name="ln8212">  { &quot;Honeydew2&quot;, RGB_(0xe0, 0xee, 0xe0) },</a>
<a name="ln8213">  { &quot;Honeydew3&quot;, RGB_(0xc1, 0xcd, 0xc1) },</a>
<a name="ln8214">  { &quot;Honeydew4&quot;, RGB_(0x83, 0x8b, 0x83) },</a>
<a name="ln8215">  { &quot;HotPink&quot;, RGB_(0xff, 0x69, 0xb4) },</a>
<a name="ln8216">  { &quot;HotPink1&quot;, RGB_(0xff, 0x6e, 0xb4) },</a>
<a name="ln8217">  { &quot;HotPink2&quot;, RGB_(0xee, 0x6a, 0xa7) },</a>
<a name="ln8218">  { &quot;HotPink3&quot;, RGB_(0xcd, 0x60, 0x90) },</a>
<a name="ln8219">  { &quot;HotPink4&quot;, RGB_(0x8b, 0x3a, 0x62) },</a>
<a name="ln8220">  { &quot;IndianRed&quot;, RGB_(0xcd, 0x5c, 0x5c) },</a>
<a name="ln8221">  { &quot;IndianRed1&quot;, RGB_(0xff, 0x6a, 0x6a) },</a>
<a name="ln8222">  { &quot;IndianRed2&quot;, RGB_(0xee, 0x63, 0x63) },</a>
<a name="ln8223">  { &quot;IndianRed3&quot;, RGB_(0xcd, 0x55, 0x55) },</a>
<a name="ln8224">  { &quot;IndianRed4&quot;, RGB_(0x8b, 0x3a, 0x3a) },</a>
<a name="ln8225">  { &quot;Indigo&quot;, RGB_(0x4b, 0x00, 0x82) },</a>
<a name="ln8226">  { &quot;Ivory&quot;, RGB_(0xff, 0xff, 0xf0) },</a>
<a name="ln8227">  { &quot;Ivory1&quot;, RGB_(0xff, 0xff, 0xf0) },</a>
<a name="ln8228">  { &quot;Ivory2&quot;, RGB_(0xee, 0xee, 0xe0) },</a>
<a name="ln8229">  { &quot;Ivory3&quot;, RGB_(0xcd, 0xcd, 0xc1) },</a>
<a name="ln8230">  { &quot;Ivory4&quot;, RGB_(0x8b, 0x8b, 0x83) },</a>
<a name="ln8231">  { &quot;Khaki&quot;, RGB_(0xf0, 0xe6, 0x8c) },</a>
<a name="ln8232">  { &quot;Khaki1&quot;, RGB_(0xff, 0xf6, 0x8f) },</a>
<a name="ln8233">  { &quot;Khaki2&quot;, RGB_(0xee, 0xe6, 0x85) },</a>
<a name="ln8234">  { &quot;Khaki3&quot;, RGB_(0xcd, 0xc6, 0x73) },</a>
<a name="ln8235">  { &quot;Khaki4&quot;, RGB_(0x8b, 0x86, 0x4e) },</a>
<a name="ln8236">  { &quot;Lavender&quot;, RGB_(0xe6, 0xe6, 0xfa) },</a>
<a name="ln8237">  { &quot;LavenderBlush&quot;, RGB_(0xff, 0xf0, 0xf5) },</a>
<a name="ln8238">  { &quot;LavenderBlush1&quot;, RGB_(0xff, 0xf0, 0xf5) },</a>
<a name="ln8239">  { &quot;LavenderBlush2&quot;, RGB_(0xee, 0xe0, 0xe5) },</a>
<a name="ln8240">  { &quot;LavenderBlush3&quot;, RGB_(0xcd, 0xc1, 0xc5) },</a>
<a name="ln8241">  { &quot;LavenderBlush4&quot;, RGB_(0x8b, 0x83, 0x86) },</a>
<a name="ln8242">  { &quot;LawnGreen&quot;, RGB_(0x7c, 0xfc, 0x00) },</a>
<a name="ln8243">  { &quot;LemonChiffon&quot;, RGB_(0xff, 0xfa, 0xcd) },</a>
<a name="ln8244">  { &quot;LemonChiffon1&quot;, RGB_(0xff, 0xfa, 0xcd) },</a>
<a name="ln8245">  { &quot;LemonChiffon2&quot;, RGB_(0xee, 0xe9, 0xbf) },</a>
<a name="ln8246">  { &quot;LemonChiffon3&quot;, RGB_(0xcd, 0xc9, 0xa5) },</a>
<a name="ln8247">  { &quot;LemonChiffon4&quot;, RGB_(0x8b, 0x89, 0x70) },</a>
<a name="ln8248">  { &quot;LightBlue&quot;, RGB_(0xad, 0xd8, 0xe6) },</a>
<a name="ln8249">  { &quot;LightBlue1&quot;, RGB_(0xbf, 0xef, 0xff) },</a>
<a name="ln8250">  { &quot;LightBlue2&quot;, RGB_(0xb2, 0xdf, 0xee) },</a>
<a name="ln8251">  { &quot;LightBlue3&quot;, RGB_(0x9a, 0xc0, 0xcd) },</a>
<a name="ln8252">  { &quot;LightBlue4&quot;, RGB_(0x68, 0x83, 0x8b) },</a>
<a name="ln8253">  { &quot;LightCoral&quot;, RGB_(0xf0, 0x80, 0x80) },</a>
<a name="ln8254">  { &quot;LightCyan&quot;, RGB_(0xe0, 0xff, 0xff) },</a>
<a name="ln8255">  { &quot;LightCyan1&quot;, RGB_(0xe0, 0xff, 0xff) },</a>
<a name="ln8256">  { &quot;LightCyan2&quot;, RGB_(0xd1, 0xee, 0xee) },</a>
<a name="ln8257">  { &quot;LightCyan3&quot;, RGB_(0xb4, 0xcd, 0xcd) },</a>
<a name="ln8258">  { &quot;LightCyan4&quot;, RGB_(0x7a, 0x8b, 0x8b) },</a>
<a name="ln8259">  { &quot;LightGoldenrod&quot;, RGB_(0xee, 0xdd, 0x82) },</a>
<a name="ln8260">  { &quot;LightGoldenrod1&quot;, RGB_(0xff, 0xec, 0x8b) },</a>
<a name="ln8261">  { &quot;LightGoldenrod2&quot;, RGB_(0xee, 0xdc, 0x82) },</a>
<a name="ln8262">  { &quot;LightGoldenrod3&quot;, RGB_(0xcd, 0xbe, 0x70) },</a>
<a name="ln8263">  { &quot;LightGoldenrod4&quot;, RGB_(0x8b, 0x81, 0x4c) },</a>
<a name="ln8264">  { &quot;LightGoldenRodYellow&quot;, RGB_(0xfa, 0xfa, 0xd2) },</a>
<a name="ln8265">  { &quot;LightGray&quot;, RGB_(0xd3, 0xd3, 0xd3) },</a>
<a name="ln8266">  { &quot;LightGreen&quot;, RGB_(0x90, 0xee, 0x90) },</a>
<a name="ln8267">  { &quot;LightGrey&quot;, RGB_(0xd3, 0xd3, 0xd3) },</a>
<a name="ln8268">  { &quot;LightMagenta&quot;, RGB_(0xff, 0xbb, 0xff) },</a>
<a name="ln8269">  { &quot;LightPink&quot;, RGB_(0xff, 0xb6, 0xc1) },</a>
<a name="ln8270">  { &quot;LightPink1&quot;, RGB_(0xff, 0xae, 0xb9) },</a>
<a name="ln8271">  { &quot;LightPink2&quot;, RGB_(0xee, 0xa2, 0xad) },</a>
<a name="ln8272">  { &quot;LightPink3&quot;, RGB_(0xcd, 0x8c, 0x95) },</a>
<a name="ln8273">  { &quot;LightPink4&quot;, RGB_(0x8b, 0x5f, 0x65) },</a>
<a name="ln8274">  { &quot;LightRed&quot;, RGB_(0xff, 0xbb, 0xbb) },</a>
<a name="ln8275">  { &quot;LightSalmon&quot;, RGB_(0xff, 0xa0, 0x7a) },</a>
<a name="ln8276">  { &quot;LightSalmon1&quot;, RGB_(0xff, 0xa0, 0x7a) },</a>
<a name="ln8277">  { &quot;LightSalmon2&quot;, RGB_(0xee, 0x95, 0x72) },</a>
<a name="ln8278">  { &quot;LightSalmon3&quot;, RGB_(0xcd, 0x81, 0x62) },</a>
<a name="ln8279">  { &quot;LightSalmon4&quot;, RGB_(0x8b, 0x57, 0x42) },</a>
<a name="ln8280">  { &quot;LightSeaGreen&quot;, RGB_(0x20, 0xb2, 0xaa) },</a>
<a name="ln8281">  { &quot;LightSkyBlue&quot;, RGB_(0x87, 0xce, 0xfa) },</a>
<a name="ln8282">  { &quot;LightSkyBlue1&quot;, RGB_(0xb0, 0xe2, 0xff) },</a>
<a name="ln8283">  { &quot;LightSkyBlue2&quot;, RGB_(0xa4, 0xd3, 0xee) },</a>
<a name="ln8284">  { &quot;LightSkyBlue3&quot;, RGB_(0x8d, 0xb6, 0xcd) },</a>
<a name="ln8285">  { &quot;LightSkyBlue4&quot;, RGB_(0x60, 0x7b, 0x8b) },</a>
<a name="ln8286">  { &quot;LightSlateBlue&quot;, RGB_(0x84, 0x70, 0xff) },</a>
<a name="ln8287">  { &quot;LightSlateGray&quot;, RGB_(0x77, 0x88, 0x99) },</a>
<a name="ln8288">  { &quot;LightSlateGrey&quot;, RGB_(0x77, 0x88, 0x99) },</a>
<a name="ln8289">  { &quot;LightSteelBlue&quot;, RGB_(0xb0, 0xc4, 0xde) },</a>
<a name="ln8290">  { &quot;LightSteelBlue1&quot;, RGB_(0xca, 0xe1, 0xff) },</a>
<a name="ln8291">  { &quot;LightSteelBlue2&quot;, RGB_(0xbc, 0xd2, 0xee) },</a>
<a name="ln8292">  { &quot;LightSteelBlue3&quot;, RGB_(0xa2, 0xb5, 0xcd) },</a>
<a name="ln8293">  { &quot;LightSteelBlue4&quot;, RGB_(0x6e, 0x7b, 0x8b) },</a>
<a name="ln8294">  { &quot;LightYellow&quot;, RGB_(0xff, 0xff, 0xe0) },</a>
<a name="ln8295">  { &quot;LightYellow1&quot;, RGB_(0xff, 0xff, 0xe0) },</a>
<a name="ln8296">  { &quot;LightYellow2&quot;, RGB_(0xee, 0xee, 0xd1) },</a>
<a name="ln8297">  { &quot;LightYellow3&quot;, RGB_(0xcd, 0xcd, 0xb4) },</a>
<a name="ln8298">  { &quot;LightYellow4&quot;, RGB_(0x8b, 0x8b, 0x7a) },</a>
<a name="ln8299">  { &quot;Lime&quot;, RGB_(0x00, 0xff, 0x00) },</a>
<a name="ln8300">  { &quot;LimeGreen&quot;, RGB_(0x32, 0xcd, 0x32) },</a>
<a name="ln8301">  { &quot;Linen&quot;, RGB_(0xfa, 0xf0, 0xe6) },</a>
<a name="ln8302">  { &quot;Magenta&quot;, RGB_(0xff, 0x00, 0xff) },</a>
<a name="ln8303">  { &quot;Magenta1&quot;, RGB_(0xff, 0x0, 0xff) },</a>
<a name="ln8304">  { &quot;Magenta2&quot;, RGB_(0xee, 0x0, 0xee) },</a>
<a name="ln8305">  { &quot;Magenta3&quot;, RGB_(0xcd, 0x0, 0xcd) },</a>
<a name="ln8306">  { &quot;Magenta4&quot;, RGB_(0x8b, 0x0, 0x8b) },</a>
<a name="ln8307">  { &quot;Maroon&quot;, RGB_(0x80, 0x00, 0x00) },</a>
<a name="ln8308">  { &quot;Maroon1&quot;, RGB_(0xff, 0x34, 0xb3) },</a>
<a name="ln8309">  { &quot;Maroon2&quot;, RGB_(0xee, 0x30, 0xa7) },</a>
<a name="ln8310">  { &quot;Maroon3&quot;, RGB_(0xcd, 0x29, 0x90) },</a>
<a name="ln8311">  { &quot;Maroon4&quot;, RGB_(0x8b, 0x1c, 0x62) },</a>
<a name="ln8312">  { &quot;MediumAquamarine&quot;, RGB_(0x66, 0xcd, 0xaa) },</a>
<a name="ln8313">  { &quot;MediumBlue&quot;, RGB_(0x00, 0x00, 0xcd) },</a>
<a name="ln8314">  { &quot;MediumOrchid&quot;, RGB_(0xba, 0x55, 0xd3) },</a>
<a name="ln8315">  { &quot;MediumOrchid1&quot;, RGB_(0xe0, 0x66, 0xff) },</a>
<a name="ln8316">  { &quot;MediumOrchid2&quot;, RGB_(0xd1, 0x5f, 0xee) },</a>
<a name="ln8317">  { &quot;MediumOrchid3&quot;, RGB_(0xb4, 0x52, 0xcd) },</a>
<a name="ln8318">  { &quot;MediumOrchid4&quot;, RGB_(0x7a, 0x37, 0x8b) },</a>
<a name="ln8319">  { &quot;MediumPurple&quot;, RGB_(0x93, 0x70, 0xdb) },</a>
<a name="ln8320">  { &quot;MediumPurple1&quot;, RGB_(0xab, 0x82, 0xff) },</a>
<a name="ln8321">  { &quot;MediumPurple2&quot;, RGB_(0x9f, 0x79, 0xee) },</a>
<a name="ln8322">  { &quot;MediumPurple3&quot;, RGB_(0x89, 0x68, 0xcd) },</a>
<a name="ln8323">  { &quot;MediumPurple4&quot;, RGB_(0x5d, 0x47, 0x8b) },</a>
<a name="ln8324">  { &quot;MediumSeaGreen&quot;, RGB_(0x3c, 0xb3, 0x71) },</a>
<a name="ln8325">  { &quot;MediumSlateBlue&quot;, RGB_(0x7b, 0x68, 0xee) },</a>
<a name="ln8326">  { &quot;MediumSpringGreen&quot;, RGB_(0x00, 0xfa, 0x9a) },</a>
<a name="ln8327">  { &quot;MediumTurquoise&quot;, RGB_(0x48, 0xd1, 0xcc) },</a>
<a name="ln8328">  { &quot;MediumVioletRed&quot;, RGB_(0xc7, 0x15, 0x85) },</a>
<a name="ln8329">  { &quot;MidnightBlue&quot;, RGB_(0x19, 0x19, 0x70) },</a>
<a name="ln8330">  { &quot;MintCream&quot;, RGB_(0xf5, 0xff, 0xfa) },</a>
<a name="ln8331">  { &quot;MistyRose&quot;, RGB_(0xff, 0xe4, 0xe1) },</a>
<a name="ln8332">  { &quot;MistyRose1&quot;, RGB_(0xff, 0xe4, 0xe1) },</a>
<a name="ln8333">  { &quot;MistyRose2&quot;, RGB_(0xee, 0xd5, 0xd2) },</a>
<a name="ln8334">  { &quot;MistyRose3&quot;, RGB_(0xcd, 0xb7, 0xb5) },</a>
<a name="ln8335">  { &quot;MistyRose4&quot;, RGB_(0x8b, 0x7d, 0x7b) },</a>
<a name="ln8336">  { &quot;Moccasin&quot;, RGB_(0xff, 0xe4, 0xb5) },</a>
<a name="ln8337">  { &quot;NavajoWhite&quot;, RGB_(0xff, 0xde, 0xad) },</a>
<a name="ln8338">  { &quot;NavajoWhite1&quot;, RGB_(0xff, 0xde, 0xad) },</a>
<a name="ln8339">  { &quot;NavajoWhite2&quot;, RGB_(0xee, 0xcf, 0xa1) },</a>
<a name="ln8340">  { &quot;NavajoWhite3&quot;, RGB_(0xcd, 0xb3, 0x8b) },</a>
<a name="ln8341">  { &quot;NavajoWhite4&quot;, RGB_(0x8b, 0x79, 0x5e) },</a>
<a name="ln8342">  { &quot;Navy&quot;, RGB_(0x00, 0x00, 0x80) },</a>
<a name="ln8343">  { &quot;NavyBlue&quot;, RGB_(0x0, 0x0, 0x80) },</a>
<a name="ln8344">  { &quot;OldLace&quot;, RGB_(0xfd, 0xf5, 0xe6) },</a>
<a name="ln8345">  { &quot;Olive&quot;, RGB_(0x80, 0x80, 0x00) },</a>
<a name="ln8346">  { &quot;OliveDrab&quot;, RGB_(0x6b, 0x8e, 0x23) },</a>
<a name="ln8347">  { &quot;OliveDrab1&quot;, RGB_(0xc0, 0xff, 0x3e) },</a>
<a name="ln8348">  { &quot;OliveDrab2&quot;, RGB_(0xb3, 0xee, 0x3a) },</a>
<a name="ln8349">  { &quot;OliveDrab3&quot;, RGB_(0x9a, 0xcd, 0x32) },</a>
<a name="ln8350">  { &quot;OliveDrab4&quot;, RGB_(0x69, 0x8b, 0x22) },</a>
<a name="ln8351">  { &quot;Orange&quot;, RGB_(0xff, 0xa5, 0x00) },</a>
<a name="ln8352">  { &quot;Orange1&quot;, RGB_(0xff, 0xa5, 0x0) },</a>
<a name="ln8353">  { &quot;Orange2&quot;, RGB_(0xee, 0x9a, 0x0) },</a>
<a name="ln8354">  { &quot;Orange3&quot;, RGB_(0xcd, 0x85, 0x0) },</a>
<a name="ln8355">  { &quot;Orange4&quot;, RGB_(0x8b, 0x5a, 0x0) },</a>
<a name="ln8356">  { &quot;OrangeRed&quot;, RGB_(0xff, 0x45, 0x00) },</a>
<a name="ln8357">  { &quot;OrangeRed1&quot;, RGB_(0xff, 0x45, 0x0) },</a>
<a name="ln8358">  { &quot;OrangeRed2&quot;, RGB_(0xee, 0x40, 0x0) },</a>
<a name="ln8359">  { &quot;OrangeRed3&quot;, RGB_(0xcd, 0x37, 0x0) },</a>
<a name="ln8360">  { &quot;OrangeRed4&quot;, RGB_(0x8b, 0x25, 0x0) },</a>
<a name="ln8361">  { &quot;Orchid&quot;, RGB_(0xda, 0x70, 0xd6) },</a>
<a name="ln8362">  { &quot;Orchid1&quot;, RGB_(0xff, 0x83, 0xfa) },</a>
<a name="ln8363">  { &quot;Orchid2&quot;, RGB_(0xee, 0x7a, 0xe9) },</a>
<a name="ln8364">  { &quot;Orchid3&quot;, RGB_(0xcd, 0x69, 0xc9) },</a>
<a name="ln8365">  { &quot;Orchid4&quot;, RGB_(0x8b, 0x47, 0x89) },</a>
<a name="ln8366">  { &quot;PaleGoldenRod&quot;, RGB_(0xee, 0xe8, 0xaa) },</a>
<a name="ln8367">  { &quot;PaleGreen&quot;, RGB_(0x98, 0xfb, 0x98) },</a>
<a name="ln8368">  { &quot;PaleGreen1&quot;, RGB_(0x9a, 0xff, 0x9a) },</a>
<a name="ln8369">  { &quot;PaleGreen2&quot;, RGB_(0x90, 0xee, 0x90) },</a>
<a name="ln8370">  { &quot;PaleGreen3&quot;, RGB_(0x7c, 0xcd, 0x7c) },</a>
<a name="ln8371">  { &quot;PaleGreen4&quot;, RGB_(0x54, 0x8b, 0x54) },</a>
<a name="ln8372">  { &quot;PaleTurquoise&quot;, RGB_(0xaf, 0xee, 0xee) },</a>
<a name="ln8373">  { &quot;PaleTurquoise1&quot;, RGB_(0xbb, 0xff, 0xff) },</a>
<a name="ln8374">  { &quot;PaleTurquoise2&quot;, RGB_(0xae, 0xee, 0xee) },</a>
<a name="ln8375">  { &quot;PaleTurquoise3&quot;, RGB_(0x96, 0xcd, 0xcd) },</a>
<a name="ln8376">  { &quot;PaleTurquoise4&quot;, RGB_(0x66, 0x8b, 0x8b) },</a>
<a name="ln8377">  { &quot;PaleVioletRed&quot;, RGB_(0xdb, 0x70, 0x93) },</a>
<a name="ln8378">  { &quot;PaleVioletRed1&quot;, RGB_(0xff, 0x82, 0xab) },</a>
<a name="ln8379">  { &quot;PaleVioletRed2&quot;, RGB_(0xee, 0x79, 0x9f) },</a>
<a name="ln8380">  { &quot;PaleVioletRed3&quot;, RGB_(0xcd, 0x68, 0x89) },</a>
<a name="ln8381">  { &quot;PaleVioletRed4&quot;, RGB_(0x8b, 0x47, 0x5d) },</a>
<a name="ln8382">  { &quot;PapayaWhip&quot;, RGB_(0xff, 0xef, 0xd5) },</a>
<a name="ln8383">  { &quot;PeachPuff&quot;, RGB_(0xff, 0xda, 0xb9) },</a>
<a name="ln8384">  { &quot;PeachPuff1&quot;, RGB_(0xff, 0xda, 0xb9) },</a>
<a name="ln8385">  { &quot;PeachPuff2&quot;, RGB_(0xee, 0xcb, 0xad) },</a>
<a name="ln8386">  { &quot;PeachPuff3&quot;, RGB_(0xcd, 0xaf, 0x95) },</a>
<a name="ln8387">  { &quot;PeachPuff4&quot;, RGB_(0x8b, 0x77, 0x65) },</a>
<a name="ln8388">  { &quot;Peru&quot;, RGB_(0xcd, 0x85, 0x3f) },</a>
<a name="ln8389">  { &quot;Pink&quot;, RGB_(0xff, 0xc0, 0xcb) },</a>
<a name="ln8390">  { &quot;Pink1&quot;, RGB_(0xff, 0xb5, 0xc5) },</a>
<a name="ln8391">  { &quot;Pink2&quot;, RGB_(0xee, 0xa9, 0xb8) },</a>
<a name="ln8392">  { &quot;Pink3&quot;, RGB_(0xcd, 0x91, 0x9e) },</a>
<a name="ln8393">  { &quot;Pink4&quot;, RGB_(0x8b, 0x63, 0x6c) },</a>
<a name="ln8394">  { &quot;Plum&quot;, RGB_(0xdd, 0xa0, 0xdd) },</a>
<a name="ln8395">  { &quot;Plum1&quot;, RGB_(0xff, 0xbb, 0xff) },</a>
<a name="ln8396">  { &quot;Plum2&quot;, RGB_(0xee, 0xae, 0xee) },</a>
<a name="ln8397">  { &quot;Plum3&quot;, RGB_(0xcd, 0x96, 0xcd) },</a>
<a name="ln8398">  { &quot;Plum4&quot;, RGB_(0x8b, 0x66, 0x8b) },</a>
<a name="ln8399">  { &quot;PowderBlue&quot;, RGB_(0xb0, 0xe0, 0xe6) },</a>
<a name="ln8400">  { &quot;Purple&quot;, RGB_(0x80, 0x00, 0x80) },</a>
<a name="ln8401">  { &quot;Purple1&quot;, RGB_(0x9b, 0x30, 0xff) },</a>
<a name="ln8402">  { &quot;Purple2&quot;, RGB_(0x91, 0x2c, 0xee) },</a>
<a name="ln8403">  { &quot;Purple3&quot;, RGB_(0x7d, 0x26, 0xcd) },</a>
<a name="ln8404">  { &quot;Purple4&quot;, RGB_(0x55, 0x1a, 0x8b) },</a>
<a name="ln8405">  { &quot;RebeccaPurple&quot;, RGB_(0x66, 0x33, 0x99) },</a>
<a name="ln8406">  { &quot;Red&quot;, RGB_(0xff, 0x00, 0x00) },</a>
<a name="ln8407">  { &quot;Red1&quot;, RGB_(0xff, 0x0, 0x0) },</a>
<a name="ln8408">  { &quot;Red2&quot;, RGB_(0xee, 0x0, 0x0) },</a>
<a name="ln8409">  { &quot;Red3&quot;, RGB_(0xcd, 0x0, 0x0) },</a>
<a name="ln8410">  { &quot;Red4&quot;, RGB_(0x8b, 0x0, 0x0) },</a>
<a name="ln8411">  { &quot;RosyBrown&quot;, RGB_(0xbc, 0x8f, 0x8f) },</a>
<a name="ln8412">  { &quot;RosyBrown1&quot;, RGB_(0xff, 0xc1, 0xc1) },</a>
<a name="ln8413">  { &quot;RosyBrown2&quot;, RGB_(0xee, 0xb4, 0xb4) },</a>
<a name="ln8414">  { &quot;RosyBrown3&quot;, RGB_(0xcd, 0x9b, 0x9b) },</a>
<a name="ln8415">  { &quot;RosyBrown4&quot;, RGB_(0x8b, 0x69, 0x69) },</a>
<a name="ln8416">  { &quot;RoyalBlue&quot;, RGB_(0x41, 0x69, 0xe1) },</a>
<a name="ln8417">  { &quot;RoyalBlue1&quot;, RGB_(0x48, 0x76, 0xff) },</a>
<a name="ln8418">  { &quot;RoyalBlue2&quot;, RGB_(0x43, 0x6e, 0xee) },</a>
<a name="ln8419">  { &quot;RoyalBlue3&quot;, RGB_(0x3a, 0x5f, 0xcd) },</a>
<a name="ln8420">  { &quot;RoyalBlue4&quot;, RGB_(0x27, 0x40, 0x8b) },</a>
<a name="ln8421">  { &quot;SaddleBrown&quot;, RGB_(0x8b, 0x45, 0x13) },</a>
<a name="ln8422">  { &quot;Salmon&quot;, RGB_(0xfa, 0x80, 0x72) },</a>
<a name="ln8423">  { &quot;Salmon1&quot;, RGB_(0xff, 0x8c, 0x69) },</a>
<a name="ln8424">  { &quot;Salmon2&quot;, RGB_(0xee, 0x82, 0x62) },</a>
<a name="ln8425">  { &quot;Salmon3&quot;, RGB_(0xcd, 0x70, 0x54) },</a>
<a name="ln8426">  { &quot;Salmon4&quot;, RGB_(0x8b, 0x4c, 0x39) },</a>
<a name="ln8427">  { &quot;SandyBrown&quot;, RGB_(0xf4, 0xa4, 0x60) },</a>
<a name="ln8428">  { &quot;SeaGreen&quot;, RGB_(0x2e, 0x8b, 0x57) },</a>
<a name="ln8429">  { &quot;SeaGreen1&quot;, RGB_(0x54, 0xff, 0x9f) },</a>
<a name="ln8430">  { &quot;SeaGreen2&quot;, RGB_(0x4e, 0xee, 0x94) },</a>
<a name="ln8431">  { &quot;SeaGreen3&quot;, RGB_(0x43, 0xcd, 0x80) },</a>
<a name="ln8432">  { &quot;SeaGreen4&quot;, RGB_(0x2e, 0x8b, 0x57) },</a>
<a name="ln8433">  { &quot;SeaShell&quot;, RGB_(0xff, 0xf5, 0xee) },</a>
<a name="ln8434">  { &quot;Seashell1&quot;, RGB_(0xff, 0xf5, 0xee) },</a>
<a name="ln8435">  { &quot;Seashell2&quot;, RGB_(0xee, 0xe5, 0xde) },</a>
<a name="ln8436">  { &quot;Seashell3&quot;, RGB_(0xcd, 0xc5, 0xbf) },</a>
<a name="ln8437">  { &quot;Seashell4&quot;, RGB_(0x8b, 0x86, 0x82) },</a>
<a name="ln8438">  { &quot;Sienna&quot;, RGB_(0xa0, 0x52, 0x2d) },</a>
<a name="ln8439">  { &quot;Sienna1&quot;, RGB_(0xff, 0x82, 0x47) },</a>
<a name="ln8440">  { &quot;Sienna2&quot;, RGB_(0xee, 0x79, 0x42) },</a>
<a name="ln8441">  { &quot;Sienna3&quot;, RGB_(0xcd, 0x68, 0x39) },</a>
<a name="ln8442">  { &quot;Sienna4&quot;, RGB_(0x8b, 0x47, 0x26) },</a>
<a name="ln8443">  { &quot;Silver&quot;, RGB_(0xc0, 0xc0, 0xc0) },</a>
<a name="ln8444">  { &quot;SkyBlue&quot;, RGB_(0x87, 0xce, 0xeb) },</a>
<a name="ln8445">  { &quot;SkyBlue1&quot;, RGB_(0x87, 0xce, 0xff) },</a>
<a name="ln8446">  { &quot;SkyBlue2&quot;, RGB_(0x7e, 0xc0, 0xee) },</a>
<a name="ln8447">  { &quot;SkyBlue3&quot;, RGB_(0x6c, 0xa6, 0xcd) },</a>
<a name="ln8448">  { &quot;SkyBlue4&quot;, RGB_(0x4a, 0x70, 0x8b) },</a>
<a name="ln8449">  { &quot;SlateBlue&quot;, RGB_(0x6a, 0x5a, 0xcd) },</a>
<a name="ln8450">  { &quot;SlateBlue1&quot;, RGB_(0x83, 0x6f, 0xff) },</a>
<a name="ln8451">  { &quot;SlateBlue2&quot;, RGB_(0x7a, 0x67, 0xee) },</a>
<a name="ln8452">  { &quot;SlateBlue3&quot;, RGB_(0x69, 0x59, 0xcd) },</a>
<a name="ln8453">  { &quot;SlateBlue4&quot;, RGB_(0x47, 0x3c, 0x8b) },</a>
<a name="ln8454">  { &quot;SlateGray&quot;, RGB_(0x70, 0x80, 0x90) },</a>
<a name="ln8455">  { &quot;SlateGray1&quot;, RGB_(0xc6, 0xe2, 0xff) },</a>
<a name="ln8456">  { &quot;SlateGray2&quot;, RGB_(0xb9, 0xd3, 0xee) },</a>
<a name="ln8457">  { &quot;SlateGray3&quot;, RGB_(0x9f, 0xb6, 0xcd) },</a>
<a name="ln8458">  { &quot;SlateGray4&quot;, RGB_(0x6c, 0x7b, 0x8b) },</a>
<a name="ln8459">  { &quot;SlateGrey&quot;, RGB_(0x70, 0x80, 0x90) },</a>
<a name="ln8460">  { &quot;Snow&quot;, RGB_(0xff, 0xfa, 0xfa) },</a>
<a name="ln8461">  { &quot;Snow1&quot;, RGB_(0xff, 0xfa, 0xfa) },</a>
<a name="ln8462">  { &quot;Snow2&quot;, RGB_(0xee, 0xe9, 0xe9) },</a>
<a name="ln8463">  { &quot;Snow3&quot;, RGB_(0xcd, 0xc9, 0xc9) },</a>
<a name="ln8464">  { &quot;Snow4&quot;, RGB_(0x8b, 0x89, 0x89) },</a>
<a name="ln8465">  { &quot;SpringGreen&quot;, RGB_(0x00, 0xff, 0x7f) },</a>
<a name="ln8466">  { &quot;SpringGreen1&quot;, RGB_(0x0, 0xff, 0x7f) },</a>
<a name="ln8467">  { &quot;SpringGreen2&quot;, RGB_(0x0, 0xee, 0x76) },</a>
<a name="ln8468">  { &quot;SpringGreen3&quot;, RGB_(0x0, 0xcd, 0x66) },</a>
<a name="ln8469">  { &quot;SpringGreen4&quot;, RGB_(0x0, 0x8b, 0x45) },</a>
<a name="ln8470">  { &quot;SteelBlue&quot;, RGB_(0x46, 0x82, 0xb4) },</a>
<a name="ln8471">  { &quot;SteelBlue1&quot;, RGB_(0x63, 0xb8, 0xff) },</a>
<a name="ln8472">  { &quot;SteelBlue2&quot;, RGB_(0x5c, 0xac, 0xee) },</a>
<a name="ln8473">  { &quot;SteelBlue3&quot;, RGB_(0x4f, 0x94, 0xcd) },</a>
<a name="ln8474">  { &quot;SteelBlue4&quot;, RGB_(0x36, 0x64, 0x8b) },</a>
<a name="ln8475">  { &quot;Tan&quot;, RGB_(0xd2, 0xb4, 0x8c) },</a>
<a name="ln8476">  { &quot;Tan1&quot;, RGB_(0xff, 0xa5, 0x4f) },</a>
<a name="ln8477">  { &quot;Tan2&quot;, RGB_(0xee, 0x9a, 0x49) },</a>
<a name="ln8478">  { &quot;Tan3&quot;, RGB_(0xcd, 0x85, 0x3f) },</a>
<a name="ln8479">  { &quot;Tan4&quot;, RGB_(0x8b, 0x5a, 0x2b) },</a>
<a name="ln8480">  { &quot;Teal&quot;, RGB_(0x00, 0x80, 0x80) },</a>
<a name="ln8481">  { &quot;Thistle&quot;, RGB_(0xd8, 0xbf, 0xd8) },</a>
<a name="ln8482">  { &quot;Thistle1&quot;, RGB_(0xff, 0xe1, 0xff) },</a>
<a name="ln8483">  { &quot;Thistle2&quot;, RGB_(0xee, 0xd2, 0xee) },</a>
<a name="ln8484">  { &quot;Thistle3&quot;, RGB_(0xcd, 0xb5, 0xcd) },</a>
<a name="ln8485">  { &quot;Thistle4&quot;, RGB_(0x8b, 0x7b, 0x8b) },</a>
<a name="ln8486">  { &quot;Tomato&quot;, RGB_(0xff, 0x63, 0x47) },</a>
<a name="ln8487">  { &quot;Tomato1&quot;, RGB_(0xff, 0x63, 0x47) },</a>
<a name="ln8488">  { &quot;Tomato2&quot;, RGB_(0xee, 0x5c, 0x42) },</a>
<a name="ln8489">  { &quot;Tomato3&quot;, RGB_(0xcd, 0x4f, 0x39) },</a>
<a name="ln8490">  { &quot;Tomato4&quot;, RGB_(0x8b, 0x36, 0x26) },</a>
<a name="ln8491">  { &quot;Turquoise&quot;, RGB_(0x40, 0xe0, 0xd0) },</a>
<a name="ln8492">  { &quot;Turquoise1&quot;, RGB_(0x0, 0xf5, 0xff) },</a>
<a name="ln8493">  { &quot;Turquoise2&quot;, RGB_(0x0, 0xe5, 0xee) },</a>
<a name="ln8494">  { &quot;Turquoise3&quot;, RGB_(0x0, 0xc5, 0xcd) },</a>
<a name="ln8495">  { &quot;Turquoise4&quot;, RGB_(0x0, 0x86, 0x8b) },</a>
<a name="ln8496">  { &quot;Violet&quot;, RGB_(0xee, 0x82, 0xee) },</a>
<a name="ln8497">  { &quot;VioletRed&quot;, RGB_(0xd0, 0x20, 0x90) },</a>
<a name="ln8498">  { &quot;VioletRed1&quot;, RGB_(0xff, 0x3e, 0x96) },</a>
<a name="ln8499">  { &quot;VioletRed2&quot;, RGB_(0xee, 0x3a, 0x8c) },</a>
<a name="ln8500">  { &quot;VioletRed3&quot;, RGB_(0xcd, 0x32, 0x78) },</a>
<a name="ln8501">  { &quot;VioletRed4&quot;, RGB_(0x8b, 0x22, 0x52) },</a>
<a name="ln8502">  { &quot;WebGray&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8503">  { &quot;WebGreen&quot;, RGB_(0x0, 0x80, 0x0) },</a>
<a name="ln8504">  { &quot;WebGrey&quot;, RGB_(0x80, 0x80, 0x80) },</a>
<a name="ln8505">  { &quot;WebMaroon&quot;, RGB_(0x80, 0x0, 0x0) },</a>
<a name="ln8506">  { &quot;WebPurple&quot;, RGB_(0x80, 0x0, 0x80) },</a>
<a name="ln8507">  { &quot;Wheat&quot;, RGB_(0xf5, 0xde, 0xb3) },</a>
<a name="ln8508">  { &quot;Wheat1&quot;, RGB_(0xff, 0xe7, 0xba) },</a>
<a name="ln8509">  { &quot;Wheat2&quot;, RGB_(0xee, 0xd8, 0xae) },</a>
<a name="ln8510">  { &quot;Wheat3&quot;, RGB_(0xcd, 0xba, 0x96) },</a>
<a name="ln8511">  { &quot;Wheat4&quot;, RGB_(0x8b, 0x7e, 0x66) },</a>
<a name="ln8512">  { &quot;White&quot;, RGB_(0xff, 0xff, 0xff) },</a>
<a name="ln8513">  { &quot;WhiteSmoke&quot;, RGB_(0xf5, 0xf5, 0xf5) },</a>
<a name="ln8514">  { &quot;X11Gray&quot;, RGB_(0xbe, 0xbe, 0xbe) },</a>
<a name="ln8515">  { &quot;X11Green&quot;, RGB_(0x0, 0xff, 0x0) },</a>
<a name="ln8516">  { &quot;X11Grey&quot;, RGB_(0xbe, 0xbe, 0xbe) },</a>
<a name="ln8517">  { &quot;X11Maroon&quot;, RGB_(0xb0, 0x30, 0x60) },</a>
<a name="ln8518">  { &quot;X11Purple&quot;, RGB_(0xa0, 0x20, 0xf0) },</a>
<a name="ln8519">  { &quot;Yellow&quot;, RGB_(0xff, 0xff, 0x00) },</a>
<a name="ln8520">  { &quot;Yellow1&quot;, RGB_(0xff, 0xff, 0x0) },</a>
<a name="ln8521">  { &quot;Yellow2&quot;, RGB_(0xee, 0xee, 0x0) },</a>
<a name="ln8522">  { &quot;Yellow3&quot;, RGB_(0xcd, 0xcd, 0x0) },</a>
<a name="ln8523">  { &quot;Yellow4&quot;, RGB_(0x8b, 0x8b, 0x0) },</a>
<a name="ln8524">  { &quot;YellowGreen&quot;, RGB_(0x9a, 0xcd, 0x32) },</a>
<a name="ln8525">  { NULL, 0 },</a>
<a name="ln8526">};</a>
<a name="ln8527"> </a>
<a name="ln8528"> </a>
<a name="ln8529">/// Translate to RgbValue if \p name is an hex value (e.g. #XXXXXX),</a>
<a name="ln8530">/// else look into color_name_table to translate a color name to  its</a>
<a name="ln8531">/// hex value</a>
<a name="ln8532">///</a>
<a name="ln8533">/// @param[in] name string value to convert to RGB</a>
<a name="ln8534">/// return the hex value or -1 if could not find a correct value</a>
<a name="ln8535">RgbValue name_to_color(const char *name)</a>
<a name="ln8536">{</a>
<a name="ln8537"> </a>
<a name="ln8538">  if (name[0] == '#' &amp;&amp; isxdigit(name[1]) &amp;&amp; isxdigit(name[2])</a>
<a name="ln8539">      &amp;&amp; isxdigit(name[3]) &amp;&amp; isxdigit(name[4]) &amp;&amp; isxdigit(name[5])</a>
<a name="ln8540">      &amp;&amp; isxdigit(name[6]) &amp;&amp; name[7] == NUL) {</a>
<a name="ln8541">    // rgb hex string</a>
<a name="ln8542">    return strtol((char *)(name + 1), NULL, 16);</a>
<a name="ln8543">  } else if (!STRICMP(name, &quot;bg&quot;) || !STRICMP(name, &quot;background&quot;)) {</a>
<a name="ln8544">    return normal_bg;</a>
<a name="ln8545">  } else if (!STRICMP(name, &quot;fg&quot;) || !STRICMP(name, &quot;foreground&quot;)) {</a>
<a name="ln8546">    return normal_fg;</a>
<a name="ln8547">  }</a>
<a name="ln8548"> </a>
<a name="ln8549">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln8550">    if (!STRICMP(name, color_name_table[i].name)) {</a>
<a name="ln8551">      return color_name_table[i].color;</a>
<a name="ln8552">    }</a>
<a name="ln8553">  }</a>
<a name="ln8554"> </a>
<a name="ln8555">  return -1;</a>
<a name="ln8556">}</a>
<a name="ln8557"> </a>
<a name="ln8558"> </a>
<a name="ln8559">/**************************************</a>
<a name="ln8560">*  End of Highlighting stuff	      *</a>
<a name="ln8561">**************************************/</a>

</code></pre>
<div class="balloon" rel="3363"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'arg_end' should be checked here.</p></div>
<div class="balloon" rel="3548"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'arg_end' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>


<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>typval.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;stdio.h&gt;</a>
<a name="ln5">#include &lt;stddef.h&gt;</a>
<a name="ln6">#include &lt;stdlib.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;nvim/lib/queue.h&quot;</a>
<a name="ln12">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln13">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln14">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln15">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln16">#include &quot;nvim/eval/typval_encode.h&quot;</a>
<a name="ln17">#include &quot;nvim/eval.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln19">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln20">#include &quot;nvim/types.h&quot;</a>
<a name="ln21">#include &quot;nvim/assert.h&quot;</a>
<a name="ln22">#include &quot;nvim/memory.h&quot;</a>
<a name="ln23">#include &quot;nvim/globals.h&quot;</a>
<a name="ln24">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln25">#include &quot;nvim/vim.h&quot;</a>
<a name="ln26">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln27">#include &quot;nvim/pos.h&quot;</a>
<a name="ln28">#include &quot;nvim/charset.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln31">#include &quot;nvim/macros.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/message.h&quot;</a>
<a name="ln34">// TODO(ZyX-I): Move line_breakcheck out of misc1</a>
<a name="ln35">#include &quot;nvim/misc1.h&quot;  // For line_breakcheck</a>
<a name="ln36">#include &quot;nvim/os/fileio.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln39"># include &quot;eval/typval.c.generated.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">bool tv_in_free_unref_items = false;</a>
<a name="ln43"> </a>
<a name="ln44">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln45"> </a>
<a name="ln46">#define DICT_MAXNEST 100</a>
<a name="ln47"> </a>
<a name="ln48">const char *const tv_empty_string = &quot;&quot;;</a>
<a name="ln49"> </a>
<a name="ln50">//{{{1 Lists</a>
<a name="ln51">//{{{2 List log</a>
<a name="ln52">#ifdef LOG_LIST_ACTIONS</a>
<a name="ln53">ListLog *list_log_first = NULL;</a>
<a name="ln54">ListLog *list_log_last = NULL;</a>
<a name="ln55"> </a>
<a name="ln56">/// Write list log to the given file</a>
<a name="ln57">///</a>
<a name="ln58">/// @param[in]  fname  File to write log to. Will be appended to if already</a>
<a name="ln59">///                    present.</a>
<a name="ln60">void list_write_log(const char *const fname)</a>
<a name="ln61">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln62">{</a>
<a name="ln63">  FileDescriptor fp;</a>
<a name="ln64">  const int fo_ret = file_open(&amp;fp, fname, kFileCreate|kFileAppend, 0600);</a>
<a name="ln65">  if (fo_ret != 0) {</a>
<a name="ln66">    emsgf(_(&quot;E5142: Failed to open file %s: %s&quot;), fname, os_strerror(fo_ret));</a>
<a name="ln67">    return;</a>
<a name="ln68">  }</a>
<a name="ln69">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln70">    for (size_t i = 0; i &lt; chunk-&gt;size; i++) {</a>
<a name="ln71">      char buf[10 + 1 + ((16 + 3) * 3) + (8 + 2) + 2];</a>
<a name="ln72">      //       act  :     hex  &quot; c:&quot;      len &quot;[]&quot; &quot;\n\0&quot;</a>
<a name="ln73">      const ListLogEntry entry = chunk-&gt;entries[i];</a>
<a name="ln74">      const size_t snp_len = (size_t)snprintf(</a>
<a name="ln75">          buf, sizeof(buf),</a>
<a name="ln76">          &quot;%-10.10s: l:%016&quot; PRIxPTR &quot;[%08d] 1:%016&quot; PRIxPTR &quot; 2:%016&quot; PRIxPTR</a>
<a name="ln77">          &quot;\n&quot;,</a>
<a name="ln78">          entry.action, entry.l, entry.len, entry.li1, entry.li2);</a>
<a name="ln79">      assert(snp_len + 1 == sizeof(buf));</a>
<a name="ln80">      const ptrdiff_t fw_ret = file_write(&amp;fp, buf, snp_len);</a>
<a name="ln81">      if (fw_ret != (ptrdiff_t)snp_len) {</a>
<a name="ln82">        assert(fw_ret &lt; 0);</a>
<a name="ln83">        if (i) {</a>
<a name="ln84">          memmove(chunk-&gt;entries, chunk-&gt;entries + i,</a>
<a name="ln85">                  sizeof(chunk-&gt;entries[0]) * (chunk-&gt;size - i));</a>
<a name="ln86">          chunk-&gt;size -= i;</a>
<a name="ln87">        }</a>
<a name="ln88">        emsgf(_(&quot;E5143: Failed to write to file %s: %s&quot;),</a>
<a name="ln89">              fname, os_strerror((int)fw_ret));</a>
<a name="ln90">        return;</a>
<a name="ln91">      }</a>
<a name="ln92">    }</a>
<a name="ln93">    list_log_first = chunk-&gt;next;</a>
<a name="ln94">    xfree(chunk);</a>
<a name="ln95">    chunk = list_log_first;</a>
<a name="ln96">  }</a>
<a name="ln97">  const int fc_ret = file_close(&amp;fp, true);</a>
<a name="ln98">  if (fc_ret != 0) {</a>
<a name="ln99">    emsgf(_(&quot;E5144: Failed to close file %s: %s&quot;), fname, os_strerror(fc_ret));</a>
<a name="ln100">  }</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">#ifdef EXITFREE</a>
<a name="ln104">/// Free list log</a>
<a name="ln105">void list_free_log(void)</a>
<a name="ln106">{</a>
<a name="ln107">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln108">    list_log_first = chunk-&gt;next;</a>
<a name="ln109">    xfree(chunk);</a>
<a name="ln110">    chunk = list_log_first;</a>
<a name="ln111">  }</a>
<a name="ln112">}</a>
<a name="ln113">#endif</a>
<a name="ln114">#endif</a>
<a name="ln115">//{{{2 List item</a>
<a name="ln116"> </a>
<a name="ln117">/// Allocate a list item</a>
<a name="ln118">///</a>
<a name="ln119">/// @warning Allocated item is not initialized, do not forget to initialize it</a>
<a name="ln120">///          and specifically set lv_lock.</a>
<a name="ln121">///</a>
<a name="ln122">/// @return [allocated] new list item.</a>
<a name="ln123">static listitem_T *tv_list_item_alloc(void)</a>
<a name="ln124">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC</a>
<a name="ln125">{</a>
<a name="ln126">  return xmalloc(sizeof(listitem_T));</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/// Remove a list item from a List and free it</a>
<a name="ln130">///</a>
<a name="ln131">/// Also clears the value.</a>
<a name="ln132">///</a>
<a name="ln133">/// @param[out]  l  List to remove item from.</a>
<a name="ln134">/// @param[in,out]  item  Item to remove.</a>
<a name="ln135">///</a>
<a name="ln136">/// @return Pointer to the list item just after removed one, NULL if removed</a>
<a name="ln137">///         item was the last one.</a>
<a name="ln138">listitem_T *tv_list_item_remove(list_T *const l, listitem_T *const item)</a>
<a name="ln139">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln140">{</a>
<a name="ln141">  listitem_T *const next_item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln142">  tv_list_drop_items(l, item, item);</a>
<a name="ln143">  tv_clear(TV_LIST_ITEM_TV(item));</a>
<a name="ln144">  xfree(item);</a>
<a name="ln145">  return next_item;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">//{{{2 List watchers</a>
<a name="ln149"> </a>
<a name="ln150">/// Add a watcher to a list</a>
<a name="ln151">///</a>
<a name="ln152">/// @param[out]  l  List to add watcher to.</a>
<a name="ln153">/// @param[in]  lw  Watcher to add.</a>
<a name="ln154">void tv_list_watch_add(list_T *const l, listwatch_T *const lw)</a>
<a name="ln155">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln156">{</a>
<a name="ln157">  lw-&gt;lw_next = l-&gt;lv_watch;</a>
<a name="ln158">  l-&gt;lv_watch = lw;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/// Remove a watcher from a list</a>
<a name="ln162">///</a>
<a name="ln163">/// Does not give a warning if watcher was not found.</a>
<a name="ln164">///</a>
<a name="ln165">/// @param[out]  l  List to remove watcher from.</a>
<a name="ln166">/// @param[in]  lwrem  Watcher to remove.</a>
<a name="ln167">void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)</a>
<a name="ln168">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln169">{</a>
<a name="ln170">  listwatch_T **lwp = &amp;l-&gt;lv_watch;</a>
<a name="ln171">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln172">    if (lw == lwrem) {</a>
<a name="ln173">      *lwp = lw-&gt;lw_next;</a>
<a name="ln174">      break;</a>
<a name="ln175">    }</a>
<a name="ln176">    lwp = &amp;lw-&gt;lw_next;</a>
<a name="ln177">  }</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">/// Advance watchers to the next item</a>
<a name="ln181">///</a>
<a name="ln182">/// Used just before removing an item from a list.</a>
<a name="ln183">///</a>
<a name="ln184">/// @param[out]  l  List from which item is removed.</a>
<a name="ln185">/// @param[in]  item  List item being removed.</a>
<a name="ln186">void tv_list_watch_fix(list_T *const l, const listitem_T *const item)</a>
<a name="ln187">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln188">{</a>
<a name="ln189">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln190">    if (lw-&gt;lw_item == item) {</a>
<a name="ln191">      lw-&gt;lw_item = item-&gt;li_next;</a>
<a name="ln192">    }</a>
<a name="ln193">  }</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">//{{{2 Alloc/free</a>
<a name="ln197"> </a>
<a name="ln198">/// Allocate an empty list</a>
<a name="ln199">///</a>
<a name="ln200">/// Caller should take care of the reference count.</a>
<a name="ln201">///</a>
<a name="ln202">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln203">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln204">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln205">///                  will be allocated in advance. Currently does nothing.</a>
<a name="ln206">///                  @see ListLenSpecials.</a>
<a name="ln207">///</a>
<a name="ln208">/// @return [allocated] new list.</a>
<a name="ln209">list_T *tv_list_alloc(const ptrdiff_t len)</a>
<a name="ln210">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln211">{</a>
<a name="ln212">  list_T *const list = xcalloc(1, sizeof(list_T));</a>
<a name="ln213"> </a>
<a name="ln214">  // Prepend the list to the list of lists for garbage collection.</a>
<a name="ln215">  if (gc_first_list != NULL) {</a>
<a name="ln216">    gc_first_list-&gt;lv_used_prev = list;</a>
<a name="ln217">  }</a>
<a name="ln218">  list-&gt;lv_used_prev = NULL;</a>
<a name="ln219">  list-&gt;lv_used_next = gc_first_list;</a>
<a name="ln220">  gc_first_list = list;</a>
<a name="ln221">  list_log(list, NULL, (void *)(uintptr_t)len, &quot;alloc&quot;);</a>
<a name="ln222">  return list;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">/// Initialize a static list with 10 items</a>
<a name="ln226">///</a>
<a name="ln227">/// @param[out]  sl  Static list to initialize.</a>
<a name="ln228">void tv_list_init_static10(staticList10_T *const sl)</a>
<a name="ln229">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln230">{</a>
<a name="ln231">#define SL_SIZE ARRAY_SIZE(sl-&gt;sl_items)</a>
<a name="ln232">  list_T *const l = &amp;sl-&gt;sl_list;</a>
<a name="ln233"> </a>
<a name="ln234">  memset(sl, 0, sizeof(staticList10_T));</a>
<a name="ln235">  l-&gt;lv_first = &amp;sl-&gt;sl_items[0];</a>
<a name="ln236">  l-&gt;lv_last = &amp;sl-&gt;sl_items[SL_SIZE - 1];</a>
<a name="ln237">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln238">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln239">  sl-&gt;sl_list.lv_len = 10;</a>
<a name="ln240"> </a>
<a name="ln241">  sl-&gt;sl_items[0].li_prev = NULL;</a>
<a name="ln242">  sl-&gt;sl_items[0].li_next = &amp;sl-&gt;sl_items[1];</a>
<a name="ln243">  sl-&gt;sl_items[SL_SIZE - 1].li_prev = &amp;sl-&gt;sl_items[SL_SIZE - 2];</a>
<a name="ln244">  sl-&gt;sl_items[SL_SIZE - 1].li_next = NULL;</a>
<a name="ln245"> </a>
<a name="ln246">  for (size_t i = 1; i &lt; SL_SIZE - 1; i++) {</a>
<a name="ln247">    listitem_T *const li = &amp;sl-&gt;sl_items[i];</a>
<a name="ln248">    li-&gt;li_prev = li - 1;</a>
<a name="ln249">    li-&gt;li_next = li + 1;</a>
<a name="ln250">  }</a>
<a name="ln251">  list_log((const list_T *)sl, &amp;sl-&gt;sl_items[0], &amp;sl-&gt;sl_items[SL_SIZE - 1],</a>
<a name="ln252">           &quot;s10init&quot;);</a>
<a name="ln253">#undef SL_SIZE</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">/// Initialize static list with undefined number of elements</a>
<a name="ln257">///</a>
<a name="ln258">/// @param[out]  l  List to initialize.</a>
<a name="ln259">void tv_list_init_static(list_T *const l)</a>
<a name="ln260">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln261">{</a>
<a name="ln262">  memset(l, 0, sizeof(*l));</a>
<a name="ln263">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln264">  list_log(l, NULL, NULL, &quot;sinit&quot;);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/// Free items contained in a list</a>
<a name="ln268">///</a>
<a name="ln269">/// @param[in,out]  l  List to clear.</a>
<a name="ln270">void tv_list_free_contents(list_T *const l)</a>
<a name="ln271">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln272">{</a>
<a name="ln273">  list_log(l, NULL, NULL, &quot;freecont&quot;);</a>
<a name="ln274">  for (listitem_T *item = l-&gt;lv_first; item != NULL; item = l-&gt;lv_first) {</a>
<a name="ln275">    // Remove the item before deleting it.</a>
<a name="ln276">    l-&gt;lv_first = item-&gt;li_next;</a>
<a name="ln277">    tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln278">    xfree(item);</a>
<a name="ln279">  }</a>
<a name="ln280">  l-&gt;lv_len = 0;</a>
<a name="ln281">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln282">  l-&gt;lv_last = NULL;</a>
<a name="ln283">  assert(l-&gt;lv_watch == NULL);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/// Free a list itself, ignoring items it contains</a>
<a name="ln287">///</a>
<a name="ln288">/// Ignores the reference count.</a>
<a name="ln289">///</a>
<a name="ln290">/// @param[in,out]  l  List to free.</a>
<a name="ln291">void tv_list_free_list(list_T *const l)</a>
<a name="ln292">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln293">{</a>
<a name="ln294">  // Remove the list from the list of lists for garbage collection.</a>
<a name="ln295">  if (l-&gt;lv_used_prev == NULL) {</a>
<a name="ln296">    gc_first_list = l-&gt;lv_used_next;</a>
<a name="ln297">  } else {</a>
<a name="ln298">    l-&gt;lv_used_prev-&gt;lv_used_next = l-&gt;lv_used_next;</a>
<a name="ln299">  }</a>
<a name="ln300">  if (l-&gt;lv_used_next != NULL) {</a>
<a name="ln301">    l-&gt;lv_used_next-&gt;lv_used_prev = l-&gt;lv_used_prev;</a>
<a name="ln302">  }</a>
<a name="ln303">  list_log(l, NULL, NULL, &quot;freelist&quot;);</a>
<a name="ln304"> </a>
<a name="ln305">  nlua_free_typval_list(l);</a>
<a name="ln306">  xfree(l);</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">/// Free a list, including all items it points to</a>
<a name="ln310">///</a>
<a name="ln311">/// Ignores the reference count. Does not do anything if</a>
<a name="ln312">/// tv_in_free_unref_items is true.</a>
<a name="ln313">///</a>
<a name="ln314">/// @param[in,out]  l  List to free.</a>
<a name="ln315">void tv_list_free(list_T *const l)</a>
<a name="ln316">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln317">{</a>
<a name="ln318">  if (!tv_in_free_unref_items) {</a>
<a name="ln319">    tv_list_free_contents(l);</a>
<a name="ln320">    tv_list_free_list(l);</a>
<a name="ln321">  }</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">/// Unreference a list</a>
<a name="ln325">///</a>
<a name="ln326">/// Decrements the reference count and frees when it becomes zero or less.</a>
<a name="ln327">///</a>
<a name="ln328">/// @param[in,out]  l  List to unreference.</a>
<a name="ln329">void tv_list_unref(list_T *const l)</a>
<a name="ln330">{</a>
<a name="ln331">  if (l != NULL &amp;&amp; --l-&gt;lv_refcount &lt;= 0) {</a>
<a name="ln332">    tv_list_free(l);</a>
<a name="ln333">  }</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">//{{{2 Add/remove</a>
<a name="ln337"> </a>
<a name="ln338">/// Remove items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot;</a>
<a name="ln339">///</a>
<a name="ln340">/// @warning Does not free the listitem or the value!</a>
<a name="ln341">///</a>
<a name="ln342">/// @param[out]  l  List to remove from.</a>
<a name="ln343">/// @param[in]  item  First item to remove.</a>
<a name="ln344">/// @param[in]  item2  Last item to remove.</a>
<a name="ln345">void tv_list_drop_items(list_T *const l, listitem_T *const item,</a>
<a name="ln346">                        listitem_T *const item2)</a>
<a name="ln347">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln348">{</a>
<a name="ln349">  list_log(l, item, item2, &quot;drop&quot;);</a>
<a name="ln350">  // Notify watchers.</a>
<a name="ln351">  for (listitem_T *ip = item; ip != item2-&gt;li_next; ip = ip-&gt;li_next) {</a>
<a name="ln352">    l-&gt;lv_len--;</a>
<a name="ln353">    tv_list_watch_fix(l, ip);</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  if (item2-&gt;li_next == NULL) {</a>
<a name="ln357">    l-&gt;lv_last = item-&gt;li_prev;</a>
<a name="ln358">  } else {</a>
<a name="ln359">    item2-&gt;li_next-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln360">  }</a>
<a name="ln361">  if (item-&gt;li_prev == NULL) {</a>
<a name="ln362">    l-&gt;lv_first = item2-&gt;li_next;</a>
<a name="ln363">  } else {</a>
<a name="ln364">    item-&gt;li_prev-&gt;li_next = item2-&gt;li_next;</a>
<a name="ln365">  }</a>
<a name="ln366">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln367">  list_log(l, l-&gt;lv_first, l-&gt;lv_last, &quot;afterdrop&quot;);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">/// Like tv_list_drop_items, but also frees all removed items</a>
<a name="ln371">void tv_list_remove_items(list_T *const l, listitem_T *const item,</a>
<a name="ln372">                          listitem_T *const item2)</a>
<a name="ln373">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln374">{</a>
<a name="ln375">  list_log(l, item, item2, &quot;remove&quot;);</a>
<a name="ln376">  tv_list_drop_items(l, item, item2);</a>
<a name="ln377">  for (listitem_T *li = item;;) {</a>
<a name="ln378">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln379">    listitem_T *const nli = li-&gt;li_next;</a>
<a name="ln380">    xfree(li);</a>
<a name="ln381">    if (li == item2) {</a>
<a name="ln382">      break;</a>
<a name="ln383">    }</a>
<a name="ln384">    li = nli;</a>
<a name="ln385">  }</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">/// Move items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot; to the end of the list &quot;tgt_l&quot;</a>
<a name="ln389">///</a>
<a name="ln390">/// @param[out]  l  List to move from.</a>
<a name="ln391">/// @param[in]  item  First item to move.</a>
<a name="ln392">/// @param[in]  item2  Last item to move.</a>
<a name="ln393">/// @param[out]  tgt_l  List to move to.</a>
<a name="ln394">/// @param[in]  cnt  Number of items moved.</a>
<a name="ln395">void tv_list_move_items(list_T *const l, listitem_T *const item,</a>
<a name="ln396">                        listitem_T *const item2, list_T *const tgt_l,</a>
<a name="ln397">                        const int cnt)</a>
<a name="ln398">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln399">{</a>
<a name="ln400">  list_log(l, item, item2, &quot;move&quot;);</a>
<a name="ln401">  tv_list_drop_items(l, item, item2);</a>
<a name="ln402">  item-&gt;li_prev = tgt_l-&gt;lv_last;</a>
<a name="ln403">  item2-&gt;li_next = NULL;</a>
<a name="ln404">  if (tgt_l-&gt;lv_last == NULL) {</a>
<a name="ln405">    tgt_l-&gt;lv_first = item;</a>
<a name="ln406">  } else {</a>
<a name="ln407">    tgt_l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln408">  }</a>
<a name="ln409">  tgt_l-&gt;lv_last = item2;</a>
<a name="ln410">  tgt_l-&gt;lv_len += cnt;</a>
<a name="ln411">  list_log(tgt_l, tgt_l-&gt;lv_first, tgt_l-&gt;lv_last, &quot;movetgt&quot;);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">/// Insert list item</a>
<a name="ln415">///</a>
<a name="ln416">/// @param[out]  l  List to insert to.</a>
<a name="ln417">/// @param[in,out]  ni  Item to insert.</a>
<a name="ln418">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln419">///                   list.</a>
<a name="ln420">void tv_list_insert(list_T *const l, listitem_T *const ni,</a>
<a name="ln421">                    listitem_T *const item)</a>
<a name="ln422">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln423">{</a>
<a name="ln424">  if (item == NULL) {</a>
<a name="ln425">    // Append new item at end of list.</a>
<a name="ln426">    tv_list_append(l, ni);</a>
<a name="ln427">  } else {</a>
<a name="ln428">    // Insert new item before existing item.</a>
<a name="ln429">    ni-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln430">    ni-&gt;li_next = item;</a>
<a name="ln431">    if (item-&gt;li_prev == NULL) {</a>
<a name="ln432">      l-&gt;lv_first = ni;</a>
<a name="ln433">      l-&gt;lv_idx++;</a>
<a name="ln434">    } else {</a>
<a name="ln435">      item-&gt;li_prev-&gt;li_next = ni;</a>
<a name="ln436">      l-&gt;lv_idx_item = NULL;</a>
<a name="ln437">    }</a>
<a name="ln438">    item-&gt;li_prev = ni;</a>
<a name="ln439">    l-&gt;lv_len++;</a>
<a name="ln440">    list_log(l, ni, item, &quot;insert&quot;);</a>
<a name="ln441">  }</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/// Insert VimL value into a list</a>
<a name="ln445">///</a>
<a name="ln446">/// @param[out]  l  List to insert to.</a>
<a name="ln447">/// @param[in,out]  tv  Value to insert. Is copied (@see tv_copy()) to an</a>
<a name="ln448">///                     allocated listitem_T and inserted.</a>
<a name="ln449">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln450">///                   list.</a>
<a name="ln451">void tv_list_insert_tv(list_T *const l, typval_T *const tv,</a>
<a name="ln452">                       listitem_T *const item)</a>
<a name="ln453">{</a>
<a name="ln454">  listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln455"> </a>
<a name="ln456">  tv_copy(tv, &amp;ni-&gt;li_tv);</a>
<a name="ln457">  tv_list_insert(l, ni, item);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/// Append item to the end of list</a>
<a name="ln461">///</a>
<a name="ln462">/// @param[out]  l  List to append to.</a>
<a name="ln463">/// @param[in,out]  item  Item to append.</a>
<a name="ln464">void tv_list_append(list_T *const l, listitem_T *const item)</a>
<a name="ln465">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln466">{</a>
<a name="ln467">  list_log(l, item, NULL, &quot;append&quot;);</a>
<a name="ln468">  if (l-&gt;lv_last == NULL) {</a>
<a name="ln469">    // empty list</a>
<a name="ln470">    l-&gt;lv_first = item;</a>
<a name="ln471">    l-&gt;lv_last = item;</a>
<a name="ln472">    item-&gt;li_prev = NULL;</a>
<a name="ln473">  } else {</a>
<a name="ln474">    l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln475">    item-&gt;li_prev = l-&gt;lv_last;</a>
<a name="ln476">    l-&gt;lv_last = item;</a>
<a name="ln477">  }</a>
<a name="ln478">  l-&gt;lv_len++;</a>
<a name="ln479">  item-&gt;li_next = NULL;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/// Append VimL value to the end of list</a>
<a name="ln483">///</a>
<a name="ln484">/// @param[out]  l  List to append to.</a>
<a name="ln485">/// @param[in,out]  tv  Value to append. Is copied (@see tv_copy()) to an</a>
<a name="ln486">///                     allocated listitem_T.</a>
<a name="ln487">void tv_list_append_tv(list_T *const l, typval_T *const tv)</a>
<a name="ln488">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln489">{</a>
<a name="ln490">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln491">  tv_copy(tv, TV_LIST_ITEM_TV(li));</a>
<a name="ln492">  tv_list_append(l, li);</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">/// Like tv_list_append_tv(), but tv is moved to a list</a>
<a name="ln496">///</a>
<a name="ln497">/// This means that it is no longer valid to use contents of the typval_T after</a>
<a name="ln498">/// function exits.</a>
<a name="ln499">void tv_list_append_owned_tv(list_T *const l, typval_T tv)</a>
<a name="ln500">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln501">{</a>
<a name="ln502">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln503">  *TV_LIST_ITEM_TV(li) = tv;</a>
<a name="ln504">  tv_list_append(l, li);</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">/// Append a list to a list as one item</a>
<a name="ln508">///</a>
<a name="ln509">/// @param[out]  l  List to append to.</a>
<a name="ln510">/// @param[in,out]  itemlist  List to append. Reference count is increased.</a>
<a name="ln511">void tv_list_append_list(list_T *const l, list_T *const itemlist)</a>
<a name="ln512">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln513">{</a>
<a name="ln514">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln515">    .v_type = VAR_LIST,</a>
<a name="ln516">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln517">    .vval.v_list = itemlist,</a>
<a name="ln518">  });</a>
<a name="ln519">  tv_list_ref(itemlist);</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">/// Append a dictionary to a list</a>
<a name="ln523">///</a>
<a name="ln524">/// @param[out]  l  List to append to.</a>
<a name="ln525">/// @param[in,out]  dict  Dictionary to append. Reference count is increased.</a>
<a name="ln526">void tv_list_append_dict(list_T *const l, dict_T *const dict)</a>
<a name="ln527">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln528">{</a>
<a name="ln529">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln530">    .v_type = VAR_DICT,</a>
<a name="ln531">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln532">    .vval.v_dict = dict,</a>
<a name="ln533">  });</a>
<a name="ln534">  if (dict != NULL) {</a>
<a name="ln535">    dict-&gt;dv_refcount++;</a>
<a name="ln536">  }</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">/// Make a copy of &quot;str&quot; and append it as an item to list &quot;l&quot;</a>
<a name="ln540">///</a>
<a name="ln541">/// @param[out]  l  List to append to.</a>
<a name="ln542">/// @param[in]  str  String to append.</a>
<a name="ln543">/// @param[in]  len  Length of the appended string. May be -1, in this</a>
<a name="ln544">///                  case string is considered to be usual zero-terminated</a>
<a name="ln545">///                  string or NULL “empty” string.</a>
<a name="ln546">void tv_list_append_string(list_T *const l, const char *const str,</a>
<a name="ln547">                           const ssize_t len)</a>
<a name="ln548">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln549">{</a>
<a name="ln550">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln551">    .v_type = VAR_STRING,</a>
<a name="ln552">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln553">    .vval.v_string = (str == NULL</a>
<a name="ln554">                      ? NULL</a>
<a name="ln555">                      : (len &gt;= 0</a>
<a name="ln556">                         ? xmemdupz(str, (size_t)len)</a>
<a name="ln557">                         : xstrdup(str))),</a>
<a name="ln558">  });</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">/// Append given string to the list</a>
<a name="ln562">///</a>
<a name="ln563">/// Unlike list_append_string this function does not copy the string.</a>
<a name="ln564">///</a>
<a name="ln565">/// @param[out]  l    List to append to.</a>
<a name="ln566">/// @param[in]   str  String to append.</a>
<a name="ln567">void tv_list_append_allocated_string(list_T *const l, char *const str)</a>
<a name="ln568">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln569">{</a>
<a name="ln570">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln571">    .v_type = VAR_STRING,</a>
<a name="ln572">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln573">    .vval.v_string = (char_u *)str,</a>
<a name="ln574">  });</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">/// Append number to the list</a>
<a name="ln578">///</a>
<a name="ln579">/// @param[out]  l  List to append to.</a>
<a name="ln580">/// @param[in]  n  Number to append. Will be recorded in the allocated</a>
<a name="ln581">///                listitem_T.</a>
<a name="ln582">void tv_list_append_number(list_T *const l, const varnumber_T n)</a>
<a name="ln583">{</a>
<a name="ln584">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln585">    .v_type = VAR_NUMBER,</a>
<a name="ln586">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln587">    .vval.v_number = n,</a>
<a name="ln588">  });</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">//{{{2 Operations on the whole list</a>
<a name="ln592"> </a>
<a name="ln593">/// Make a copy of list</a>
<a name="ln594">///</a>
<a name="ln595">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln596">///                   Only used when `deep` is true.</a>
<a name="ln597">/// @param[in]  orig  Original list to copy.</a>
<a name="ln598">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln599">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln600">///</a>
<a name="ln601">/// @return Copied list. May be NULL in case original list is NULL or some</a>
<a name="ln602">///         failure happens. The refcount of the new list is set to 1.</a>
<a name="ln603">list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig,</a>
<a name="ln604">                     const bool deep, const int copyID)</a>
<a name="ln605">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln606">{</a>
<a name="ln607">  if (orig == NULL) {</a>
<a name="ln608">    return NULL;</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  list_T *copy = tv_list_alloc(tv_list_len(orig));</a>
<a name="ln612">  tv_list_ref(copy);</a>
<a name="ln613">  if (copyID != 0) {</a>
<a name="ln614">    // Do this before adding the items, because one of the items may</a>
<a name="ln615">    // refer back to this list.</a>
<a name="ln616">    orig-&gt;lv_copyID = copyID;</a>
<a name="ln617">    orig-&gt;lv_copylist = copy;</a>
<a name="ln618">  }</a>
<a name="ln619">  TV_LIST_ITER(orig, item, {</a>
<a name="ln620">    if (got_int) {</a>
<a name="ln621">      break;</a>
<a name="ln622">    }</a>
<a name="ln623">    listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln624">    if (deep) {</a>
<a name="ln625">      if (var_item_copy(conv, TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni),</a>
<a name="ln626">                        deep, copyID) == FAIL) {</a>
<a name="ln627">        xfree(ni);</a>
<a name="ln628">        goto tv_list_copy_error;</a>
<a name="ln629">      }</a>
<a name="ln630">    } else {</a>
<a name="ln631">      tv_copy(TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni));</a>
<a name="ln632">    }</a>
<a name="ln633">    tv_list_append(copy, ni);</a>
<a name="ln634">  });</a>
<a name="ln635"> </a>
<a name="ln636">  return copy;</a>
<a name="ln637"> </a>
<a name="ln638">tv_list_copy_error:</a>
<a name="ln639">  tv_list_unref(copy);</a>
<a name="ln640">  return NULL;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">/// Flatten &quot;list&quot; in place to depth &quot;maxdepth&quot;.</a>
<a name="ln644">/// Does nothing if &quot;maxdepth&quot; is 0.</a>
<a name="ln645">///</a>
<a name="ln646">/// @param[in,out] list   List to flatten</a>
<a name="ln647">/// @param[in] maxdepth   Maximum depth that will be flattened</a>
<a name="ln648">///</a>
<a name="ln649">/// @return OK or FAIL</a>
<a name="ln650">int tv_list_flatten(list_T *list, long maxdepth)</a>
<a name="ln651">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln652">{</a>
<a name="ln653">  listitem_T *item;</a>
<a name="ln654">  listitem_T *to_free;</a>
<a name="ln655">  int n;</a>
<a name="ln656">  if (maxdepth == 0) {</a>
<a name="ln657">    return OK;</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  n = 0;</a>
<a name="ln661">  item = list-&gt;lv_first;</a>
<a name="ln662">  while (item != NULL) {</a>
<a name="ln663">    fast_breakcheck();</a>
<a name="ln664">    if (got_int) {</a>
<a name="ln665">      return FAIL;</a>
<a name="ln666">    }</a>
<a name="ln667">    if (item-&gt;li_tv.v_type == VAR_LIST) {</a>
<a name="ln668">      listitem_T *next = item-&gt;li_next;</a>
<a name="ln669"> </a>
<a name="ln670">      tv_list_drop_items(list, item, item);</a>
<a name="ln671">      tv_list_extend(list, item-&gt;li_tv.vval.v_list, next);</a>
<a name="ln672">      tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln673">      to_free = item;</a>
<a name="ln674"> </a>
<a name="ln675">      if (item-&gt;li_prev == NULL) {</a>
<a name="ln676">        item = list-&gt;lv_first;</a>
<a name="ln677">      } else {</a>
<a name="ln678">        item = item-&gt;li_prev-&gt;li_next;</a>
<a name="ln679">      }</a>
<a name="ln680">      xfree(to_free);</a>
<a name="ln681"> </a>
<a name="ln682">      if (++n &gt;= maxdepth) {</a>
<a name="ln683">        n = 0;</a>
<a name="ln684">        item = next;</a>
<a name="ln685">      }</a>
<a name="ln686">    } else {</a>
<a name="ln687">      n = 0;</a>
<a name="ln688">      item = item-&gt;li_next;</a>
<a name="ln689">    }</a>
<a name="ln690">  }</a>
<a name="ln691">  return OK;</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">/// Extend first list with the second</a>
<a name="ln695">///</a>
<a name="ln696">/// @param[out]  l1  List to extend.</a>
<a name="ln697">/// @param[in]  l2  List to extend with.</a>
<a name="ln698">/// @param[in]  bef  If not NULL, extends before this item.</a>
<a name="ln699">void tv_list_extend(list_T *const l1, list_T *const l2,</a>
<a name="ln700">                    listitem_T *const bef)</a>
<a name="ln701">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln702">{</a>
<a name="ln703">  int todo = tv_list_len(l2);</a>
<a name="ln704">  listitem_T *const befbef = (bef == NULL ? NULL : bef-&gt;li_prev);</a>
<a name="ln705">  listitem_T *const saved_next = (befbef == NULL ? NULL : befbef-&gt;li_next);</a>
<a name="ln706">  // We also quit the loop when we have inserted the original item count of</a>
<a name="ln707">  // the list, avoid a hang when we extend a list with itself.</a>
<a name="ln708">  for (listitem_T *item = tv_list_first(l2)</a>
<a name="ln709">       ; item != NULL &amp;&amp; todo--</a>
<a name="ln710">       ; item = (item == befbef ? saved_next : item-&gt;li_next)) {</a>
<a name="ln711">    tv_list_insert_tv(l1, TV_LIST_ITEM_TV(item), bef);</a>
<a name="ln712">  }</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">/// Concatenate lists into a new list</a>
<a name="ln716">///</a>
<a name="ln717">/// @param[in]  l1  First list.</a>
<a name="ln718">/// @param[in]  l2  Second list.</a>
<a name="ln719">/// @param[out]  ret_tv  Location where new list is saved.</a>
<a name="ln720">///</a>
<a name="ln721">/// @return OK or FAIL.</a>
<a name="ln722">int tv_list_concat(list_T *const l1, list_T *const l2, typval_T *const tv)</a>
<a name="ln723">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln724">{</a>
<a name="ln725">  list_T *l;</a>
<a name="ln726"> </a>
<a name="ln727">  tv-&gt;v_type = VAR_LIST;</a>
<a name="ln728">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln729">  if (l1 == NULL &amp;&amp; l2 == NULL) {</a>
<a name="ln730">    l = NULL;</a>
<a name="ln731">  } else if (l1 == NULL) {</a>
<a name="ln732">    l = tv_list_copy(NULL, l2, false, 0);</a>
<a name="ln733">  } else {</a>
<a name="ln734">    l = tv_list_copy(NULL, l1, false, 0);</a>
<a name="ln735">    if (l != NULL &amp;&amp; l2 != NULL) {</a>
<a name="ln736">      tv_list_extend(l, l2, NULL);</a>
<a name="ln737">    }</a>
<a name="ln738">  }</a>
<a name="ln739">  if (l == NULL &amp;&amp; !(l1 == NULL &amp;&amp; l2 == NULL)) {</a>
<a name="ln740">    return FAIL;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  tv-&gt;vval.v_list = l;</a>
<a name="ln744">  return OK;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">typedef struct {</a>
<a name="ln748">  char_u *s;</a>
<a name="ln749">  char_u *tofree;</a>
<a name="ln750">} Join;</a>
<a name="ln751"> </a>
<a name="ln752">/// Join list into a string, helper function</a>
<a name="ln753">///</a>
<a name="ln754">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln755">/// @param[in]  l  List to join.</a>
<a name="ln756">/// @param[in]  sep  Used separator.</a>
<a name="ln757">/// @param[in]  join_gap  Garray to keep each list item string.</a>
<a name="ln758">///</a>
<a name="ln759">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln760">static int list_join_inner(garray_T *const gap, list_T *const l,</a>
<a name="ln761">                           const char *const sep, garray_T *const join_gap)</a>
<a name="ln762">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln763">{</a>
<a name="ln764">  size_t sumlen = 0;</a>
<a name="ln765">  bool first = true;</a>
<a name="ln766"> </a>
<a name="ln767">  // Stringify each item in the list.</a>
<a name="ln768">  TV_LIST_ITER(l, item, {</a>
<a name="ln769">    if (got_int) {</a>
<a name="ln770">      break;</a>
<a name="ln771">    }</a>
<a name="ln772">    char *s;</a>
<a name="ln773">    size_t len;</a>
<a name="ln774">    s = encode_tv2echo(TV_LIST_ITEM_TV(item), &amp;len);</a>
<a name="ln775">    if (s == NULL) {</a>
<a name="ln776">      return FAIL;</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">    sumlen += len;</a>
<a name="ln780"> </a>
<a name="ln781">    Join *const p = GA_APPEND_VIA_PTR(Join, join_gap);</a>
<a name="ln782">    p-&gt;tofree = p-&gt;s = (char_u *)s;</a>
<a name="ln783"> </a>
<a name="ln784">    line_breakcheck();</a>
<a name="ln785">  });</a>
<a name="ln786"> </a>
<a name="ln787">  // Allocate result buffer with its total size, avoid re-allocation and</a>
<a name="ln788">  // multiple copy operations.  Add 2 for a tailing ']' and NUL.</a>
<a name="ln789">  if (join_gap-&gt;ga_len &gt;= 2) {</a>
<a name="ln790">    sumlen += strlen(sep) * (size_t)(join_gap-&gt;ga_len - 1);</a>
<a name="ln791">  }</a>
<a name="ln792">  ga_grow(gap, (int)sumlen + 2);</a>
<a name="ln793"> </a>
<a name="ln794">  for (int i = 0; i &lt; join_gap-&gt;ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln795">    if (first) {</a>
<a name="ln796">      first = false;</a>
<a name="ln797">    } else {</a>
<a name="ln798">      ga_concat(gap, (const char_u *)sep);</a>
<a name="ln799">    }</a>
<a name="ln800">    const Join *const p = ((const Join *)join_gap-&gt;ga_data) + i;</a>
<a name="ln801"> </a>
<a name="ln802">    if (p-&gt;s != NULL) {</a>
<a name="ln803">      ga_concat(gap, p-&gt;s);</a>
<a name="ln804">    }</a>
<a name="ln805">    line_breakcheck();</a>
<a name="ln806">  }</a>
<a name="ln807"> </a>
<a name="ln808">  return OK;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">/// Join list into a string using given separator</a>
<a name="ln812">///</a>
<a name="ln813">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln814">/// @param[in]  l  Joined list.</a>
<a name="ln815">/// @param[in]  sep  Separator.</a>
<a name="ln816">///</a>
<a name="ln817">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln818">int tv_list_join(garray_T *const gap, list_T *const l, const char *const sep)</a>
<a name="ln819">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln820">{</a>
<a name="ln821">  if (!tv_list_len(l)) {</a>
<a name="ln822">    return OK;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  garray_T join_ga;</a>
<a name="ln826">  int retval;</a>
<a name="ln827"> </a>
<a name="ln828">  ga_init(&amp;join_ga, (int)sizeof(Join), tv_list_len(l));</a>
<a name="ln829">  retval = list_join_inner(gap, l, sep, &amp;join_ga);</a>
<a name="ln830"> </a>
<a name="ln831">#define FREE_JOIN_TOFREE(join) xfree((join)-&gt;tofree)</a>
<a name="ln832">  GA_DEEP_CLEAR(&amp;join_ga, Join, FREE_JOIN_TOFREE);</a>
<a name="ln833">#undef FREE_JOIN_TOFREE</a>
<a name="ln834"> </a>
<a name="ln835">  return retval;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">/// Chech whether two lists are equal</a>
<a name="ln839">///</a>
<a name="ln840">/// @param[in]  l1  First list to compare.</a>
<a name="ln841">/// @param[in]  l2  Second list to compare.</a>
<a name="ln842">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln843">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln844">///</a>
<a name="ln845">/// @return True if lists are equal, false otherwise.</a>
<a name="ln846">bool tv_list_equal(list_T *const l1, list_T *const l2, const bool ic,</a>
<a name="ln847">                   const bool recursive)</a>
<a name="ln848">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln849">{</a>
<a name="ln850">  if (l1 == l2) {</a>
<a name="ln851">    return true;</a>
<a name="ln852">  }</a>
<a name="ln853">  if (tv_list_len(l1) != tv_list_len(l2)) {</a>
<a name="ln854">    return false;</a>
<a name="ln855">  }</a>
<a name="ln856">  if (tv_list_len(l1) == 0) {</a>
<a name="ln857">    // empty and NULL list are considered equal</a>
<a name="ln858">    return true;</a>
<a name="ln859">  }</a>
<a name="ln860">  if (l1 == NULL || l2 == NULL) {</a>
<a name="ln861">    return false;</a>
<a name="ln862">  }</a>
<a name="ln863"> </a>
<a name="ln864">  listitem_T *item1 = tv_list_first(l1);</a>
<a name="ln865">  listitem_T *item2 = tv_list_first(l2);</a>
<a name="ln866">  for (; item1 != NULL &amp;&amp; item2 != NULL</a>
<a name="ln867">       ; (item1 = TV_LIST_ITEM_NEXT(l1, item1),</a>
<a name="ln868">          item2 = TV_LIST_ITEM_NEXT(l2, item2))) {</a>
<a name="ln869">    if (!tv_equal(TV_LIST_ITEM_TV(item1), TV_LIST_ITEM_TV(item2), ic,</a>
<a name="ln870">                  recursive)) {</a>
<a name="ln871">      return false;</a>
<a name="ln872">    }</a>
<a name="ln873">  }</a>
<a name="ln874">  assert(item1 == NULL &amp;&amp; item2 == NULL);</a>
<a name="ln875">  return true;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">/// Reverse list in-place</a>
<a name="ln879">///</a>
<a name="ln880">/// @param[in,out]  l  List to reverse.</a>
<a name="ln881">void tv_list_reverse(list_T *const l)</a>
<a name="ln882">{</a>
<a name="ln883">  if (tv_list_len(l) &lt;= 1) {</a>
<a name="ln884">    return;</a>
<a name="ln885">  }</a>
<a name="ln886">  list_log(l, NULL, NULL, &quot;reverse&quot;);</a>
<a name="ln887">#define SWAP(a, b) \</a>
<a name="ln888">  do { \</a>
<a name="ln889">    tmp = a; \</a>
<a name="ln890">    a = b; \</a>
<a name="ln891">    b = tmp; \</a>
<a name="ln892">  } while (0)</a>
<a name="ln893">  listitem_T *tmp;</a>
<a name="ln894"> </a>
<a name="ln895">  SWAP(l-&gt;lv_first, l-&gt;lv_last);</a>
<a name="ln896">  for (listitem_T *li = l-&gt;lv_first; li != NULL; li = li-&gt;li_next) {</a>
<a name="ln897">    SWAP(li-&gt;li_next, li-&gt;li_prev);</a>
<a name="ln898">  }</a>
<a name="ln899">#undef SWAP</a>
<a name="ln900"> </a>
<a name="ln901">  l-&gt;lv_idx = l-&gt;lv_len - l-&gt;lv_idx - 1;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">// FIXME Add unit tests for tv_list_item_sort().</a>
<a name="ln905"> </a>
<a name="ln906">/// Sort list using libc qsort</a>
<a name="ln907">///</a>
<a name="ln908">/// @param[in,out]  l  List to sort, will be sorted in-place.</a>
<a name="ln909">/// @param  ptrs  Preallocated array of items to sort, must have at least</a>
<a name="ln910">///               tv_list_len(l) entries. Should not be initialized.</a>
<a name="ln911">/// @param[in]  item_compare_func  Function used to compare list items.</a>
<a name="ln912">/// @param  errp  Location where information about whether error occurred is</a>
<a name="ln913">///               saved by item_compare_func. If boolean there appears to be</a>
<a name="ln914">///               true list will not be modified. Must be initialized to false</a>
<a name="ln915">///               by the caller.</a>
<a name="ln916">void tv_list_item_sort(list_T *const l, ListSortItem *const ptrs,</a>
<a name="ln917">                       const ListSorter item_compare_func,</a>
<a name="ln918">                       bool *errp)</a>
<a name="ln919">  FUNC_ATTR_NONNULL_ARG(3, 4)</a>
<a name="ln920">{</a>
<a name="ln921">  const int len = tv_list_len(l);</a>
<a name="ln922">  if (len &lt;= 1) {</a>
<a name="ln923">    return;</a>
<a name="ln924">  }</a>
<a name="ln925">  list_log(l, NULL, NULL, &quot;sort&quot;);</a>
<a name="ln926">  int i = 0;</a>
<a name="ln927">  TV_LIST_ITER(l, li, {</a>
<a name="ln928">    ptrs[i].item = li;</a>
<a name="ln929">    ptrs[i].idx = i;</a>
<a name="ln930">    i++;</a>
<a name="ln931">  });</a>
<a name="ln932">  // Sort the array with item pointers.</a>
<a name="ln933">  qsort(ptrs, (size_t)len, sizeof(ListSortItem), item_compare_func);</a>
<a name="ln934">  if (!(*errp)) {</a>
<a name="ln935">    // Clear the list and append the items in the sorted order.</a>
<a name="ln936">    l-&gt;lv_first    = NULL;</a>
<a name="ln937">    l-&gt;lv_last     = NULL;</a>
<a name="ln938">    l-&gt;lv_idx_item = NULL;</a>
<a name="ln939">    l-&gt;lv_len      = 0;</a>
<a name="ln940">    for (i = 0; i &lt; len; i++) {</a>
<a name="ln941">      tv_list_append(l, ptrs[i].item);</a>
<a name="ln942">    }</a>
<a name="ln943">  }</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946">//{{{2 Indexing/searching</a>
<a name="ln947"> </a>
<a name="ln948">/// Locate item with a given index in a list and return it</a>
<a name="ln949">///</a>
<a name="ln950">/// @param[in]  l  List to index.</a>
<a name="ln951">/// @param[in]  n  Index. Negative index is counted from the end, -1 is the last</a>
<a name="ln952">///                item.</a>
<a name="ln953">///</a>
<a name="ln954">/// @return Item at the given index or NULL if `n` is out of range.</a>
<a name="ln955">listitem_T *tv_list_find(list_T *const l, int n)</a>
<a name="ln956">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln957">{</a>
<a name="ln958">  STATIC_ASSERT(sizeof(n) == sizeof(l-&gt;lv_idx),</a>
<a name="ln959">                &quot;n and lv_idx sizes do not match&quot;);</a>
<a name="ln960">  if (l == NULL) {</a>
<a name="ln961">    return NULL;</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  n = tv_list_uidx(l, n);</a>
<a name="ln965">  if (n == -1) {</a>
<a name="ln966">    return NULL;</a>
<a name="ln967">  }</a>
<a name="ln968"> </a>
<a name="ln969">  int idx;</a>
<a name="ln970">  listitem_T  *item;</a>
<a name="ln971"> </a>
<a name="ln972">  // When there is a cached index may start search from there.</a>
<a name="ln973">  if (l-&gt;lv_idx_item != NULL) {</a>
<a name="ln974">    if (n &lt; l-&gt;lv_idx / 2) {</a>
<a name="ln975">      // Closest to the start of the list.</a>
<a name="ln976">      item = l-&gt;lv_first;</a>
<a name="ln977">      idx = 0;</a>
<a name="ln978">    } else if (n &gt; (l-&gt;lv_idx + l-&gt;lv_len) / 2) {</a>
<a name="ln979">      // Closest to the end of the list.</a>
<a name="ln980">      item = l-&gt;lv_last;</a>
<a name="ln981">      idx = l-&gt;lv_len - 1;</a>
<a name="ln982">    } else {</a>
<a name="ln983">      // Closest to the cached index.</a>
<a name="ln984">      item = l-&gt;lv_idx_item;</a>
<a name="ln985">      idx = l-&gt;lv_idx;</a>
<a name="ln986">    }</a>
<a name="ln987">  } else {</a>
<a name="ln988">    if (n &lt; l-&gt;lv_len / 2) {</a>
<a name="ln989">      // Closest to the start of the list.</a>
<a name="ln990">      item = l-&gt;lv_first;</a>
<a name="ln991">      idx = 0;</a>
<a name="ln992">    } else {</a>
<a name="ln993">      // Closest to the end of the list.</a>
<a name="ln994">      item = l-&gt;lv_last;</a>
<a name="ln995">      idx = l-&gt;lv_len - 1;</a>
<a name="ln996">    }</a>
<a name="ln997">  }</a>
<a name="ln998"> </a>
<a name="ln999">  while (n &gt; idx) {</a>
<a name="ln1000">    // Search forward.</a>
<a name="ln1001">    item = item-&gt;li_next;</a>
<a name="ln1002">    idx++;</a>
<a name="ln1003">  }</a>
<a name="ln1004">  while (n &lt; idx) {</a>
<a name="ln1005">    // Search backward.</a>
<a name="ln1006">    item = item-&gt;li_prev;</a>
<a name="ln1007">    idx--;</a>
<a name="ln1008">  }</a>
<a name="ln1009"> </a>
<a name="ln1010">  assert(idx == n);</a>
<a name="ln1011">  // Cache the used index.</a>
<a name="ln1012">  l-&gt;lv_idx = idx;</a>
<a name="ln1013">  l-&gt;lv_idx_item = item;</a>
<a name="ln1014">  list_log(l, l-&gt;lv_idx_item, (void *)(uintptr_t)l-&gt;lv_idx, &quot;find&quot;);</a>
<a name="ln1015"> </a>
<a name="ln1016">  return item;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">/// Get list item l[n] as a number</a>
<a name="ln1020">///</a>
<a name="ln1021">/// @param[in]  l  List to index.</a>
<a name="ln1022">/// @param[in]  n  Index in a list.</a>
<a name="ln1023">/// @param[out]  ret_error  Location where 1 will be saved if index was not</a>
<a name="ln1024">///                         found. May be NULL. If everything is OK,</a>
<a name="ln1025">///                         `*ret_error` is not touched.</a>
<a name="ln1026">///</a>
<a name="ln1027">/// @return Integer value at the given index or -1.</a>
<a name="ln1028">varnumber_T tv_list_find_nr(list_T *const l, const int n, bool *const ret_error)</a>
<a name="ln1029">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1030">{</a>
<a name="ln1031">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1032">  if (li == NULL) {</a>
<a name="ln1033">    if (ret_error != NULL) {</a>
<a name="ln1034">      *ret_error = true;</a>
<a name="ln1035">    }</a>
<a name="ln1036">    return -1;</a>
<a name="ln1037">  }</a>
<a name="ln1038">  return tv_get_number_chk(TV_LIST_ITEM_TV(li), ret_error);</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">/// Get list item l[n] as a string</a>
<a name="ln1042">///</a>
<a name="ln1043">/// @param[in]  l  List to index.</a>
<a name="ln1044">/// @param[in]  n  Index in a list.</a>
<a name="ln1045">///</a>
<a name="ln1046">/// @return List item string value or NULL in case of error.</a>
<a name="ln1047">const char *tv_list_find_str(list_T *const l, const int n)</a>
<a name="ln1048">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1049">{</a>
<a name="ln1050">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1051">  if (li == NULL) {</a>
<a name="ln1052">    EMSG2(_(e_listidx), (int64_t)n);</a>
<a name="ln1053">    return NULL;</a>
<a name="ln1054">  }</a>
<a name="ln1055">  return tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">/// Locate item in a list and return its index</a>
<a name="ln1059">///</a>
<a name="ln1060">/// @param[in]  l  List to search.</a>
<a name="ln1061">/// @param[in]  item  Item to search for.</a>
<a name="ln1062">///</a>
<a name="ln1063">/// @return Index of an item or -1 if item is not in the list.</a>
<a name="ln1064">long tv_list_idx_of_item(const list_T *const l, const listitem_T *const item)</a>
<a name="ln1065">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1066">{</a>
<a name="ln1067">  if (l == NULL) {</a>
<a name="ln1068">    return -1;</a>
<a name="ln1069">  }</a>
<a name="ln1070">  int idx = 0;</a>
<a name="ln1071">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1072">    if (li == item) {</a>
<a name="ln1073">      return idx;</a>
<a name="ln1074">    }</a>
<a name="ln1075">    idx++;</a>
<a name="ln1076">  });</a>
<a name="ln1077">  return -1;</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">//{{{1 Dictionaries</a>
<a name="ln1081">//{{{2 Dictionary watchers</a>
<a name="ln1082"> </a>
<a name="ln1083">/// Perform all necessary cleanup for a `DictWatcher` instance</a>
<a name="ln1084">///</a>
<a name="ln1085">/// @param  watcher  Watcher to free.</a>
<a name="ln1086">static void tv_dict_watcher_free(DictWatcher *watcher)</a>
<a name="ln1087">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1088">{</a>
<a name="ln1089">  callback_free(&amp;watcher-&gt;callback);</a>
<a name="ln1090">  xfree(watcher-&gt;key_pattern);</a>
<a name="ln1091">  xfree(watcher);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">/// Add watcher to a dictionary</a>
<a name="ln1095">///</a>
<a name="ln1096">/// @param[in]  dict  Dictionary to add watcher to.</a>
<a name="ln1097">/// @param[in]  key_pattern  Pattern to watch for.</a>
<a name="ln1098">/// @param[in]  key_pattern_len  Key pattern length.</a>
<a name="ln1099">/// @param  callback  Function to be called on events.</a>
<a name="ln1100">void tv_dict_watcher_add(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1101">                         const size_t key_pattern_len, Callback callback)</a>
<a name="ln1102">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1103">{</a>
<a name="ln1104">  if (dict == NULL) {</a>
<a name="ln1105">    return;</a>
<a name="ln1106">  }</a>
<a name="ln1107">  DictWatcher *const watcher = xmalloc(sizeof(DictWatcher));</a>
<a name="ln1108">  watcher-&gt;key_pattern = xmemdupz(key_pattern, key_pattern_len);</a>
<a name="ln1109">  watcher-&gt;key_pattern_len = key_pattern_len;</a>
<a name="ln1110">  watcher-&gt;callback = callback;</a>
<a name="ln1111">  watcher-&gt;busy = false;</a>
<a name="ln1112">  QUEUE_INSERT_TAIL(&amp;dict-&gt;watchers, &amp;watcher-&gt;node);</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115">/// Check whether two callbacks are equal</a>
<a name="ln1116">///</a>
<a name="ln1117">/// @param[in]  cb1  First callback to check.</a>
<a name="ln1118">/// @param[in]  cb2  Second callback to check.</a>
<a name="ln1119">///</a>
<a name="ln1120">/// @return True if they are equal, false otherwise.</a>
<a name="ln1121">bool tv_callback_equal(const Callback *cb1, const Callback *cb2)</a>
<a name="ln1122">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1123">{</a>
<a name="ln1124">  if (cb1-&gt;type != cb2-&gt;type) {</a>
<a name="ln1125">    return false;</a>
<a name="ln1126">  }</a>
<a name="ln1127">  switch (cb1-&gt;type) {</a>
<a name="ln1128">    case kCallbackFuncref: {</a>
<a name="ln1129">      return STRCMP(cb1-&gt;data.funcref, cb2-&gt;data.funcref) == 0;</a>
<a name="ln1130">    }</a>
<a name="ln1131">    case kCallbackPartial: {</a>
<a name="ln1132">      // FIXME: this is inconsistent with tv_equal but is needed for precision</a>
<a name="ln1133">      // maybe change dictwatcheradd to return a watcher id instead?</a>
<a name="ln1134">      return cb1-&gt;data.partial == cb2-&gt;data.partial;</a>
<a name="ln1135">    }</a>
<a name="ln1136">    case kCallbackNone: {</a>
<a name="ln1137">      return true;</a>
<a name="ln1138">    }</a>
<a name="ln1139">  }</a>
<a name="ln1140">  abort();</a>
<a name="ln1141">  return false;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">/// Unref/free callback</a>
<a name="ln1145">void callback_free(Callback *callback)</a>
<a name="ln1146">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1147">{</a>
<a name="ln1148">  switch (callback-&gt;type) {</a>
<a name="ln1149">    case kCallbackFuncref: {</a>
<a name="ln1150">      func_unref(callback-&gt;data.funcref);</a>
<a name="ln1151">      xfree(callback-&gt;data.funcref);</a>
<a name="ln1152">      break;</a>
<a name="ln1153">    }</a>
<a name="ln1154">    case kCallbackPartial: {</a>
<a name="ln1155">      partial_unref(callback-&gt;data.partial);</a>
<a name="ln1156">      break;</a>
<a name="ln1157">    }</a>
<a name="ln1158">    case kCallbackNone: {</a>
<a name="ln1159">      break;</a>
<a name="ln1160">    }</a>
<a name="ln1161">  }</a>
<a name="ln1162">  callback-&gt;type = kCallbackNone;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">/// Remove watcher from a dictionary</a>
<a name="ln1166">///</a>
<a name="ln1167">/// @param  dict  Dictionary to remove watcher from.</a>
<a name="ln1168">/// @param[in]  key_pattern  Pattern to remove watcher for.</a>
<a name="ln1169">/// @param[in]  key_pattern_len  Pattern length.</a>
<a name="ln1170">/// @param  callback  Callback to remove watcher for.</a>
<a name="ln1171">///</a>
<a name="ln1172">/// @return True on success, false if relevant watcher was not found.</a>
<a name="ln1173">bool tv_dict_watcher_remove(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1174">                            const size_t key_pattern_len,</a>
<a name="ln1175">                            Callback callback)</a>
<a name="ln1176">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1177">{</a>
<a name="ln1178">  if (dict == NULL) {</a>
<a name="ln1179">    return false;</a>
<a name="ln1180">  }</a>
<a name="ln1181"> </a>
<a name="ln1182">  QUEUE *w = NULL;</a>
<a name="ln1183">  DictWatcher *watcher = NULL;</a>
<a name="ln1184">  bool matched = false;</a>
<a name="ln1185">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers) {</a>
<a name="ln1186">    watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1187">    if (tv_callback_equal(&amp;watcher-&gt;callback, &amp;callback)</a>
<a name="ln1188">        &amp;&amp; watcher-&gt;key_pattern_len == key_pattern_len</a>
<a name="ln1189">        &amp;&amp; memcmp(watcher-&gt;key_pattern, key_pattern, key_pattern_len) == 0) {</a>
<a name="ln1190">      matched = true;</a>
<a name="ln1191">      break;</a>
<a name="ln1192">    }</a>
<a name="ln1193">  }</a>
<a name="ln1194"> </a>
<a name="ln1195">  if (!matched) {</a>
<a name="ln1196">    return false;</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  QUEUE_REMOVE(w);</a>
<a name="ln1200">  tv_dict_watcher_free(watcher);</a>
<a name="ln1201">  return true;</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/// Test if `key` matches with with `watcher-&gt;key_pattern`</a>
<a name="ln1205">///</a>
<a name="ln1206">/// @param[in]  watcher  Watcher to check key pattern from.</a>
<a name="ln1207">/// @param[in]  key  Key to check.</a>
<a name="ln1208">///</a>
<a name="ln1209">/// @return true if key matches, false otherwise.</a>
<a name="ln1210">static bool tv_dict_watcher_matches(DictWatcher *watcher, const char *const key)</a>
<a name="ln1211">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1212">{</a>
<a name="ln1213">  // For now only allow very simple globbing in key patterns: a '*' at the end</a>
<a name="ln1214">  // of the string means it should match everything up to the '*' instead of the</a>
<a name="ln1215">  // whole string.</a>
<a name="ln1216">  const size_t len = watcher-&gt;key_pattern_len;</a>
<a name="ln1217">  if (len &amp;&amp; watcher-&gt;key_pattern[len - 1] == '*') {</a>
<a name="ln1218">    return strncmp(key, watcher-&gt;key_pattern, len - 1) == 0;</a>
<a name="ln1219">  } else {</a>
<a name="ln1220">    return strcmp(key, watcher-&gt;key_pattern) == 0;</a>
<a name="ln1221">  }</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">/// Send a change notification to all dictionary watchers that match given key</a>
<a name="ln1225">///</a>
<a name="ln1226">/// @param[in]  dict  Dictionary which was modified.</a>
<a name="ln1227">/// @param[in]  key  Key which was modified.</a>
<a name="ln1228">/// @param[in]  newtv  New key value.</a>
<a name="ln1229">/// @param[in]  oldtv  Old key value.</a>
<a name="ln1230">void tv_dict_watcher_notify(dict_T *const dict, const char *const key,</a>
<a name="ln1231">                            typval_T *const newtv, typval_T *const oldtv)</a>
<a name="ln1232">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1233">{</a>
<a name="ln1234">  typval_T argv[3];</a>
<a name="ln1235"> </a>
<a name="ln1236">  argv[0].v_type = VAR_DICT;</a>
<a name="ln1237">  argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln1238">  argv[0].vval.v_dict = dict;</a>
<a name="ln1239">  argv[1].v_type = VAR_STRING;</a>
<a name="ln1240">  argv[1].v_lock = VAR_UNLOCKED;</a>
<a name="ln1241">  argv[1].vval.v_string = (char_u *)xstrdup(key);</a>
<a name="ln1242">  argv[2].v_type = VAR_DICT;</a>
<a name="ln1243">  argv[2].v_lock = VAR_UNLOCKED;</a>
<a name="ln1244">  argv[2].vval.v_dict = tv_dict_alloc();</a>
<a name="ln1245">  argv[2].vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln1246"> </a>
<a name="ln1247">  if (newtv) {</a>
<a name="ln1248">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;new&quot;));</a>
<a name="ln1249">    tv_copy(newtv, &amp;v-&gt;di_tv);</a>
<a name="ln1250">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1251">  }</a>
<a name="ln1252"> </a>
<a name="ln1253">  if (oldtv) {</a>
<a name="ln1254">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;old&quot;));</a>
<a name="ln1255">    tv_copy(oldtv, &amp;v-&gt;di_tv);</a>
<a name="ln1256">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259">  typval_T rettv;</a>
<a name="ln1260"> </a>
<a name="ln1261">  dict-&gt;dv_refcount++;</a>
<a name="ln1262">  QUEUE *w;</a>
<a name="ln1263">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers) {</a>
<a name="ln1264">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1265">    if (!watcher-&gt;busy &amp;&amp; tv_dict_watcher_matches(watcher, key)) {</a>
<a name="ln1266">      rettv = TV_INITIAL_VALUE;</a>
<a name="ln1267">      watcher-&gt;busy = true;</a>
<a name="ln1268">      callback_call(&amp;watcher-&gt;callback, 3, argv, &amp;rettv);</a>
<a name="ln1269">      watcher-&gt;busy = false;</a>
<a name="ln1270">      tv_clear(&amp;rettv);</a>
<a name="ln1271">    }</a>
<a name="ln1272">  }</a>
<a name="ln1273">  tv_dict_unref(dict);</a>
<a name="ln1274"> </a>
<a name="ln1275">  for (size_t i = 1; i &lt; ARRAY_SIZE(argv); i++) {</a>
<a name="ln1276">    tv_clear(argv + i);</a>
<a name="ln1277">  }</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">//{{{2 Dictionary item</a>
<a name="ln1281"> </a>
<a name="ln1282">/// Allocate a dictionary item</a>
<a name="ln1283">///</a>
<a name="ln1284">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1285">///       be initialized.</a>
<a name="ln1286">///</a>
<a name="ln1287">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1288">/// @param[in]  key_len  Key length.</a>
<a name="ln1289">///</a>
<a name="ln1290">/// @return [allocated] new dictionary item.</a>
<a name="ln1291">dictitem_T *tv_dict_item_alloc_len(const char *const key, const size_t key_len)</a>
<a name="ln1292">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1293">  FUNC_ATTR_MALLOC</a>
<a name="ln1294">{</a>
<a name="ln1295">  dictitem_T *const di = xmalloc(offsetof(dictitem_T, di_key) + key_len + 1);</a>
<a name="ln1296">  memcpy(di-&gt;di_key, key, key_len);</a>
<a name="ln1297">  di-&gt;di_key[key_len] = NUL;</a>
<a name="ln1298">  di-&gt;di_flags = DI_FLAGS_ALLOC;</a>
<a name="ln1299">  di-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln1300">  return di;</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">/// Allocate a dictionary item</a>
<a name="ln1304">///</a>
<a name="ln1305">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1306">///       be initialized.</a>
<a name="ln1307">///</a>
<a name="ln1308">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1309">///</a>
<a name="ln1310">/// @return [allocated] new dictionary item.</a>
<a name="ln1311">dictitem_T *tv_dict_item_alloc(const char *const key)</a>
<a name="ln1312">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1313">  FUNC_ATTR_MALLOC</a>
<a name="ln1314">{</a>
<a name="ln1315">  return tv_dict_item_alloc_len(key, strlen(key));</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">/// Free a dictionary item, also clearing the value</a>
<a name="ln1319">///</a>
<a name="ln1320">/// @param  item  Item to free.</a>
<a name="ln1321">void tv_dict_item_free(dictitem_T *const item)</a>
<a name="ln1322">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1323">{</a>
<a name="ln1324">  tv_clear(&amp;item-&gt;di_tv);</a>
<a name="ln1325">  if (item-&gt;di_flags &amp; DI_FLAGS_ALLOC) {</a>
<a name="ln1326">    xfree(item);</a>
<a name="ln1327">  }</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330">/// Make a copy of a dictionary item</a>
<a name="ln1331">///</a>
<a name="ln1332">/// @param[in]  di  Item to copy.</a>
<a name="ln1333">///</a>
<a name="ln1334">/// @return [allocated] new dictionary item.</a>
<a name="ln1335">dictitem_T *tv_dict_item_copy(dictitem_T *const di)</a>
<a name="ln1336">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1337">{</a>
<a name="ln1338">  dictitem_T *const new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln1339">  tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln1340">  return new_di;</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">/// Remove item from dictionary and free it</a>
<a name="ln1344">///</a>
<a name="ln1345">/// @param  dict  Dictionary to remove item from.</a>
<a name="ln1346">/// @param  item  Item to remove.</a>
<a name="ln1347">void tv_dict_item_remove(dict_T *const dict, dictitem_T *const item)</a>
<a name="ln1348">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1349">{</a>
<a name="ln1350">  hashitem_T *const hi = hash_find(&amp;dict-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln1351">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1352">    emsgf(_(e_intern2), &quot;tv_dict_item_remove()&quot;);</a>
<a name="ln1353">  } else {</a>
<a name="ln1354">    hash_remove(&amp;dict-&gt;dv_hashtab, hi);</a>
<a name="ln1355">  }</a>
<a name="ln1356">  tv_dict_item_free(item);</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">//{{{2 Alloc/free</a>
<a name="ln1360"> </a>
<a name="ln1361">/// Allocate an empty dictionary.</a>
<a name="ln1362">/// Caller should take care of the reference count.</a>
<a name="ln1363">///</a>
<a name="ln1364">/// @return [allocated] new dictionary.</a>
<a name="ln1365">dict_T *tv_dict_alloc(void)</a>
<a name="ln1366">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1367">{</a>
<a name="ln1368">  dict_T *const d = xcalloc(1, sizeof(dict_T));</a>
<a name="ln1369"> </a>
<a name="ln1370">  // Add the dict to the list of dicts for garbage collection.</a>
<a name="ln1371">  if (gc_first_dict != NULL) {</a>
<a name="ln1372">    gc_first_dict-&gt;dv_used_prev = d;</a>
<a name="ln1373">  }</a>
<a name="ln1374">  d-&gt;dv_used_next = gc_first_dict;</a>
<a name="ln1375">  d-&gt;dv_used_prev = NULL;</a>
<a name="ln1376">  gc_first_dict = d;</a>
<a name="ln1377"> </a>
<a name="ln1378">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1379">  d-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln1380">  d-&gt;dv_scope = VAR_NO_SCOPE;</a>
<a name="ln1381">  d-&gt;dv_refcount = 0;</a>
<a name="ln1382">  d-&gt;dv_copyID = 0;</a>
<a name="ln1383">  QUEUE_INIT(&amp;d-&gt;watchers);</a>
<a name="ln1384"> </a>
<a name="ln1385">  return d;</a>
<a name="ln1386">}</a>
<a name="ln1387"> </a>
<a name="ln1388">/// Free items contained in a dictionary</a>
<a name="ln1389">///</a>
<a name="ln1390">/// @param[in,out]  d  Dictionary to clear.</a>
<a name="ln1391">void tv_dict_free_contents(dict_T *const d)</a>
<a name="ln1392">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1393">{</a>
<a name="ln1394">  // Lock the hashtab, we don't want it to resize while freeing items.</a>
<a name="ln1395">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1396">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln1397">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln1398">    // Remove the item before deleting it, just in case there is</a>
<a name="ln1399">    // something recursive causing trouble.</a>
<a name="ln1400">    dictitem_T *const di = TV_DICT_HI2DI(hi);</a>
<a name="ln1401">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln1402">    tv_dict_item_free(di);</a>
<a name="ln1403">  });</a>
<a name="ln1404"> </a>
<a name="ln1405">  while (!QUEUE_EMPTY(&amp;d-&gt;watchers)) {</a>
<a name="ln1406">    QUEUE *w = QUEUE_HEAD(&amp;d-&gt;watchers);</a>
<a name="ln1407">    QUEUE_REMOVE(w);</a>
<a name="ln1408">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1409">    tv_dict_watcher_free(watcher);</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">  hash_clear(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1413">  d-&gt;dv_hashtab.ht_locked--;</a>
<a name="ln1414">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417">/// Free a dictionary itself, ignoring items it contains</a>
<a name="ln1418">///</a>
<a name="ln1419">/// Ignores the reference count.</a>
<a name="ln1420">///</a>
<a name="ln1421">/// @param[in,out]  d  Dictionary to free.</a>
<a name="ln1422">void tv_dict_free_dict(dict_T *const d)</a>
<a name="ln1423">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1424">{</a>
<a name="ln1425">  // Remove the dict from the list of dicts for garbage collection.</a>
<a name="ln1426">  if (d-&gt;dv_used_prev == NULL) {</a>
<a name="ln1427">    gc_first_dict = d-&gt;dv_used_next;</a>
<a name="ln1428">  } else {</a>
<a name="ln1429">    d-&gt;dv_used_prev-&gt;dv_used_next = d-&gt;dv_used_next;</a>
<a name="ln1430">  }</a>
<a name="ln1431">  if (d-&gt;dv_used_next != NULL) {</a>
<a name="ln1432">    d-&gt;dv_used_next-&gt;dv_used_prev = d-&gt;dv_used_prev;</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  nlua_free_typval_dict(d);</a>
<a name="ln1436">  xfree(d);</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">/// Free a dictionary, including all items it contains</a>
<a name="ln1440">///</a>
<a name="ln1441">/// Ignores the reference count.</a>
<a name="ln1442">///</a>
<a name="ln1443">/// @param  d  Dictionary to free.</a>
<a name="ln1444">void tv_dict_free(dict_T *const d)</a>
<a name="ln1445">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1446">{</a>
<a name="ln1447">  if (!tv_in_free_unref_items) {</a>
<a name="ln1448">    tv_dict_free_contents(d);</a>
<a name="ln1449">    tv_dict_free_dict(d);</a>
<a name="ln1450">  }</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453"> </a>
<a name="ln1454">/// Unreference a dictionary</a>
<a name="ln1455">///</a>
<a name="ln1456">/// Decrements the reference count and frees dictionary when it becomes zero.</a>
<a name="ln1457">///</a>
<a name="ln1458">/// @param[in]  d  Dictionary to operate on.</a>
<a name="ln1459">void tv_dict_unref(dict_T *const d)</a>
<a name="ln1460">{</a>
<a name="ln1461">  if (d != NULL &amp;&amp; --d-&gt;dv_refcount &lt;= 0) {</a>
<a name="ln1462">    tv_dict_free(d);</a>
<a name="ln1463">  }</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">//{{{2 Indexing/searching</a>
<a name="ln1467"> </a>
<a name="ln1468">/// Find item in dictionary</a>
<a name="ln1469">///</a>
<a name="ln1470">/// @param[in]  d  Dictionary to check.</a>
<a name="ln1471">/// @param[in]  key  Dictionary key.</a>
<a name="ln1472">/// @param[in]  len  Key length. If negative, then strlen(key) is used.</a>
<a name="ln1473">///</a>
<a name="ln1474">/// @return found item or NULL if nothing was found.</a>
<a name="ln1475">dictitem_T *tv_dict_find(const dict_T *const d, const char *const key,</a>
<a name="ln1476">                         const ptrdiff_t len)</a>
<a name="ln1477">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1478">{</a>
<a name="ln1479">  if (d == NULL) {</a>
<a name="ln1480">    return NULL;</a>
<a name="ln1481">  }</a>
<a name="ln1482">  hashitem_T *const hi = (len &lt; 0</a>
<a name="ln1483">                          ? hash_find(&amp;d-&gt;dv_hashtab, (const char_u *)key)</a>
<a name="ln1484">                          : hash_find_len(&amp;d-&gt;dv_hashtab, key, (size_t)len));</a>
<a name="ln1485">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1486">    return NULL;</a>
<a name="ln1487">  }</a>
<a name="ln1488">  return TV_DICT_HI2DI(hi);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">/// Get a typval item from a dictionary and copy it into &quot;rettv&quot;.</a>
<a name="ln1492">///</a>
<a name="ln1493">/// @param[in]  d  Dictionary to check.</a>
<a name="ln1494">/// @param[in]  key  Dictionary key.</a>
<a name="ln1495">/// @param[in]  rettv  Return value.</a>
<a name="ln1496">/// @return OK in case of success or FAIL if nothing was found.</a>
<a name="ln1497">int tv_dict_get_tv(dict_T *d, const char *const key, typval_T *rettv)</a>
<a name="ln1498">{</a>
<a name="ln1499">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1500">  if (di == NULL) {</a>
<a name="ln1501">    return FAIL;</a>
<a name="ln1502">  }</a>
<a name="ln1503"> </a>
<a name="ln1504">  tv_copy(&amp;di-&gt;di_tv, rettv);</a>
<a name="ln1505">  return OK;</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">/// Get a number item from a dictionary</a>
<a name="ln1509">///</a>
<a name="ln1510">/// Returns 0 if the entry does not exist.</a>
<a name="ln1511">///</a>
<a name="ln1512">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1513">/// @param[in]  key  Key to find in dictionary.</a>
<a name="ln1514">///</a>
<a name="ln1515">/// @return Dictionary item.</a>
<a name="ln1516">varnumber_T tv_dict_get_number(const dict_T *const d, const char *const key)</a>
<a name="ln1517">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1518">{</a>
<a name="ln1519">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1520">  if (di == NULL) {</a>
<a name="ln1521">    return 0;</a>
<a name="ln1522">  }</a>
<a name="ln1523">  return tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526">/// Get a string item from a dictionary</a>
<a name="ln1527">///</a>
<a name="ln1528">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1529">/// @param[in]  key  Dictionary key.</a>
<a name="ln1530">/// @param[in]  save  If true, returned string will be placed in the allocated</a>
<a name="ln1531">///                   memory.</a>
<a name="ln1532">///</a>
<a name="ln1533">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln1534">///         string item value otherwise. If returned value is not NULL, it may</a>
<a name="ln1535">///         be allocated depending on `save` argument.</a>
<a name="ln1536">char *tv_dict_get_string(const dict_T *const d, const char *const key,</a>
<a name="ln1537">                         const bool save)</a>
<a name="ln1538">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1539">{</a>
<a name="ln1540">  static char numbuf[NUMBUFLEN];</a>
<a name="ln1541">  const char *const s = tv_dict_get_string_buf(d, key, numbuf);</a>
<a name="ln1542">  if (save &amp;&amp; s != NULL) {</a>
<a name="ln1543">    return xstrdup(s);</a>
<a name="ln1544">  }</a>
<a name="ln1545">  return (char *)s;</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548">/// Get a string item from a dictionary</a>
<a name="ln1549">///</a>
<a name="ln1550">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1551">/// @param[in]  key  Dictionary key.</a>
<a name="ln1552">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln1553">///                     least of #NUMBUFLEN length.</a>
<a name="ln1554">///</a>
<a name="ln1555">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln1556">///         string item value otherwise.</a>
<a name="ln1557">const char *tv_dict_get_string_buf(const dict_T *const d, const char *const key,</a>
<a name="ln1558">                                   char *const numbuf)</a>
<a name="ln1559">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1560">{</a>
<a name="ln1561">  const dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln1562">  if (di == NULL) {</a>
<a name="ln1563">    return NULL;</a>
<a name="ln1564">  }</a>
<a name="ln1565">  return tv_get_string_buf(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">/// Get a string item from a dictionary</a>
<a name="ln1569">///</a>
<a name="ln1570">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln1571">/// @param[in]  key  Dictionary key.</a>
<a name="ln1572">/// @param[in]  key_len  Key length.</a>
<a name="ln1573">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln1574">///                     least of #NUMBUFLEN length.</a>
<a name="ln1575">/// @param[in]  def  Default return when key does not exist.</a>
<a name="ln1576">///</a>
<a name="ln1577">/// @return `def` when key does not exist,</a>
<a name="ln1578">///         NULL in case of type error,</a>
<a name="ln1579">///         string item value in case of success.</a>
<a name="ln1580">const char *tv_dict_get_string_buf_chk(const dict_T *const d,</a>
<a name="ln1581">                                       const char *const key,</a>
<a name="ln1582">                                       const ptrdiff_t key_len,</a>
<a name="ln1583">                                       char *const numbuf,</a>
<a name="ln1584">                                       const char *const def)</a>
<a name="ln1585">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1586">{</a>
<a name="ln1587">  const dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln1588">  if (di == NULL) {</a>
<a name="ln1589">    return def;</a>
<a name="ln1590">  }</a>
<a name="ln1591">  return tv_get_string_buf_chk(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594">/// Get a function from a dictionary</a>
<a name="ln1595">///</a>
<a name="ln1596">/// @param[in]  d  Dictionary to get callback from.</a>
<a name="ln1597">/// @param[in]  key  Dictionary key.</a>
<a name="ln1598">/// @param[in]  key_len  Key length, may be -1 to use strlen().</a>
<a name="ln1599">/// @param[out]  result  The address where a pointer to the wanted callback</a>
<a name="ln1600">///                      will be left.</a>
<a name="ln1601">///</a>
<a name="ln1602">/// @return true/false on success/failure.</a>
<a name="ln1603">bool tv_dict_get_callback(dict_T *const d,</a>
<a name="ln1604">                          const char *const key, const ptrdiff_t key_len,</a>
<a name="ln1605">                          Callback *const result)</a>
<a name="ln1606">  FUNC_ATTR_NONNULL_ARG(2, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1607">{</a>
<a name="ln1608">  result-&gt;type = kCallbackNone;</a>
<a name="ln1609"> </a>
<a name="ln1610">  dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln1611"> </a>
<a name="ln1612">  if (di == NULL) {</a>
<a name="ln1613">    return true;</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  if (!tv_is_func(di-&gt;di_tv) &amp;&amp; di-&gt;di_tv.v_type != VAR_STRING) {</a>
<a name="ln1617">    EMSG(_(&quot;E6000: Argument is not a function or function name&quot;));</a>
<a name="ln1618">    return false;</a>
<a name="ln1619">  }</a>
<a name="ln1620"> </a>
<a name="ln1621">  typval_T tv;</a>
<a name="ln1622">  tv_copy(&amp;di-&gt;di_tv, &amp;tv);</a>
<a name="ln1623">  set_selfdict(&amp;tv, d);</a>
<a name="ln1624">  const bool res = callback_from_typval(result, &amp;tv);</a>
<a name="ln1625">  tv_clear(&amp;tv);</a>
<a name="ln1626">  return res;</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629">//{{{2 dict_add*</a>
<a name="ln1630"> </a>
<a name="ln1631">/// Add item to dictionary</a>
<a name="ln1632">///</a>
<a name="ln1633">/// @param[out]  d  Dictionary to add to.</a>
<a name="ln1634">/// @param[in]  item  Item to add.</a>
<a name="ln1635">///</a>
<a name="ln1636">/// @return FAIL if key already exists.</a>
<a name="ln1637">int tv_dict_add(dict_T *const d, dictitem_T *const item)</a>
<a name="ln1638">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1639">{</a>
<a name="ln1640">  return hash_add(&amp;d-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643">/// Add a list entry to dictionary</a>
<a name="ln1644">///</a>
<a name="ln1645">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1646">/// @param[in]  key  Key to add.</a>
<a name="ln1647">/// @param[in]  key_len  Key length.</a>
<a name="ln1648">/// @param  list  List to add. Will have reference count incremented.</a>
<a name="ln1649">///</a>
<a name="ln1650">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1651">int tv_dict_add_list(dict_T *const d, const char *const key,</a>
<a name="ln1652">                     const size_t key_len, list_T *const list)</a>
<a name="ln1653">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1654">{</a>
<a name="ln1655">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1656"> </a>
<a name="ln1657">  item-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln1658">  item-&gt;di_tv.vval.v_list = list;</a>
<a name="ln1659">  tv_list_ref(list);</a>
<a name="ln1660">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1661">    tv_dict_item_free(item);</a>
<a name="ln1662">    return FAIL;</a>
<a name="ln1663">  }</a>
<a name="ln1664">  return OK;</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">/// Add a typval entry to dictionary.</a>
<a name="ln1668">///</a>
<a name="ln1669">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1670">/// @param[in]  key  Key to add.</a>
<a name="ln1671">/// @param[in]  key_len  Key length.</a>
<a name="ln1672">///</a>
<a name="ln1673">/// @return FAIL if out of memory or key already exists.</a>
<a name="ln1674">int tv_dict_add_tv(dict_T *d, const char *key, const size_t key_len,</a>
<a name="ln1675">                   typval_T *tv)</a>
<a name="ln1676">{</a>
<a name="ln1677">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1678"> </a>
<a name="ln1679">  tv_copy(tv, &amp;item-&gt;di_tv);</a>
<a name="ln1680">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1681">      tv_dict_item_free(item);</a>
<a name="ln1682">      return FAIL;</a>
<a name="ln1683">  }</a>
<a name="ln1684">  return OK;</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">/// Add a dictionary entry to dictionary</a>
<a name="ln1688">///</a>
<a name="ln1689">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1690">/// @param[in]  key  Key to add.</a>
<a name="ln1691">/// @param[in]  key_len  Key length.</a>
<a name="ln1692">/// @param  dict  Dictionary to add. Will have reference count incremented.</a>
<a name="ln1693">///</a>
<a name="ln1694">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1695">int tv_dict_add_dict(dict_T *const d, const char *const key,</a>
<a name="ln1696">                     const size_t key_len, dict_T *const dict)</a>
<a name="ln1697">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1698">{</a>
<a name="ln1699">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1700"> </a>
<a name="ln1701">  item-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln1702">  item-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln1703">  dict-&gt;dv_refcount++;</a>
<a name="ln1704">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1705">    tv_dict_item_free(item);</a>
<a name="ln1706">    return FAIL;</a>
<a name="ln1707">  }</a>
<a name="ln1708">  return OK;</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">/// Add a number entry to dictionary</a>
<a name="ln1712">///</a>
<a name="ln1713">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1714">/// @param[in]  key  Key to add.</a>
<a name="ln1715">/// @param[in]  key_len  Key length.</a>
<a name="ln1716">/// @param[in]  nr  Number to add.</a>
<a name="ln1717">///</a>
<a name="ln1718">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1719">int tv_dict_add_nr(dict_T *const d, const char *const key,</a>
<a name="ln1720">                   const size_t key_len, const varnumber_T nr)</a>
<a name="ln1721">{</a>
<a name="ln1722">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1723"> </a>
<a name="ln1724">  item-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln1725">  item-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln1726">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1727">    tv_dict_item_free(item);</a>
<a name="ln1728">    return FAIL;</a>
<a name="ln1729">  }</a>
<a name="ln1730">  return OK;</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">/// Add a floating point number entry to dictionary</a>
<a name="ln1734">///</a>
<a name="ln1735">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1736">/// @param[in]  key  Key to add.</a>
<a name="ln1737">/// @param[in]  key_len  Key length.</a>
<a name="ln1738">/// @param[in]  nr  Floating point number to add.</a>
<a name="ln1739">///</a>
<a name="ln1740">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1741">int tv_dict_add_float(dict_T *const d, const char *const key,</a>
<a name="ln1742">                      const size_t key_len, const float_T nr)</a>
<a name="ln1743">{</a>
<a name="ln1744">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1745"> </a>
<a name="ln1746">  item-&gt;di_tv.v_type = VAR_FLOAT;</a>
<a name="ln1747">  item-&gt;di_tv.vval.v_float = nr;</a>
<a name="ln1748">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1749">    tv_dict_item_free(item);</a>
<a name="ln1750">    return FAIL;</a>
<a name="ln1751">  }</a>
<a name="ln1752">  return OK;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755">/// Add a boolean entry to dictionary</a>
<a name="ln1756">///</a>
<a name="ln1757">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1758">/// @param[in]  key  Key to add.</a>
<a name="ln1759">/// @param[in]  key_len  Key length.</a>
<a name="ln1760">/// @param[in]  val BoolVarValue to add.</a>
<a name="ln1761">///</a>
<a name="ln1762">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1763">int tv_dict_add_bool(dict_T *const d, const char *const key,</a>
<a name="ln1764">                     const size_t key_len, BoolVarValue val)</a>
<a name="ln1765">{</a>
<a name="ln1766">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1767"> </a>
<a name="ln1768">  item-&gt;di_tv.v_type = VAR_BOOL;</a>
<a name="ln1769">  item-&gt;di_tv.vval.v_bool = val;</a>
<a name="ln1770">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1771">    tv_dict_item_free(item);</a>
<a name="ln1772">    return FAIL;</a>
<a name="ln1773">  }</a>
<a name="ln1774">  return OK;</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">/// Add a string entry to dictionary</a>
<a name="ln1778">///</a>
<a name="ln1779">/// @see tv_dict_add_allocated_str</a>
<a name="ln1780">int tv_dict_add_str(dict_T *const d,</a>
<a name="ln1781">                    const char *const key, const size_t key_len,</a>
<a name="ln1782">                    const char *const val)</a>
<a name="ln1783">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1784">{</a>
<a name="ln1785">  return tv_dict_add_str_len(d, key, key_len, val, -1);</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">/// Add a string entry to dictionary</a>
<a name="ln1789">///</a>
<a name="ln1790">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1791">/// @param[in]  key  Key to add.</a>
<a name="ln1792">/// @param[in]  key_len  Key length.</a>
<a name="ln1793">/// @param[in]  val  String to add. NULL adds empty string.</a>
<a name="ln1794">/// @param[in]  len  Use this many bytes from `val`, or -1 for whole string.</a>
<a name="ln1795">///</a>
<a name="ln1796">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1797">int tv_dict_add_str_len(dict_T *const d,</a>
<a name="ln1798">                        const char *const key, const size_t key_len,</a>
<a name="ln1799">                        const char *const val, int len)</a>
<a name="ln1800">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1801">{</a>
<a name="ln1802">  char *s = NULL;</a>
<a name="ln1803">  if (val != NULL) {</a>
<a name="ln1804">    s = (len &lt; 0) ? xstrdup(val) : xstrndup(val, (size_t)len);</a>
<a name="ln1805">  }</a>
<a name="ln1806">  return tv_dict_add_allocated_str(d, key, key_len, s);</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">/// Add a string entry to dictionary</a>
<a name="ln1810">///</a>
<a name="ln1811">/// Unlike tv_dict_add_str() saves val to the new dictionary item in place of</a>
<a name="ln1812">/// creating a new copy.</a>
<a name="ln1813">///</a>
<a name="ln1814">/// @warning String will be freed even in case addition fails.</a>
<a name="ln1815">///</a>
<a name="ln1816">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln1817">/// @param[in]  key  Key to add.</a>
<a name="ln1818">/// @param[in]  key_len  Key length.</a>
<a name="ln1819">/// @param[in]  val  String to add.</a>
<a name="ln1820">///</a>
<a name="ln1821">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln1822">int tv_dict_add_allocated_str(dict_T *const d,</a>
<a name="ln1823">                              const char *const key, const size_t key_len,</a>
<a name="ln1824">                              char *const val)</a>
<a name="ln1825">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1826">{</a>
<a name="ln1827">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln1828"> </a>
<a name="ln1829">  item-&gt;di_tv.v_type = VAR_STRING;</a>
<a name="ln1830">  item-&gt;di_tv.vval.v_string = (char_u *)val;</a>
<a name="ln1831">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln1832">    tv_dict_item_free(item);</a>
<a name="ln1833">    return FAIL;</a>
<a name="ln1834">  }</a>
<a name="ln1835">  return OK;</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">//{{{2 Operations on the whole dict</a>
<a name="ln1839"> </a>
<a name="ln1840">/// Clear all the keys of a Dictionary. &quot;d&quot; remains a valid empty Dictionary.</a>
<a name="ln1841">///</a>
<a name="ln1842">/// @param  d  The Dictionary to clear</a>
<a name="ln1843">void tv_dict_clear(dict_T *const d)</a>
<a name="ln1844">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1845">{</a>
<a name="ln1846">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1847">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln1848"> </a>
<a name="ln1849">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln1850">    tv_dict_item_free(TV_DICT_HI2DI(hi));</a>
<a name="ln1851">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln1852">  });</a>
<a name="ln1853"> </a>
<a name="ln1854">  hash_unlock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857">/// Extend dictionary with items from another dictionary</a>
<a name="ln1858">///</a>
<a name="ln1859">/// @param  d1  Dictionary to extend.</a>
<a name="ln1860">/// @param[in]  d2  Dictionary to extend with.</a>
<a name="ln1861">/// @param[in]  action  &quot;error&quot;, &quot;force&quot;, &quot;keep&quot;:</a>
<a name="ln1862">///</a>
<a name="ln1863">///                     e*, including &quot;error&quot;: duplicate key gives an error.</a>
<a name="ln1864">///                     f*, including &quot;force&quot;: duplicate d2 keys override d1.</a>
<a name="ln1865">///                     other, including &quot;keep&quot;: duplicate d2 keys ignored.</a>
<a name="ln1866">void tv_dict_extend(dict_T *const d1, dict_T *const d2,</a>
<a name="ln1867">                    const char *const action)</a>
<a name="ln1868">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1869">{</a>
<a name="ln1870">  const bool watched = tv_dict_is_watched(d1);</a>
<a name="ln1871">  const char *const arg_errmsg = _(&quot;extend() argument&quot;);</a>
<a name="ln1872">  const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1873"> </a>
<a name="ln1874">  TV_DICT_ITER(d2, di2, {</a>
<a name="ln1875">    dictitem_T *const di1 = tv_dict_find(d1, (const char *)di2-&gt;di_key, -1);</a>
<a name="ln1876">    if (d1-&gt;dv_scope != VAR_NO_SCOPE) {</a>
<a name="ln1877">      // Disallow replacing a builtin function in l: and g:.</a>
<a name="ln1878">      // Check the key to be valid when adding to any scope.</a>
<a name="ln1879">      if (d1-&gt;dv_scope == VAR_DEF_SCOPE</a>
<a name="ln1880">          &amp;&amp; tv_is_func(di2-&gt;di_tv)</a>
<a name="ln1881">          &amp;&amp; !var_check_func_name((const char *)di2-&gt;di_key, di1 == NULL)) {</a>
<a name="ln1882">        break;</a>
<a name="ln1883">      }</a>
<a name="ln1884">      if (!valid_varname((const char *)di2-&gt;di_key)) {</a>
<a name="ln1885">        break;</a>
<a name="ln1886">      }</a>
<a name="ln1887">    }</a>
<a name="ln1888">    if (di1 == NULL) {</a>
<a name="ln1889">      dictitem_T *const new_di = tv_dict_item_copy(di2);</a>
<a name="ln1890">      if (tv_dict_add(d1, new_di) == FAIL) {</a>
<a name="ln1891">        tv_dict_item_free(new_di);</a>
<a name="ln1892">      } else if (watched) {</a>
<a name="ln1893">        tv_dict_watcher_notify(d1, (const char *)new_di-&gt;di_key, &amp;new_di-&gt;di_tv,</a>
<a name="ln1894">                               NULL);</a>
<a name="ln1895">      }</a>
<a name="ln1896">    } else if (*action == 'e') {</a>
<a name="ln1897">      emsgf(_(&quot;E737: Key already exists: %s&quot;), di2-&gt;di_key);</a>
<a name="ln1898">      break;</a>
<a name="ln1899">    } else if (*action == 'f' &amp;&amp; di2 != di1) {</a>
<a name="ln1900">      typval_T oldtv;</a>
<a name="ln1901"> </a>
<a name="ln1902">      if (tv_check_lock(di1-&gt;di_tv.v_lock, arg_errmsg, arg_errmsg_len)</a>
<a name="ln1903">          || var_check_ro(di1-&gt;di_flags, arg_errmsg, arg_errmsg_len)) {</a>
<a name="ln1904">        break;</a>
<a name="ln1905">      }</a>
<a name="ln1906"> </a>
<a name="ln1907">      if (watched) {</a>
<a name="ln1908">        tv_copy(&amp;di1-&gt;di_tv, &amp;oldtv);</a>
<a name="ln1909">      }</a>
<a name="ln1910"> </a>
<a name="ln1911">      tv_clear(&amp;di1-&gt;di_tv);</a>
<a name="ln1912">      tv_copy(&amp;di2-&gt;di_tv, &amp;di1-&gt;di_tv);</a>
<a name="ln1913"> </a>
<a name="ln1914">      if (watched) {</a>
<a name="ln1915">        tv_dict_watcher_notify(d1, (const char *)di1-&gt;di_key, &amp;di1-&gt;di_tv,</a>
<a name="ln1916">                               &amp;oldtv);</a>
<a name="ln1917">        tv_clear(&amp;oldtv);</a>
<a name="ln1918">      }</a>
<a name="ln1919">    }</a>
<a name="ln1920">  });</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">/// Compare two dictionaries</a>
<a name="ln1924">///</a>
<a name="ln1925">/// @param[in]  d1  First dictionary.</a>
<a name="ln1926">/// @param[in]  d2  Second dictionary.</a>
<a name="ln1927">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln1928">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln1929">bool tv_dict_equal(dict_T *const d1, dict_T *const d2,</a>
<a name="ln1930">                   const bool ic, const bool recursive)</a>
<a name="ln1931">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1932">{</a>
<a name="ln1933">  if (d1 == d2) {</a>
<a name="ln1934">    return true;</a>
<a name="ln1935">  }</a>
<a name="ln1936">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln1937">    return false;</a>
<a name="ln1938">  }</a>
<a name="ln1939">  if (tv_dict_len(d1) != tv_dict_len(d2)) {</a>
<a name="ln1940">    return false;</a>
<a name="ln1941">  }</a>
<a name="ln1942"> </a>
<a name="ln1943">  TV_DICT_ITER(d1, di1, {</a>
<a name="ln1944">    dictitem_T *const di2 = tv_dict_find(d2, (const char *)di1-&gt;di_key, -1);</a>
<a name="ln1945">    if (di2 == NULL) {</a>
<a name="ln1946">      return false;</a>
<a name="ln1947">    }</a>
<a name="ln1948">    if (!tv_equal(&amp;di1-&gt;di_tv, &amp;di2-&gt;di_tv, ic, recursive)) {</a>
<a name="ln1949">      return false;</a>
<a name="ln1950">    }</a>
<a name="ln1951">  });</a>
<a name="ln1952">  return true;</a>
<a name="ln1953">}</a>
<a name="ln1954"> </a>
<a name="ln1955">/// Make a copy of dictionary</a>
<a name="ln1956">///</a>
<a name="ln1957">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln1958">/// @param[in]  orig  Original dictionary to copy.</a>
<a name="ln1959">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln1960">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln1961">///</a>
<a name="ln1962">/// @return Copied dictionary. May be NULL in case original dictionary is NULL</a>
<a name="ln1963">///         or some failure happens. The refcount of the new dictionary is set</a>
<a name="ln1964">///         to 1.</a>
<a name="ln1965">dict_T *tv_dict_copy(const vimconv_T *const conv,</a>
<a name="ln1966">                     dict_T *const orig,</a>
<a name="ln1967">                     const bool deep,</a>
<a name="ln1968">                     const int copyID)</a>
<a name="ln1969">{</a>
<a name="ln1970">  if (orig == NULL) {</a>
<a name="ln1971">    return NULL;</a>
<a name="ln1972">  }</a>
<a name="ln1973"> </a>
<a name="ln1974">  dict_T *copy = tv_dict_alloc();</a>
<a name="ln1975">  if (copyID != 0) {</a>
<a name="ln1976">    orig-&gt;dv_copyID = copyID;</a>
<a name="ln1977">    orig-&gt;dv_copydict = copy;</a>
<a name="ln1978">  }</a>
<a name="ln1979">  TV_DICT_ITER(orig, di, {</a>
<a name="ln1980">    if (got_int) {</a>
<a name="ln1981">      break;</a>
<a name="ln1982">    }</a>
<a name="ln1983">    dictitem_T *new_di;</a>
<a name="ln1984">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE) {</a>
<a name="ln1985">      new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln1986">    } else {</a>
<a name="ln1987">      size_t len = STRLEN(di-&gt;di_key);</a>
<a name="ln1988">      char *const key = (char *)string_convert(conv, di-&gt;di_key, &amp;len);</a>
<a name="ln1989">      if (key == NULL) {</a>
<a name="ln1990">        new_di = tv_dict_item_alloc_len((const char *)di-&gt;di_key, len);</a>
<a name="ln1991">      } else {</a>
<a name="ln1992">        new_di = tv_dict_item_alloc_len(key, len);</a>
<a name="ln1993">        xfree(key);</a>
<a name="ln1994">      }</a>
<a name="ln1995">    }</a>
<a name="ln1996">    if (deep) {</a>
<a name="ln1997">      if (var_item_copy(conv, &amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv, deep,</a>
<a name="ln1998">                        copyID) == FAIL) {</a>
<a name="ln1999">        xfree(new_di);</a>
<a name="ln2000">        break;</a>
<a name="ln2001">      }</a>
<a name="ln2002">    } else {</a>
<a name="ln2003">      tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln2004">    }</a>
<a name="ln2005">    if (tv_dict_add(copy, new_di) == FAIL) {</a>
<a name="ln2006">      tv_dict_item_free(new_di);</a>
<a name="ln2007">      break;</a>
<a name="ln2008">    }</a>
<a name="ln2009">  });</a>
<a name="ln2010"> </a>
<a name="ln2011">  copy-&gt;dv_refcount++;</a>
<a name="ln2012">  if (got_int) {</a>
<a name="ln2013">    tv_dict_unref(copy);</a>
<a name="ln2014">    copy = NULL;</a>
<a name="ln2015">  }</a>
<a name="ln2016"> </a>
<a name="ln2017">  return copy;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">/// Set all existing keys in &quot;dict&quot; as read-only.</a>
<a name="ln2021">///</a>
<a name="ln2022">/// This does not protect against adding new keys to the Dictionary.</a>
<a name="ln2023">///</a>
<a name="ln2024">/// @param  dict  The dict whose keys should be frozen.</a>
<a name="ln2025">void tv_dict_set_keys_readonly(dict_T *const dict)</a>
<a name="ln2026">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2027">{</a>
<a name="ln2028">  TV_DICT_ITER(dict, di, {</a>
<a name="ln2029">    di-&gt;di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln2030">  });</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033">//{{{1 Generic typval operations</a>
<a name="ln2034">//{{{2 Init/alloc/clear</a>
<a name="ln2035">//{{{3 Alloc</a>
<a name="ln2036"> </a>
<a name="ln2037">/// Allocate an empty list for a return value</a>
<a name="ln2038">///</a>
<a name="ln2039">/// Also sets reference count.</a>
<a name="ln2040">///</a>
<a name="ln2041">/// @param[out]  ret_tv  Structure where list is saved.</a>
<a name="ln2042">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln2043">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln2044">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln2045">///                  will be allocated in advance. @see ListLenSpecials.</a>
<a name="ln2046">///</a>
<a name="ln2047">/// @return [allocated] pointer to the created list.</a>
<a name="ln2048">list_T *tv_list_alloc_ret(typval_T *const ret_tv, const ptrdiff_t len)</a>
<a name="ln2049">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2050">{</a>
<a name="ln2051">  list_T *const l = tv_list_alloc(len);</a>
<a name="ln2052">  tv_list_set_ret(ret_tv, l);</a>
<a name="ln2053">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2054">  return l;</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">/// Allocate an empty dictionary for a return value</a>
<a name="ln2058">///</a>
<a name="ln2059">/// Also sets reference count.</a>
<a name="ln2060">///</a>
<a name="ln2061">/// @param[out]  ret_tv  Structure where dictionary is saved.</a>
<a name="ln2062">void tv_dict_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln2063">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2064">{</a>
<a name="ln2065">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln2066">  tv_dict_set_ret(ret_tv, d);</a>
<a name="ln2067">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">//{{{3 Clear</a>
<a name="ln2071">#define TYPVAL_ENCODE_ALLOW_SPECIALS false</a>
<a name="ln2072"> </a>
<a name="ln2073">#define TYPVAL_ENCODE_CONV_NIL(tv) \</a>
<a name="ln2074">    do { \</a>
<a name="ln2075">      tv-&gt;vval.v_special = kSpecialVarNull; \</a>
<a name="ln2076">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2077">    } while (0)</a>
<a name="ln2078"> </a>
<a name="ln2079">#define TYPVAL_ENCODE_CONV_BOOL(tv, num) \</a>
<a name="ln2080">    do { \</a>
<a name="ln2081">      tv-&gt;vval.v_bool = kBoolVarFalse; \</a>
<a name="ln2082">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2083">    } while (0)</a>
<a name="ln2084"> </a>
<a name="ln2085">#define TYPVAL_ENCODE_CONV_NUMBER(tv, num) \</a>
<a name="ln2086">    do { \</a>
<a name="ln2087">      (void)num; \</a>
<a name="ln2088">      tv-&gt;vval.v_number = 0; \</a>
<a name="ln2089">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2090">    } while (0)</a>
<a name="ln2091"> </a>
<a name="ln2092">#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, num)</a>
<a name="ln2093"> </a>
<a name="ln2094">#define TYPVAL_ENCODE_CONV_FLOAT(tv, flt) \</a>
<a name="ln2095">    do { \</a>
<a name="ln2096">      tv-&gt;vval.v_float = 0; \</a>
<a name="ln2097">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2098">    } while (0)</a>
<a name="ln2099"> </a>
<a name="ln2100">#define TYPVAL_ENCODE_CONV_STRING(tv, buf, len) \</a>
<a name="ln2101">    do { \</a>
<a name="ln2102">      xfree(buf); \</a>
<a name="ln2103">      tv-&gt;vval.v_string = NULL; \</a>
<a name="ln2104">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2105">    } while (0)</a>
<a name="ln2106"> </a>
<a name="ln2107">#define TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len)</a>
<a name="ln2108"> </a>
<a name="ln2109">#define TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type)</a>
<a name="ln2110"> </a>
<a name="ln2111">static inline int _nothing_conv_func_start(typval_T *const tv,</a>
<a name="ln2112">                                           char_u *const fun)</a>
<a name="ln2113">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2114">{</a>
<a name="ln2115">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2116">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2117">    partial_T *const pt_ = tv-&gt;vval.v_partial;</a>
<a name="ln2118">    if (pt_ != NULL &amp;&amp; pt_-&gt;pt_refcount &gt; 1) {</a>
<a name="ln2119">      pt_-&gt;pt_refcount--;</a>
<a name="ln2120">      tv-&gt;vval.v_partial = NULL;</a>
<a name="ln2121">      return OK;</a>
<a name="ln2122">    }</a>
<a name="ln2123">  } else {</a>
<a name="ln2124">    func_unref(fun);</a>
<a name="ln2125">    if ((const char *)fun != tv_empty_string) {</a>
<a name="ln2126">      xfree(fun);</a>
<a name="ln2127">    }</a>
<a name="ln2128">    tv-&gt;vval.v_string = NULL;</a>
<a name="ln2129">  }</a>
<a name="ln2130">  return NOTDONE;</a>
<a name="ln2131">}</a>
<a name="ln2132">#define TYPVAL_ENCODE_CONV_FUNC_START(tv, fun) \</a>
<a name="ln2133">    do { \</a>
<a name="ln2134">      if (_nothing_conv_func_start(tv, fun) != NOTDONE) { \</a>
<a name="ln2135">        return OK; \</a>
<a name="ln2136">      } \</a>
<a name="ln2137">    } while (0)</a>
<a name="ln2138"> </a>
<a name="ln2139">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, len)</a>
<a name="ln2140">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, len)</a>
<a name="ln2141"> </a>
<a name="ln2142">static inline void _nothing_conv_func_end(typval_T *const tv, const int copyID)</a>
<a name="ln2143">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2144">{</a>
<a name="ln2145">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2146">    partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln2147">    if (pt == NULL) {</a>
<a name="ln2148">      return;</a>
<a name="ln2149">    }</a>
<a name="ln2150">    // Dictionary should already be freed by the time.</a>
<a name="ln2151">    // If it was not freed then it is a part of the reference cycle.</a>
<a name="ln2152">    assert(pt-&gt;pt_dict == NULL || pt-&gt;pt_dict-&gt;dv_copyID == copyID);</a>
<a name="ln2153">    pt-&gt;pt_dict = NULL;</a>
<a name="ln2154">    // As well as all arguments.</a>
<a name="ln2155">    pt-&gt;pt_argc = 0;</a>
<a name="ln2156">    assert(pt-&gt;pt_refcount &lt;= 1);</a>
<a name="ln2157">    partial_unref(pt);</a>
<a name="ln2158">    tv-&gt;vval.v_partial = NULL;</a>
<a name="ln2159">    assert(tv-&gt;v_lock == VAR_UNLOCKED);</a>
<a name="ln2160">  }</a>
<a name="ln2161">}</a>
<a name="ln2162">#define TYPVAL_ENCODE_CONV_FUNC_END(tv) _nothing_conv_func_end(tv, copyID)</a>
<a name="ln2163"> </a>
<a name="ln2164">#define TYPVAL_ENCODE_CONV_EMPTY_LIST(tv) \</a>
<a name="ln2165">    do { \</a>
<a name="ln2166">      tv_list_unref(tv-&gt;vval.v_list); \</a>
<a name="ln2167">      tv-&gt;vval.v_list = NULL; \</a>
<a name="ln2168">      tv-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2169">    } while (0)</a>
<a name="ln2170"> </a>
<a name="ln2171">static inline void _nothing_conv_empty_dict(typval_T *const tv,</a>
<a name="ln2172">                                            dict_T **const dictp)</a>
<a name="ln2173">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2174">{</a>
<a name="ln2175">  tv_dict_unref(*dictp);</a>
<a name="ln2176">  *dictp = NULL;</a>
<a name="ln2177">  if (tv != NULL) {</a>
<a name="ln2178">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2179">  }</a>
<a name="ln2180">}</a>
<a name="ln2181">#define TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, dict) \</a>
<a name="ln2182">    do { \</a>
<a name="ln2183">      assert((void *)&amp;dict != (void *)&amp;TYPVAL_ENCODE_NODICT_VAR); \</a>
<a name="ln2184">      _nothing_conv_empty_dict(tv, ((dict_T **)&amp;dict)); \</a>
<a name="ln2185">    } while (0)</a>
<a name="ln2186"> </a>
<a name="ln2187">static inline int _nothing_conv_real_list_after_start(</a>
<a name="ln2188">    typval_T *const tv, MPConvStackVal *const mpsv)</a>
<a name="ln2189">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2190">{</a>
<a name="ln2191">  assert(tv != NULL);</a>
<a name="ln2192">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2193">  if (tv-&gt;vval.v_list-&gt;lv_refcount &gt; 1) {</a>
<a name="ln2194">    tv-&gt;vval.v_list-&gt;lv_refcount--;</a>
<a name="ln2195">    tv-&gt;vval.v_list = NULL;</a>
<a name="ln2196">    mpsv-&gt;data.l.li = NULL;</a>
<a name="ln2197">    return OK;</a>
<a name="ln2198">  }</a>
<a name="ln2199">  return NOTDONE;</a>
<a name="ln2200">}</a>
<a name="ln2201">#define TYPVAL_ENCODE_CONV_LIST_START(tv, len)</a>
<a name="ln2202"> </a>
<a name="ln2203">#define TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, mpsv) \</a>
<a name="ln2204">    do { \</a>
<a name="ln2205">      if (_nothing_conv_real_list_after_start(tv, &amp;mpsv) != NOTDONE) { \</a>
<a name="ln2206">        goto typval_encode_stop_converting_one_item; \</a>
<a name="ln2207">      } \</a>
<a name="ln2208">    } while (0)</a>
<a name="ln2209"> </a>
<a name="ln2210">#define TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(tv)</a>
<a name="ln2211"> </a>
<a name="ln2212">static inline void _nothing_conv_list_end(typval_T *const tv)</a>
<a name="ln2213">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2214">{</a>
<a name="ln2215">  if (tv == NULL) {</a>
<a name="ln2216">    return;</a>
<a name="ln2217">  }</a>
<a name="ln2218">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln2219">  list_T *const list = tv-&gt;vval.v_list;</a>
<a name="ln2220">  tv_list_unref(list);</a>
<a name="ln2221">  tv-&gt;vval.v_list = NULL;</a>
<a name="ln2222">}</a>
<a name="ln2223">#define TYPVAL_ENCODE_CONV_LIST_END(tv) _nothing_conv_list_end(tv)</a>
<a name="ln2224"> </a>
<a name="ln2225">static inline int _nothing_conv_real_dict_after_start(</a>
<a name="ln2226">    typval_T *const tv, dict_T **const dictp, const void *const nodictvar,</a>
<a name="ln2227">    MPConvStackVal *const mpsv)</a>
<a name="ln2228">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2229">{</a>
<a name="ln2230">  if (tv != NULL) {</a>
<a name="ln2231">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2232">  }</a>
<a name="ln2233">  if ((const void *)dictp != nodictvar &amp;&amp; (*dictp)-&gt;dv_refcount &gt; 1) {</a>
<a name="ln2234">    (*dictp)-&gt;dv_refcount--;</a>
<a name="ln2235">    *dictp = NULL;</a>
<a name="ln2236">    mpsv-&gt;data.d.todo = 0;</a>
<a name="ln2237">    return OK;</a>
<a name="ln2238">  }</a>
<a name="ln2239">  return NOTDONE;</a>
<a name="ln2240">}</a>
<a name="ln2241">#define TYPVAL_ENCODE_CONV_DICT_START(tv, dict, len)</a>
<a name="ln2242"> </a>
<a name="ln2243">#define TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, dict, mpsv) \</a>
<a name="ln2244">    do { \</a>
<a name="ln2245">      if (_nothing_conv_real_dict_after_start( \</a>
<a name="ln2246">          tv, (dict_T **)&amp;dict, (void *)&amp;TYPVAL_ENCODE_NODICT_VAR, \</a>
<a name="ln2247">          &amp;mpsv) != NOTDONE) { \</a>
<a name="ln2248">        goto typval_encode_stop_converting_one_item; \</a>
<a name="ln2249">      } \</a>
<a name="ln2250">    } while (0)</a>
<a name="ln2251"> </a>
<a name="ln2252">#define TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(tv, dict)</a>
<a name="ln2253">#define TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(tv, dict)</a>
<a name="ln2254">#define TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(tv, dict)</a>
<a name="ln2255"> </a>
<a name="ln2256">static inline void _nothing_conv_dict_end(typval_T *const tv,</a>
<a name="ln2257">                                          dict_T **const dictp,</a>
<a name="ln2258">                                          const void *const nodictvar)</a>
<a name="ln2259">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln2260">{</a>
<a name="ln2261">  if ((const void *)dictp != nodictvar) {</a>
<a name="ln2262">    tv_dict_unref(*dictp);</a>
<a name="ln2263">    *dictp = NULL;</a>
<a name="ln2264">  }</a>
<a name="ln2265">}</a>
<a name="ln2266">#define TYPVAL_ENCODE_CONV_DICT_END(tv, dict) \</a>
<a name="ln2267">    _nothing_conv_dict_end(tv, (dict_T **)&amp;dict, \</a>
<a name="ln2268">                           (void *)&amp;TYPVAL_ENCODE_NODICT_VAR)</a>
<a name="ln2269"> </a>
<a name="ln2270">#define TYPVAL_ENCODE_CONV_RECURSE(val, conv_type)</a>
<a name="ln2271"> </a>
<a name="ln2272">#define TYPVAL_ENCODE_SCOPE static</a>
<a name="ln2273">#define TYPVAL_ENCODE_NAME nothing</a>
<a name="ln2274">#define TYPVAL_ENCODE_FIRST_ARG_TYPE const void *const</a>
<a name="ln2275">#define TYPVAL_ENCODE_FIRST_ARG_NAME ignored</a>
<a name="ln2276">#define TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</a>
<a name="ln2277">#include &quot;nvim/eval/typval_encode.c.h&quot;</a>
<a name="ln2278">#undef TYPVAL_ENCODE_SCOPE</a>
<a name="ln2279">#undef TYPVAL_ENCODE_NAME</a>
<a name="ln2280">#undef TYPVAL_ENCODE_FIRST_ARG_TYPE</a>
<a name="ln2281">#undef TYPVAL_ENCODE_FIRST_ARG_NAME</a>
<a name="ln2282">#undef TYPVAL_ENCODE_TRANSLATE_OBJECT_NAME</a>
<a name="ln2283"> </a>
<a name="ln2284">#undef TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln2285">#undef TYPVAL_ENCODE_CONV_NIL</a>
<a name="ln2286">#undef TYPVAL_ENCODE_CONV_BOOL</a>
<a name="ln2287">#undef TYPVAL_ENCODE_CONV_NUMBER</a>
<a name="ln2288">#undef TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</a>
<a name="ln2289">#undef TYPVAL_ENCODE_CONV_FLOAT</a>
<a name="ln2290">#undef TYPVAL_ENCODE_CONV_STRING</a>
<a name="ln2291">#undef TYPVAL_ENCODE_CONV_STR_STRING</a>
<a name="ln2292">#undef TYPVAL_ENCODE_CONV_EXT_STRING</a>
<a name="ln2293">#undef TYPVAL_ENCODE_CONV_FUNC_START</a>
<a name="ln2294">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</a>
<a name="ln2295">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</a>
<a name="ln2296">#undef TYPVAL_ENCODE_CONV_FUNC_END</a>
<a name="ln2297">#undef TYPVAL_ENCODE_CONV_EMPTY_LIST</a>
<a name="ln2298">#undef TYPVAL_ENCODE_CONV_EMPTY_DICT</a>
<a name="ln2299">#undef TYPVAL_ENCODE_CONV_LIST_START</a>
<a name="ln2300">#undef TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</a>
<a name="ln2301">#undef TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</a>
<a name="ln2302">#undef TYPVAL_ENCODE_CONV_LIST_END</a>
<a name="ln2303">#undef TYPVAL_ENCODE_CONV_DICT_START</a>
<a name="ln2304">#undef TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</a>
<a name="ln2305">#undef TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</a>
<a name="ln2306">#undef TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</a>
<a name="ln2307">#undef TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</a>
<a name="ln2308">#undef TYPVAL_ENCODE_CONV_DICT_END</a>
<a name="ln2309">#undef TYPVAL_ENCODE_CONV_RECURSE</a>
<a name="ln2310"> </a>
<a name="ln2311">/// Free memory for a variable value and set the value to NULL or 0</a>
<a name="ln2312">///</a>
<a name="ln2313">/// @param[in,out]  tv  Value to free.</a>
<a name="ln2314">void tv_clear(typval_T *const tv)</a>
<a name="ln2315">{</a>
<a name="ln2316">  if (tv != NULL &amp;&amp; tv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln2317">    // WARNING: do not translate the string here, gettext is slow and function</a>
<a name="ln2318">    // is used *very* often. At the current state encode_vim_to_nothing() does</a>
<a name="ln2319">    // not error out and does not use the argument anywhere.</a>
<a name="ln2320">    //</a>
<a name="ln2321">    // If situation changes and this argument will be used, translate it in the</a>
<a name="ln2322">    // place where it is used.</a>
<a name="ln2323">    const int evn_ret = encode_vim_to_nothing(NULL, tv, &quot;tv_clear() argument&quot;);</a>
<a name="ln2324">    (void)evn_ret;</a>
<a name="ln2325">    assert(evn_ret == OK);</a>
<a name="ln2326">  }</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">//{{{3 Free</a>
<a name="ln2330"> </a>
<a name="ln2331">/// Free allocated VimL object and value stored inside</a>
<a name="ln2332">///</a>
<a name="ln2333">/// @param  tv  Object to free.</a>
<a name="ln2334">void tv_free(typval_T *tv)</a>
<a name="ln2335">{</a>
<a name="ln2336">  if (tv != NULL) {</a>
<a name="ln2337">    switch (tv-&gt;v_type) {</a>
<a name="ln2338">      case VAR_PARTIAL: {</a>
<a name="ln2339">        partial_unref(tv-&gt;vval.v_partial);</a>
<a name="ln2340">        break;</a>
<a name="ln2341">      }</a>
<a name="ln2342">      case VAR_FUNC: {</a>
<a name="ln2343">        func_unref(tv-&gt;vval.v_string);</a>
<a name="ln2344">        FALLTHROUGH;</a>
<a name="ln2345">      }</a>
<a name="ln2346">      case VAR_STRING: {</a>
<a name="ln2347">        xfree(tv-&gt;vval.v_string);</a>
<a name="ln2348">        break;</a>
<a name="ln2349">      }</a>
<a name="ln2350">      case VAR_LIST: {</a>
<a name="ln2351">        tv_list_unref(tv-&gt;vval.v_list);</a>
<a name="ln2352">        break;</a>
<a name="ln2353">      }</a>
<a name="ln2354">      case VAR_DICT: {</a>
<a name="ln2355">        tv_dict_unref(tv-&gt;vval.v_dict);</a>
<a name="ln2356">        break;</a>
<a name="ln2357">      }</a>
<a name="ln2358">      case VAR_BOOL:</a>
<a name="ln2359">      case VAR_SPECIAL:</a>
<a name="ln2360">      case VAR_NUMBER:</a>
<a name="ln2361">      case VAR_FLOAT:</a>
<a name="ln2362">      case VAR_UNKNOWN: {</a>
<a name="ln2363">        break;</a>
<a name="ln2364">      }</a>
<a name="ln2365">    }</a>
<a name="ln2366">    xfree(tv);</a>
<a name="ln2367">  }</a>
<a name="ln2368">}</a>
<a name="ln2369"> </a>
<a name="ln2370">//{{{3 Copy</a>
<a name="ln2371"> </a>
<a name="ln2372">/// Copy typval from one location to another</a>
<a name="ln2373">///</a>
<a name="ln2374">/// When needed allocates string or increases reference count. Does not make</a>
<a name="ln2375">/// a copy of a container, but copies its reference!</a>
<a name="ln2376">///</a>
<a name="ln2377">/// It is OK for `from` and `to` to point to the same location; this is used to</a>
<a name="ln2378">/// make a copy later.</a>
<a name="ln2379">///</a>
<a name="ln2380">/// @param[in]  from  Location to copy from.</a>
<a name="ln2381">/// @param[out]  to  Location to copy to.</a>
<a name="ln2382">void tv_copy(const typval_T *const from, typval_T *const to)</a>
<a name="ln2383">{</a>
<a name="ln2384">  to-&gt;v_type = from-&gt;v_type;</a>
<a name="ln2385">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2386">  memmove(&amp;to-&gt;vval, &amp;from-&gt;vval, sizeof(to-&gt;vval));</a>
<a name="ln2387">  switch (from-&gt;v_type) {</a>
<a name="ln2388">    case VAR_NUMBER:</a>
<a name="ln2389">    case VAR_FLOAT:</a>
<a name="ln2390">    case VAR_BOOL:</a>
<a name="ln2391">    case VAR_SPECIAL: {</a>
<a name="ln2392">      break;</a>
<a name="ln2393">    }</a>
<a name="ln2394">    case VAR_STRING:</a>
<a name="ln2395">    case VAR_FUNC: {</a>
<a name="ln2396">      if (from-&gt;vval.v_string != NULL) {</a>
<a name="ln2397">        to-&gt;vval.v_string = vim_strsave(from-&gt;vval.v_string);</a>
<a name="ln2398">        if (from-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2399">          func_ref(to-&gt;vval.v_string);</a>
<a name="ln2400">        }</a>
<a name="ln2401">      }</a>
<a name="ln2402">      break;</a>
<a name="ln2403">    }</a>
<a name="ln2404">    case VAR_PARTIAL: {</a>
<a name="ln2405">      if (to-&gt;vval.v_partial != NULL) {</a>
<a name="ln2406">        to-&gt;vval.v_partial-&gt;pt_refcount++;</a>
<a name="ln2407">      }</a>
<a name="ln2408">      break;</a>
<a name="ln2409">    }</a>
<a name="ln2410">    case VAR_LIST: {</a>
<a name="ln2411">      tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln2412">      break;</a>
<a name="ln2413">    }</a>
<a name="ln2414">    case VAR_DICT: {</a>
<a name="ln2415">      if (from-&gt;vval.v_dict != NULL) {</a>
<a name="ln2416">        to-&gt;vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln2417">      }</a>
<a name="ln2418">      break;</a>
<a name="ln2419">    }</a>
<a name="ln2420">    case VAR_UNKNOWN: {</a>
<a name="ln2421">      emsgf(_(e_intern2), &quot;tv_copy(UNKNOWN)&quot;);</a>
<a name="ln2422">      break;</a>
<a name="ln2423">    }</a>
<a name="ln2424">  }</a>
<a name="ln2425">}</a>
<a name="ln2426"> </a>
<a name="ln2427">//{{{2 Locks</a>
<a name="ln2428"> </a>
<a name="ln2429">/// Lock or unlock an item</a>
<a name="ln2430">///</a>
<a name="ln2431">/// @param[out]  tv  Item to (un)lock.</a>
<a name="ln2432">/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.</a>
<a name="ln2433">/// @param[in]  lock  True if it is needed to lock an item, false to unlock.</a>
<a name="ln2434">void tv_item_lock(typval_T *const tv, const int deep, const bool lock)</a>
<a name="ln2435">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2436">{</a>
<a name="ln2437">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln2438">  static int recurse = 0;</a>
<a name="ln2439"> </a>
<a name="ln2440">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln2441">    EMSG(_(&quot;E743: variable nested too deep for (un)lock&quot;));</a>
<a name="ln2442">    return;</a>
<a name="ln2443">  }</a>
<a name="ln2444">  if (deep == 0) {</a>
<a name="ln2445">    return;</a>
<a name="ln2446">  }</a>
<a name="ln2447">  recurse++;</a>
<a name="ln2448"> </a>
<a name="ln2449">  // lock/unlock the item itself</a>
<a name="ln2450">#define CHANGE_LOCK(lock, var) \</a>
<a name="ln2451">  do { \</a>
<a name="ln2452">    var = ((VarLockStatus[]) { \</a>
<a name="ln2453">      [VAR_UNLOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln2454">      [VAR_LOCKED] = (lock ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln2455">      [VAR_FIXED] = VAR_FIXED, \</a>
<a name="ln2456">    })[var]; \</a>
<a name="ln2457">  } while (0)</a>
<a name="ln2458">  CHANGE_LOCK(lock, tv-&gt;v_lock);</a>
<a name="ln2459"> </a>
<a name="ln2460">  switch (tv-&gt;v_type) {</a>
<a name="ln2461">    case VAR_LIST: {</a>
<a name="ln2462">      list_T *const l = tv-&gt;vval.v_list;</a>
<a name="ln2463">      if (l != NULL) {</a>
<a name="ln2464">        CHANGE_LOCK(lock, l-&gt;lv_lock);</a>
<a name="ln2465">        if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln2466">          // Recursive: lock/unlock the items the List contains.</a>
<a name="ln2467">          TV_LIST_ITER(l, li, {</a>
<a name="ln2468">            tv_item_lock(TV_LIST_ITEM_TV(li), deep - 1, lock);</a>
<a name="ln2469">          });</a>
<a name="ln2470">        }</a>
<a name="ln2471">      }</a>
<a name="ln2472">      break;</a>
<a name="ln2473">    }</a>
<a name="ln2474">    case VAR_DICT: {</a>
<a name="ln2475">      dict_T *const d = tv-&gt;vval.v_dict;</a>
<a name="ln2476">      if (d != NULL) {</a>
<a name="ln2477">        CHANGE_LOCK(lock, d-&gt;dv_lock);</a>
<a name="ln2478">        if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln2479">          // recursive: lock/unlock the items the List contains</a>
<a name="ln2480">          TV_DICT_ITER(d, di, {</a>
<a name="ln2481">            tv_item_lock(&amp;di-&gt;di_tv, deep - 1, lock);</a>
<a name="ln2482">          });</a>
<a name="ln2483">        }</a>
<a name="ln2484">      }</a>
<a name="ln2485">      break;</a>
<a name="ln2486">    }</a>
<a name="ln2487">    case VAR_NUMBER:</a>
<a name="ln2488">    case VAR_FLOAT:</a>
<a name="ln2489">    case VAR_STRING:</a>
<a name="ln2490">    case VAR_FUNC:</a>
<a name="ln2491">    case VAR_PARTIAL:</a>
<a name="ln2492">    case VAR_BOOL:</a>
<a name="ln2493">    case VAR_SPECIAL: {</a>
<a name="ln2494">      break;</a>
<a name="ln2495">    }</a>
<a name="ln2496">    case VAR_UNKNOWN: {</a>
<a name="ln2497">      assert(false);</a>
<a name="ln2498">    }</a>
<a name="ln2499">  }</a>
<a name="ln2500">#undef CHANGE_LOCK</a>
<a name="ln2501">  recurse--;</a>
<a name="ln2502">}</a>
<a name="ln2503"> </a>
<a name="ln2504">/// Check whether VimL value is locked itself or refers to a locked container</a>
<a name="ln2505">///</a>
<a name="ln2506">/// @warning Fixed container is not the same as locked.</a>
<a name="ln2507">///</a>
<a name="ln2508">/// @param[in]  tv  Value to check.</a>
<a name="ln2509">///</a>
<a name="ln2510">/// @return True if value is locked, false otherwise.</a>
<a name="ln2511">bool tv_islocked(const typval_T *const tv)</a>
<a name="ln2512">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2513">{</a>
<a name="ln2514">  return ((tv-&gt;v_lock == VAR_LOCKED)</a>
<a name="ln2515">          || (tv-&gt;v_type == VAR_LIST</a>
<a name="ln2516">              &amp;&amp; (tv_list_locked(tv-&gt;vval.v_list) == VAR_LOCKED))</a>
<a name="ln2517">          || (tv-&gt;v_type == VAR_DICT</a>
<a name="ln2518">              &amp;&amp; tv-&gt;vval.v_dict != NULL</a>
<a name="ln2519">              &amp;&amp; (tv-&gt;vval.v_dict-&gt;dv_lock == VAR_LOCKED)));</a>
<a name="ln2520">}</a>
<a name="ln2521"> </a>
<a name="ln2522">/// Return true if typval is locked</a>
<a name="ln2523">///</a>
<a name="ln2524">/// Also gives an error message when typval is locked.</a>
<a name="ln2525">///</a>
<a name="ln2526">/// @param[in]  lock  Lock status.</a>
<a name="ln2527">/// @param[in]  name  Variable name, used in the error message.</a>
<a name="ln2528">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln2529">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln2530">///                       to compute the length with strlen() without</a>
<a name="ln2531">///                       translating.</a>
<a name="ln2532">///</a>
<a name="ln2533">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln2534">///                       variable name with its length is needed only in case</a>
<a name="ln2535">///                       of error, when no error occurs computing them is</a>
<a name="ln2536">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln2537">///                       gettext.</a>
<a name="ln2538">///</a>
<a name="ln2539">/// @return true if variable is locked, false otherwise.</a>
<a name="ln2540">bool tv_check_lock(const VarLockStatus lock, const char *name,</a>
<a name="ln2541">                   size_t name_len)</a>
<a name="ln2542">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2543">{</a>
<a name="ln2544">  const char *error_message = NULL;</a>
<a name="ln2545">  switch (lock) {</a>
<a name="ln2546">    case VAR_UNLOCKED: {</a>
<a name="ln2547">      return false;</a>
<a name="ln2548">    }</a>
<a name="ln2549">    case VAR_LOCKED: {</a>
<a name="ln2550">      error_message = N_(&quot;E741: Value is locked: %.*s&quot;);</a>
<a name="ln2551">      break;</a>
<a name="ln2552">    }</a>
<a name="ln2553">    case VAR_FIXED: {</a>
<a name="ln2554">      error_message = N_(&quot;E742: Cannot change value of %.*s&quot;);</a>
<a name="ln2555">      break;</a>
<a name="ln2556">    }</a>
<a name="ln2557">  }</a>
<a name="ln2558">  assert(error_message != NULL);</a>
<a name="ln2559"> </a>
<a name="ln2560">  if (name == NULL) {</a>
<a name="ln2561">    name = _(&quot;Unknown&quot;);</a>
<a name="ln2562">    name_len = strlen(name);</a>
<a name="ln2563">  } else if (name_len == TV_TRANSLATE) {</a>
<a name="ln2564">    name = _(name);</a>
<a name="ln2565">    name_len = strlen(name);</a>
<a name="ln2566">  } else if (name_len == TV_CSTRING) {</a>
<a name="ln2567">    name_len = strlen(name);</a>
<a name="ln2568">  }</a>
<a name="ln2569"> </a>
<a name="ln2570">  emsgf(_(error_message), (int)name_len, name);</a>
<a name="ln2571"> </a>
<a name="ln2572">  return true;</a>
<a name="ln2573">}</a>
<a name="ln2574"> </a>
<a name="ln2575">//{{{2 Comparison</a>
<a name="ln2576"> </a>
<a name="ln2577">static int tv_equal_recurse_limit;</a>
<a name="ln2578"> </a>
<a name="ln2579">/// Compare two VimL values</a>
<a name="ln2580">///</a>
<a name="ln2581">/// Like &quot;==&quot;, but strings and numbers are different, as well as floats and</a>
<a name="ln2582">/// numbers.</a>
<a name="ln2583">///</a>
<a name="ln2584">/// @warning Too nested structures may be considered equal even if they are not.</a>
<a name="ln2585">///</a>
<a name="ln2586">/// @param[in]  tv1  First value to compare.</a>
<a name="ln2587">/// @param[in]  tv2  Second value to compare.</a>
<a name="ln2588">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln2589">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln2590">///</a>
<a name="ln2591">/// @return true if values are equal.</a>
<a name="ln2592">bool tv_equal(typval_T *const tv1, typval_T *const tv2, const bool ic,</a>
<a name="ln2593">              const bool recursive)</a>
<a name="ln2594">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2595">{</a>
<a name="ln2596">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln2597">  static int recursive_cnt = 0;  // Catch recursive loops.</a>
<a name="ln2598"> </a>
<a name="ln2599">  if (!(tv_is_func(*tv1) &amp;&amp; tv_is_func(*tv2)) &amp;&amp; tv1-&gt;v_type != tv2-&gt;v_type) {</a>
<a name="ln2600">    return false;</a>
<a name="ln2601">  }</a>
<a name="ln2602"> </a>
<a name="ln2603">  // Catch lists and dicts that have an endless loop by limiting</a>
<a name="ln2604">  // recursiveness to a limit.  We guess they are equal then.</a>
<a name="ln2605">  // A fixed limit has the problem of still taking an awful long time.</a>
<a name="ln2606">  // Reduce the limit every time running into it. That should work fine for</a>
<a name="ln2607">  // deeply linked structures that are not recursively linked and catch</a>
<a name="ln2608">  // recursiveness quickly.</a>
<a name="ln2609">  if (!recursive) {</a>
<a name="ln2610">    tv_equal_recurse_limit = 1000;</a>
<a name="ln2611">  }</a>
<a name="ln2612">  if (recursive_cnt &gt;= tv_equal_recurse_limit) {</a>
<a name="ln2613">    tv_equal_recurse_limit--;</a>
<a name="ln2614">    return true;</a>
<a name="ln2615">  }</a>
<a name="ln2616"> </a>
<a name="ln2617">  switch (tv1-&gt;v_type) {</a>
<a name="ln2618">    case VAR_LIST: {</a>
<a name="ln2619">      recursive_cnt++;</a>
<a name="ln2620">      const bool r = tv_list_equal(tv1-&gt;vval.v_list, tv2-&gt;vval.v_list, ic,</a>
<a name="ln2621">                                   true);</a>
<a name="ln2622">      recursive_cnt--;</a>
<a name="ln2623">      return r;</a>
<a name="ln2624">    }</a>
<a name="ln2625">    case VAR_DICT: {</a>
<a name="ln2626">      recursive_cnt++;</a>
<a name="ln2627">      const bool r = tv_dict_equal(tv1-&gt;vval.v_dict, tv2-&gt;vval.v_dict, ic,</a>
<a name="ln2628">                                   true);</a>
<a name="ln2629">      recursive_cnt--;</a>
<a name="ln2630">      return r;</a>
<a name="ln2631">    }</a>
<a name="ln2632">    case VAR_PARTIAL:</a>
<a name="ln2633">    case VAR_FUNC: {</a>
<a name="ln2634">      if ((tv1-&gt;v_type == VAR_PARTIAL &amp;&amp; tv1-&gt;vval.v_partial == NULL)</a>
<a name="ln2635">          || (tv2-&gt;v_type == VAR_PARTIAL &amp;&amp; tv2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln2636">        return false;</a>
<a name="ln2637">      }</a>
<a name="ln2638">      recursive_cnt++;</a>
<a name="ln2639">      const bool r = func_equal(tv1, tv2, ic);</a>
<a name="ln2640">      recursive_cnt--;</a>
<a name="ln2641">      return r;</a>
<a name="ln2642">    }</a>
<a name="ln2643">    case VAR_NUMBER: {</a>
<a name="ln2644">      return tv1-&gt;vval.v_number == tv2-&gt;vval.v_number;</a>
<a name="ln2645">    }</a>
<a name="ln2646">    case VAR_FLOAT: {</a>
<a name="ln2647">      return tv1-&gt;vval.v_float == tv2-&gt;vval.v_float;</a>
<a name="ln2648">    }</a>
<a name="ln2649">    case VAR_STRING: {</a>
<a name="ln2650">      char buf1[NUMBUFLEN];</a>
<a name="ln2651">      char buf2[NUMBUFLEN];</a>
<a name="ln2652">      const char *s1 = tv_get_string_buf(tv1, buf1);</a>
<a name="ln2653">      const char *s2 = tv_get_string_buf(tv2, buf2);</a>
<a name="ln2654">      return mb_strcmp_ic((bool)ic, s1, s2) == 0;</a>
<a name="ln2655">    }</a>
<a name="ln2656">    case VAR_BOOL: {</a>
<a name="ln2657">      return tv1-&gt;vval.v_bool == tv2-&gt;vval.v_bool;</a>
<a name="ln2658">    }</a>
<a name="ln2659">    case VAR_SPECIAL: {</a>
<a name="ln2660">      return tv1-&gt;vval.v_special == tv2-&gt;vval.v_special;</a>
<a name="ln2661">    }</a>
<a name="ln2662">    case VAR_UNKNOWN: {</a>
<a name="ln2663">      // VAR_UNKNOWN can be the result of an invalid expression, let’s say it</a>
<a name="ln2664">      // does not equal anything, not even self.</a>
<a name="ln2665">      return false;</a>
<a name="ln2666">    }</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">  assert(false);</a>
<a name="ln2670">  return false;</a>
<a name="ln2671">}</a>
<a name="ln2672"> </a>
<a name="ln2673">//{{{2 Type checks</a>
<a name="ln2674"> </a>
<a name="ln2675">/// Check that given value is a number or string</a>
<a name="ln2676">///</a>
<a name="ln2677">/// Error messages are compatible with tv_get_number() previously used for the</a>
<a name="ln2678">/// same purpose in buf*() functions. Special values are not accepted (previous</a>
<a name="ln2679">/// behaviour: silently fail to find buffer).</a>
<a name="ln2680">///</a>
<a name="ln2681">/// @param[in]  tv  Value to check.</a>
<a name="ln2682">///</a>
<a name="ln2683">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2684">bool tv_check_str_or_nr(const typval_T *const tv)</a>
<a name="ln2685">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2686">{</a>
<a name="ln2687">  switch (tv-&gt;v_type) {</a>
<a name="ln2688">    case VAR_NUMBER:</a>
<a name="ln2689">    case VAR_STRING: {</a>
<a name="ln2690">      return true;</a>
<a name="ln2691">    }</a>
<a name="ln2692">    case VAR_FLOAT: {</a>
<a name="ln2693">      EMSG(_(&quot;E805: Expected a Number or a String, Float found&quot;));</a>
<a name="ln2694">      return false;</a>
<a name="ln2695">    }</a>
<a name="ln2696">    case VAR_PARTIAL:</a>
<a name="ln2697">    case VAR_FUNC: {</a>
<a name="ln2698">      EMSG(_(&quot;E703: Expected a Number or a String, Funcref found&quot;));</a>
<a name="ln2699">      return false;</a>
<a name="ln2700">    }</a>
<a name="ln2701">    case VAR_LIST: {</a>
<a name="ln2702">      EMSG(_(&quot;E745: Expected a Number or a String, List found&quot;));</a>
<a name="ln2703">      return false;</a>
<a name="ln2704">    }</a>
<a name="ln2705">    case VAR_DICT: {</a>
<a name="ln2706">      EMSG(_(&quot;E728: Expected a Number or a String, Dictionary found&quot;));</a>
<a name="ln2707">      return false;</a>
<a name="ln2708">    }</a>
<a name="ln2709">    case VAR_BOOL: {</a>
<a name="ln2710">      EMSG(_(&quot;E5299: Expected a Number or a String, Boolean found&quot;));</a>
<a name="ln2711">      return false;</a>
<a name="ln2712">    }</a>
<a name="ln2713">    case VAR_SPECIAL: {</a>
<a name="ln2714">      EMSG(_(&quot;E5300: Expected a Number or a String&quot;));</a>
<a name="ln2715">      return false;</a>
<a name="ln2716">    }</a>
<a name="ln2717">    case VAR_UNKNOWN: {</a>
<a name="ln2718">      EMSG2(_(e_intern2), &quot;tv_check_str_or_nr(UNKNOWN)&quot;);</a>
<a name="ln2719">      return false;</a>
<a name="ln2720">    }</a>
<a name="ln2721">  }</a>
<a name="ln2722">  assert(false);</a>
<a name="ln2723">  return false;</a>
<a name="ln2724">}</a>
<a name="ln2725"> </a>
<a name="ln2726">#define FUNC_ERROR &quot;E703: Using a Funcref as a Number&quot;</a>
<a name="ln2727"> </a>
<a name="ln2728">static const char *const num_errors[] = {</a>
<a name="ln2729">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln2730">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln2731">  [VAR_LIST]=N_(&quot;E745: Using a List as a Number&quot;),</a>
<a name="ln2732">  [VAR_DICT]=N_(&quot;E728: Using a Dictionary as a Number&quot;),</a>
<a name="ln2733">  [VAR_FLOAT]=N_(&quot;E805: Using a Float as a Number&quot;),</a>
<a name="ln2734">  [VAR_UNKNOWN]=N_(&quot;E685: using an invalid value as a Number&quot;),</a>
<a name="ln2735">};</a>
<a name="ln2736"> </a>
<a name="ln2737">#undef FUNC_ERROR</a>
<a name="ln2738"> </a>
<a name="ln2739">/// Check that given value is a number or can be converted to it</a>
<a name="ln2740">///</a>
<a name="ln2741">/// Error messages are compatible with tv_get_number_chk() previously used for</a>
<a name="ln2742">/// the same purpose.</a>
<a name="ln2743">///</a>
<a name="ln2744">/// @param[in]  tv  Value to check.</a>
<a name="ln2745">///</a>
<a name="ln2746">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2747">bool tv_check_num(const typval_T *const tv)</a>
<a name="ln2748">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2749">{</a>
<a name="ln2750">  switch (tv-&gt;v_type) {</a>
<a name="ln2751">    case VAR_NUMBER:</a>
<a name="ln2752">    case VAR_BOOL:</a>
<a name="ln2753">    case VAR_SPECIAL:</a>
<a name="ln2754">    case VAR_STRING: {</a>
<a name="ln2755">      return true;</a>
<a name="ln2756">    }</a>
<a name="ln2757">    case VAR_FUNC:</a>
<a name="ln2758">    case VAR_PARTIAL:</a>
<a name="ln2759">    case VAR_LIST:</a>
<a name="ln2760">    case VAR_DICT:</a>
<a name="ln2761">    case VAR_FLOAT:</a>
<a name="ln2762">    case VAR_UNKNOWN: {</a>
<a name="ln2763">      EMSG(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln2764">      return false;</a>
<a name="ln2765">    }</a>
<a name="ln2766">  }</a>
<a name="ln2767">  assert(false);</a>
<a name="ln2768">  return false;</a>
<a name="ln2769">}</a>
<a name="ln2770"> </a>
<a name="ln2771">#define FUNC_ERROR &quot;E729: using Funcref as a String&quot;</a>
<a name="ln2772"> </a>
<a name="ln2773">static const char *const str_errors[] = {</a>
<a name="ln2774">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln2775">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln2776">  [VAR_LIST]=N_(&quot;E730: using List as a String&quot;),</a>
<a name="ln2777">  [VAR_DICT]=N_(&quot;E731: using Dictionary as a String&quot;),</a>
<a name="ln2778">  [VAR_FLOAT]=((const char *)e_float_as_string),</a>
<a name="ln2779">  [VAR_UNKNOWN]=N_(&quot;E908: using an invalid value as a String&quot;),</a>
<a name="ln2780">};</a>
<a name="ln2781"> </a>
<a name="ln2782">#undef FUNC_ERROR</a>
<a name="ln2783"> </a>
<a name="ln2784">/// Check that given value is a VimL String or can be &quot;cast&quot; to it.</a>
<a name="ln2785">///</a>
<a name="ln2786">/// Error messages are compatible with tv_get_string_chk() previously used for</a>
<a name="ln2787">/// the same purpose.</a>
<a name="ln2788">///</a>
<a name="ln2789">/// @param[in]  tv  Value to check.</a>
<a name="ln2790">///</a>
<a name="ln2791">/// @return true if everything is OK, false otherwise.</a>
<a name="ln2792">bool tv_check_str(const typval_T *const tv)</a>
<a name="ln2793">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2794">{</a>
<a name="ln2795">  switch (tv-&gt;v_type) {</a>
<a name="ln2796">    case VAR_NUMBER:</a>
<a name="ln2797">    case VAR_BOOL:</a>
<a name="ln2798">    case VAR_SPECIAL:</a>
<a name="ln2799">    case VAR_STRING: {</a>
<a name="ln2800">      return true;</a>
<a name="ln2801">    }</a>
<a name="ln2802">    case VAR_PARTIAL:</a>
<a name="ln2803">    case VAR_FUNC:</a>
<a name="ln2804">    case VAR_LIST:</a>
<a name="ln2805">    case VAR_DICT:</a>
<a name="ln2806">    case VAR_FLOAT:</a>
<a name="ln2807">    case VAR_UNKNOWN: {</a>
<a name="ln2808">      EMSG(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln2809">      return false;</a>
<a name="ln2810">    }</a>
<a name="ln2811">  }</a>
<a name="ln2812">  assert(false);</a>
<a name="ln2813">  return false;</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816">//{{{2 Get</a>
<a name="ln2817"> </a>
<a name="ln2818">/// Get the number value of a VimL object</a>
<a name="ln2819">///</a>
<a name="ln2820">/// @note Use tv_get_number_chk() if you need to determine whether there was an</a>
<a name="ln2821">///       error.</a>
<a name="ln2822">///</a>
<a name="ln2823">/// @param[in]  tv  Object to get value from.</a>
<a name="ln2824">///</a>
<a name="ln2825">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln2826">///         for VAR_NUMBER objects, -1 for other types.</a>
<a name="ln2827">varnumber_T tv_get_number(const typval_T *const tv)</a>
<a name="ln2828">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2829">{</a>
<a name="ln2830">  bool error = false;</a>
<a name="ln2831">  return tv_get_number_chk(tv, &amp;error);</a>
<a name="ln2832">}</a>
<a name="ln2833"> </a>
<a name="ln2834">/// Get the number value of a VimL object</a>
<a name="ln2835">///</a>
<a name="ln2836">/// @param[in]  tv  Object to get value from.</a>
<a name="ln2837">/// @param[out]  ret_error  If type error occurred then `true` will be written</a>
<a name="ln2838">///                         to this location. Otherwise it is not touched.</a>
<a name="ln2839">///</a>
<a name="ln2840">///                         @note Needs to be initialized to `false` to be</a>
<a name="ln2841">///                               useful.</a>
<a name="ln2842">///</a>
<a name="ln2843">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln2844">///         for VAR_NUMBER objects, -1 (ret_error == NULL) or 0 (otherwise) for</a>
<a name="ln2845">///         other types.</a>
<a name="ln2846">varnumber_T tv_get_number_chk(const typval_T *const tv, bool *const ret_error)</a>
<a name="ln2847">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2848">{</a>
<a name="ln2849">  switch (tv-&gt;v_type) {</a>
<a name="ln2850">    case VAR_FUNC:</a>
<a name="ln2851">    case VAR_PARTIAL:</a>
<a name="ln2852">    case VAR_LIST:</a>
<a name="ln2853">    case VAR_DICT:</a>
<a name="ln2854">    case VAR_FLOAT: {</a>
<a name="ln2855">      EMSG(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln2856">      break;</a>
<a name="ln2857">    }</a>
<a name="ln2858">    case VAR_NUMBER: {</a>
<a name="ln2859">      return tv-&gt;vval.v_number;</a>
<a name="ln2860">    }</a>
<a name="ln2861">    case VAR_STRING: {</a>
<a name="ln2862">      varnumber_T n = 0;</a>
<a name="ln2863">      if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln2864">        vim_str2nr(tv-&gt;vval.v_string, NULL, NULL, STR2NR_ALL, &amp;n, NULL, 0);</a>
<a name="ln2865">      }</a>
<a name="ln2866">      return n;</a>
<a name="ln2867">    }</a>
<a name="ln2868">    case VAR_BOOL: {</a>
<a name="ln2869">      return tv-&gt;vval.v_bool == kBoolVarTrue ? 1 : 0;</a>
<a name="ln2870">    }</a>
<a name="ln2871">    case VAR_SPECIAL: {</a>
<a name="ln2872">      return 0;</a>
<a name="ln2873">    }</a>
<a name="ln2874">    case VAR_UNKNOWN: {</a>
<a name="ln2875">      emsgf(_(e_intern2), &quot;tv_get_number(UNKNOWN)&quot;);</a>
<a name="ln2876">      break;</a>
<a name="ln2877">    }</a>
<a name="ln2878">  }</a>
<a name="ln2879">  if (ret_error != NULL) {</a>
<a name="ln2880">    *ret_error = true;</a>
<a name="ln2881">  }</a>
<a name="ln2882">  return (ret_error == NULL ? -1 : 0);</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885">/// Get the line number from VimL object</a>
<a name="ln2886">///</a>
<a name="ln2887">/// @param[in]  tv  Object to get value from. Is expected to be a number or</a>
<a name="ln2888">///                 a special string like &quot;.&quot;, &quot;$&quot;, … (works with current buffer</a>
<a name="ln2889">///                 only).</a>
<a name="ln2890">///</a>
<a name="ln2891">/// @return Line number or -1 or 0.</a>
<a name="ln2892">linenr_T tv_get_lnum(const typval_T *const tv)</a>
<a name="ln2893">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2894">{</a>
<a name="ln2895">  linenr_T lnum = (linenr_T)tv_get_number_chk(tv, NULL);</a>
<a name="ln2896">  if (lnum == 0) {  // No valid number, try using same function as line() does.</a>
<a name="ln2897">    int fnum;</a>
<a name="ln2898">    pos_T *const fp = var2fpos(tv, true, &amp;fnum);</a>
<a name="ln2899">    if (fp != NULL) {</a>
<a name="ln2900">      lnum = fp-&gt;lnum;</a>
<a name="ln2901">    }</a>
<a name="ln2902">  }</a>
<a name="ln2903">  return lnum;</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">/// Get the floating-point value of a VimL object</a>
<a name="ln2907">///</a>
<a name="ln2908">/// Raises an error if object is not number or floating-point.</a>
<a name="ln2909">///</a>
<a name="ln2910">/// @param[in]  tv  Object to get value of.</a>
<a name="ln2911">///</a>
<a name="ln2912">/// @return Floating-point value of the variable or zero.</a>
<a name="ln2913">float_T tv_get_float(const typval_T *const tv)</a>
<a name="ln2914">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2915">{</a>
<a name="ln2916">  switch (tv-&gt;v_type) {</a>
<a name="ln2917">    case VAR_NUMBER: {</a>
<a name="ln2918">      return (float_T)(tv-&gt;vval.v_number);</a>
<a name="ln2919">    }</a>
<a name="ln2920">    case VAR_FLOAT: {</a>
<a name="ln2921">      return tv-&gt;vval.v_float;</a>
<a name="ln2922">    }</a>
<a name="ln2923">    case VAR_PARTIAL:</a>
<a name="ln2924">    case VAR_FUNC: {</a>
<a name="ln2925">      EMSG(_(&quot;E891: Using a Funcref as a Float&quot;));</a>
<a name="ln2926">      break;</a>
<a name="ln2927">    }</a>
<a name="ln2928">    case VAR_STRING: {</a>
<a name="ln2929">      EMSG(_(&quot;E892: Using a String as a Float&quot;));</a>
<a name="ln2930">      break;</a>
<a name="ln2931">    }</a>
<a name="ln2932">    case VAR_LIST: {</a>
<a name="ln2933">      EMSG(_(&quot;E893: Using a List as a Float&quot;));</a>
<a name="ln2934">      break;</a>
<a name="ln2935">    }</a>
<a name="ln2936">    case VAR_DICT: {</a>
<a name="ln2937">      EMSG(_(&quot;E894: Using a Dictionary as a Float&quot;));</a>
<a name="ln2938">      break;</a>
<a name="ln2939">    }</a>
<a name="ln2940">    case VAR_BOOL: {</a>
<a name="ln2941">      EMSG(_(&quot;E362: Using a boolean value as a Float&quot;));</a>
<a name="ln2942">      break;</a>
<a name="ln2943">    }</a>
<a name="ln2944">    case VAR_SPECIAL: {</a>
<a name="ln2945">      EMSG(_(&quot;E907: Using a special value as a Float&quot;));</a>
<a name="ln2946">      break;</a>
<a name="ln2947">    }</a>
<a name="ln2948">    case VAR_UNKNOWN: {</a>
<a name="ln2949">      emsgf(_(e_intern2), &quot;tv_get_float(UNKNOWN)&quot;);</a>
<a name="ln2950">      break;</a>
<a name="ln2951">    }</a>
<a name="ln2952">  }</a>
<a name="ln2953">  return 0;</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">// Give an error and return FAIL unless &quot;tv&quot; is a non-empty string.</a>
<a name="ln2957">int tv_check_for_string(const typval_T *const tv)</a>
<a name="ln2958">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln2959">{</a>
<a name="ln2960">  if (tv-&gt;v_type != VAR_STRING</a>
<a name="ln2961">      || tv-&gt;vval.v_string == NULL</a>
<a name="ln2962">      || *tv-&gt;vval.v_string == NUL) {</a>
<a name="ln2963">    EMSG(_(e_stringreq));</a>
<a name="ln2964">    return FAIL;</a>
<a name="ln2965">  }</a>
<a name="ln2966">  return OK;</a>
<a name="ln2967">}</a>
<a name="ln2968"> </a>
<a name="ln2969">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln2970">///</a>
<a name="ln2971">/// @param[in]  tv  Object to get value of.</a>
<a name="ln2972">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln2973">///              string. When function encounters one of these stringified value</a>
<a name="ln2974">///              will be written to buf and buf will be returned.</a>
<a name="ln2975">///</a>
<a name="ln2976">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln2977">///</a>
<a name="ln2978">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln2979">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln2980">const char *tv_get_string_buf_chk(const typval_T *const tv, char *const buf)</a>
<a name="ln2981">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2982">{</a>
<a name="ln2983">  switch (tv-&gt;v_type) {</a>
<a name="ln2984">    case VAR_NUMBER: {</a>
<a name="ln2985">      snprintf(buf, NUMBUFLEN, &quot;%&quot; PRIdVARNUMBER, tv-&gt;vval.v_number);  // -V576</a>
<a name="ln2986">      return buf;</a>
<a name="ln2987">    }</a>
<a name="ln2988">    case VAR_STRING: {</a>
<a name="ln2989">      if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln2990">        return (const char *)tv-&gt;vval.v_string;</a>
<a name="ln2991">      }</a>
<a name="ln2992">      return &quot;&quot;;</a>
<a name="ln2993">    }</a>
<a name="ln2994">    case VAR_BOOL: {</a>
<a name="ln2995">      STRCPY(buf, encode_bool_var_names[tv-&gt;vval.v_bool]);</a>
<a name="ln2996">      return buf;</a>
<a name="ln2997">    }</a>
<a name="ln2998">    case VAR_SPECIAL: {</a>
<a name="ln2999">      STRCPY(buf, encode_special_var_names[tv-&gt;vval.v_special]);</a>
<a name="ln3000">      return buf;</a>
<a name="ln3001">    }</a>
<a name="ln3002">    case VAR_PARTIAL:</a>
<a name="ln3003">    case VAR_FUNC:</a>
<a name="ln3004">    case VAR_LIST:</a>
<a name="ln3005">    case VAR_DICT:</a>
<a name="ln3006">    case VAR_FLOAT:</a>
<a name="ln3007">    case VAR_UNKNOWN: {</a>
<a name="ln3008">      EMSG(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln3009">      return false;</a>
<a name="ln3010">    }</a>
<a name="ln3011">  }</a>
<a name="ln3012">  return NULL;</a>
<a name="ln3013">}</a>
<a name="ln3014"> </a>
<a name="ln3015">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3016">///</a>
<a name="ln3017">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3018">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3019">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3020">///          calling it again.</a>
<a name="ln3021">///</a>
<a name="ln3022">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3023">///</a>
<a name="ln3024">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3025">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln3026">const char *tv_get_string_chk(const typval_T *const tv)</a>
<a name="ln3027">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3028">{</a>
<a name="ln3029">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3030"> </a>
<a name="ln3031">  return tv_get_string_buf_chk(tv, mybuf);</a>
<a name="ln3032">}</a>
<a name="ln3033"> </a>
<a name="ln3034">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3035">///</a>
<a name="ln3036">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3037">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3038">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3039">///          calling it again.</a>
<a name="ln3040">///</a>
<a name="ln3041">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3042">///       return NULL on error.</a>
<a name="ln3043">///</a>
<a name="ln3044">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3045">///</a>
<a name="ln3046">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3047">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3048">///         string.</a>
<a name="ln3049">const char *tv_get_string(const typval_T *const tv)</a>
<a name="ln3050">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3051">{</a>
<a name="ln3052">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3053">  return tv_get_string_buf((typval_T *)tv, mybuf);</a>
<a name="ln3054">}</a>
<a name="ln3055"> </a>
<a name="ln3056">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3057">///</a>
<a name="ln3058">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3059">///       return NULL on error.</a>
<a name="ln3060">///</a>
<a name="ln3061">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3062">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln3063">///              string. When function encounters one of these stringified value</a>
<a name="ln3064">///              will be written to buf and buf will be returned.</a>
<a name="ln3065">///</a>
<a name="ln3066">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln3067">///</a>
<a name="ln3068">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3069">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3070">///         string.</a>
<a name="ln3071">const char *tv_get_string_buf(const typval_T *const tv, char *const buf)</a>
<a name="ln3072">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3073">{</a>
<a name="ln3074">  const char *const res = (const char *)tv_get_string_buf_chk(tv, buf);</a>
<a name="ln3075"> </a>
<a name="ln3076">  return res != NULL ? res : &quot;&quot;;</a>
<a name="ln3077">}</a>

</code></pre>
<div class="balloon" rel="2660"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

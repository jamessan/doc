
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>userfunc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User defined function support</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln7">#include &quot;nvim/charset.h&quot;</a>
<a name="ln8">#include &quot;nvim/edit.h&quot;</a>
<a name="ln9">#include &quot;nvim/eval.h&quot;</a>
<a name="ln10">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln11">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln12">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln13">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln14">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln15">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln16">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln17">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln18">#include &quot;nvim/globals.h&quot;</a>
<a name="ln19">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln20">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln21">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln22">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln23">#include &quot;nvim/search.h&quot;</a>
<a name="ln24">#include &quot;nvim/ui.h&quot;</a>
<a name="ln25">#include &quot;nvim/vim.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">// flags used in uf_flags</a>
<a name="ln28">#define FC_ABORT    0x01          // abort function on error</a>
<a name="ln29">#define FC_RANGE    0x02          // function accepts range</a>
<a name="ln30">#define FC_DICT     0x04          // Dict function, uses &quot;self&quot;</a>
<a name="ln31">#define FC_CLOSURE  0x08          // closure, uses outer scope variables</a>
<a name="ln32">#define FC_DELETED  0x10          // :delfunction used while uf_refcount &gt; 0</a>
<a name="ln33">#define FC_REMOVED  0x20          // function redefined while uf_refcount &gt; 0</a>
<a name="ln34">#define FC_SANDBOX  0x40          // function defined in the sandbox</a>
<a name="ln35">#define FC_DEAD     0x80          // function kept only for reference to dfunc</a>
<a name="ln36">#define FC_EXPORT   0x100         // &quot;export def Func()&quot;</a>
<a name="ln37">#define FC_NOARGS   0x200         // no a: variables in lambda</a>
<a name="ln38">#define FC_VIM9     0x400         // defined in vim9 script file</a>
<a name="ln39">#define FC_CFUNC    0x800         // C function extension</a>
<a name="ln40"> </a>
<a name="ln41">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln42">#include &quot;eval/userfunc.c.generated.h&quot;</a>
<a name="ln43">#endif</a>
<a name="ln44"> </a>
<a name="ln45">hashtab_T func_hashtab;</a>
<a name="ln46"> </a>
<a name="ln47">// Used by get_func_tv()</a>
<a name="ln48">static garray_T funcargs = GA_EMPTY_INIT_VALUE;</a>
<a name="ln49"> </a>
<a name="ln50">// pointer to funccal for currently active function</a>
<a name="ln51">static funccall_T *current_funccal = NULL;</a>
<a name="ln52"> </a>
<a name="ln53">// Pointer to list of previously used funccal, still around because some</a>
<a name="ln54">// item in it is still being used.</a>
<a name="ln55">static funccall_T *previous_funccal = NULL;</a>
<a name="ln56"> </a>
<a name="ln57">static char *e_funcexts = N_(</a>
<a name="ln58">    &quot;E122: Function %s already exists, add ! to replace it&quot;);</a>
<a name="ln59">static char *e_funcdict = N_(&quot;E717: Dictionary entry already exists&quot;);</a>
<a name="ln60">static char *e_funcref = N_(&quot;E718: Funcref required&quot;);</a>
<a name="ln61">static char *e_nofunc = N_(&quot;E130: Unknown function: %s&quot;);</a>
<a name="ln62"> </a>
<a name="ln63">void func_init(void)</a>
<a name="ln64">{</a>
<a name="ln65">    hash_init(&amp;func_hashtab);</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">/// Get function arguments.</a>
<a name="ln69">static int get_function_args(char_u **argp, char_u endchar, garray_T *newargs,</a>
<a name="ln70">                             int *varargs, bool skip)</a>
<a name="ln71">{</a>
<a name="ln72">  bool    mustend = false;</a>
<a name="ln73">  char_u  *arg = *argp;</a>
<a name="ln74">  char_u  *p = arg;</a>
<a name="ln75">  int     c;</a>
<a name="ln76">  int     i;</a>
<a name="ln77"> </a>
<a name="ln78">  if (newargs != NULL) {</a>
<a name="ln79">    ga_init(newargs, (int)sizeof(char_u *), 3);</a>
<a name="ln80">  }</a>
<a name="ln81"> </a>
<a name="ln82">  if (varargs != NULL) {</a>
<a name="ln83">    *varargs = false;</a>
<a name="ln84">  }</a>
<a name="ln85"> </a>
<a name="ln86">  // Isolate the arguments: &quot;arg1, arg2, ...)&quot;</a>
<a name="ln87">  while (*p != endchar) {</a>
<a name="ln88">    if (p[0] == '.' &amp;&amp; p[1] == '.' &amp;&amp; p[2] == '.') {</a>
<a name="ln89">      if (varargs != NULL) {</a>
<a name="ln90">        *varargs = true;</a>
<a name="ln91">      }</a>
<a name="ln92">      p += 3;</a>
<a name="ln93">      mustend = true;</a>
<a name="ln94">    } else {</a>
<a name="ln95">      arg = p;</a>
<a name="ln96">      while (ASCII_ISALNUM(*p) || *p == '_') {</a>
<a name="ln97">        p++;</a>
<a name="ln98">      }</a>
<a name="ln99">      if (arg == p || isdigit(*arg)</a>
<a name="ln100">          || (p - arg == 9 &amp;&amp; STRNCMP(arg, &quot;firstline&quot;, 9) == 0)</a>
<a name="ln101">          || (p - arg == 8 &amp;&amp; STRNCMP(arg, &quot;lastline&quot;, 8) == 0)) {</a>
<a name="ln102">        if (!skip) {</a>
<a name="ln103">          EMSG2(_(&quot;E125: Illegal argument: %s&quot;), arg);</a>
<a name="ln104">        }</a>
<a name="ln105">        break;</a>
<a name="ln106">      }</a>
<a name="ln107">      if (newargs != NULL) {</a>
<a name="ln108">        ga_grow(newargs, 1);</a>
<a name="ln109">        c = *p;</a>
<a name="ln110">        *p = NUL;</a>
<a name="ln111">        arg = vim_strsave(arg);</a>
<a name="ln112"> </a>
<a name="ln113">        // Check for duplicate argument name.</a>
<a name="ln114">        for (i = 0; i &lt; newargs-&gt;ga_len; i++) {</a>
<a name="ln115">          if (STRCMP(((char_u **)(newargs-&gt;ga_data))[i], arg) == 0) {</a>
<a name="ln116">            EMSG2(_(&quot;E853: Duplicate argument name: %s&quot;), arg);</a>
<a name="ln117">            xfree(arg);</a>
<a name="ln118">            goto err_ret;</a>
<a name="ln119">          }</a>
<a name="ln120">        }</a>
<a name="ln121">        ((char_u **)(newargs-&gt;ga_data))[newargs-&gt;ga_len] = arg;</a>
<a name="ln122">        newargs-&gt;ga_len++;</a>
<a name="ln123"> </a>
<a name="ln124">        *p = c;</a>
<a name="ln125">      }</a>
<a name="ln126">      if (*p == ',') {</a>
<a name="ln127">        p++;</a>
<a name="ln128">      } else {</a>
<a name="ln129">        mustend = true;</a>
<a name="ln130">      }</a>
<a name="ln131">    }</a>
<a name="ln132">    p = skipwhite(p);</a>
<a name="ln133">    if (mustend &amp;&amp; *p != endchar) {</a>
<a name="ln134">      if (!skip) {</a>
<a name="ln135">        EMSG2(_(e_invarg2), *argp);</a>
<a name="ln136">      }</a>
<a name="ln137">      break;</a>
<a name="ln138">    }</a>
<a name="ln139">  }</a>
<a name="ln140">  if (*p != endchar) {</a>
<a name="ln141">    goto err_ret;</a>
<a name="ln142">  }</a>
<a name="ln143">  p++;  // skip &quot;endchar&quot;</a>
<a name="ln144"> </a>
<a name="ln145">  *argp = p;</a>
<a name="ln146">  return OK;</a>
<a name="ln147"> </a>
<a name="ln148">err_ret:</a>
<a name="ln149">  if (newargs != NULL) {</a>
<a name="ln150">    ga_clear_strings(newargs);</a>
<a name="ln151">  }</a>
<a name="ln152">  return FAIL;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">/// Register function &quot;fp&quot; as using &quot;current_funccal&quot; as its scope.</a>
<a name="ln156">static void register_closure(ufunc_T *fp)</a>
<a name="ln157">{</a>
<a name="ln158">  if (fp-&gt;uf_scoped == current_funccal) {</a>
<a name="ln159">    // no change</a>
<a name="ln160">    return;</a>
<a name="ln161">  }</a>
<a name="ln162">  funccal_unref(fp-&gt;uf_scoped, fp, false);</a>
<a name="ln163">  fp-&gt;uf_scoped = current_funccal;</a>
<a name="ln164">  current_funccal-&gt;fc_refcount++;</a>
<a name="ln165">  ga_grow(&amp;current_funccal-&gt;fc_funcs, 1);</a>
<a name="ln166">  ((ufunc_T **)current_funccal-&gt;fc_funcs.ga_data)</a>
<a name="ln167">    [current_funccal-&gt;fc_funcs.ga_len++] = fp;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">/// Get a name for a lambda.  Returned in static memory.</a>
<a name="ln172">char_u * get_lambda_name(void)</a>
<a name="ln173">{</a>
<a name="ln174">    static char_u   name[30];</a>
<a name="ln175">    static int      lambda_no = 0;</a>
<a name="ln176"> </a>
<a name="ln177">    snprintf((char *)name, sizeof(name), &quot;&lt;lambda&gt;%d&quot;, ++lambda_no);</a>
<a name="ln178">    return name;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">/// Parse a lambda expression and get a Funcref from &quot;*arg&quot;.</a>
<a name="ln182">///</a>
<a name="ln183">/// @return OK or FAIL.  Returns NOTDONE for dict or {expr}.</a>
<a name="ln184">int get_lambda_tv(char_u **arg, typval_T *rettv, bool evaluate)</a>
<a name="ln185">{</a>
<a name="ln186">  garray_T   newargs = GA_EMPTY_INIT_VALUE;</a>
<a name="ln187">  garray_T   *pnewargs;</a>
<a name="ln188">  ufunc_T    *fp = NULL;</a>
<a name="ln189">  partial_T *pt = NULL;</a>
<a name="ln190">  int        varargs;</a>
<a name="ln191">  int        ret;</a>
<a name="ln192">  char_u     *start = skipwhite(*arg + 1);</a>
<a name="ln193">  char_u     *s, *e;</a>
<a name="ln194">  bool       *old_eval_lavars = eval_lavars_used;</a>
<a name="ln195">  bool       eval_lavars = false;</a>
<a name="ln196"> </a>
<a name="ln197">  // First, check if this is a lambda expression. &quot;-&gt;&quot; must exists.</a>
<a name="ln198">  ret = get_function_args(&amp;start, '-', NULL, NULL, true);</a>
<a name="ln199">  if (ret == FAIL || *start != '&gt;') {</a>
<a name="ln200">    return NOTDONE;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  // Parse the arguments again.</a>
<a name="ln204">  if (evaluate) {</a>
<a name="ln205">    pnewargs = &amp;newargs;</a>
<a name="ln206">  } else {</a>
<a name="ln207">    pnewargs = NULL;</a>
<a name="ln208">  }</a>
<a name="ln209">  *arg = skipwhite(*arg + 1);</a>
<a name="ln210">  ret = get_function_args(arg, '-', pnewargs, &amp;varargs, false);</a>
<a name="ln211">  if (ret == FAIL || **arg != '&gt;') {</a>
<a name="ln212">    goto errret;</a>
<a name="ln213">  }</a>
<a name="ln214"> </a>
<a name="ln215">  // Set up a flag for checking local variables and arguments.</a>
<a name="ln216">  if (evaluate) {</a>
<a name="ln217">    eval_lavars_used = &amp;eval_lavars;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  // Get the start and the end of the expression.</a>
<a name="ln221">  *arg = skipwhite(*arg + 1);</a>
<a name="ln222">  s = *arg;</a>
<a name="ln223">  ret = skip_expr(arg);</a>
<a name="ln224">  if (ret == FAIL) {</a>
<a name="ln225">    goto errret;</a>
<a name="ln226">  }</a>
<a name="ln227">  e = *arg;</a>
<a name="ln228">  *arg = skipwhite(*arg);</a>
<a name="ln229">  if (**arg != '}') {</a>
<a name="ln230">    goto errret;</a>
<a name="ln231">  }</a>
<a name="ln232">  (*arg)++;</a>
<a name="ln233"> </a>
<a name="ln234">  if (evaluate) {</a>
<a name="ln235">    int len, flags = 0;</a>
<a name="ln236">    char_u *p;</a>
<a name="ln237">    garray_T newlines;</a>
<a name="ln238"> </a>
<a name="ln239">    char_u *name = get_lambda_name();</a>
<a name="ln240"> </a>
<a name="ln241">    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);</a>
<a name="ln242">    pt = xcalloc(1, sizeof(partial_T));</a>
<a name="ln243"> </a>
<a name="ln244">    ga_init(&amp;newlines, (int)sizeof(char_u *), 1);</a>
<a name="ln245">    ga_grow(&amp;newlines, 1);</a>
<a name="ln246"> </a>
<a name="ln247">    // Add &quot;return &quot; before the expression.</a>
<a name="ln248">    len = 7 + e - s + 1;</a>
<a name="ln249">    p = (char_u *)xmalloc(len);</a>
<a name="ln250">    ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;</a>
<a name="ln251">    STRCPY(p, &quot;return &quot;);</a>
<a name="ln252">    STRLCPY(p + 7, s, e - s + 1);</a>
<a name="ln253">    if (strstr((char *)p + 7, &quot;a:&quot;) == NULL) {</a>
<a name="ln254">      // No a: variables are used for sure.</a>
<a name="ln255">      flags |= FC_NOARGS;</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">    fp-&gt;uf_refcount = 1;</a>
<a name="ln259">    STRCPY(fp-&gt;uf_name, name);</a>
<a name="ln260">    hash_add(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln261">    fp-&gt;uf_args = newargs;</a>
<a name="ln262">    fp-&gt;uf_lines = newlines;</a>
<a name="ln263">    if (current_funccal != NULL &amp;&amp; eval_lavars) {</a>
<a name="ln264">      flags |= FC_CLOSURE;</a>
<a name="ln265">      register_closure(fp);</a>
<a name="ln266">    } else {</a>
<a name="ln267">      fp-&gt;uf_scoped = NULL;</a>
<a name="ln268">    }</a>
<a name="ln269"> </a>
<a name="ln270">    if (prof_def_func()) {</a>
<a name="ln271">      func_do_profile(fp);</a>
<a name="ln272">    }</a>
<a name="ln273">    if (sandbox) {</a>
<a name="ln274">      flags |= FC_SANDBOX;</a>
<a name="ln275">    }</a>
<a name="ln276">    fp-&gt;uf_varargs = true;</a>
<a name="ln277">    fp-&gt;uf_flags = flags;</a>
<a name="ln278">    fp-&gt;uf_calls = 0;</a>
<a name="ln279">    fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln280">    fp-&gt;uf_script_ctx.sc_lnum += sourcing_lnum - newlines.ga_len;</a>
<a name="ln281"> </a>
<a name="ln282">    pt-&gt;pt_func = fp;</a>
<a name="ln283">    pt-&gt;pt_refcount = 1;</a>
<a name="ln284">    rettv-&gt;vval.v_partial = pt;</a>
<a name="ln285">    rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  eval_lavars_used = old_eval_lavars;</a>
<a name="ln289">  return OK;</a>
<a name="ln290"> </a>
<a name="ln291">errret:</a>
<a name="ln292">  ga_clear_strings(&amp;newargs);</a>
<a name="ln293">  xfree(fp);</a>
<a name="ln294">  xfree(pt);</a>
<a name="ln295">  eval_lavars_used = old_eval_lavars;</a>
<a name="ln296">  return FAIL;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">/// Return name of the function corresponding to `name`</a>
<a name="ln300">///</a>
<a name="ln301">/// If `name` points to variable that is either a function or partial then</a>
<a name="ln302">/// corresponding function name is returned. Otherwise it returns `name` itself.</a>
<a name="ln303">///</a>
<a name="ln304">/// @param[in]  name  Function name to check.</a>
<a name="ln305">/// @param[in,out]  lenp  Location where length of the returned name is stored.</a>
<a name="ln306">///                       Must be set to the length of the `name` argument.</a>
<a name="ln307">/// @param[out]  partialp  Location where partial will be stored if found</a>
<a name="ln308">///                        function appears to be a partial. May be NULL if this</a>
<a name="ln309">///                        is not needed.</a>
<a name="ln310">/// @param[in]  no_autoload  If true, do not source autoload scripts if function</a>
<a name="ln311">///                          was not found.</a>
<a name="ln312">///</a>
<a name="ln313">/// @return name of the function.</a>
<a name="ln314">char_u *deref_func_name(const char *name, int *lenp,</a>
<a name="ln315">                               partial_T **const partialp, bool no_autoload)</a>
<a name="ln316">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln317">{</a>
<a name="ln318">  if (partialp != NULL) {</a>
<a name="ln319">    *partialp = NULL;</a>
<a name="ln320">  }</a>
<a name="ln321"> </a>
<a name="ln322">  dictitem_T *const v = find_var(name, (size_t)(*lenp), NULL, no_autoload);</a>
<a name="ln323">  if (v != NULL &amp;&amp; v-&gt;di_tv.v_type == VAR_FUNC) {</a>
<a name="ln324">    if (v-&gt;di_tv.vval.v_string == NULL) {  // just in case</a>
<a name="ln325">      *lenp = 0;</a>
<a name="ln326">      return (char_u *)&quot;&quot;;</a>
<a name="ln327">    }</a>
<a name="ln328">    *lenp = (int)STRLEN(v-&gt;di_tv.vval.v_string);</a>
<a name="ln329">    return v-&gt;di_tv.vval.v_string;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  if (v != NULL &amp;&amp; v-&gt;di_tv.v_type == VAR_PARTIAL) {</a>
<a name="ln333">    partial_T *const pt = v-&gt;di_tv.vval.v_partial;</a>
<a name="ln334"> </a>
<a name="ln335">    if (pt == NULL) {  // just in case</a>
<a name="ln336">      *lenp = 0;</a>
<a name="ln337">      return (char_u *)&quot;&quot;;</a>
<a name="ln338">    }</a>
<a name="ln339">    if (partialp != NULL) {</a>
<a name="ln340">      *partialp = pt;</a>
<a name="ln341">    }</a>
<a name="ln342">    char_u *s = partial_name(pt);</a>
<a name="ln343">    *lenp = (int)STRLEN(s);</a>
<a name="ln344">    return s;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  return (char_u *)name;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">/// Give an error message with a function name.  Handle &lt;SNR&gt; things.</a>
<a name="ln351">///</a>
<a name="ln352">/// @param ermsg must be passed without translation (use N_() instead of _()).</a>
<a name="ln353">/// @param name function name</a>
<a name="ln354">void emsg_funcname(char *ermsg, const char_u *name)</a>
<a name="ln355">{</a>
<a name="ln356">  char_u *p;</a>
<a name="ln357"> </a>
<a name="ln358">  if (*name == K_SPECIAL) {</a>
<a name="ln359">    p = concat_str((char_u *)&quot;&lt;SNR&gt;&quot;, name + 3);</a>
<a name="ln360">  } else {</a>
<a name="ln361">    p = (char_u *)name;</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  EMSG2(_(ermsg), p);</a>
<a name="ln365"> </a>
<a name="ln366">  if (p != name) {</a>
<a name="ln367">    xfree(p);</a>
<a name="ln368">  }</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">/*</a>
<a name="ln372"> * Allocate a variable for the result of a function.</a>
<a name="ln373"> * Return OK or FAIL.</a>
<a name="ln374"> */</a>
<a name="ln375">int</a>
<a name="ln376">get_func_tv(</a>
<a name="ln377">    const char_u *name,     // name of the function</a>
<a name="ln378">    int len,                // length of &quot;name&quot; or -1 to use strlen()</a>
<a name="ln379">    typval_T *rettv,</a>
<a name="ln380">    char_u **arg,           // argument, pointing to the '('</a>
<a name="ln381">    linenr_T firstline,     // first line of range</a>
<a name="ln382">    linenr_T lastline,      // last line of range</a>
<a name="ln383">    int *doesrange,         // return: function handled range</a>
<a name="ln384">    int evaluate,</a>
<a name="ln385">    partial_T *partial,     // for extra arguments</a>
<a name="ln386">    dict_T *selfdict        // Dictionary for &quot;self&quot;</a>
<a name="ln387">)</a>
<a name="ln388">{</a>
<a name="ln389">  char_u      *argp;</a>
<a name="ln390">  int ret = OK;</a>
<a name="ln391">  typval_T argvars[MAX_FUNC_ARGS + 1];          /* vars for arguments */</a>
<a name="ln392">  int argcount = 0;                     /* number of arguments found */</a>
<a name="ln393"> </a>
<a name="ln394">  /*</a>
<a name="ln395">   * Get the arguments.</a>
<a name="ln396">   */</a>
<a name="ln397">  argp = *arg;</a>
<a name="ln398">  while (argcount &lt; MAX_FUNC_ARGS - (partial == NULL ? 0 : partial-&gt;pt_argc)) {</a>
<a name="ln399">    argp = skipwhite(argp + 1);             // skip the '(' or ','</a>
<a name="ln400">    if (*argp == ')' || *argp == ',' || *argp == NUL) {</a>
<a name="ln401">      break;</a>
<a name="ln402">    }</a>
<a name="ln403">    if (eval1(&amp;argp, &amp;argvars[argcount], evaluate) == FAIL) {</a>
<a name="ln404">      ret = FAIL;</a>
<a name="ln405">      break;</a>
<a name="ln406">    }</a>
<a name="ln407">    ++argcount;</a>
<a name="ln408">    if (*argp != ',')</a>
<a name="ln409">      break;</a>
<a name="ln410">  }</a>
<a name="ln411">  if (*argp == ')')</a>
<a name="ln412">    ++argp;</a>
<a name="ln413">  else</a>
<a name="ln414">    ret = FAIL;</a>
<a name="ln415"> </a>
<a name="ln416">  if (ret == OK) {</a>
<a name="ln417">    int i = 0;</a>
<a name="ln418"> </a>
<a name="ln419">    if (get_vim_var_nr(VV_TESTING)) {</a>
<a name="ln420">      // Prepare for calling garbagecollect_for_testing(), need to know</a>
<a name="ln421">      // what variables are used on the call stack.</a>
<a name="ln422">      if (funcargs.ga_itemsize == 0) {</a>
<a name="ln423">        ga_init(&amp;funcargs, (int)sizeof(typval_T *), 50);</a>
<a name="ln424">      }</a>
<a name="ln425">      for (i = 0; i &lt; argcount; i++) {</a>
<a name="ln426">        ga_grow(&amp;funcargs, 1);</a>
<a name="ln427">        ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] = &amp;argvars[i];</a>
<a name="ln428">      }</a>
<a name="ln429">    }</a>
<a name="ln430">    ret = call_func(name, len, rettv, argcount, argvars, NULL,</a>
<a name="ln431">                    firstline, lastline, doesrange, evaluate,</a>
<a name="ln432">                    partial, selfdict);</a>
<a name="ln433"> </a>
<a name="ln434">    funcargs.ga_len -= i;</a>
<a name="ln435">  } else if (!aborting()) {</a>
<a name="ln436">    if (argcount == MAX_FUNC_ARGS) {</a>
<a name="ln437">      emsg_funcname(N_(&quot;E740: Too many arguments for function %s&quot;), name);</a>
<a name="ln438">    } else {</a>
<a name="ln439">      emsg_funcname(N_(&quot;E116: Invalid arguments for function %s&quot;), name);</a>
<a name="ln440">    }</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  while (--argcount &gt;= 0) {</a>
<a name="ln444">    tv_clear(&amp;argvars[argcount]);</a>
<a name="ln445">  }</a>
<a name="ln446"> </a>
<a name="ln447">  *arg = skipwhite(argp);</a>
<a name="ln448">  return ret;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">#define FLEN_FIXED 40</a>
<a name="ln452"> </a>
<a name="ln453">/// Check whether function name starts with &lt;SID&gt; or s:</a>
<a name="ln454">///</a>
<a name="ln455">/// @warning Only works for names previously checked by eval_fname_script(), if</a>
<a name="ln456">///          it returned non-zero.</a>
<a name="ln457">///</a>
<a name="ln458">/// @param[in]  name  Name to check.</a>
<a name="ln459">///</a>
<a name="ln460">/// @return true if it starts with &lt;SID&gt; or s:, false otherwise.</a>
<a name="ln461">static inline bool eval_fname_sid(const char *const name)</a>
<a name="ln462">  FUNC_ATTR_PURE FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln463">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln464">{</a>
<a name="ln465">  return *name == 's' || TOUPPER_ASC(name[2]) == 'I';</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/// In a script transform script-local names into actually used names</a>
<a name="ln469">///</a>
<a name="ln470">/// Transforms &quot;&lt;SID&gt;&quot; and &quot;s:&quot; prefixes to `K_SNR {N}` (e.g. K_SNR &quot;123&quot;) and</a>
<a name="ln471">/// &quot;&lt;SNR&gt;&quot; prefix to `K_SNR`. Uses `fname_buf` buffer that is supposed to have</a>
<a name="ln472">/// #FLEN_FIXED + 1 length when it fits, otherwise it allocates memory.</a>
<a name="ln473">///</a>
<a name="ln474">/// @param[in]  name  Name to transform.</a>
<a name="ln475">/// @param  fname_buf  Buffer to save resulting function name to, if it fits.</a>
<a name="ln476">///                    Must have at least #FLEN_FIXED + 1 length.</a>
<a name="ln477">/// @param[out]  tofree  Location where pointer to an allocated memory is saved</a>
<a name="ln478">///                      in case result does not fit into fname_buf.</a>
<a name="ln479">/// @param[out]  error  Location where error type is saved, @see</a>
<a name="ln480">///                     FnameTransError.</a>
<a name="ln481">///</a>
<a name="ln482">/// @return transformed name: either `fname_buf` or a pointer to an allocated</a>
<a name="ln483">///         memory.</a>
<a name="ln484">static char_u *fname_trans_sid(const char_u *const name,</a>
<a name="ln485">                               char_u *const fname_buf,</a>
<a name="ln486">                               char_u **const tofree, int *const error)</a>
<a name="ln487">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln488">{</a>
<a name="ln489">  char_u *fname;</a>
<a name="ln490">  const int llen = eval_fname_script((const char *)name);</a>
<a name="ln491">  if (llen &gt; 0) {</a>
<a name="ln492">    fname_buf[0] = K_SPECIAL;</a>
<a name="ln493">    fname_buf[1] = KS_EXTRA;</a>
<a name="ln494">    fname_buf[2] = (int)KE_SNR;</a>
<a name="ln495">    int i = 3;</a>
<a name="ln496">    if (eval_fname_sid((const char *)name)) {  // &quot;&lt;SID&gt;&quot; or &quot;s:&quot;</a>
<a name="ln497">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln498">        *error = ERROR_SCRIPT;</a>
<a name="ln499">      } else {</a>
<a name="ln500">        snprintf((char *)fname_buf + 3, FLEN_FIXED + 1, &quot;%&quot; PRId64 &quot;_&quot;,</a>
<a name="ln501">                 (int64_t)current_sctx.sc_sid);</a>
<a name="ln502">        i = (int)STRLEN(fname_buf);</a>
<a name="ln503">      }</a>
<a name="ln504">    }</a>
<a name="ln505">    if (i + STRLEN(name + llen) &lt; FLEN_FIXED) {</a>
<a name="ln506">      STRCPY(fname_buf + i, name + llen);</a>
<a name="ln507">      fname = fname_buf;</a>
<a name="ln508">    } else {</a>
<a name="ln509">      fname = xmalloc(i + STRLEN(name + llen) + 1);</a>
<a name="ln510">      *tofree = fname;</a>
<a name="ln511">      memmove(fname, fname_buf, (size_t)i);</a>
<a name="ln512">      STRCPY(fname + i, name + llen);</a>
<a name="ln513">    }</a>
<a name="ln514">  } else {</a>
<a name="ln515">    fname = (char_u *)name;</a>
<a name="ln516">  }</a>
<a name="ln517"> </a>
<a name="ln518">  return fname;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">/// Find a function by name, return pointer to it in ufuncs.</a>
<a name="ln522">/// @return NULL for unknown function.</a>
<a name="ln523">ufunc_T *find_func(const char_u *name)</a>
<a name="ln524">{</a>
<a name="ln525">  hashitem_T  *hi;</a>
<a name="ln526"> </a>
<a name="ln527">  hi = hash_find(&amp;func_hashtab, name);</a>
<a name="ln528">  if (!HASHITEM_EMPTY(hi))</a>
<a name="ln529">    return HI2UF(hi);</a>
<a name="ln530">  return NULL;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">/*</a>
<a name="ln534"> * Copy the function name of &quot;fp&quot; to buffer &quot;buf&quot;.</a>
<a name="ln535"> * &quot;buf&quot; must be able to hold the function name plus three bytes.</a>
<a name="ln536"> * Takes care of script-local function names.</a>
<a name="ln537"> */</a>
<a name="ln538">static void cat_func_name(char_u *buf, ufunc_T *fp)</a>
<a name="ln539">{</a>
<a name="ln540">  if (fp-&gt;uf_name[0] == K_SPECIAL) {</a>
<a name="ln541">    STRCPY(buf, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln542">    STRCAT(buf, fp-&gt;uf_name + 3);</a>
<a name="ln543">  } else</a>
<a name="ln544">    STRCPY(buf, fp-&gt;uf_name);</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">/*</a>
<a name="ln548"> * Add a number variable &quot;name&quot; to dict &quot;dp&quot; with value &quot;nr&quot;.</a>
<a name="ln549"> */</a>
<a name="ln550">static void add_nr_var(dict_T *dp, dictitem_T *v, char *name, varnumber_T nr)</a>
<a name="ln551">{</a>
<a name="ln552">#ifndef __clang_analyzer__</a>
<a name="ln553">  STRCPY(v-&gt;di_key, name);</a>
<a name="ln554">#endif</a>
<a name="ln555">  v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln556">  tv_dict_add(dp, v);</a>
<a name="ln557">  v-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln558">  v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln559">  v-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">// Free &quot;fc&quot;</a>
<a name="ln563">static void free_funccal(funccall_T *fc)</a>
<a name="ln564">{</a>
<a name="ln565">  for (int i = 0; i &lt; fc-&gt;fc_funcs.ga_len; i++) {</a>
<a name="ln566">    ufunc_T *fp = ((ufunc_T **)(fc-&gt;fc_funcs.ga_data))[i];</a>
<a name="ln567"> </a>
<a name="ln568">    // When garbage collecting a funccall_T may be freed before the</a>
<a name="ln569">    // function that references it, clear its uf_scoped field.</a>
<a name="ln570">    // The function may have been redefined and point to another</a>
<a name="ln571">    // funccal_T, don't clear it then.</a>
<a name="ln572">    if (fp != NULL &amp;&amp; fp-&gt;uf_scoped == fc) {</a>
<a name="ln573">      fp-&gt;uf_scoped = NULL;</a>
<a name="ln574">    }</a>
<a name="ln575">  }</a>
<a name="ln576">  ga_clear(&amp;fc-&gt;fc_funcs);</a>
<a name="ln577"> </a>
<a name="ln578">  func_ptr_unref(fc-&gt;func);</a>
<a name="ln579">  xfree(fc);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">// Free &quot;fc&quot; and what it contains.</a>
<a name="ln583">// Can be called only when &quot;fc&quot; is kept beyond the period of it called,</a>
<a name="ln584">// i.e. after cleanup_function_call(fc).</a>
<a name="ln585">static void free_funccal_contents(funccall_T *fc)</a>
<a name="ln586">{</a>
<a name="ln587">  // Free all l: variables.</a>
<a name="ln588">  vars_clear(&amp;fc-&gt;l_vars.dv_hashtab);</a>
<a name="ln589"> </a>
<a name="ln590">  // Free all a: variables.</a>
<a name="ln591">  vars_clear(&amp;fc-&gt;l_avars.dv_hashtab);</a>
<a name="ln592"> </a>
<a name="ln593">  // Free the a:000 variables.</a>
<a name="ln594">  TV_LIST_ITER(&amp;fc-&gt;l_varlist, li, {</a>
<a name="ln595">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln596">  });</a>
<a name="ln597"> </a>
<a name="ln598">  free_funccal(fc);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">/// Handle the last part of returning from a function: free the local hashtable.</a>
<a name="ln602">/// Unless it is still in use by a closure.</a>
<a name="ln603">static void cleanup_function_call(funccall_T *fc)</a>
<a name="ln604">{</a>
<a name="ln605">  bool may_free_fc = fc-&gt;fc_refcount &lt;= 0;</a>
<a name="ln606">  bool free_fc = true;</a>
<a name="ln607"> </a>
<a name="ln608">  current_funccal = fc-&gt;caller;</a>
<a name="ln609"> </a>
<a name="ln610">  // Free all l: variables if not referred.</a>
<a name="ln611">  if (may_free_fc &amp;&amp; fc-&gt;l_vars.dv_refcount == DO_NOT_FREE_CNT) {</a>
<a name="ln612">    vars_clear(&amp;fc-&gt;l_vars.dv_hashtab);</a>
<a name="ln613">  } else {</a>
<a name="ln614">    free_fc = false;</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  // If the a:000 list and the l: and a: dicts are not referenced and</a>
<a name="ln618">  // there is no closure using it, we can free the funccall_T and what's</a>
<a name="ln619">  // in it.</a>
<a name="ln620">  if (may_free_fc &amp;&amp; fc-&gt;l_avars.dv_refcount == DO_NOT_FREE_CNT) {</a>
<a name="ln621">    vars_clear_ext(&amp;fc-&gt;l_avars.dv_hashtab, false);</a>
<a name="ln622">  } else {</a>
<a name="ln623">    free_fc = false;</a>
<a name="ln624"> </a>
<a name="ln625">    // Make a copy of the a: variables, since we didn't do that above.</a>
<a name="ln626">    TV_DICT_ITER(&amp;fc-&gt;l_avars, di, {</a>
<a name="ln627">      tv_copy(&amp;di-&gt;di_tv, &amp;di-&gt;di_tv);</a>
<a name="ln628">    });</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  if (may_free_fc &amp;&amp; fc-&gt;l_varlist.lv_refcount   // NOLINT(runtime/deprecated)</a>
<a name="ln632">      == DO_NOT_FREE_CNT) {</a>
<a name="ln633">    fc-&gt;l_varlist.lv_first = NULL;  // NOLINT(runtime/deprecated)</a>
<a name="ln634"> </a>
<a name="ln635">  } else {</a>
<a name="ln636">    free_fc = false;</a>
<a name="ln637"> </a>
<a name="ln638">    // Make a copy of the a:000 items, since we didn't do that above.</a>
<a name="ln639">    TV_LIST_ITER(&amp;fc-&gt;l_varlist, li, {</a>
<a name="ln640">      tv_copy(TV_LIST_ITEM_TV(li), TV_LIST_ITEM_TV(li));</a>
<a name="ln641">    });</a>
<a name="ln642">  }</a>
<a name="ln643"> </a>
<a name="ln644">  if (free_fc) {</a>
<a name="ln645">    free_funccal(fc);</a>
<a name="ln646">  } else {</a>
<a name="ln647">    static int made_copy = 0;</a>
<a name="ln648"> </a>
<a name="ln649">    // &quot;fc&quot; is still in use.  This can happen when returning &quot;a:000&quot;,</a>
<a name="ln650">    // assigning &quot;l:&quot; to a global variable or defining a closure.</a>
<a name="ln651">    // Link &quot;fc&quot; in the list for garbage collection later.</a>
<a name="ln652">    fc-&gt;caller = previous_funccal;</a>
<a name="ln653">    previous_funccal = fc;</a>
<a name="ln654"> </a>
<a name="ln655">    if (want_garbage_collect) {</a>
<a name="ln656">      // If garbage collector is ready, clear count.</a>
<a name="ln657">      made_copy = 0;</a>
<a name="ln658">    } else if (++made_copy &gt;= (int)((4096 * 1024) / sizeof(*fc))) {</a>
<a name="ln659">      // We have made a lot of copies, worth 4 Mbyte.  This can happen</a>
<a name="ln660">      // when repetitively calling a function that creates a reference to</a>
<a name="ln661">      // itself somehow.  Call the garbage collector soon to avoid using</a>
<a name="ln662">      // too much memory.</a>
<a name="ln663">      made_copy = 0;</a>
<a name="ln664">      want_garbage_collect = true;</a>
<a name="ln665">    }</a>
<a name="ln666">  }</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">/// Unreference &quot;fc&quot;: decrement the reference count and free it when it</a>
<a name="ln670">/// becomes zero.  &quot;fp&quot; is detached from &quot;fc&quot;.</a>
<a name="ln671">///</a>
<a name="ln672">/// @param[in]   force   When true, we are exiting.</a>
<a name="ln673">static void funccal_unref(funccall_T *fc, ufunc_T *fp, bool force)</a>
<a name="ln674">{</a>
<a name="ln675">  funccall_T **pfc;</a>
<a name="ln676">  int i;</a>
<a name="ln677"> </a>
<a name="ln678">  if (fc == NULL) {</a>
<a name="ln679">    return;</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  fc-&gt;fc_refcount--;</a>
<a name="ln683">  if (force ? fc-&gt;fc_refcount &lt;= 0 : !fc_referenced(fc)) {</a>
<a name="ln684">    for (pfc = &amp;previous_funccal; *pfc != NULL; pfc = &amp;(*pfc)-&gt;caller) {</a>
<a name="ln685">      if (fc == *pfc) {</a>
<a name="ln686">        *pfc = fc-&gt;caller;</a>
<a name="ln687">        free_funccal_contents(fc);</a>
<a name="ln688">        return;</a>
<a name="ln689">      }</a>
<a name="ln690">    }</a>
<a name="ln691">  }</a>
<a name="ln692">  for (i = 0; i &lt; fc-&gt;fc_funcs.ga_len; i++) {</a>
<a name="ln693">    if (((ufunc_T **)(fc-&gt;fc_funcs.ga_data))[i] == fp) {</a>
<a name="ln694">      ((ufunc_T **)(fc-&gt;fc_funcs.ga_data))[i] = NULL;</a>
<a name="ln695">    }</a>
<a name="ln696">  }</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">/// Remove the function from the function hashtable.  If the function was</a>
<a name="ln700">/// deleted while it still has references this was already done.</a>
<a name="ln701">///</a>
<a name="ln702">/// @return true if the entry was deleted, false if it wasn't found.</a>
<a name="ln703">static bool func_remove(ufunc_T *fp)</a>
<a name="ln704">{</a>
<a name="ln705">  hashitem_T *hi = hash_find(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln706"> </a>
<a name="ln707">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln708">    hash_remove(&amp;func_hashtab, hi);</a>
<a name="ln709">    return true;</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  return false;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">static void func_clear_items(ufunc_T *fp)</a>
<a name="ln716">{</a>
<a name="ln717">  ga_clear_strings(&amp;(fp-&gt;uf_args));</a>
<a name="ln718">  ga_clear_strings(&amp;(fp-&gt;uf_lines));</a>
<a name="ln719"> </a>
<a name="ln720">  if (fp-&gt;uf_cb_free != NULL) {</a>
<a name="ln721">    fp-&gt;uf_cb_free(fp-&gt;uf_cb_state);</a>
<a name="ln722">    fp-&gt;uf_cb_free = NULL;</a>
<a name="ln723">  }</a>
<a name="ln724"> </a>
<a name="ln725">  XFREE_CLEAR(fp-&gt;uf_tml_count);</a>
<a name="ln726">  XFREE_CLEAR(fp-&gt;uf_tml_total);</a>
<a name="ln727">  XFREE_CLEAR(fp-&gt;uf_tml_self);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">/// Free all things that a function contains. Does not free the function</a>
<a name="ln731">/// itself, use func_free() for that.</a>
<a name="ln732">///</a>
<a name="ln733">/// param[in]        force        When true, we are exiting.</a>
<a name="ln734">static void func_clear(ufunc_T *fp, bool force)</a>
<a name="ln735">{</a>
<a name="ln736">  if (fp-&gt;uf_cleared) {</a>
<a name="ln737">    return;</a>
<a name="ln738">  }</a>
<a name="ln739">  fp-&gt;uf_cleared = true;</a>
<a name="ln740"> </a>
<a name="ln741">  // clear this function</a>
<a name="ln742">  func_clear_items(fp);</a>
<a name="ln743">  funccal_unref(fp-&gt;uf_scoped, fp, force);</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">/// Free a function and remove it from the list of functions. Does not free</a>
<a name="ln747">/// what a function contains, call func_clear() first.</a>
<a name="ln748">///</a>
<a name="ln749">/// param[in]        fp        The function to free.</a>
<a name="ln750">static void func_free(ufunc_T *fp)</a>
<a name="ln751">{</a>
<a name="ln752">  // only remove it when not done already, otherwise we would remove a newer</a>
<a name="ln753">  // version of the function</a>
<a name="ln754">  if ((fp-&gt;uf_flags &amp; (FC_DELETED | FC_REMOVED)) == 0) {</a>
<a name="ln755">    func_remove(fp);</a>
<a name="ln756">  }</a>
<a name="ln757">  xfree(fp);</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">/// Free all things that a function contains and free the function itself.</a>
<a name="ln761">///</a>
<a name="ln762">/// param[in]        force        When true, we are exiting.</a>
<a name="ln763">static void func_clear_free(ufunc_T *fp, bool force)</a>
<a name="ln764">{</a>
<a name="ln765">  func_clear(fp, force);</a>
<a name="ln766">  func_free(fp);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">/// Call a user function</a>
<a name="ln770">///</a>
<a name="ln771">/// @param  fp  Function to call.</a>
<a name="ln772">/// @param[in]  argcount  Number of arguments.</a>
<a name="ln773">/// @param  argvars  Arguments.</a>
<a name="ln774">/// @param[out]  rettv  Return value.</a>
<a name="ln775">/// @param[in]  firstline  First line of range.</a>
<a name="ln776">/// @param[in]  lastline  Last line of range.</a>
<a name="ln777">/// @param  selfdict  Dictionary for &quot;self&quot; for dictionary functions.</a>
<a name="ln778">void call_user_func(ufunc_T *fp, int argcount, typval_T *argvars,</a>
<a name="ln779">                    typval_T *rettv, linenr_T firstline, linenr_T lastline,</a>
<a name="ln780">                    dict_T *selfdict)</a>
<a name="ln781">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln782">{</a>
<a name="ln783">  char_u      *save_sourcing_name;</a>
<a name="ln784">  linenr_T save_sourcing_lnum;</a>
<a name="ln785">  bool using_sandbox = false;</a>
<a name="ln786">  funccall_T  *fc;</a>
<a name="ln787">  int save_did_emsg;</a>
<a name="ln788">  static int depth = 0;</a>
<a name="ln789">  dictitem_T  *v;</a>
<a name="ln790">  int fixvar_idx = 0;           // index in fixvar[]</a>
<a name="ln791">  int ai;</a>
<a name="ln792">  bool islambda = false;</a>
<a name="ln793">  char_u numbuf[NUMBUFLEN];</a>
<a name="ln794">  char_u      *name;</a>
<a name="ln795">  proftime_T wait_start;</a>
<a name="ln796">  proftime_T call_start;</a>
<a name="ln797">  int started_profiling = false;</a>
<a name="ln798">  bool did_save_redo = false;</a>
<a name="ln799">  save_redo_T save_redo;</a>
<a name="ln800"> </a>
<a name="ln801">  // If depth of calling is getting too high, don't execute the function</a>
<a name="ln802">  if (depth &gt;= p_mfd) {</a>
<a name="ln803">    EMSG(_(&quot;E132: Function call depth is higher than 'maxfuncdepth'&quot;));</a>
<a name="ln804">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln805">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln806">    return;</a>
<a name="ln807">  }</a>
<a name="ln808">  ++depth;</a>
<a name="ln809">  // Save search patterns and redo buffer.</a>
<a name="ln810">  save_search_patterns();</a>
<a name="ln811">  if (!ins_compl_active()) {</a>
<a name="ln812">    saveRedobuff(&amp;save_redo);</a>
<a name="ln813">    did_save_redo = true;</a>
<a name="ln814">  }</a>
<a name="ln815">  ++fp-&gt;uf_calls;</a>
<a name="ln816">  // check for CTRL-C hit</a>
<a name="ln817">  line_breakcheck();</a>
<a name="ln818">  // prepare the funccall_T structure</a>
<a name="ln819">  fc = xcalloc(1, sizeof(funccall_T));</a>
<a name="ln820">  fc-&gt;caller = current_funccal;</a>
<a name="ln821">  current_funccal = fc;</a>
<a name="ln822">  fc-&gt;func = fp;</a>
<a name="ln823">  fc-&gt;rettv = rettv;</a>
<a name="ln824">  fc-&gt;level = ex_nesting_level;</a>
<a name="ln825">  // Check if this function has a breakpoint.</a>
<a name="ln826">  fc-&gt;breakpoint = dbg_find_breakpoint(false, fp-&gt;uf_name, (linenr_T)0);</a>
<a name="ln827">  fc-&gt;dbg_tick = debug_tick;</a>
<a name="ln828"> </a>
<a name="ln829">  // Set up fields for closure.</a>
<a name="ln830">  ga_init(&amp;fc-&gt;fc_funcs, sizeof(ufunc_T *), 1);</a>
<a name="ln831">  func_ptr_ref(fp);</a>
<a name="ln832"> </a>
<a name="ln833">  if (STRNCMP(fp-&gt;uf_name, &quot;&lt;lambda&gt;&quot;, 8) == 0) {</a>
<a name="ln834">    islambda = true;</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  // Note about using fc-&gt;fixvar[]: This is an array of FIXVAR_CNT variables</a>
<a name="ln838">  // with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free</a>
<a name="ln839">  // each argument variable and saves a lot of time.</a>
<a name="ln840">  //</a>
<a name="ln841">  // Init l: variables.</a>
<a name="ln842">  init_var_dict(&amp;fc-&gt;l_vars, &amp;fc-&gt;l_vars_var, VAR_DEF_SCOPE);</a>
<a name="ln843">  if (selfdict != NULL) {</a>
<a name="ln844">    // Set l:self to &quot;selfdict&quot;.  Use &quot;name&quot; to avoid a warning from</a>
<a name="ln845">    // some compiler that checks the destination size.</a>
<a name="ln846">    v = (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++];</a>
<a name="ln847">#ifndef __clang_analyzer__</a>
<a name="ln848">    name = v-&gt;di_key;</a>
<a name="ln849">    STRCPY(name, &quot;self&quot;);</a>
<a name="ln850">#endif</a>
<a name="ln851">    v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln852">    tv_dict_add(&amp;fc-&gt;l_vars, v);</a>
<a name="ln853">    v-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln854">    v-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln855">    v-&gt;di_tv.vval.v_dict = selfdict;</a>
<a name="ln856">    ++selfdict-&gt;dv_refcount;</a>
<a name="ln857">  }</a>
<a name="ln858"> </a>
<a name="ln859">  // Init a: variables, unless none found (in lambda).</a>
<a name="ln860">  // Set a:0 to &quot;argcount&quot;.</a>
<a name="ln861">  // Set a:000 to a list with room for the &quot;...&quot; arguments.</a>
<a name="ln862">  init_var_dict(&amp;fc-&gt;l_avars, &amp;fc-&gt;l_avars_var, VAR_SCOPE);</a>
<a name="ln863">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln864">    add_nr_var(&amp;fc-&gt;l_avars, (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++], &quot;0&quot;,</a>
<a name="ln865">               (varnumber_T)(argcount - fp-&gt;uf_args.ga_len));</a>
<a name="ln866">  }</a>
<a name="ln867">  fc-&gt;l_avars.dv_lock = VAR_FIXED;</a>
<a name="ln868">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln869">    // Use &quot;name&quot; to avoid a warning from some compiler that checks the</a>
<a name="ln870">    // destination size.</a>
<a name="ln871">    v = (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++];</a>
<a name="ln872">#ifndef __clang_analyzer__</a>
<a name="ln873">    name = v-&gt;di_key;</a>
<a name="ln874">    STRCPY(name, &quot;000&quot;);</a>
<a name="ln875">#endif</a>
<a name="ln876">    v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln877">    tv_dict_add(&amp;fc-&gt;l_avars, v);</a>
<a name="ln878">    v-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln879">    v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln880">    v-&gt;di_tv.vval.v_list = &amp;fc-&gt;l_varlist;</a>
<a name="ln881">  }</a>
<a name="ln882">  tv_list_init_static(&amp;fc-&gt;l_varlist);</a>
<a name="ln883">  tv_list_set_lock(&amp;fc-&gt;l_varlist, VAR_FIXED);</a>
<a name="ln884"> </a>
<a name="ln885">  // Set a:firstline to &quot;firstline&quot; and a:lastline to &quot;lastline&quot;.</a>
<a name="ln886">  // Set a:name to named arguments.</a>
<a name="ln887">  // Set a:N to the &quot;...&quot; arguments.</a>
<a name="ln888">  // Skipped when no a: variables used (in lambda).</a>
<a name="ln889">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln890">    add_nr_var(&amp;fc-&gt;l_avars, (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++],</a>
<a name="ln891">               &quot;firstline&quot;, (varnumber_T)firstline);</a>
<a name="ln892">    add_nr_var(&amp;fc-&gt;l_avars, (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++],</a>
<a name="ln893">               &quot;lastline&quot;, (varnumber_T)lastline);</a>
<a name="ln894">  }</a>
<a name="ln895">  for (int i = 0; i &lt; argcount; i++) {</a>
<a name="ln896">    bool addlocal = false;</a>
<a name="ln897"> </a>
<a name="ln898">    ai = i - fp-&gt;uf_args.ga_len;</a>
<a name="ln899">    if (ai &lt; 0) {</a>
<a name="ln900">      // named argument a:name</a>
<a name="ln901">      name = FUNCARG(fp, i);</a>
<a name="ln902">      if (islambda) {</a>
<a name="ln903">        addlocal = true;</a>
<a name="ln904">      }</a>
<a name="ln905">    } else {</a>
<a name="ln906">      if ((fp-&gt;uf_flags &amp; FC_NOARGS) != 0) {</a>
<a name="ln907">        // Bail out if no a: arguments used (in lambda).</a>
<a name="ln908">        break;</a>
<a name="ln909">      }</a>
<a name="ln910">      // &quot;...&quot; argument a:1, a:2, etc.</a>
<a name="ln911">      snprintf((char *)numbuf, sizeof(numbuf), &quot;%d&quot;, ai + 1);</a>
<a name="ln912">      name = numbuf;</a>
<a name="ln913">    }</a>
<a name="ln914">    if (fixvar_idx &lt; FIXVAR_CNT &amp;&amp; STRLEN(name) &lt;= VAR_SHORT_LEN) {</a>
<a name="ln915">      v = (dictitem_T *)&amp;fc-&gt;fixvar[fixvar_idx++];</a>
<a name="ln916">      v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln917">    } else {</a>
<a name="ln918">      v = xmalloc(sizeof(dictitem_T) + STRLEN(name));</a>
<a name="ln919">      v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX | DI_FLAGS_ALLOC;</a>
<a name="ln920">    }</a>
<a name="ln921">    STRCPY(v-&gt;di_key, name);</a>
<a name="ln922"> </a>
<a name="ln923">    // Note: the values are copied directly to avoid alloc/free.</a>
<a name="ln924">    // &quot;argvars&quot; must have VAR_FIXED for v_lock.</a>
<a name="ln925">    v-&gt;di_tv = argvars[i];</a>
<a name="ln926">    v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln927"> </a>
<a name="ln928">    if (addlocal) {</a>
<a name="ln929">      // Named arguments can be accessed without the &quot;a:&quot; prefix in lambda</a>
<a name="ln930">      // expressions. Add to the l: dict.</a>
<a name="ln931">      tv_copy(&amp;v-&gt;di_tv, &amp;v-&gt;di_tv);</a>
<a name="ln932">      tv_dict_add(&amp;fc-&gt;l_vars, v);</a>
<a name="ln933">    } else {</a>
<a name="ln934">      tv_dict_add(&amp;fc-&gt;l_avars, v);</a>
<a name="ln935">    }</a>
<a name="ln936"> </a>
<a name="ln937">    if (ai &gt;= 0 &amp;&amp; ai &lt; MAX_FUNC_ARGS) {</a>
<a name="ln938">      listitem_T *li = &amp;fc-&gt;l_listitems[ai];</a>
<a name="ln939"> </a>
<a name="ln940">      *TV_LIST_ITEM_TV(li) = argvars[i];</a>
<a name="ln941">      TV_LIST_ITEM_TV(li)-&gt;v_lock =  VAR_FIXED;</a>
<a name="ln942">      tv_list_append(&amp;fc-&gt;l_varlist, li);</a>
<a name="ln943">    }</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">  // Don't redraw while executing the function.</a>
<a name="ln947">  RedrawingDisabled++;</a>
<a name="ln948">  save_sourcing_name = sourcing_name;</a>
<a name="ln949">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln950">  sourcing_lnum = 1;</a>
<a name="ln951"> </a>
<a name="ln952">  if (fp-&gt;uf_flags &amp; FC_SANDBOX) {</a>
<a name="ln953">    using_sandbox = true;</a>
<a name="ln954">    sandbox++;</a>
<a name="ln955">  }</a>
<a name="ln956"> </a>
<a name="ln957">  // need space for new sourcing_name:</a>
<a name="ln958">  // * save_sourcing_name</a>
<a name="ln959">  // * &quot;[&quot;number&quot;]..&quot; or &quot;function &quot;</a>
<a name="ln960">  // * &quot;&lt;SNR&gt;&quot; + fp-&gt;uf_name - 3</a>
<a name="ln961">  // * terminating NUL</a>
<a name="ln962">  size_t len = (save_sourcing_name == NULL ? 0 : STRLEN(save_sourcing_name))</a>
<a name="ln963">               + STRLEN(fp-&gt;uf_name) + 27;</a>
<a name="ln964">  sourcing_name = xmalloc(len);</a>
<a name="ln965">  {</a>
<a name="ln966">    if (save_sourcing_name != NULL</a>
<a name="ln967">        &amp;&amp; STRNCMP(save_sourcing_name, &quot;function &quot;, 9) == 0) {</a>
<a name="ln968">      vim_snprintf((char *)sourcing_name,</a>
<a name="ln969">                   len,</a>
<a name="ln970">                   &quot;%s[%&quot; PRId64 &quot;]..&quot;,</a>
<a name="ln971">                   save_sourcing_name,</a>
<a name="ln972">                   (int64_t)save_sourcing_lnum);</a>
<a name="ln973">    } else {</a>
<a name="ln974">      STRCPY(sourcing_name, &quot;function &quot;);</a>
<a name="ln975">    }</a>
<a name="ln976">    cat_func_name(sourcing_name + STRLEN(sourcing_name), fp);</a>
<a name="ln977"> </a>
<a name="ln978">    if (p_verbose &gt;= 12) {</a>
<a name="ln979">      ++no_wait_return;</a>
<a name="ln980">      verbose_enter_scroll();</a>
<a name="ln981"> </a>
<a name="ln982">      smsg(_(&quot;calling %s&quot;), sourcing_name);</a>
<a name="ln983">      if (p_verbose &gt;= 14) {</a>
<a name="ln984">        msg_puts(&quot;(&quot;);</a>
<a name="ln985">        for (int i = 0; i &lt; argcount; i++) {</a>
<a name="ln986">          if (i &gt; 0) {</a>
<a name="ln987">            msg_puts(&quot;, &quot;);</a>
<a name="ln988">          }</a>
<a name="ln989">          if (argvars[i].v_type == VAR_NUMBER) {</a>
<a name="ln990">            msg_outnum((long)argvars[i].vval.v_number);</a>
<a name="ln991">          } else {</a>
<a name="ln992">            // Do not want errors such as E724 here.</a>
<a name="ln993">            emsg_off++;</a>
<a name="ln994">            char *tofree = encode_tv2string(&amp;argvars[i], NULL);</a>
<a name="ln995">            emsg_off--;</a>
<a name="ln996">            if (tofree != NULL) {</a>
<a name="ln997">              char *s = tofree;</a>
<a name="ln998">              char buf[MSG_BUF_LEN];</a>
<a name="ln999">              if (vim_strsize((char_u *)s) &gt; MSG_BUF_CLEN) {</a>
<a name="ln1000">                trunc_string((char_u *)s, (char_u *)buf, MSG_BUF_CLEN,</a>
<a name="ln1001">                             sizeof(buf));</a>
<a name="ln1002">                s = buf;</a>
<a name="ln1003">              }</a>
<a name="ln1004">              msg_puts(s);</a>
<a name="ln1005">              xfree(tofree);</a>
<a name="ln1006">            }</a>
<a name="ln1007">          }</a>
<a name="ln1008">        }</a>
<a name="ln1009">        msg_puts(&quot;)&quot;);</a>
<a name="ln1010">      }</a>
<a name="ln1011">      msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1012"> </a>
<a name="ln1013">      verbose_leave_scroll();</a>
<a name="ln1014">      --no_wait_return;</a>
<a name="ln1015">    }</a>
<a name="ln1016">  }</a>
<a name="ln1017"> </a>
<a name="ln1018">  const bool do_profiling_yes = do_profiling == PROF_YES;</a>
<a name="ln1019"> </a>
<a name="ln1020">  bool func_not_yet_profiling_but_should =</a>
<a name="ln1021">    do_profiling_yes</a>
<a name="ln1022">    &amp;&amp; !fp-&gt;uf_profiling &amp;&amp; has_profiling(false, fp-&gt;uf_name, NULL);</a>
<a name="ln1023"> </a>
<a name="ln1024">  if (func_not_yet_profiling_but_should) {</a>
<a name="ln1025">    started_profiling = true;</a>
<a name="ln1026">    func_do_profile(fp);</a>
<a name="ln1027">  }</a>
<a name="ln1028"> </a>
<a name="ln1029">  bool func_or_func_caller_profiling =</a>
<a name="ln1030">    do_profiling_yes</a>
<a name="ln1031">    &amp;&amp; (fp-&gt;uf_profiling</a>
<a name="ln1032">        || (fc-&gt;caller != NULL &amp;&amp; fc-&gt;caller-&gt;func-&gt;uf_profiling));</a>
<a name="ln1033"> </a>
<a name="ln1034">  if (func_or_func_caller_profiling) {</a>
<a name="ln1035">    ++fp-&gt;uf_tm_count;</a>
<a name="ln1036">    call_start = profile_start();</a>
<a name="ln1037">    fp-&gt;uf_tm_children = profile_zero();</a>
<a name="ln1038">  }</a>
<a name="ln1039"> </a>
<a name="ln1040">  if (do_profiling_yes) {</a>
<a name="ln1041">    script_prof_save(&amp;wait_start);</a>
<a name="ln1042">  }</a>
<a name="ln1043"> </a>
<a name="ln1044">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln1045">  current_sctx = fp-&gt;uf_script_ctx;</a>
<a name="ln1046">  save_did_emsg = did_emsg;</a>
<a name="ln1047">  did_emsg = FALSE;</a>
<a name="ln1048"> </a>
<a name="ln1049">  if (islambda) {</a>
<a name="ln1050">    char_u *p = *(char_u **)fp-&gt;uf_lines.ga_data + 7;</a>
<a name="ln1051"> </a>
<a name="ln1052">    // A Lambda always has the command &quot;return {expr}&quot;.  It is much faster</a>
<a name="ln1053">    // to evaluate {expr} directly.</a>
<a name="ln1054">    ex_nesting_level++;</a>
<a name="ln1055">    (void)eval1(&amp;p, rettv, true);</a>
<a name="ln1056">    ex_nesting_level--;</a>
<a name="ln1057">  } else {</a>
<a name="ln1058">    // call do_cmdline() to execute the lines</a>
<a name="ln1059">    do_cmdline(NULL, get_func_line, (void *)fc,</a>
<a name="ln1060">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  --RedrawingDisabled;</a>
<a name="ln1064"> </a>
<a name="ln1065">  // when the function was aborted because of an error, return -1</a>
<a name="ln1066">  if ((did_emsg</a>
<a name="ln1067">       &amp;&amp; (fp-&gt;uf_flags &amp; FC_ABORT)) || rettv-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln1068">    tv_clear(rettv);</a>
<a name="ln1069">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1070">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  if (func_or_func_caller_profiling) {</a>
<a name="ln1074">    call_start = profile_end(call_start);</a>
<a name="ln1075">    call_start = profile_sub_wait(wait_start, call_start);  // -V614</a>
<a name="ln1076">    fp-&gt;uf_tm_total = profile_add(fp-&gt;uf_tm_total, call_start);</a>
<a name="ln1077">    fp-&gt;uf_tm_self = profile_self(fp-&gt;uf_tm_self, call_start,</a>
<a name="ln1078">        fp-&gt;uf_tm_children);</a>
<a name="ln1079">    if (fc-&gt;caller != NULL &amp;&amp; fc-&gt;caller-&gt;func-&gt;uf_profiling) {</a>
<a name="ln1080">      fc-&gt;caller-&gt;func-&gt;uf_tm_children =</a>
<a name="ln1081">        profile_add(fc-&gt;caller-&gt;func-&gt;uf_tm_children, call_start);</a>
<a name="ln1082">      fc-&gt;caller-&gt;func-&gt;uf_tml_children =</a>
<a name="ln1083">        profile_add(fc-&gt;caller-&gt;func-&gt;uf_tml_children, call_start);</a>
<a name="ln1084">    }</a>
<a name="ln1085">    if (started_profiling) {</a>
<a name="ln1086">      // make a &quot;:profdel func&quot; stop profiling the function</a>
<a name="ln1087">      fp-&gt;uf_profiling = false;</a>
<a name="ln1088">    }</a>
<a name="ln1089">  }</a>
<a name="ln1090"> </a>
<a name="ln1091">  // when being verbose, mention the return value</a>
<a name="ln1092">  if (p_verbose &gt;= 12) {</a>
<a name="ln1093">    ++no_wait_return;</a>
<a name="ln1094">    verbose_enter_scroll();</a>
<a name="ln1095"> </a>
<a name="ln1096">    if (aborting())</a>
<a name="ln1097">      smsg(_(&quot;%s aborted&quot;), sourcing_name);</a>
<a name="ln1098">    else if (fc-&gt;rettv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln1099">      smsg(_(&quot;%s returning #%&quot; PRId64 &quot;&quot;),</a>
<a name="ln1100">           sourcing_name, (int64_t)fc-&gt;rettv-&gt;vval.v_number);</a>
<a name="ln1101">    else {</a>
<a name="ln1102">      char_u buf[MSG_BUF_LEN];</a>
<a name="ln1103"> </a>
<a name="ln1104">      // The value may be very long.  Skip the middle part, so that we</a>
<a name="ln1105">      // have some idea how it starts and ends. smsg() would always</a>
<a name="ln1106">      // truncate it at the end. Don't want errors such as E724 here.</a>
<a name="ln1107">      emsg_off++;</a>
<a name="ln1108">      char_u *s = (char_u *) encode_tv2string(fc-&gt;rettv, NULL);</a>
<a name="ln1109">      char_u *tofree = s;</a>
<a name="ln1110">      emsg_off--;</a>
<a name="ln1111">      if (s != NULL) {</a>
<a name="ln1112">        if (vim_strsize(s) &gt; MSG_BUF_CLEN) {</a>
<a name="ln1113">          trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);</a>
<a name="ln1114">          s = buf;</a>
<a name="ln1115">        }</a>
<a name="ln1116">        smsg(_(&quot;%s returning %s&quot;), sourcing_name, s);</a>
<a name="ln1117">        xfree(tofree);</a>
<a name="ln1118">      }</a>
<a name="ln1119">    }</a>
<a name="ln1120">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1121"> </a>
<a name="ln1122">    verbose_leave_scroll();</a>
<a name="ln1123">    --no_wait_return;</a>
<a name="ln1124">  }</a>
<a name="ln1125"> </a>
<a name="ln1126">  xfree(sourcing_name);</a>
<a name="ln1127">  sourcing_name = save_sourcing_name;</a>
<a name="ln1128">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln1129">  current_sctx = save_current_sctx;</a>
<a name="ln1130">  if (do_profiling_yes) {</a>
<a name="ln1131">    script_prof_restore(&amp;wait_start);</a>
<a name="ln1132">  }</a>
<a name="ln1133">  if (using_sandbox) {</a>
<a name="ln1134">    sandbox--;</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  if (p_verbose &gt;= 12 &amp;&amp; sourcing_name != NULL) {</a>
<a name="ln1138">    ++no_wait_return;</a>
<a name="ln1139">    verbose_enter_scroll();</a>
<a name="ln1140"> </a>
<a name="ln1141">    smsg(_(&quot;continuing in %s&quot;), sourcing_name);</a>
<a name="ln1142">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1143"> </a>
<a name="ln1144">    verbose_leave_scroll();</a>
<a name="ln1145">    --no_wait_return;</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  did_emsg |= save_did_emsg;</a>
<a name="ln1149">  depth--;</a>
<a name="ln1150"> </a>
<a name="ln1151">  cleanup_function_call(fc);</a>
<a name="ln1152"> </a>
<a name="ln1153">  if (--fp-&gt;uf_calls &lt;= 0 &amp;&amp; fp-&gt;uf_refcount &lt;= 0) {</a>
<a name="ln1154">    // Function was unreferenced while being used, free it now.</a>
<a name="ln1155">    func_clear_free(fp, false);</a>
<a name="ln1156">  }</a>
<a name="ln1157">  // restore search patterns and redo buffer</a>
<a name="ln1158">  if (did_save_redo) {</a>
<a name="ln1159">    restoreRedobuff(&amp;save_redo);</a>
<a name="ln1160">  }</a>
<a name="ln1161">  restore_search_patterns();</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">/// There are two kinds of function names:</a>
<a name="ln1165">/// 1. ordinary names, function defined with :function</a>
<a name="ln1166">/// 2. numbered functions and lambdas</a>
<a name="ln1167">/// For the first we only count the name stored in func_hashtab as a reference,</a>
<a name="ln1168">/// using function() does not count as a reference, because the function is</a>
<a name="ln1169">/// looked up by name.</a>
<a name="ln1170">static bool func_name_refcount(char_u *name)</a>
<a name="ln1171">{</a>
<a name="ln1172">  return isdigit(*name) || *name == '&lt;';</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">static funccal_entry_T *funccal_stack = NULL;</a>
<a name="ln1176"> </a>
<a name="ln1177">// Save the current function call pointer, and set it to NULL.</a>
<a name="ln1178">// Used when executing autocommands and for &quot;:source&quot;.</a>
<a name="ln1179">void save_funccal(funccal_entry_T *entry)</a>
<a name="ln1180">{</a>
<a name="ln1181">  entry-&gt;top_funccal = current_funccal;</a>
<a name="ln1182">  entry-&gt;next = funccal_stack;</a>
<a name="ln1183">  funccal_stack = entry;</a>
<a name="ln1184">  current_funccal = NULL;</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">void restore_funccal(void)</a>
<a name="ln1188">{</a>
<a name="ln1189">  if (funccal_stack == NULL) {</a>
<a name="ln1190">    IEMSG(&quot;INTERNAL: restore_funccal()&quot;);</a>
<a name="ln1191">  } else {</a>
<a name="ln1192">    current_funccal = funccal_stack-&gt;top_funccal;</a>
<a name="ln1193">    funccal_stack = funccal_stack-&gt;next;</a>
<a name="ln1194">  }</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">funccall_T *get_current_funccal(void)</a>
<a name="ln1198">{</a>
<a name="ln1199">  return current_funccal;</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">void set_current_funccal(funccall_T *fc)</a>
<a name="ln1203">{</a>
<a name="ln1204">  current_funccal = fc;</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">#if defined(EXITFREE)</a>
<a name="ln1208">void free_all_functions(void)</a>
<a name="ln1209">{</a>
<a name="ln1210">  hashitem_T  *hi;</a>
<a name="ln1211">  ufunc_T     *fp;</a>
<a name="ln1212">  uint64_t skipped = 0;</a>
<a name="ln1213">  uint64_t todo = 1;</a>
<a name="ln1214">  uint64_t used;</a>
<a name="ln1215"> </a>
<a name="ln1216">  // Clean up the current_funccal chain and the funccal stack.</a>
<a name="ln1217">  while (current_funccal != NULL) {</a>
<a name="ln1218">    tv_clear(current_funccal-&gt;rettv);</a>
<a name="ln1219">    cleanup_function_call(current_funccal);</a>
<a name="ln1220">    if (current_funccal == NULL &amp;&amp; funccal_stack != NULL) {</a>
<a name="ln1221">      restore_funccal();</a>
<a name="ln1222">    }</a>
<a name="ln1223">  }</a>
<a name="ln1224"> </a>
<a name="ln1225">  // First clear what the functions contain. Since this may lower the</a>
<a name="ln1226">  // reference count of a function, it may also free a function and change</a>
<a name="ln1227">  // the hash table. Restart if that happens.</a>
<a name="ln1228">  while (todo &gt; 0) {</a>
<a name="ln1229">    todo = func_hashtab.ht_used;</a>
<a name="ln1230">    for (hi = func_hashtab.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln1231">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1232">        // Only free functions that are not refcounted, those are</a>
<a name="ln1233">        // supposed to be freed when no longer referenced.</a>
<a name="ln1234">        fp = HI2UF(hi);</a>
<a name="ln1235">        if (func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln1236">          skipped++;</a>
<a name="ln1237">        } else {</a>
<a name="ln1238">          used = func_hashtab.ht_used;</a>
<a name="ln1239">          func_clear(fp, true);</a>
<a name="ln1240">          if (used != func_hashtab.ht_used) {</a>
<a name="ln1241">            skipped = 0;</a>
<a name="ln1242">            break;</a>
<a name="ln1243">          }</a>
<a name="ln1244">        }</a>
<a name="ln1245">        todo--;</a>
<a name="ln1246">      }</a>
<a name="ln1247">    }</a>
<a name="ln1248">  }</a>
<a name="ln1249"> </a>
<a name="ln1250">  // Now actually free the functions. Need to start all over every time,</a>
<a name="ln1251">  // because func_free() may change the hash table.</a>
<a name="ln1252">  skipped = 0;</a>
<a name="ln1253">  while (func_hashtab.ht_used &gt; skipped) {</a>
<a name="ln1254">    todo = func_hashtab.ht_used;</a>
<a name="ln1255">    for (hi = func_hashtab.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln1256">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1257">        todo--;</a>
<a name="ln1258">        // Only free functions that are not refcounted, those are</a>
<a name="ln1259">        // supposed to be freed when no longer referenced.</a>
<a name="ln1260">        fp = HI2UF(hi);</a>
<a name="ln1261">        if (func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln1262">          skipped++;</a>
<a name="ln1263">        } else {</a>
<a name="ln1264">          func_free(fp);</a>
<a name="ln1265">          skipped = 0;</a>
<a name="ln1266">          break;</a>
<a name="ln1267">        }</a>
<a name="ln1268">      }</a>
<a name="ln1269">    }</a>
<a name="ln1270">  }</a>
<a name="ln1271">  if (skipped == 0) {</a>
<a name="ln1272">    hash_clear(&amp;func_hashtab);</a>
<a name="ln1273">  }</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">#endif</a>
<a name="ln1277"> </a>
<a name="ln1278">/// Checks if a builtin function with the given name exists.</a>
<a name="ln1279">///</a>
<a name="ln1280">/// @param[in]   name   name of the builtin function to check.</a>
<a name="ln1281">/// @param[in]   len    length of &quot;name&quot;, or -1 for NUL terminated.</a>
<a name="ln1282">///</a>
<a name="ln1283">/// @return true if &quot;name&quot; looks like a builtin function name: starts with a</a>
<a name="ln1284">/// lower case letter and doesn't contain AUTOLOAD_CHAR.</a>
<a name="ln1285">static bool builtin_function(const char *name, int len)</a>
<a name="ln1286">{</a>
<a name="ln1287">  if (!ASCII_ISLOWER(name[0])) {</a>
<a name="ln1288">    return false;</a>
<a name="ln1289">  }</a>
<a name="ln1290"> </a>
<a name="ln1291">  const char *p = (len == -1</a>
<a name="ln1292">                   ? strchr(name, AUTOLOAD_CHAR)</a>
<a name="ln1293">                   : memchr(name, AUTOLOAD_CHAR, (size_t)len));</a>
<a name="ln1294"> </a>
<a name="ln1295">  return p == NULL;</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">int func_call(char_u *name, typval_T *args, partial_T *partial,</a>
<a name="ln1299">              dict_T *selfdict, typval_T *rettv)</a>
<a name="ln1300">{</a>
<a name="ln1301">  typval_T argv[MAX_FUNC_ARGS + 1];</a>
<a name="ln1302">  int argc = 0;</a>
<a name="ln1303">  int dummy;</a>
<a name="ln1304">  int r = 0;</a>
<a name="ln1305"> </a>
<a name="ln1306">  TV_LIST_ITER(args-&gt;vval.v_list, item, {</a>
<a name="ln1307">    if (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial-&gt;pt_argc)) {</a>
<a name="ln1308">      EMSG(_(&quot;E699: Too many arguments&quot;));</a>
<a name="ln1309">      goto func_call_skip_call;</a>
<a name="ln1310">    }</a>
<a name="ln1311">    // Make a copy of each argument.  This is needed to be able to set</a>
<a name="ln1312">    // v_lock to VAR_FIXED in the copy without changing the original list.</a>
<a name="ln1313">    tv_copy(TV_LIST_ITEM_TV(item), &amp;argv[argc++]);</a>
<a name="ln1314">  });</a>
<a name="ln1315"> </a>
<a name="ln1316">  r = call_func(name, -1, rettv, argc, argv, NULL,</a>
<a name="ln1317">                curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln1318">                &amp;dummy, true, partial, selfdict);</a>
<a name="ln1319"> </a>
<a name="ln1320">func_call_skip_call:</a>
<a name="ln1321">  // Free the arguments.</a>
<a name="ln1322">  while (argc &gt; 0) {</a>
<a name="ln1323">    tv_clear(&amp;argv[--argc]);</a>
<a name="ln1324">  }</a>
<a name="ln1325"> </a>
<a name="ln1326">  return r;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">// Give an error message for the result of a function.</a>
<a name="ln1330">// Nothing if &quot;error&quot; is FCERR_NONE.</a>
<a name="ln1331">static void user_func_error(int error, const char_u *name)</a>
<a name="ln1332">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1333">{</a>
<a name="ln1334">  switch (error) {</a>
<a name="ln1335">    case ERROR_UNKNOWN:</a>
<a name="ln1336">      emsg_funcname(N_(&quot;E117: Unknown function: %s&quot;), name);</a>
<a name="ln1337">      break;</a>
<a name="ln1338">    case ERROR_DELETED:</a>
<a name="ln1339">      emsg_funcname(N_(&quot;E933: Function was deleted: %s&quot;), name);</a>
<a name="ln1340">      break;</a>
<a name="ln1341">    case ERROR_TOOMANY:</a>
<a name="ln1342">      emsg_funcname(_(e_toomanyarg), name);</a>
<a name="ln1343">      break;</a>
<a name="ln1344">    case ERROR_TOOFEW:</a>
<a name="ln1345">      emsg_funcname(N_(&quot;E119: Not enough arguments for function: %s&quot;),</a>
<a name="ln1346">          name);</a>
<a name="ln1347">      break;</a>
<a name="ln1348">    case ERROR_SCRIPT:</a>
<a name="ln1349">      emsg_funcname(N_(&quot;E120: Using &lt;SID&gt; not in a script context: %s&quot;),</a>
<a name="ln1350">          name);</a>
<a name="ln1351">      break;</a>
<a name="ln1352">    case ERROR_DICT:</a>
<a name="ln1353">      emsg_funcname(N_(&quot;E725: Calling dict function without Dictionary: %s&quot;),</a>
<a name="ln1354">          name);</a>
<a name="ln1355">      break;</a>
<a name="ln1356">  }</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">/// Call a function with its resolved parameters</a>
<a name="ln1360">///</a>
<a name="ln1361">/// &quot;argv_func&quot;, when not NULL, can be used to fill in arguments only when the</a>
<a name="ln1362">/// invoked function uses them. It is called like this:</a>
<a name="ln1363">///   new_argcount = argv_func(current_argcount, argv, called_func_argcount)</a>
<a name="ln1364">///</a>
<a name="ln1365">/// @return FAIL if function cannot be called, else OK (even if an error</a>
<a name="ln1366">///         occurred while executing the function! Set `msg_list` to capture</a>
<a name="ln1367">///         the error, see do_cmdline()).</a>
<a name="ln1368">int</a>
<a name="ln1369">call_func(</a>
<a name="ln1370">    const char_u *funcname,         // name of the function</a>
<a name="ln1371">    int len,                        // length of &quot;name&quot; or -1 to use strlen()</a>
<a name="ln1372">    typval_T *rettv,                // [out] value goes here</a>
<a name="ln1373">    int argcount_in,                // number of &quot;argvars&quot;</a>
<a name="ln1374">    typval_T *argvars_in,           // vars for arguments, must have &quot;argcount&quot;</a>
<a name="ln1375">                                    // PLUS ONE elements!</a>
<a name="ln1376">    ArgvFunc argv_func,             // function to fill in argvars</a>
<a name="ln1377">    linenr_T firstline,             // first line of range</a>
<a name="ln1378">    linenr_T lastline,              // last line of range</a>
<a name="ln1379">    int *doesrange,                 // [out] function handled range</a>
<a name="ln1380">    bool evaluate,</a>
<a name="ln1381">    partial_T *partial,             // optional, can be NULL</a>
<a name="ln1382">    dict_T *selfdict_in             // Dictionary for &quot;self&quot;</a>
<a name="ln1383">)</a>
<a name="ln1384">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 9)</a>
<a name="ln1385">{</a>
<a name="ln1386">  int ret = FAIL;</a>
<a name="ln1387">  int error = ERROR_NONE;</a>
<a name="ln1388">  ufunc_T *fp = NULL;</a>
<a name="ln1389">  char_u fname_buf[FLEN_FIXED + 1];</a>
<a name="ln1390">  char_u *tofree = NULL;</a>
<a name="ln1391">  char_u *fname = NULL;</a>
<a name="ln1392">  char_u *name = NULL;</a>
<a name="ln1393">  int argcount = argcount_in;</a>
<a name="ln1394">  typval_T *argvars = argvars_in;</a>
<a name="ln1395">  dict_T *selfdict = selfdict_in;</a>
<a name="ln1396">  typval_T argv[MAX_FUNC_ARGS + 1];  // used when &quot;partial&quot; is not NULL</a>
<a name="ln1397">  int argv_clear = 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">  // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)</a>
<a name="ln1400">  // even when call_func() returns FAIL.</a>
<a name="ln1401">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln1402"> </a>
<a name="ln1403">  if (len &lt;= 0) {</a>
<a name="ln1404">    len = (int)STRLEN(funcname);</a>
<a name="ln1405">  }</a>
<a name="ln1406">  if (partial != NULL) {</a>
<a name="ln1407">    fp = partial-&gt;pt_func;</a>
<a name="ln1408">  }</a>
<a name="ln1409">  if (fp == NULL) {</a>
<a name="ln1410">    // Make a copy of the name, if it comes from a funcref variable it could</a>
<a name="ln1411">    // be changed or deleted in the called function.</a>
<a name="ln1412">    name = vim_strnsave(funcname, len);</a>
<a name="ln1413">    fname = fname_trans_sid(name, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln1414">  }</a>
<a name="ln1415"> </a>
<a name="ln1416">  *doesrange = false;</a>
<a name="ln1417"> </a>
<a name="ln1418">  if (partial != NULL) {</a>
<a name="ln1419">    // When the function has a partial with a dict and there is a dict</a>
<a name="ln1420">    // argument, use the dict argument. That is backwards compatible.</a>
<a name="ln1421">    // When the dict was bound explicitly use the one from the partial.</a>
<a name="ln1422">    if (partial-&gt;pt_dict != NULL</a>
<a name="ln1423">        &amp;&amp; (selfdict_in == NULL || !partial-&gt;pt_auto)) {</a>
<a name="ln1424">      selfdict = partial-&gt;pt_dict;</a>
<a name="ln1425">    }</a>
<a name="ln1426">    if (error == ERROR_NONE &amp;&amp; partial-&gt;pt_argc &gt; 0) {</a>
<a name="ln1427">      for (argv_clear = 0; argv_clear &lt; partial-&gt;pt_argc; argv_clear++) {</a>
<a name="ln1428">        if (argv_clear + argcount_in &gt;= MAX_FUNC_ARGS) {</a>
<a name="ln1429">          error = ERROR_TOOMANY;</a>
<a name="ln1430">          goto theend;</a>
<a name="ln1431">        }</a>
<a name="ln1432">        tv_copy(&amp;partial-&gt;pt_argv[argv_clear], &amp;argv[argv_clear]);</a>
<a name="ln1433">      }</a>
<a name="ln1434">      for (int i = 0; i &lt; argcount_in; i++) {</a>
<a name="ln1435">        argv[i + argv_clear] = argvars_in[i];</a>
<a name="ln1436">      }</a>
<a name="ln1437">      argvars = argv;</a>
<a name="ln1438">      argcount = partial-&gt;pt_argc + argcount_in;</a>
<a name="ln1439">    }</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  if (error == ERROR_NONE &amp;&amp; evaluate) {</a>
<a name="ln1443">    char_u *rfname = fname;</a>
<a name="ln1444"> </a>
<a name="ln1445">    // Ignore &quot;g:&quot; before a function name.</a>
<a name="ln1446">    if (fp == NULL &amp;&amp; fname[0] == 'g' &amp;&amp; fname[1] == ':') {</a>
<a name="ln1447">      rfname = fname + 2;</a>
<a name="ln1448">    }</a>
<a name="ln1449"> </a>
<a name="ln1450">    rettv-&gt;v_type = VAR_NUMBER;         // default rettv is number zero</a>
<a name="ln1451">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1452">    error = ERROR_UNKNOWN;</a>
<a name="ln1453"> </a>
<a name="ln1454">    if (is_luafunc(partial)) {</a>
<a name="ln1455">      if (len &gt; 0) {</a>
<a name="ln1456">        error = ERROR_NONE;</a>
<a name="ln1457">        nlua_typval_call((const char *)funcname, len, argvars, argcount, rettv);</a>
<a name="ln1458">      }</a>
<a name="ln1459">    } else if (fp != NULL || !builtin_function((const char *)rfname, -1)) {</a>
<a name="ln1460">      // User defined function.</a>
<a name="ln1461">      if (fp == NULL) {</a>
<a name="ln1462">        fp = find_func(rfname);</a>
<a name="ln1463">      }</a>
<a name="ln1464"> </a>
<a name="ln1465">      // Trigger FuncUndefined event, may load the function.</a>
<a name="ln1466">      if (fp == NULL</a>
<a name="ln1467">          &amp;&amp; apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, TRUE, NULL)</a>
<a name="ln1468">          &amp;&amp; !aborting()) {</a>
<a name="ln1469">        // executed an autocommand, search for the function again</a>
<a name="ln1470">        fp = find_func(rfname);</a>
<a name="ln1471">      }</a>
<a name="ln1472">      // Try loading a package.</a>
<a name="ln1473">      if (fp == NULL &amp;&amp; script_autoload((const char *)rfname, STRLEN(rfname),</a>
<a name="ln1474">                                        true) &amp;&amp; !aborting()) {</a>
<a name="ln1475">        // Loaded a package, search for the function again.</a>
<a name="ln1476">        fp = find_func(rfname);</a>
<a name="ln1477">      }</a>
<a name="ln1478"> </a>
<a name="ln1479">      if (fp != NULL &amp;&amp; (fp-&gt;uf_flags &amp; FC_DELETED)) {</a>
<a name="ln1480">        error = ERROR_DELETED;</a>
<a name="ln1481">      } else if (fp != NULL &amp;&amp; (fp-&gt;uf_flags &amp; FC_CFUNC)) {</a>
<a name="ln1482">        cfunc_T cb = fp-&gt;uf_cb;</a>
<a name="ln1483">        error = (*cb)(argcount, argvars, rettv, fp-&gt;uf_cb_state);</a>
<a name="ln1484">      } else if (fp != NULL) {</a>
<a name="ln1485">        if (argv_func != NULL) {</a>
<a name="ln1486">          // postponed filling in the arguments, do it now</a>
<a name="ln1487">          argcount = argv_func(argcount, argvars, argv_clear,</a>
<a name="ln1488">                               fp-&gt;uf_args.ga_len);</a>
<a name="ln1489">        }</a>
<a name="ln1490">        if (fp-&gt;uf_flags &amp; FC_RANGE) {</a>
<a name="ln1491">          *doesrange = true;</a>
<a name="ln1492">        }</a>
<a name="ln1493">        if (argcount &lt; fp-&gt;uf_args.ga_len) {</a>
<a name="ln1494">          error = ERROR_TOOFEW;</a>
<a name="ln1495">        } else if (!fp-&gt;uf_varargs &amp;&amp; argcount &gt; fp-&gt;uf_args.ga_len) {</a>
<a name="ln1496">          error = ERROR_TOOMANY;</a>
<a name="ln1497">        } else if ((fp-&gt;uf_flags &amp; FC_DICT) &amp;&amp; selfdict == NULL) {</a>
<a name="ln1498">          error = ERROR_DICT;</a>
<a name="ln1499">        } else {</a>
<a name="ln1500">          // Call the user function.</a>
<a name="ln1501">          call_user_func(fp, argcount, argvars, rettv, firstline, lastline,</a>
<a name="ln1502">                         (fp-&gt;uf_flags &amp; FC_DICT) ? selfdict : NULL);</a>
<a name="ln1503">          error = ERROR_NONE;</a>
<a name="ln1504">        }</a>
<a name="ln1505">      }</a>
<a name="ln1506">    } else {</a>
<a name="ln1507">      // Find the function name in the table, call its implementation.</a>
<a name="ln1508">      const VimLFuncDef *const fdef = find_internal_func((const char *)fname);</a>
<a name="ln1509">      if (fdef != NULL) {</a>
<a name="ln1510">        if (argcount &lt; fdef-&gt;min_argc) {</a>
<a name="ln1511">          error = ERROR_TOOFEW;</a>
<a name="ln1512">        } else if (argcount &gt; fdef-&gt;max_argc) {</a>
<a name="ln1513">          error = ERROR_TOOMANY;</a>
<a name="ln1514">        } else {</a>
<a name="ln1515">          argvars[argcount].v_type = VAR_UNKNOWN;</a>
<a name="ln1516">          fdef-&gt;func(argvars, rettv, fdef-&gt;data);</a>
<a name="ln1517">          error = ERROR_NONE;</a>
<a name="ln1518">        }</a>
<a name="ln1519">      }</a>
<a name="ln1520">    }</a>
<a name="ln1521">    /*</a>
<a name="ln1522">     * The function call (or &quot;FuncUndefined&quot; autocommand sequence) might</a>
<a name="ln1523">     * have been aborted by an error, an interrupt, or an explicitly thrown</a>
<a name="ln1524">     * exception that has not been caught so far.  This situation can be</a>
<a name="ln1525">     * tested for by calling aborting().  For an error in an internal</a>
<a name="ln1526">     * function or for the &quot;E132&quot; error in call_user_func(), however, the</a>
<a name="ln1527">     * throw point at which the &quot;force_abort&quot; flag (temporarily reset by</a>
<a name="ln1528">     * emsg()) is normally updated has not been reached yet. We need to</a>
<a name="ln1529">     * update that flag first to make aborting() reliable.</a>
<a name="ln1530">     */</a>
<a name="ln1531">    update_force_abort();</a>
<a name="ln1532">  }</a>
<a name="ln1533">  if (error == ERROR_NONE)</a>
<a name="ln1534">    ret = OK;</a>
<a name="ln1535"> </a>
<a name="ln1536">theend:</a>
<a name="ln1537">  // Report an error unless the argument evaluation or function call has been</a>
<a name="ln1538">  // cancelled due to an aborting error, an interrupt, or an exception.</a>
<a name="ln1539">  if (!aborting()) {</a>
<a name="ln1540">    user_func_error(error, (name != NULL) ? name : funcname);</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  while (argv_clear &gt; 0) {</a>
<a name="ln1544">    tv_clear(&amp;argv[--argv_clear]);</a>
<a name="ln1545">  }</a>
<a name="ln1546">  xfree(tofree);</a>
<a name="ln1547">  xfree(name);</a>
<a name="ln1548"> </a>
<a name="ln1549">  return ret;</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552">/// List the head of the function: &quot;name(arg1, arg2)&quot;.</a>
<a name="ln1553">///</a>
<a name="ln1554">/// @param[in]  fp      Function pointer.</a>
<a name="ln1555">/// @param[in]  indent  Indent line.</a>
<a name="ln1556">/// @param[in]  force   Include bang &quot;!&quot; (i.e.: &quot;function!&quot;).</a>
<a name="ln1557">static void list_func_head(ufunc_T *fp, int indent, bool force)</a>
<a name="ln1558">{</a>
<a name="ln1559">  msg_start();</a>
<a name="ln1560">  if (indent)</a>
<a name="ln1561">    MSG_PUTS(&quot;   &quot;);</a>
<a name="ln1562">  MSG_PUTS(force ? &quot;function! &quot; : &quot;function &quot;);</a>
<a name="ln1563">  if (fp-&gt;uf_name[0] == K_SPECIAL) {</a>
<a name="ln1564">    MSG_PUTS_ATTR(&quot;&lt;SNR&gt;&quot;, HL_ATTR(HLF_8));</a>
<a name="ln1565">    msg_puts((const char *)fp-&gt;uf_name + 3);</a>
<a name="ln1566">  } else {</a>
<a name="ln1567">    msg_puts((const char *)fp-&gt;uf_name);</a>
<a name="ln1568">  }</a>
<a name="ln1569">  msg_putchar('(');</a>
<a name="ln1570">  int j;</a>
<a name="ln1571">  for (j = 0; j &lt; fp-&gt;uf_args.ga_len; j++) {</a>
<a name="ln1572">    if (j) {</a>
<a name="ln1573">      msg_puts(&quot;, &quot;);</a>
<a name="ln1574">    }</a>
<a name="ln1575">    msg_puts((const char *)FUNCARG(fp, j));</a>
<a name="ln1576">  }</a>
<a name="ln1577">  if (fp-&gt;uf_varargs) {</a>
<a name="ln1578">    if (j) {</a>
<a name="ln1579">      msg_puts(&quot;, &quot;);</a>
<a name="ln1580">    }</a>
<a name="ln1581">    msg_puts(&quot;...&quot;);</a>
<a name="ln1582">  }</a>
<a name="ln1583">  msg_putchar(')');</a>
<a name="ln1584">  if (fp-&gt;uf_flags &amp; FC_ABORT) {</a>
<a name="ln1585">    msg_puts(&quot; abort&quot;);</a>
<a name="ln1586">  }</a>
<a name="ln1587">  if (fp-&gt;uf_flags &amp; FC_RANGE) {</a>
<a name="ln1588">    msg_puts(&quot; range&quot;);</a>
<a name="ln1589">  }</a>
<a name="ln1590">  if (fp-&gt;uf_flags &amp; FC_DICT) {</a>
<a name="ln1591">    msg_puts(&quot; dict&quot;);</a>
<a name="ln1592">  }</a>
<a name="ln1593">  if (fp-&gt;uf_flags &amp; FC_CLOSURE) {</a>
<a name="ln1594">    msg_puts(&quot; closure&quot;);</a>
<a name="ln1595">  }</a>
<a name="ln1596">  msg_clr_eos();</a>
<a name="ln1597">  if (p_verbose &gt; 0) {</a>
<a name="ln1598">    last_set_msg(fp-&gt;uf_script_ctx);</a>
<a name="ln1599">  }</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">/// Get a function name, translating &quot;&lt;SID&gt;&quot; and &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln1603">/// Also handles a Funcref in a List or Dictionary.</a>
<a name="ln1604">/// flags:</a>
<a name="ln1605">/// TFN_INT:         internal function name OK</a>
<a name="ln1606">/// TFN_QUIET:       be quiet</a>
<a name="ln1607">/// TFN_NO_AUTOLOAD: do not use script autoloading</a>
<a name="ln1608">/// TFN_NO_DEREF:    do not dereference a Funcref</a>
<a name="ln1609">/// Advances &quot;pp&quot; to just after the function name (if no error).</a>
<a name="ln1610">///</a>
<a name="ln1611">/// @return the function name in allocated memory, or NULL for failure.</a>
<a name="ln1612">char_u *</a>
<a name="ln1613">trans_function_name(</a>
<a name="ln1614">    char_u **pp,</a>
<a name="ln1615">    bool skip,                     // only find the end, don't evaluate</a>
<a name="ln1616">    int flags,</a>
<a name="ln1617">    funcdict_T *fdp,               // return: info about dictionary used</a>
<a name="ln1618">    partial_T **partial            // return: partial of a FuncRef</a>
<a name="ln1619">)</a>
<a name="ln1620">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1621">{</a>
<a name="ln1622">  char_u      *name = NULL;</a>
<a name="ln1623">  const char_u *start;</a>
<a name="ln1624">  const char_u *end;</a>
<a name="ln1625">  int lead;</a>
<a name="ln1626">  int len;</a>
<a name="ln1627">  lval_T lv;</a>
<a name="ln1628"> </a>
<a name="ln1629">  if (fdp != NULL)</a>
<a name="ln1630">    memset(fdp, 0, sizeof(funcdict_T));</a>
<a name="ln1631">  start = *pp;</a>
<a name="ln1632"> </a>
<a name="ln1633">  /* Check for hard coded &lt;SNR&gt;: already translated function ID (from a user</a>
<a name="ln1634">   * command). */</a>
<a name="ln1635">  if ((*pp)[0] == K_SPECIAL &amp;&amp; (*pp)[1] == KS_EXTRA</a>
<a name="ln1636">      &amp;&amp; (*pp)[2] == (int)KE_SNR) {</a>
<a name="ln1637">    *pp += 3;</a>
<a name="ln1638">    len = get_id_len((const char **)pp) + 3;</a>
<a name="ln1639">    return (char_u *)xmemdupz(start, len);</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  /* A name starting with &quot;&lt;SID&gt;&quot; or &quot;&lt;SNR&gt;&quot; is local to a script.  But</a>
<a name="ln1643">   * don't skip over &quot;s:&quot;, get_lval() needs it for &quot;s:dict.func&quot;. */</a>
<a name="ln1644">  lead = eval_fname_script((const char *)start);</a>
<a name="ln1645">  if (lead &gt; 2) {</a>
<a name="ln1646">    start += lead;</a>
<a name="ln1647">  }</a>
<a name="ln1648"> </a>
<a name="ln1649">  // Note that TFN_ flags use the same values as GLV_ flags.</a>
<a name="ln1650">  end = get_lval((char_u *)start, NULL, &amp;lv, false, skip, flags | GLV_READ_ONLY,</a>
<a name="ln1651">                 lead &gt; 2 ? 0 : FNE_CHECK_START);</a>
<a name="ln1652">  if (end == start) {</a>
<a name="ln1653">    if (!skip)</a>
<a name="ln1654">      EMSG(_(&quot;E129: Function name required&quot;));</a>
<a name="ln1655">    goto theend;</a>
<a name="ln1656">  }</a>
<a name="ln1657">  if (end == NULL || (lv.ll_tv != NULL &amp;&amp; (lead &gt; 2 || lv.ll_range))) {</a>
<a name="ln1658">    /*</a>
<a name="ln1659">     * Report an invalid expression in braces, unless the expression</a>
<a name="ln1660">     * evaluation has been cancelled due to an aborting error, an</a>
<a name="ln1661">     * interrupt, or an exception.</a>
<a name="ln1662">     */</a>
<a name="ln1663">    if (!aborting()) {</a>
<a name="ln1664">      if (end != NULL) {</a>
<a name="ln1665">        emsgf(_(e_invarg2), start);</a>
<a name="ln1666">      }</a>
<a name="ln1667">    } else {</a>
<a name="ln1668">      *pp = (char_u *)find_name_end(start, NULL, NULL, FNE_INCL_BR);</a>
<a name="ln1669">    }</a>
<a name="ln1670">    goto theend;</a>
<a name="ln1671">  }</a>
<a name="ln1672"> </a>
<a name="ln1673">  if (lv.ll_tv != NULL) {</a>
<a name="ln1674">    if (fdp != NULL) {</a>
<a name="ln1675">      fdp-&gt;fd_dict = lv.ll_dict;</a>
<a name="ln1676">      fdp-&gt;fd_newkey = lv.ll_newkey;</a>
<a name="ln1677">      lv.ll_newkey = NULL;</a>
<a name="ln1678">      fdp-&gt;fd_di = lv.ll_di;</a>
<a name="ln1679">    }</a>
<a name="ln1680">    if (lv.ll_tv-&gt;v_type == VAR_FUNC &amp;&amp; lv.ll_tv-&gt;vval.v_string != NULL) {</a>
<a name="ln1681">      name = vim_strsave(lv.ll_tv-&gt;vval.v_string);</a>
<a name="ln1682">      *pp = (char_u *)end;</a>
<a name="ln1683">    } else if (lv.ll_tv-&gt;v_type == VAR_PARTIAL</a>
<a name="ln1684">               &amp;&amp; lv.ll_tv-&gt;vval.v_partial != NULL) {</a>
<a name="ln1685">      if (is_luafunc(lv.ll_tv-&gt;vval.v_partial) &amp;&amp; *end == '.') {</a>
<a name="ln1686">        len = check_luafunc_name((const char *)end+1, true);</a>
<a name="ln1687">        if (len == 0) {</a>
<a name="ln1688">          EMSG2(e_invexpr2, &quot;v:lua&quot;);</a>
<a name="ln1689">          goto theend;</a>
<a name="ln1690">        }</a>
<a name="ln1691">        name = xmallocz(len);</a>
<a name="ln1692">        memcpy(name, end+1, len);</a>
<a name="ln1693">        *pp = (char_u *)end+1+len;</a>
<a name="ln1694">      } else {</a>
<a name="ln1695">        name = vim_strsave(partial_name(lv.ll_tv-&gt;vval.v_partial));</a>
<a name="ln1696">        *pp = (char_u *)end;</a>
<a name="ln1697">      }</a>
<a name="ln1698">      if (partial != NULL) {</a>
<a name="ln1699">        *partial = lv.ll_tv-&gt;vval.v_partial;</a>
<a name="ln1700">      }</a>
<a name="ln1701">    } else {</a>
<a name="ln1702">      if (!skip &amp;&amp; !(flags &amp; TFN_QUIET) &amp;&amp; (fdp == NULL</a>
<a name="ln1703">                                            || lv.ll_dict == NULL</a>
<a name="ln1704">                                            || fdp-&gt;fd_newkey == NULL)) {</a>
<a name="ln1705">        EMSG(_(e_funcref));</a>
<a name="ln1706">      } else {</a>
<a name="ln1707">        *pp = (char_u *)end;</a>
<a name="ln1708">      }</a>
<a name="ln1709">      name = NULL;</a>
<a name="ln1710">    }</a>
<a name="ln1711">    goto theend;</a>
<a name="ln1712">  }</a>
<a name="ln1713"> </a>
<a name="ln1714">  if (lv.ll_name == NULL) {</a>
<a name="ln1715">    // Error found, but continue after the function name.</a>
<a name="ln1716">    *pp = (char_u *)end;</a>
<a name="ln1717">    goto theend;</a>
<a name="ln1718">  }</a>
<a name="ln1719"> </a>
<a name="ln1720">  /* Check if the name is a Funcref.  If so, use the value. */</a>
<a name="ln1721">  if (lv.ll_exp_name != NULL) {</a>
<a name="ln1722">    len = (int)strlen(lv.ll_exp_name);</a>
<a name="ln1723">    name = deref_func_name(lv.ll_exp_name, &amp;len, partial,</a>
<a name="ln1724">                           flags &amp; TFN_NO_AUTOLOAD);</a>
<a name="ln1725">    if ((const char *)name == lv.ll_exp_name) {</a>
<a name="ln1726">      name = NULL;</a>
<a name="ln1727">    }</a>
<a name="ln1728">  } else if (!(flags &amp; TFN_NO_DEREF)) {</a>
<a name="ln1729">    len = (int)(end - *pp);</a>
<a name="ln1730">    name = deref_func_name((const char *)(*pp), &amp;len, partial,</a>
<a name="ln1731">                           flags &amp; TFN_NO_AUTOLOAD);</a>
<a name="ln1732">    if (name == *pp) {</a>
<a name="ln1733">      name = NULL;</a>
<a name="ln1734">    }</a>
<a name="ln1735">  }</a>
<a name="ln1736">  if (name != NULL) {</a>
<a name="ln1737">    name = vim_strsave(name);</a>
<a name="ln1738">    *pp = (char_u *)end;</a>
<a name="ln1739">    if (strncmp((char *)name, &quot;&lt;SNR&gt;&quot;, 5) == 0) {</a>
<a name="ln1740">      // Change &quot;&lt;SNR&gt;&quot; to the byte sequence.</a>
<a name="ln1741">      name[0] = K_SPECIAL;</a>
<a name="ln1742">      name[1] = KS_EXTRA;</a>
<a name="ln1743">      name[2] = (int)KE_SNR;</a>
<a name="ln1744">      memmove(name + 3, name + 5, strlen((char *)name + 5) + 1);</a>
<a name="ln1745">    }</a>
<a name="ln1746">    goto theend;</a>
<a name="ln1747">  }</a>
<a name="ln1748"> </a>
<a name="ln1749">  if (lv.ll_exp_name != NULL) {</a>
<a name="ln1750">    len = (int)strlen(lv.ll_exp_name);</a>
<a name="ln1751">    if (lead &lt;= 2 &amp;&amp; lv.ll_name == lv.ll_exp_name</a>
<a name="ln1752">        &amp;&amp; lv.ll_name_len &gt;= 2 &amp;&amp; memcmp(lv.ll_name, &quot;s:&quot;, 2) == 0) {</a>
<a name="ln1753">      // When there was &quot;s:&quot; already or the name expanded to get a</a>
<a name="ln1754">      // leading &quot;s:&quot; then remove it.</a>
<a name="ln1755">      lv.ll_name += 2;</a>
<a name="ln1756">      lv.ll_name_len -= 2;</a>
<a name="ln1757">      len -= 2;</a>
<a name="ln1758">      lead = 2;</a>
<a name="ln1759">    }</a>
<a name="ln1760">  } else {</a>
<a name="ln1761">    // Skip over &quot;s:&quot; and &quot;g:&quot;.</a>
<a name="ln1762">    if (lead == 2 || (lv.ll_name[0] == 'g' &amp;&amp; lv.ll_name[1] == ':')) {</a>
<a name="ln1763">      lv.ll_name += 2;</a>
<a name="ln1764">      lv.ll_name_len -= 2;</a>
<a name="ln1765">    }</a>
<a name="ln1766">    len = (int)((const char *)end - lv.ll_name);</a>
<a name="ln1767">  }</a>
<a name="ln1768"> </a>
<a name="ln1769">  size_t sid_buf_len = 0;</a>
<a name="ln1770">  char sid_buf[20];</a>
<a name="ln1771"> </a>
<a name="ln1772">  // Copy the function name to allocated memory.</a>
<a name="ln1773">  // Accept &lt;SID&gt;name() inside a script, translate into &lt;SNR&gt;123_name().</a>
<a name="ln1774">  // Accept &lt;SNR&gt;123_name() outside a script.</a>
<a name="ln1775">  if (skip) {</a>
<a name="ln1776">    lead = 0;  // do nothing</a>
<a name="ln1777">  } else if (lead &gt; 0) {</a>
<a name="ln1778">    lead = 3;</a>
<a name="ln1779">    if ((lv.ll_exp_name != NULL &amp;&amp; eval_fname_sid(lv.ll_exp_name))</a>
<a name="ln1780">        || eval_fname_sid((const char *)(*pp))) {</a>
<a name="ln1781">      // It's &quot;s:&quot; or &quot;&lt;SID&gt;&quot;.</a>
<a name="ln1782">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln1783">        EMSG(_(e_usingsid));</a>
<a name="ln1784">        goto theend;</a>
<a name="ln1785">      }</a>
<a name="ln1786">      sid_buf_len = snprintf(sid_buf, sizeof(sid_buf),</a>
<a name="ln1787">                             &quot;%&quot; PRIdSCID &quot;_&quot;, current_sctx.sc_sid);</a>
<a name="ln1788">      lead += sid_buf_len;</a>
<a name="ln1789">    }</a>
<a name="ln1790">  } else if (!(flags &amp; TFN_INT)</a>
<a name="ln1791">             &amp;&amp; builtin_function(lv.ll_name, lv.ll_name_len)) {</a>
<a name="ln1792">    EMSG2(_(&quot;E128: Function name must start with a capital or \&quot;s:\&quot;: %s&quot;),</a>
<a name="ln1793">          start);</a>
<a name="ln1794">    goto theend;</a>
<a name="ln1795">  }</a>
<a name="ln1796"> </a>
<a name="ln1797">  if (!skip &amp;&amp; !(flags &amp; TFN_QUIET) &amp;&amp; !(flags &amp; TFN_NO_DEREF)) {</a>
<a name="ln1798">    char_u *cp = xmemrchr(lv.ll_name, ':', lv.ll_name_len);</a>
<a name="ln1799"> </a>
<a name="ln1800">    if (cp != NULL &amp;&amp; cp &lt; end) {</a>
<a name="ln1801">      EMSG2(_(&quot;E884: Function name cannot contain a colon: %s&quot;), start);</a>
<a name="ln1802">      goto theend;</a>
<a name="ln1803">    }</a>
<a name="ln1804">  }</a>
<a name="ln1805"> </a>
<a name="ln1806">  name = xmalloc(len + lead + 1);</a>
<a name="ln1807">  if (!skip &amp;&amp; lead &gt; 0) {</a>
<a name="ln1808">    name[0] = K_SPECIAL;</a>
<a name="ln1809">    name[1] = KS_EXTRA;</a>
<a name="ln1810">    name[2] = (int)KE_SNR;</a>
<a name="ln1811">    if (sid_buf_len &gt; 0) {  // If it's &quot;&lt;SID&gt;&quot;</a>
<a name="ln1812">      memcpy(name + 3, sid_buf, sid_buf_len);</a>
<a name="ln1813">    }</a>
<a name="ln1814">  }</a>
<a name="ln1815">  memmove(name + lead, lv.ll_name, len);</a>
<a name="ln1816">  name[lead + len] = NUL;</a>
<a name="ln1817">  *pp = (char_u *)end;</a>
<a name="ln1818"> </a>
<a name="ln1819">theend:</a>
<a name="ln1820">  clear_lval(&amp;lv);</a>
<a name="ln1821">  return name;</a>
<a name="ln1822">}</a>
<a name="ln1823"> </a>
<a name="ln1824">/*</a>
<a name="ln1825"> * &quot;:function&quot;</a>
<a name="ln1826"> */</a>
<a name="ln1827">void ex_function(exarg_T *eap)</a>
<a name="ln1828">{</a>
<a name="ln1829">  char_u      *theline;</a>
<a name="ln1830">  char_u      *line_to_free = NULL;</a>
<a name="ln1831">  int c;</a>
<a name="ln1832">  int saved_did_emsg;</a>
<a name="ln1833">  int saved_wait_return = need_wait_return;</a>
<a name="ln1834">  char_u      *name = NULL;</a>
<a name="ln1835">  char_u      *p;</a>
<a name="ln1836">  char_u      *arg;</a>
<a name="ln1837">  char_u      *line_arg = NULL;</a>
<a name="ln1838">  garray_T newargs;</a>
<a name="ln1839">  garray_T newlines;</a>
<a name="ln1840">  int varargs = false;</a>
<a name="ln1841">  int flags = 0;</a>
<a name="ln1842">  ufunc_T     *fp;</a>
<a name="ln1843">  bool overwrite = false;</a>
<a name="ln1844">  int indent;</a>
<a name="ln1845">  int nesting;</a>
<a name="ln1846">  dictitem_T  *v;</a>
<a name="ln1847">  funcdict_T fudi;</a>
<a name="ln1848">  static int func_nr = 0;           // number for nameless function</a>
<a name="ln1849">  int paren;</a>
<a name="ln1850">  hashtab_T   *ht;</a>
<a name="ln1851">  int todo;</a>
<a name="ln1852">  hashitem_T  *hi;</a>
<a name="ln1853">  linenr_T sourcing_lnum_off;</a>
<a name="ln1854">  linenr_T sourcing_lnum_top;</a>
<a name="ln1855">  bool is_heredoc = false;</a>
<a name="ln1856">  char_u *skip_until = NULL;</a>
<a name="ln1857">  char_u *heredoc_trimmed = NULL;</a>
<a name="ln1858">  bool show_block = false;</a>
<a name="ln1859">  bool do_concat = true;</a>
<a name="ln1860"> </a>
<a name="ln1861">  /*</a>
<a name="ln1862">   * &quot;:function&quot; without argument: list functions.</a>
<a name="ln1863">   */</a>
<a name="ln1864">  if (ends_excmd(*eap-&gt;arg)) {</a>
<a name="ln1865">    if (!eap-&gt;skip) {</a>
<a name="ln1866">      todo = (int)func_hashtab.ht_used;</a>
<a name="ln1867">      for (hi = func_hashtab.ht_array; todo &gt; 0 &amp;&amp; !got_int; ++hi) {</a>
<a name="ln1868">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1869">          --todo;</a>
<a name="ln1870">          fp = HI2UF(hi);</a>
<a name="ln1871">          if (message_filtered(fp-&gt;uf_name)) {</a>
<a name="ln1872">            continue;</a>
<a name="ln1873">          }</a>
<a name="ln1874">          if (!func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln1875">            list_func_head(fp, false, false);</a>
<a name="ln1876">          }</a>
<a name="ln1877">        }</a>
<a name="ln1878">      }</a>
<a name="ln1879">    }</a>
<a name="ln1880">    eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln1881">    return;</a>
<a name="ln1882">  }</a>
<a name="ln1883"> </a>
<a name="ln1884">  /*</a>
<a name="ln1885">   * &quot;:function /pat&quot;: list functions matching pattern.</a>
<a name="ln1886">   */</a>
<a name="ln1887">  if (*eap-&gt;arg == '/') {</a>
<a name="ln1888">    p = skip_regexp(eap-&gt;arg + 1, '/', TRUE, NULL);</a>
<a name="ln1889">    if (!eap-&gt;skip) {</a>
<a name="ln1890">      regmatch_T regmatch;</a>
<a name="ln1891"> </a>
<a name="ln1892">      c = *p;</a>
<a name="ln1893">      *p = NUL;</a>
<a name="ln1894">      regmatch.regprog = vim_regcomp(eap-&gt;arg + 1, RE_MAGIC);</a>
<a name="ln1895">      *p = c;</a>
<a name="ln1896">      if (regmatch.regprog != NULL) {</a>
<a name="ln1897">        regmatch.rm_ic = p_ic;</a>
<a name="ln1898"> </a>
<a name="ln1899">        todo = (int)func_hashtab.ht_used;</a>
<a name="ln1900">        for (hi = func_hashtab.ht_array; todo &gt; 0 &amp;&amp; !got_int; ++hi) {</a>
<a name="ln1901">          if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1902">            --todo;</a>
<a name="ln1903">            fp = HI2UF(hi);</a>
<a name="ln1904">            if (!isdigit(*fp-&gt;uf_name)</a>
<a name="ln1905">                &amp;&amp; vim_regexec(&amp;regmatch, fp-&gt;uf_name, 0))</a>
<a name="ln1906">              list_func_head(fp, false, false);</a>
<a name="ln1907">          }</a>
<a name="ln1908">        }</a>
<a name="ln1909">        vim_regfree(regmatch.regprog);</a>
<a name="ln1910">      }</a>
<a name="ln1911">    }</a>
<a name="ln1912">    if (*p == '/')</a>
<a name="ln1913">      ++p;</a>
<a name="ln1914">    eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln1915">    return;</a>
<a name="ln1916">  }</a>
<a name="ln1917"> </a>
<a name="ln1918">  // Get the function name.  There are these situations:</a>
<a name="ln1919">  // func        function name</a>
<a name="ln1920">  //             &quot;name&quot; == func, &quot;fudi.fd_dict&quot; == NULL</a>
<a name="ln1921">  // dict.func   new dictionary entry</a>
<a name="ln1922">  //             &quot;name&quot; == NULL, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln1923">  //             &quot;fudi.fd_di&quot; == NULL, &quot;fudi.fd_newkey&quot; == func</a>
<a name="ln1924">  // dict.func   existing dict entry with a Funcref</a>
<a name="ln1925">  //             &quot;name&quot; == func, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln1926">  //             &quot;fudi.fd_di&quot; set, &quot;fudi.fd_newkey&quot; == NULL</a>
<a name="ln1927">  // dict.func   existing dict entry that's not a Funcref</a>
<a name="ln1928">  //             &quot;name&quot; == NULL, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln1929">  //             &quot;fudi.fd_di&quot; set, &quot;fudi.fd_newkey&quot; == NULL</a>
<a name="ln1930">  // s:func      script-local function name</a>
<a name="ln1931">  // g:func      global function name, same as &quot;func&quot;</a>
<a name="ln1932">  p = eap-&gt;arg;</a>
<a name="ln1933">  name = trans_function_name(&amp;p, eap-&gt;skip, TFN_NO_AUTOLOAD, &amp;fudi, NULL);</a>
<a name="ln1934">  paren = (vim_strchr(p, '(') != NULL);</a>
<a name="ln1935">  if (name == NULL &amp;&amp; (fudi.fd_dict == NULL || !paren) &amp;&amp; !eap-&gt;skip) {</a>
<a name="ln1936">    /*</a>
<a name="ln1937">     * Return on an invalid expression in braces, unless the expression</a>
<a name="ln1938">     * evaluation has been cancelled due to an aborting error, an</a>
<a name="ln1939">     * interrupt, or an exception.</a>
<a name="ln1940">     */</a>
<a name="ln1941">    if (!aborting()) {</a>
<a name="ln1942">      if (fudi.fd_newkey != NULL) {</a>
<a name="ln1943">        EMSG2(_(e_dictkey), fudi.fd_newkey);</a>
<a name="ln1944">      }</a>
<a name="ln1945">      xfree(fudi.fd_newkey);</a>
<a name="ln1946">      return;</a>
<a name="ln1947">    } else</a>
<a name="ln1948">      eap-&gt;skip = TRUE;</a>
<a name="ln1949">  }</a>
<a name="ln1950"> </a>
<a name="ln1951">  /* An error in a function call during evaluation of an expression in magic</a>
<a name="ln1952">   * braces should not cause the function not to be defined. */</a>
<a name="ln1953">  saved_did_emsg = did_emsg;</a>
<a name="ln1954">  did_emsg = FALSE;</a>
<a name="ln1955"> </a>
<a name="ln1956">  //</a>
<a name="ln1957">  // &quot;:function func&quot; with only function name: list function.</a>
<a name="ln1958">  // If bang is given:</a>
<a name="ln1959">  //  - include &quot;!&quot; in function head</a>
<a name="ln1960">  //  - exclude line numbers from function body</a>
<a name="ln1961">  //</a>
<a name="ln1962">  if (!paren) {</a>
<a name="ln1963">    if (!ends_excmd(*skipwhite(p))) {</a>
<a name="ln1964">      EMSG(_(e_trailing));</a>
<a name="ln1965">      goto ret_free;</a>
<a name="ln1966">    }</a>
<a name="ln1967">    eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln1968">    if (eap-&gt;nextcmd != NULL)</a>
<a name="ln1969">      *p = NUL;</a>
<a name="ln1970">    if (!eap-&gt;skip &amp;&amp; !got_int) {</a>
<a name="ln1971">      fp = find_func(name);</a>
<a name="ln1972">      if (fp != NULL) {</a>
<a name="ln1973">        list_func_head(fp, !eap-&gt;forceit, eap-&gt;forceit);</a>
<a name="ln1974">        for (int j = 0; j &lt; fp-&gt;uf_lines.ga_len &amp;&amp; !got_int; j++) {</a>
<a name="ln1975">          if (FUNCLINE(fp, j) == NULL) {</a>
<a name="ln1976">            continue;</a>
<a name="ln1977">          }</a>
<a name="ln1978">          msg_putchar('\n');</a>
<a name="ln1979">          if (!eap-&gt;forceit) {</a>
<a name="ln1980">            msg_outnum((long)j + 1);</a>
<a name="ln1981">            if (j &lt; 9) {</a>
<a name="ln1982">              msg_putchar(' ');</a>
<a name="ln1983">            }</a>
<a name="ln1984">            if (j &lt; 99) {</a>
<a name="ln1985">              msg_putchar(' ');</a>
<a name="ln1986">            }</a>
<a name="ln1987">          }</a>
<a name="ln1988">          msg_prt_line(FUNCLINE(fp, j), false);</a>
<a name="ln1989">          ui_flush();                  // show a line at a time</a>
<a name="ln1990">          os_breakcheck();</a>
<a name="ln1991">        }</a>
<a name="ln1992">        if (!got_int) {</a>
<a name="ln1993">          msg_putchar('\n');</a>
<a name="ln1994">          msg_puts(eap-&gt;forceit ? &quot;endfunction&quot; : &quot;   endfunction&quot;);</a>
<a name="ln1995">        }</a>
<a name="ln1996">      } else</a>
<a name="ln1997">        emsg_funcname(N_(&quot;E123: Undefined function: %s&quot;), name);</a>
<a name="ln1998">    }</a>
<a name="ln1999">    goto ret_free;</a>
<a name="ln2000">  }</a>
<a name="ln2001"> </a>
<a name="ln2002">  /*</a>
<a name="ln2003">   * &quot;:function name(arg1, arg2)&quot; Define function.</a>
<a name="ln2004">   */</a>
<a name="ln2005">  p = skipwhite(p);</a>
<a name="ln2006">  if (*p != '(') {</a>
<a name="ln2007">    if (!eap-&gt;skip) {</a>
<a name="ln2008">      EMSG2(_(&quot;E124: Missing '(': %s&quot;), eap-&gt;arg);</a>
<a name="ln2009">      goto ret_free;</a>
<a name="ln2010">    }</a>
<a name="ln2011">    // attempt to continue by skipping some text</a>
<a name="ln2012">    if (vim_strchr(p, '(') != NULL) {</a>
<a name="ln2013">      p = vim_strchr(p, '(');</a>
<a name="ln2014">    }</a>
<a name="ln2015">  }</a>
<a name="ln2016">  p = skipwhite(p + 1);</a>
<a name="ln2017"> </a>
<a name="ln2018">  ga_init(&amp;newargs, (int)sizeof(char_u *), 3);</a>
<a name="ln2019">  ga_init(&amp;newlines, (int)sizeof(char_u *), 3);</a>
<a name="ln2020"> </a>
<a name="ln2021">  if (!eap-&gt;skip) {</a>
<a name="ln2022">    /* Check the name of the function.  Unless it's a dictionary function</a>
<a name="ln2023">     * (that we are overwriting). */</a>
<a name="ln2024">    if (name != NULL)</a>
<a name="ln2025">      arg = name;</a>
<a name="ln2026">    else</a>
<a name="ln2027">      arg = fudi.fd_newkey;</a>
<a name="ln2028">    if (arg != NULL &amp;&amp; (fudi.fd_di == NULL || !tv_is_func(fudi.fd_di-&gt;di_tv))) {</a>
<a name="ln2029">      int j = (*arg == K_SPECIAL) ? 3 : 0;</a>
<a name="ln2030">      while (arg[j] != NUL &amp;&amp; (j == 0 ? eval_isnamec1(arg[j])</a>
<a name="ln2031">                               : eval_isnamec(arg[j])))</a>
<a name="ln2032">        ++j;</a>
<a name="ln2033">      if (arg[j] != NUL)</a>
<a name="ln2034">        emsg_funcname((char *)e_invarg2, arg);</a>
<a name="ln2035">    }</a>
<a name="ln2036">    // Disallow using the g: dict.</a>
<a name="ln2037">    if (fudi.fd_dict != NULL &amp;&amp; fudi.fd_dict-&gt;dv_scope == VAR_DEF_SCOPE) {</a>
<a name="ln2038">      EMSG(_(&quot;E862: Cannot use g: here&quot;));</a>
<a name="ln2039">    }</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  if (get_function_args(&amp;p, ')', &amp;newargs, &amp;varargs, eap-&gt;skip) == FAIL) {</a>
<a name="ln2043">    goto errret_2;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  if (KeyTyped &amp;&amp; ui_has(kUICmdline)) {</a>
<a name="ln2047">    show_block = true;</a>
<a name="ln2048">    ui_ext_cmdline_block_append(0, (const char *)eap-&gt;cmd);</a>
<a name="ln2049">  }</a>
<a name="ln2050"> </a>
<a name="ln2051">  // find extra arguments &quot;range&quot;, &quot;dict&quot;, &quot;abort&quot; and &quot;closure&quot;</a>
<a name="ln2052">  for (;; ) {</a>
<a name="ln2053">    p = skipwhite(p);</a>
<a name="ln2054">    if (STRNCMP(p, &quot;range&quot;, 5) == 0) {</a>
<a name="ln2055">      flags |= FC_RANGE;</a>
<a name="ln2056">      p += 5;</a>
<a name="ln2057">    } else if (STRNCMP(p, &quot;dict&quot;, 4) == 0) {</a>
<a name="ln2058">      flags |= FC_DICT;</a>
<a name="ln2059">      p += 4;</a>
<a name="ln2060">    } else if (STRNCMP(p, &quot;abort&quot;, 5) == 0) {</a>
<a name="ln2061">      flags |= FC_ABORT;</a>
<a name="ln2062">      p += 5;</a>
<a name="ln2063">    } else if (STRNCMP(p, &quot;closure&quot;, 7) == 0) {</a>
<a name="ln2064">      flags |= FC_CLOSURE;</a>
<a name="ln2065">      p += 7;</a>
<a name="ln2066">      if (current_funccal == NULL) {</a>
<a name="ln2067">        emsg_funcname(N_</a>
<a name="ln2068">                      (&quot;E932: Closure function should not be at top level: %s&quot;),</a>
<a name="ln2069">                      name == NULL ? (char_u *)&quot;&quot; : name);</a>
<a name="ln2070">        goto erret;</a>
<a name="ln2071">      }</a>
<a name="ln2072">    } else {</a>
<a name="ln2073">      break;</a>
<a name="ln2074">    }</a>
<a name="ln2075">  }</a>
<a name="ln2076"> </a>
<a name="ln2077">  /* When there is a line break use what follows for the function body.</a>
<a name="ln2078">   * Makes 'exe &quot;func Test()\n...\nendfunc&quot;' work. */</a>
<a name="ln2079">  if (*p == '\n') {</a>
<a name="ln2080">    line_arg = p + 1;</a>
<a name="ln2081">  } else if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; !eap-&gt;skip &amp;&amp; !did_emsg) {</a>
<a name="ln2082">    EMSG(_(e_trailing));</a>
<a name="ln2083">  }</a>
<a name="ln2084"> </a>
<a name="ln2085">  /*</a>
<a name="ln2086">   * Read the body of the function, until &quot;:endfunction&quot; is found.</a>
<a name="ln2087">   */</a>
<a name="ln2088">  if (KeyTyped) {</a>
<a name="ln2089">    /* Check if the function already exists, don't let the user type the</a>
<a name="ln2090">     * whole function before telling him it doesn't work!  For a script we</a>
<a name="ln2091">     * need to skip the body to be able to find what follows. */</a>
<a name="ln2092">    if (!eap-&gt;skip &amp;&amp; !eap-&gt;forceit) {</a>
<a name="ln2093">      if (fudi.fd_dict != NULL &amp;&amp; fudi.fd_newkey == NULL)</a>
<a name="ln2094">        EMSG(_(e_funcdict));</a>
<a name="ln2095">      else if (name != NULL &amp;&amp; find_func(name) != NULL)</a>
<a name="ln2096">        emsg_funcname(e_funcexts, name);</a>
<a name="ln2097">    }</a>
<a name="ln2098"> </a>
<a name="ln2099">    if (!eap-&gt;skip &amp;&amp; did_emsg)</a>
<a name="ln2100">      goto erret;</a>
<a name="ln2101"> </a>
<a name="ln2102">    if (!ui_has(kUICmdline)) {</a>
<a name="ln2103">      msg_putchar('\n');              // don't overwrite the function name</a>
<a name="ln2104">    }</a>
<a name="ln2105">    cmdline_row = msg_row;</a>
<a name="ln2106">  }</a>
<a name="ln2107"> </a>
<a name="ln2108">  // Save the starting line number.</a>
<a name="ln2109">  sourcing_lnum_top = sourcing_lnum;</a>
<a name="ln2110"> </a>
<a name="ln2111">  indent = 2;</a>
<a name="ln2112">  nesting = 0;</a>
<a name="ln2113">  for (;; ) {</a>
<a name="ln2114">    if (KeyTyped) {</a>
<a name="ln2115">      msg_scroll = true;</a>
<a name="ln2116">      saved_wait_return = false;</a>
<a name="ln2117">    }</a>
<a name="ln2118">    need_wait_return = false;</a>
<a name="ln2119"> </a>
<a name="ln2120">    if (line_arg != NULL) {</a>
<a name="ln2121">      // Use eap-&gt;arg, split up in parts by line breaks.</a>
<a name="ln2122">      theline = line_arg;</a>
<a name="ln2123">      p = vim_strchr(theline, '\n');</a>
<a name="ln2124">      if (p == NULL)</a>
<a name="ln2125">        line_arg += STRLEN(line_arg);</a>
<a name="ln2126">      else {</a>
<a name="ln2127">        *p = NUL;</a>
<a name="ln2128">        line_arg = p + 1;</a>
<a name="ln2129">      }</a>
<a name="ln2130">    } else {</a>
<a name="ln2131">      xfree(line_to_free);</a>
<a name="ln2132">      if (eap-&gt;getline == NULL) {</a>
<a name="ln2133">        theline = getcmdline(':', 0L, indent, do_concat);</a>
<a name="ln2134">      } else {</a>
<a name="ln2135">        theline = eap-&gt;getline(':', eap-&gt;cookie, indent, do_concat);</a>
<a name="ln2136">      }</a>
<a name="ln2137">      line_to_free = theline;</a>
<a name="ln2138">    }</a>
<a name="ln2139">    if (KeyTyped) {</a>
<a name="ln2140">      lines_left = Rows - 1;</a>
<a name="ln2141">    }</a>
<a name="ln2142">    if (theline == NULL) {</a>
<a name="ln2143">      EMSG(_(&quot;E126: Missing :endfunction&quot;));</a>
<a name="ln2144">      goto erret;</a>
<a name="ln2145">    }</a>
<a name="ln2146">    if (show_block) {</a>
<a name="ln2147">      assert(indent &gt;= 0);</a>
<a name="ln2148">      ui_ext_cmdline_block_append((size_t)indent, (const char *)theline);</a>
<a name="ln2149">    }</a>
<a name="ln2150"> </a>
<a name="ln2151">    // Detect line continuation: sourcing_lnum increased more than one.</a>
<a name="ln2152">    sourcing_lnum_off = get_sourced_lnum(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln2153">    if (sourcing_lnum &lt; sourcing_lnum_off) {</a>
<a name="ln2154">        sourcing_lnum_off -= sourcing_lnum;</a>
<a name="ln2155">    } else {</a>
<a name="ln2156">      sourcing_lnum_off = 0;</a>
<a name="ln2157">    }</a>
<a name="ln2158"> </a>
<a name="ln2159">    if (skip_until != NULL) {</a>
<a name="ln2160">      // Don't check for &quot;:endfunc&quot; between</a>
<a name="ln2161">      // * &quot;:append&quot; and &quot;.&quot;</a>
<a name="ln2162">      // * &quot;:python &lt;&lt;EOF&quot; and &quot;EOF&quot;</a>
<a name="ln2163">      // * &quot;:let {var-name} =&lt;&lt; [trim] {marker}&quot; and &quot;{marker}&quot;</a>
<a name="ln2164">      if (heredoc_trimmed == NULL</a>
<a name="ln2165">          || (is_heredoc &amp;&amp; skipwhite(theline) == theline)</a>
<a name="ln2166">          || STRNCMP(theline, heredoc_trimmed,</a>
<a name="ln2167">                     STRLEN(heredoc_trimmed)) == 0) {</a>
<a name="ln2168">        if (heredoc_trimmed == NULL) {</a>
<a name="ln2169">          p = theline;</a>
<a name="ln2170">        } else if (is_heredoc) {</a>
<a name="ln2171">          p = skipwhite(theline) == theline</a>
<a name="ln2172">            ? theline : theline + STRLEN(heredoc_trimmed);</a>
<a name="ln2173">        } else {</a>
<a name="ln2174">          p = theline + STRLEN(heredoc_trimmed);</a>
<a name="ln2175">        }</a>
<a name="ln2176">        if (STRCMP(p, skip_until) == 0) {</a>
<a name="ln2177">          XFREE_CLEAR(skip_until);</a>
<a name="ln2178">          XFREE_CLEAR(heredoc_trimmed);</a>
<a name="ln2179">          do_concat = true;</a>
<a name="ln2180">          is_heredoc = false;</a>
<a name="ln2181">        }</a>
<a name="ln2182">      }</a>
<a name="ln2183">    } else {</a>
<a name="ln2184">      // skip ':' and blanks</a>
<a name="ln2185">      for (p = theline; ascii_iswhite(*p) || *p == ':'; p++) {</a>
<a name="ln2186">      }</a>
<a name="ln2187"> </a>
<a name="ln2188">      // Check for &quot;endfunction&quot;.</a>
<a name="ln2189">      if (checkforcmd(&amp;p, &quot;endfunction&quot;, 4) &amp;&amp; nesting-- == 0) {</a>
<a name="ln2190">        if (*p == '!') {</a>
<a name="ln2191">          p++;</a>
<a name="ln2192">        }</a>
<a name="ln2193">        char_u *nextcmd = NULL;</a>
<a name="ln2194">        if (*p == '|') {</a>
<a name="ln2195">          nextcmd = p + 1;</a>
<a name="ln2196">        } else if (line_arg != NULL &amp;&amp; *skipwhite(line_arg) != NUL) {</a>
<a name="ln2197">          nextcmd = line_arg;</a>
<a name="ln2198">        } else if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; p_verbose &gt; 0) {</a>
<a name="ln2199">          give_warning2((char_u *)_(&quot;W22: Text found after :endfunction: %s&quot;),</a>
<a name="ln2200">                        p, true);</a>
<a name="ln2201">        }</a>
<a name="ln2202">        if (nextcmd != NULL) {</a>
<a name="ln2203">          // Another command follows. If the line came from &quot;eap&quot; we</a>
<a name="ln2204">          // can simply point into it, otherwise we need to change</a>
<a name="ln2205">          // &quot;eap-&gt;cmdlinep&quot;.</a>
<a name="ln2206">          eap-&gt;nextcmd = nextcmd;</a>
<a name="ln2207">          if (line_to_free != NULL) {</a>
<a name="ln2208">            xfree(*eap-&gt;cmdlinep);</a>
<a name="ln2209">            *eap-&gt;cmdlinep = line_to_free;</a>
<a name="ln2210">            line_to_free = NULL;</a>
<a name="ln2211">          }</a>
<a name="ln2212">        }</a>
<a name="ln2213">        break;</a>
<a name="ln2214">      }</a>
<a name="ln2215"> </a>
<a name="ln2216">      /* Increase indent inside &quot;if&quot;, &quot;while&quot;, &quot;for&quot; and &quot;try&quot;, decrease</a>
<a name="ln2217">       * at &quot;end&quot;. */</a>
<a name="ln2218">      if (indent &gt; 2 &amp;&amp; STRNCMP(p, &quot;end&quot;, 3) == 0)</a>
<a name="ln2219">        indent -= 2;</a>
<a name="ln2220">      else if (STRNCMP(p, &quot;if&quot;, 2) == 0</a>
<a name="ln2221">               || STRNCMP(p, &quot;wh&quot;, 2) == 0</a>
<a name="ln2222">               || STRNCMP(p, &quot;for&quot;, 3) == 0</a>
<a name="ln2223">               || STRNCMP(p, &quot;try&quot;, 3) == 0)</a>
<a name="ln2224">        indent += 2;</a>
<a name="ln2225"> </a>
<a name="ln2226">      // Check for defining a function inside this function.</a>
<a name="ln2227">      if (checkforcmd(&amp;p, &quot;function&quot;, 2)) {</a>
<a name="ln2228">        if (*p == '!') {</a>
<a name="ln2229">          p = skipwhite(p + 1);</a>
<a name="ln2230">        }</a>
<a name="ln2231">        p += eval_fname_script((const char *)p);</a>
<a name="ln2232">        xfree(trans_function_name(&amp;p, true, 0, NULL, NULL));</a>
<a name="ln2233">        if (*skipwhite(p) == '(') {</a>
<a name="ln2234">          nesting++;</a>
<a name="ln2235">          indent += 2;</a>
<a name="ln2236">        }</a>
<a name="ln2237">      }</a>
<a name="ln2238"> </a>
<a name="ln2239">      // Check for &quot;:append&quot;, &quot;:change&quot;, &quot;:insert&quot;.</a>
<a name="ln2240">      p = skip_range(p, NULL);</a>
<a name="ln2241">      if ((p[0] == 'a' &amp;&amp; (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))</a>
<a name="ln2242">          || (p[0] == 'c'</a>
<a name="ln2243">              &amp;&amp; (!ASCII_ISALPHA(p[1])</a>
<a name="ln2244">                  || (p[1] == 'h' &amp;&amp; (!ASCII_ISALPHA(p[2])</a>
<a name="ln2245">                                      || (p[2] == 'a'</a>
<a name="ln2246">                                          &amp;&amp; (STRNCMP(&amp;p[3], &quot;nge&quot;, 3) != 0</a>
<a name="ln2247">                                              || !ASCII_ISALPHA(p[6])))))))</a>
<a name="ln2248">          || (p[0] == 'i'</a>
<a name="ln2249">              &amp;&amp; (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'</a>
<a name="ln2250">                                           &amp;&amp; (!ASCII_ISALPHA(p[2])</a>
<a name="ln2251">                                               || (p[2] == 's')))))) {</a>
<a name="ln2252">        skip_until = vim_strsave((char_u *)&quot;.&quot;);</a>
<a name="ln2253">      }</a>
<a name="ln2254"> </a>
<a name="ln2255">      // heredoc: Check for &quot;:python &lt;&lt;EOF&quot;, &quot;:lua &lt;&lt;EOF&quot;, etc.</a>
<a name="ln2256">      arg = skipwhite(skiptowhite(p));</a>
<a name="ln2257">      if (arg[0] == '&lt;' &amp;&amp; arg[1] =='&lt;'</a>
<a name="ln2258">          &amp;&amp; ((p[0] == 'p' &amp;&amp; p[1] == 'y'</a>
<a name="ln2259">               &amp;&amp; (!ASCII_ISALNUM(p[2]) || p[2] == 't'</a>
<a name="ln2260">                   || ((p[2] == '3' || p[2] == 'x')</a>
<a name="ln2261">                       &amp;&amp; !ASCII_ISALPHA(p[3]))))</a>
<a name="ln2262">              || (p[0] == 'p' &amp;&amp; p[1] == 'e'</a>
<a name="ln2263">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))</a>
<a name="ln2264">              || (p[0] == 't' &amp;&amp; p[1] == 'c'</a>
<a name="ln2265">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))</a>
<a name="ln2266">              || (p[0] == 'l' &amp;&amp; p[1] == 'u' &amp;&amp; p[2] == 'a'</a>
<a name="ln2267">                  &amp;&amp; !ASCII_ISALPHA(p[3]))</a>
<a name="ln2268">              || (p[0] == 'r' &amp;&amp; p[1] == 'u' &amp;&amp; p[2] == 'b'</a>
<a name="ln2269">                  &amp;&amp; (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))</a>
<a name="ln2270">              || (p[0] == 'm' &amp;&amp; p[1] == 'z'</a>
<a name="ln2271">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 's')))) {</a>
<a name="ln2272">        // &quot;:python &lt;&lt;&quot; continues until a dot, like &quot;:append&quot;</a>
<a name="ln2273">        p = skipwhite(arg + 2);</a>
<a name="ln2274">        if (*p == NUL)</a>
<a name="ln2275">          skip_until = vim_strsave((char_u *)&quot;.&quot;);</a>
<a name="ln2276">        else</a>
<a name="ln2277">          skip_until = vim_strsave(p);</a>
<a name="ln2278">      }</a>
<a name="ln2279"> </a>
<a name="ln2280">      // Check for &quot;:let v =&lt;&lt; [trim] EOF&quot;</a>
<a name="ln2281">      //       and &quot;:let [a, b] =&lt;&lt; [trim] EOF&quot;</a>
<a name="ln2282">      arg = skipwhite(skiptowhite(p));</a>
<a name="ln2283">      if (*arg == '[') {</a>
<a name="ln2284">        arg = vim_strchr(arg, ']');</a>
<a name="ln2285">      }</a>
<a name="ln2286">      if (arg != NULL) {</a>
<a name="ln2287">        arg = skipwhite(skiptowhite(arg));</a>
<a name="ln2288">        if (arg[0] == '='</a>
<a name="ln2289">            &amp;&amp; arg[1] == '&lt;'</a>
<a name="ln2290">            &amp;&amp; arg[2] =='&lt;'</a>
<a name="ln2291">            &amp;&amp; (p[0] == 'l'</a>
<a name="ln2292">                &amp;&amp; p[1] == 'e'</a>
<a name="ln2293">                &amp;&amp; (!ASCII_ISALNUM(p[2])</a>
<a name="ln2294">                    || (p[2] == 't' &amp;&amp; !ASCII_ISALNUM(p[3]))))) {</a>
<a name="ln2295">          p = skipwhite(arg + 3);</a>
<a name="ln2296">          if (STRNCMP(p, &quot;trim&quot;, 4) == 0) {</a>
<a name="ln2297">            // Ignore leading white space.</a>
<a name="ln2298">            p = skipwhite(p + 4);</a>
<a name="ln2299">            heredoc_trimmed =</a>
<a name="ln2300">              vim_strnsave(theline, skipwhite(theline) - theline);</a>
<a name="ln2301">          }</a>
<a name="ln2302">          skip_until = vim_strnsave(p, skiptowhite(p) - p);</a>
<a name="ln2303">          do_concat = false;</a>
<a name="ln2304">          is_heredoc = true;</a>
<a name="ln2305">        }</a>
<a name="ln2306">      }</a>
<a name="ln2307">    }</a>
<a name="ln2308"> </a>
<a name="ln2309">    // Add the line to the function.</a>
<a name="ln2310">    ga_grow(&amp;newlines, 1 + sourcing_lnum_off);</a>
<a name="ln2311"> </a>
<a name="ln2312">    /* Copy the line to newly allocated memory.  get_one_sourceline()</a>
<a name="ln2313">     * allocates 250 bytes per line, this saves 80% on average.  The cost</a>
<a name="ln2314">     * is an extra alloc/free. */</a>
<a name="ln2315">    p = vim_strsave(theline);</a>
<a name="ln2316">    ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;</a>
<a name="ln2317"> </a>
<a name="ln2318">    /* Add NULL lines for continuation lines, so that the line count is</a>
<a name="ln2319">     * equal to the index in the growarray.   */</a>
<a name="ln2320">    while (sourcing_lnum_off-- &gt; 0)</a>
<a name="ln2321">      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;</a>
<a name="ln2322"> </a>
<a name="ln2323">    // Check for end of eap-&gt;arg.</a>
<a name="ln2324">    if (line_arg != NULL &amp;&amp; *line_arg == NUL) {</a>
<a name="ln2325">      line_arg = NULL;</a>
<a name="ln2326">    }</a>
<a name="ln2327">  }</a>
<a name="ln2328"> </a>
<a name="ln2329">  /* Don't define the function when skipping commands or when an error was</a>
<a name="ln2330">   * detected. */</a>
<a name="ln2331">  if (eap-&gt;skip || did_emsg)</a>
<a name="ln2332">    goto erret;</a>
<a name="ln2333"> </a>
<a name="ln2334">  /*</a>
<a name="ln2335">   * If there are no errors, add the function</a>
<a name="ln2336">   */</a>
<a name="ln2337">  if (fudi.fd_dict == NULL) {</a>
<a name="ln2338">    v = find_var((const char *)name, STRLEN(name), &amp;ht, false);</a>
<a name="ln2339">    if (v != NULL &amp;&amp; v-&gt;di_tv.v_type == VAR_FUNC) {</a>
<a name="ln2340">      emsg_funcname(N_(&quot;E707: Function name conflicts with variable: %s&quot;),</a>
<a name="ln2341">          name);</a>
<a name="ln2342">      goto erret;</a>
<a name="ln2343">    }</a>
<a name="ln2344"> </a>
<a name="ln2345">    fp = find_func(name);</a>
<a name="ln2346">    if (fp != NULL) {</a>
<a name="ln2347">      // Function can be replaced with &quot;function!&quot; and when sourcing the</a>
<a name="ln2348">      // same script again, but only once.</a>
<a name="ln2349">      if (!eap-&gt;forceit</a>
<a name="ln2350">          &amp;&amp; (fp-&gt;uf_script_ctx.sc_sid != current_sctx.sc_sid</a>
<a name="ln2351">              || fp-&gt;uf_script_ctx.sc_seq == current_sctx.sc_seq)) {</a>
<a name="ln2352">        emsg_funcname(e_funcexts, name);</a>
<a name="ln2353">        goto erret;</a>
<a name="ln2354">      }</a>
<a name="ln2355">      if (fp-&gt;uf_calls &gt; 0) {</a>
<a name="ln2356">        emsg_funcname(N_(&quot;E127: Cannot redefine function %s: It is in use&quot;),</a>
<a name="ln2357">            name);</a>
<a name="ln2358">        goto erret;</a>
<a name="ln2359">      }</a>
<a name="ln2360">      if (fp-&gt;uf_refcount &gt; 1) {</a>
<a name="ln2361">        // This function is referenced somewhere, don't redefine it but</a>
<a name="ln2362">        // create a new one.</a>
<a name="ln2363">        (fp-&gt;uf_refcount)--;</a>
<a name="ln2364">        fp-&gt;uf_flags |= FC_REMOVED;</a>
<a name="ln2365">        fp = NULL;</a>
<a name="ln2366">        overwrite = true;</a>
<a name="ln2367">      } else {</a>
<a name="ln2368">        // redefine existing function</a>
<a name="ln2369">        XFREE_CLEAR(name);</a>
<a name="ln2370">        func_clear_items(fp);</a>
<a name="ln2371">        fp-&gt;uf_profiling = false;</a>
<a name="ln2372">        fp-&gt;uf_prof_initialized = false;</a>
<a name="ln2373">      }</a>
<a name="ln2374">    }</a>
<a name="ln2375">  } else {</a>
<a name="ln2376">    char numbuf[20];</a>
<a name="ln2377"> </a>
<a name="ln2378">    fp = NULL;</a>
<a name="ln2379">    if (fudi.fd_newkey == NULL &amp;&amp; !eap-&gt;forceit) {</a>
<a name="ln2380">      EMSG(_(e_funcdict));</a>
<a name="ln2381">      goto erret;</a>
<a name="ln2382">    }</a>
<a name="ln2383">    if (fudi.fd_di == NULL) {</a>
<a name="ln2384">      if (tv_check_lock(fudi.fd_dict-&gt;dv_lock, (const char *)eap-&gt;arg,</a>
<a name="ln2385">                        TV_CSTRING)) {</a>
<a name="ln2386">        // Can't add a function to a locked dictionary</a>
<a name="ln2387">        goto erret;</a>
<a name="ln2388">      }</a>
<a name="ln2389">    } else if (tv_check_lock(fudi.fd_di-&gt;di_tv.v_lock, (const char *)eap-&gt;arg,</a>
<a name="ln2390">                             TV_CSTRING)) {</a>
<a name="ln2391">      // Can't change an existing function if it is locked</a>
<a name="ln2392">      goto erret;</a>
<a name="ln2393">    }</a>
<a name="ln2394"> </a>
<a name="ln2395">    /* Give the function a sequential number.  Can only be used with a</a>
<a name="ln2396">     * Funcref! */</a>
<a name="ln2397">    xfree(name);</a>
<a name="ln2398">    sprintf(numbuf, &quot;%d&quot;, ++func_nr);</a>
<a name="ln2399">    name = vim_strsave((char_u *)numbuf);</a>
<a name="ln2400">  }</a>
<a name="ln2401"> </a>
<a name="ln2402">  if (fp == NULL) {</a>
<a name="ln2403">    if (fudi.fd_dict == NULL &amp;&amp; vim_strchr(name, AUTOLOAD_CHAR) != NULL) {</a>
<a name="ln2404">      int slen, plen;</a>
<a name="ln2405">      char_u  *scriptname;</a>
<a name="ln2406"> </a>
<a name="ln2407">      // Check that the autoload name matches the script name.</a>
<a name="ln2408">      int j = FAIL;</a>
<a name="ln2409">      if (sourcing_name != NULL) {</a>
<a name="ln2410">        scriptname = (char_u *)autoload_name((const char *)name, STRLEN(name));</a>
<a name="ln2411">        p = vim_strchr(scriptname, '/');</a>
<a name="ln2412">        plen = (int)STRLEN(p);</a>
<a name="ln2413">        slen = (int)STRLEN(sourcing_name);</a>
<a name="ln2414">        if (slen &gt; plen &amp;&amp; fnamecmp(p,</a>
<a name="ln2415">                sourcing_name + slen - plen) == 0)</a>
<a name="ln2416">          j = OK;</a>
<a name="ln2417">        xfree(scriptname);</a>
<a name="ln2418">      }</a>
<a name="ln2419">      if (j == FAIL) {</a>
<a name="ln2420">        EMSG2(_(</a>
<a name="ln2421">                &quot;E746: Function name does not match script file name: %s&quot;),</a>
<a name="ln2422">            name);</a>
<a name="ln2423">        goto erret;</a>
<a name="ln2424">      }</a>
<a name="ln2425">    }</a>
<a name="ln2426"> </a>
<a name="ln2427">    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);</a>
<a name="ln2428"> </a>
<a name="ln2429">    if (fudi.fd_dict != NULL) {</a>
<a name="ln2430">      if (fudi.fd_di == NULL) {</a>
<a name="ln2431">        // Add new dict entry</a>
<a name="ln2432">        fudi.fd_di = tv_dict_item_alloc((const char *)fudi.fd_newkey);</a>
<a name="ln2433">        if (tv_dict_add(fudi.fd_dict, fudi.fd_di) == FAIL) {</a>
<a name="ln2434">          xfree(fudi.fd_di);</a>
<a name="ln2435">          xfree(fp);</a>
<a name="ln2436">          goto erret;</a>
<a name="ln2437">        }</a>
<a name="ln2438">      } else {</a>
<a name="ln2439">        // Overwrite existing dict entry.</a>
<a name="ln2440">        tv_clear(&amp;fudi.fd_di-&gt;di_tv);</a>
<a name="ln2441">      }</a>
<a name="ln2442">      fudi.fd_di-&gt;di_tv.v_type = VAR_FUNC;</a>
<a name="ln2443">      fudi.fd_di-&gt;di_tv.vval.v_string = vim_strsave(name);</a>
<a name="ln2444"> </a>
<a name="ln2445">      // behave like &quot;dict&quot; was used</a>
<a name="ln2446">      flags |= FC_DICT;</a>
<a name="ln2447">    }</a>
<a name="ln2448"> </a>
<a name="ln2449">    // insert the new function in the function list</a>
<a name="ln2450">    STRCPY(fp-&gt;uf_name, name);</a>
<a name="ln2451">    if (overwrite) {</a>
<a name="ln2452">      hi = hash_find(&amp;func_hashtab, name);</a>
<a name="ln2453">      hi-&gt;hi_key = UF2HIKEY(fp);</a>
<a name="ln2454">    } else if (hash_add(&amp;func_hashtab, UF2HIKEY(fp)) == FAIL) {</a>
<a name="ln2455">      xfree(fp);</a>
<a name="ln2456">      goto erret;</a>
<a name="ln2457">    }</a>
<a name="ln2458">    fp-&gt;uf_refcount = 1;</a>
<a name="ln2459">  }</a>
<a name="ln2460">  fp-&gt;uf_args = newargs;</a>
<a name="ln2461">  fp-&gt;uf_lines = newlines;</a>
<a name="ln2462">  if ((flags &amp; FC_CLOSURE) != 0) {</a>
<a name="ln2463">    register_closure(fp);</a>
<a name="ln2464">  } else {</a>
<a name="ln2465">    fp-&gt;uf_scoped = NULL;</a>
<a name="ln2466">  }</a>
<a name="ln2467">  if (prof_def_func()) {</a>
<a name="ln2468">    func_do_profile(fp);</a>
<a name="ln2469">  }</a>
<a name="ln2470">  fp-&gt;uf_varargs = varargs;</a>
<a name="ln2471">  if (sandbox) {</a>
<a name="ln2472">    flags |= FC_SANDBOX;</a>
<a name="ln2473">  }</a>
<a name="ln2474">  fp-&gt;uf_flags = flags;</a>
<a name="ln2475">  fp-&gt;uf_calls = 0;</a>
<a name="ln2476">  fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln2477">  fp-&gt;uf_script_ctx.sc_lnum += sourcing_lnum_top;</a>
<a name="ln2478"> </a>
<a name="ln2479">  goto ret_free;</a>
<a name="ln2480"> </a>
<a name="ln2481">erret:</a>
<a name="ln2482">  ga_clear_strings(&amp;newargs);</a>
<a name="ln2483">errret_2:</a>
<a name="ln2484">  ga_clear_strings(&amp;newlines);</a>
<a name="ln2485">ret_free:</a>
<a name="ln2486">  xfree(skip_until);</a>
<a name="ln2487">  xfree(heredoc_trimmed);</a>
<a name="ln2488">  xfree(line_to_free);</a>
<a name="ln2489">  xfree(fudi.fd_newkey);</a>
<a name="ln2490">  xfree(name);</a>
<a name="ln2491">  did_emsg |= saved_did_emsg;</a>
<a name="ln2492">  need_wait_return |= saved_wait_return;</a>
<a name="ln2493">  if (show_block) {</a>
<a name="ln2494">    ui_ext_cmdline_block_leave();</a>
<a name="ln2495">  }</a>
<a name="ln2496">}  // NOLINT(readability/fn_size)</a>
<a name="ln2497"> </a>
<a name="ln2498">/*</a>
<a name="ln2499"> * Return 5 if &quot;p&quot; starts with &quot;&lt;SID&gt;&quot; or &quot;&lt;SNR&gt;&quot; (ignoring case).</a>
<a name="ln2500"> * Return 2 if &quot;p&quot; starts with &quot;s:&quot;.</a>
<a name="ln2501"> * Return 0 otherwise.</a>
<a name="ln2502"> */</a>
<a name="ln2503">int eval_fname_script(const char *const p)</a>
<a name="ln2504">{</a>
<a name="ln2505">  // Use mb_strnicmp() because in Turkish comparing the &quot;I&quot; may not work with</a>
<a name="ln2506">  // the standard library function.</a>
<a name="ln2507">  if (p[0] == '&lt;'</a>
<a name="ln2508">      &amp;&amp; (mb_strnicmp((char_u *)p + 1, (char_u *)&quot;SID&gt;&quot;, 4) == 0</a>
<a name="ln2509">          || mb_strnicmp((char_u *)p + 1, (char_u *)&quot;SNR&gt;&quot;, 4) == 0)) {</a>
<a name="ln2510">    return 5;</a>
<a name="ln2511">  }</a>
<a name="ln2512">  if (p[0] == 's' &amp;&amp; p[1] == ':') {</a>
<a name="ln2513">    return 2;</a>
<a name="ln2514">  }</a>
<a name="ln2515">  return 0;</a>
<a name="ln2516">}</a>
<a name="ln2517"> </a>
<a name="ln2518">bool translated_function_exists(const char *name)</a>
<a name="ln2519">{</a>
<a name="ln2520">  if (builtin_function(name, -1)) {</a>
<a name="ln2521">    return find_internal_func((char *)name) != NULL;</a>
<a name="ln2522">  }</a>
<a name="ln2523">  return find_func((const char_u *)name) != NULL;</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">/// Check whether function with the given name exists</a>
<a name="ln2527">///</a>
<a name="ln2528">/// @param[in]  name  Function name.</a>
<a name="ln2529">/// @param[in]  no_deref  Whether to dereference a Funcref.</a>
<a name="ln2530">///</a>
<a name="ln2531">/// @return True if it exists, false otherwise.</a>
<a name="ln2532">bool function_exists(const char *const name, bool no_deref)</a>
<a name="ln2533">{</a>
<a name="ln2534">  const char_u *nm = (const char_u *)name;</a>
<a name="ln2535">  bool n = false;</a>
<a name="ln2536">  int flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;</a>
<a name="ln2537"> </a>
<a name="ln2538">  if (no_deref) {</a>
<a name="ln2539">    flag |= TFN_NO_DEREF;</a>
<a name="ln2540">  }</a>
<a name="ln2541">  char *const p = (char *)trans_function_name((char_u **)&amp;nm, false, flag, NULL,</a>
<a name="ln2542">                                              NULL);</a>
<a name="ln2543">  nm = skipwhite(nm);</a>
<a name="ln2544"> </a>
<a name="ln2545">  /* Only accept &quot;funcname&quot;, &quot;funcname &quot;, &quot;funcname (...&quot; and</a>
<a name="ln2546">   * &quot;funcname(...&quot;, not &quot;funcname!...&quot;. */</a>
<a name="ln2547">  if (p != NULL &amp;&amp; (*nm == NUL || *nm == '(')) {</a>
<a name="ln2548">    n = translated_function_exists(p);</a>
<a name="ln2549">  }</a>
<a name="ln2550">  xfree(p);</a>
<a name="ln2551">  return n;</a>
<a name="ln2552">}</a>
<a name="ln2553"> </a>
<a name="ln2554">/*</a>
<a name="ln2555"> * Function given to ExpandGeneric() to obtain the list of user defined</a>
<a name="ln2556"> * function names.</a>
<a name="ln2557"> */</a>
<a name="ln2558">char_u *get_user_func_name(expand_T *xp, int idx)</a>
<a name="ln2559">{</a>
<a name="ln2560">  static size_t done;</a>
<a name="ln2561">  static hashitem_T   *hi;</a>
<a name="ln2562">  ufunc_T             *fp;</a>
<a name="ln2563"> </a>
<a name="ln2564">  if (idx == 0) {</a>
<a name="ln2565">    done = 0;</a>
<a name="ln2566">    hi = func_hashtab.ht_array;</a>
<a name="ln2567">  }</a>
<a name="ln2568">  assert(hi);</a>
<a name="ln2569">  if (done &lt; func_hashtab.ht_used) {</a>
<a name="ln2570">    if (done++ &gt; 0)</a>
<a name="ln2571">      ++hi;</a>
<a name="ln2572">    while (HASHITEM_EMPTY(hi))</a>
<a name="ln2573">      ++hi;</a>
<a name="ln2574">    fp = HI2UF(hi);</a>
<a name="ln2575"> </a>
<a name="ln2576">    if ((fp-&gt;uf_flags &amp; FC_DICT)</a>
<a name="ln2577">        || STRNCMP(fp-&gt;uf_name, &quot;&lt;lambda&gt;&quot;, 8) == 0) {</a>
<a name="ln2578">      return (char_u *)&quot;&quot;;       // don't show dict and lambda functions</a>
<a name="ln2579">    }</a>
<a name="ln2580"> </a>
<a name="ln2581">    if (STRLEN(fp-&gt;uf_name) + 4 &gt;= IOSIZE) {</a>
<a name="ln2582">      return fp-&gt;uf_name;  // Prevent overflow.</a>
<a name="ln2583">    }</a>
<a name="ln2584"> </a>
<a name="ln2585">    cat_func_name(IObuff, fp);</a>
<a name="ln2586">    if (xp-&gt;xp_context != EXPAND_USER_FUNC) {</a>
<a name="ln2587">      STRCAT(IObuff, &quot;(&quot;);</a>
<a name="ln2588">      if (!fp-&gt;uf_varargs &amp;&amp; GA_EMPTY(&amp;fp-&gt;uf_args))</a>
<a name="ln2589">        STRCAT(IObuff, &quot;)&quot;);</a>
<a name="ln2590">    }</a>
<a name="ln2591">    return IObuff;</a>
<a name="ln2592">  }</a>
<a name="ln2593">  return NULL;</a>
<a name="ln2594">}</a>
<a name="ln2595"> </a>
<a name="ln2596">/// &quot;:delfunction {name}&quot;</a>
<a name="ln2597">void ex_delfunction(exarg_T *eap)</a>
<a name="ln2598">{</a>
<a name="ln2599">  ufunc_T     *fp = NULL;</a>
<a name="ln2600">  char_u      *p;</a>
<a name="ln2601">  char_u      *name;</a>
<a name="ln2602">  funcdict_T fudi;</a>
<a name="ln2603"> </a>
<a name="ln2604">  p = eap-&gt;arg;</a>
<a name="ln2605">  name = trans_function_name(&amp;p, eap-&gt;skip, 0, &amp;fudi, NULL);</a>
<a name="ln2606">  xfree(fudi.fd_newkey);</a>
<a name="ln2607">  if (name == NULL) {</a>
<a name="ln2608">    if (fudi.fd_dict != NULL &amp;&amp; !eap-&gt;skip)</a>
<a name="ln2609">      EMSG(_(e_funcref));</a>
<a name="ln2610">    return;</a>
<a name="ln2611">  }</a>
<a name="ln2612">  if (!ends_excmd(*skipwhite(p))) {</a>
<a name="ln2613">    xfree(name);</a>
<a name="ln2614">    EMSG(_(e_trailing));</a>
<a name="ln2615">    return;</a>
<a name="ln2616">  }</a>
<a name="ln2617">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln2618">  if (eap-&gt;nextcmd != NULL)</a>
<a name="ln2619">    *p = NUL;</a>
<a name="ln2620"> </a>
<a name="ln2621">  if (!eap-&gt;skip)</a>
<a name="ln2622">    fp = find_func(name);</a>
<a name="ln2623">  xfree(name);</a>
<a name="ln2624"> </a>
<a name="ln2625">  if (!eap-&gt;skip) {</a>
<a name="ln2626">    if (fp == NULL) {</a>
<a name="ln2627">      if (!eap-&gt;forceit) {</a>
<a name="ln2628">        EMSG2(_(e_nofunc), eap-&gt;arg);</a>
<a name="ln2629">      }</a>
<a name="ln2630">      return;</a>
<a name="ln2631">    }</a>
<a name="ln2632">    if (fp-&gt;uf_calls &gt; 0) {</a>
<a name="ln2633">      EMSG2(_(&quot;E131: Cannot delete function %s: It is in use&quot;), eap-&gt;arg);</a>
<a name="ln2634">      return;</a>
<a name="ln2635">    }</a>
<a name="ln2636">    // check `uf_refcount &gt; 2` because deleting a function should also reduce</a>
<a name="ln2637">    // the reference count, and 1 is the initial refcount.</a>
<a name="ln2638">    if (fp-&gt;uf_refcount &gt; 2) {</a>
<a name="ln2639">      EMSG2(_(&quot;Cannot delete function %s: It is being used internally&quot;),</a>
<a name="ln2640">          eap-&gt;arg);</a>
<a name="ln2641">      return;</a>
<a name="ln2642">    }</a>
<a name="ln2643"> </a>
<a name="ln2644">    if (fudi.fd_dict != NULL) {</a>
<a name="ln2645">      // Delete the dict item that refers to the function, it will</a>
<a name="ln2646">      // invoke func_unref() and possibly delete the function.</a>
<a name="ln2647">      tv_dict_item_remove(fudi.fd_dict, fudi.fd_di);</a>
<a name="ln2648">    } else {</a>
<a name="ln2649">      // A normal function (not a numbered function or lambda) has a</a>
<a name="ln2650">      // refcount of 1 for the entry in the hashtable.  When deleting</a>
<a name="ln2651">      // it and the refcount is more than one, it should be kept.</a>
<a name="ln2652">      // A numbered function or lambda should be kept if the refcount is</a>
<a name="ln2653">      // one or more.</a>
<a name="ln2654">      if (fp-&gt;uf_refcount &gt; (func_name_refcount(fp-&gt;uf_name) ? 0 : 1)) {</a>
<a name="ln2655">        // Function is still referenced somewhere. Don't free it but</a>
<a name="ln2656">        // do remove it from the hashtable.</a>
<a name="ln2657">        if (func_remove(fp)) {</a>
<a name="ln2658">          fp-&gt;uf_refcount--;</a>
<a name="ln2659">        }</a>
<a name="ln2660">        fp-&gt;uf_flags |= FC_DELETED;</a>
<a name="ln2661">      } else {</a>
<a name="ln2662">        func_clear_free(fp, false);</a>
<a name="ln2663">      }</a>
<a name="ln2664">    }</a>
<a name="ln2665">  }</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">/*</a>
<a name="ln2669"> * Unreference a Function: decrement the reference count and free it when it</a>
<a name="ln2670"> * becomes zero.</a>
<a name="ln2671"> */</a>
<a name="ln2672">void func_unref(char_u *name)</a>
<a name="ln2673">{</a>
<a name="ln2674">  ufunc_T *fp = NULL;</a>
<a name="ln2675"> </a>
<a name="ln2676">  if (name == NULL || !func_name_refcount(name)) {</a>
<a name="ln2677">    return;</a>
<a name="ln2678">  }</a>
<a name="ln2679"> </a>
<a name="ln2680">  fp = find_func(name);</a>
<a name="ln2681">  if (fp == NULL &amp;&amp; isdigit(*name)) {</a>
<a name="ln2682">#ifdef EXITFREE</a>
<a name="ln2683">    if (!entered_free_all_mem) {</a>
<a name="ln2684">      internal_error(&quot;func_unref()&quot;);</a>
<a name="ln2685">      abort();</a>
<a name="ln2686">    }</a>
<a name="ln2687">#else</a>
<a name="ln2688">      internal_error(&quot;func_unref()&quot;);</a>
<a name="ln2689">      abort();</a>
<a name="ln2690">#endif</a>
<a name="ln2691">  }</a>
<a name="ln2692">  func_ptr_unref(fp);</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695">/// Unreference a Function: decrement the reference count and free it when it</a>
<a name="ln2696">/// becomes zero.</a>
<a name="ln2697">/// Unreference user function, freeing it if needed</a>
<a name="ln2698">///</a>
<a name="ln2699">/// Decrements the reference count and frees when it becomes zero.</a>
<a name="ln2700">///</a>
<a name="ln2701">/// @param  fp  Function to unreference.</a>
<a name="ln2702">void func_ptr_unref(ufunc_T *fp)</a>
<a name="ln2703">{</a>
<a name="ln2704">  if (fp != NULL &amp;&amp; --fp-&gt;uf_refcount &lt;= 0) {</a>
<a name="ln2705">    // Only delete it when it's not being used. Otherwise it's done</a>
<a name="ln2706">    // when &quot;uf_calls&quot; becomes zero.</a>
<a name="ln2707">    if (fp-&gt;uf_calls == 0) {</a>
<a name="ln2708">      func_clear_free(fp, false);</a>
<a name="ln2709">    }</a>
<a name="ln2710">  }</a>
<a name="ln2711">}</a>
<a name="ln2712"> </a>
<a name="ln2713">/// Count a reference to a Function.</a>
<a name="ln2714">void func_ref(char_u *name)</a>
<a name="ln2715">{</a>
<a name="ln2716">  ufunc_T *fp;</a>
<a name="ln2717"> </a>
<a name="ln2718">  if (name == NULL || !func_name_refcount(name)) {</a>
<a name="ln2719">    return;</a>
<a name="ln2720">  }</a>
<a name="ln2721">  fp = find_func(name);</a>
<a name="ln2722">  if (fp != NULL) {</a>
<a name="ln2723">    (fp-&gt;uf_refcount)++;</a>
<a name="ln2724">  } else if (isdigit(*name)) {</a>
<a name="ln2725">    // Only give an error for a numbered function.</a>
<a name="ln2726">    // Fail silently, when named or lambda function isn't found.</a>
<a name="ln2727">    internal_error(&quot;func_ref()&quot;);</a>
<a name="ln2728">  }</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">/// Count a reference to a Function.</a>
<a name="ln2732">void func_ptr_ref(ufunc_T *fp)</a>
<a name="ln2733">{</a>
<a name="ln2734">  if (fp != NULL) {</a>
<a name="ln2735">    (fp-&gt;uf_refcount)++;</a>
<a name="ln2736">  }</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739">/// Check whether funccall is still referenced outside</a>
<a name="ln2740">///</a>
<a name="ln2741">/// It is supposed to be referenced if either it is referenced itself or if l:,</a>
<a name="ln2742">/// a: or a:000 are referenced as all these are statically allocated within</a>
<a name="ln2743">/// funccall structure.</a>
<a name="ln2744">static inline bool fc_referenced(const funccall_T *const fc)</a>
<a name="ln2745">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2746">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2747">{</a>
<a name="ln2748">  return ((fc-&gt;l_varlist.lv_refcount  // NOLINT(runtime/deprecated)</a>
<a name="ln2749">           != DO_NOT_FREE_CNT)</a>
<a name="ln2750">          || fc-&gt;l_vars.dv_refcount != DO_NOT_FREE_CNT</a>
<a name="ln2751">          || fc-&gt;l_avars.dv_refcount != DO_NOT_FREE_CNT</a>
<a name="ln2752">          || fc-&gt;fc_refcount &gt; 0);</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">/// @return true if items in &quot;fc&quot; do not have &quot;copyID&quot;.  That means they are not</a>
<a name="ln2756">/// referenced from anywhere that is in use.</a>
<a name="ln2757">static int can_free_funccal(funccall_T *fc, int copyID)</a>
<a name="ln2758">{</a>
<a name="ln2759">  return fc-&gt;l_varlist.lv_copyID != copyID</a>
<a name="ln2760">         &amp;&amp; fc-&gt;l_vars.dv_copyID != copyID</a>
<a name="ln2761">         &amp;&amp; fc-&gt;l_avars.dv_copyID != copyID</a>
<a name="ln2762">         &amp;&amp; fc-&gt;fc_copyID != copyID;</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">/*</a>
<a name="ln2766"> * &quot;:return [expr]&quot;</a>
<a name="ln2767"> */</a>
<a name="ln2768">void ex_return(exarg_T *eap)</a>
<a name="ln2769">{</a>
<a name="ln2770">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln2771">  typval_T rettv;</a>
<a name="ln2772">  int returning = FALSE;</a>
<a name="ln2773"> </a>
<a name="ln2774">  if (current_funccal == NULL) {</a>
<a name="ln2775">    EMSG(_(&quot;E133: :return not inside a function&quot;));</a>
<a name="ln2776">    return;</a>
<a name="ln2777">  }</a>
<a name="ln2778"> </a>
<a name="ln2779">  if (eap-&gt;skip)</a>
<a name="ln2780">    ++emsg_skip;</a>
<a name="ln2781"> </a>
<a name="ln2782">  eap-&gt;nextcmd = NULL;</a>
<a name="ln2783">  if ((*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n')</a>
<a name="ln2784">      &amp;&amp; eval0(arg, &amp;rettv, &amp;eap-&gt;nextcmd, !eap-&gt;skip) != FAIL) {</a>
<a name="ln2785">    if (!eap-&gt;skip) {</a>
<a name="ln2786">      returning = do_return(eap, false, true, &amp;rettv);</a>
<a name="ln2787">    } else {</a>
<a name="ln2788">      tv_clear(&amp;rettv);</a>
<a name="ln2789">    }</a>
<a name="ln2790">  } else if (!eap-&gt;skip) {  // It's safer to return also on error.</a>
<a name="ln2791">    // In return statement, cause_abort should be force_abort.</a>
<a name="ln2792">    update_force_abort();</a>
<a name="ln2793"> </a>
<a name="ln2794">    // Return unless the expression evaluation has been cancelled due to an</a>
<a name="ln2795">    // aborting error, an interrupt, or an exception.</a>
<a name="ln2796">    if (!aborting()) {</a>
<a name="ln2797">      returning = do_return(eap, false, true, NULL);</a>
<a name="ln2798">    }</a>
<a name="ln2799">  }</a>
<a name="ln2800"> </a>
<a name="ln2801">  /* When skipping or the return gets pending, advance to the next command</a>
<a name="ln2802">   * in this line (!returning).  Otherwise, ignore the rest of the line.</a>
<a name="ln2803">   * Following lines will be ignored by get_func_line(). */</a>
<a name="ln2804">  if (returning) {</a>
<a name="ln2805">    eap-&gt;nextcmd = NULL;</a>
<a name="ln2806">  } else if (eap-&gt;nextcmd == NULL) {          // no argument</a>
<a name="ln2807">    eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  if (eap-&gt;skip)</a>
<a name="ln2811">    --emsg_skip;</a>
<a name="ln2812">}</a>
<a name="ln2813"> </a>
<a name="ln2814">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2815"> </a>
<a name="ln2816">/*</a>
<a name="ln2817"> * &quot;:1,25call func(arg1, arg2)&quot;	function call.</a>
<a name="ln2818"> */</a>
<a name="ln2819">void ex_call(exarg_T *eap)</a>
<a name="ln2820">{</a>
<a name="ln2821">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln2822">  char_u      *startarg;</a>
<a name="ln2823">  char_u      *name;</a>
<a name="ln2824">  char_u      *tofree;</a>
<a name="ln2825">  int len;</a>
<a name="ln2826">  typval_T rettv;</a>
<a name="ln2827">  linenr_T lnum;</a>
<a name="ln2828">  int doesrange;</a>
<a name="ln2829">  bool failed = false;</a>
<a name="ln2830">  funcdict_T fudi;</a>
<a name="ln2831">  partial_T *partial = NULL;</a>
<a name="ln2832"> </a>
<a name="ln2833">  if (eap-&gt;skip) {</a>
<a name="ln2834">    // trans_function_name() doesn't work well when skipping, use eval0()</a>
<a name="ln2835">    // instead to skip to any following command, e.g. for:</a>
<a name="ln2836">    //   :if 0 | call dict.foo().bar() | endif.</a>
<a name="ln2837">    emsg_skip++;</a>
<a name="ln2838">    if (eval0(eap-&gt;arg, &amp;rettv, &amp;eap-&gt;nextcmd, false) != FAIL) {</a>
<a name="ln2839">      tv_clear(&amp;rettv);</a>
<a name="ln2840">    }</a>
<a name="ln2841">    emsg_skip--;</a>
<a name="ln2842">    return;</a>
<a name="ln2843">  }</a>
<a name="ln2844"> </a>
<a name="ln2845">  tofree = trans_function_name(&amp;arg, false, TFN_INT, &amp;fudi, &amp;partial);</a>
<a name="ln2846">  if (fudi.fd_newkey != NULL) {</a>
<a name="ln2847">    // Still need to give an error message for missing key.</a>
<a name="ln2848">    EMSG2(_(e_dictkey), fudi.fd_newkey);</a>
<a name="ln2849">    xfree(fudi.fd_newkey);</a>
<a name="ln2850">  }</a>
<a name="ln2851">  if (tofree == NULL) {</a>
<a name="ln2852">    return;</a>
<a name="ln2853">  }</a>
<a name="ln2854"> </a>
<a name="ln2855">  // Increase refcount on dictionary, it could get deleted when evaluating</a>
<a name="ln2856">  // the arguments.</a>
<a name="ln2857">  if (fudi.fd_dict != NULL) {</a>
<a name="ln2858">    fudi.fd_dict-&gt;dv_refcount++;</a>
<a name="ln2859">  }</a>
<a name="ln2860"> </a>
<a name="ln2861">  // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its</a>
<a name="ln2862">  // contents. For VAR_PARTIAL get its partial, unless we already have one</a>
<a name="ln2863">  // from trans_function_name().</a>
<a name="ln2864">  len = (int)STRLEN(tofree);</a>
<a name="ln2865">  name = deref_func_name((const char *)tofree, &amp;len,</a>
<a name="ln2866">                         partial != NULL ? NULL : &amp;partial, false);</a>
<a name="ln2867"> </a>
<a name="ln2868">  // Skip white space to allow &quot;:call func ()&quot;.  Not good, but required for</a>
<a name="ln2869">  // backward compatibility.</a>
<a name="ln2870">  startarg = skipwhite(arg);</a>
<a name="ln2871">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this.</a>
<a name="ln2872"> </a>
<a name="ln2873">  if (*startarg != '(') {</a>
<a name="ln2874">    EMSG2(_(&quot;E107: Missing parentheses: %s&quot;), eap-&gt;arg);</a>
<a name="ln2875">    goto end;</a>
<a name="ln2876">  }</a>
<a name="ln2877"> </a>
<a name="ln2878">  lnum = eap-&gt;line1;</a>
<a name="ln2879">  for (; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln2880">    if (eap-&gt;addr_count &gt; 0) {  // -V560</a>
<a name="ln2881">      if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2882">        // If the function deleted lines or switched to another buffer</a>
<a name="ln2883">        // the line number may become invalid.</a>
<a name="ln2884">        EMSG(_(e_invrange));</a>
<a name="ln2885">        break;</a>
<a name="ln2886">      }</a>
<a name="ln2887">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2888">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2889">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2890">    }</a>
<a name="ln2891">    arg = startarg;</a>
<a name="ln2892">    if (get_func_tv(name, -1, &amp;rettv, &amp;arg,</a>
<a name="ln2893">                    eap-&gt;line1, eap-&gt;line2, &amp;doesrange,</a>
<a name="ln2894">                    true, partial, fudi.fd_dict) == FAIL) {</a>
<a name="ln2895">      failed = true;</a>
<a name="ln2896">      break;</a>
<a name="ln2897">    }</a>
<a name="ln2898"> </a>
<a name="ln2899">    // Handle a function returning a Funcref, Dictionary or List.</a>
<a name="ln2900">    if (handle_subscript((const char **)&amp;arg, &amp;rettv, true, true)</a>
<a name="ln2901">        == FAIL) {</a>
<a name="ln2902">      failed = true;</a>
<a name="ln2903">      break;</a>
<a name="ln2904">    }</a>
<a name="ln2905"> </a>
<a name="ln2906">    tv_clear(&amp;rettv);</a>
<a name="ln2907">    if (doesrange) {</a>
<a name="ln2908">      break;</a>
<a name="ln2909">    }</a>
<a name="ln2910"> </a>
<a name="ln2911">    // Stop when immediately aborting on error, or when an interrupt</a>
<a name="ln2912">    // occurred or an exception was thrown but not caught.</a>
<a name="ln2913">    // get_func_tv() returned OK, so that the check for trailing</a>
<a name="ln2914">    // characters below is executed.</a>
<a name="ln2915">    if (aborting()) {</a>
<a name="ln2916">      break;</a>
<a name="ln2917">    }</a>
<a name="ln2918">  }</a>
<a name="ln2919"> </a>
<a name="ln2920">  // When inside :try we need to check for following &quot;| catch&quot;.</a>
<a name="ln2921">  if (!failed || eap-&gt;cstack-&gt;cs_trylevel &gt; 0) {</a>
<a name="ln2922">    // Check for trailing illegal characters and a following command.</a>
<a name="ln2923">    if (!ends_excmd(*arg)) {</a>
<a name="ln2924">      if (!failed) {</a>
<a name="ln2925">        emsg_severe = true;</a>
<a name="ln2926">        EMSG(_(e_trailing));</a>
<a name="ln2927">      }</a>
<a name="ln2928">    } else {</a>
<a name="ln2929">      eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln2930">    }</a>
<a name="ln2931">  }</a>
<a name="ln2932"> </a>
<a name="ln2933">end:</a>
<a name="ln2934">  tv_dict_unref(fudi.fd_dict);</a>
<a name="ln2935">  xfree(tofree);</a>
<a name="ln2936">}</a>
<a name="ln2937"> </a>
<a name="ln2938">/*</a>
<a name="ln2939"> * Return from a function.  Possibly makes the return pending.  Also called</a>
<a name="ln2940"> * for a pending return at the &quot;:endtry&quot; or after returning from an extra</a>
<a name="ln2941"> * do_cmdline().  &quot;reanimate&quot; is used in the latter case.  &quot;is_cmd&quot; is set</a>
<a name="ln2942"> * when called due to a &quot;:return&quot; command.  &quot;rettv&quot; may point to a typval_T</a>
<a name="ln2943"> * with the return rettv.  Returns TRUE when the return can be carried out,</a>
<a name="ln2944"> * FALSE when the return gets pending.</a>
<a name="ln2945"> */</a>
<a name="ln2946">int do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv)</a>
<a name="ln2947">{</a>
<a name="ln2948">  int idx;</a>
<a name="ln2949">  cstack_T *const cstack = eap-&gt;cstack;</a>
<a name="ln2950"> </a>
<a name="ln2951">  if (reanimate) {</a>
<a name="ln2952">    // Undo the return.</a>
<a name="ln2953">    current_funccal-&gt;returned = false;</a>
<a name="ln2954">  }</a>
<a name="ln2955"> </a>
<a name="ln2956">  /*</a>
<a name="ln2957">   * Cleanup (and inactivate) conditionals, but stop when a try conditional</a>
<a name="ln2958">   * not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln2959">   * In this case, make the &quot;:return&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln2960">   * Otherwise, return normally.</a>
<a name="ln2961">   */</a>
<a name="ln2962">  idx = cleanup_conditionals(eap-&gt;cstack, 0, TRUE);</a>
<a name="ln2963">  if (idx &gt;= 0) {</a>
<a name="ln2964">    cstack-&gt;cs_pending[idx] = CSTP_RETURN;</a>
<a name="ln2965"> </a>
<a name="ln2966">    if (!is_cmd &amp;&amp; !reanimate)</a>
<a name="ln2967">      /* A pending return again gets pending.  &quot;rettv&quot; points to an</a>
<a name="ln2968">       * allocated variable with the rettv of the original &quot;:return&quot;'s</a>
<a name="ln2969">       * argument if present or is NULL else. */</a>
<a name="ln2970">      cstack-&gt;cs_rettv[idx] = rettv;</a>
<a name="ln2971">    else {</a>
<a name="ln2972">      /* When undoing a return in order to make it pending, get the stored</a>
<a name="ln2973">       * return rettv. */</a>
<a name="ln2974">      if (reanimate) {</a>
<a name="ln2975">        assert(current_funccal-&gt;rettv);</a>
<a name="ln2976">        rettv = current_funccal-&gt;rettv;</a>
<a name="ln2977">      }</a>
<a name="ln2978"> </a>
<a name="ln2979">      if (rettv != NULL) {</a>
<a name="ln2980">        // Store the value of the pending return.</a>
<a name="ln2981">        cstack-&gt;cs_rettv[idx] = xcalloc(1, sizeof(typval_T));</a>
<a name="ln2982">        *(typval_T *)cstack-&gt;cs_rettv[idx] = *(typval_T *)rettv;</a>
<a name="ln2983">      } else</a>
<a name="ln2984">        cstack-&gt;cs_rettv[idx] = NULL;</a>
<a name="ln2985"> </a>
<a name="ln2986">      if (reanimate) {</a>
<a name="ln2987">        /* The pending return value could be overwritten by a &quot;:return&quot;</a>
<a name="ln2988">         * without argument in a finally clause; reset the default</a>
<a name="ln2989">         * return value. */</a>
<a name="ln2990">        current_funccal-&gt;rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln2991">        current_funccal-&gt;rettv-&gt;vval.v_number = 0;</a>
<a name="ln2992">      }</a>
<a name="ln2993">    }</a>
<a name="ln2994">    report_make_pending(CSTP_RETURN, rettv);</a>
<a name="ln2995">  } else {</a>
<a name="ln2996">    current_funccal-&gt;returned = TRUE;</a>
<a name="ln2997"> </a>
<a name="ln2998">    /* If the return is carried out now, store the return value.  For</a>
<a name="ln2999">     * a return immediately after reanimation, the value is already</a>
<a name="ln3000">     * there. */</a>
<a name="ln3001">    if (!reanimate &amp;&amp; rettv != NULL) {</a>
<a name="ln3002">      tv_clear(current_funccal-&gt;rettv);</a>
<a name="ln3003">      *current_funccal-&gt;rettv = *(typval_T *)rettv;</a>
<a name="ln3004">      if (!is_cmd)</a>
<a name="ln3005">        xfree(rettv);</a>
<a name="ln3006">    }</a>
<a name="ln3007">  }</a>
<a name="ln3008"> </a>
<a name="ln3009">  return idx &lt; 0;</a>
<a name="ln3010">}</a>
<a name="ln3011"> </a>
<a name="ln3012">/*</a>
<a name="ln3013"> * Generate a return command for producing the value of &quot;rettv&quot;.  The result</a>
<a name="ln3014"> * is an allocated string.  Used by report_pending() for verbose messages.</a>
<a name="ln3015"> */</a>
<a name="ln3016">char_u *get_return_cmd(void *rettv)</a>
<a name="ln3017">{</a>
<a name="ln3018">  char_u *s = NULL;</a>
<a name="ln3019">  char_u *tofree = NULL;</a>
<a name="ln3020"> </a>
<a name="ln3021">  if (rettv != NULL) {</a>
<a name="ln3022">    tofree = s = (char_u *) encode_tv2echo((typval_T *) rettv, NULL);</a>
<a name="ln3023">  }</a>
<a name="ln3024">  if (s == NULL) {</a>
<a name="ln3025">    s = (char_u *)&quot;&quot;;</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  STRCPY(IObuff, &quot;:return &quot;);</a>
<a name="ln3029">  STRLCPY(IObuff + 8, s, IOSIZE - 8);</a>
<a name="ln3030">  if (STRLEN(s) + 8 &gt;= IOSIZE)</a>
<a name="ln3031">    STRCPY(IObuff + IOSIZE - 4, &quot;...&quot;);</a>
<a name="ln3032">  xfree(tofree);</a>
<a name="ln3033">  return vim_strsave(IObuff);</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036">/*</a>
<a name="ln3037"> * Get next function line.</a>
<a name="ln3038"> * Called by do_cmdline() to get the next line.</a>
<a name="ln3039"> * Returns allocated string, or NULL for end of function.</a>
<a name="ln3040"> */</a>
<a name="ln3041">char_u *get_func_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3042">{</a>
<a name="ln3043">  funccall_T  *fcp = (funccall_T *)cookie;</a>
<a name="ln3044">  ufunc_T     *fp = fcp-&gt;func;</a>
<a name="ln3045">  char_u      *retval;</a>
<a name="ln3046">  garray_T    *gap;    // growarray with function lines</a>
<a name="ln3047"> </a>
<a name="ln3048">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3049">  if (fcp-&gt;dbg_tick != debug_tick) {</a>
<a name="ln3050">    fcp-&gt;breakpoint = dbg_find_breakpoint(FALSE, fp-&gt;uf_name,</a>
<a name="ln3051">        sourcing_lnum);</a>
<a name="ln3052">    fcp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3053">  }</a>
<a name="ln3054">  if (do_profiling == PROF_YES)</a>
<a name="ln3055">    func_line_end(cookie);</a>
<a name="ln3056"> </a>
<a name="ln3057">  gap = &amp;fp-&gt;uf_lines;</a>
<a name="ln3058">  if (((fp-&gt;uf_flags &amp; FC_ABORT) &amp;&amp; did_emsg &amp;&amp; !aborted_in_try())</a>
<a name="ln3059">      || fcp-&gt;returned) {</a>
<a name="ln3060">    retval = NULL;</a>
<a name="ln3061">  } else {</a>
<a name="ln3062">    // Skip NULL lines (continuation lines).</a>
<a name="ln3063">    while (fcp-&gt;linenr &lt; gap-&gt;ga_len</a>
<a name="ln3064">           &amp;&amp; ((char_u **)(gap-&gt;ga_data))[fcp-&gt;linenr] == NULL) {</a>
<a name="ln3065">      fcp-&gt;linenr++;</a>
<a name="ln3066">    }</a>
<a name="ln3067">    if (fcp-&gt;linenr &gt;= gap-&gt;ga_len) {</a>
<a name="ln3068">      retval = NULL;</a>
<a name="ln3069">    } else {</a>
<a name="ln3070">      retval = vim_strsave(((char_u **)(gap-&gt;ga_data))[fcp-&gt;linenr++]);</a>
<a name="ln3071">      sourcing_lnum = fcp-&gt;linenr;</a>
<a name="ln3072">      if (do_profiling == PROF_YES)</a>
<a name="ln3073">        func_line_start(cookie);</a>
<a name="ln3074">    }</a>
<a name="ln3075">  }</a>
<a name="ln3076"> </a>
<a name="ln3077">  // Did we encounter a breakpoint?</a>
<a name="ln3078">  if (fcp-&gt;breakpoint != 0 &amp;&amp; fcp-&gt;breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln3079">    dbg_breakpoint(fp-&gt;uf_name, sourcing_lnum);</a>
<a name="ln3080">    // Find next breakpoint.</a>
<a name="ln3081">    fcp-&gt;breakpoint = dbg_find_breakpoint(false, fp-&gt;uf_name,</a>
<a name="ln3082">                                          sourcing_lnum);</a>
<a name="ln3083">    fcp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3084">  }</a>
<a name="ln3085"> </a>
<a name="ln3086">  return retval;</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089">/*</a>
<a name="ln3090"> * Return TRUE if the currently active function should be ended, because a</a>
<a name="ln3091"> * return was encountered or an error occurred.  Used inside a &quot;:while&quot;.</a>
<a name="ln3092"> */</a>
<a name="ln3093">int func_has_ended(void *cookie)</a>
<a name="ln3094">{</a>
<a name="ln3095">  funccall_T  *fcp = (funccall_T *)cookie;</a>
<a name="ln3096"> </a>
<a name="ln3097">  /* Ignore the &quot;abort&quot; flag if the abortion behavior has been changed due to</a>
<a name="ln3098">   * an error inside a try conditional. */</a>
<a name="ln3099">  return ((fcp-&gt;func-&gt;uf_flags &amp; FC_ABORT) &amp;&amp; did_emsg &amp;&amp; !aborted_in_try())</a>
<a name="ln3100">         || fcp-&gt;returned;</a>
<a name="ln3101">}</a>
<a name="ln3102"> </a>
<a name="ln3103">/*</a>
<a name="ln3104"> * return TRUE if cookie indicates a function which &quot;abort&quot;s on errors.</a>
<a name="ln3105"> */</a>
<a name="ln3106">int func_has_abort(void *cookie)</a>
<a name="ln3107">{</a>
<a name="ln3108">  return ((funccall_T *)cookie)-&gt;func-&gt;uf_flags &amp; FC_ABORT;</a>
<a name="ln3109">}</a>
<a name="ln3110"> </a>
<a name="ln3111">/// Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; bound to &quot;dict&quot;.</a>
<a name="ln3112">/// Changes &quot;rettv&quot; in-place.</a>
<a name="ln3113">void make_partial(dict_T *const selfdict, typval_T *const rettv)</a>
<a name="ln3114">{</a>
<a name="ln3115">  char_u *fname;</a>
<a name="ln3116">  char_u *tofree = NULL;</a>
<a name="ln3117">  ufunc_T *fp;</a>
<a name="ln3118">  char_u fname_buf[FLEN_FIXED + 1];</a>
<a name="ln3119">  int error;</a>
<a name="ln3120"> </a>
<a name="ln3121">  if (rettv-&gt;v_type == VAR_PARTIAL &amp;&amp; rettv-&gt;vval.v_partial-&gt;pt_func != NULL) {</a>
<a name="ln3122">    fp = rettv-&gt;vval.v_partial-&gt;pt_func;</a>
<a name="ln3123">  } else {</a>
<a name="ln3124">    fname = rettv-&gt;v_type == VAR_FUNC || rettv-&gt;v_type == VAR_STRING</a>
<a name="ln3125">                                      ? rettv-&gt;vval.v_string</a>
<a name="ln3126">                                      : rettv-&gt;vval.v_partial-&gt;pt_name;</a>
<a name="ln3127">    // Translate &quot;s:func&quot; to the stored function name.</a>
<a name="ln3128">    fname = fname_trans_sid(fname, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln3129">    fp = find_func(fname);</a>
<a name="ln3130">    xfree(tofree);</a>
<a name="ln3131">  }</a>
<a name="ln3132"> </a>
<a name="ln3133">  // Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; with &quot;dict&quot;.</a>
<a name="ln3134">  if (fp != NULL &amp;&amp; (fp-&gt;uf_flags &amp; FC_DICT)) {</a>
<a name="ln3135">    partial_T *pt = (partial_T *)xcalloc(1, sizeof(partial_T));</a>
<a name="ln3136">    pt-&gt;pt_refcount = 1;</a>
<a name="ln3137">    pt-&gt;pt_dict = selfdict;</a>
<a name="ln3138">    (selfdict-&gt;dv_refcount)++;</a>
<a name="ln3139">    pt-&gt;pt_auto = true;</a>
<a name="ln3140">    if (rettv-&gt;v_type == VAR_FUNC || rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln3141">      // Just a function: Take over the function name and use selfdict.</a>
<a name="ln3142">      pt-&gt;pt_name = rettv-&gt;vval.v_string;</a>
<a name="ln3143">    } else {</a>
<a name="ln3144">      partial_T *ret_pt = rettv-&gt;vval.v_partial;</a>
<a name="ln3145">      int i;</a>
<a name="ln3146"> </a>
<a name="ln3147">      // Partial: copy the function name, use selfdict and copy</a>
<a name="ln3148">      // args. Can't take over name or args, the partial might</a>
<a name="ln3149">      // be referenced elsewhere.</a>
<a name="ln3150">      if (ret_pt-&gt;pt_name != NULL) {</a>
<a name="ln3151">        pt-&gt;pt_name = vim_strsave(ret_pt-&gt;pt_name);</a>
<a name="ln3152">        func_ref(pt-&gt;pt_name);</a>
<a name="ln3153">      } else {</a>
<a name="ln3154">        pt-&gt;pt_func = ret_pt-&gt;pt_func;</a>
<a name="ln3155">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln3156">      }</a>
<a name="ln3157">      if (ret_pt-&gt;pt_argc &gt; 0) {</a>
<a name="ln3158">        size_t arg_size = sizeof(typval_T) * ret_pt-&gt;pt_argc;</a>
<a name="ln3159">        pt-&gt;pt_argv = (typval_T *)xmalloc(arg_size);</a>
<a name="ln3160">        pt-&gt;pt_argc = ret_pt-&gt;pt_argc;</a>
<a name="ln3161">        for (i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln3162">          tv_copy(&amp;ret_pt-&gt;pt_argv[i], &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln3163">        }</a>
<a name="ln3164">      }</a>
<a name="ln3165">      partial_unref(ret_pt);</a>
<a name="ln3166">    }</a>
<a name="ln3167">    rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln3168">    rettv-&gt;vval.v_partial = pt;</a>
<a name="ln3169">  }</a>
<a name="ln3170">}</a>
<a name="ln3171"> </a>
<a name="ln3172">/*</a>
<a name="ln3173"> * Return the name of the executed function.</a>
<a name="ln3174"> */</a>
<a name="ln3175">char_u *func_name(void *cookie)</a>
<a name="ln3176">{</a>
<a name="ln3177">  return ((funccall_T *)cookie)-&gt;func-&gt;uf_name;</a>
<a name="ln3178">}</a>
<a name="ln3179"> </a>
<a name="ln3180">/*</a>
<a name="ln3181"> * Return the address holding the next breakpoint line for a funccall cookie.</a>
<a name="ln3182"> */</a>
<a name="ln3183">linenr_T *func_breakpoint(void *cookie)</a>
<a name="ln3184">{</a>
<a name="ln3185">  return &amp;((funccall_T *)cookie)-&gt;breakpoint;</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188">/*</a>
<a name="ln3189"> * Return the address holding the debug tick for a funccall cookie.</a>
<a name="ln3190"> */</a>
<a name="ln3191">int *func_dbg_tick(void *cookie)</a>
<a name="ln3192">{</a>
<a name="ln3193">  return &amp;((funccall_T *)cookie)-&gt;dbg_tick;</a>
<a name="ln3194">}</a>
<a name="ln3195"> </a>
<a name="ln3196">/*</a>
<a name="ln3197"> * Return the nesting level for a funccall cookie.</a>
<a name="ln3198"> */</a>
<a name="ln3199">int func_level(void *cookie)</a>
<a name="ln3200">{</a>
<a name="ln3201">  return ((funccall_T *)cookie)-&gt;level;</a>
<a name="ln3202">}</a>
<a name="ln3203"> </a>
<a name="ln3204">/*</a>
<a name="ln3205"> * Return TRUE when a function was ended by a &quot;:return&quot; command.</a>
<a name="ln3206"> */</a>
<a name="ln3207">int current_func_returned(void)</a>
<a name="ln3208">{</a>
<a name="ln3209">  return current_funccal-&gt;returned;</a>
<a name="ln3210">}</a>
<a name="ln3211"> </a>
<a name="ln3212">bool free_unref_funccal(int copyID, int testing)</a>
<a name="ln3213">{</a>
<a name="ln3214">  bool did_free = false;</a>
<a name="ln3215">  bool did_free_funccal = false;</a>
<a name="ln3216"> </a>
<a name="ln3217">  for (funccall_T **pfc = &amp;previous_funccal; *pfc != NULL;) {</a>
<a name="ln3218">    if (can_free_funccal(*pfc, copyID)) {</a>
<a name="ln3219">      funccall_T *fc = *pfc;</a>
<a name="ln3220">      *pfc = fc-&gt;caller;</a>
<a name="ln3221">      free_funccal_contents(fc);</a>
<a name="ln3222">      did_free = true;</a>
<a name="ln3223">      did_free_funccal = true;</a>
<a name="ln3224">    } else {</a>
<a name="ln3225">      pfc = &amp;(*pfc)-&gt;caller;</a>
<a name="ln3226">    }</a>
<a name="ln3227">  }</a>
<a name="ln3228">  if (did_free_funccal) {</a>
<a name="ln3229">    // When a funccal was freed some more items might be garbage</a>
<a name="ln3230">    // collected, so run again.</a>
<a name="ln3231">    (void)garbage_collect(testing);</a>
<a name="ln3232">  }</a>
<a name="ln3233">  return did_free;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">// Get function call environment based on backtrace debug level</a>
<a name="ln3237">funccall_T *get_funccal(void)</a>
<a name="ln3238">{</a>
<a name="ln3239">  funccall_T *funccal = current_funccal;</a>
<a name="ln3240">  if (debug_backtrace_level &gt; 0) {</a>
<a name="ln3241">    for (int i = 0; i &lt; debug_backtrace_level; i++) {</a>
<a name="ln3242">      funccall_T *temp_funccal = funccal-&gt;caller;</a>
<a name="ln3243">      if (temp_funccal) {</a>
<a name="ln3244">        funccal = temp_funccal;</a>
<a name="ln3245">      } else {</a>
<a name="ln3246">        // backtrace level overflow. reset to max</a>
<a name="ln3247">        debug_backtrace_level = i;</a>
<a name="ln3248">      }</a>
<a name="ln3249">    }</a>
<a name="ln3250">  }</a>
<a name="ln3251"> </a>
<a name="ln3252">  return funccal;</a>
<a name="ln3253">}</a>
<a name="ln3254"> </a>
<a name="ln3255">/// Return the hashtable used for local variables in the current funccal.</a>
<a name="ln3256">/// Return NULL if there is no current funccal.</a>
<a name="ln3257">hashtab_T *get_funccal_local_ht(void)</a>
<a name="ln3258">{</a>
<a name="ln3259">  if (current_funccal == NULL) {</a>
<a name="ln3260">    return NULL;</a>
<a name="ln3261">  }</a>
<a name="ln3262">  return &amp;get_funccal()-&gt;l_vars.dv_hashtab;</a>
<a name="ln3263">}</a>
<a name="ln3264"> </a>
<a name="ln3265">/// Return the l: scope variable.</a>
<a name="ln3266">/// Return NULL if there is no current funccal.</a>
<a name="ln3267">dictitem_T *get_funccal_local_var(void)</a>
<a name="ln3268">{</a>
<a name="ln3269">  if (current_funccal == NULL) {</a>
<a name="ln3270">    return NULL;</a>
<a name="ln3271">  }</a>
<a name="ln3272">  return (dictitem_T *)&amp;get_funccal()-&gt;l_vars_var;</a>
<a name="ln3273">}</a>
<a name="ln3274"> </a>
<a name="ln3275">/// Return the hashtable used for argument in the current funccal.</a>
<a name="ln3276">/// Return NULL if there is no current funccal.</a>
<a name="ln3277">hashtab_T *get_funccal_args_ht(void)</a>
<a name="ln3278">{</a>
<a name="ln3279">  if (current_funccal == NULL) {</a>
<a name="ln3280">    return NULL;</a>
<a name="ln3281">  }</a>
<a name="ln3282">  return &amp;get_funccal()-&gt;l_avars.dv_hashtab;</a>
<a name="ln3283">}</a>
<a name="ln3284"> </a>
<a name="ln3285">/// Return the a: scope variable.</a>
<a name="ln3286">/// Return NULL if there is no current funccal.</a>
<a name="ln3287">dictitem_T *get_funccal_args_var(void)</a>
<a name="ln3288">{</a>
<a name="ln3289">  if (current_funccal == NULL) {</a>
<a name="ln3290">    return NULL;</a>
<a name="ln3291">  }</a>
<a name="ln3292">  return (dictitem_T *)&amp;current_funccal-&gt;l_avars_var;</a>
<a name="ln3293">}</a>
<a name="ln3294"> </a>
<a name="ln3295">/*</a>
<a name="ln3296"> * List function variables, if there is a function.</a>
<a name="ln3297"> */</a>
<a name="ln3298">void list_func_vars(int *first)</a>
<a name="ln3299">{</a>
<a name="ln3300">  if (current_funccal != NULL) {</a>
<a name="ln3301">    list_hashtable_vars(&amp;current_funccal-&gt;l_vars.dv_hashtab, &quot;l:&quot;, false,</a>
<a name="ln3302">                        first);</a>
<a name="ln3303">  }</a>
<a name="ln3304">}</a>
<a name="ln3305"> </a>
<a name="ln3306">/// If &quot;ht&quot; is the hashtable for local variables in the current funccal, return</a>
<a name="ln3307">/// the dict that contains it.</a>
<a name="ln3308">/// Otherwise return NULL.</a>
<a name="ln3309">dict_T *get_current_funccal_dict(hashtab_T *ht)</a>
<a name="ln3310">{</a>
<a name="ln3311">  if (current_funccal != NULL &amp;&amp; ht == &amp;current_funccal-&gt;l_vars.dv_hashtab) {</a>
<a name="ln3312">    return &amp;current_funccal-&gt;l_vars;</a>
<a name="ln3313">  }</a>
<a name="ln3314">  return NULL;</a>
<a name="ln3315">}</a>
<a name="ln3316"> </a>
<a name="ln3317">/// Search hashitem in parent scope.</a>
<a name="ln3318">hashitem_T *find_hi_in_scoped_ht(const char *name, hashtab_T **pht)</a>
<a name="ln3319">{</a>
<a name="ln3320">  if (current_funccal == NULL || current_funccal-&gt;func-&gt;uf_scoped == NULL) {</a>
<a name="ln3321">    return NULL;</a>
<a name="ln3322">  }</a>
<a name="ln3323"> </a>
<a name="ln3324">  funccall_T *old_current_funccal = current_funccal;</a>
<a name="ln3325">  hashitem_T *hi = NULL;</a>
<a name="ln3326">  const size_t namelen = strlen(name);</a>
<a name="ln3327">  const char *varname;</a>
<a name="ln3328"> </a>
<a name="ln3329">  // Search in parent scope which is possible to reference from lambda</a>
<a name="ln3330">  current_funccal = current_funccal-&gt;func-&gt;uf_scoped;</a>
<a name="ln3331">  while (current_funccal != NULL) {</a>
<a name="ln3332">    hashtab_T *ht = find_var_ht(name, namelen, &amp;varname);</a>
<a name="ln3333">    if (ht != NULL &amp;&amp; *varname != NUL) {</a>
<a name="ln3334">      hi = hash_find_len(ht, varname, namelen - (varname - name));</a>
<a name="ln3335">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3336">        *pht = ht;</a>
<a name="ln3337">        break;</a>
<a name="ln3338">      }</a>
<a name="ln3339">    }</a>
<a name="ln3340">    if (current_funccal == current_funccal-&gt;func-&gt;uf_scoped) {</a>
<a name="ln3341">      break;</a>
<a name="ln3342">    }</a>
<a name="ln3343">    current_funccal = current_funccal-&gt;func-&gt;uf_scoped;</a>
<a name="ln3344">  }</a>
<a name="ln3345">  current_funccal = old_current_funccal;</a>
<a name="ln3346"> </a>
<a name="ln3347">  return hi;</a>
<a name="ln3348">}</a>
<a name="ln3349"> </a>
<a name="ln3350">/// Search variable in parent scope.</a>
<a name="ln3351">dictitem_T *find_var_in_scoped_ht(const char *name, const size_t namelen,</a>
<a name="ln3352">                                  int no_autoload)</a>
<a name="ln3353">{</a>
<a name="ln3354">  if (current_funccal == NULL || current_funccal-&gt;func-&gt;uf_scoped == NULL) {</a>
<a name="ln3355">    return NULL;</a>
<a name="ln3356">  }</a>
<a name="ln3357"> </a>
<a name="ln3358">  dictitem_T *v = NULL;</a>
<a name="ln3359">  funccall_T *old_current_funccal = current_funccal;</a>
<a name="ln3360">  const char *varname;</a>
<a name="ln3361"> </a>
<a name="ln3362">  // Search in parent scope which is possible to reference from lambda</a>
<a name="ln3363">  current_funccal = current_funccal-&gt;func-&gt;uf_scoped;</a>
<a name="ln3364">  while (current_funccal) {</a>
<a name="ln3365">    hashtab_T *ht = find_var_ht(name, namelen, &amp;varname);</a>
<a name="ln3366">    if (ht != NULL &amp;&amp; *varname != NUL) {</a>
<a name="ln3367">      v = find_var_in_ht(ht, *name, varname,</a>
<a name="ln3368">                         namelen - (size_t)(varname - name), no_autoload);</a>
<a name="ln3369">      if (v != NULL) {</a>
<a name="ln3370">        break;</a>
<a name="ln3371">      }</a>
<a name="ln3372">    }</a>
<a name="ln3373">    if (current_funccal == current_funccal-&gt;func-&gt;uf_scoped) {</a>
<a name="ln3374">      break;</a>
<a name="ln3375">    }</a>
<a name="ln3376">    current_funccal = current_funccal-&gt;func-&gt;uf_scoped;</a>
<a name="ln3377">  }</a>
<a name="ln3378">  current_funccal = old_current_funccal;</a>
<a name="ln3379"> </a>
<a name="ln3380">  return v;</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">/// Set &quot;copyID + 1&quot; in previous_funccal and callers.</a>
<a name="ln3384">bool set_ref_in_previous_funccal(int copyID)</a>
<a name="ln3385">{</a>
<a name="ln3386">  bool abort = false;</a>
<a name="ln3387"> </a>
<a name="ln3388">  for (funccall_T *fc = previous_funccal; !abort &amp;&amp; fc != NULL;</a>
<a name="ln3389">       fc = fc-&gt;caller) {</a>
<a name="ln3390">    fc-&gt;fc_copyID = copyID + 1;</a>
<a name="ln3391">    abort = abort</a>
<a name="ln3392">      || set_ref_in_ht(&amp;fc-&gt;l_vars.dv_hashtab, copyID + 1, NULL)</a>
<a name="ln3393">      || set_ref_in_ht(&amp;fc-&gt;l_avars.dv_hashtab, copyID + 1, NULL)</a>
<a name="ln3394">      || set_ref_in_list(&amp;fc-&gt;l_varlist, copyID + 1, NULL);</a>
<a name="ln3395">  }</a>
<a name="ln3396">  return abort;</a>
<a name="ln3397">}</a>
<a name="ln3398"> </a>
<a name="ln3399">static bool set_ref_in_funccal(funccall_T *fc, int copyID)</a>
<a name="ln3400">{</a>
<a name="ln3401">  bool abort = false;</a>
<a name="ln3402"> </a>
<a name="ln3403">  if (fc-&gt;fc_copyID != copyID) {</a>
<a name="ln3404">    fc-&gt;fc_copyID = copyID;</a>
<a name="ln3405">    abort = abort</a>
<a name="ln3406">      || set_ref_in_ht(&amp;fc-&gt;l_vars.dv_hashtab, copyID, NULL)</a>
<a name="ln3407">      || set_ref_in_ht(&amp;fc-&gt;l_avars.dv_hashtab, copyID, NULL)</a>
<a name="ln3408">      || set_ref_in_list(&amp;fc-&gt;l_varlist, copyID, NULL)</a>
<a name="ln3409">      || set_ref_in_func(NULL, fc-&gt;func, copyID);</a>
<a name="ln3410">  }</a>
<a name="ln3411">  return abort;</a>
<a name="ln3412">}</a>
<a name="ln3413"> </a>
<a name="ln3414">/// Set &quot;copyID&quot; in all local vars and arguments in the call stack.</a>
<a name="ln3415">bool set_ref_in_call_stack(int copyID)</a>
<a name="ln3416">{</a>
<a name="ln3417">  bool abort = false;</a>
<a name="ln3418"> </a>
<a name="ln3419">  for (funccall_T *fc = current_funccal; !abort &amp;&amp; fc != NULL;</a>
<a name="ln3420">       fc = fc-&gt;caller) {</a>
<a name="ln3421">    abort = abort || set_ref_in_funccal(fc, copyID);</a>
<a name="ln3422">  }</a>
<a name="ln3423"> </a>
<a name="ln3424">  // Also go through the funccal_stack.</a>
<a name="ln3425">  for (funccal_entry_T *entry = funccal_stack; !abort &amp;&amp; entry != NULL;</a>
<a name="ln3426">       entry = entry-&gt;next) {</a>
<a name="ln3427">    for (funccall_T *fc = entry-&gt;top_funccal; !abort &amp;&amp; fc != NULL;</a>
<a name="ln3428">         fc = fc-&gt;caller) {</a>
<a name="ln3429">      abort = abort || set_ref_in_funccal(fc, copyID);</a>
<a name="ln3430">    }</a>
<a name="ln3431">  }</a>
<a name="ln3432"> </a>
<a name="ln3433">  return abort;</a>
<a name="ln3434">}</a>
<a name="ln3435"> </a>
<a name="ln3436">/// Set &quot;copyID&quot; in all functions available by name.</a>
<a name="ln3437">bool set_ref_in_functions(int copyID)</a>
<a name="ln3438">{</a>
<a name="ln3439">  int todo;</a>
<a name="ln3440">  hashitem_T *hi = NULL;</a>
<a name="ln3441">  bool abort = false;</a>
<a name="ln3442">  ufunc_T *fp;</a>
<a name="ln3443"> </a>
<a name="ln3444">  todo = (int)func_hashtab.ht_used;</a>
<a name="ln3445">  for (hi = func_hashtab.ht_array; todo &gt; 0 &amp;&amp; !got_int; hi++) {</a>
<a name="ln3446">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3447">      todo--;</a>
<a name="ln3448">      fp = HI2UF(hi);</a>
<a name="ln3449">      if (!func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln3450">        abort = abort || set_ref_in_func(NULL, fp, copyID);</a>
<a name="ln3451">      }</a>
<a name="ln3452">    }</a>
<a name="ln3453">  }</a>
<a name="ln3454">  return abort;</a>
<a name="ln3455">}</a>
<a name="ln3456"> </a>
<a name="ln3457">/// Set &quot;copyID&quot; in all function arguments.</a>
<a name="ln3458">bool set_ref_in_func_args(int copyID)</a>
<a name="ln3459">{</a>
<a name="ln3460">  bool abort = false;</a>
<a name="ln3461"> </a>
<a name="ln3462">  for (int i = 0; i &lt; funcargs.ga_len; i++) {</a>
<a name="ln3463">    abort = abort || set_ref_in_item(((typval_T **)funcargs.ga_data)[i],</a>
<a name="ln3464">                                     copyID, NULL, NULL);</a>
<a name="ln3465">  }</a>
<a name="ln3466">  return abort;</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469">/// Mark all lists and dicts referenced through function &quot;name&quot; with &quot;copyID&quot;.</a>
<a name="ln3470">/// &quot;list_stack&quot; is used to add lists to be marked.  Can be NULL.</a>
<a name="ln3471">/// &quot;ht_stack&quot; is used to add hashtabs to be marked.  Can be NULL.</a>
<a name="ln3472">///</a>
<a name="ln3473">/// @return true if setting references failed somehow.</a>
<a name="ln3474">bool set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)</a>
<a name="ln3475">{</a>
<a name="ln3476">  ufunc_T *fp = fp_in;</a>
<a name="ln3477">  funccall_T *fc;</a>
<a name="ln3478">  int error = ERROR_NONE;</a>
<a name="ln3479">  char_u fname_buf[FLEN_FIXED + 1];</a>
<a name="ln3480">  char_u *tofree = NULL;</a>
<a name="ln3481">  char_u *fname;</a>
<a name="ln3482">  bool abort = false;</a>
<a name="ln3483">  if (name == NULL &amp;&amp; fp_in == NULL) {</a>
<a name="ln3484">    return false;</a>
<a name="ln3485">  }</a>
<a name="ln3486"> </a>
<a name="ln3487">  if (fp_in == NULL) {</a>
<a name="ln3488">    fname = fname_trans_sid(name, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln3489">    fp = find_func(fname);</a>
<a name="ln3490">  }</a>
<a name="ln3491">  if (fp != NULL) {</a>
<a name="ln3492">    for (fc = fp-&gt;uf_scoped; fc != NULL; fc = fc-&gt;func-&gt;uf_scoped) {</a>
<a name="ln3493">      abort = abort || set_ref_in_funccal(fc, copyID);</a>
<a name="ln3494">    }</a>
<a name="ln3495">  }</a>
<a name="ln3496">  xfree(tofree);</a>
<a name="ln3497">  return abort;</a>
<a name="ln3498">}</a>
<a name="ln3499"> </a>
<a name="ln3500">/// Registers a C extension user function.</a>
<a name="ln3501">char_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)</a>
<a name="ln3502">{</a>
<a name="ln3503">  char_u *name = get_lambda_name();</a>
<a name="ln3504">  ufunc_T *fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);</a>
<a name="ln3505"> </a>
<a name="ln3506">  fp-&gt;uf_refcount = 1;</a>
<a name="ln3507">  fp-&gt;uf_varargs = true;</a>
<a name="ln3508">  fp-&gt;uf_flags = FC_CFUNC;</a>
<a name="ln3509">  fp-&gt;uf_calls = 0;</a>
<a name="ln3510">  fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln3511">  fp-&gt;uf_cb = cb;</a>
<a name="ln3512">  fp-&gt;uf_cb_free = cb_free;</a>
<a name="ln3513">  fp-&gt;uf_cb_state = state;</a>
<a name="ln3514"> </a>
<a name="ln3515">  STRCPY(fp-&gt;uf_name, name);</a>
<a name="ln3516">  hash_add(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln3517"> </a>
<a name="ln3518">  return fp-&gt;uf_name;</a>
<a name="ln3519">}</a>

</code></pre>
<div class="balloon" rel="3391"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: abort.</p></div>
<div class="balloon" rel="3421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: abort.</p></div>
<div class="balloon" rel="3429"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: abort.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
